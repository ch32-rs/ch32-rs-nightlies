//!Peripheral access API for CH569 microcontrollers (generated using svd2rust v0.31.5 ( ))
//!
//!You can find an overview of the generated API [here].
//!
//!API features to be included in the [next]
//!svd2rust release can be generated by cloning the svd2rust [repository], checking out the above commit, and running `cargo doc --open`.
//!
//![here]: https://docs.rs/svd2rust/0.31.5/svd2rust/#peripheral-api
//![next]: https://github.com/rust-embedded/svd2rust/blob/master/CHANGELOG.md#unreleased
//![repository]: https://github.com/rust-embedded/svd2rust
use core::marker::PhantomData;
use core::ops::Deref;
#[cfg(feature = "rt")]
extern "C" {}
#[doc(hidden)]
#[repr(C)]
pub union Vector {
    pub _handler: unsafe extern "C" fn(),
    pub _reserved: usize,
}
#[cfg(feature = "rt")]
#[doc(hidden)]
#[no_mangle]
pub static __EXTERNAL_INTERRUPTS: [Vector; 0] = [];
///SYS register
pub struct SYS {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for SYS {}
impl SYS {
    ///Pointer to the register block
    pub const PTR: *const sys::RegisterBlock = 0x4000_1000 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const sys::RegisterBlock {
        Self::PTR
    }
    /// Steal an instance of this peripheral
    ///
    /// # Safety
    ///
    /// Ensure that the new instance of the peripheral cannot be used in a way
    /// that may race with any existing instances, for example by only
    /// accessing read-only or write-only registers, or by consuming the
    /// original peripheral and using critical sections to coordinate
    /// access between multiple new instances.
    ///
    /// Additionally, other software such as HALs may rely on only one
    /// peripheral instance existing to ensure memory safety; ensure
    /// no stolen instances are passed to such software.
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for SYS {
    type Target = sys::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for SYS {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("SYS").finish()
    }
}
///SYS register
pub mod sys {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        safe_access_sig: SAFE_ACCESS_SIG,
        chip_id: CHIP_ID,
        safe_access_id: SAFE_ACCESS_ID,
        wdog_count: WDOG_COUNT,
        glob_rom_cfg: GLOB_ROM_CFG,
        rst_boot_stat: RST_BOOT_STAT,
        rst_wdog_ctrl: RST_WDOG_CTRL,
        glob_reset_keep: GLOB_RESET_KEEP,
        clk_pll_div: CLK_PLL_DIV,
        _reserved9: [u8; 0x01],
        clk_cfg_ctrl: CLK_CFG_CTRL,
        clk_mod_aux: CLK_MOD_AUX,
        slp_clk_off0: SLP_CLK_OFF0,
        slp_clk_off1: SLP_CLK_OFF1,
        slp_wake_ctrl: SLP_WAKE_CTRL,
        slp_power_ctrl: SLP_POWER_CTRL,
        _reserved15: [u8; 0x10],
        serd_ana_cfg1: SERD_ANA_CFG1,
        _reserved16: [u8; 0x02],
        serd_ana_cfg2: SERD_ANA_CFG2,
    }
    impl RegisterBlock {
        ///0x00 - safe accessing sign register
        #[inline(always)]
        pub const fn safe_access_sig(&self) -> &SAFE_ACCESS_SIG {
            &self.safe_access_sig
        }
        ///0x01 - chip ID register
        #[inline(always)]
        pub const fn chip_id(&self) -> &CHIP_ID {
            &self.chip_id
        }
        ///0x02 - safe accessing ID register
        #[inline(always)]
        pub const fn safe_access_id(&self) -> &SAFE_ACCESS_ID {
            &self.safe_access_id
        }
        ///0x03 - watch-dog count register
        #[inline(always)]
        pub const fn wdog_count(&self) -> &WDOG_COUNT {
            &self.wdog_count
        }
        ///0x04 - flash ROM configuration register
        #[inline(always)]
        pub const fn glob_rom_cfg(&self) -> &GLOB_ROM_CFG {
            &self.glob_rom_cfg
        }
        ///0x05 - reset status and boot/debug status
        #[inline(always)]
        pub const fn rst_boot_stat(&self) -> &RST_BOOT_STAT {
            &self.rst_boot_stat
        }
        ///0x06 - reset and watch-dog control
        #[inline(always)]
        pub const fn rst_wdog_ctrl(&self) -> &RST_WDOG_CTRL {
            &self.rst_wdog_ctrl
        }
        ///0x07 - value keeper during global reset
        #[inline(always)]
        pub const fn glob_reset_keep(&self) -> &GLOB_RESET_KEEP {
            &self.glob_reset_keep
        }
        ///0x08 - output clock divider from PLL
        #[inline(always)]
        pub const fn clk_pll_div(&self) -> &CLK_PLL_DIV {
            &self.clk_pll_div
        }
        ///0x0a - clock control
        #[inline(always)]
        pub const fn clk_cfg_ctrl(&self) -> &CLK_CFG_CTRL {
            &self.clk_cfg_ctrl
        }
        ///0x0b - clock mode aux register
        #[inline(always)]
        pub const fn clk_mod_aux(&self) -> &CLK_MOD_AUX {
            &self.clk_mod_aux
        }
        ///0x0c - sleep clock off control byte 0
        #[inline(always)]
        pub const fn slp_clk_off0(&self) -> &SLP_CLK_OFF0 {
            &self.slp_clk_off0
        }
        ///0x0d - sleep clock off control byte 1
        #[inline(always)]
        pub const fn slp_clk_off1(&self) -> &SLP_CLK_OFF1 {
            &self.slp_clk_off1
        }
        ///0x0e - wake control
        #[inline(always)]
        pub const fn slp_wake_ctrl(&self) -> &SLP_WAKE_CTRL {
            &self.slp_wake_ctrl
        }
        ///0x0f - power control
        #[inline(always)]
        pub const fn slp_power_ctrl(&self) -> &SLP_POWER_CTRL {
            &self.slp_power_ctrl
        }
        ///0x20 - Serdes Analog parameter configuration1
        #[inline(always)]
        pub const fn serd_ana_cfg1(&self) -> &SERD_ANA_CFG1 {
            &self.serd_ana_cfg1
        }
        ///0x24 - Serdes Analog parameter configuration2
        #[inline(always)]
        pub const fn serd_ana_cfg2(&self) -> &SERD_ANA_CFG2 {
            &self.serd_ana_cfg2
        }
    }
    ///SAFE_ACCESS_SIG (rw) register accessor: safe accessing sign register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`safe_access_sig::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`safe_access_sig::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@safe_access_sig`]
    ///module
    pub type SAFE_ACCESS_SIG = crate::Reg<safe_access_sig::SAFE_ACCESS_SIG_SPEC>;
    ///safe accessing sign register
    pub mod safe_access_sig {
        ///Register `SAFE_ACCESS_SIG` reader
        pub type R = crate::R<SAFE_ACCESS_SIG_SPEC>;
        ///Register `SAFE_ACCESS_SIG` writer
        pub type W = crate::W<SAFE_ACCESS_SIG_SPEC>;
        ///Field `SAFE_ACC_MODE` reader - current safe accessing mode
        pub type SAFE_ACC_MODE_R = crate::FieldReader;
        ///Field `SAFE_ACC_MODE` writer - current safe accessing mode
        pub type SAFE_ACC_MODE_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `SAFE_ACC_TIMER` reader - safe accessing timer bit mask
        pub type SAFE_ACC_TIMER_R = crate::FieldReader;
        ///Field `SAFE_ACC_TIMER` writer - safe accessing timer bit mask
        pub type SAFE_ACC_TIMER_W<'a, REG> = crate::FieldWriter<'a, REG, 3>;
        impl R {
            ///Bits 0:1 - current safe accessing mode
            #[inline(always)]
            pub fn safe_acc_mode(&self) -> SAFE_ACC_MODE_R {
                SAFE_ACC_MODE_R::new(self.bits & 3)
            }
            ///Bits 4:6 - safe accessing timer bit mask
            #[inline(always)]
            pub fn safe_acc_timer(&self) -> SAFE_ACC_TIMER_R {
                SAFE_ACC_TIMER_R::new((self.bits >> 4) & 7)
            }
        }
        impl W {
            ///Bits 0:1 - current safe accessing mode
            #[inline(always)]
            #[must_use]
            pub fn safe_acc_mode(&mut self) -> SAFE_ACC_MODE_W<SAFE_ACCESS_SIG_SPEC> {
                SAFE_ACC_MODE_W::new(self, 0)
            }
            ///Bits 4:6 - safe accessing timer bit mask
            #[inline(always)]
            #[must_use]
            pub fn safe_acc_timer(&mut self) -> SAFE_ACC_TIMER_W<SAFE_ACCESS_SIG_SPEC> {
                SAFE_ACC_TIMER_W::new(self, 4)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///safe accessing sign register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`safe_access_sig::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`safe_access_sig::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct SAFE_ACCESS_SIG_SPEC;
        impl crate::RegisterSpec for SAFE_ACCESS_SIG_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`safe_access_sig::R`](R) reader structure
        impl crate::Readable for SAFE_ACCESS_SIG_SPEC {}
        ///`write(|w| ..)` method takes [`safe_access_sig::W`](W) writer structure
        impl crate::Writable for SAFE_ACCESS_SIG_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets SAFE_ACCESS_SIG to value 0
        impl crate::Resettable for SAFE_ACCESS_SIG_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///CHIP_ID (r) register accessor: chip ID register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`chip_id::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@chip_id`]
    ///module
    pub type CHIP_ID = crate::Reg<chip_id::CHIP_ID_SPEC>;
    ///chip ID register
    pub mod chip_id {
        ///Register `CHIP_ID` reader
        pub type R = crate::R<CHIP_ID_SPEC>;
        ///Field `CHIP_ID` reader - chip ID
        pub type CHIP_ID_R = crate::FieldReader;
        impl R {
            ///Bits 0:7 - chip ID
            #[inline(always)]
            pub fn chip_id(&self) -> CHIP_ID_R {
                CHIP_ID_R::new(self.bits)
            }
        }
        ///chip ID register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`chip_id::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct CHIP_ID_SPEC;
        impl crate::RegisterSpec for CHIP_ID_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`chip_id::R`](R) reader structure
        impl crate::Readable for CHIP_ID_SPEC {}
        ///`reset()` method sets CHIP_ID to value 0x69
        impl crate::Resettable for CHIP_ID_SPEC {
            const RESET_VALUE: u8 = 0x69;
        }
    }
    ///SAFE_ACCESS_ID (r) register accessor: safe accessing ID register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`safe_access_id::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@safe_access_id`]
    ///module
    pub type SAFE_ACCESS_ID = crate::Reg<safe_access_id::SAFE_ACCESS_ID_SPEC>;
    ///safe accessing ID register
    pub mod safe_access_id {
        ///Register `SAFE_ACCESS_ID` reader
        pub type R = crate::R<SAFE_ACCESS_ID_SPEC>;
        ///Field `SAFE_ACCESS_ID` reader - safe accessing ID
        pub type SAFE_ACCESS_ID_R = crate::FieldReader;
        impl R {
            ///Bits 0:7 - safe accessing ID
            #[inline(always)]
            pub fn safe_access_id(&self) -> SAFE_ACCESS_ID_R {
                SAFE_ACCESS_ID_R::new(self.bits)
            }
        }
        ///safe accessing ID register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`safe_access_id::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct SAFE_ACCESS_ID_SPEC;
        impl crate::RegisterSpec for SAFE_ACCESS_ID_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`safe_access_id::R`](R) reader structure
        impl crate::Readable for SAFE_ACCESS_ID_SPEC {}
        ///`reset()` method sets SAFE_ACCESS_ID to value 0x02
        impl crate::Resettable for SAFE_ACCESS_ID_SPEC {
            const RESET_VALUE: u8 = 0x02;
        }
    }
    ///WDOG_COUNT (rw) register accessor: watch-dog count register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`wdog_count::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`wdog_count::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@wdog_count`]
    ///module
    pub type WDOG_COUNT = crate::Reg<wdog_count::WDOG_COUNT_SPEC>;
    ///watch-dog count register
    pub mod wdog_count {
        ///Register `WDOG_COUNT` reader
        pub type R = crate::R<WDOG_COUNT_SPEC>;
        ///Register `WDOG_COUNT` writer
        pub type W = crate::W<WDOG_COUNT_SPEC>;
        ///Field `WDOG_COUNT` reader - watch-dog count
        pub type WDOG_COUNT_R = crate::FieldReader;
        ///Field `WDOG_COUNT` writer - watch-dog count
        pub type WDOG_COUNT_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            ///Bits 0:7 - watch-dog count
            #[inline(always)]
            pub fn wdog_count(&self) -> WDOG_COUNT_R {
                WDOG_COUNT_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:7 - watch-dog count
            #[inline(always)]
            #[must_use]
            pub fn wdog_count(&mut self) -> WDOG_COUNT_W<WDOG_COUNT_SPEC> {
                WDOG_COUNT_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///watch-dog count register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`wdog_count::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`wdog_count::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct WDOG_COUNT_SPEC;
        impl crate::RegisterSpec for WDOG_COUNT_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`wdog_count::R`](R) reader structure
        impl crate::Readable for WDOG_COUNT_SPEC {}
        ///`write(|w| ..)` method takes [`wdog_count::W`](W) writer structure
        impl crate::Writable for WDOG_COUNT_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets WDOG_COUNT to value 0
        impl crate::Resettable for WDOG_COUNT_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///GLOB_ROM_CFG (rw) register accessor: flash ROM configuration register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`glob_rom_cfg::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`glob_rom_cfg::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@glob_rom_cfg`]
    ///module
    pub type GLOB_ROM_CFG = crate::Reg<glob_rom_cfg::GLOB_ROM_CFG_SPEC>;
    ///flash ROM configuration register
    pub mod glob_rom_cfg {
        ///Register `GLOB_ROM_CFG` reader
        pub type R = crate::R<GLOB_ROM_CFG_SPEC>;
        ///Register `GLOB_ROM_CFG` writer
        pub type W = crate::W<GLOB_ROM_CFG_SPEC>;
        ///Field `ROM_EXT_RE` reader - enable flash ROM being read by external programmer
        pub type ROM_EXT_RE_R = crate::BitReader;
        ///Field `ROM_EXT_RE` writer - enable flash ROM being read by external programmer
        pub type ROM_EXT_RE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CODE_RAM_WE` reader - enable code RAM being write
        pub type CODE_RAM_WE_R = crate::BitReader;
        ///Field `CODE_RAM_WE` writer - enable code RAM being write
        pub type CODE_RAM_WE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `ROM_DATA_WE` reader - enable flash ROM data area being erase/write
        pub type ROM_DATA_WE_R = crate::BitReader;
        ///Field `ROM_DATA_WE` writer - enable flash ROM data area being erase/write
        pub type ROM_DATA_WE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `ROM_CODE_WE` reader - enable flash ROM code and data area being erase or write
        pub type ROM_CODE_WE_R = crate::BitReader;
        ///Field `ROM_CODE_WE` writer - enable flash ROM code and data area being erase or write
        pub type ROM_CODE_WE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `ROM_CODE_OFS` reader - Config the start offset address of user code in Flash
        pub type ROM_CODE_OFS_R = crate::BitReader;
        ///Field `ROM_CODE_OFS` writer - Config the start offset address of user code in Flash
        pub type ROM_CODE_OFS_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - enable flash ROM being read by external programmer
            #[inline(always)]
            pub fn rom_ext_re(&self) -> ROM_EXT_RE_R {
                ROM_EXT_RE_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - enable code RAM being write
            #[inline(always)]
            pub fn code_ram_we(&self) -> CODE_RAM_WE_R {
                CODE_RAM_WE_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - enable flash ROM data area being erase/write
            #[inline(always)]
            pub fn rom_data_we(&self) -> ROM_DATA_WE_R {
                ROM_DATA_WE_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - enable flash ROM code and data area being erase or write
            #[inline(always)]
            pub fn rom_code_we(&self) -> ROM_CODE_WE_R {
                ROM_CODE_WE_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - Config the start offset address of user code in Flash
            #[inline(always)]
            pub fn rom_code_ofs(&self) -> ROM_CODE_OFS_R {
                ROM_CODE_OFS_R::new(((self.bits >> 4) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - enable flash ROM being read by external programmer
            #[inline(always)]
            #[must_use]
            pub fn rom_ext_re(&mut self) -> ROM_EXT_RE_W<GLOB_ROM_CFG_SPEC> {
                ROM_EXT_RE_W::new(self, 0)
            }
            ///Bit 1 - enable code RAM being write
            #[inline(always)]
            #[must_use]
            pub fn code_ram_we(&mut self) -> CODE_RAM_WE_W<GLOB_ROM_CFG_SPEC> {
                CODE_RAM_WE_W::new(self, 1)
            }
            ///Bit 2 - enable flash ROM data area being erase/write
            #[inline(always)]
            #[must_use]
            pub fn rom_data_we(&mut self) -> ROM_DATA_WE_W<GLOB_ROM_CFG_SPEC> {
                ROM_DATA_WE_W::new(self, 2)
            }
            ///Bit 3 - enable flash ROM code and data area being erase or write
            #[inline(always)]
            #[must_use]
            pub fn rom_code_we(&mut self) -> ROM_CODE_WE_W<GLOB_ROM_CFG_SPEC> {
                ROM_CODE_WE_W::new(self, 3)
            }
            ///Bit 4 - Config the start offset address of user code in Flash
            #[inline(always)]
            #[must_use]
            pub fn rom_code_ofs(&mut self) -> ROM_CODE_OFS_W<GLOB_ROM_CFG_SPEC> {
                ROM_CODE_OFS_W::new(self, 4)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///flash ROM configuration register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`glob_rom_cfg::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`glob_rom_cfg::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct GLOB_ROM_CFG_SPEC;
        impl crate::RegisterSpec for GLOB_ROM_CFG_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`glob_rom_cfg::R`](R) reader structure
        impl crate::Readable for GLOB_ROM_CFG_SPEC {}
        ///`write(|w| ..)` method takes [`glob_rom_cfg::W`](W) writer structure
        impl crate::Writable for GLOB_ROM_CFG_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets GLOB_ROM_CFG to value 0x80
        impl crate::Resettable for GLOB_ROM_CFG_SPEC {
            const RESET_VALUE: u8 = 0x80;
        }
    }
    ///RST_BOOT_STAT (r) register accessor: reset status and boot/debug status
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`rst_boot_stat::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@rst_boot_stat`]
    ///module
    pub type RST_BOOT_STAT = crate::Reg<rst_boot_stat::RST_BOOT_STAT_SPEC>;
    ///reset status and boot/debug status
    pub mod rst_boot_stat {
        ///Register `RST_BOOT_STAT` reader
        pub type R = crate::R<RST_BOOT_STAT_SPEC>;
        ///Field `RESET_FLAG` reader - recent reset flag
        pub type RESET_FLAG_R = crate::FieldReader;
        ///Field `CFG_RESET_EN` reader - manual reset input enable status
        pub type CFG_RESET_EN_R = crate::BitReader;
        ///Field `CFG_BOOT_EN` reader - boot-loader enable status
        pub type CFG_BOOT_EN_R = crate::BitReader;
        ///Field `CFG_DEBUG_EN` reader - debug enable status
        pub type CFG_DEBUG_EN_R = crate::BitReader;
        ///Field `BOOT_LOADER` reader - indicate boot loader status
        pub type BOOT_LOADER_R = crate::BitReader;
        impl R {
            ///Bits 0:1 - recent reset flag
            #[inline(always)]
            pub fn reset_flag(&self) -> RESET_FLAG_R {
                RESET_FLAG_R::new(self.bits & 3)
            }
            ///Bit 2 - manual reset input enable status
            #[inline(always)]
            pub fn cfg_reset_en(&self) -> CFG_RESET_EN_R {
                CFG_RESET_EN_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - boot-loader enable status
            #[inline(always)]
            pub fn cfg_boot_en(&self) -> CFG_BOOT_EN_R {
                CFG_BOOT_EN_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - debug enable status
            #[inline(always)]
            pub fn cfg_debug_en(&self) -> CFG_DEBUG_EN_R {
                CFG_DEBUG_EN_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - indicate boot loader status
            #[inline(always)]
            pub fn boot_loader(&self) -> BOOT_LOADER_R {
                BOOT_LOADER_R::new(((self.bits >> 5) & 1) != 0)
            }
        }
        ///reset status and boot/debug status
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`rst_boot_stat::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct RST_BOOT_STAT_SPEC;
        impl crate::RegisterSpec for RST_BOOT_STAT_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`rst_boot_stat::R`](R) reader structure
        impl crate::Readable for RST_BOOT_STAT_SPEC {}
        ///`reset()` method sets RST_BOOT_STAT to value 0xc8
        impl crate::Resettable for RST_BOOT_STAT_SPEC {
            const RESET_VALUE: u8 = 0xc8;
        }
    }
    ///RST_WDOG_CTRL (rw) register accessor: reset and watch-dog control
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`rst_wdog_ctrl::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`rst_wdog_ctrl::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@rst_wdog_ctrl`]
    ///module
    pub type RST_WDOG_CTRL = crate::Reg<rst_wdog_ctrl::RST_WDOG_CTRL_SPEC>;
    ///reset and watch-dog control
    pub mod rst_wdog_ctrl {
        ///Register `RST_WDOG_CTRL` reader
        pub type R = crate::R<RST_WDOG_CTRL_SPEC>;
        ///Register `RST_WDOG_CTRL` writer
        pub type W = crate::W<RST_WDOG_CTRL_SPEC>;
        ///Field `SOFTWARE_RESET` reader - global software reset
        pub type SOFTWARE_RESET_R = crate::BitReader;
        ///Field `SOFTWARE_RESET` writer - global software reset
        pub type SOFTWARE_RESET_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `WDOG_RST_EN` reader - enable watch-dog reset if watch-dog timer overflow: 0=as timer only, 1=enable reset if timer overflow
        pub type WDOG_RST_EN_R = crate::BitReader;
        ///Field `WDOG_RST_EN` writer - enable watch-dog reset if watch-dog timer overflow: 0=as timer only, 1=enable reset if timer overflow
        pub type WDOG_RST_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `WDOG_INT_EN` reader - watch-dog interrupt enable or INT_ID_WDOG interrupt source selection: 0=software interrupt
        pub type WDOG_INT_EN_R = crate::BitReader;
        ///Field `WDOG_INT_EN` writer - watch-dog interrupt enable or INT_ID_WDOG interrupt source selection: 0=software interrupt
        pub type WDOG_INT_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `WDOG_INT_FLAG` reader - watch-dog timer overflow interrupt flag
        pub type WDOG_INT_FLAG_R = crate::BitReader;
        ///Field `WDOG_INT_FLAG` writer - watch-dog timer overflow interrupt flag
        pub type WDOG_INT_FLAG_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - global software reset
            #[inline(always)]
            pub fn software_reset(&self) -> SOFTWARE_RESET_R {
                SOFTWARE_RESET_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - enable watch-dog reset if watch-dog timer overflow: 0=as timer only, 1=enable reset if timer overflow
            #[inline(always)]
            pub fn wdog_rst_en(&self) -> WDOG_RST_EN_R {
                WDOG_RST_EN_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - watch-dog interrupt enable or INT_ID_WDOG interrupt source selection: 0=software interrupt
            #[inline(always)]
            pub fn wdog_int_en(&self) -> WDOG_INT_EN_R {
                WDOG_INT_EN_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - watch-dog timer overflow interrupt flag
            #[inline(always)]
            pub fn wdog_int_flag(&self) -> WDOG_INT_FLAG_R {
                WDOG_INT_FLAG_R::new(((self.bits >> 3) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - global software reset
            #[inline(always)]
            #[must_use]
            pub fn software_reset(&mut self) -> SOFTWARE_RESET_W<RST_WDOG_CTRL_SPEC> {
                SOFTWARE_RESET_W::new(self, 0)
            }
            ///Bit 1 - enable watch-dog reset if watch-dog timer overflow: 0=as timer only, 1=enable reset if timer overflow
            #[inline(always)]
            #[must_use]
            pub fn wdog_rst_en(&mut self) -> WDOG_RST_EN_W<RST_WDOG_CTRL_SPEC> {
                WDOG_RST_EN_W::new(self, 1)
            }
            ///Bit 2 - watch-dog interrupt enable or INT_ID_WDOG interrupt source selection: 0=software interrupt
            #[inline(always)]
            #[must_use]
            pub fn wdog_int_en(&mut self) -> WDOG_INT_EN_W<RST_WDOG_CTRL_SPEC> {
                WDOG_INT_EN_W::new(self, 2)
            }
            ///Bit 3 - watch-dog timer overflow interrupt flag
            #[inline(always)]
            #[must_use]
            pub fn wdog_int_flag(&mut self) -> WDOG_INT_FLAG_W<RST_WDOG_CTRL_SPEC> {
                WDOG_INT_FLAG_W::new(self, 3)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///reset and watch-dog control
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`rst_wdog_ctrl::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`rst_wdog_ctrl::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct RST_WDOG_CTRL_SPEC;
        impl crate::RegisterSpec for RST_WDOG_CTRL_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`rst_wdog_ctrl::R`](R) reader structure
        impl crate::Readable for RST_WDOG_CTRL_SPEC {}
        ///`write(|w| ..)` method takes [`rst_wdog_ctrl::W`](W) writer structure
        impl crate::Writable for RST_WDOG_CTRL_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets RST_WDOG_CTRL to value 0
        impl crate::Resettable for RST_WDOG_CTRL_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///GLOB_RESET_KEEP (rw) register accessor: value keeper during global reset
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`glob_reset_keep::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`glob_reset_keep::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@glob_reset_keep`]
    ///module
    pub type GLOB_RESET_KEEP = crate::Reg<glob_reset_keep::GLOB_RESET_KEEP_SPEC>;
    ///value keeper during global reset
    pub mod glob_reset_keep {
        ///Register `GLOB_RESET_KEEP` reader
        pub type R = crate::R<GLOB_RESET_KEEP_SPEC>;
        ///Register `GLOB_RESET_KEEP` writer
        pub type W = crate::W<GLOB_RESET_KEEP_SPEC>;
        ///Field `GLOB_RESET_KEEP` reader - value keeper during global reset
        pub type GLOB_RESET_KEEP_R = crate::FieldReader;
        ///Field `GLOB_RESET_KEEP` writer - value keeper during global reset
        pub type GLOB_RESET_KEEP_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            ///Bits 0:7 - value keeper during global reset
            #[inline(always)]
            pub fn glob_reset_keep(&self) -> GLOB_RESET_KEEP_R {
                GLOB_RESET_KEEP_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:7 - value keeper during global reset
            #[inline(always)]
            #[must_use]
            pub fn glob_reset_keep(&mut self) -> GLOB_RESET_KEEP_W<GLOB_RESET_KEEP_SPEC> {
                GLOB_RESET_KEEP_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///value keeper during global reset
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`glob_reset_keep::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`glob_reset_keep::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct GLOB_RESET_KEEP_SPEC;
        impl crate::RegisterSpec for GLOB_RESET_KEEP_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`glob_reset_keep::R`](R) reader structure
        impl crate::Readable for GLOB_RESET_KEEP_SPEC {}
        ///`write(|w| ..)` method takes [`glob_reset_keep::W`](W) writer structure
        impl crate::Writable for GLOB_RESET_KEEP_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets GLOB_RESET_KEEP to value 0
        impl crate::Resettable for GLOB_RESET_KEEP_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///CLK_PLL_DIV (rw) register accessor: output clock divider from PLL
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`clk_pll_div::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`clk_pll_div::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@clk_pll_div`]
    ///module
    pub type CLK_PLL_DIV = crate::Reg<clk_pll_div::CLK_PLL_DIV_SPEC>;
    ///output clock divider from PLL
    pub mod clk_pll_div {
        ///Register `CLK_PLL_DIV` reader
        pub type R = crate::R<CLK_PLL_DIV_SPEC>;
        ///Register `CLK_PLL_DIV` writer
        pub type W = crate::W<CLK_PLL_DIV_SPEC>;
        ///Field `CLK_PLL_DIV` reader - output clock divider from PLL
        pub type CLK_PLL_DIV_R = crate::FieldReader;
        ///Field `CLK_PLL_DIV` writer - output clock divider from PLL
        pub type CLK_PLL_DIV_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            ///Bits 0:7 - output clock divider from PLL
            #[inline(always)]
            pub fn clk_pll_div(&self) -> CLK_PLL_DIV_R {
                CLK_PLL_DIV_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:7 - output clock divider from PLL
            #[inline(always)]
            #[must_use]
            pub fn clk_pll_div(&mut self) -> CLK_PLL_DIV_W<CLK_PLL_DIV_SPEC> {
                CLK_PLL_DIV_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///output clock divider from PLL
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`clk_pll_div::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`clk_pll_div::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct CLK_PLL_DIV_SPEC;
        impl crate::RegisterSpec for CLK_PLL_DIV_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`clk_pll_div::R`](R) reader structure
        impl crate::Readable for CLK_PLL_DIV_SPEC {}
        ///`write(|w| ..)` method takes [`clk_pll_div::W`](W) writer structure
        impl crate::Writable for CLK_PLL_DIV_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets CLK_PLL_DIV to value 0x42
        impl crate::Resettable for CLK_PLL_DIV_SPEC {
            const RESET_VALUE: u8 = 0x42;
        }
    }
    ///CLK_CFG_CTRL (rw) register accessor: clock control
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`clk_cfg_ctrl::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`clk_cfg_ctrl::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@clk_cfg_ctrl`]
    ///module
    pub type CLK_CFG_CTRL = crate::Reg<clk_cfg_ctrl::CLK_CFG_CTRL_SPEC>;
    ///clock control
    pub mod clk_cfg_ctrl {
        ///Register `CLK_CFG_CTRL` reader
        pub type R = crate::R<CLK_CFG_CTRL_SPEC>;
        ///Register `CLK_CFG_CTRL` writer
        pub type W = crate::W<CLK_CFG_CTRL_SPEC>;
        ///Field `CLK_PLL_SLEEP` reader - PLL sleep control
        pub type CLK_PLL_SLEEP_R = crate::BitReader;
        ///Field `CLK_PLL_SLEEP` writer - PLL sleep control
        pub type CLK_PLL_SLEEP_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CLK_SEL_PLL` reader - clock source selection
        pub type CLK_SEL_PLL_R = crate::BitReader;
        ///Field `CLK_SEL_PLL` writer - clock source selection
        pub type CLK_SEL_PLL_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - PLL sleep control
            #[inline(always)]
            pub fn clk_pll_sleep(&self) -> CLK_PLL_SLEEP_R {
                CLK_PLL_SLEEP_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - clock source selection
            #[inline(always)]
            pub fn clk_sel_pll(&self) -> CLK_SEL_PLL_R {
                CLK_SEL_PLL_R::new(((self.bits >> 1) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - PLL sleep control
            #[inline(always)]
            #[must_use]
            pub fn clk_pll_sleep(&mut self) -> CLK_PLL_SLEEP_W<CLK_CFG_CTRL_SPEC> {
                CLK_PLL_SLEEP_W::new(self, 0)
            }
            ///Bit 1 - clock source selection
            #[inline(always)]
            #[must_use]
            pub fn clk_sel_pll(&mut self) -> CLK_SEL_PLL_W<CLK_CFG_CTRL_SPEC> {
                CLK_SEL_PLL_W::new(self, 1)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///clock control
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`clk_cfg_ctrl::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`clk_cfg_ctrl::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct CLK_CFG_CTRL_SPEC;
        impl crate::RegisterSpec for CLK_CFG_CTRL_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`clk_cfg_ctrl::R`](R) reader structure
        impl crate::Readable for CLK_CFG_CTRL_SPEC {}
        ///`write(|w| ..)` method takes [`clk_cfg_ctrl::W`](W) writer structure
        impl crate::Writable for CLK_CFG_CTRL_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets CLK_CFG_CTRL to value 0x80
        impl crate::Resettable for CLK_CFG_CTRL_SPEC {
            const RESET_VALUE: u8 = 0x80;
        }
    }
    ///CLK_MOD_AUX (rw) register accessor: clock mode aux register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`clk_mod_aux::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`clk_mod_aux::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@clk_mod_aux`]
    ///module
    pub type CLK_MOD_AUX = crate::Reg<clk_mod_aux::CLK_MOD_AUX_SPEC>;
    ///clock mode aux register
    pub mod clk_mod_aux {
        ///Register `CLK_MOD_AUX` reader
        pub type R = crate::R<CLK_MOD_AUX_SPEC>;
        ///Register `CLK_MOD_AUX` writer
        pub type W = crate::W<CLK_MOD_AUX_SPEC>;
        ///Field `INT_125M_EN` reader - clock from USB_PHY PCLK(125MHz)
        pub type INT_125M_EN_R = crate::BitReader;
        ///Field `INT_125M_EN` writer - clock from USB_PHY PCLK(125MHz)
        pub type INT_125M_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `EXT_125M_EN` reader - clock from pin_PA\[16\]
        pub type EXT_125M_EN_R = crate::BitReader;
        ///Field `EXT_125M_EN` writer - clock from pin_PA\[16\]
        pub type EXT_125M_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `MCO_SEL_MSK` reader - MCO output selection
        pub type MCO_SEL_MSK_R = crate::FieldReader;
        ///Field `MCO_SEL_MSK` writer - MCO output selection
        pub type MCO_SEL_MSK_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `MCO_EN` reader - MCO output enable
        pub type MCO_EN_R = crate::BitReader;
        ///Field `MCO_EN` writer - MCO output enable
        pub type MCO_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - clock from USB_PHY PCLK(125MHz)
            #[inline(always)]
            pub fn int_125m_en(&self) -> INT_125M_EN_R {
                INT_125M_EN_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - clock from pin_PA\[16\]
            #[inline(always)]
            pub fn ext_125m_en(&self) -> EXT_125M_EN_R {
                EXT_125M_EN_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bits 2:3 - MCO output selection
            #[inline(always)]
            pub fn mco_sel_msk(&self) -> MCO_SEL_MSK_R {
                MCO_SEL_MSK_R::new((self.bits >> 2) & 3)
            }
            ///Bit 4 - MCO output enable
            #[inline(always)]
            pub fn mco_en(&self) -> MCO_EN_R {
                MCO_EN_R::new(((self.bits >> 4) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - clock from USB_PHY PCLK(125MHz)
            #[inline(always)]
            #[must_use]
            pub fn int_125m_en(&mut self) -> INT_125M_EN_W<CLK_MOD_AUX_SPEC> {
                INT_125M_EN_W::new(self, 0)
            }
            ///Bit 1 - clock from pin_PA\[16\]
            #[inline(always)]
            #[must_use]
            pub fn ext_125m_en(&mut self) -> EXT_125M_EN_W<CLK_MOD_AUX_SPEC> {
                EXT_125M_EN_W::new(self, 1)
            }
            ///Bits 2:3 - MCO output selection
            #[inline(always)]
            #[must_use]
            pub fn mco_sel_msk(&mut self) -> MCO_SEL_MSK_W<CLK_MOD_AUX_SPEC> {
                MCO_SEL_MSK_W::new(self, 2)
            }
            ///Bit 4 - MCO output enable
            #[inline(always)]
            #[must_use]
            pub fn mco_en(&mut self) -> MCO_EN_W<CLK_MOD_AUX_SPEC> {
                MCO_EN_W::new(self, 4)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///clock mode aux register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`clk_mod_aux::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`clk_mod_aux::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct CLK_MOD_AUX_SPEC;
        impl crate::RegisterSpec for CLK_MOD_AUX_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`clk_mod_aux::R`](R) reader structure
        impl crate::Readable for CLK_MOD_AUX_SPEC {}
        ///`write(|w| ..)` method takes [`clk_mod_aux::W`](W) writer structure
        impl crate::Writable for CLK_MOD_AUX_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets CLK_MOD_AUX to value 0
        impl crate::Resettable for CLK_MOD_AUX_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///SLP_CLK_OFF0 (rw) register accessor: sleep clock off control byte 0
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`slp_clk_off0::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`slp_clk_off0::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@slp_clk_off0`]
    ///module
    pub type SLP_CLK_OFF0 = crate::Reg<slp_clk_off0::SLP_CLK_OFF0_SPEC>;
    ///sleep clock off control byte 0
    pub mod slp_clk_off0 {
        ///Register `SLP_CLK_OFF0` reader
        pub type R = crate::R<SLP_CLK_OFF0_SPEC>;
        ///Register `SLP_CLK_OFF0` writer
        pub type W = crate::W<SLP_CLK_OFF0_SPEC>;
        ///Field `SLP_CLK_TMR0` reader - sleep TMR0 clock
        pub type SLP_CLK_TMR0_R = crate::BitReader;
        ///Field `SLP_CLK_TMR0` writer - sleep TMR0 clock
        pub type SLP_CLK_TMR0_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `SLP_CLK_TMR1` reader - sleep TMR1 clock
        pub type SLP_CLK_TMR1_R = crate::BitReader;
        ///Field `SLP_CLK_TMR1` writer - sleep TMR1 clock
        pub type SLP_CLK_TMR1_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `SLP_CLK_TMR2` reader - sleep TMR2 clock
        pub type SLP_CLK_TMR2_R = crate::BitReader;
        ///Field `SLP_CLK_TMR2` writer - sleep TMR2 clock
        pub type SLP_CLK_TMR2_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `SLP_CLK_PWMX` reader - sleep PWMX clock
        pub type SLP_CLK_PWMX_R = crate::BitReader;
        ///Field `SLP_CLK_PWMX` writer - sleep PWMX clock
        pub type SLP_CLK_PWMX_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `SLP_CLK_UART0` reader - sleep UART0 clock
        pub type SLP_CLK_UART0_R = crate::BitReader;
        ///Field `SLP_CLK_UART0` writer - sleep UART0 clock
        pub type SLP_CLK_UART0_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `SLP_CLK_UART1` reader - sleep UART1 clock
        pub type SLP_CLK_UART1_R = crate::BitReader;
        ///Field `SLP_CLK_UART1` writer - sleep UART1 clock
        pub type SLP_CLK_UART1_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `SLP_CLK_UART2` reader - sleep UART2 clock
        pub type SLP_CLK_UART2_R = crate::BitReader;
        ///Field `SLP_CLK_UART2` writer - sleep UART2 clock
        pub type SLP_CLK_UART2_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `SLP_CLK_UART3` reader - sleep UART3 clock
        pub type SLP_CLK_UART3_R = crate::BitReader;
        ///Field `SLP_CLK_UART3` writer - sleep UART3 clock
        pub type SLP_CLK_UART3_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - sleep TMR0 clock
            #[inline(always)]
            pub fn slp_clk_tmr0(&self) -> SLP_CLK_TMR0_R {
                SLP_CLK_TMR0_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - sleep TMR1 clock
            #[inline(always)]
            pub fn slp_clk_tmr1(&self) -> SLP_CLK_TMR1_R {
                SLP_CLK_TMR1_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - sleep TMR2 clock
            #[inline(always)]
            pub fn slp_clk_tmr2(&self) -> SLP_CLK_TMR2_R {
                SLP_CLK_TMR2_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - sleep PWMX clock
            #[inline(always)]
            pub fn slp_clk_pwmx(&self) -> SLP_CLK_PWMX_R {
                SLP_CLK_PWMX_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - sleep UART0 clock
            #[inline(always)]
            pub fn slp_clk_uart0(&self) -> SLP_CLK_UART0_R {
                SLP_CLK_UART0_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - sleep UART1 clock
            #[inline(always)]
            pub fn slp_clk_uart1(&self) -> SLP_CLK_UART1_R {
                SLP_CLK_UART1_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - sleep UART2 clock
            #[inline(always)]
            pub fn slp_clk_uart2(&self) -> SLP_CLK_UART2_R {
                SLP_CLK_UART2_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - sleep UART3 clock
            #[inline(always)]
            pub fn slp_clk_uart3(&self) -> SLP_CLK_UART3_R {
                SLP_CLK_UART3_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - sleep TMR0 clock
            #[inline(always)]
            #[must_use]
            pub fn slp_clk_tmr0(&mut self) -> SLP_CLK_TMR0_W<SLP_CLK_OFF0_SPEC> {
                SLP_CLK_TMR0_W::new(self, 0)
            }
            ///Bit 1 - sleep TMR1 clock
            #[inline(always)]
            #[must_use]
            pub fn slp_clk_tmr1(&mut self) -> SLP_CLK_TMR1_W<SLP_CLK_OFF0_SPEC> {
                SLP_CLK_TMR1_W::new(self, 1)
            }
            ///Bit 2 - sleep TMR2 clock
            #[inline(always)]
            #[must_use]
            pub fn slp_clk_tmr2(&mut self) -> SLP_CLK_TMR2_W<SLP_CLK_OFF0_SPEC> {
                SLP_CLK_TMR2_W::new(self, 2)
            }
            ///Bit 3 - sleep PWMX clock
            #[inline(always)]
            #[must_use]
            pub fn slp_clk_pwmx(&mut self) -> SLP_CLK_PWMX_W<SLP_CLK_OFF0_SPEC> {
                SLP_CLK_PWMX_W::new(self, 3)
            }
            ///Bit 4 - sleep UART0 clock
            #[inline(always)]
            #[must_use]
            pub fn slp_clk_uart0(&mut self) -> SLP_CLK_UART0_W<SLP_CLK_OFF0_SPEC> {
                SLP_CLK_UART0_W::new(self, 4)
            }
            ///Bit 5 - sleep UART1 clock
            #[inline(always)]
            #[must_use]
            pub fn slp_clk_uart1(&mut self) -> SLP_CLK_UART1_W<SLP_CLK_OFF0_SPEC> {
                SLP_CLK_UART1_W::new(self, 5)
            }
            ///Bit 6 - sleep UART2 clock
            #[inline(always)]
            #[must_use]
            pub fn slp_clk_uart2(&mut self) -> SLP_CLK_UART2_W<SLP_CLK_OFF0_SPEC> {
                SLP_CLK_UART2_W::new(self, 6)
            }
            ///Bit 7 - sleep UART3 clock
            #[inline(always)]
            #[must_use]
            pub fn slp_clk_uart3(&mut self) -> SLP_CLK_UART3_W<SLP_CLK_OFF0_SPEC> {
                SLP_CLK_UART3_W::new(self, 7)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///sleep clock off control byte 0
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`slp_clk_off0::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`slp_clk_off0::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct SLP_CLK_OFF0_SPEC;
        impl crate::RegisterSpec for SLP_CLK_OFF0_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`slp_clk_off0::R`](R) reader structure
        impl crate::Readable for SLP_CLK_OFF0_SPEC {}
        ///`write(|w| ..)` method takes [`slp_clk_off0::W`](W) writer structure
        impl crate::Writable for SLP_CLK_OFF0_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets SLP_CLK_OFF0 to value 0
        impl crate::Resettable for SLP_CLK_OFF0_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///SLP_CLK_OFF1 (rw) register accessor: sleep clock off control byte 1
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`slp_clk_off1::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`slp_clk_off1::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@slp_clk_off1`]
    ///module
    pub type SLP_CLK_OFF1 = crate::Reg<slp_clk_off1::SLP_CLK_OFF1_SPEC>;
    ///sleep clock off control byte 1
    pub mod slp_clk_off1 {
        ///Register `SLP_CLK_OFF1` reader
        pub type R = crate::R<SLP_CLK_OFF1_SPEC>;
        ///Register `SLP_CLK_OFF1` writer
        pub type W = crate::W<SLP_CLK_OFF1_SPEC>;
        ///Field `SLP_CLK_SPI0` reader - sleep SPI0 clock
        pub type SLP_CLK_SPI0_R = crate::BitReader;
        ///Field `SLP_CLK_SPI0` writer - sleep SPI0 clock
        pub type SLP_CLK_SPI0_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `SLP_CLK_SPI1` reader - sleep SPI1 clock
        pub type SLP_CLK_SPI1_R = crate::BitReader;
        ///Field `SLP_CLK_SPI1` writer - sleep SPI1 clock
        pub type SLP_CLK_SPI1_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `SLP_CLK_EMMC` reader - sleep EMMC clock
        pub type SLP_CLK_EMMC_R = crate::BitReader;
        ///Field `SLP_CLK_EMMC` writer - sleep EMMC clock
        pub type SLP_CLK_EMMC_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `SLP_CLK_HSPI` reader - sleep HSPI clock
        pub type SLP_CLK_HSPI_R = crate::BitReader;
        ///Field `SLP_CLK_HSPI` writer - sleep HSPI clock
        pub type SLP_CLK_HSPI_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `SLP_CLK_USBHS` reader - sleep USBHS clock
        pub type SLP_CLK_USBHS_R = crate::BitReader;
        ///Field `SLP_CLK_USBHS` writer - sleep USBHS clock
        pub type SLP_CLK_USBHS_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `SLP_CLK_USBSS` reader - sleep USBSS clock
        pub type SLP_CLK_USBSS_R = crate::BitReader;
        ///Field `SLP_CLK_USBSS` writer - sleep USBSS clock
        pub type SLP_CLK_USBSS_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `SLP_CLK_SERD` reader - sleep SERD clock
        pub type SLP_CLK_SERD_R = crate::BitReader;
        ///Field `SLP_CLK_SERD` writer - sleep SERD clock
        pub type SLP_CLK_SERD_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `SLP_CLK_DVP` reader - sleep DVP clock
        pub type SLP_CLK_DVP_R = crate::BitReader;
        ///Field `SLP_CLK_DVP` writer - sleep DVP clock
        pub type SLP_CLK_DVP_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - sleep SPI0 clock
            #[inline(always)]
            pub fn slp_clk_spi0(&self) -> SLP_CLK_SPI0_R {
                SLP_CLK_SPI0_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - sleep SPI1 clock
            #[inline(always)]
            pub fn slp_clk_spi1(&self) -> SLP_CLK_SPI1_R {
                SLP_CLK_SPI1_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - sleep EMMC clock
            #[inline(always)]
            pub fn slp_clk_emmc(&self) -> SLP_CLK_EMMC_R {
                SLP_CLK_EMMC_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - sleep HSPI clock
            #[inline(always)]
            pub fn slp_clk_hspi(&self) -> SLP_CLK_HSPI_R {
                SLP_CLK_HSPI_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - sleep USBHS clock
            #[inline(always)]
            pub fn slp_clk_usbhs(&self) -> SLP_CLK_USBHS_R {
                SLP_CLK_USBHS_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - sleep USBSS clock
            #[inline(always)]
            pub fn slp_clk_usbss(&self) -> SLP_CLK_USBSS_R {
                SLP_CLK_USBSS_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - sleep SERD clock
            #[inline(always)]
            pub fn slp_clk_serd(&self) -> SLP_CLK_SERD_R {
                SLP_CLK_SERD_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - sleep DVP clock
            #[inline(always)]
            pub fn slp_clk_dvp(&self) -> SLP_CLK_DVP_R {
                SLP_CLK_DVP_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - sleep SPI0 clock
            #[inline(always)]
            #[must_use]
            pub fn slp_clk_spi0(&mut self) -> SLP_CLK_SPI0_W<SLP_CLK_OFF1_SPEC> {
                SLP_CLK_SPI0_W::new(self, 0)
            }
            ///Bit 1 - sleep SPI1 clock
            #[inline(always)]
            #[must_use]
            pub fn slp_clk_spi1(&mut self) -> SLP_CLK_SPI1_W<SLP_CLK_OFF1_SPEC> {
                SLP_CLK_SPI1_W::new(self, 1)
            }
            ///Bit 2 - sleep EMMC clock
            #[inline(always)]
            #[must_use]
            pub fn slp_clk_emmc(&mut self) -> SLP_CLK_EMMC_W<SLP_CLK_OFF1_SPEC> {
                SLP_CLK_EMMC_W::new(self, 2)
            }
            ///Bit 3 - sleep HSPI clock
            #[inline(always)]
            #[must_use]
            pub fn slp_clk_hspi(&mut self) -> SLP_CLK_HSPI_W<SLP_CLK_OFF1_SPEC> {
                SLP_CLK_HSPI_W::new(self, 3)
            }
            ///Bit 4 - sleep USBHS clock
            #[inline(always)]
            #[must_use]
            pub fn slp_clk_usbhs(&mut self) -> SLP_CLK_USBHS_W<SLP_CLK_OFF1_SPEC> {
                SLP_CLK_USBHS_W::new(self, 4)
            }
            ///Bit 5 - sleep USBSS clock
            #[inline(always)]
            #[must_use]
            pub fn slp_clk_usbss(&mut self) -> SLP_CLK_USBSS_W<SLP_CLK_OFF1_SPEC> {
                SLP_CLK_USBSS_W::new(self, 5)
            }
            ///Bit 6 - sleep SERD clock
            #[inline(always)]
            #[must_use]
            pub fn slp_clk_serd(&mut self) -> SLP_CLK_SERD_W<SLP_CLK_OFF1_SPEC> {
                SLP_CLK_SERD_W::new(self, 6)
            }
            ///Bit 7 - sleep DVP clock
            #[inline(always)]
            #[must_use]
            pub fn slp_clk_dvp(&mut self) -> SLP_CLK_DVP_W<SLP_CLK_OFF1_SPEC> {
                SLP_CLK_DVP_W::new(self, 7)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///sleep clock off control byte 1
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`slp_clk_off1::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`slp_clk_off1::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct SLP_CLK_OFF1_SPEC;
        impl crate::RegisterSpec for SLP_CLK_OFF1_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`slp_clk_off1::R`](R) reader structure
        impl crate::Readable for SLP_CLK_OFF1_SPEC {}
        ///`write(|w| ..)` method takes [`slp_clk_off1::W`](W) writer structure
        impl crate::Writable for SLP_CLK_OFF1_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets SLP_CLK_OFF1 to value 0
        impl crate::Resettable for SLP_CLK_OFF1_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///SLP_WAKE_CTRL (rw) register accessor: wake control
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`slp_wake_ctrl::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`slp_wake_ctrl::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@slp_wake_ctrl`]
    ///module
    pub type SLP_WAKE_CTRL = crate::Reg<slp_wake_ctrl::SLP_WAKE_CTRL_SPEC>;
    ///wake control
    pub mod slp_wake_ctrl {
        ///Register `SLP_WAKE_CTRL` reader
        pub type R = crate::R<SLP_WAKE_CTRL_SPEC>;
        ///Register `SLP_WAKE_CTRL` writer
        pub type W = crate::W<SLP_WAKE_CTRL_SPEC>;
        ///Field `SLP_USBHS_WAKE` reader - enable USBHS waking
        pub type SLP_USBHS_WAKE_R = crate::BitReader;
        ///Field `SLP_USBHS_WAKE` writer - enable USBHS waking
        pub type SLP_USBHS_WAKE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `SLP_USBSS_WAKE` reader - enable USBSS waking
        pub type SLP_USBSS_WAKE_R = crate::BitReader;
        ///Field `SLP_USBSS_WAKE` writer - enable USBSS waking
        pub type SLP_USBSS_WAKE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `SLP_CLK_ETH` reader - sleep ETH clock
        pub type SLP_CLK_ETH_R = crate::BitReader;
        ///Field `SLP_CLK_ETH` writer - sleep ETH clock
        pub type SLP_CLK_ETH_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `SLP_CLK_ECDC` reader - sleep ECDC clock
        pub type SLP_CLK_ECDC_R = crate::BitReader;
        ///Field `SLP_CLK_ECDC` writer - sleep ECDC clock
        pub type SLP_CLK_ECDC_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `SLP_GPIO_WAKE` reader - enable GPIO waking
        pub type SLP_GPIO_WAKE_R = crate::BitReader;
        ///Field `SLP_GPIO_WAKE` writer - enable GPIO waking
        pub type SLP_GPIO_WAKE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `SLP_ETH_WAKE` reader - enable Eth waking
        pub type SLP_ETH_WAKE_R = crate::BitReader;
        ///Field `SLP_ETH_WAKE` writer - enable Eth waking
        pub type SLP_ETH_WAKE_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - enable USBHS waking
            #[inline(always)]
            pub fn slp_usbhs_wake(&self) -> SLP_USBHS_WAKE_R {
                SLP_USBHS_WAKE_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - enable USBSS waking
            #[inline(always)]
            pub fn slp_usbss_wake(&self) -> SLP_USBSS_WAKE_R {
                SLP_USBSS_WAKE_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - sleep ETH clock
            #[inline(always)]
            pub fn slp_clk_eth(&self) -> SLP_CLK_ETH_R {
                SLP_CLK_ETH_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - sleep ECDC clock
            #[inline(always)]
            pub fn slp_clk_ecdc(&self) -> SLP_CLK_ECDC_R {
                SLP_CLK_ECDC_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - enable GPIO waking
            #[inline(always)]
            pub fn slp_gpio_wake(&self) -> SLP_GPIO_WAKE_R {
                SLP_GPIO_WAKE_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - enable Eth waking
            #[inline(always)]
            pub fn slp_eth_wake(&self) -> SLP_ETH_WAKE_R {
                SLP_ETH_WAKE_R::new(((self.bits >> 5) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - enable USBHS waking
            #[inline(always)]
            #[must_use]
            pub fn slp_usbhs_wake(&mut self) -> SLP_USBHS_WAKE_W<SLP_WAKE_CTRL_SPEC> {
                SLP_USBHS_WAKE_W::new(self, 0)
            }
            ///Bit 1 - enable USBSS waking
            #[inline(always)]
            #[must_use]
            pub fn slp_usbss_wake(&mut self) -> SLP_USBSS_WAKE_W<SLP_WAKE_CTRL_SPEC> {
                SLP_USBSS_WAKE_W::new(self, 1)
            }
            ///Bit 2 - sleep ETH clock
            #[inline(always)]
            #[must_use]
            pub fn slp_clk_eth(&mut self) -> SLP_CLK_ETH_W<SLP_WAKE_CTRL_SPEC> {
                SLP_CLK_ETH_W::new(self, 2)
            }
            ///Bit 3 - sleep ECDC clock
            #[inline(always)]
            #[must_use]
            pub fn slp_clk_ecdc(&mut self) -> SLP_CLK_ECDC_W<SLP_WAKE_CTRL_SPEC> {
                SLP_CLK_ECDC_W::new(self, 3)
            }
            ///Bit 4 - enable GPIO waking
            #[inline(always)]
            #[must_use]
            pub fn slp_gpio_wake(&mut self) -> SLP_GPIO_WAKE_W<SLP_WAKE_CTRL_SPEC> {
                SLP_GPIO_WAKE_W::new(self, 4)
            }
            ///Bit 5 - enable Eth waking
            #[inline(always)]
            #[must_use]
            pub fn slp_eth_wake(&mut self) -> SLP_ETH_WAKE_W<SLP_WAKE_CTRL_SPEC> {
                SLP_ETH_WAKE_W::new(self, 5)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///wake control
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`slp_wake_ctrl::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`slp_wake_ctrl::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct SLP_WAKE_CTRL_SPEC;
        impl crate::RegisterSpec for SLP_WAKE_CTRL_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`slp_wake_ctrl::R`](R) reader structure
        impl crate::Readable for SLP_WAKE_CTRL_SPEC {}
        ///`write(|w| ..)` method takes [`slp_wake_ctrl::W`](W) writer structure
        impl crate::Writable for SLP_WAKE_CTRL_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets SLP_WAKE_CTRL to value 0
        impl crate::Resettable for SLP_WAKE_CTRL_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///SLP_POWER_CTRL (rw) register accessor: power control
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`slp_power_ctrl::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`slp_power_ctrl::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@slp_power_ctrl`]
    ///module
    pub type SLP_POWER_CTRL = crate::Reg<slp_power_ctrl::SLP_POWER_CTRL_SPEC>;
    ///power control
    pub mod slp_power_ctrl {
        ///Register `SLP_POWER_CTRL` reader
        pub type R = crate::R<SLP_POWER_CTRL_SPEC>;
        ///Register `SLP_POWER_CTRL` writer
        pub type W = crate::W<SLP_POWER_CTRL_SPEC>;
        ///Field `SLP_USBHS_PWRDN` reader - enable USBHS power down
        pub type SLP_USBHS_PWRDN_R = crate::BitReader;
        ///Field `SLP_USBHS_PWRDN` writer - enable USBHS power down
        pub type SLP_USBHS_PWRDN_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - enable USBHS power down
            #[inline(always)]
            pub fn slp_usbhs_pwrdn(&self) -> SLP_USBHS_PWRDN_R {
                SLP_USBHS_PWRDN_R::new((self.bits & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - enable USBHS power down
            #[inline(always)]
            #[must_use]
            pub fn slp_usbhs_pwrdn(&mut self) -> SLP_USBHS_PWRDN_W<SLP_POWER_CTRL_SPEC> {
                SLP_USBHS_PWRDN_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///power control
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`slp_power_ctrl::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`slp_power_ctrl::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct SLP_POWER_CTRL_SPEC;
        impl crate::RegisterSpec for SLP_POWER_CTRL_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`slp_power_ctrl::R`](R) reader structure
        impl crate::Readable for SLP_POWER_CTRL_SPEC {}
        ///`write(|w| ..)` method takes [`slp_power_ctrl::W`](W) writer structure
        impl crate::Writable for SLP_POWER_CTRL_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets SLP_POWER_CTRL to value 0
        impl crate::Resettable for SLP_POWER_CTRL_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///SERD_ANA_CFG1 (rw) register accessor: Serdes Analog parameter configuration1
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`serd_ana_cfg1::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`serd_ana_cfg1::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@serd_ana_cfg1`]
    ///module
    pub type SERD_ANA_CFG1 = crate::Reg<serd_ana_cfg1::SERD_ANA_CFG1_SPEC>;
    ///Serdes Analog parameter configuration1
    pub mod serd_ana_cfg1 {
        ///Register `SERD_ANA_CFG1` reader
        pub type R = crate::R<SERD_ANA_CFG1_SPEC>;
        ///Register `SERD_ANA_CFG1` writer
        pub type W = crate::W<SERD_ANA_CFG1_SPEC>;
        ///Field `SERD_PLL_CFG` reader - SerDes PHY internal configuration bit
        pub type SERD_PLL_CFG_R = crate::FieldReader;
        ///Field `SERD_PLL_CFG` writer - SerDes PHY internal configuration bit
        pub type SERD_PLL_CFG_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        ///Field `SERD_30M_SEL` reader - SerDes PHY reference clock source seletion
        pub type SERD_30M_SEL_R = crate::BitReader;
        ///Field `SERD_30M_SEL` writer - SerDes PHY reference clock source seletion
        pub type SERD_30M_SEL_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `SERD_DN_SEL` reader - Enable SerDes PHY GXM test pin
        pub type SERD_DN_SEL_R = crate::BitReader;
        ///Field `SERD_DN_SEL` writer - Enable SerDes PHY GXM test pin
        pub type SERD_DN_SEL_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bits 0:7 - SerDes PHY internal configuration bit
            #[inline(always)]
            pub fn serd_pll_cfg(&self) -> SERD_PLL_CFG_R {
                SERD_PLL_CFG_R::new((self.bits & 0xff) as u8)
            }
            ///Bit 8 - SerDes PHY reference clock source seletion
            #[inline(always)]
            pub fn serd_30m_sel(&self) -> SERD_30M_SEL_R {
                SERD_30M_SEL_R::new(((self.bits >> 8) & 1) != 0)
            }
            ///Bit 9 - Enable SerDes PHY GXM test pin
            #[inline(always)]
            pub fn serd_dn_sel(&self) -> SERD_DN_SEL_R {
                SERD_DN_SEL_R::new(((self.bits >> 9) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:7 - SerDes PHY internal configuration bit
            #[inline(always)]
            #[must_use]
            pub fn serd_pll_cfg(&mut self) -> SERD_PLL_CFG_W<SERD_ANA_CFG1_SPEC> {
                SERD_PLL_CFG_W::new(self, 0)
            }
            ///Bit 8 - SerDes PHY reference clock source seletion
            #[inline(always)]
            #[must_use]
            pub fn serd_30m_sel(&mut self) -> SERD_30M_SEL_W<SERD_ANA_CFG1_SPEC> {
                SERD_30M_SEL_W::new(self, 8)
            }
            ///Bit 9 - Enable SerDes PHY GXM test pin
            #[inline(always)]
            #[must_use]
            pub fn serd_dn_sel(&mut self) -> SERD_DN_SEL_W<SERD_ANA_CFG1_SPEC> {
                SERD_DN_SEL_W::new(self, 9)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Serdes Analog parameter configuration1
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`serd_ana_cfg1::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`serd_ana_cfg1::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct SERD_ANA_CFG1_SPEC;
        impl crate::RegisterSpec for SERD_ANA_CFG1_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`serd_ana_cfg1::R`](R) reader structure
        impl crate::Readable for SERD_ANA_CFG1_SPEC {}
        ///`write(|w| ..)` method takes [`serd_ana_cfg1::W`](W) writer structure
        impl crate::Writable for SERD_ANA_CFG1_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets SERD_ANA_CFG1 to value 0x5a
        impl crate::Resettable for SERD_ANA_CFG1_SPEC {
            const RESET_VALUE: u16 = 0x5a;
        }
    }
    ///SERD_ANA_CFG2 (rw) register accessor: Serdes Analog parameter configuration2
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`serd_ana_cfg2::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`serd_ana_cfg2::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@serd_ana_cfg2`]
    ///module
    pub type SERD_ANA_CFG2 = crate::Reg<serd_ana_cfg2::SERD_ANA_CFG2_SPEC>;
    ///Serdes Analog parameter configuration2
    pub mod serd_ana_cfg2 {
        ///Register `SERD_ANA_CFG2` reader
        pub type R = crate::R<SERD_ANA_CFG2_SPEC>;
        ///Register `SERD_ANA_CFG2` writer
        pub type W = crate::W<SERD_ANA_CFG2_SPEC>;
        ///Field `SERD_TRX_CFG` reader - Tx and RX parameter setting
        pub type SERD_TRX_CFG_R = crate::FieldReader<u32>;
        ///Field `SERD_TRX_CFG` writer - Tx and RX parameter setting
        pub type SERD_TRX_CFG_W<'a, REG> = crate::FieldWriter<'a, REG, 25, u32>;
        impl R {
            ///Bits 0:24 - Tx and RX parameter setting
            #[inline(always)]
            pub fn serd_trx_cfg(&self) -> SERD_TRX_CFG_R {
                SERD_TRX_CFG_R::new(self.bits & 0x01ff_ffff)
            }
        }
        impl W {
            ///Bits 0:24 - Tx and RX parameter setting
            #[inline(always)]
            #[must_use]
            pub fn serd_trx_cfg(&mut self) -> SERD_TRX_CFG_W<SERD_ANA_CFG2_SPEC> {
                SERD_TRX_CFG_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Serdes Analog parameter configuration2
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`serd_ana_cfg2::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`serd_ana_cfg2::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct SERD_ANA_CFG2_SPEC;
        impl crate::RegisterSpec for SERD_ANA_CFG2_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`serd_ana_cfg2::R`](R) reader structure
        impl crate::Readable for SERD_ANA_CFG2_SPEC {}
        ///`write(|w| ..)` method takes [`serd_ana_cfg2::W`](W) writer structure
        impl crate::Writable for SERD_ANA_CFG2_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets SERD_ANA_CFG2 to value 0x0042_3015
        impl crate::Resettable for SERD_ANA_CFG2_SPEC {
            const RESET_VALUE: u32 = 0x0042_3015;
        }
    }
}
///TMR0 register
pub struct TMR0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for TMR0 {}
impl TMR0 {
    ///Pointer to the register block
    pub const PTR: *const tmr0::RegisterBlock = 0x4000_2000 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const tmr0::RegisterBlock {
        Self::PTR
    }
    /// Steal an instance of this peripheral
    ///
    /// # Safety
    ///
    /// Ensure that the new instance of the peripheral cannot be used in a way
    /// that may race with any existing instances, for example by only
    /// accessing read-only or write-only registers, or by consuming the
    /// original peripheral and using critical sections to coordinate
    /// access between multiple new instances.
    ///
    /// Additionally, other software such as HALs may rely on only one
    /// peripheral instance existing to ensure memory safety; ensure
    /// no stolen instances are passed to such software.
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for TMR0 {
    type Target = tmr0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for TMR0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("TMR0").finish()
    }
}
///TMR0 register
pub mod tmr0 {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        ctrl_mod: CTRL_MOD,
        _reserved1: [u8; 0x01],
        inter_en: INTER_EN,
        _reserved2: [u8; 0x03],
        int_flag: INT_FLAG,
        fifo_count: FIFO_COUNT,
        count: COUNT,
        cnt_end: CNT_END,
        fifo: FIFO,
    }
    impl RegisterBlock {
        ///0x00 - TMR0 mode control
        #[inline(always)]
        pub const fn ctrl_mod(&self) -> &CTRL_MOD {
            &self.ctrl_mod
        }
        ///0x02 - TMR0 interrupt enable
        #[inline(always)]
        pub const fn inter_en(&self) -> &INTER_EN {
            &self.inter_en
        }
        ///0x06 - TMR0 interrupt flag
        #[inline(always)]
        pub const fn int_flag(&self) -> &INT_FLAG {
            &self.int_flag
        }
        ///0x07 - TMR0 FIFO count status
        #[inline(always)]
        pub const fn fifo_count(&self) -> &FIFO_COUNT {
            &self.fifo_count
        }
        ///0x08 - TMR0 current count
        #[inline(always)]
        pub const fn count(&self) -> &COUNT {
            &self.count
        }
        ///0x0c - TMR0 end count value, only low 26 bit
        #[inline(always)]
        pub const fn cnt_end(&self) -> &CNT_END {
            &self.cnt_end
        }
        ///0x10 - TMR0 FIFO register, only low 26 bit
        #[inline(always)]
        pub const fn fifo(&self) -> &FIFO {
            &self.fifo
        }
    }
    ///CTRL_MOD (rw) register accessor: TMR0 mode control
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`ctrl_mod::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ctrl_mod::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@ctrl_mod`]
    ///module
    pub type CTRL_MOD = crate::Reg<ctrl_mod::CTRL_MOD_SPEC>;
    ///TMR0 mode control
    pub mod ctrl_mod {
        ///Register `CTRL_MOD` reader
        pub type R = crate::R<CTRL_MOD_SPEC>;
        ///Register `CTRL_MOD` writer
        pub type W = crate::W<CTRL_MOD_SPEC>;
        ///Field `TMR_MODE_IN` reader - timer in mode
        pub type TMR_MODE_IN_R = crate::BitReader;
        ///Field `TMR_MODE_IN` writer - timer in mode
        pub type TMR_MODE_IN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TMR_ALL_CLEAR` reader - force clear timer FIFO and count
        pub type TMR_ALL_CLEAR_R = crate::BitReader;
        ///Field `TMR_ALL_CLEAR` writer - force clear timer FIFO and count
        pub type TMR_ALL_CLEAR_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TMR_COUNT_EN` reader - timer count enable
        pub type TMR_COUNT_EN_R = crate::BitReader;
        ///Field `TMR_COUNT_EN` writer - timer count enable
        pub type TMR_COUNT_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TMR_OUT_EN` reader - timer output enable
        pub type TMR_OUT_EN_R = crate::BitReader;
        ///Field `TMR_OUT_EN` writer - timer output enable
        pub type TMR_OUT_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TMR_OUT_POLAR_RB_TMR_CAP_COUNT` reader - timer PWM output polarity _ Count sub-mode
        pub type TMR_OUT_POLAR_RB_TMR_CAP_COUNT_R = crate::BitReader;
        ///Field `TMR_OUT_POLAR_RB_TMR_CAP_COUNT` writer - timer PWM output polarity _ Count sub-mode
        pub type TMR_OUT_POLAR_RB_TMR_CAP_COUNT_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TMR_PWM_REPEAT_RB_TMR_CAP_EDGE` reader - timer PWM repeat mode _ timer capture edge mode
        pub type TMR_PWM_REPEAT_RB_TMR_CAP_EDGE_R = crate::FieldReader;
        ///Field `TMR_PWM_REPEAT_RB_TMR_CAP_EDGE` writer - timer PWM repeat mode _ timer capture edge mode
        pub type TMR_PWM_REPEAT_RB_TMR_CAP_EDGE_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        impl R {
            ///Bit 0 - timer in mode
            #[inline(always)]
            pub fn tmr_mode_in(&self) -> TMR_MODE_IN_R {
                TMR_MODE_IN_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - force clear timer FIFO and count
            #[inline(always)]
            pub fn tmr_all_clear(&self) -> TMR_ALL_CLEAR_R {
                TMR_ALL_CLEAR_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - timer count enable
            #[inline(always)]
            pub fn tmr_count_en(&self) -> TMR_COUNT_EN_R {
                TMR_COUNT_EN_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - timer output enable
            #[inline(always)]
            pub fn tmr_out_en(&self) -> TMR_OUT_EN_R {
                TMR_OUT_EN_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - timer PWM output polarity _ Count sub-mode
            #[inline(always)]
            pub fn tmr_out_polar_rb_tmr_cap_count(&self) -> TMR_OUT_POLAR_RB_TMR_CAP_COUNT_R {
                TMR_OUT_POLAR_RB_TMR_CAP_COUNT_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bits 6:7 - timer PWM repeat mode _ timer capture edge mode
            #[inline(always)]
            pub fn tmr_pwm_repeat_rb_tmr_cap_edge(&self) -> TMR_PWM_REPEAT_RB_TMR_CAP_EDGE_R {
                TMR_PWM_REPEAT_RB_TMR_CAP_EDGE_R::new((self.bits >> 6) & 3)
            }
        }
        impl W {
            ///Bit 0 - timer in mode
            #[inline(always)]
            #[must_use]
            pub fn tmr_mode_in(&mut self) -> TMR_MODE_IN_W<CTRL_MOD_SPEC> {
                TMR_MODE_IN_W::new(self, 0)
            }
            ///Bit 1 - force clear timer FIFO and count
            #[inline(always)]
            #[must_use]
            pub fn tmr_all_clear(&mut self) -> TMR_ALL_CLEAR_W<CTRL_MOD_SPEC> {
                TMR_ALL_CLEAR_W::new(self, 1)
            }
            ///Bit 2 - timer count enable
            #[inline(always)]
            #[must_use]
            pub fn tmr_count_en(&mut self) -> TMR_COUNT_EN_W<CTRL_MOD_SPEC> {
                TMR_COUNT_EN_W::new(self, 2)
            }
            ///Bit 3 - timer output enable
            #[inline(always)]
            #[must_use]
            pub fn tmr_out_en(&mut self) -> TMR_OUT_EN_W<CTRL_MOD_SPEC> {
                TMR_OUT_EN_W::new(self, 3)
            }
            ///Bit 4 - timer PWM output polarity _ Count sub-mode
            #[inline(always)]
            #[must_use]
            pub fn tmr_out_polar_rb_tmr_cap_count(
                &mut self,
            ) -> TMR_OUT_POLAR_RB_TMR_CAP_COUNT_W<CTRL_MOD_SPEC> {
                TMR_OUT_POLAR_RB_TMR_CAP_COUNT_W::new(self, 4)
            }
            ///Bits 6:7 - timer PWM repeat mode _ timer capture edge mode
            #[inline(always)]
            #[must_use]
            pub fn tmr_pwm_repeat_rb_tmr_cap_edge(
                &mut self,
            ) -> TMR_PWM_REPEAT_RB_TMR_CAP_EDGE_W<CTRL_MOD_SPEC> {
                TMR_PWM_REPEAT_RB_TMR_CAP_EDGE_W::new(self, 6)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///TMR0 mode control
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`ctrl_mod::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ctrl_mod::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct CTRL_MOD_SPEC;
        impl crate::RegisterSpec for CTRL_MOD_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`ctrl_mod::R`](R) reader structure
        impl crate::Readable for CTRL_MOD_SPEC {}
        ///`write(|w| ..)` method takes [`ctrl_mod::W`](W) writer structure
        impl crate::Writable for CTRL_MOD_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets CTRL_MOD to value 0x02
        impl crate::Resettable for CTRL_MOD_SPEC {
            const RESET_VALUE: u8 = 0x02;
        }
    }
    ///INTER_EN (rw) register accessor: TMR0 interrupt enable
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`inter_en::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`inter_en::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@inter_en`]
    ///module
    pub type INTER_EN = crate::Reg<inter_en::INTER_EN_SPEC>;
    ///TMR0 interrupt enable
    pub mod inter_en {
        ///Register `INTER_EN` reader
        pub type R = crate::R<INTER_EN_SPEC>;
        ///Register `INTER_EN` writer
        pub type W = crate::W<INTER_EN_SPEC>;
        ///Field `TMR_IE_CYC_END` reader - enable interrupt for timer capture count timeout or PWM cycle end
        pub type TMR_IE_CYC_END_R = crate::BitReader;
        ///Field `TMR_IE_CYC_END` writer - enable interrupt for timer capture count timeout or PWM cycle end
        pub type TMR_IE_CYC_END_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TMR_IE_DATA_ACT` reader - enable interrupt for timer capture input action or PWM trigger
        pub type TMR_IE_DATA_ACT_R = crate::BitReader;
        ///Field `TMR_IE_DATA_ACT` writer - enable interrupt for timer capture input action or PWM trigger
        pub type TMR_IE_DATA_ACT_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TMR_IE_FIFO_HF` reader - enable interrupt for timer FIFO half (capture fifo >=4 or PWM fifo lower than3)
        pub type TMR_IE_FIFO_HF_R = crate::BitReader;
        ///Field `TMR_IE_FIFO_HF` writer - enable interrupt for timer FIFO half (capture fifo >=4 or PWM fifo lower than3)
        pub type TMR_IE_FIFO_HF_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TMR_IE_DMA_END` reader - enable interrupt for timer1/2 DMA completion
        pub type TMR_IE_DMA_END_R = crate::BitReader;
        ///Field `TMR_IE_DMA_END` writer - enable interrupt for timer1/2 DMA completion
        pub type TMR_IE_DMA_END_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TMR_IE_FIFO_OV` reader - enable interrupt for timer FIFO overflow
        pub type TMR_IE_FIFO_OV_R = crate::BitReader;
        ///Field `TMR_IE_FIFO_OV` writer - enable interrupt for timer FIFO overflow
        pub type TMR_IE_FIFO_OV_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - enable interrupt for timer capture count timeout or PWM cycle end
            #[inline(always)]
            pub fn tmr_ie_cyc_end(&self) -> TMR_IE_CYC_END_R {
                TMR_IE_CYC_END_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - enable interrupt for timer capture input action or PWM trigger
            #[inline(always)]
            pub fn tmr_ie_data_act(&self) -> TMR_IE_DATA_ACT_R {
                TMR_IE_DATA_ACT_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - enable interrupt for timer FIFO half (capture fifo >=4 or PWM fifo lower than3)
            #[inline(always)]
            pub fn tmr_ie_fifo_hf(&self) -> TMR_IE_FIFO_HF_R {
                TMR_IE_FIFO_HF_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - enable interrupt for timer1/2 DMA completion
            #[inline(always)]
            pub fn tmr_ie_dma_end(&self) -> TMR_IE_DMA_END_R {
                TMR_IE_DMA_END_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - enable interrupt for timer FIFO overflow
            #[inline(always)]
            pub fn tmr_ie_fifo_ov(&self) -> TMR_IE_FIFO_OV_R {
                TMR_IE_FIFO_OV_R::new(((self.bits >> 4) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - enable interrupt for timer capture count timeout or PWM cycle end
            #[inline(always)]
            #[must_use]
            pub fn tmr_ie_cyc_end(&mut self) -> TMR_IE_CYC_END_W<INTER_EN_SPEC> {
                TMR_IE_CYC_END_W::new(self, 0)
            }
            ///Bit 1 - enable interrupt for timer capture input action or PWM trigger
            #[inline(always)]
            #[must_use]
            pub fn tmr_ie_data_act(&mut self) -> TMR_IE_DATA_ACT_W<INTER_EN_SPEC> {
                TMR_IE_DATA_ACT_W::new(self, 1)
            }
            ///Bit 2 - enable interrupt for timer FIFO half (capture fifo >=4 or PWM fifo lower than3)
            #[inline(always)]
            #[must_use]
            pub fn tmr_ie_fifo_hf(&mut self) -> TMR_IE_FIFO_HF_W<INTER_EN_SPEC> {
                TMR_IE_FIFO_HF_W::new(self, 2)
            }
            ///Bit 3 - enable interrupt for timer1/2 DMA completion
            #[inline(always)]
            #[must_use]
            pub fn tmr_ie_dma_end(&mut self) -> TMR_IE_DMA_END_W<INTER_EN_SPEC> {
                TMR_IE_DMA_END_W::new(self, 3)
            }
            ///Bit 4 - enable interrupt for timer FIFO overflow
            #[inline(always)]
            #[must_use]
            pub fn tmr_ie_fifo_ov(&mut self) -> TMR_IE_FIFO_OV_W<INTER_EN_SPEC> {
                TMR_IE_FIFO_OV_W::new(self, 4)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///TMR0 interrupt enable
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`inter_en::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`inter_en::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct INTER_EN_SPEC;
        impl crate::RegisterSpec for INTER_EN_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`inter_en::R`](R) reader structure
        impl crate::Readable for INTER_EN_SPEC {}
        ///`write(|w| ..)` method takes [`inter_en::W`](W) writer structure
        impl crate::Writable for INTER_EN_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets INTER_EN to value 0
        impl crate::Resettable for INTER_EN_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///INT_FLAG (rw) register accessor: TMR0 interrupt flag
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`int_flag::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`int_flag::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@int_flag`]
    ///module
    pub type INT_FLAG = crate::Reg<int_flag::INT_FLAG_SPEC>;
    ///TMR0 interrupt flag
    pub mod int_flag {
        ///Register `INT_FLAG` reader
        pub type R = crate::R<INT_FLAG_SPEC>;
        ///Register `INT_FLAG` writer
        pub type W = crate::W<INT_FLAG_SPEC>;
        ///Field `TMR_IF_CYC_END` reader - interrupt flag for timer capture count timeout or PWM cycle end
        pub type TMR_IF_CYC_END_R = crate::BitReader;
        ///Field `TMR_IF_CYC_END` writer - interrupt flag for timer capture count timeout or PWM cycle end
        pub type TMR_IF_CYC_END_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TMR_IF_DATA_ACT` reader - interrupt flag for timer capture input action or PWM trigger
        pub type TMR_IF_DATA_ACT_R = crate::BitReader;
        ///Field `TMR_IF_DATA_ACT` writer - interrupt flag for timer capture input action or PWM trigger
        pub type TMR_IF_DATA_ACT_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TMR_IF_FIFO_HF` reader - interrupt flag for timer FIFO half (capture fifo >=4 or PWM fifo lower than 3)
        pub type TMR_IF_FIFO_HF_R = crate::BitReader;
        ///Field `TMR_IF_FIFO_HF` writer - interrupt flag for timer FIFO half (capture fifo >=4 or PWM fifo lower than 3)
        pub type TMR_IF_FIFO_HF_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TMR_IF_DMA_END` reader - interrupt flag for timer1/2 DMA completion
        pub type TMR_IF_DMA_END_R = crate::BitReader;
        ///Field `TMR_IF_DMA_END` writer - interrupt flag for timer1/2 DMA completion
        pub type TMR_IF_DMA_END_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TMR_IF_FIFO_OV` reader - interrupt flag for timer FIFO overflow
        pub type TMR_IF_FIFO_OV_R = crate::BitReader;
        ///Field `TMR_IF_FIFO_OV` writer - interrupt flag for timer FIFO overflow
        pub type TMR_IF_FIFO_OV_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - interrupt flag for timer capture count timeout or PWM cycle end
            #[inline(always)]
            pub fn tmr_if_cyc_end(&self) -> TMR_IF_CYC_END_R {
                TMR_IF_CYC_END_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - interrupt flag for timer capture input action or PWM trigger
            #[inline(always)]
            pub fn tmr_if_data_act(&self) -> TMR_IF_DATA_ACT_R {
                TMR_IF_DATA_ACT_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - interrupt flag for timer FIFO half (capture fifo >=4 or PWM fifo lower than 3)
            #[inline(always)]
            pub fn tmr_if_fifo_hf(&self) -> TMR_IF_FIFO_HF_R {
                TMR_IF_FIFO_HF_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - interrupt flag for timer1/2 DMA completion
            #[inline(always)]
            pub fn tmr_if_dma_end(&self) -> TMR_IF_DMA_END_R {
                TMR_IF_DMA_END_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - interrupt flag for timer FIFO overflow
            #[inline(always)]
            pub fn tmr_if_fifo_ov(&self) -> TMR_IF_FIFO_OV_R {
                TMR_IF_FIFO_OV_R::new(((self.bits >> 4) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - interrupt flag for timer capture count timeout or PWM cycle end
            #[inline(always)]
            #[must_use]
            pub fn tmr_if_cyc_end(&mut self) -> TMR_IF_CYC_END_W<INT_FLAG_SPEC> {
                TMR_IF_CYC_END_W::new(self, 0)
            }
            ///Bit 1 - interrupt flag for timer capture input action or PWM trigger
            #[inline(always)]
            #[must_use]
            pub fn tmr_if_data_act(&mut self) -> TMR_IF_DATA_ACT_W<INT_FLAG_SPEC> {
                TMR_IF_DATA_ACT_W::new(self, 1)
            }
            ///Bit 2 - interrupt flag for timer FIFO half (capture fifo >=4 or PWM fifo lower than 3)
            #[inline(always)]
            #[must_use]
            pub fn tmr_if_fifo_hf(&mut self) -> TMR_IF_FIFO_HF_W<INT_FLAG_SPEC> {
                TMR_IF_FIFO_HF_W::new(self, 2)
            }
            ///Bit 3 - interrupt flag for timer1/2 DMA completion
            #[inline(always)]
            #[must_use]
            pub fn tmr_if_dma_end(&mut self) -> TMR_IF_DMA_END_W<INT_FLAG_SPEC> {
                TMR_IF_DMA_END_W::new(self, 3)
            }
            ///Bit 4 - interrupt flag for timer FIFO overflow
            #[inline(always)]
            #[must_use]
            pub fn tmr_if_fifo_ov(&mut self) -> TMR_IF_FIFO_OV_W<INT_FLAG_SPEC> {
                TMR_IF_FIFO_OV_W::new(self, 4)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///TMR0 interrupt flag
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`int_flag::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`int_flag::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct INT_FLAG_SPEC;
        impl crate::RegisterSpec for INT_FLAG_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`int_flag::R`](R) reader structure
        impl crate::Readable for INT_FLAG_SPEC {}
        ///`write(|w| ..)` method takes [`int_flag::W`](W) writer structure
        impl crate::Writable for INT_FLAG_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets INT_FLAG to value 0
        impl crate::Resettable for INT_FLAG_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///FIFO_COUNT (r) register accessor: TMR0 FIFO count status
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`fifo_count::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@fifo_count`]
    ///module
    pub type FIFO_COUNT = crate::Reg<fifo_count::FIFO_COUNT_SPEC>;
    ///TMR0 FIFO count status
    pub mod fifo_count {
        ///Register `FIFO_COUNT` reader
        pub type R = crate::R<FIFO_COUNT_SPEC>;
        ///Field `FIFO_COUNT` reader - TMR0 FIFO count status
        pub type FIFO_COUNT_R = crate::FieldReader;
        impl R {
            ///Bits 0:7 - TMR0 FIFO count status
            #[inline(always)]
            pub fn fifo_count(&self) -> FIFO_COUNT_R {
                FIFO_COUNT_R::new(self.bits)
            }
        }
        ///TMR0 FIFO count status
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`fifo_count::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct FIFO_COUNT_SPEC;
        impl crate::RegisterSpec for FIFO_COUNT_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`fifo_count::R`](R) reader structure
        impl crate::Readable for FIFO_COUNT_SPEC {}
        ///`reset()` method sets FIFO_COUNT to value 0
        impl crate::Resettable for FIFO_COUNT_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///COUNT (r) register accessor: TMR0 current count
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`count::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@count`]
    ///module
    pub type COUNT = crate::Reg<count::COUNT_SPEC>;
    ///TMR0 current count
    pub mod count {
        ///Register `COUNT` reader
        pub type R = crate::R<COUNT_SPEC>;
        ///Field `COUNT` reader - TMR0 current count
        pub type COUNT_R = crate::FieldReader<u32>;
        impl R {
            ///Bits 0:31 - TMR0 current count
            #[inline(always)]
            pub fn count(&self) -> COUNT_R {
                COUNT_R::new(self.bits)
            }
        }
        ///TMR0 current count
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`count::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct COUNT_SPEC;
        impl crate::RegisterSpec for COUNT_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`count::R`](R) reader structure
        impl crate::Readable for COUNT_SPEC {}
        ///`reset()` method sets COUNT to value 0
        impl crate::Resettable for COUNT_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///CNT_END (rw) register accessor: TMR0 end count value, only low 26 bit
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`cnt_end::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cnt_end::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@cnt_end`]
    ///module
    pub type CNT_END = crate::Reg<cnt_end::CNT_END_SPEC>;
    ///TMR0 end count value, only low 26 bit
    pub mod cnt_end {
        ///Register `CNT_END` reader
        pub type R = crate::R<CNT_END_SPEC>;
        ///Register `CNT_END` writer
        pub type W = crate::W<CNT_END_SPEC>;
        ///Field `COUNT` reader - TMR0 current count
        pub type COUNT_R = crate::FieldReader<u32>;
        ///Field `COUNT` writer - TMR0 current count
        pub type COUNT_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - TMR0 current count
            #[inline(always)]
            pub fn count(&self) -> COUNT_R {
                COUNT_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - TMR0 current count
            #[inline(always)]
            #[must_use]
            pub fn count(&mut self) -> COUNT_W<CNT_END_SPEC> {
                COUNT_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///TMR0 end count value, only low 26 bit
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`cnt_end::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cnt_end::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct CNT_END_SPEC;
        impl crate::RegisterSpec for CNT_END_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`cnt_end::R`](R) reader structure
        impl crate::Readable for CNT_END_SPEC {}
        ///`write(|w| ..)` method takes [`cnt_end::W`](W) writer structure
        impl crate::Writable for CNT_END_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets CNT_END to value 0
        impl crate::Resettable for CNT_END_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///FIFO (rw) register accessor: TMR0 FIFO register, only low 26 bit
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`fifo::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`fifo::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@fifo`]
    ///module
    pub type FIFO = crate::Reg<fifo::FIFO_SPEC>;
    ///TMR0 FIFO register, only low 26 bit
    pub mod fifo {
        ///Register `FIFO` reader
        pub type R = crate::R<FIFO_SPEC>;
        ///Register `FIFO` writer
        pub type W = crate::W<FIFO_SPEC>;
        ///Field `FIFO` reader - TMR0 FIFO current count
        pub type FIFO_R = crate::FieldReader<u32>;
        ///Field `FIFO` writer - TMR0 FIFO current count
        pub type FIFO_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - TMR0 FIFO current count
            #[inline(always)]
            pub fn fifo(&self) -> FIFO_R {
                FIFO_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - TMR0 FIFO current count
            #[inline(always)]
            #[must_use]
            pub fn fifo(&mut self) -> FIFO_W<FIFO_SPEC> {
                FIFO_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///TMR0 FIFO register, only low 26 bit
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`fifo::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`fifo::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct FIFO_SPEC;
        impl crate::RegisterSpec for FIFO_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`fifo::R`](R) reader structure
        impl crate::Readable for FIFO_SPEC {}
        ///`write(|w| ..)` method takes [`fifo::W`](W) writer structure
        impl crate::Writable for FIFO_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets FIFO to value 0
        impl crate::Resettable for FIFO_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
}
///TMR1 register
pub struct TMR1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for TMR1 {}
impl TMR1 {
    ///Pointer to the register block
    pub const PTR: *const tmr1::RegisterBlock = 0x4000_2400 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const tmr1::RegisterBlock {
        Self::PTR
    }
    /// Steal an instance of this peripheral
    ///
    /// # Safety
    ///
    /// Ensure that the new instance of the peripheral cannot be used in a way
    /// that may race with any existing instances, for example by only
    /// accessing read-only or write-only registers, or by consuming the
    /// original peripheral and using critical sections to coordinate
    /// access between multiple new instances.
    ///
    /// Additionally, other software such as HALs may rely on only one
    /// peripheral instance existing to ensure memory safety; ensure
    /// no stolen instances are passed to such software.
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for TMR1 {
    type Target = tmr1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for TMR1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("TMR1").finish()
    }
}
///TMR1 register
pub mod tmr1 {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        ctrl_mod: CTRL_MOD,
        ctrl_dma: CTRL_DMA,
        inter_en: INTER_EN,
        _reserved3: [u8; 0x03],
        int_flag: INT_FLAG,
        fifo_count: FIFO_COUNT,
        count: COUNT,
        cnt_end: CNT_END,
        fifo: FIFO,
        dma_now: DMA_NOW,
        dma_beg: DMA_BEG,
        dma_end: DMA_END,
    }
    impl RegisterBlock {
        ///0x00 - TMR1 mode control
        #[inline(always)]
        pub const fn ctrl_mod(&self) -> &CTRL_MOD {
            &self.ctrl_mod
        }
        ///0x01 - TMR1 DMA control
        #[inline(always)]
        pub const fn ctrl_dma(&self) -> &CTRL_DMA {
            &self.ctrl_dma
        }
        ///0x02 - TMR1 interrupt enable
        #[inline(always)]
        pub const fn inter_en(&self) -> &INTER_EN {
            &self.inter_en
        }
        ///0x06 - TMR1 interrupt flag
        #[inline(always)]
        pub const fn int_flag(&self) -> &INT_FLAG {
            &self.int_flag
        }
        ///0x07 - TMR1 FIFO count status
        #[inline(always)]
        pub const fn fifo_count(&self) -> &FIFO_COUNT {
            &self.fifo_count
        }
        ///0x08 - TMR1 current count
        #[inline(always)]
        pub const fn count(&self) -> &COUNT {
            &self.count
        }
        ///0x0c - TMR1 end count value, only low 26 bit
        #[inline(always)]
        pub const fn cnt_end(&self) -> &CNT_END {
            &self.cnt_end
        }
        ///0x10 - TMR1 FIFO only low 26 bit
        #[inline(always)]
        pub const fn fifo(&self) -> &FIFO {
            &self.fifo
        }
        ///0x14 - TMR1 DMA current address
        #[inline(always)]
        pub const fn dma_now(&self) -> &DMA_NOW {
            &self.dma_now
        }
        ///0x18 - TMR1 DMA begin address
        #[inline(always)]
        pub const fn dma_beg(&self) -> &DMA_BEG {
            &self.dma_beg
        }
        ///0x1c - TMR1 DMA end address
        #[inline(always)]
        pub const fn dma_end(&self) -> &DMA_END {
            &self.dma_end
        }
    }
    ///CTRL_MOD (rw) register accessor: TMR1 mode control
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`ctrl_mod::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ctrl_mod::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@ctrl_mod`]
    ///module
    pub type CTRL_MOD = crate::Reg<ctrl_mod::CTRL_MOD_SPEC>;
    ///TMR1 mode control
    pub mod ctrl_mod {
        ///Register `CTRL_MOD` reader
        pub type R = crate::R<CTRL_MOD_SPEC>;
        ///Register `CTRL_MOD` writer
        pub type W = crate::W<CTRL_MOD_SPEC>;
        ///Field `TMR_MODE_IN` reader - timer in mode
        pub type TMR_MODE_IN_R = crate::BitReader;
        ///Field `TMR_MODE_IN` writer - timer in mode
        pub type TMR_MODE_IN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TMR_ALL_CLEAR` reader - force clear timer FIFO and count
        pub type TMR_ALL_CLEAR_R = crate::BitReader;
        ///Field `TMR_ALL_CLEAR` writer - force clear timer FIFO and count
        pub type TMR_ALL_CLEAR_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TMR_COUNT_EN` reader - timer count enable
        pub type TMR_COUNT_EN_R = crate::BitReader;
        ///Field `TMR_COUNT_EN` writer - timer count enable
        pub type TMR_COUNT_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TMR_OUT_EN` reader - timer output enable
        pub type TMR_OUT_EN_R = crate::BitReader;
        ///Field `TMR_OUT_EN` writer - timer output enable
        pub type TMR_OUT_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TMR_OUT_POLAR_RB_TMR_CAP_COUNT` reader - timer PWM output polarity _ Count sub-mode
        pub type TMR_OUT_POLAR_RB_TMR_CAP_COUNT_R = crate::BitReader;
        ///Field `TMR_OUT_POLAR_RB_TMR_CAP_COUNT` writer - timer PWM output polarity _ Count sub-mode
        pub type TMR_OUT_POLAR_RB_TMR_CAP_COUNT_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TMR_PWM_REPEAT_RB_TMR_CAP_EDGE` reader - timer PWM repeat mode _ timer capture edge mode
        pub type TMR_PWM_REPEAT_RB_TMR_CAP_EDGE_R = crate::FieldReader;
        ///Field `TMR_PWM_REPEAT_RB_TMR_CAP_EDGE` writer - timer PWM repeat mode _ timer capture edge mode
        pub type TMR_PWM_REPEAT_RB_TMR_CAP_EDGE_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        impl R {
            ///Bit 0 - timer in mode
            #[inline(always)]
            pub fn tmr_mode_in(&self) -> TMR_MODE_IN_R {
                TMR_MODE_IN_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - force clear timer FIFO and count
            #[inline(always)]
            pub fn tmr_all_clear(&self) -> TMR_ALL_CLEAR_R {
                TMR_ALL_CLEAR_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - timer count enable
            #[inline(always)]
            pub fn tmr_count_en(&self) -> TMR_COUNT_EN_R {
                TMR_COUNT_EN_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - timer output enable
            #[inline(always)]
            pub fn tmr_out_en(&self) -> TMR_OUT_EN_R {
                TMR_OUT_EN_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - timer PWM output polarity _ Count sub-mode
            #[inline(always)]
            pub fn tmr_out_polar_rb_tmr_cap_count(&self) -> TMR_OUT_POLAR_RB_TMR_CAP_COUNT_R {
                TMR_OUT_POLAR_RB_TMR_CAP_COUNT_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bits 6:7 - timer PWM repeat mode _ timer capture edge mode
            #[inline(always)]
            pub fn tmr_pwm_repeat_rb_tmr_cap_edge(&self) -> TMR_PWM_REPEAT_RB_TMR_CAP_EDGE_R {
                TMR_PWM_REPEAT_RB_TMR_CAP_EDGE_R::new((self.bits >> 6) & 3)
            }
        }
        impl W {
            ///Bit 0 - timer in mode
            #[inline(always)]
            #[must_use]
            pub fn tmr_mode_in(&mut self) -> TMR_MODE_IN_W<CTRL_MOD_SPEC> {
                TMR_MODE_IN_W::new(self, 0)
            }
            ///Bit 1 - force clear timer FIFO and count
            #[inline(always)]
            #[must_use]
            pub fn tmr_all_clear(&mut self) -> TMR_ALL_CLEAR_W<CTRL_MOD_SPEC> {
                TMR_ALL_CLEAR_W::new(self, 1)
            }
            ///Bit 2 - timer count enable
            #[inline(always)]
            #[must_use]
            pub fn tmr_count_en(&mut self) -> TMR_COUNT_EN_W<CTRL_MOD_SPEC> {
                TMR_COUNT_EN_W::new(self, 2)
            }
            ///Bit 3 - timer output enable
            #[inline(always)]
            #[must_use]
            pub fn tmr_out_en(&mut self) -> TMR_OUT_EN_W<CTRL_MOD_SPEC> {
                TMR_OUT_EN_W::new(self, 3)
            }
            ///Bit 4 - timer PWM output polarity _ Count sub-mode
            #[inline(always)]
            #[must_use]
            pub fn tmr_out_polar_rb_tmr_cap_count(
                &mut self,
            ) -> TMR_OUT_POLAR_RB_TMR_CAP_COUNT_W<CTRL_MOD_SPEC> {
                TMR_OUT_POLAR_RB_TMR_CAP_COUNT_W::new(self, 4)
            }
            ///Bits 6:7 - timer PWM repeat mode _ timer capture edge mode
            #[inline(always)]
            #[must_use]
            pub fn tmr_pwm_repeat_rb_tmr_cap_edge(
                &mut self,
            ) -> TMR_PWM_REPEAT_RB_TMR_CAP_EDGE_W<CTRL_MOD_SPEC> {
                TMR_PWM_REPEAT_RB_TMR_CAP_EDGE_W::new(self, 6)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///TMR1 mode control
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`ctrl_mod::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ctrl_mod::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct CTRL_MOD_SPEC;
        impl crate::RegisterSpec for CTRL_MOD_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`ctrl_mod::R`](R) reader structure
        impl crate::Readable for CTRL_MOD_SPEC {}
        ///`write(|w| ..)` method takes [`ctrl_mod::W`](W) writer structure
        impl crate::Writable for CTRL_MOD_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets CTRL_MOD to value 0x02
        impl crate::Resettable for CTRL_MOD_SPEC {
            const RESET_VALUE: u8 = 0x02;
        }
    }
    ///INTER_EN (rw) register accessor: TMR1 interrupt enable
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`inter_en::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`inter_en::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@inter_en`]
    ///module
    pub type INTER_EN = crate::Reg<inter_en::INTER_EN_SPEC>;
    ///TMR1 interrupt enable
    pub mod inter_en {
        ///Register `INTER_EN` reader
        pub type R = crate::R<INTER_EN_SPEC>;
        ///Register `INTER_EN` writer
        pub type W = crate::W<INTER_EN_SPEC>;
        ///Field `TMR_IE_CYC_END` reader - enable interrupt for timer capture count timeout or PWM cycle end
        pub type TMR_IE_CYC_END_R = crate::BitReader;
        ///Field `TMR_IE_CYC_END` writer - enable interrupt for timer capture count timeout or PWM cycle end
        pub type TMR_IE_CYC_END_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TMR_IE_DATA_ACT` reader - enable interrupt for timer capture input action or PWM trigger
        pub type TMR_IE_DATA_ACT_R = crate::BitReader;
        ///Field `TMR_IE_DATA_ACT` writer - enable interrupt for timer capture input action or PWM trigger
        pub type TMR_IE_DATA_ACT_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TMR_IE_FIFO_HF` reader - enable interrupt for timer FIFO half (capture fifo >=4 or PWM fifo lower than3)
        pub type TMR_IE_FIFO_HF_R = crate::BitReader;
        ///Field `TMR_IE_FIFO_HF` writer - enable interrupt for timer FIFO half (capture fifo >=4 or PWM fifo lower than3)
        pub type TMR_IE_FIFO_HF_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TMR_IE_DMA_END` reader - enable interrupt for timer1/2 DMA completion
        pub type TMR_IE_DMA_END_R = crate::BitReader;
        ///Field `TMR_IE_DMA_END` writer - enable interrupt for timer1/2 DMA completion
        pub type TMR_IE_DMA_END_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TMR_IE_FIFO_OV` reader - enable interrupt for timer FIFO overflow
        pub type TMR_IE_FIFO_OV_R = crate::BitReader;
        ///Field `TMR_IE_FIFO_OV` writer - enable interrupt for timer FIFO overflow
        pub type TMR_IE_FIFO_OV_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - enable interrupt for timer capture count timeout or PWM cycle end
            #[inline(always)]
            pub fn tmr_ie_cyc_end(&self) -> TMR_IE_CYC_END_R {
                TMR_IE_CYC_END_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - enable interrupt for timer capture input action or PWM trigger
            #[inline(always)]
            pub fn tmr_ie_data_act(&self) -> TMR_IE_DATA_ACT_R {
                TMR_IE_DATA_ACT_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - enable interrupt for timer FIFO half (capture fifo >=4 or PWM fifo lower than3)
            #[inline(always)]
            pub fn tmr_ie_fifo_hf(&self) -> TMR_IE_FIFO_HF_R {
                TMR_IE_FIFO_HF_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - enable interrupt for timer1/2 DMA completion
            #[inline(always)]
            pub fn tmr_ie_dma_end(&self) -> TMR_IE_DMA_END_R {
                TMR_IE_DMA_END_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - enable interrupt for timer FIFO overflow
            #[inline(always)]
            pub fn tmr_ie_fifo_ov(&self) -> TMR_IE_FIFO_OV_R {
                TMR_IE_FIFO_OV_R::new(((self.bits >> 4) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - enable interrupt for timer capture count timeout or PWM cycle end
            #[inline(always)]
            #[must_use]
            pub fn tmr_ie_cyc_end(&mut self) -> TMR_IE_CYC_END_W<INTER_EN_SPEC> {
                TMR_IE_CYC_END_W::new(self, 0)
            }
            ///Bit 1 - enable interrupt for timer capture input action or PWM trigger
            #[inline(always)]
            #[must_use]
            pub fn tmr_ie_data_act(&mut self) -> TMR_IE_DATA_ACT_W<INTER_EN_SPEC> {
                TMR_IE_DATA_ACT_W::new(self, 1)
            }
            ///Bit 2 - enable interrupt for timer FIFO half (capture fifo >=4 or PWM fifo lower than3)
            #[inline(always)]
            #[must_use]
            pub fn tmr_ie_fifo_hf(&mut self) -> TMR_IE_FIFO_HF_W<INTER_EN_SPEC> {
                TMR_IE_FIFO_HF_W::new(self, 2)
            }
            ///Bit 3 - enable interrupt for timer1/2 DMA completion
            #[inline(always)]
            #[must_use]
            pub fn tmr_ie_dma_end(&mut self) -> TMR_IE_DMA_END_W<INTER_EN_SPEC> {
                TMR_IE_DMA_END_W::new(self, 3)
            }
            ///Bit 4 - enable interrupt for timer FIFO overflow
            #[inline(always)]
            #[must_use]
            pub fn tmr_ie_fifo_ov(&mut self) -> TMR_IE_FIFO_OV_W<INTER_EN_SPEC> {
                TMR_IE_FIFO_OV_W::new(self, 4)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///TMR1 interrupt enable
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`inter_en::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`inter_en::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct INTER_EN_SPEC;
        impl crate::RegisterSpec for INTER_EN_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`inter_en::R`](R) reader structure
        impl crate::Readable for INTER_EN_SPEC {}
        ///`write(|w| ..)` method takes [`inter_en::W`](W) writer structure
        impl crate::Writable for INTER_EN_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets INTER_EN to value 0
        impl crate::Resettable for INTER_EN_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///INT_FLAG (rw) register accessor: TMR1 interrupt flag
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`int_flag::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`int_flag::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@int_flag`]
    ///module
    pub type INT_FLAG = crate::Reg<int_flag::INT_FLAG_SPEC>;
    ///TMR1 interrupt flag
    pub mod int_flag {
        ///Register `INT_FLAG` reader
        pub type R = crate::R<INT_FLAG_SPEC>;
        ///Register `INT_FLAG` writer
        pub type W = crate::W<INT_FLAG_SPEC>;
        ///Field `TMR_IF_CYC_END` reader - interrupt flag for timer capture count timeout or PWM cycle end
        pub type TMR_IF_CYC_END_R = crate::BitReader;
        ///Field `TMR_IF_CYC_END` writer - interrupt flag for timer capture count timeout or PWM cycle end
        pub type TMR_IF_CYC_END_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TMR_IF_DATA_ACT` reader - interrupt flag for timer capture input action or PWM trigger
        pub type TMR_IF_DATA_ACT_R = crate::BitReader;
        ///Field `TMR_IF_DATA_ACT` writer - interrupt flag for timer capture input action or PWM trigger
        pub type TMR_IF_DATA_ACT_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TMR_IF_FIFO_HF` reader - interrupt flag for timer FIFO half (capture fifo >=4 or PWM fifo lower than 3)
        pub type TMR_IF_FIFO_HF_R = crate::BitReader;
        ///Field `TMR_IF_FIFO_HF` writer - interrupt flag for timer FIFO half (capture fifo >=4 or PWM fifo lower than 3)
        pub type TMR_IF_FIFO_HF_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TMR_IF_DMA_END` reader - interrupt flag for timer1_2 DMA completion
        pub type TMR_IF_DMA_END_R = crate::BitReader;
        ///Field `TMR_IF_DMA_END` writer - interrupt flag for timer1_2 DMA completion
        pub type TMR_IF_DMA_END_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TMR_IF_FIFO_OV` reader - interrupt flag for timer FIFO overflow
        pub type TMR_IF_FIFO_OV_R = crate::BitReader;
        ///Field `TMR_IF_FIFO_OV` writer - interrupt flag for timer FIFO overflow
        pub type TMR_IF_FIFO_OV_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - interrupt flag for timer capture count timeout or PWM cycle end
            #[inline(always)]
            pub fn tmr_if_cyc_end(&self) -> TMR_IF_CYC_END_R {
                TMR_IF_CYC_END_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - interrupt flag for timer capture input action or PWM trigger
            #[inline(always)]
            pub fn tmr_if_data_act(&self) -> TMR_IF_DATA_ACT_R {
                TMR_IF_DATA_ACT_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - interrupt flag for timer FIFO half (capture fifo >=4 or PWM fifo lower than 3)
            #[inline(always)]
            pub fn tmr_if_fifo_hf(&self) -> TMR_IF_FIFO_HF_R {
                TMR_IF_FIFO_HF_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - interrupt flag for timer1_2 DMA completion
            #[inline(always)]
            pub fn tmr_if_dma_end(&self) -> TMR_IF_DMA_END_R {
                TMR_IF_DMA_END_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - interrupt flag for timer FIFO overflow
            #[inline(always)]
            pub fn tmr_if_fifo_ov(&self) -> TMR_IF_FIFO_OV_R {
                TMR_IF_FIFO_OV_R::new(((self.bits >> 4) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - interrupt flag for timer capture count timeout or PWM cycle end
            #[inline(always)]
            #[must_use]
            pub fn tmr_if_cyc_end(&mut self) -> TMR_IF_CYC_END_W<INT_FLAG_SPEC> {
                TMR_IF_CYC_END_W::new(self, 0)
            }
            ///Bit 1 - interrupt flag for timer capture input action or PWM trigger
            #[inline(always)]
            #[must_use]
            pub fn tmr_if_data_act(&mut self) -> TMR_IF_DATA_ACT_W<INT_FLAG_SPEC> {
                TMR_IF_DATA_ACT_W::new(self, 1)
            }
            ///Bit 2 - interrupt flag for timer FIFO half (capture fifo >=4 or PWM fifo lower than 3)
            #[inline(always)]
            #[must_use]
            pub fn tmr_if_fifo_hf(&mut self) -> TMR_IF_FIFO_HF_W<INT_FLAG_SPEC> {
                TMR_IF_FIFO_HF_W::new(self, 2)
            }
            ///Bit 3 - interrupt flag for timer1_2 DMA completion
            #[inline(always)]
            #[must_use]
            pub fn tmr_if_dma_end(&mut self) -> TMR_IF_DMA_END_W<INT_FLAG_SPEC> {
                TMR_IF_DMA_END_W::new(self, 3)
            }
            ///Bit 4 - interrupt flag for timer FIFO overflow
            #[inline(always)]
            #[must_use]
            pub fn tmr_if_fifo_ov(&mut self) -> TMR_IF_FIFO_OV_W<INT_FLAG_SPEC> {
                TMR_IF_FIFO_OV_W::new(self, 4)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///TMR1 interrupt flag
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`int_flag::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`int_flag::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct INT_FLAG_SPEC;
        impl crate::RegisterSpec for INT_FLAG_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`int_flag::R`](R) reader structure
        impl crate::Readable for INT_FLAG_SPEC {}
        ///`write(|w| ..)` method takes [`int_flag::W`](W) writer structure
        impl crate::Writable for INT_FLAG_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets INT_FLAG to value 0
        impl crate::Resettable for INT_FLAG_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///FIFO_COUNT (r) register accessor: TMR1 FIFO count status
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`fifo_count::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@fifo_count`]
    ///module
    pub type FIFO_COUNT = crate::Reg<fifo_count::FIFO_COUNT_SPEC>;
    ///TMR1 FIFO count status
    pub mod fifo_count {
        ///Register `FIFO_COUNT` reader
        pub type R = crate::R<FIFO_COUNT_SPEC>;
        ///Field `FIFO_COUNT` reader - TMR FIFO count status
        pub type FIFO_COUNT_R = crate::FieldReader;
        impl R {
            ///Bits 0:7 - TMR FIFO count status
            #[inline(always)]
            pub fn fifo_count(&self) -> FIFO_COUNT_R {
                FIFO_COUNT_R::new(self.bits)
            }
        }
        ///TMR1 FIFO count status
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`fifo_count::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct FIFO_COUNT_SPEC;
        impl crate::RegisterSpec for FIFO_COUNT_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`fifo_count::R`](R) reader structure
        impl crate::Readable for FIFO_COUNT_SPEC {}
        ///`reset()` method sets FIFO_COUNT to value 0
        impl crate::Resettable for FIFO_COUNT_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///COUNT (r) register accessor: TMR1 current count
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`count::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@count`]
    ///module
    pub type COUNT = crate::Reg<count::COUNT_SPEC>;
    ///TMR1 current count
    pub mod count {
        ///Register `COUNT` reader
        pub type R = crate::R<COUNT_SPEC>;
        ///Field `COUNT` reader - TMR current count
        pub type COUNT_R = crate::FieldReader<u32>;
        impl R {
            ///Bits 0:31 - TMR current count
            #[inline(always)]
            pub fn count(&self) -> COUNT_R {
                COUNT_R::new(self.bits)
            }
        }
        ///TMR1 current count
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`count::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct COUNT_SPEC;
        impl crate::RegisterSpec for COUNT_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`count::R`](R) reader structure
        impl crate::Readable for COUNT_SPEC {}
        ///`reset()` method sets COUNT to value 0
        impl crate::Resettable for COUNT_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///CNT_END (rw) register accessor: TMR1 end count value, only low 26 bit
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`cnt_end::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cnt_end::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@cnt_end`]
    ///module
    pub type CNT_END = crate::Reg<cnt_end::CNT_END_SPEC>;
    ///TMR1 end count value, only low 26 bit
    pub mod cnt_end {
        ///Register `CNT_END` reader
        pub type R = crate::R<CNT_END_SPEC>;
        ///Register `CNT_END` writer
        pub type W = crate::W<CNT_END_SPEC>;
        ///Field `CNT_END` reader - TMR current count
        pub type CNT_END_R = crate::FieldReader<u32>;
        ///Field `CNT_END` writer - TMR current count
        pub type CNT_END_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - TMR current count
            #[inline(always)]
            pub fn cnt_end(&self) -> CNT_END_R {
                CNT_END_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - TMR current count
            #[inline(always)]
            #[must_use]
            pub fn cnt_end(&mut self) -> CNT_END_W<CNT_END_SPEC> {
                CNT_END_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///TMR1 end count value, only low 26 bit
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`cnt_end::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cnt_end::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct CNT_END_SPEC;
        impl crate::RegisterSpec for CNT_END_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`cnt_end::R`](R) reader structure
        impl crate::Readable for CNT_END_SPEC {}
        ///`write(|w| ..)` method takes [`cnt_end::W`](W) writer structure
        impl crate::Writable for CNT_END_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets CNT_END to value 0
        impl crate::Resettable for CNT_END_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///FIFO (rw) register accessor: TMR1 FIFO only low 26 bit
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`fifo::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`fifo::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@fifo`]
    ///module
    pub type FIFO = crate::Reg<fifo::FIFO_SPEC>;
    ///TMR1 FIFO only low 26 bit
    pub mod fifo {
        ///Register `FIFO` reader
        pub type R = crate::R<FIFO_SPEC>;
        ///Register `FIFO` writer
        pub type W = crate::W<FIFO_SPEC>;
        ///Field `FIFO` reader - TMR current count
        pub type FIFO_R = crate::FieldReader<u32>;
        ///Field `FIFO` writer - TMR current count
        pub type FIFO_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - TMR current count
            #[inline(always)]
            pub fn fifo(&self) -> FIFO_R {
                FIFO_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - TMR current count
            #[inline(always)]
            #[must_use]
            pub fn fifo(&mut self) -> FIFO_W<FIFO_SPEC> {
                FIFO_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///TMR1 FIFO only low 26 bit
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`fifo::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`fifo::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct FIFO_SPEC;
        impl crate::RegisterSpec for FIFO_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`fifo::R`](R) reader structure
        impl crate::Readable for FIFO_SPEC {}
        ///`write(|w| ..)` method takes [`fifo::W`](W) writer structure
        impl crate::Writable for FIFO_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets FIFO to value 0
        impl crate::Resettable for FIFO_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///CTRL_DMA (rw) register accessor: TMR1 DMA control
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`ctrl_dma::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ctrl_dma::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@ctrl_dma`]
    ///module
    pub type CTRL_DMA = crate::Reg<ctrl_dma::CTRL_DMA_SPEC>;
    ///TMR1 DMA control
    pub mod ctrl_dma {
        ///Register `CTRL_DMA` reader
        pub type R = crate::R<CTRL_DMA_SPEC>;
        ///Register `CTRL_DMA` writer
        pub type W = crate::W<CTRL_DMA_SPEC>;
        ///Field `TMR_DMA_ENABLE` reader - timer1/2 DMA enable
        pub type TMR_DMA_ENABLE_R = crate::BitReader;
        ///Field `TMR_DMA_ENABLE` writer - timer1/2 DMA enable
        pub type TMR_DMA_ENABLE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TMR_DMA_LOOP` reader - timer1/2 DMA address loop enable
        pub type TMR_DMA_LOOP_R = crate::BitReader;
        ///Field `TMR_DMA_LOOP` writer - timer1/2 DMA address loop enable
        pub type TMR_DMA_LOOP_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - timer1/2 DMA enable
            #[inline(always)]
            pub fn tmr_dma_enable(&self) -> TMR_DMA_ENABLE_R {
                TMR_DMA_ENABLE_R::new((self.bits & 1) != 0)
            }
            ///Bit 2 - timer1/2 DMA address loop enable
            #[inline(always)]
            pub fn tmr_dma_loop(&self) -> TMR_DMA_LOOP_R {
                TMR_DMA_LOOP_R::new(((self.bits >> 2) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - timer1/2 DMA enable
            #[inline(always)]
            #[must_use]
            pub fn tmr_dma_enable(&mut self) -> TMR_DMA_ENABLE_W<CTRL_DMA_SPEC> {
                TMR_DMA_ENABLE_W::new(self, 0)
            }
            ///Bit 2 - timer1/2 DMA address loop enable
            #[inline(always)]
            #[must_use]
            pub fn tmr_dma_loop(&mut self) -> TMR_DMA_LOOP_W<CTRL_DMA_SPEC> {
                TMR_DMA_LOOP_W::new(self, 2)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///TMR1 DMA control
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`ctrl_dma::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ctrl_dma::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct CTRL_DMA_SPEC;
        impl crate::RegisterSpec for CTRL_DMA_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`ctrl_dma::R`](R) reader structure
        impl crate::Readable for CTRL_DMA_SPEC {}
        ///`write(|w| ..)` method takes [`ctrl_dma::W`](W) writer structure
        impl crate::Writable for CTRL_DMA_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets CTRL_DMA to value 0
        impl crate::Resettable for CTRL_DMA_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///DMA_NOW (rw) register accessor: TMR1 DMA current address
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`dma_now::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dma_now::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@dma_now`]
    ///module
    pub type DMA_NOW = crate::Reg<dma_now::DMA_NOW_SPEC>;
    ///TMR1 DMA current address
    pub mod dma_now {
        ///Register `DMA_NOW` reader
        pub type R = crate::R<DMA_NOW_SPEC>;
        ///Register `DMA_NOW` writer
        pub type W = crate::W<DMA_NOW_SPEC>;
        ///Field `DMA_NOW` reader - TMR DMA current address
        pub type DMA_NOW_R = crate::FieldReader<u32>;
        ///Field `DMA_NOW` writer - TMR DMA current address
        pub type DMA_NOW_W<'a, REG> = crate::FieldWriter<'a, REG, 18, u32>;
        impl R {
            ///Bits 0:17 - TMR DMA current address
            #[inline(always)]
            pub fn dma_now(&self) -> DMA_NOW_R {
                DMA_NOW_R::new(self.bits & 0x0003_ffff)
            }
        }
        impl W {
            ///Bits 0:17 - TMR DMA current address
            #[inline(always)]
            #[must_use]
            pub fn dma_now(&mut self) -> DMA_NOW_W<DMA_NOW_SPEC> {
                DMA_NOW_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///TMR1 DMA current address
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`dma_now::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dma_now::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct DMA_NOW_SPEC;
        impl crate::RegisterSpec for DMA_NOW_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`dma_now::R`](R) reader structure
        impl crate::Readable for DMA_NOW_SPEC {}
        ///`write(|w| ..)` method takes [`dma_now::W`](W) writer structure
        impl crate::Writable for DMA_NOW_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets DMA_NOW to value 0
        impl crate::Resettable for DMA_NOW_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///DMA_BEG (rw) register accessor: TMR1 DMA begin address
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`dma_beg::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dma_beg::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@dma_beg`]
    ///module
    pub type DMA_BEG = crate::Reg<dma_beg::DMA_BEG_SPEC>;
    ///TMR1 DMA begin address
    pub mod dma_beg {
        ///Register `DMA_BEG` reader
        pub type R = crate::R<DMA_BEG_SPEC>;
        ///Register `DMA_BEG` writer
        pub type W = crate::W<DMA_BEG_SPEC>;
        ///Field `DMA_BEG` reader - TMR1 DMA begin address
        pub type DMA_BEG_R = crate::FieldReader<u32>;
        ///Field `DMA_BEG` writer - TMR1 DMA begin address
        pub type DMA_BEG_W<'a, REG> = crate::FieldWriter<'a, REG, 18, u32>;
        impl R {
            ///Bits 0:17 - TMR1 DMA begin address
            #[inline(always)]
            pub fn dma_beg(&self) -> DMA_BEG_R {
                DMA_BEG_R::new(self.bits & 0x0003_ffff)
            }
        }
        impl W {
            ///Bits 0:17 - TMR1 DMA begin address
            #[inline(always)]
            #[must_use]
            pub fn dma_beg(&mut self) -> DMA_BEG_W<DMA_BEG_SPEC> {
                DMA_BEG_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///TMR1 DMA begin address
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`dma_beg::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dma_beg::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct DMA_BEG_SPEC;
        impl crate::RegisterSpec for DMA_BEG_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`dma_beg::R`](R) reader structure
        impl crate::Readable for DMA_BEG_SPEC {}
        ///`write(|w| ..)` method takes [`dma_beg::W`](W) writer structure
        impl crate::Writable for DMA_BEG_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets DMA_BEG to value 0
        impl crate::Resettable for DMA_BEG_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///DMA_END (rw) register accessor: TMR1 DMA end address
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`dma_end::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dma_end::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@dma_end`]
    ///module
    pub type DMA_END = crate::Reg<dma_end::DMA_END_SPEC>;
    ///TMR1 DMA end address
    pub mod dma_end {
        ///Register `DMA_END` reader
        pub type R = crate::R<DMA_END_SPEC>;
        ///Register `DMA_END` writer
        pub type W = crate::W<DMA_END_SPEC>;
        ///Field `DMA_END` reader - TMR1 DMA end address
        pub type DMA_END_R = crate::FieldReader<u32>;
        ///Field `DMA_END` writer - TMR1 DMA end address
        pub type DMA_END_W<'a, REG> = crate::FieldWriter<'a, REG, 18, u32>;
        impl R {
            ///Bits 0:17 - TMR1 DMA end address
            #[inline(always)]
            pub fn dma_end(&self) -> DMA_END_R {
                DMA_END_R::new(self.bits & 0x0003_ffff)
            }
        }
        impl W {
            ///Bits 0:17 - TMR1 DMA end address
            #[inline(always)]
            #[must_use]
            pub fn dma_end(&mut self) -> DMA_END_W<DMA_END_SPEC> {
                DMA_END_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///TMR1 DMA end address
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`dma_end::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dma_end::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct DMA_END_SPEC;
        impl crate::RegisterSpec for DMA_END_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`dma_end::R`](R) reader structure
        impl crate::Readable for DMA_END_SPEC {}
        ///`write(|w| ..)` method takes [`dma_end::W`](W) writer structure
        impl crate::Writable for DMA_END_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets DMA_END to value 0
        impl crate::Resettable for DMA_END_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
}
///TMR2 register
pub struct TMR2 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for TMR2 {}
impl TMR2 {
    ///Pointer to the register block
    pub const PTR: *const tmr1::RegisterBlock = 0x4000_2800 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const tmr1::RegisterBlock {
        Self::PTR
    }
    /// Steal an instance of this peripheral
    ///
    /// # Safety
    ///
    /// Ensure that the new instance of the peripheral cannot be used in a way
    /// that may race with any existing instances, for example by only
    /// accessing read-only or write-only registers, or by consuming the
    /// original peripheral and using critical sections to coordinate
    /// access between multiple new instances.
    ///
    /// Additionally, other software such as HALs may rely on only one
    /// peripheral instance existing to ensure memory safety; ensure
    /// no stolen instances are passed to such software.
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for TMR2 {
    type Target = tmr1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for TMR2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("TMR2").finish()
    }
}
///TMR2 register
pub use self::tmr1 as tmr2;
///UART0 register
pub struct UART0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for UART0 {}
impl UART0 {
    ///Pointer to the register block
    pub const PTR: *const uart0::RegisterBlock = 0x4000_3000 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const uart0::RegisterBlock {
        Self::PTR
    }
    /// Steal an instance of this peripheral
    ///
    /// # Safety
    ///
    /// Ensure that the new instance of the peripheral cannot be used in a way
    /// that may race with any existing instances, for example by only
    /// accessing read-only or write-only registers, or by consuming the
    /// original peripheral and using critical sections to coordinate
    /// access between multiple new instances.
    ///
    /// Additionally, other software such as HALs may rely on only one
    /// peripheral instance existing to ensure memory safety; ensure
    /// no stolen instances are passed to such software.
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for UART0 {
    type Target = uart0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for UART0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("UART0").finish()
    }
}
///UART0 register
pub mod uart0 {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        mcr: MCR,
        ier: IER,
        fcr: FCR,
        lcr: LCR,
        iir: IIR,
        lsr: LSR,
        msr: MSR,
        _reserved7: [u8; 0x01],
        _reserved_7_rbr: [u8; 0x01],
        _reserved8: [u8; 0x01],
        rfc: RFC,
        tfc: TFC,
        dl: DL,
        div: DIV,
        adr: ADR,
    }
    impl RegisterBlock {
        ///0x00 - UART0 modem control
        #[inline(always)]
        pub const fn mcr(&self) -> &MCR {
            &self.mcr
        }
        ///0x01 - UART0 interrupt enable
        #[inline(always)]
        pub const fn ier(&self) -> &IER {
            &self.ier
        }
        ///0x02 - UART0 FIFO control
        #[inline(always)]
        pub const fn fcr(&self) -> &FCR {
            &self.fcr
        }
        ///0x03 - UART0 line control
        #[inline(always)]
        pub const fn lcr(&self) -> &LCR {
            &self.lcr
        }
        ///0x04 - UART0 interrupt identification
        #[inline(always)]
        pub const fn iir(&self) -> &IIR {
            &self.iir
        }
        ///0x05 - UART0 line status
        #[inline(always)]
        pub const fn lsr(&self) -> &LSR {
            &self.lsr
        }
        ///0x06 - UART0 modem status
        #[inline(always)]
        pub const fn msr(&self) -> &MSR {
            &self.msr
        }
        ///0x08 - Transmit hold register
        #[inline(always)]
        pub const fn thr(&self) -> &THR {
            unsafe { &*(self as *const Self).cast::<u8>().add(8).cast() }
        }
        ///0x08 - Receive buffer register
        #[inline(always)]
        pub const fn rbr(&self) -> &RBR {
            unsafe { &*(self as *const Self).cast::<u8>().add(8).cast() }
        }
        ///0x0a - UART0 receiver FIFO count
        #[inline(always)]
        pub const fn rfc(&self) -> &RFC {
            &self.rfc
        }
        ///0x0b - UART0 transmitter FIFO count
        #[inline(always)]
        pub const fn tfc(&self) -> &TFC {
            &self.tfc
        }
        ///0x0c - UART0 divisor latch
        #[inline(always)]
        pub const fn dl(&self) -> &DL {
            &self.dl
        }
        ///0x0e - UART0 pre-divisor latch byte
        #[inline(always)]
        pub const fn div(&self) -> &DIV {
            &self.div
        }
        ///0x0f - UART0 slave address
        #[inline(always)]
        pub const fn adr(&self) -> &ADR {
            &self.adr
        }
    }
    ///MCR (rw) register accessor: UART0 modem control
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`mcr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`mcr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@mcr`]
    ///module
    pub type MCR = crate::Reg<mcr::MCR_SPEC>;
    ///UART0 modem control
    pub mod mcr {
        ///Register `MCR` reader
        pub type R = crate::R<MCR_SPEC>;
        ///Register `MCR` writer
        pub type W = crate::W<MCR_SPEC>;
        ///Field `MCR_DTR` reader - UART0 control DTR
        pub type MCR_DTR_R = crate::BitReader;
        ///Field `MCR_DTR` writer - UART0 control DTR
        pub type MCR_DTR_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `MCR_RTS` reader - UART0 control RTS
        pub type MCR_RTS_R = crate::BitReader;
        ///Field `MCR_RTS` writer - UART0 control RTS
        pub type MCR_RTS_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `MCR_OUT1` reader - UART0 control OUT1
        pub type MCR_OUT1_R = crate::BitReader;
        ///Field `MCR_OUT1` writer - UART0 control OUT1
        pub type MCR_OUT1_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `MCR_OUT2` reader - UART control OUT2
        pub type MCR_OUT2_R = crate::BitReader;
        ///Field `MCR_OUT2` writer - UART control OUT2
        pub type MCR_OUT2_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `MCR_LOOP` reader - UART0 enable local loop back
        pub type MCR_LOOP_R = crate::BitReader;
        ///Field `MCR_LOOP` writer - UART0 enable local loop back
        pub type MCR_LOOP_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `MCR_AU_FLOW_EN` reader - UART0 enable autoflow control
        pub type MCR_AU_FLOW_EN_R = crate::BitReader;
        ///Field `MCR_AU_FLOW_EN` writer - UART0 enable autoflow control
        pub type MCR_AU_FLOW_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `MCR_TNOW` reader - UART0 enable TNOW output on DTR pin
        pub type MCR_TNOW_R = crate::BitReader;
        ///Field `MCR_TNOW` writer - UART0 enable TNOW output on DTR pin
        pub type MCR_TNOW_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `MCR_HALF` reader - UART0 enable half-duplex
        pub type MCR_HALF_R = crate::BitReader;
        ///Field `MCR_HALF` writer - UART0 enable half-duplex
        pub type MCR_HALF_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - UART0 control DTR
            #[inline(always)]
            pub fn mcr_dtr(&self) -> MCR_DTR_R {
                MCR_DTR_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - UART0 control RTS
            #[inline(always)]
            pub fn mcr_rts(&self) -> MCR_RTS_R {
                MCR_RTS_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - UART0 control OUT1
            #[inline(always)]
            pub fn mcr_out1(&self) -> MCR_OUT1_R {
                MCR_OUT1_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - UART control OUT2
            #[inline(always)]
            pub fn mcr_out2(&self) -> MCR_OUT2_R {
                MCR_OUT2_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - UART0 enable local loop back
            #[inline(always)]
            pub fn mcr_loop(&self) -> MCR_LOOP_R {
                MCR_LOOP_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - UART0 enable autoflow control
            #[inline(always)]
            pub fn mcr_au_flow_en(&self) -> MCR_AU_FLOW_EN_R {
                MCR_AU_FLOW_EN_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - UART0 enable TNOW output on DTR pin
            #[inline(always)]
            pub fn mcr_tnow(&self) -> MCR_TNOW_R {
                MCR_TNOW_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - UART0 enable half-duplex
            #[inline(always)]
            pub fn mcr_half(&self) -> MCR_HALF_R {
                MCR_HALF_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - UART0 control DTR
            #[inline(always)]
            #[must_use]
            pub fn mcr_dtr(&mut self) -> MCR_DTR_W<MCR_SPEC> {
                MCR_DTR_W::new(self, 0)
            }
            ///Bit 1 - UART0 control RTS
            #[inline(always)]
            #[must_use]
            pub fn mcr_rts(&mut self) -> MCR_RTS_W<MCR_SPEC> {
                MCR_RTS_W::new(self, 1)
            }
            ///Bit 2 - UART0 control OUT1
            #[inline(always)]
            #[must_use]
            pub fn mcr_out1(&mut self) -> MCR_OUT1_W<MCR_SPEC> {
                MCR_OUT1_W::new(self, 2)
            }
            ///Bit 3 - UART control OUT2
            #[inline(always)]
            #[must_use]
            pub fn mcr_out2(&mut self) -> MCR_OUT2_W<MCR_SPEC> {
                MCR_OUT2_W::new(self, 3)
            }
            ///Bit 4 - UART0 enable local loop back
            #[inline(always)]
            #[must_use]
            pub fn mcr_loop(&mut self) -> MCR_LOOP_W<MCR_SPEC> {
                MCR_LOOP_W::new(self, 4)
            }
            ///Bit 5 - UART0 enable autoflow control
            #[inline(always)]
            #[must_use]
            pub fn mcr_au_flow_en(&mut self) -> MCR_AU_FLOW_EN_W<MCR_SPEC> {
                MCR_AU_FLOW_EN_W::new(self, 5)
            }
            ///Bit 6 - UART0 enable TNOW output on DTR pin
            #[inline(always)]
            #[must_use]
            pub fn mcr_tnow(&mut self) -> MCR_TNOW_W<MCR_SPEC> {
                MCR_TNOW_W::new(self, 6)
            }
            ///Bit 7 - UART0 enable half-duplex
            #[inline(always)]
            #[must_use]
            pub fn mcr_half(&mut self) -> MCR_HALF_W<MCR_SPEC> {
                MCR_HALF_W::new(self, 7)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///UART0 modem control
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`mcr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`mcr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct MCR_SPEC;
        impl crate::RegisterSpec for MCR_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`mcr::R`](R) reader structure
        impl crate::Readable for MCR_SPEC {}
        ///`write(|w| ..)` method takes [`mcr::W`](W) writer structure
        impl crate::Writable for MCR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets MCR to value 0
        impl crate::Resettable for MCR_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///IER (rw) register accessor: UART0 interrupt enable
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`ier::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ier::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@ier`]
    ///module
    pub type IER = crate::Reg<ier::IER_SPEC>;
    ///UART0 interrupt enable
    pub mod ier {
        ///Register `IER` reader
        pub type R = crate::R<IER_SPEC>;
        ///Register `IER` writer
        pub type W = crate::W<IER_SPEC>;
        ///Field `IER_RECV_RDY` reader - UART interrupt enable for receiver data ready
        pub type IER_RECV_RDY_R = crate::BitReader;
        ///Field `IER_RECV_RDY` writer - UART interrupt enable for receiver data ready
        pub type IER_RECV_RDY_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `IER_THR_EMPTY` reader - UART interrupt enable for THR empty
        pub type IER_THR_EMPTY_R = crate::BitReader;
        ///Field `IER_THR_EMPTY` writer - UART interrupt enable for THR empty
        pub type IER_THR_EMPTY_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `IER_LINE_STAT` reader - UART interrupt enable for receiver line status
        pub type IER_LINE_STAT_R = crate::BitReader;
        ///Field `IER_LINE_STAT` writer - UART interrupt enable for receiver line status
        pub type IER_LINE_STAT_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `IER_MODEM_CHG` reader - UART0 interrupt enable for modem status change
        pub type IER_MODEM_CHG_R = crate::BitReader;
        ///Field `IER_MODEM_CHG` writer - UART0 interrupt enable for modem status change
        pub type IER_MODEM_CHG_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `IER_DTR_EN` reader - UART0 DTR/TNOW output pin enable
        pub type IER_DTR_EN_R = crate::BitReader;
        ///Field `IER_DTR_EN` writer - UART0 DTR/TNOW output pin enable
        pub type IER_DTR_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `IER_RTS_EN` reader - UART0 RTS output pin enable
        pub type IER_RTS_EN_R = crate::BitReader;
        ///Field `IER_RTS_EN` writer - UART0 RTS output pin enable
        pub type IER_RTS_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `IER_TXD_EN` reader - UART TXD pin enable
        pub type IER_TXD_EN_R = crate::BitReader;
        ///Field `IER_TXD_EN` writer - UART TXD pin enable
        pub type IER_TXD_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `IER_RESET` reader - UART software reset control, high action, auto clear
        pub type IER_RESET_R = crate::BitReader;
        ///Field `IER_RESET` writer - UART software reset control, high action, auto clear
        pub type IER_RESET_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - UART interrupt enable for receiver data ready
            #[inline(always)]
            pub fn ier_recv_rdy(&self) -> IER_RECV_RDY_R {
                IER_RECV_RDY_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - UART interrupt enable for THR empty
            #[inline(always)]
            pub fn ier_thr_empty(&self) -> IER_THR_EMPTY_R {
                IER_THR_EMPTY_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - UART interrupt enable for receiver line status
            #[inline(always)]
            pub fn ier_line_stat(&self) -> IER_LINE_STAT_R {
                IER_LINE_STAT_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - UART0 interrupt enable for modem status change
            #[inline(always)]
            pub fn ier_modem_chg(&self) -> IER_MODEM_CHG_R {
                IER_MODEM_CHG_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - UART0 DTR/TNOW output pin enable
            #[inline(always)]
            pub fn ier_dtr_en(&self) -> IER_DTR_EN_R {
                IER_DTR_EN_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - UART0 RTS output pin enable
            #[inline(always)]
            pub fn ier_rts_en(&self) -> IER_RTS_EN_R {
                IER_RTS_EN_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - UART TXD pin enable
            #[inline(always)]
            pub fn ier_txd_en(&self) -> IER_TXD_EN_R {
                IER_TXD_EN_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - UART software reset control, high action, auto clear
            #[inline(always)]
            pub fn ier_reset(&self) -> IER_RESET_R {
                IER_RESET_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - UART interrupt enable for receiver data ready
            #[inline(always)]
            #[must_use]
            pub fn ier_recv_rdy(&mut self) -> IER_RECV_RDY_W<IER_SPEC> {
                IER_RECV_RDY_W::new(self, 0)
            }
            ///Bit 1 - UART interrupt enable for THR empty
            #[inline(always)]
            #[must_use]
            pub fn ier_thr_empty(&mut self) -> IER_THR_EMPTY_W<IER_SPEC> {
                IER_THR_EMPTY_W::new(self, 1)
            }
            ///Bit 2 - UART interrupt enable for receiver line status
            #[inline(always)]
            #[must_use]
            pub fn ier_line_stat(&mut self) -> IER_LINE_STAT_W<IER_SPEC> {
                IER_LINE_STAT_W::new(self, 2)
            }
            ///Bit 3 - UART0 interrupt enable for modem status change
            #[inline(always)]
            #[must_use]
            pub fn ier_modem_chg(&mut self) -> IER_MODEM_CHG_W<IER_SPEC> {
                IER_MODEM_CHG_W::new(self, 3)
            }
            ///Bit 4 - UART0 DTR/TNOW output pin enable
            #[inline(always)]
            #[must_use]
            pub fn ier_dtr_en(&mut self) -> IER_DTR_EN_W<IER_SPEC> {
                IER_DTR_EN_W::new(self, 4)
            }
            ///Bit 5 - UART0 RTS output pin enable
            #[inline(always)]
            #[must_use]
            pub fn ier_rts_en(&mut self) -> IER_RTS_EN_W<IER_SPEC> {
                IER_RTS_EN_W::new(self, 5)
            }
            ///Bit 6 - UART TXD pin enable
            #[inline(always)]
            #[must_use]
            pub fn ier_txd_en(&mut self) -> IER_TXD_EN_W<IER_SPEC> {
                IER_TXD_EN_W::new(self, 6)
            }
            ///Bit 7 - UART software reset control, high action, auto clear
            #[inline(always)]
            #[must_use]
            pub fn ier_reset(&mut self) -> IER_RESET_W<IER_SPEC> {
                IER_RESET_W::new(self, 7)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///UART0 interrupt enable
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`ier::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ier::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IER_SPEC;
        impl crate::RegisterSpec for IER_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`ier::R`](R) reader structure
        impl crate::Readable for IER_SPEC {}
        ///`write(|w| ..)` method takes [`ier::W`](W) writer structure
        impl crate::Writable for IER_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets IER to value 0
        impl crate::Resettable for IER_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///FCR (rw) register accessor: UART0 FIFO control
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`fcr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`fcr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@fcr`]
    ///module
    pub type FCR = crate::Reg<fcr::FCR_SPEC>;
    ///UART0 FIFO control
    pub mod fcr {
        ///Register `FCR` reader
        pub type R = crate::R<FCR_SPEC>;
        ///Register `FCR` writer
        pub type W = crate::W<FCR_SPEC>;
        ///Field `FCR_FIFO_EN` reader - UART FIFO enable
        pub type FCR_FIFO_EN_R = crate::BitReader;
        ///Field `FCR_FIFO_EN` writer - UART FIFO enable
        pub type FCR_FIFO_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FCR_RX_FIFO_CLR` reader - clear UART receiver FIFO, high action, auto clear
        pub type FCR_RX_FIFO_CLR_R = crate::BitReader;
        ///Field `FCR_RX_FIFO_CLR` writer - clear UART receiver FIFO, high action, auto clear
        pub type FCR_RX_FIFO_CLR_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FCR_TX_FIFO_CLR` reader - clear UART transmitter FIFO, high action, auto clear
        pub type FCR_TX_FIFO_CLR_R = crate::BitReader;
        ///Field `FCR_TX_FIFO_CLR` writer - clear UART transmitter FIFO, high action, auto clear
        pub type FCR_TX_FIFO_CLR_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FCR_FIFO_TRIG` reader - UART receiver FIFO trigger level
        pub type FCR_FIFO_TRIG_R = crate::FieldReader;
        ///Field `FCR_FIFO_TRIG` writer - UART receiver FIFO trigger level
        pub type FCR_FIFO_TRIG_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        impl R {
            ///Bit 0 - UART FIFO enable
            #[inline(always)]
            pub fn fcr_fifo_en(&self) -> FCR_FIFO_EN_R {
                FCR_FIFO_EN_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - clear UART receiver FIFO, high action, auto clear
            #[inline(always)]
            pub fn fcr_rx_fifo_clr(&self) -> FCR_RX_FIFO_CLR_R {
                FCR_RX_FIFO_CLR_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - clear UART transmitter FIFO, high action, auto clear
            #[inline(always)]
            pub fn fcr_tx_fifo_clr(&self) -> FCR_TX_FIFO_CLR_R {
                FCR_TX_FIFO_CLR_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bits 6:7 - UART receiver FIFO trigger level
            #[inline(always)]
            pub fn fcr_fifo_trig(&self) -> FCR_FIFO_TRIG_R {
                FCR_FIFO_TRIG_R::new((self.bits >> 6) & 3)
            }
        }
        impl W {
            ///Bit 0 - UART FIFO enable
            #[inline(always)]
            #[must_use]
            pub fn fcr_fifo_en(&mut self) -> FCR_FIFO_EN_W<FCR_SPEC> {
                FCR_FIFO_EN_W::new(self, 0)
            }
            ///Bit 1 - clear UART receiver FIFO, high action, auto clear
            #[inline(always)]
            #[must_use]
            pub fn fcr_rx_fifo_clr(&mut self) -> FCR_RX_FIFO_CLR_W<FCR_SPEC> {
                FCR_RX_FIFO_CLR_W::new(self, 1)
            }
            ///Bit 2 - clear UART transmitter FIFO, high action, auto clear
            #[inline(always)]
            #[must_use]
            pub fn fcr_tx_fifo_clr(&mut self) -> FCR_TX_FIFO_CLR_W<FCR_SPEC> {
                FCR_TX_FIFO_CLR_W::new(self, 2)
            }
            ///Bits 6:7 - UART receiver FIFO trigger level
            #[inline(always)]
            #[must_use]
            pub fn fcr_fifo_trig(&mut self) -> FCR_FIFO_TRIG_W<FCR_SPEC> {
                FCR_FIFO_TRIG_W::new(self, 6)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///UART0 FIFO control
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`fcr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`fcr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct FCR_SPEC;
        impl crate::RegisterSpec for FCR_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`fcr::R`](R) reader structure
        impl crate::Readable for FCR_SPEC {}
        ///`write(|w| ..)` method takes [`fcr::W`](W) writer structure
        impl crate::Writable for FCR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets FCR to value 0
        impl crate::Resettable for FCR_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///LCR (rw) register accessor: UART0 line control
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`lcr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`lcr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@lcr`]
    ///module
    pub type LCR = crate::Reg<lcr::LCR_SPEC>;
    ///UART0 line control
    pub mod lcr {
        ///Register `LCR` reader
        pub type R = crate::R<LCR_SPEC>;
        ///Register `LCR` writer
        pub type W = crate::W<LCR_SPEC>;
        ///Field `LCR_WORD_SZ` reader - UART word bit length
        pub type LCR_WORD_SZ_R = crate::FieldReader;
        ///Field `LCR_WORD_SZ` writer - UART word bit length
        pub type LCR_WORD_SZ_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `LCR_STOP_BIT` reader - UART stop bit length
        pub type LCR_STOP_BIT_R = crate::BitReader;
        ///Field `LCR_STOP_BIT` writer - UART stop bit length
        pub type LCR_STOP_BIT_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `LCR_PAR_EN` reader - UART parity enable
        pub type LCR_PAR_EN_R = crate::BitReader;
        ///Field `LCR_PAR_EN` writer - UART parity enable
        pub type LCR_PAR_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `LCR_PAR_MOD` reader - UART parity mode
        pub type LCR_PAR_MOD_R = crate::FieldReader;
        ///Field `LCR_PAR_MOD` writer - UART parity mode
        pub type LCR_PAR_MOD_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `LCR_BREAK_EN` reader - UART break control enable
        pub type LCR_BREAK_EN_R = crate::BitReader;
        ///Field `LCR_BREAK_EN` writer - UART break control enable
        pub type LCR_BREAK_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `LCR_DLAB_RB_LCR_GP_BIT` reader - UART reserved bit _UART general purpose bit
        pub type LCR_DLAB_RB_LCR_GP_BIT_R = crate::BitReader;
        ///Field `LCR_DLAB_RB_LCR_GP_BIT` writer - UART reserved bit _UART general purpose bit
        pub type LCR_DLAB_RB_LCR_GP_BIT_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bits 0:1 - UART word bit length
            #[inline(always)]
            pub fn lcr_word_sz(&self) -> LCR_WORD_SZ_R {
                LCR_WORD_SZ_R::new(self.bits & 3)
            }
            ///Bit 2 - UART stop bit length
            #[inline(always)]
            pub fn lcr_stop_bit(&self) -> LCR_STOP_BIT_R {
                LCR_STOP_BIT_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - UART parity enable
            #[inline(always)]
            pub fn lcr_par_en(&self) -> LCR_PAR_EN_R {
                LCR_PAR_EN_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bits 4:5 - UART parity mode
            #[inline(always)]
            pub fn lcr_par_mod(&self) -> LCR_PAR_MOD_R {
                LCR_PAR_MOD_R::new((self.bits >> 4) & 3)
            }
            ///Bit 6 - UART break control enable
            #[inline(always)]
            pub fn lcr_break_en(&self) -> LCR_BREAK_EN_R {
                LCR_BREAK_EN_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - UART reserved bit _UART general purpose bit
            #[inline(always)]
            pub fn lcr_dlab_rb_lcr_gp_bit(&self) -> LCR_DLAB_RB_LCR_GP_BIT_R {
                LCR_DLAB_RB_LCR_GP_BIT_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:1 - UART word bit length
            #[inline(always)]
            #[must_use]
            pub fn lcr_word_sz(&mut self) -> LCR_WORD_SZ_W<LCR_SPEC> {
                LCR_WORD_SZ_W::new(self, 0)
            }
            ///Bit 2 - UART stop bit length
            #[inline(always)]
            #[must_use]
            pub fn lcr_stop_bit(&mut self) -> LCR_STOP_BIT_W<LCR_SPEC> {
                LCR_STOP_BIT_W::new(self, 2)
            }
            ///Bit 3 - UART parity enable
            #[inline(always)]
            #[must_use]
            pub fn lcr_par_en(&mut self) -> LCR_PAR_EN_W<LCR_SPEC> {
                LCR_PAR_EN_W::new(self, 3)
            }
            ///Bits 4:5 - UART parity mode
            #[inline(always)]
            #[must_use]
            pub fn lcr_par_mod(&mut self) -> LCR_PAR_MOD_W<LCR_SPEC> {
                LCR_PAR_MOD_W::new(self, 4)
            }
            ///Bit 6 - UART break control enable
            #[inline(always)]
            #[must_use]
            pub fn lcr_break_en(&mut self) -> LCR_BREAK_EN_W<LCR_SPEC> {
                LCR_BREAK_EN_W::new(self, 6)
            }
            ///Bit 7 - UART reserved bit _UART general purpose bit
            #[inline(always)]
            #[must_use]
            pub fn lcr_dlab_rb_lcr_gp_bit(&mut self) -> LCR_DLAB_RB_LCR_GP_BIT_W<LCR_SPEC> {
                LCR_DLAB_RB_LCR_GP_BIT_W::new(self, 7)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///UART0 line control
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`lcr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`lcr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct LCR_SPEC;
        impl crate::RegisterSpec for LCR_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`lcr::R`](R) reader structure
        impl crate::Readable for LCR_SPEC {}
        ///`write(|w| ..)` method takes [`lcr::W`](W) writer structure
        impl crate::Writable for LCR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets LCR to value 0
        impl crate::Resettable for LCR_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///IIR (r) register accessor: UART0 interrupt identification
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iir::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iir`]
    ///module
    pub type IIR = crate::Reg<iir::IIR_SPEC>;
    ///UART0 interrupt identification
    pub mod iir {
        ///Register `IIR` reader
        pub type R = crate::R<IIR_SPEC>;
        ///Field `IIR_NO_INT` reader - UART no interrupt flag
        pub type IIR_NO_INT_R = crate::BitReader;
        ///Field `IIR_INT_MASK` reader - UART interrupt flag bit mask
        pub type IIR_INT_MASK_R = crate::FieldReader;
        ///Field `IIR_FIFO_ID` reader - UART FIFO enabled flag
        pub type IIR_FIFO_ID_R = crate::FieldReader;
        impl R {
            ///Bit 0 - UART no interrupt flag
            #[inline(always)]
            pub fn iir_no_int(&self) -> IIR_NO_INT_R {
                IIR_NO_INT_R::new((self.bits & 1) != 0)
            }
            ///Bits 1:3 - UART interrupt flag bit mask
            #[inline(always)]
            pub fn iir_int_mask(&self) -> IIR_INT_MASK_R {
                IIR_INT_MASK_R::new((self.bits >> 1) & 7)
            }
            ///Bits 6:7 - UART FIFO enabled flag
            #[inline(always)]
            pub fn iir_fifo_id(&self) -> IIR_FIFO_ID_R {
                IIR_FIFO_ID_R::new((self.bits >> 6) & 3)
            }
        }
        ///UART0 interrupt identification
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iir::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IIR_SPEC;
        impl crate::RegisterSpec for IIR_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`iir::R`](R) reader structure
        impl crate::Readable for IIR_SPEC {}
        ///`reset()` method sets IIR to value 0x01
        impl crate::Resettable for IIR_SPEC {
            const RESET_VALUE: u8 = 0x01;
        }
    }
    ///LSR (r) register accessor: UART0 line status
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`lsr::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@lsr`]
    ///module
    pub type LSR = crate::Reg<lsr::LSR_SPEC>;
    ///UART0 line status
    pub mod lsr {
        ///Register `LSR` reader
        pub type R = crate::R<LSR_SPEC>;
        ///Field `LSR_DATA_RDY` reader - UART receiver fifo data ready status
        pub type LSR_DATA_RDY_R = crate::BitReader;
        ///Field `LSR_OVER_ERR` reader - UART receiver overrun error
        pub type LSR_OVER_ERR_R = crate::BitReader;
        ///Field `LSR_PAR_ERR` reader - UART receiver frame error
        pub type LSR_PAR_ERR_R = crate::BitReader;
        ///Field `LSR_FRAME_ERR` reader - UART receiver frame error
        pub type LSR_FRAME_ERR_R = crate::BitReader;
        ///Field `LSR_BREAK_ERR` reader - UART receiver break error
        pub type LSR_BREAK_ERR_R = crate::BitReader;
        ///Field `LSR_TX_FIFO_EMP` reader - UART transmitter fifo empty status
        pub type LSR_TX_FIFO_EMP_R = crate::BitReader;
        ///Field `LSR_TX_ALL_EMP` reader - UART transmitter all empty status
        pub type LSR_TX_ALL_EMP_R = crate::BitReader;
        ///Field `LSR_ERR_RX_FIFO` reader - indicate error in UART receiver fifo
        pub type LSR_ERR_RX_FIFO_R = crate::BitReader;
        impl R {
            ///Bit 0 - UART receiver fifo data ready status
            #[inline(always)]
            pub fn lsr_data_rdy(&self) -> LSR_DATA_RDY_R {
                LSR_DATA_RDY_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - UART receiver overrun error
            #[inline(always)]
            pub fn lsr_over_err(&self) -> LSR_OVER_ERR_R {
                LSR_OVER_ERR_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - UART receiver frame error
            #[inline(always)]
            pub fn lsr_par_err(&self) -> LSR_PAR_ERR_R {
                LSR_PAR_ERR_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - UART receiver frame error
            #[inline(always)]
            pub fn lsr_frame_err(&self) -> LSR_FRAME_ERR_R {
                LSR_FRAME_ERR_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - UART receiver break error
            #[inline(always)]
            pub fn lsr_break_err(&self) -> LSR_BREAK_ERR_R {
                LSR_BREAK_ERR_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - UART transmitter fifo empty status
            #[inline(always)]
            pub fn lsr_tx_fifo_emp(&self) -> LSR_TX_FIFO_EMP_R {
                LSR_TX_FIFO_EMP_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - UART transmitter all empty status
            #[inline(always)]
            pub fn lsr_tx_all_emp(&self) -> LSR_TX_ALL_EMP_R {
                LSR_TX_ALL_EMP_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - indicate error in UART receiver fifo
            #[inline(always)]
            pub fn lsr_err_rx_fifo(&self) -> LSR_ERR_RX_FIFO_R {
                LSR_ERR_RX_FIFO_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        ///UART0 line status
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`lsr::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct LSR_SPEC;
        impl crate::RegisterSpec for LSR_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`lsr::R`](R) reader structure
        impl crate::Readable for LSR_SPEC {}
        ///`reset()` method sets LSR to value 0xc0
        impl crate::Resettable for LSR_SPEC {
            const RESET_VALUE: u8 = 0xc0;
        }
    }
    ///MSR (r) register accessor: UART0 modem status
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`msr::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@msr`]
    ///module
    pub type MSR = crate::Reg<msr::MSR_SPEC>;
    ///UART0 modem status
    pub mod msr {
        ///Register `MSR` reader
        pub type R = crate::R<MSR_SPEC>;
        ///Field `MSR_CTS_CHG` reader - UART0 CTS changed status, high action
        pub type MSR_CTS_CHG_R = crate::BitReader;
        ///Field `MSR_DSR_CHG` reader - UART0 DSR changed status, high action
        pub type MSR_DSR_CHG_R = crate::BitReader;
        ///Field `MSR_RI_CHG` reader - UART0 RI changed status, high action
        pub type MSR_RI_CHG_R = crate::BitReader;
        ///Field `MSR_DCD_CHG` reader - UART0 DCD changed status, high action
        pub type MSR_DCD_CHG_R = crate::BitReader;
        ///Field `MSR_CTS` reader - UART0 CTS action status
        pub type MSR_CTS_R = crate::BitReader;
        ///Field `MSR_DSR` reader - UART0 DSR action status
        pub type MSR_DSR_R = crate::BitReader;
        ///Field `MSR_RI` reader - UART0 RI action status
        pub type MSR_RI_R = crate::BitReader;
        ///Field `MSR_DCD` reader - UART0 DCD action status
        pub type MSR_DCD_R = crate::BitReader;
        impl R {
            ///Bit 0 - UART0 CTS changed status, high action
            #[inline(always)]
            pub fn msr_cts_chg(&self) -> MSR_CTS_CHG_R {
                MSR_CTS_CHG_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - UART0 DSR changed status, high action
            #[inline(always)]
            pub fn msr_dsr_chg(&self) -> MSR_DSR_CHG_R {
                MSR_DSR_CHG_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - UART0 RI changed status, high action
            #[inline(always)]
            pub fn msr_ri_chg(&self) -> MSR_RI_CHG_R {
                MSR_RI_CHG_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - UART0 DCD changed status, high action
            #[inline(always)]
            pub fn msr_dcd_chg(&self) -> MSR_DCD_CHG_R {
                MSR_DCD_CHG_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - UART0 CTS action status
            #[inline(always)]
            pub fn msr_cts(&self) -> MSR_CTS_R {
                MSR_CTS_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - UART0 DSR action status
            #[inline(always)]
            pub fn msr_dsr(&self) -> MSR_DSR_R {
                MSR_DSR_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - UART0 RI action status
            #[inline(always)]
            pub fn msr_ri(&self) -> MSR_RI_R {
                MSR_RI_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - UART0 DCD action status
            #[inline(always)]
            pub fn msr_dcd(&self) -> MSR_DCD_R {
                MSR_DCD_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        ///UART0 modem status
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`msr::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct MSR_SPEC;
        impl crate::RegisterSpec for MSR_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`msr::R`](R) reader structure
        impl crate::Readable for MSR_SPEC {}
        ///`reset()` method sets MSR to value 0
        impl crate::Resettable for MSR_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///RFC (r) register accessor: UART0 receiver FIFO count
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`rfc::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@rfc`]
    ///module
    pub type RFC = crate::Reg<rfc::RFC_SPEC>;
    ///UART0 receiver FIFO count
    pub mod rfc {
        ///Register `RFC` reader
        pub type R = crate::R<RFC_SPEC>;
        ///Field `UART_RFC` reader - UART receiver FIFO count
        pub type UART_RFC_R = crate::FieldReader;
        impl R {
            ///Bits 0:7 - UART receiver FIFO count
            #[inline(always)]
            pub fn uart_rfc(&self) -> UART_RFC_R {
                UART_RFC_R::new(self.bits)
            }
        }
        ///UART0 receiver FIFO count
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`rfc::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct RFC_SPEC;
        impl crate::RegisterSpec for RFC_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`rfc::R`](R) reader structure
        impl crate::Readable for RFC_SPEC {}
        ///`reset()` method sets RFC to value 0
        impl crate::Resettable for RFC_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///TFC (r) register accessor: UART0 transmitter FIFO count
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`tfc::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@tfc`]
    ///module
    pub type TFC = crate::Reg<tfc::TFC_SPEC>;
    ///UART0 transmitter FIFO count
    pub mod tfc {
        ///Register `TFC` reader
        pub type R = crate::R<TFC_SPEC>;
        ///Field `TFC` reader - UART transmitter FIFO count
        pub type TFC_R = crate::FieldReader;
        impl R {
            ///Bits 0:7 - UART transmitter FIFO count
            #[inline(always)]
            pub fn tfc(&self) -> TFC_R {
                TFC_R::new(self.bits)
            }
        }
        ///UART0 transmitter FIFO count
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`tfc::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct TFC_SPEC;
        impl crate::RegisterSpec for TFC_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`tfc::R`](R) reader structure
        impl crate::Readable for TFC_SPEC {}
        ///`reset()` method sets TFC to value 0
        impl crate::Resettable for TFC_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///DL (rw) register accessor: UART0 divisor latch
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`dl::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dl::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@dl`]
    ///module
    pub type DL = crate::Reg<dl::DL_SPEC>;
    ///UART0 divisor latch
    pub mod dl {
        ///Register `DL` reader
        pub type R = crate::R<DL_SPEC>;
        ///Register `DL` writer
        pub type W = crate::W<DL_SPEC>;
        ///Field `DL` reader - UART divisor latch
        pub type DL_R = crate::FieldReader<u16>;
        ///Field `DL` writer - UART divisor latch
        pub type DL_W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            ///Bits 0:15 - UART divisor latch
            #[inline(always)]
            pub fn dl(&self) -> DL_R {
                DL_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - UART divisor latch
            #[inline(always)]
            #[must_use]
            pub fn dl(&mut self) -> DL_W<DL_SPEC> {
                DL_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///UART0 divisor latch
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`dl::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dl::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct DL_SPEC;
        impl crate::RegisterSpec for DL_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`dl::R`](R) reader structure
        impl crate::Readable for DL_SPEC {}
        ///`write(|w| ..)` method takes [`dl::W`](W) writer structure
        impl crate::Writable for DL_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets DL to value 0
        impl crate::Resettable for DL_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///DIV (rw) register accessor: UART0 pre-divisor latch byte
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`div::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`div::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@div`]
    ///module
    pub type DIV = crate::Reg<div::DIV_SPEC>;
    ///UART0 pre-divisor latch byte
    pub mod div {
        ///Register `DIV` reader
        pub type R = crate::R<DIV_SPEC>;
        ///Register `DIV` writer
        pub type W = crate::W<DIV_SPEC>;
        ///Field `ADR` reader - UART pre-divisor latch byte
        pub type ADR_R = crate::FieldReader;
        ///Field `ADR` writer - UART pre-divisor latch byte
        pub type ADR_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            ///Bits 0:7 - UART pre-divisor latch byte
            #[inline(always)]
            pub fn adr(&self) -> ADR_R {
                ADR_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:7 - UART pre-divisor latch byte
            #[inline(always)]
            #[must_use]
            pub fn adr(&mut self) -> ADR_W<DIV_SPEC> {
                ADR_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///UART0 pre-divisor latch byte
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`div::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`div::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct DIV_SPEC;
        impl crate::RegisterSpec for DIV_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`div::R`](R) reader structure
        impl crate::Readable for DIV_SPEC {}
        ///`write(|w| ..)` method takes [`div::W`](W) writer structure
        impl crate::Writable for DIV_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets DIV to value 0
        impl crate::Resettable for DIV_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///ADR (rw) register accessor: UART0 slave address
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`adr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`adr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@adr`]
    ///module
    pub type ADR = crate::Reg<adr::ADR_SPEC>;
    ///UART0 slave address
    pub mod adr {
        ///Register `ADR` reader
        pub type R = crate::R<ADR_SPEC>;
        ///Register `ADR` writer
        pub type W = crate::W<ADR_SPEC>;
        ///Field `ADR` reader - UART0 slave address
        pub type ADR_R = crate::FieldReader;
        ///Field `ADR` writer - UART0 slave address
        pub type ADR_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            ///Bits 0:7 - UART0 slave address
            #[inline(always)]
            pub fn adr(&self) -> ADR_R {
                ADR_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:7 - UART0 slave address
            #[inline(always)]
            #[must_use]
            pub fn adr(&mut self) -> ADR_W<ADR_SPEC> {
                ADR_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///UART0 slave address
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`adr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`adr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct ADR_SPEC;
        impl crate::RegisterSpec for ADR_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`adr::R`](R) reader structure
        impl crate::Readable for ADR_SPEC {}
        ///`write(|w| ..)` method takes [`adr::W`](W) writer structure
        impl crate::Writable for ADR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets ADR to value 0xff
        impl crate::Resettable for ADR_SPEC {
            const RESET_VALUE: u8 = 0xff;
        }
    }
    ///RBR (rw) register accessor: Receive buffer register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`rbr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`rbr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@rbr`]
    ///module
    pub type RBR = crate::Reg<rbr::RBR_SPEC>;
    ///Receive buffer register
    pub mod rbr {
        ///Register `RBR` reader
        pub type R = crate::R<RBR_SPEC>;
        ///Register `RBR` writer
        pub type W = crate::W<RBR_SPEC>;
        ///Field `RBR` reader - Data receive buffer register
        pub type RBR_R = crate::FieldReader;
        ///Field `RBR` writer - Data receive buffer register
        pub type RBR_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            ///Bits 0:7 - Data receive buffer register
            #[inline(always)]
            pub fn rbr(&self) -> RBR_R {
                RBR_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:7 - Data receive buffer register
            #[inline(always)]
            #[must_use]
            pub fn rbr(&mut self) -> RBR_W<RBR_SPEC> {
                RBR_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Receive buffer register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`rbr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`rbr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct RBR_SPEC;
        impl crate::RegisterSpec for RBR_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`rbr::R`](R) reader structure
        impl crate::Readable for RBR_SPEC {}
        ///`write(|w| ..)` method takes [`rbr::W`](W) writer structure
        impl crate::Writable for RBR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets RBR to value 0
        impl crate::Resettable for RBR_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///THR (rw) register accessor: Transmit hold register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`thr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`thr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@thr`]
    ///module
    pub type THR = crate::Reg<thr::THR_SPEC>;
    ///Transmit hold register
    pub mod thr {
        ///Register `THR` reader
        pub type R = crate::R<THR_SPEC>;
        ///Register `THR` writer
        pub type W = crate::W<THR_SPEC>;
        ///Field `THR` reader - Data transmit hold register
        pub type THR_R = crate::FieldReader;
        ///Field `THR` writer - Data transmit hold register
        pub type THR_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            ///Bits 0:7 - Data transmit hold register
            #[inline(always)]
            pub fn thr(&self) -> THR_R {
                THR_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:7 - Data transmit hold register
            #[inline(always)]
            #[must_use]
            pub fn thr(&mut self) -> THR_W<THR_SPEC> {
                THR_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Transmit hold register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`thr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`thr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct THR_SPEC;
        impl crate::RegisterSpec for THR_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`thr::R`](R) reader structure
        impl crate::Readable for THR_SPEC {}
        ///`write(|w| ..)` method takes [`thr::W`](W) writer structure
        impl crate::Writable for THR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets THR to value 0
        impl crate::Resettable for THR_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
}
///UART1 register
pub struct UART1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for UART1 {}
impl UART1 {
    ///Pointer to the register block
    pub const PTR: *const uart1::RegisterBlock = 0x4000_3400 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const uart1::RegisterBlock {
        Self::PTR
    }
    /// Steal an instance of this peripheral
    ///
    /// # Safety
    ///
    /// Ensure that the new instance of the peripheral cannot be used in a way
    /// that may race with any existing instances, for example by only
    /// accessing read-only or write-only registers, or by consuming the
    /// original peripheral and using critical sections to coordinate
    /// access between multiple new instances.
    ///
    /// Additionally, other software such as HALs may rely on only one
    /// peripheral instance existing to ensure memory safety; ensure
    /// no stolen instances are passed to such software.
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for UART1 {
    type Target = uart1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for UART1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("UART1").finish()
    }
}
///UART1 register
pub mod uart1 {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        mcr: MCR,
        ier: IER,
        fcr: FCR,
        lcr: LCR,
        iir: IIR,
        lsr: LSR,
        _reserved6: [u8; 0x02],
        _reserved_6_rbr: [u8; 0x01],
        _reserved7: [u8; 0x01],
        rfc: RFC,
        tfc: TFC,
        dl: DL,
        div: DIV,
    }
    impl RegisterBlock {
        ///0x00 - UART1 modem control
        #[inline(always)]
        pub const fn mcr(&self) -> &MCR {
            &self.mcr
        }
        ///0x01 - UART1 interrupt enable
        #[inline(always)]
        pub const fn ier(&self) -> &IER {
            &self.ier
        }
        ///0x02 - UART1 FIFO control
        #[inline(always)]
        pub const fn fcr(&self) -> &FCR {
            &self.fcr
        }
        ///0x03 - UART1 line control
        #[inline(always)]
        pub const fn lcr(&self) -> &LCR {
            &self.lcr
        }
        ///0x04 - UART1 interrupt identification
        #[inline(always)]
        pub const fn iir(&self) -> &IIR {
            &self.iir
        }
        ///0x05 - UART1 line status
        #[inline(always)]
        pub const fn lsr(&self) -> &LSR {
            &self.lsr
        }
        ///0x08 - Transmit hold register
        #[inline(always)]
        pub const fn thr(&self) -> &THR {
            unsafe { &*(self as *const Self).cast::<u8>().add(8).cast() }
        }
        ///0x08 - Receive buffer register
        #[inline(always)]
        pub const fn rbr(&self) -> &RBR {
            unsafe { &*(self as *const Self).cast::<u8>().add(8).cast() }
        }
        ///0x0a - UART1 receiver FIFO count
        #[inline(always)]
        pub const fn rfc(&self) -> &RFC {
            &self.rfc
        }
        ///0x0b - UART1 transmitter FIFO count
        #[inline(always)]
        pub const fn tfc(&self) -> &TFC {
            &self.tfc
        }
        ///0x0c - UART1 divisor latch
        #[inline(always)]
        pub const fn dl(&self) -> &DL {
            &self.dl
        }
        ///0x0e - UART1 pre-divisor latch byte
        #[inline(always)]
        pub const fn div(&self) -> &DIV {
            &self.div
        }
    }
    ///MCR (rw) register accessor: UART1 modem control
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`mcr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`mcr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@mcr`]
    ///module
    pub type MCR = crate::Reg<mcr::MCR_SPEC>;
    ///UART1 modem control
    pub mod mcr {
        ///Register `MCR` reader
        pub type R = crate::R<MCR_SPEC>;
        ///Register `MCR` writer
        pub type W = crate::W<MCR_SPEC>;
        ///Field `MCR_OUT2` reader - UART1 control OUT2
        pub type MCR_OUT2_R = crate::BitReader;
        ///Field `MCR_OUT2` writer - UART1 control OUT2
        pub type MCR_OUT2_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 3 - UART1 control OUT2
            #[inline(always)]
            pub fn mcr_out2(&self) -> MCR_OUT2_R {
                MCR_OUT2_R::new(((self.bits >> 3) & 1) != 0)
            }
        }
        impl W {
            ///Bit 3 - UART1 control OUT2
            #[inline(always)]
            #[must_use]
            pub fn mcr_out2(&mut self) -> MCR_OUT2_W<MCR_SPEC> {
                MCR_OUT2_W::new(self, 3)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///UART1 modem control
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`mcr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`mcr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct MCR_SPEC;
        impl crate::RegisterSpec for MCR_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`mcr::R`](R) reader structure
        impl crate::Readable for MCR_SPEC {}
        ///`write(|w| ..)` method takes [`mcr::W`](W) writer structure
        impl crate::Writable for MCR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets MCR to value 0
        impl crate::Resettable for MCR_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///IER (rw) register accessor: UART1 interrupt enable
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`ier::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ier::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@ier`]
    ///module
    pub type IER = crate::Reg<ier::IER_SPEC>;
    ///UART1 interrupt enable
    pub mod ier {
        ///Register `IER` reader
        pub type R = crate::R<IER_SPEC>;
        ///Register `IER` writer
        pub type W = crate::W<IER_SPEC>;
        ///Field `IER_RECV_RDY` reader - UART interrupt enable for receiver data ready
        pub type IER_RECV_RDY_R = crate::BitReader;
        ///Field `IER_RECV_RDY` writer - UART interrupt enable for receiver data ready
        pub type IER_RECV_RDY_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `IER_THR_EMPTY` reader - UART interrupt enable for THR empty
        pub type IER_THR_EMPTY_R = crate::BitReader;
        ///Field `IER_THR_EMPTY` writer - UART interrupt enable for THR empty
        pub type IER_THR_EMPTY_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `IER_LINE_STAT` reader - UART interrupt enable for receiver line status
        pub type IER_LINE_STAT_R = crate::BitReader;
        ///Field `IER_LINE_STAT` writer - UART interrupt enable for receiver line status
        pub type IER_LINE_STAT_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `IER_TXD_EN` reader - UART TXD pin enable
        pub type IER_TXD_EN_R = crate::BitReader;
        ///Field `IER_TXD_EN` writer - UART TXD pin enable
        pub type IER_TXD_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `IER_RESET` reader - UART software reset control, high action, auto clear
        pub type IER_RESET_R = crate::BitReader;
        ///Field `IER_RESET` writer - UART software reset control, high action, auto clear
        pub type IER_RESET_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - UART interrupt enable for receiver data ready
            #[inline(always)]
            pub fn ier_recv_rdy(&self) -> IER_RECV_RDY_R {
                IER_RECV_RDY_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - UART interrupt enable for THR empty
            #[inline(always)]
            pub fn ier_thr_empty(&self) -> IER_THR_EMPTY_R {
                IER_THR_EMPTY_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - UART interrupt enable for receiver line status
            #[inline(always)]
            pub fn ier_line_stat(&self) -> IER_LINE_STAT_R {
                IER_LINE_STAT_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 6 - UART TXD pin enable
            #[inline(always)]
            pub fn ier_txd_en(&self) -> IER_TXD_EN_R {
                IER_TXD_EN_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - UART software reset control, high action, auto clear
            #[inline(always)]
            pub fn ier_reset(&self) -> IER_RESET_R {
                IER_RESET_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - UART interrupt enable for receiver data ready
            #[inline(always)]
            #[must_use]
            pub fn ier_recv_rdy(&mut self) -> IER_RECV_RDY_W<IER_SPEC> {
                IER_RECV_RDY_W::new(self, 0)
            }
            ///Bit 1 - UART interrupt enable for THR empty
            #[inline(always)]
            #[must_use]
            pub fn ier_thr_empty(&mut self) -> IER_THR_EMPTY_W<IER_SPEC> {
                IER_THR_EMPTY_W::new(self, 1)
            }
            ///Bit 2 - UART interrupt enable for receiver line status
            #[inline(always)]
            #[must_use]
            pub fn ier_line_stat(&mut self) -> IER_LINE_STAT_W<IER_SPEC> {
                IER_LINE_STAT_W::new(self, 2)
            }
            ///Bit 6 - UART TXD pin enable
            #[inline(always)]
            #[must_use]
            pub fn ier_txd_en(&mut self) -> IER_TXD_EN_W<IER_SPEC> {
                IER_TXD_EN_W::new(self, 6)
            }
            ///Bit 7 - UART software reset control, high action, auto clear
            #[inline(always)]
            #[must_use]
            pub fn ier_reset(&mut self) -> IER_RESET_W<IER_SPEC> {
                IER_RESET_W::new(self, 7)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///UART1 interrupt enable
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`ier::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ier::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IER_SPEC;
        impl crate::RegisterSpec for IER_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`ier::R`](R) reader structure
        impl crate::Readable for IER_SPEC {}
        ///`write(|w| ..)` method takes [`ier::W`](W) writer structure
        impl crate::Writable for IER_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets IER to value 0
        impl crate::Resettable for IER_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///FCR (rw) register accessor: UART1 FIFO control
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`fcr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`fcr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@fcr`]
    ///module
    pub type FCR = crate::Reg<fcr::FCR_SPEC>;
    ///UART1 FIFO control
    pub mod fcr {
        ///Register `FCR` reader
        pub type R = crate::R<FCR_SPEC>;
        ///Register `FCR` writer
        pub type W = crate::W<FCR_SPEC>;
        ///Field `FCR_FIFO_EN` reader - UART FIFO enable
        pub type FCR_FIFO_EN_R = crate::BitReader;
        ///Field `FCR_FIFO_EN` writer - UART FIFO enable
        pub type FCR_FIFO_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FCR_RX_FIFO_CLR` reader - clear UART receiver FIFO, high action, auto clear
        pub type FCR_RX_FIFO_CLR_R = crate::BitReader;
        ///Field `FCR_RX_FIFO_CLR` writer - clear UART receiver FIFO, high action, auto clear
        pub type FCR_RX_FIFO_CLR_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FCR_TX_FIFO_CLR` reader - clear UART transmitter FIFO, high action, auto clear
        pub type FCR_TX_FIFO_CLR_R = crate::BitReader;
        ///Field `FCR_TX_FIFO_CLR` writer - clear UART transmitter FIFO, high action, auto clear
        pub type FCR_TX_FIFO_CLR_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FCR_FIFO_TRIG` reader - UART receiver FIFO trigger level
        pub type FCR_FIFO_TRIG_R = crate::FieldReader;
        ///Field `FCR_FIFO_TRIG` writer - UART receiver FIFO trigger level
        pub type FCR_FIFO_TRIG_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        impl R {
            ///Bit 0 - UART FIFO enable
            #[inline(always)]
            pub fn fcr_fifo_en(&self) -> FCR_FIFO_EN_R {
                FCR_FIFO_EN_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - clear UART receiver FIFO, high action, auto clear
            #[inline(always)]
            pub fn fcr_rx_fifo_clr(&self) -> FCR_RX_FIFO_CLR_R {
                FCR_RX_FIFO_CLR_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - clear UART transmitter FIFO, high action, auto clear
            #[inline(always)]
            pub fn fcr_tx_fifo_clr(&self) -> FCR_TX_FIFO_CLR_R {
                FCR_TX_FIFO_CLR_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bits 6:7 - UART receiver FIFO trigger level
            #[inline(always)]
            pub fn fcr_fifo_trig(&self) -> FCR_FIFO_TRIG_R {
                FCR_FIFO_TRIG_R::new((self.bits >> 6) & 3)
            }
        }
        impl W {
            ///Bit 0 - UART FIFO enable
            #[inline(always)]
            #[must_use]
            pub fn fcr_fifo_en(&mut self) -> FCR_FIFO_EN_W<FCR_SPEC> {
                FCR_FIFO_EN_W::new(self, 0)
            }
            ///Bit 1 - clear UART receiver FIFO, high action, auto clear
            #[inline(always)]
            #[must_use]
            pub fn fcr_rx_fifo_clr(&mut self) -> FCR_RX_FIFO_CLR_W<FCR_SPEC> {
                FCR_RX_FIFO_CLR_W::new(self, 1)
            }
            ///Bit 2 - clear UART transmitter FIFO, high action, auto clear
            #[inline(always)]
            #[must_use]
            pub fn fcr_tx_fifo_clr(&mut self) -> FCR_TX_FIFO_CLR_W<FCR_SPEC> {
                FCR_TX_FIFO_CLR_W::new(self, 2)
            }
            ///Bits 6:7 - UART receiver FIFO trigger level
            #[inline(always)]
            #[must_use]
            pub fn fcr_fifo_trig(&mut self) -> FCR_FIFO_TRIG_W<FCR_SPEC> {
                FCR_FIFO_TRIG_W::new(self, 6)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///UART1 FIFO control
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`fcr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`fcr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct FCR_SPEC;
        impl crate::RegisterSpec for FCR_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`fcr::R`](R) reader structure
        impl crate::Readable for FCR_SPEC {}
        ///`write(|w| ..)` method takes [`fcr::W`](W) writer structure
        impl crate::Writable for FCR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets FCR to value 0
        impl crate::Resettable for FCR_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///LCR (rw) register accessor: UART1 line control
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`lcr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`lcr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@lcr`]
    ///module
    pub type LCR = crate::Reg<lcr::LCR_SPEC>;
    ///UART1 line control
    pub mod lcr {
        ///Register `LCR` reader
        pub type R = crate::R<LCR_SPEC>;
        ///Register `LCR` writer
        pub type W = crate::W<LCR_SPEC>;
        ///Field `LCR_WORD_SZ` reader - UART word bit length
        pub type LCR_WORD_SZ_R = crate::FieldReader;
        ///Field `LCR_WORD_SZ` writer - UART word bit length
        pub type LCR_WORD_SZ_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `LCR_STOP_BIT` reader - UART stop bit length
        pub type LCR_STOP_BIT_R = crate::BitReader;
        ///Field `LCR_STOP_BIT` writer - UART stop bit length
        pub type LCR_STOP_BIT_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `LCR_PAR_EN` reader - UART parity enable
        pub type LCR_PAR_EN_R = crate::BitReader;
        ///Field `LCR_PAR_EN` writer - UART parity enable
        pub type LCR_PAR_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `LCR_PAR_MOD` reader - UART parity mode
        pub type LCR_PAR_MOD_R = crate::FieldReader;
        ///Field `LCR_PAR_MOD` writer - UART parity mode
        pub type LCR_PAR_MOD_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `LCR_BREAK_EN` reader - UART break control enable
        pub type LCR_BREAK_EN_R = crate::BitReader;
        ///Field `LCR_BREAK_EN` writer - UART break control enable
        pub type LCR_BREAK_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `LCR_DLAB_RB_LCR_GP_BIT` reader - UART reserved bit _ UART general purpose bit
        pub type LCR_DLAB_RB_LCR_GP_BIT_R = crate::BitReader;
        ///Field `LCR_DLAB_RB_LCR_GP_BIT` writer - UART reserved bit _ UART general purpose bit
        pub type LCR_DLAB_RB_LCR_GP_BIT_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bits 0:1 - UART word bit length
            #[inline(always)]
            pub fn lcr_word_sz(&self) -> LCR_WORD_SZ_R {
                LCR_WORD_SZ_R::new(self.bits & 3)
            }
            ///Bit 2 - UART stop bit length
            #[inline(always)]
            pub fn lcr_stop_bit(&self) -> LCR_STOP_BIT_R {
                LCR_STOP_BIT_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - UART parity enable
            #[inline(always)]
            pub fn lcr_par_en(&self) -> LCR_PAR_EN_R {
                LCR_PAR_EN_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bits 4:5 - UART parity mode
            #[inline(always)]
            pub fn lcr_par_mod(&self) -> LCR_PAR_MOD_R {
                LCR_PAR_MOD_R::new((self.bits >> 4) & 3)
            }
            ///Bit 6 - UART break control enable
            #[inline(always)]
            pub fn lcr_break_en(&self) -> LCR_BREAK_EN_R {
                LCR_BREAK_EN_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - UART reserved bit _ UART general purpose bit
            #[inline(always)]
            pub fn lcr_dlab_rb_lcr_gp_bit(&self) -> LCR_DLAB_RB_LCR_GP_BIT_R {
                LCR_DLAB_RB_LCR_GP_BIT_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:1 - UART word bit length
            #[inline(always)]
            #[must_use]
            pub fn lcr_word_sz(&mut self) -> LCR_WORD_SZ_W<LCR_SPEC> {
                LCR_WORD_SZ_W::new(self, 0)
            }
            ///Bit 2 - UART stop bit length
            #[inline(always)]
            #[must_use]
            pub fn lcr_stop_bit(&mut self) -> LCR_STOP_BIT_W<LCR_SPEC> {
                LCR_STOP_BIT_W::new(self, 2)
            }
            ///Bit 3 - UART parity enable
            #[inline(always)]
            #[must_use]
            pub fn lcr_par_en(&mut self) -> LCR_PAR_EN_W<LCR_SPEC> {
                LCR_PAR_EN_W::new(self, 3)
            }
            ///Bits 4:5 - UART parity mode
            #[inline(always)]
            #[must_use]
            pub fn lcr_par_mod(&mut self) -> LCR_PAR_MOD_W<LCR_SPEC> {
                LCR_PAR_MOD_W::new(self, 4)
            }
            ///Bit 6 - UART break control enable
            #[inline(always)]
            #[must_use]
            pub fn lcr_break_en(&mut self) -> LCR_BREAK_EN_W<LCR_SPEC> {
                LCR_BREAK_EN_W::new(self, 6)
            }
            ///Bit 7 - UART reserved bit _ UART general purpose bit
            #[inline(always)]
            #[must_use]
            pub fn lcr_dlab_rb_lcr_gp_bit(&mut self) -> LCR_DLAB_RB_LCR_GP_BIT_W<LCR_SPEC> {
                LCR_DLAB_RB_LCR_GP_BIT_W::new(self, 7)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///UART1 line control
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`lcr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`lcr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct LCR_SPEC;
        impl crate::RegisterSpec for LCR_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`lcr::R`](R) reader structure
        impl crate::Readable for LCR_SPEC {}
        ///`write(|w| ..)` method takes [`lcr::W`](W) writer structure
        impl crate::Writable for LCR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets LCR to value 0
        impl crate::Resettable for LCR_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///IIR (r) register accessor: UART1 interrupt identification
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iir::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iir`]
    ///module
    pub type IIR = crate::Reg<iir::IIR_SPEC>;
    ///UART1 interrupt identification
    pub mod iir {
        ///Register `IIR` reader
        pub type R = crate::R<IIR_SPEC>;
        ///Field `IIR_NO_INT` reader - UART no interrupt flag
        pub type IIR_NO_INT_R = crate::BitReader;
        ///Field `IIR_INT_MASK` reader - UART interrupt flag bit mask
        pub type IIR_INT_MASK_R = crate::FieldReader;
        ///Field `IIR_FIFO_ID` reader - UART FIFO enabled flag
        pub type IIR_FIFO_ID_R = crate::FieldReader;
        impl R {
            ///Bit 0 - UART no interrupt flag
            #[inline(always)]
            pub fn iir_no_int(&self) -> IIR_NO_INT_R {
                IIR_NO_INT_R::new((self.bits & 1) != 0)
            }
            ///Bits 1:3 - UART interrupt flag bit mask
            #[inline(always)]
            pub fn iir_int_mask(&self) -> IIR_INT_MASK_R {
                IIR_INT_MASK_R::new((self.bits >> 1) & 7)
            }
            ///Bits 6:7 - UART FIFO enabled flag
            #[inline(always)]
            pub fn iir_fifo_id(&self) -> IIR_FIFO_ID_R {
                IIR_FIFO_ID_R::new((self.bits >> 6) & 3)
            }
        }
        ///UART1 interrupt identification
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iir::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IIR_SPEC;
        impl crate::RegisterSpec for IIR_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`iir::R`](R) reader structure
        impl crate::Readable for IIR_SPEC {}
        ///`reset()` method sets IIR to value 0x01
        impl crate::Resettable for IIR_SPEC {
            const RESET_VALUE: u8 = 0x01;
        }
    }
    ///LSR (r) register accessor: UART1 line status
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`lsr::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@lsr`]
    ///module
    pub type LSR = crate::Reg<lsr::LSR_SPEC>;
    ///UART1 line status
    pub mod lsr {
        ///Register `LSR` reader
        pub type R = crate::R<LSR_SPEC>;
        ///Field `LSR_DATA_RDY` reader - UART receiver fifo data ready status
        pub type LSR_DATA_RDY_R = crate::BitReader;
        ///Field `LSR_OVER_ERR` reader - UART receiver overrun error
        pub type LSR_OVER_ERR_R = crate::BitReader;
        ///Field `LSR_PAR_ERR` reader - UART receiver frame error
        pub type LSR_PAR_ERR_R = crate::BitReader;
        ///Field `LSR_FRAME_ERR` reader - UART receiver frame error
        pub type LSR_FRAME_ERR_R = crate::BitReader;
        ///Field `LSR_BREAK_ERR` reader - UART receiver break error
        pub type LSR_BREAK_ERR_R = crate::BitReader;
        ///Field `LSR_TX_FIFO_EMP` reader - UART transmitter fifo empty status
        pub type LSR_TX_FIFO_EMP_R = crate::BitReader;
        ///Field `LSR_TX_ALL_EMP` reader - UART transmitter all empty status
        pub type LSR_TX_ALL_EMP_R = crate::BitReader;
        ///Field `LSR_ERR_RX_FIFO` reader - indicate error in UART receiver fifo
        pub type LSR_ERR_RX_FIFO_R = crate::BitReader;
        impl R {
            ///Bit 0 - UART receiver fifo data ready status
            #[inline(always)]
            pub fn lsr_data_rdy(&self) -> LSR_DATA_RDY_R {
                LSR_DATA_RDY_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - UART receiver overrun error
            #[inline(always)]
            pub fn lsr_over_err(&self) -> LSR_OVER_ERR_R {
                LSR_OVER_ERR_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - UART receiver frame error
            #[inline(always)]
            pub fn lsr_par_err(&self) -> LSR_PAR_ERR_R {
                LSR_PAR_ERR_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - UART receiver frame error
            #[inline(always)]
            pub fn lsr_frame_err(&self) -> LSR_FRAME_ERR_R {
                LSR_FRAME_ERR_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - UART receiver break error
            #[inline(always)]
            pub fn lsr_break_err(&self) -> LSR_BREAK_ERR_R {
                LSR_BREAK_ERR_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - UART transmitter fifo empty status
            #[inline(always)]
            pub fn lsr_tx_fifo_emp(&self) -> LSR_TX_FIFO_EMP_R {
                LSR_TX_FIFO_EMP_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - UART transmitter all empty status
            #[inline(always)]
            pub fn lsr_tx_all_emp(&self) -> LSR_TX_ALL_EMP_R {
                LSR_TX_ALL_EMP_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - indicate error in UART receiver fifo
            #[inline(always)]
            pub fn lsr_err_rx_fifo(&self) -> LSR_ERR_RX_FIFO_R {
                LSR_ERR_RX_FIFO_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        ///UART1 line status
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`lsr::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct LSR_SPEC;
        impl crate::RegisterSpec for LSR_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`lsr::R`](R) reader structure
        impl crate::Readable for LSR_SPEC {}
        ///`reset()` method sets LSR to value 0xc0
        impl crate::Resettable for LSR_SPEC {
            const RESET_VALUE: u8 = 0xc0;
        }
    }
    ///RFC (r) register accessor: UART1 receiver FIFO count
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`rfc::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@rfc`]
    ///module
    pub type RFC = crate::Reg<rfc::RFC_SPEC>;
    ///UART1 receiver FIFO count
    pub mod rfc {
        ///Register `RFC` reader
        pub type R = crate::R<RFC_SPEC>;
        ///Field `RFC` reader - UART receiver FIFO count
        pub type RFC_R = crate::FieldReader;
        impl R {
            ///Bits 0:7 - UART receiver FIFO count
            #[inline(always)]
            pub fn rfc(&self) -> RFC_R {
                RFC_R::new(self.bits)
            }
        }
        ///UART1 receiver FIFO count
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`rfc::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct RFC_SPEC;
        impl crate::RegisterSpec for RFC_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`rfc::R`](R) reader structure
        impl crate::Readable for RFC_SPEC {}
        ///`reset()` method sets RFC to value 0
        impl crate::Resettable for RFC_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///TFC (r) register accessor: UART1 transmitter FIFO count
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`tfc::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@tfc`]
    ///module
    pub type TFC = crate::Reg<tfc::TFC_SPEC>;
    ///UART1 transmitter FIFO count
    pub mod tfc {
        ///Register `TFC` reader
        pub type R = crate::R<TFC_SPEC>;
        ///Field `TFC` reader - UART transmitter FIFO count
        pub type TFC_R = crate::FieldReader;
        impl R {
            ///Bits 0:7 - UART transmitter FIFO count
            #[inline(always)]
            pub fn tfc(&self) -> TFC_R {
                TFC_R::new(self.bits)
            }
        }
        ///UART1 transmitter FIFO count
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`tfc::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct TFC_SPEC;
        impl crate::RegisterSpec for TFC_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`tfc::R`](R) reader structure
        impl crate::Readable for TFC_SPEC {}
        ///`reset()` method sets TFC to value 0
        impl crate::Resettable for TFC_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///DL (rw) register accessor: UART1 divisor latch
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`dl::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dl::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@dl`]
    ///module
    pub type DL = crate::Reg<dl::DL_SPEC>;
    ///UART1 divisor latch
    pub mod dl {
        ///Register `DL` reader
        pub type R = crate::R<DL_SPEC>;
        ///Register `DL` writer
        pub type W = crate::W<DL_SPEC>;
        ///Field `DL` reader - UART divisor latch
        pub type DL_R = crate::FieldReader<u16>;
        ///Field `DL` writer - UART divisor latch
        pub type DL_W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            ///Bits 0:15 - UART divisor latch
            #[inline(always)]
            pub fn dl(&self) -> DL_R {
                DL_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - UART divisor latch
            #[inline(always)]
            #[must_use]
            pub fn dl(&mut self) -> DL_W<DL_SPEC> {
                DL_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///UART1 divisor latch
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`dl::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dl::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct DL_SPEC;
        impl crate::RegisterSpec for DL_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`dl::R`](R) reader structure
        impl crate::Readable for DL_SPEC {}
        ///`write(|w| ..)` method takes [`dl::W`](W) writer structure
        impl crate::Writable for DL_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets DL to value 0
        impl crate::Resettable for DL_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///DIV (rw) register accessor: UART1 pre-divisor latch byte
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`div::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`div::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@div`]
    ///module
    pub type DIV = crate::Reg<div::DIV_SPEC>;
    ///UART1 pre-divisor latch byte
    pub mod div {
        ///Register `DIV` reader
        pub type R = crate::R<DIV_SPEC>;
        ///Register `DIV` writer
        pub type W = crate::W<DIV_SPEC>;
        ///Field `DIV` reader - UART pre-divisor latch byte
        pub type DIV_R = crate::FieldReader;
        ///Field `DIV` writer - UART pre-divisor latch byte
        pub type DIV_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            ///Bits 0:7 - UART pre-divisor latch byte
            #[inline(always)]
            pub fn div(&self) -> DIV_R {
                DIV_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:7 - UART pre-divisor latch byte
            #[inline(always)]
            #[must_use]
            pub fn div(&mut self) -> DIV_W<DIV_SPEC> {
                DIV_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///UART1 pre-divisor latch byte
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`div::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`div::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct DIV_SPEC;
        impl crate::RegisterSpec for DIV_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`div::R`](R) reader structure
        impl crate::Readable for DIV_SPEC {}
        ///`write(|w| ..)` method takes [`div::W`](W) writer structure
        impl crate::Writable for DIV_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets DIV to value 0
        impl crate::Resettable for DIV_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///RBR (rw) register accessor: Receive buffer register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`rbr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`rbr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@rbr`]
    ///module
    pub type RBR = crate::Reg<rbr::RBR_SPEC>;
    ///Receive buffer register
    pub mod rbr {
        ///Register `RBR` reader
        pub type R = crate::R<RBR_SPEC>;
        ///Register `RBR` writer
        pub type W = crate::W<RBR_SPEC>;
        ///Field `RBR` reader - Data receive buffer register
        pub type RBR_R = crate::FieldReader;
        ///Field `RBR` writer - Data receive buffer register
        pub type RBR_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            ///Bits 0:7 - Data receive buffer register
            #[inline(always)]
            pub fn rbr(&self) -> RBR_R {
                RBR_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:7 - Data receive buffer register
            #[inline(always)]
            #[must_use]
            pub fn rbr(&mut self) -> RBR_W<RBR_SPEC> {
                RBR_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Receive buffer register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`rbr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`rbr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct RBR_SPEC;
        impl crate::RegisterSpec for RBR_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`rbr::R`](R) reader structure
        impl crate::Readable for RBR_SPEC {}
        ///`write(|w| ..)` method takes [`rbr::W`](W) writer structure
        impl crate::Writable for RBR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets RBR to value 0
        impl crate::Resettable for RBR_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///THR (rw) register accessor: Transmit hold register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`thr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`thr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@thr`]
    ///module
    pub type THR = crate::Reg<thr::THR_SPEC>;
    ///Transmit hold register
    pub mod thr {
        ///Register `THR` reader
        pub type R = crate::R<THR_SPEC>;
        ///Register `THR` writer
        pub type W = crate::W<THR_SPEC>;
        ///Field `THR` reader - Data transmit hold register
        pub type THR_R = crate::FieldReader;
        ///Field `THR` writer - Data transmit hold register
        pub type THR_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            ///Bits 0:7 - Data transmit hold register
            #[inline(always)]
            pub fn thr(&self) -> THR_R {
                THR_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:7 - Data transmit hold register
            #[inline(always)]
            #[must_use]
            pub fn thr(&mut self) -> THR_W<THR_SPEC> {
                THR_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Transmit hold register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`thr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`thr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct THR_SPEC;
        impl crate::RegisterSpec for THR_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`thr::R`](R) reader structure
        impl crate::Readable for THR_SPEC {}
        ///`write(|w| ..)` method takes [`thr::W`](W) writer structure
        impl crate::Writable for THR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets THR to value 0
        impl crate::Resettable for THR_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
}
///UART2 register
pub struct UART2 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for UART2 {}
impl UART2 {
    ///Pointer to the register block
    pub const PTR: *const uart1::RegisterBlock = 0x4000_3800 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const uart1::RegisterBlock {
        Self::PTR
    }
    /// Steal an instance of this peripheral
    ///
    /// # Safety
    ///
    /// Ensure that the new instance of the peripheral cannot be used in a way
    /// that may race with any existing instances, for example by only
    /// accessing read-only or write-only registers, or by consuming the
    /// original peripheral and using critical sections to coordinate
    /// access between multiple new instances.
    ///
    /// Additionally, other software such as HALs may rely on only one
    /// peripheral instance existing to ensure memory safety; ensure
    /// no stolen instances are passed to such software.
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for UART2 {
    type Target = uart1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for UART2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("UART2").finish()
    }
}
///UART2 register
pub use self::uart1 as uart2;
///UART3 register
pub struct UART3 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for UART3 {}
impl UART3 {
    ///Pointer to the register block
    pub const PTR: *const uart1::RegisterBlock = 0x4000_3c00 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const uart1::RegisterBlock {
        Self::PTR
    }
    /// Steal an instance of this peripheral
    ///
    /// # Safety
    ///
    /// Ensure that the new instance of the peripheral cannot be used in a way
    /// that may race with any existing instances, for example by only
    /// accessing read-only or write-only registers, or by consuming the
    /// original peripheral and using critical sections to coordinate
    /// access between multiple new instances.
    ///
    /// Additionally, other software such as HALs may rely on only one
    /// peripheral instance existing to ensure memory safety; ensure
    /// no stolen instances are passed to such software.
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for UART3 {
    type Target = uart1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for UART3 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("UART3").finish()
    }
}
///UART3 register
pub use self::uart1 as uart3;
///SPI0 register
pub struct SPI0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for SPI0 {}
impl SPI0 {
    ///Pointer to the register block
    pub const PTR: *const spi0::RegisterBlock = 0x4000_4000 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const spi0::RegisterBlock {
        Self::PTR
    }
    /// Steal an instance of this peripheral
    ///
    /// # Safety
    ///
    /// Ensure that the new instance of the peripheral cannot be used in a way
    /// that may race with any existing instances, for example by only
    /// accessing read-only or write-only registers, or by consuming the
    /// original peripheral and using critical sections to coordinate
    /// access between multiple new instances.
    ///
    /// Additionally, other software such as HALs may rely on only one
    /// peripheral instance existing to ensure memory safety; ensure
    /// no stolen instances are passed to such software.
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for SPI0 {
    type Target = spi0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for SPI0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("SPI0").finish()
    }
}
///SPI0 register
pub mod spi0 {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        ctrl_mod: CTRL_MOD,
        ctrl_cfg: CTRL_CFG,
        inter_en: INTER_EN,
        _reserved_3_clock_div: [u8; 0x01],
        buffer: BUFFER,
        run_flag: RUN_FLAG,
        int_flag: INT_FLAG,
        fifo_count: FIFO_COUNT,
        _reserved8: [u8; 0x04],
        total_cnt: TOTAL_CNT,
        _reserved9: [u8; 0x02],
        fifo: FIFO,
        _reserved10: [u8; 0x02],
        fifo_count1: FIFO_COUNT1,
        dma_now: DMA_NOW,
        dma_beg: DMA_BEG,
        dma_end: DMA_END,
    }
    impl RegisterBlock {
        ///0x00 - SPI0 mode control
        #[inline(always)]
        pub const fn ctrl_mod(&self) -> &CTRL_MOD {
            &self.ctrl_mod
        }
        ///0x01 - SPI0 configuration control
        #[inline(always)]
        pub const fn ctrl_cfg(&self) -> &CTRL_CFG {
            &self.ctrl_cfg
        }
        ///0x02 - SPI0 interrupt enable
        #[inline(always)]
        pub const fn inter_en(&self) -> &INTER_EN {
            &self.inter_en
        }
        ///0x03 - SPI slave mode preset data register
        #[inline(always)]
        pub const fn slave_pre(&self) -> &SLAVE_PRE {
            unsafe { &*(self as *const Self).cast::<u8>().add(3).cast() }
        }
        ///0x03 - SPI master mode clock divider register
        #[inline(always)]
        pub const fn clock_div(&self) -> &CLOCK_DIV {
            unsafe { &*(self as *const Self).cast::<u8>().add(3).cast() }
        }
        ///0x04 - SPI0 data buffer
        #[inline(always)]
        pub const fn buffer(&self) -> &BUFFER {
            &self.buffer
        }
        ///0x05 - SPI0 work flag
        #[inline(always)]
        pub const fn run_flag(&self) -> &RUN_FLAG {
            &self.run_flag
        }
        ///0x06 - SPI0 interrupt flag
        #[inline(always)]
        pub const fn int_flag(&self) -> &INT_FLAG {
            &self.int_flag
        }
        ///0x07 - SPI0 FIFO count status
        #[inline(always)]
        pub const fn fifo_count(&self) -> &FIFO_COUNT {
            &self.fifo_count
        }
        ///0x0c - SPI0 total byte count, only low 12 bit
        #[inline(always)]
        pub const fn total_cnt(&self) -> &TOTAL_CNT {
            &self.total_cnt
        }
        ///0x10 - SPI0 FIFO register
        #[inline(always)]
        pub const fn fifo(&self) -> &FIFO {
            &self.fifo
        }
        ///0x13 - SPI0 FIFO count status
        #[inline(always)]
        pub const fn fifo_count1(&self) -> &FIFO_COUNT1 {
            &self.fifo_count1
        }
        ///0x14 - SPI0 DMA current address
        #[inline(always)]
        pub const fn dma_now(&self) -> &DMA_NOW {
            &self.dma_now
        }
        ///0x18 - SPI0 DMA begin address
        #[inline(always)]
        pub const fn dma_beg(&self) -> &DMA_BEG {
            &self.dma_beg
        }
        ///0x1c - SPI0 DMA end address
        #[inline(always)]
        pub const fn dma_end(&self) -> &DMA_END {
            &self.dma_end
        }
    }
    ///CTRL_MOD (rw) register accessor: SPI0 mode control
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`ctrl_mod::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ctrl_mod::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@ctrl_mod`]
    ///module
    pub type CTRL_MOD = crate::Reg<ctrl_mod::CTRL_MOD_SPEC>;
    ///SPI0 mode control
    pub mod ctrl_mod {
        ///Register `CTRL_MOD` reader
        pub type R = crate::R<CTRL_MOD_SPEC>;
        ///Register `CTRL_MOD` writer
        pub type W = crate::W<CTRL_MOD_SPEC>;
        ///Field `SPI_MODE_SLAVE` reader - SPI slave mode
        pub type SPI_MODE_SLAVE_R = crate::BitReader;
        ///Field `SPI_MODE_SLAVE` writer - SPI slave mode
        pub type SPI_MODE_SLAVE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `SPI_ALL_CLEAR` reader - force clear SPI FIFO and count
        pub type SPI_ALL_CLEAR_R = crate::BitReader;
        ///Field `SPI_ALL_CLEAR` writer - force clear SPI FIFO and count
        pub type SPI_ALL_CLEAR_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `SPI_2WIRE_MOD` reader - SPI enable 2 wire mode
        pub type SPI_2WIRE_MOD_R = crate::BitReader;
        ///Field `SPI_2WIRE_MOD` writer - SPI enable 2 wire mode
        pub type SPI_2WIRE_MOD_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `SPI_MST_SCK_MOD_RB_SPI_SLV_CMD_MOD` reader - SPI master clock mode _SPI slave command mode
        pub type SPI_MST_SCK_MOD_RB_SPI_SLV_CMD_MOD_R = crate::BitReader;
        ///Field `SPI_MST_SCK_MOD_RB_SPI_SLV_CMD_MOD` writer - SPI master clock mode _SPI slave command mode
        pub type SPI_MST_SCK_MOD_RB_SPI_SLV_CMD_MOD_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `SPI_FIFO_DIR` reader - SPI FIFO direction
        pub type SPI_FIFO_DIR_R = crate::BitReader;
        ///Field `SPI_FIFO_DIR` writer - SPI FIFO direction
        pub type SPI_FIFO_DIR_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `SPI_SCK_OE` reader - SPI SCK output enable
        pub type SPI_SCK_OE_R = crate::BitReader;
        ///Field `SPI_SCK_OE` writer - SPI SCK output enable
        pub type SPI_SCK_OE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `SPI_MOSI_OE` reader - SPI MOSI output enable
        pub type SPI_MOSI_OE_R = crate::BitReader;
        ///Field `SPI_MOSI_OE` writer - SPI MOSI output enable
        pub type SPI_MOSI_OE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `SPI_MISO_OE` reader - SPI MISO output enable
        pub type SPI_MISO_OE_R = crate::BitReader;
        ///Field `SPI_MISO_OE` writer - SPI MISO output enable
        pub type SPI_MISO_OE_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - SPI slave mode
            #[inline(always)]
            pub fn spi_mode_slave(&self) -> SPI_MODE_SLAVE_R {
                SPI_MODE_SLAVE_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - force clear SPI FIFO and count
            #[inline(always)]
            pub fn spi_all_clear(&self) -> SPI_ALL_CLEAR_R {
                SPI_ALL_CLEAR_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - SPI enable 2 wire mode
            #[inline(always)]
            pub fn spi_2wire_mod(&self) -> SPI_2WIRE_MOD_R {
                SPI_2WIRE_MOD_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - SPI master clock mode _SPI slave command mode
            #[inline(always)]
            pub fn spi_mst_sck_mod_rb_spi_slv_cmd_mod(
                &self,
            ) -> SPI_MST_SCK_MOD_RB_SPI_SLV_CMD_MOD_R {
                SPI_MST_SCK_MOD_RB_SPI_SLV_CMD_MOD_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - SPI FIFO direction
            #[inline(always)]
            pub fn spi_fifo_dir(&self) -> SPI_FIFO_DIR_R {
                SPI_FIFO_DIR_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - SPI SCK output enable
            #[inline(always)]
            pub fn spi_sck_oe(&self) -> SPI_SCK_OE_R {
                SPI_SCK_OE_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - SPI MOSI output enable
            #[inline(always)]
            pub fn spi_mosi_oe(&self) -> SPI_MOSI_OE_R {
                SPI_MOSI_OE_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - SPI MISO output enable
            #[inline(always)]
            pub fn spi_miso_oe(&self) -> SPI_MISO_OE_R {
                SPI_MISO_OE_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - SPI slave mode
            #[inline(always)]
            #[must_use]
            pub fn spi_mode_slave(&mut self) -> SPI_MODE_SLAVE_W<CTRL_MOD_SPEC> {
                SPI_MODE_SLAVE_W::new(self, 0)
            }
            ///Bit 1 - force clear SPI FIFO and count
            #[inline(always)]
            #[must_use]
            pub fn spi_all_clear(&mut self) -> SPI_ALL_CLEAR_W<CTRL_MOD_SPEC> {
                SPI_ALL_CLEAR_W::new(self, 1)
            }
            ///Bit 2 - SPI enable 2 wire mode
            #[inline(always)]
            #[must_use]
            pub fn spi_2wire_mod(&mut self) -> SPI_2WIRE_MOD_W<CTRL_MOD_SPEC> {
                SPI_2WIRE_MOD_W::new(self, 2)
            }
            ///Bit 3 - SPI master clock mode _SPI slave command mode
            #[inline(always)]
            #[must_use]
            pub fn spi_mst_sck_mod_rb_spi_slv_cmd_mod(
                &mut self,
            ) -> SPI_MST_SCK_MOD_RB_SPI_SLV_CMD_MOD_W<CTRL_MOD_SPEC> {
                SPI_MST_SCK_MOD_RB_SPI_SLV_CMD_MOD_W::new(self, 3)
            }
            ///Bit 4 - SPI FIFO direction
            #[inline(always)]
            #[must_use]
            pub fn spi_fifo_dir(&mut self) -> SPI_FIFO_DIR_W<CTRL_MOD_SPEC> {
                SPI_FIFO_DIR_W::new(self, 4)
            }
            ///Bit 5 - SPI SCK output enable
            #[inline(always)]
            #[must_use]
            pub fn spi_sck_oe(&mut self) -> SPI_SCK_OE_W<CTRL_MOD_SPEC> {
                SPI_SCK_OE_W::new(self, 5)
            }
            ///Bit 6 - SPI MOSI output enable
            #[inline(always)]
            #[must_use]
            pub fn spi_mosi_oe(&mut self) -> SPI_MOSI_OE_W<CTRL_MOD_SPEC> {
                SPI_MOSI_OE_W::new(self, 6)
            }
            ///Bit 7 - SPI MISO output enable
            #[inline(always)]
            #[must_use]
            pub fn spi_miso_oe(&mut self) -> SPI_MISO_OE_W<CTRL_MOD_SPEC> {
                SPI_MISO_OE_W::new(self, 7)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///SPI0 mode control
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`ctrl_mod::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ctrl_mod::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct CTRL_MOD_SPEC;
        impl crate::RegisterSpec for CTRL_MOD_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`ctrl_mod::R`](R) reader structure
        impl crate::Readable for CTRL_MOD_SPEC {}
        ///`write(|w| ..)` method takes [`ctrl_mod::W`](W) writer structure
        impl crate::Writable for CTRL_MOD_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets CTRL_MOD to value 0x02
        impl crate::Resettable for CTRL_MOD_SPEC {
            const RESET_VALUE: u8 = 0x02;
        }
    }
    ///CTRL_CFG (rw) register accessor: SPI0 configuration control
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`ctrl_cfg::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ctrl_cfg::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@ctrl_cfg`]
    ///module
    pub type CTRL_CFG = crate::Reg<ctrl_cfg::CTRL_CFG_SPEC>;
    ///SPI0 configuration control
    pub mod ctrl_cfg {
        ///Register `CTRL_CFG` reader
        pub type R = crate::R<CTRL_CFG_SPEC>;
        ///Register `CTRL_CFG` writer
        pub type W = crate::W<CTRL_CFG_SPEC>;
        ///Field `SPI_DMA_ENABLE` reader - SPI DMA enable
        pub type SPI_DMA_ENABLE_R = crate::BitReader;
        ///Field `SPI_DMA_ENABLE` writer - SPI DMA enable
        pub type SPI_DMA_ENABLE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `SPI_DMA_LOOP` reader - SPI DMA address loop enable
        pub type SPI_DMA_LOOP_R = crate::BitReader;
        ///Field `SPI_DMA_LOOP` writer - SPI DMA address loop enable
        pub type SPI_DMA_LOOP_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `SPI_AUTO_IF` reader - enable buffer or FIFO accessing to auto clear RB_SPI_IF_BYTE_END interrupt flag
        pub type SPI_AUTO_IF_R = crate::BitReader;
        ///Field `SPI_AUTO_IF` writer - enable buffer or FIFO accessing to auto clear RB_SPI_IF_BYTE_END interrupt flag
        pub type SPI_AUTO_IF_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `SPI_BIT_ORDER` reader - SPI bit data order
        pub type SPI_BIT_ORDER_R = crate::BitReader;
        ///Field `SPI_BIT_ORDER` writer - SPI bit data order
        pub type SPI_BIT_ORDER_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - SPI DMA enable
            #[inline(always)]
            pub fn spi_dma_enable(&self) -> SPI_DMA_ENABLE_R {
                SPI_DMA_ENABLE_R::new((self.bits & 1) != 0)
            }
            ///Bit 2 - SPI DMA address loop enable
            #[inline(always)]
            pub fn spi_dma_loop(&self) -> SPI_DMA_LOOP_R {
                SPI_DMA_LOOP_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 4 - enable buffer or FIFO accessing to auto clear RB_SPI_IF_BYTE_END interrupt flag
            #[inline(always)]
            pub fn spi_auto_if(&self) -> SPI_AUTO_IF_R {
                SPI_AUTO_IF_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - SPI bit data order
            #[inline(always)]
            pub fn spi_bit_order(&self) -> SPI_BIT_ORDER_R {
                SPI_BIT_ORDER_R::new(((self.bits >> 5) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - SPI DMA enable
            #[inline(always)]
            #[must_use]
            pub fn spi_dma_enable(&mut self) -> SPI_DMA_ENABLE_W<CTRL_CFG_SPEC> {
                SPI_DMA_ENABLE_W::new(self, 0)
            }
            ///Bit 2 - SPI DMA address loop enable
            #[inline(always)]
            #[must_use]
            pub fn spi_dma_loop(&mut self) -> SPI_DMA_LOOP_W<CTRL_CFG_SPEC> {
                SPI_DMA_LOOP_W::new(self, 2)
            }
            ///Bit 4 - enable buffer or FIFO accessing to auto clear RB_SPI_IF_BYTE_END interrupt flag
            #[inline(always)]
            #[must_use]
            pub fn spi_auto_if(&mut self) -> SPI_AUTO_IF_W<CTRL_CFG_SPEC> {
                SPI_AUTO_IF_W::new(self, 4)
            }
            ///Bit 5 - SPI bit data order
            #[inline(always)]
            #[must_use]
            pub fn spi_bit_order(&mut self) -> SPI_BIT_ORDER_W<CTRL_CFG_SPEC> {
                SPI_BIT_ORDER_W::new(self, 5)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///SPI0 configuration control
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`ctrl_cfg::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ctrl_cfg::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct CTRL_CFG_SPEC;
        impl crate::RegisterSpec for CTRL_CFG_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`ctrl_cfg::R`](R) reader structure
        impl crate::Readable for CTRL_CFG_SPEC {}
        ///`write(|w| ..)` method takes [`ctrl_cfg::W`](W) writer structure
        impl crate::Writable for CTRL_CFG_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets CTRL_CFG to value 0
        impl crate::Resettable for CTRL_CFG_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///INTER_EN (rw) register accessor: SPI0 interrupt enable
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`inter_en::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`inter_en::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@inter_en`]
    ///module
    pub type INTER_EN = crate::Reg<inter_en::INTER_EN_SPEC>;
    ///SPI0 interrupt enable
    pub mod inter_en {
        ///Register `INTER_EN` reader
        pub type R = crate::R<INTER_EN_SPEC>;
        ///Register `INTER_EN` writer
        pub type W = crate::W<INTER_EN_SPEC>;
        ///Field `SPI_IE_CNT_END` reader - enable interrupt for SPI total byte count end
        pub type SPI_IE_CNT_END_R = crate::BitReader;
        ///Field `SPI_IE_CNT_END` writer - enable interrupt for SPI total byte count end
        pub type SPI_IE_CNT_END_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `SPI_IE_BYTE_END` reader - enable interrupt for SPI byte exchanged
        pub type SPI_IE_BYTE_END_R = crate::BitReader;
        ///Field `SPI_IE_BYTE_END` writer - enable interrupt for SPI byte exchanged
        pub type SPI_IE_BYTE_END_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `SPI_IE_FIFO_HF` reader - enable interrupt for SPI FIFO half
        pub type SPI_IE_FIFO_HF_R = crate::BitReader;
        ///Field `SPI_IE_FIFO_HF` writer - enable interrupt for SPI FIFO half
        pub type SPI_IE_FIFO_HF_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `SPI_IE_DMA_END` reader - enable interrupt for SPI DMA completion
        pub type SPI_IE_DMA_END_R = crate::BitReader;
        ///Field `SPI_IE_DMA_END` writer - enable interrupt for SPI DMA completion
        pub type SPI_IE_DMA_END_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `SPI_IE_FIFO_OV` reader - enable interrupt for SPI FIFO overflow
        pub type SPI_IE_FIFO_OV_R = crate::BitReader;
        ///Field `SPI_IE_FIFO_OV` writer - enable interrupt for SPI FIFO overflow
        pub type SPI_IE_FIFO_OV_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `SPI_IE_FST_BYTE` reader - enable interrupt for SPI slave mode first byte received
        pub type SPI_IE_FST_BYTE_R = crate::BitReader;
        ///Field `SPI_IE_FST_BYTE` writer - enable interrupt for SPI slave mode first byte received
        pub type SPI_IE_FST_BYTE_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - enable interrupt for SPI total byte count end
            #[inline(always)]
            pub fn spi_ie_cnt_end(&self) -> SPI_IE_CNT_END_R {
                SPI_IE_CNT_END_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - enable interrupt for SPI byte exchanged
            #[inline(always)]
            pub fn spi_ie_byte_end(&self) -> SPI_IE_BYTE_END_R {
                SPI_IE_BYTE_END_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - enable interrupt for SPI FIFO half
            #[inline(always)]
            pub fn spi_ie_fifo_hf(&self) -> SPI_IE_FIFO_HF_R {
                SPI_IE_FIFO_HF_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - enable interrupt for SPI DMA completion
            #[inline(always)]
            pub fn spi_ie_dma_end(&self) -> SPI_IE_DMA_END_R {
                SPI_IE_DMA_END_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - enable interrupt for SPI FIFO overflow
            #[inline(always)]
            pub fn spi_ie_fifo_ov(&self) -> SPI_IE_FIFO_OV_R {
                SPI_IE_FIFO_OV_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 7 - enable interrupt for SPI slave mode first byte received
            #[inline(always)]
            pub fn spi_ie_fst_byte(&self) -> SPI_IE_FST_BYTE_R {
                SPI_IE_FST_BYTE_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - enable interrupt for SPI total byte count end
            #[inline(always)]
            #[must_use]
            pub fn spi_ie_cnt_end(&mut self) -> SPI_IE_CNT_END_W<INTER_EN_SPEC> {
                SPI_IE_CNT_END_W::new(self, 0)
            }
            ///Bit 1 - enable interrupt for SPI byte exchanged
            #[inline(always)]
            #[must_use]
            pub fn spi_ie_byte_end(&mut self) -> SPI_IE_BYTE_END_W<INTER_EN_SPEC> {
                SPI_IE_BYTE_END_W::new(self, 1)
            }
            ///Bit 2 - enable interrupt for SPI FIFO half
            #[inline(always)]
            #[must_use]
            pub fn spi_ie_fifo_hf(&mut self) -> SPI_IE_FIFO_HF_W<INTER_EN_SPEC> {
                SPI_IE_FIFO_HF_W::new(self, 2)
            }
            ///Bit 3 - enable interrupt for SPI DMA completion
            #[inline(always)]
            #[must_use]
            pub fn spi_ie_dma_end(&mut self) -> SPI_IE_DMA_END_W<INTER_EN_SPEC> {
                SPI_IE_DMA_END_W::new(self, 3)
            }
            ///Bit 4 - enable interrupt for SPI FIFO overflow
            #[inline(always)]
            #[must_use]
            pub fn spi_ie_fifo_ov(&mut self) -> SPI_IE_FIFO_OV_W<INTER_EN_SPEC> {
                SPI_IE_FIFO_OV_W::new(self, 4)
            }
            ///Bit 7 - enable interrupt for SPI slave mode first byte received
            #[inline(always)]
            #[must_use]
            pub fn spi_ie_fst_byte(&mut self) -> SPI_IE_FST_BYTE_W<INTER_EN_SPEC> {
                SPI_IE_FST_BYTE_W::new(self, 7)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///SPI0 interrupt enable
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`inter_en::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`inter_en::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct INTER_EN_SPEC;
        impl crate::RegisterSpec for INTER_EN_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`inter_en::R`](R) reader structure
        impl crate::Readable for INTER_EN_SPEC {}
        ///`write(|w| ..)` method takes [`inter_en::W`](W) writer structure
        impl crate::Writable for INTER_EN_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets INTER_EN to value 0
        impl crate::Resettable for INTER_EN_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///BUFFER (r) register accessor: SPI0 data buffer
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`buffer::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@buffer`]
    ///module
    pub type BUFFER = crate::Reg<buffer::BUFFER_SPEC>;
    ///SPI0 data buffer
    pub mod buffer {
        ///Register `BUFFER` reader
        pub type R = crate::R<BUFFER_SPEC>;
        ///Field `BUFFER` reader - SPI data buffer
        pub type BUFFER_R = crate::FieldReader;
        impl R {
            ///Bits 0:7 - SPI data buffer
            #[inline(always)]
            pub fn buffer(&self) -> BUFFER_R {
                BUFFER_R::new(self.bits)
            }
        }
        ///SPI0 data buffer
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`buffer::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct BUFFER_SPEC;
        impl crate::RegisterSpec for BUFFER_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`buffer::R`](R) reader structure
        impl crate::Readable for BUFFER_SPEC {}
        ///`reset()` method sets BUFFER to value 0
        impl crate::Resettable for BUFFER_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///RUN_FLAG (r) register accessor: SPI0 work flag
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`run_flag::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@run_flag`]
    ///module
    pub type RUN_FLAG = crate::Reg<run_flag::RUN_FLAG_SPEC>;
    ///SPI0 work flag
    pub mod run_flag {
        ///Register `RUN_FLAG` reader
        pub type R = crate::R<RUN_FLAG_SPEC>;
        ///Field `SPI_SLV_CMD_ACT` reader - SPI slave command flag
        pub type SPI_SLV_CMD_ACT_R = crate::BitReader;
        ///Field `SPI_FIFO_READY` reader - SPI FIFO ready status
        pub type SPI_FIFO_READY_R = crate::BitReader;
        ///Field `SPI_SLV_CS_LOAD` reader - SPI slave chip-select loading status
        pub type SPI_SLV_CS_LOAD_R = crate::BitReader;
        ///Field `SPI_SLV_SELECT` reader - SPI slave selection status
        pub type SPI_SLV_SELECT_R = crate::BitReader;
        impl R {
            ///Bit 4 - SPI slave command flag
            #[inline(always)]
            pub fn spi_slv_cmd_act(&self) -> SPI_SLV_CMD_ACT_R {
                SPI_SLV_CMD_ACT_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - SPI FIFO ready status
            #[inline(always)]
            pub fn spi_fifo_ready(&self) -> SPI_FIFO_READY_R {
                SPI_FIFO_READY_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - SPI slave chip-select loading status
            #[inline(always)]
            pub fn spi_slv_cs_load(&self) -> SPI_SLV_CS_LOAD_R {
                SPI_SLV_CS_LOAD_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - SPI slave selection status
            #[inline(always)]
            pub fn spi_slv_select(&self) -> SPI_SLV_SELECT_R {
                SPI_SLV_SELECT_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        ///SPI0 work flag
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`run_flag::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct RUN_FLAG_SPEC;
        impl crate::RegisterSpec for RUN_FLAG_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`run_flag::R`](R) reader structure
        impl crate::Readable for RUN_FLAG_SPEC {}
        ///`reset()` method sets RUN_FLAG to value 0
        impl crate::Resettable for RUN_FLAG_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///INT_FLAG (rw) register accessor: SPI0 interrupt flag
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`int_flag::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`int_flag::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@int_flag`]
    ///module
    pub type INT_FLAG = crate::Reg<int_flag::INT_FLAG_SPEC>;
    ///SPI0 interrupt flag
    pub mod int_flag {
        ///Register `INT_FLAG` reader
        pub type R = crate::R<INT_FLAG_SPEC>;
        ///Register `INT_FLAG` writer
        pub type W = crate::W<INT_FLAG_SPEC>;
        ///Field `SPI_IF_CNT_END` reader - interrupt flag for SPI total byte count end
        pub type SPI_IF_CNT_END_R = crate::BitReader;
        ///Field `SPI_IF_CNT_END` writer - interrupt flag for SPI total byte count end
        pub type SPI_IF_CNT_END_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `SPI_IF_BYTE_END` reader - interrupt flag for SPI byte exchanged
        pub type SPI_IF_BYTE_END_R = crate::BitReader;
        ///Field `SPI_IF_BYTE_END` writer - interrupt flag for SPI byte exchanged
        pub type SPI_IF_BYTE_END_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `SPI_IF_FIFO_HF` reader - interrupt flag for SPI FIFO half
        pub type SPI_IF_FIFO_HF_R = crate::BitReader;
        ///Field `SPI_IF_FIFO_HF` writer - interrupt flag for SPI FIFO half
        pub type SPI_IF_FIFO_HF_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `SPI_IF_DMA_END` reader - interrupt flag for SPI DMA completion
        pub type SPI_IF_DMA_END_R = crate::BitReader;
        ///Field `SPI_IF_DMA_END` writer - interrupt flag for SPI DMA completion
        pub type SPI_IF_DMA_END_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `SPI_IF_FIFO_OV` reader - interrupt flag for SPI FIFO overflow
        pub type SPI_IF_FIFO_OV_R = crate::BitReader;
        ///Field `SPI_IF_FIFO_OV` writer - interrupt flag for SPI FIFO overflow
        pub type SPI_IF_FIFO_OV_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `SPI_FREE` reader - current SPI free status
        pub type SPI_FREE_R = crate::BitReader;
        ///Field `SPI_FREE` writer - current SPI free status
        pub type SPI_FREE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `SPI_IF_FST_BYTE` reader - interrupt flag for SPI slave mode first byte received
        pub type SPI_IF_FST_BYTE_R = crate::BitReader;
        ///Field `SPI_IF_FST_BYTE` writer - interrupt flag for SPI slave mode first byte received
        pub type SPI_IF_FST_BYTE_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - interrupt flag for SPI total byte count end
            #[inline(always)]
            pub fn spi_if_cnt_end(&self) -> SPI_IF_CNT_END_R {
                SPI_IF_CNT_END_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - interrupt flag for SPI byte exchanged
            #[inline(always)]
            pub fn spi_if_byte_end(&self) -> SPI_IF_BYTE_END_R {
                SPI_IF_BYTE_END_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - interrupt flag for SPI FIFO half
            #[inline(always)]
            pub fn spi_if_fifo_hf(&self) -> SPI_IF_FIFO_HF_R {
                SPI_IF_FIFO_HF_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - interrupt flag for SPI DMA completion
            #[inline(always)]
            pub fn spi_if_dma_end(&self) -> SPI_IF_DMA_END_R {
                SPI_IF_DMA_END_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - interrupt flag for SPI FIFO overflow
            #[inline(always)]
            pub fn spi_if_fifo_ov(&self) -> SPI_IF_FIFO_OV_R {
                SPI_IF_FIFO_OV_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 6 - current SPI free status
            #[inline(always)]
            pub fn spi_free(&self) -> SPI_FREE_R {
                SPI_FREE_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - interrupt flag for SPI slave mode first byte received
            #[inline(always)]
            pub fn spi_if_fst_byte(&self) -> SPI_IF_FST_BYTE_R {
                SPI_IF_FST_BYTE_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - interrupt flag for SPI total byte count end
            #[inline(always)]
            #[must_use]
            pub fn spi_if_cnt_end(&mut self) -> SPI_IF_CNT_END_W<INT_FLAG_SPEC> {
                SPI_IF_CNT_END_W::new(self, 0)
            }
            ///Bit 1 - interrupt flag for SPI byte exchanged
            #[inline(always)]
            #[must_use]
            pub fn spi_if_byte_end(&mut self) -> SPI_IF_BYTE_END_W<INT_FLAG_SPEC> {
                SPI_IF_BYTE_END_W::new(self, 1)
            }
            ///Bit 2 - interrupt flag for SPI FIFO half
            #[inline(always)]
            #[must_use]
            pub fn spi_if_fifo_hf(&mut self) -> SPI_IF_FIFO_HF_W<INT_FLAG_SPEC> {
                SPI_IF_FIFO_HF_W::new(self, 2)
            }
            ///Bit 3 - interrupt flag for SPI DMA completion
            #[inline(always)]
            #[must_use]
            pub fn spi_if_dma_end(&mut self) -> SPI_IF_DMA_END_W<INT_FLAG_SPEC> {
                SPI_IF_DMA_END_W::new(self, 3)
            }
            ///Bit 4 - interrupt flag for SPI FIFO overflow
            #[inline(always)]
            #[must_use]
            pub fn spi_if_fifo_ov(&mut self) -> SPI_IF_FIFO_OV_W<INT_FLAG_SPEC> {
                SPI_IF_FIFO_OV_W::new(self, 4)
            }
            ///Bit 6 - current SPI free status
            #[inline(always)]
            #[must_use]
            pub fn spi_free(&mut self) -> SPI_FREE_W<INT_FLAG_SPEC> {
                SPI_FREE_W::new(self, 6)
            }
            ///Bit 7 - interrupt flag for SPI slave mode first byte received
            #[inline(always)]
            #[must_use]
            pub fn spi_if_fst_byte(&mut self) -> SPI_IF_FST_BYTE_W<INT_FLAG_SPEC> {
                SPI_IF_FST_BYTE_W::new(self, 7)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///SPI0 interrupt flag
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`int_flag::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`int_flag::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct INT_FLAG_SPEC;
        impl crate::RegisterSpec for INT_FLAG_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`int_flag::R`](R) reader structure
        impl crate::Readable for INT_FLAG_SPEC {}
        ///`write(|w| ..)` method takes [`int_flag::W`](W) writer structure
        impl crate::Writable for INT_FLAG_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets INT_FLAG to value 0
        impl crate::Resettable for INT_FLAG_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///FIFO_COUNT (rw) register accessor: SPI0 FIFO count status
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`fifo_count::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`fifo_count::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@fifo_count`]
    ///module
    pub type FIFO_COUNT = crate::Reg<fifo_count::FIFO_COUNT_SPEC>;
    ///SPI0 FIFO count status
    pub mod fifo_count {
        ///Register `FIFO_COUNT` reader
        pub type R = crate::R<FIFO_COUNT_SPEC>;
        ///Register `FIFO_COUNT` writer
        pub type W = crate::W<FIFO_COUNT_SPEC>;
        ///Field `FIFO_COUNT` reader - SPI FIFO count status
        pub type FIFO_COUNT_R = crate::FieldReader;
        ///Field `FIFO_COUNT` writer - SPI FIFO count status
        pub type FIFO_COUNT_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            ///Bits 0:7 - SPI FIFO count status
            #[inline(always)]
            pub fn fifo_count(&self) -> FIFO_COUNT_R {
                FIFO_COUNT_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:7 - SPI FIFO count status
            #[inline(always)]
            #[must_use]
            pub fn fifo_count(&mut self) -> FIFO_COUNT_W<FIFO_COUNT_SPEC> {
                FIFO_COUNT_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///SPI0 FIFO count status
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`fifo_count::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`fifo_count::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct FIFO_COUNT_SPEC;
        impl crate::RegisterSpec for FIFO_COUNT_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`fifo_count::R`](R) reader structure
        impl crate::Readable for FIFO_COUNT_SPEC {}
        ///`write(|w| ..)` method takes [`fifo_count::W`](W) writer structure
        impl crate::Writable for FIFO_COUNT_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets FIFO_COUNT to value 0
        impl crate::Resettable for FIFO_COUNT_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///TOTAL_CNT (rw) register accessor: SPI0 total byte count, only low 12 bit
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`total_cnt::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`total_cnt::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@total_cnt`]
    ///module
    pub type TOTAL_CNT = crate::Reg<total_cnt::TOTAL_CNT_SPEC>;
    ///SPI0 total byte count, only low 12 bit
    pub mod total_cnt {
        ///Register `TOTAL_CNT` reader
        pub type R = crate::R<TOTAL_CNT_SPEC>;
        ///Register `TOTAL_CNT` writer
        pub type W = crate::W<TOTAL_CNT_SPEC>;
        ///Field `TOTAL_CNT` reader - SPI total byte count, only low 12 bit
        pub type TOTAL_CNT_R = crate::FieldReader<u16>;
        ///Field `TOTAL_CNT` writer - SPI total byte count, only low 12 bit
        pub type TOTAL_CNT_W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            ///Bits 0:15 - SPI total byte count, only low 12 bit
            #[inline(always)]
            pub fn total_cnt(&self) -> TOTAL_CNT_R {
                TOTAL_CNT_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - SPI total byte count, only low 12 bit
            #[inline(always)]
            #[must_use]
            pub fn total_cnt(&mut self) -> TOTAL_CNT_W<TOTAL_CNT_SPEC> {
                TOTAL_CNT_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///SPI0 total byte count, only low 12 bit
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`total_cnt::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`total_cnt::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct TOTAL_CNT_SPEC;
        impl crate::RegisterSpec for TOTAL_CNT_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`total_cnt::R`](R) reader structure
        impl crate::Readable for TOTAL_CNT_SPEC {}
        ///`write(|w| ..)` method takes [`total_cnt::W`](W) writer structure
        impl crate::Writable for TOTAL_CNT_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets TOTAL_CNT to value 0
        impl crate::Resettable for TOTAL_CNT_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///FIFO (rw) register accessor: SPI0 FIFO register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`fifo::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`fifo::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@fifo`]
    ///module
    pub type FIFO = crate::Reg<fifo::FIFO_SPEC>;
    ///SPI0 FIFO register
    pub mod fifo {
        ///Register `FIFO` reader
        pub type R = crate::R<FIFO_SPEC>;
        ///Register `FIFO` writer
        pub type W = crate::W<FIFO_SPEC>;
        ///Field `FIFO` reader - SPI FIFO register
        pub type FIFO_R = crate::FieldReader;
        ///Field `FIFO` writer - SPI FIFO register
        pub type FIFO_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            ///Bits 0:7 - SPI FIFO register
            #[inline(always)]
            pub fn fifo(&self) -> FIFO_R {
                FIFO_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:7 - SPI FIFO register
            #[inline(always)]
            #[must_use]
            pub fn fifo(&mut self) -> FIFO_W<FIFO_SPEC> {
                FIFO_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///SPI0 FIFO register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`fifo::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`fifo::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct FIFO_SPEC;
        impl crate::RegisterSpec for FIFO_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`fifo::R`](R) reader structure
        impl crate::Readable for FIFO_SPEC {}
        ///`write(|w| ..)` method takes [`fifo::W`](W) writer structure
        impl crate::Writable for FIFO_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets FIFO to value 0
        impl crate::Resettable for FIFO_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///FIFO_COUNT1 (rw) register accessor: SPI0 FIFO count status
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`fifo_count1::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`fifo_count1::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@fifo_count1`]
    ///module
    pub type FIFO_COUNT1 = crate::Reg<fifo_count1::FIFO_COUNT1_SPEC>;
    ///SPI0 FIFO count status
    pub mod fifo_count1 {
        ///Register `FIFO_COUNT1` reader
        pub type R = crate::R<FIFO_COUNT1_SPEC>;
        ///Register `FIFO_COUNT1` writer
        pub type W = crate::W<FIFO_COUNT1_SPEC>;
        ///Field `FIFO_COUNT1` reader - SPI FIFO count statu
        pub type FIFO_COUNT1_R = crate::FieldReader;
        ///Field `FIFO_COUNT1` writer - SPI FIFO count statu
        pub type FIFO_COUNT1_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            ///Bits 0:7 - SPI FIFO count statu
            #[inline(always)]
            pub fn fifo_count1(&self) -> FIFO_COUNT1_R {
                FIFO_COUNT1_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:7 - SPI FIFO count statu
            #[inline(always)]
            #[must_use]
            pub fn fifo_count1(&mut self) -> FIFO_COUNT1_W<FIFO_COUNT1_SPEC> {
                FIFO_COUNT1_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///SPI0 FIFO count status
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`fifo_count1::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`fifo_count1::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct FIFO_COUNT1_SPEC;
        impl crate::RegisterSpec for FIFO_COUNT1_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`fifo_count1::R`](R) reader structure
        impl crate::Readable for FIFO_COUNT1_SPEC {}
        ///`write(|w| ..)` method takes [`fifo_count1::W`](W) writer structure
        impl crate::Writable for FIFO_COUNT1_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets FIFO_COUNT1 to value 0
        impl crate::Resettable for FIFO_COUNT1_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///DMA_NOW (rw) register accessor: SPI0 DMA current address
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`dma_now::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dma_now::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@dma_now`]
    ///module
    pub type DMA_NOW = crate::Reg<dma_now::DMA_NOW_SPEC>;
    ///SPI0 DMA current address
    pub mod dma_now {
        ///Register `DMA_NOW` reader
        pub type R = crate::R<DMA_NOW_SPEC>;
        ///Register `DMA_NOW` writer
        pub type W = crate::W<DMA_NOW_SPEC>;
        ///Field `DMA_NOW` reader - SPI DMA current address
        pub type DMA_NOW_R = crate::FieldReader<u32>;
        ///Field `DMA_NOW` writer - SPI DMA current address
        pub type DMA_NOW_W<'a, REG> = crate::FieldWriter<'a, REG, 18, u32>;
        impl R {
            ///Bits 0:17 - SPI DMA current address
            #[inline(always)]
            pub fn dma_now(&self) -> DMA_NOW_R {
                DMA_NOW_R::new(self.bits & 0x0003_ffff)
            }
        }
        impl W {
            ///Bits 0:17 - SPI DMA current address
            #[inline(always)]
            #[must_use]
            pub fn dma_now(&mut self) -> DMA_NOW_W<DMA_NOW_SPEC> {
                DMA_NOW_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///SPI0 DMA current address
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`dma_now::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dma_now::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct DMA_NOW_SPEC;
        impl crate::RegisterSpec for DMA_NOW_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`dma_now::R`](R) reader structure
        impl crate::Readable for DMA_NOW_SPEC {}
        ///`write(|w| ..)` method takes [`dma_now::W`](W) writer structure
        impl crate::Writable for DMA_NOW_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets DMA_NOW to value 0
        impl crate::Resettable for DMA_NOW_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///DMA_BEG (rw) register accessor: SPI0 DMA begin address
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`dma_beg::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dma_beg::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@dma_beg`]
    ///module
    pub type DMA_BEG = crate::Reg<dma_beg::DMA_BEG_SPEC>;
    ///SPI0 DMA begin address
    pub mod dma_beg {
        ///Register `DMA_BEG` reader
        pub type R = crate::R<DMA_BEG_SPEC>;
        ///Register `DMA_BEG` writer
        pub type W = crate::W<DMA_BEG_SPEC>;
        ///Field `DMA_BEG` reader - SPI DMA begin address
        pub type DMA_BEG_R = crate::FieldReader<u32>;
        ///Field `DMA_BEG` writer - SPI DMA begin address
        pub type DMA_BEG_W<'a, REG> = crate::FieldWriter<'a, REG, 18, u32>;
        impl R {
            ///Bits 0:17 - SPI DMA begin address
            #[inline(always)]
            pub fn dma_beg(&self) -> DMA_BEG_R {
                DMA_BEG_R::new(self.bits & 0x0003_ffff)
            }
        }
        impl W {
            ///Bits 0:17 - SPI DMA begin address
            #[inline(always)]
            #[must_use]
            pub fn dma_beg(&mut self) -> DMA_BEG_W<DMA_BEG_SPEC> {
                DMA_BEG_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///SPI0 DMA begin address
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`dma_beg::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dma_beg::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct DMA_BEG_SPEC;
        impl crate::RegisterSpec for DMA_BEG_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`dma_beg::R`](R) reader structure
        impl crate::Readable for DMA_BEG_SPEC {}
        ///`write(|w| ..)` method takes [`dma_beg::W`](W) writer structure
        impl crate::Writable for DMA_BEG_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets DMA_BEG to value 0
        impl crate::Resettable for DMA_BEG_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///DMA_END (rw) register accessor: SPI0 DMA end address
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`dma_end::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dma_end::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@dma_end`]
    ///module
    pub type DMA_END = crate::Reg<dma_end::DMA_END_SPEC>;
    ///SPI0 DMA end address
    pub mod dma_end {
        ///Register `DMA_END` reader
        pub type R = crate::R<DMA_END_SPEC>;
        ///Register `DMA_END` writer
        pub type W = crate::W<DMA_END_SPEC>;
        ///Field `DMA_END` reader - SPI DMA end address
        pub type DMA_END_R = crate::FieldReader<u32>;
        ///Field `DMA_END` writer - SPI DMA end address
        pub type DMA_END_W<'a, REG> = crate::FieldWriter<'a, REG, 18, u32>;
        impl R {
            ///Bits 0:17 - SPI DMA end address
            #[inline(always)]
            pub fn dma_end(&self) -> DMA_END_R {
                DMA_END_R::new(self.bits & 0x0003_ffff)
            }
        }
        impl W {
            ///Bits 0:17 - SPI DMA end address
            #[inline(always)]
            #[must_use]
            pub fn dma_end(&mut self) -> DMA_END_W<DMA_END_SPEC> {
                DMA_END_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///SPI0 DMA end address
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`dma_end::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dma_end::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct DMA_END_SPEC;
        impl crate::RegisterSpec for DMA_END_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`dma_end::R`](R) reader structure
        impl crate::Readable for DMA_END_SPEC {}
        ///`write(|w| ..)` method takes [`dma_end::W`](W) writer structure
        impl crate::Writable for DMA_END_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets DMA_END to value 0
        impl crate::Resettable for DMA_END_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///CLOCK_DIV (rw) register accessor: SPI master mode clock divider register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`clock_div::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`clock_div::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@clock_div`]
    ///module
    pub type CLOCK_DIV = crate::Reg<clock_div::CLOCK_DIV_SPEC>;
    ///SPI master mode clock divider register
    pub mod clock_div {
        ///Register `CLOCK_DIV` reader
        pub type R = crate::R<CLOCK_DIV_SPEC>;
        ///Register `CLOCK_DIV` writer
        pub type W = crate::W<CLOCK_DIV_SPEC>;
        ///Field `CLICK_DIV` reader - SPI master mode clock divider
        pub type CLICK_DIV_R = crate::FieldReader;
        ///Field `CLICK_DIV` writer - SPI master mode clock divider
        pub type CLICK_DIV_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            ///Bits 0:7 - SPI master mode clock divider
            #[inline(always)]
            pub fn click_div(&self) -> CLICK_DIV_R {
                CLICK_DIV_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:7 - SPI master mode clock divider
            #[inline(always)]
            #[must_use]
            pub fn click_div(&mut self) -> CLICK_DIV_W<CLOCK_DIV_SPEC> {
                CLICK_DIV_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///SPI master mode clock divider register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`clock_div::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`clock_div::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct CLOCK_DIV_SPEC;
        impl crate::RegisterSpec for CLOCK_DIV_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`clock_div::R`](R) reader structure
        impl crate::Readable for CLOCK_DIV_SPEC {}
        ///`write(|w| ..)` method takes [`clock_div::W`](W) writer structure
        impl crate::Writable for CLOCK_DIV_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets CLOCK_DIV to value 0
        impl crate::Resettable for CLOCK_DIV_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///SLAVE_PRE (rw) register accessor: SPI slave mode preset data register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`slave_pre::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`slave_pre::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@slave_pre`]
    ///module
    pub type SLAVE_PRE = crate::Reg<slave_pre::SLAVE_PRE_SPEC>;
    ///SPI slave mode preset data register
    pub mod slave_pre {
        ///Register `SLAVE_PRE` reader
        pub type R = crate::R<SLAVE_PRE_SPEC>;
        ///Register `SLAVE_PRE` writer
        pub type W = crate::W<SLAVE_PRE_SPEC>;
        ///Field `SLAVE_PRE` reader - SPI slave mode preset data
        pub type SLAVE_PRE_R = crate::FieldReader;
        ///Field `SLAVE_PRE` writer - SPI slave mode preset data
        pub type SLAVE_PRE_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            ///Bits 0:7 - SPI slave mode preset data
            #[inline(always)]
            pub fn slave_pre(&self) -> SLAVE_PRE_R {
                SLAVE_PRE_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:7 - SPI slave mode preset data
            #[inline(always)]
            #[must_use]
            pub fn slave_pre(&mut self) -> SLAVE_PRE_W<SLAVE_PRE_SPEC> {
                SLAVE_PRE_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///SPI slave mode preset data register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`slave_pre::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`slave_pre::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct SLAVE_PRE_SPEC;
        impl crate::RegisterSpec for SLAVE_PRE_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`slave_pre::R`](R) reader structure
        impl crate::Readable for SLAVE_PRE_SPEC {}
        ///`write(|w| ..)` method takes [`slave_pre::W`](W) writer structure
        impl crate::Writable for SLAVE_PRE_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets SLAVE_PRE to value 0
        impl crate::Resettable for SLAVE_PRE_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
}
///SPI1 register
pub struct SPI1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for SPI1 {}
impl SPI1 {
    ///Pointer to the register block
    pub const PTR: *const spi0::RegisterBlock = 0x4000_4400 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const spi0::RegisterBlock {
        Self::PTR
    }
    /// Steal an instance of this peripheral
    ///
    /// # Safety
    ///
    /// Ensure that the new instance of the peripheral cannot be used in a way
    /// that may race with any existing instances, for example by only
    /// accessing read-only or write-only registers, or by consuming the
    /// original peripheral and using critical sections to coordinate
    /// access between multiple new instances.
    ///
    /// Additionally, other software such as HALs may rely on only one
    /// peripheral instance existing to ensure memory safety; ensure
    /// no stolen instances are passed to such software.
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for SPI1 {
    type Target = spi0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for SPI1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("SPI1").finish()
    }
}
///SPI1 register
pub use self::spi0 as spi1;
///PWMX register
pub struct PWMX {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for PWMX {}
impl PWMX {
    ///Pointer to the register block
    pub const PTR: *const pwmx::RegisterBlock = 0x4000_5000 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const pwmx::RegisterBlock {
        Self::PTR
    }
    /// Steal an instance of this peripheral
    ///
    /// # Safety
    ///
    /// Ensure that the new instance of the peripheral cannot be used in a way
    /// that may race with any existing instances, for example by only
    /// accessing read-only or write-only registers, or by consuming the
    /// original peripheral and using critical sections to coordinate
    /// access between multiple new instances.
    ///
    /// Additionally, other software such as HALs may rely on only one
    /// peripheral instance existing to ensure memory safety; ensure
    /// no stolen instances are passed to such software.
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for PWMX {
    type Target = pwmx::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for PWMX {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("PWMX").finish()
    }
}
///PWMX register
pub mod pwmx {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        pwm_ctrl_mod: PWM_CTRL_MOD,
        pwm_ctrl_cfg: PWM_CTRL_CFG,
        pwm_clock_div: PWM_CLOCK_DIV,
        _reserved3: [u8; 0x01],
        _reserved_3_pwm_data: [u8; 0x04],
    }
    impl RegisterBlock {
        ///0x00 - PWM mode control
        #[inline(always)]
        pub const fn pwm_ctrl_mod(&self) -> &PWM_CTRL_MOD {
            &self.pwm_ctrl_mod
        }
        ///0x01 - PWM configuration control
        #[inline(always)]
        pub const fn pwm_ctrl_cfg(&self) -> &PWM_CTRL_CFG {
            &self.pwm_ctrl_cfg
        }
        ///0x02 - PWM clock divisor
        #[inline(always)]
        pub const fn pwm_clock_div(&self) -> &PWM_CLOCK_DIV {
            &self.pwm_clock_div
        }
        ///0x04 - PWM data register
        #[inline(always)]
        pub const fn pwm_data(&self) -> &PWM_DATA {
            unsafe { &*(self as *const Self).cast::<u8>().add(4).cast() }
        }
        ///0x04 - PWM data holding
        #[inline(always)]
        pub const fn pwm0_data(&self) -> &PWM0_DATA {
            unsafe { &*(self as *const Self).cast::<u8>().add(4).cast() }
        }
        ///0x05 - PWM1 data holding
        #[inline(always)]
        pub const fn pwm1_data(&self) -> &PWM1_DATA {
            unsafe { &*(self as *const Self).cast::<u8>().add(5).cast() }
        }
        ///0x06 - PWM2 data holding
        #[inline(always)]
        pub const fn pwm2_data(&self) -> &PWM2_DATA {
            unsafe { &*(self as *const Self).cast::<u8>().add(6).cast() }
        }
        ///0x07 - PWM3 data holding
        #[inline(always)]
        pub const fn pwm3_data(&self) -> &PWM3_DATA {
            unsafe { &*(self as *const Self).cast::<u8>().add(7).cast() }
        }
    }
    ///PWM_CTRL_MOD (rw) register accessor: PWM mode control
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`pwm_ctrl_mod::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pwm_ctrl_mod::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@pwm_ctrl_mod`]
    ///module
    pub type PWM_CTRL_MOD = crate::Reg<pwm_ctrl_mod::PWM_CTRL_MOD_SPEC>;
    ///PWM mode control
    pub mod pwm_ctrl_mod {
        ///Register `PWM_CTRL_MOD` reader
        pub type R = crate::R<PWM_CTRL_MOD_SPEC>;
        ///Register `PWM_CTRL_MOD` writer
        pub type W = crate::W<PWM_CTRL_MOD_SPEC>;
        ///Field `PWM0_OUT_EN` reader - PWM0 output enable
        pub type PWM0_OUT_EN_R = crate::BitReader;
        ///Field `PWM0_OUT_EN` writer - PWM0 output enable
        pub type PWM0_OUT_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PWM1_OUT_EN` reader - PWM1 output enable
        pub type PWM1_OUT_EN_R = crate::BitReader;
        ///Field `PWM1_OUT_EN` writer - PWM1 output enable
        pub type PWM1_OUT_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PWM2_OUT_EN` reader - PWM2 output enable
        pub type PWM2_OUT_EN_R = crate::BitReader;
        ///Field `PWM2_OUT_EN` writer - PWM2 output enable
        pub type PWM2_OUT_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PWM3_OUT_EN` reader - PWM3 output enable
        pub type PWM3_OUT_EN_R = crate::BitReader;
        ///Field `PWM3_OUT_EN` writer - PWM3 output enable
        pub type PWM3_OUT_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PWM0_POLAR` reader - PWM0 output polarity
        pub type PWM0_POLAR_R = crate::BitReader;
        ///Field `PWM0_POLAR` writer - PWM0 output polarity
        pub type PWM0_POLAR_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PWM1_POLAR` reader - PWM1 output polarity
        pub type PWM1_POLAR_R = crate::BitReader;
        ///Field `PWM1_POLAR` writer - PWM1 output polarity
        pub type PWM1_POLAR_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PWM2_POLAR` reader - PWM2 output polarity
        pub type PWM2_POLAR_R = crate::BitReader;
        ///Field `PWM2_POLAR` writer - PWM2 output polarity
        pub type PWM2_POLAR_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PWM3_POLAR` reader - PWM3 output polarity
        pub type PWM3_POLAR_R = crate::BitReader;
        ///Field `PWM3_POLAR` writer - PWM3 output polarity
        pub type PWM3_POLAR_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - PWM0 output enable
            #[inline(always)]
            pub fn pwm0_out_en(&self) -> PWM0_OUT_EN_R {
                PWM0_OUT_EN_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - PWM1 output enable
            #[inline(always)]
            pub fn pwm1_out_en(&self) -> PWM1_OUT_EN_R {
                PWM1_OUT_EN_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - PWM2 output enable
            #[inline(always)]
            pub fn pwm2_out_en(&self) -> PWM2_OUT_EN_R {
                PWM2_OUT_EN_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - PWM3 output enable
            #[inline(always)]
            pub fn pwm3_out_en(&self) -> PWM3_OUT_EN_R {
                PWM3_OUT_EN_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - PWM0 output polarity
            #[inline(always)]
            pub fn pwm0_polar(&self) -> PWM0_POLAR_R {
                PWM0_POLAR_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - PWM1 output polarity
            #[inline(always)]
            pub fn pwm1_polar(&self) -> PWM1_POLAR_R {
                PWM1_POLAR_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - PWM2 output polarity
            #[inline(always)]
            pub fn pwm2_polar(&self) -> PWM2_POLAR_R {
                PWM2_POLAR_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - PWM3 output polarity
            #[inline(always)]
            pub fn pwm3_polar(&self) -> PWM3_POLAR_R {
                PWM3_POLAR_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - PWM0 output enable
            #[inline(always)]
            #[must_use]
            pub fn pwm0_out_en(&mut self) -> PWM0_OUT_EN_W<PWM_CTRL_MOD_SPEC> {
                PWM0_OUT_EN_W::new(self, 0)
            }
            ///Bit 1 - PWM1 output enable
            #[inline(always)]
            #[must_use]
            pub fn pwm1_out_en(&mut self) -> PWM1_OUT_EN_W<PWM_CTRL_MOD_SPEC> {
                PWM1_OUT_EN_W::new(self, 1)
            }
            ///Bit 2 - PWM2 output enable
            #[inline(always)]
            #[must_use]
            pub fn pwm2_out_en(&mut self) -> PWM2_OUT_EN_W<PWM_CTRL_MOD_SPEC> {
                PWM2_OUT_EN_W::new(self, 2)
            }
            ///Bit 3 - PWM3 output enable
            #[inline(always)]
            #[must_use]
            pub fn pwm3_out_en(&mut self) -> PWM3_OUT_EN_W<PWM_CTRL_MOD_SPEC> {
                PWM3_OUT_EN_W::new(self, 3)
            }
            ///Bit 4 - PWM0 output polarity
            #[inline(always)]
            #[must_use]
            pub fn pwm0_polar(&mut self) -> PWM0_POLAR_W<PWM_CTRL_MOD_SPEC> {
                PWM0_POLAR_W::new(self, 4)
            }
            ///Bit 5 - PWM1 output polarity
            #[inline(always)]
            #[must_use]
            pub fn pwm1_polar(&mut self) -> PWM1_POLAR_W<PWM_CTRL_MOD_SPEC> {
                PWM1_POLAR_W::new(self, 5)
            }
            ///Bit 6 - PWM2 output polarity
            #[inline(always)]
            #[must_use]
            pub fn pwm2_polar(&mut self) -> PWM2_POLAR_W<PWM_CTRL_MOD_SPEC> {
                PWM2_POLAR_W::new(self, 6)
            }
            ///Bit 7 - PWM3 output polarity
            #[inline(always)]
            #[must_use]
            pub fn pwm3_polar(&mut self) -> PWM3_POLAR_W<PWM_CTRL_MOD_SPEC> {
                PWM3_POLAR_W::new(self, 7)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///PWM mode control
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`pwm_ctrl_mod::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pwm_ctrl_mod::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct PWM_CTRL_MOD_SPEC;
        impl crate::RegisterSpec for PWM_CTRL_MOD_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`pwm_ctrl_mod::R`](R) reader structure
        impl crate::Readable for PWM_CTRL_MOD_SPEC {}
        ///`write(|w| ..)` method takes [`pwm_ctrl_mod::W`](W) writer structure
        impl crate::Writable for PWM_CTRL_MOD_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets PWM_CTRL_MOD to value 0
        impl crate::Resettable for PWM_CTRL_MOD_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///PWM_CTRL_CFG (rw) register accessor: PWM configuration control
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`pwm_ctrl_cfg::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pwm_ctrl_cfg::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@pwm_ctrl_cfg`]
    ///module
    pub type PWM_CTRL_CFG = crate::Reg<pwm_ctrl_cfg::PWM_CTRL_CFG_SPEC>;
    ///PWM configuration control
    pub mod pwm_ctrl_cfg {
        ///Register `PWM_CTRL_CFG` reader
        pub type R = crate::R<PWM_CTRL_CFG_SPEC>;
        ///Register `PWM_CTRL_CFG` writer
        pub type W = crate::W<PWM_CTRL_CFG_SPEC>;
        ///Field `PWM_CYCLE_SEL` reader - PWM cycle selection
        pub type PWM_CYCLE_SEL_R = crate::BitReader;
        ///Field `PWM_CYCLE_SEL` writer - PWM cycle selection
        pub type PWM_CYCLE_SEL_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - PWM cycle selection
            #[inline(always)]
            pub fn pwm_cycle_sel(&self) -> PWM_CYCLE_SEL_R {
                PWM_CYCLE_SEL_R::new((self.bits & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - PWM cycle selection
            #[inline(always)]
            #[must_use]
            pub fn pwm_cycle_sel(&mut self) -> PWM_CYCLE_SEL_W<PWM_CTRL_CFG_SPEC> {
                PWM_CYCLE_SEL_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///PWM configuration control
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`pwm_ctrl_cfg::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pwm_ctrl_cfg::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct PWM_CTRL_CFG_SPEC;
        impl crate::RegisterSpec for PWM_CTRL_CFG_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`pwm_ctrl_cfg::R`](R) reader structure
        impl crate::Readable for PWM_CTRL_CFG_SPEC {}
        ///`write(|w| ..)` method takes [`pwm_ctrl_cfg::W`](W) writer structure
        impl crate::Writable for PWM_CTRL_CFG_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets PWM_CTRL_CFG to value 0
        impl crate::Resettable for PWM_CTRL_CFG_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///PWM_CLOCK_DIV (rw) register accessor: PWM clock divisor
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`pwm_clock_div::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pwm_clock_div::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@pwm_clock_div`]
    ///module
    pub type PWM_CLOCK_DIV = crate::Reg<pwm_clock_div::PWM_CLOCK_DIV_SPEC>;
    ///PWM clock divisor
    pub mod pwm_clock_div {
        ///Register `PWM_CLOCK_DIV` reader
        pub type R = crate::R<PWM_CLOCK_DIV_SPEC>;
        ///Register `PWM_CLOCK_DIV` writer
        pub type W = crate::W<PWM_CLOCK_DIV_SPEC>;
        ///Field `PWM_CLOCK_DIV` reader - PWM clock divisor
        pub type PWM_CLOCK_DIV_R = crate::FieldReader;
        ///Field `PWM_CLOCK_DIV` writer - PWM clock divisor
        pub type PWM_CLOCK_DIV_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            ///Bits 0:7 - PWM clock divisor
            #[inline(always)]
            pub fn pwm_clock_div(&self) -> PWM_CLOCK_DIV_R {
                PWM_CLOCK_DIV_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:7 - PWM clock divisor
            #[inline(always)]
            #[must_use]
            pub fn pwm_clock_div(&mut self) -> PWM_CLOCK_DIV_W<PWM_CLOCK_DIV_SPEC> {
                PWM_CLOCK_DIV_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///PWM clock divisor
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`pwm_clock_div::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pwm_clock_div::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct PWM_CLOCK_DIV_SPEC;
        impl crate::RegisterSpec for PWM_CLOCK_DIV_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`pwm_clock_div::R`](R) reader structure
        impl crate::Readable for PWM_CLOCK_DIV_SPEC {}
        ///`write(|w| ..)` method takes [`pwm_clock_div::W`](W) writer structure
        impl crate::Writable for PWM_CLOCK_DIV_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets PWM_CLOCK_DIV to value 0
        impl crate::Resettable for PWM_CLOCK_DIV_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///PWM0_DATA (rw) register accessor: PWM data holding
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`pwm0_data::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pwm0_data::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@pwm0_data`]
    ///module
    pub type PWM0_DATA = crate::Reg<pwm0_data::PWM0_DATA_SPEC>;
    ///PWM data holding
    pub mod pwm0_data {
        ///Register `PWM0_DATA` reader
        pub type R = crate::R<PWM0_DATA_SPEC>;
        ///Register `PWM0_DATA` writer
        pub type W = crate::W<PWM0_DATA_SPEC>;
        ///Field `PWM0_DATA` reader - PWM0 data holding
        pub type PWM0_DATA_R = crate::FieldReader;
        ///Field `PWM0_DATA` writer - PWM0 data holding
        pub type PWM0_DATA_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            ///Bits 0:7 - PWM0 data holding
            #[inline(always)]
            pub fn pwm0_data(&self) -> PWM0_DATA_R {
                PWM0_DATA_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:7 - PWM0 data holding
            #[inline(always)]
            #[must_use]
            pub fn pwm0_data(&mut self) -> PWM0_DATA_W<PWM0_DATA_SPEC> {
                PWM0_DATA_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///PWM data holding
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`pwm0_data::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pwm0_data::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct PWM0_DATA_SPEC;
        impl crate::RegisterSpec for PWM0_DATA_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`pwm0_data::R`](R) reader structure
        impl crate::Readable for PWM0_DATA_SPEC {}
        ///`write(|w| ..)` method takes [`pwm0_data::W`](W) writer structure
        impl crate::Writable for PWM0_DATA_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets PWM0_DATA to value 0
        impl crate::Resettable for PWM0_DATA_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///PWM1_DATA (rw) register accessor: PWM1 data holding
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`pwm1_data::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pwm1_data::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@pwm1_data`]
    ///module
    pub type PWM1_DATA = crate::Reg<pwm1_data::PWM1_DATA_SPEC>;
    ///PWM1 data holding
    pub mod pwm1_data {
        ///Register `PWM1_DATA` reader
        pub type R = crate::R<PWM1_DATA_SPEC>;
        ///Register `PWM1_DATA` writer
        pub type W = crate::W<PWM1_DATA_SPEC>;
        ///Field `PWM1_DATA` reader - PWM1 data holding
        pub type PWM1_DATA_R = crate::FieldReader;
        ///Field `PWM1_DATA` writer - PWM1 data holding
        pub type PWM1_DATA_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            ///Bits 0:7 - PWM1 data holding
            #[inline(always)]
            pub fn pwm1_data(&self) -> PWM1_DATA_R {
                PWM1_DATA_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:7 - PWM1 data holding
            #[inline(always)]
            #[must_use]
            pub fn pwm1_data(&mut self) -> PWM1_DATA_W<PWM1_DATA_SPEC> {
                PWM1_DATA_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///PWM1 data holding
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`pwm1_data::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pwm1_data::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct PWM1_DATA_SPEC;
        impl crate::RegisterSpec for PWM1_DATA_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`pwm1_data::R`](R) reader structure
        impl crate::Readable for PWM1_DATA_SPEC {}
        ///`write(|w| ..)` method takes [`pwm1_data::W`](W) writer structure
        impl crate::Writable for PWM1_DATA_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets PWM1_DATA to value 0
        impl crate::Resettable for PWM1_DATA_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///PWM2_DATA (rw) register accessor: PWM2 data holding
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`pwm2_data::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pwm2_data::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@pwm2_data`]
    ///module
    pub type PWM2_DATA = crate::Reg<pwm2_data::PWM2_DATA_SPEC>;
    ///PWM2 data holding
    pub mod pwm2_data {
        ///Register `PWM2_DATA` reader
        pub type R = crate::R<PWM2_DATA_SPEC>;
        ///Register `PWM2_DATA` writer
        pub type W = crate::W<PWM2_DATA_SPEC>;
        ///Field `PWM2_DATA` reader - PWM2 data holding
        pub type PWM2_DATA_R = crate::FieldReader;
        ///Field `PWM2_DATA` writer - PWM2 data holding
        pub type PWM2_DATA_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            ///Bits 0:7 - PWM2 data holding
            #[inline(always)]
            pub fn pwm2_data(&self) -> PWM2_DATA_R {
                PWM2_DATA_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:7 - PWM2 data holding
            #[inline(always)]
            #[must_use]
            pub fn pwm2_data(&mut self) -> PWM2_DATA_W<PWM2_DATA_SPEC> {
                PWM2_DATA_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///PWM2 data holding
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`pwm2_data::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pwm2_data::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct PWM2_DATA_SPEC;
        impl crate::RegisterSpec for PWM2_DATA_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`pwm2_data::R`](R) reader structure
        impl crate::Readable for PWM2_DATA_SPEC {}
        ///`write(|w| ..)` method takes [`pwm2_data::W`](W) writer structure
        impl crate::Writable for PWM2_DATA_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets PWM2_DATA to value 0
        impl crate::Resettable for PWM2_DATA_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///PWM3_DATA (rw) register accessor: PWM3 data holding
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`pwm3_data::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pwm3_data::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@pwm3_data`]
    ///module
    pub type PWM3_DATA = crate::Reg<pwm3_data::PWM3_DATA_SPEC>;
    ///PWM3 data holding
    pub mod pwm3_data {
        ///Register `PWM3_DATA` reader
        pub type R = crate::R<PWM3_DATA_SPEC>;
        ///Register `PWM3_DATA` writer
        pub type W = crate::W<PWM3_DATA_SPEC>;
        ///Field `PWM3_DATA` reader - PWM3 data holding
        pub type PWM3_DATA_R = crate::FieldReader;
        ///Field `PWM3_DATA` writer - PWM3 data holding
        pub type PWM3_DATA_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            ///Bits 0:7 - PWM3 data holding
            #[inline(always)]
            pub fn pwm3_data(&self) -> PWM3_DATA_R {
                PWM3_DATA_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:7 - PWM3 data holding
            #[inline(always)]
            #[must_use]
            pub fn pwm3_data(&mut self) -> PWM3_DATA_W<PWM3_DATA_SPEC> {
                PWM3_DATA_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///PWM3 data holding
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`pwm3_data::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pwm3_data::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct PWM3_DATA_SPEC;
        impl crate::RegisterSpec for PWM3_DATA_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`pwm3_data::R`](R) reader structure
        impl crate::Readable for PWM3_DATA_SPEC {}
        ///`write(|w| ..)` method takes [`pwm3_data::W`](W) writer structure
        impl crate::Writable for PWM3_DATA_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets PWM3_DATA to value 0
        impl crate::Resettable for PWM3_DATA_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///PWM_DATA (rw) register accessor: PWM data register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`pwm_data::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pwm_data::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@pwm_data`]
    ///module
    pub type PWM_DATA = crate::Reg<pwm_data::PWM_DATA_SPEC>;
    ///PWM data register
    pub mod pwm_data {
        ///Register `PWM_DATA` reader
        pub type R = crate::R<PWM_DATA_SPEC>;
        ///Register `PWM_DATA` writer
        pub type W = crate::W<PWM_DATA_SPEC>;
        ///Field `DATA0` reader - PWM0 data
        pub type DATA0_R = crate::FieldReader;
        ///Field `DATA0` writer - PWM0 data
        pub type DATA0_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        ///Field `DATA1` reader - PWM1 data
        pub type DATA1_R = crate::FieldReader;
        ///Field `DATA1` writer - PWM1 data
        pub type DATA1_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        ///Field `DATA2` reader - PWM2 data
        pub type DATA2_R = crate::FieldReader;
        ///Field `DATA2` writer - PWM2 data
        pub type DATA2_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        ///Field `DATA3` reader - PWM3 data
        pub type DATA3_R = crate::FieldReader;
        ///Field `DATA3` writer - PWM3 data
        pub type DATA3_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            ///Bits 0:7 - PWM0 data
            #[inline(always)]
            pub fn data0(&self) -> DATA0_R {
                DATA0_R::new((self.bits & 0xff) as u8)
            }
            ///Bits 8:15 - PWM1 data
            #[inline(always)]
            pub fn data1(&self) -> DATA1_R {
                DATA1_R::new(((self.bits >> 8) & 0xff) as u8)
            }
            ///Bits 16:23 - PWM2 data
            #[inline(always)]
            pub fn data2(&self) -> DATA2_R {
                DATA2_R::new(((self.bits >> 16) & 0xff) as u8)
            }
            ///Bits 24:31 - PWM3 data
            #[inline(always)]
            pub fn data3(&self) -> DATA3_R {
                DATA3_R::new(((self.bits >> 24) & 0xff) as u8)
            }
        }
        impl W {
            ///Bits 0:7 - PWM0 data
            #[inline(always)]
            #[must_use]
            pub fn data0(&mut self) -> DATA0_W<PWM_DATA_SPEC> {
                DATA0_W::new(self, 0)
            }
            ///Bits 8:15 - PWM1 data
            #[inline(always)]
            #[must_use]
            pub fn data1(&mut self) -> DATA1_W<PWM_DATA_SPEC> {
                DATA1_W::new(self, 8)
            }
            ///Bits 16:23 - PWM2 data
            #[inline(always)]
            #[must_use]
            pub fn data2(&mut self) -> DATA2_W<PWM_DATA_SPEC> {
                DATA2_W::new(self, 16)
            }
            ///Bits 24:31 - PWM3 data
            #[inline(always)]
            #[must_use]
            pub fn data3(&mut self) -> DATA3_W<PWM_DATA_SPEC> {
                DATA3_W::new(self, 24)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///PWM data register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`pwm_data::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pwm_data::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct PWM_DATA_SPEC;
        impl crate::RegisterSpec for PWM_DATA_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`pwm_data::R`](R) reader structure
        impl crate::Readable for PWM_DATA_SPEC {}
        ///`write(|w| ..)` method takes [`pwm_data::W`](W) writer structure
        impl crate::Writable for PWM_DATA_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets PWM_DATA to value 0
        impl crate::Resettable for PWM_DATA_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
}
///HSPI register
pub struct HSPI {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for HSPI {}
impl HSPI {
    ///Pointer to the register block
    pub const PTR: *const hspi::RegisterBlock = 0x4000_6000 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const hspi::RegisterBlock {
        Self::PTR
    }
    /// Steal an instance of this peripheral
    ///
    /// # Safety
    ///
    /// Ensure that the new instance of the peripheral cannot be used in a way
    /// that may race with any existing instances, for example by only
    /// accessing read-only or write-only registers, or by consuming the
    /// original peripheral and using critical sections to coordinate
    /// access between multiple new instances.
    ///
    /// Additionally, other software such as HALs may rely on only one
    /// peripheral instance existing to ensure memory safety; ensure
    /// no stolen instances are passed to such software.
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for HSPI {
    type Target = hspi::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for HSPI {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("HSPI").finish()
    }
}
///HSPI register
pub mod hspi {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        cfg: CFG,
        ctrl: CTRL,
        int_en: INT_EN,
        aux: AUX,
        tx_addr0: TX_ADDR0,
        tx_addr1: TX_ADDR1,
        rx_addr0: RX_ADDR0,
        rx_addr1: RX_ADDR1,
        dma_len0: DMA_LEN0,
        rx_len0: RX_LEN0,
        dma_len1: DMA_LEN1,
        rx_len1: RX_LEN1,
        burst_cfg: BURST_CFG,
        burst_cnt: BURST_CNT,
        _reserved14: [u8; 0x01],
        udf0: UDF0,
        udf1: UDF1,
        int_flag: INT_FLAG,
        rtx_status: RTX_STATUS,
        tx_sc: TX_SC,
        rx_sc: RX_SC,
    }
    impl RegisterBlock {
        ///0x00 - parallel if tx or rx cfg
        #[inline(always)]
        pub const fn cfg(&self) -> &CFG {
            &self.cfg
        }
        ///0x01 - parallel if tx or rx control
        #[inline(always)]
        pub const fn ctrl(&self) -> &CTRL {
            &self.ctrl
        }
        ///0x02 - parallel if interrupt enable register
        #[inline(always)]
        pub const fn int_en(&self) -> &INT_EN {
            &self.int_en
        }
        ///0x03 - parallel if aux
        #[inline(always)]
        pub const fn aux(&self) -> &AUX {
            &self.aux
        }
        ///0x04 - parallel if dma tx addr0
        #[inline(always)]
        pub const fn tx_addr0(&self) -> &TX_ADDR0 {
            &self.tx_addr0
        }
        ///0x08 - parallel if dma tx addr1
        #[inline(always)]
        pub const fn tx_addr1(&self) -> &TX_ADDR1 {
            &self.tx_addr1
        }
        ///0x0c - parallel if dma rx addr0
        #[inline(always)]
        pub const fn rx_addr0(&self) -> &RX_ADDR0 {
            &self.rx_addr0
        }
        ///0x10 - parallel if dma rx addr1
        #[inline(always)]
        pub const fn rx_addr1(&self) -> &RX_ADDR1 {
            &self.rx_addr1
        }
        ///0x14 - parallel if dma length0
        #[inline(always)]
        pub const fn dma_len0(&self) -> &DMA_LEN0 {
            &self.dma_len0
        }
        ///0x16 - parallel if receive length0
        #[inline(always)]
        pub const fn rx_len0(&self) -> &RX_LEN0 {
            &self.rx_len0
        }
        ///0x18 - parallel if dma length1
        #[inline(always)]
        pub const fn dma_len1(&self) -> &DMA_LEN1 {
            &self.dma_len1
        }
        ///0x1a - parallel if receive length1
        #[inline(always)]
        pub const fn rx_len1(&self) -> &RX_LEN1 {
            &self.rx_len1
        }
        ///0x1c - parallel if tx burst config register
        #[inline(always)]
        pub const fn burst_cfg(&self) -> &BURST_CFG {
            &self.burst_cfg
        }
        ///0x1e - parallel if tx burst count
        #[inline(always)]
        pub const fn burst_cnt(&self) -> &BURST_CNT {
            &self.burst_cnt
        }
        ///0x20 - parallel if user defined field 0 register
        #[inline(always)]
        pub const fn udf0(&self) -> &UDF0 {
            &self.udf0
        }
        ///0x24 - parallel if user defined field 1 register
        #[inline(always)]
        pub const fn udf1(&self) -> &UDF1 {
            &self.udf1
        }
        ///0x28 - parallel if interrupt flag
        #[inline(always)]
        pub const fn int_flag(&self) -> &INT_FLAG {
            &self.int_flag
        }
        ///0x29 - parallel rtx status
        #[inline(always)]
        pub const fn rtx_status(&self) -> &RTX_STATUS {
            &self.rtx_status
        }
        ///0x2a - parallel TX sequence ctrl
        #[inline(always)]
        pub const fn tx_sc(&self) -> &TX_SC {
            &self.tx_sc
        }
        ///0x2b - parallel RX sequence ctrl
        #[inline(always)]
        pub const fn rx_sc(&self) -> &RX_SC {
            &self.rx_sc
        }
    }
    ///CFG (rw) register accessor: parallel if tx or rx cfg
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`cfg::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cfg::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    pub type CFG = crate::Reg<cfg::CFG_SPEC>;
    ///parallel if tx or rx cfg
    pub mod cfg {
        ///Register `CFG` reader
        pub type R = crate::R<CFG_SPEC>;
        ///Register `CFG` writer
        pub type W = crate::W<CFG_SPEC>;
        ///Field `MODE` reader - parallel if mode
        pub type MODE_R = crate::BitReader;
        ///Field `MODE` writer - parallel if mode
        pub type MODE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `DUALDMA` reader - parallel if dualdma mode enable
        pub type DUALDMA_R = crate::BitReader;
        ///Field `DUALDMA` writer - parallel if dualdma mode enable
        pub type DUALDMA_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `MSK_SIZE` reader - parallel if data mode
        pub type MSK_SIZE_R = crate::FieldReader;
        ///Field `MSK_SIZE` writer - parallel if data mode
        pub type MSK_SIZE_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `TX_TOG_EN` reader - parallel if tx addr toggle enable
        pub type TX_TOG_EN_R = crate::BitReader;
        ///Field `TX_TOG_EN` writer - parallel if tx addr toggle enable
        pub type TX_TOG_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `RX_TOG_EN` reader - parallel if rx addr toggle enable
        pub type RX_TOG_EN_R = crate::BitReader;
        ///Field `RX_TOG_EN` writer - parallel if rx addr toggle enable
        pub type RX_TOG_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `HW_ACK` reader - parallel if tx ack by hardware
        pub type HW_ACK_R = crate::BitReader;
        ///Field `HW_ACK` writer - parallel if tx ack by hardware
        pub type HW_ACK_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - parallel if mode
            #[inline(always)]
            pub fn mode(&self) -> MODE_R {
                MODE_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - parallel if dualdma mode enable
            #[inline(always)]
            pub fn dualdma(&self) -> DUALDMA_R {
                DUALDMA_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bits 2:3 - parallel if data mode
            #[inline(always)]
            pub fn msk_size(&self) -> MSK_SIZE_R {
                MSK_SIZE_R::new((self.bits >> 2) & 3)
            }
            ///Bit 5 - parallel if tx addr toggle enable
            #[inline(always)]
            pub fn tx_tog_en(&self) -> TX_TOG_EN_R {
                TX_TOG_EN_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - parallel if rx addr toggle enable
            #[inline(always)]
            pub fn rx_tog_en(&self) -> RX_TOG_EN_R {
                RX_TOG_EN_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - parallel if tx ack by hardware
            #[inline(always)]
            pub fn hw_ack(&self) -> HW_ACK_R {
                HW_ACK_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - parallel if mode
            #[inline(always)]
            #[must_use]
            pub fn mode(&mut self) -> MODE_W<CFG_SPEC> {
                MODE_W::new(self, 0)
            }
            ///Bit 1 - parallel if dualdma mode enable
            #[inline(always)]
            #[must_use]
            pub fn dualdma(&mut self) -> DUALDMA_W<CFG_SPEC> {
                DUALDMA_W::new(self, 1)
            }
            ///Bits 2:3 - parallel if data mode
            #[inline(always)]
            #[must_use]
            pub fn msk_size(&mut self) -> MSK_SIZE_W<CFG_SPEC> {
                MSK_SIZE_W::new(self, 2)
            }
            ///Bit 5 - parallel if tx addr toggle enable
            #[inline(always)]
            #[must_use]
            pub fn tx_tog_en(&mut self) -> TX_TOG_EN_W<CFG_SPEC> {
                TX_TOG_EN_W::new(self, 5)
            }
            ///Bit 6 - parallel if rx addr toggle enable
            #[inline(always)]
            #[must_use]
            pub fn rx_tog_en(&mut self) -> RX_TOG_EN_W<CFG_SPEC> {
                RX_TOG_EN_W::new(self, 6)
            }
            ///Bit 7 - parallel if tx ack by hardware
            #[inline(always)]
            #[must_use]
            pub fn hw_ack(&mut self) -> HW_ACK_W<CFG_SPEC> {
                HW_ACK_W::new(self, 7)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///parallel if tx or rx cfg
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`cfg::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cfg::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct CFG_SPEC;
        impl crate::RegisterSpec for CFG_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`cfg::R`](R) reader structure
        impl crate::Readable for CFG_SPEC {}
        ///`write(|w| ..)` method takes [`cfg::W`](W) writer structure
        impl crate::Writable for CFG_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets CFG to value 0x82
        impl crate::Resettable for CFG_SPEC {
            const RESET_VALUE: u8 = 0x82;
        }
    }
    ///CTRL (rw) register accessor: parallel if tx or rx control
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`ctrl::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ctrl::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@ctrl`]
    ///module
    pub type CTRL = crate::Reg<ctrl::CTRL_SPEC>;
    ///parallel if tx or rx control
    pub mod ctrl {
        ///Register `CTRL` reader
        pub type R = crate::R<CTRL_SPEC>;
        ///Register `CTRL` writer
        pub type W = crate::W<CTRL_SPEC>;
        ///Field `ENABLE` reader - parallel if enable
        pub type ENABLE_R = crate::BitReader;
        ///Field `ENABLE` writer - parallel if enable
        pub type ENABLE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `DMA_EN` reader - parallel if dma enable
        pub type DMA_EN_R = crate::BitReader;
        ///Field `DMA_EN` writer - parallel if dma enable
        pub type DMA_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `SW_ACT` reader - parallel if transmit software trigger
        pub type SW_ACT_R = crate::BitReader;
        ///Field `SW_ACT` writer - parallel if transmit software trigger
        pub type SW_ACT_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `ALL_CLR` reader - parallel if all clear
        pub type ALL_CLR_R = crate::BitReader;
        ///Field `ALL_CLR` writer - parallel if all clear
        pub type ALL_CLR_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TRX_RST` reader - parallel if tx and rx logic clear, high action
        pub type TRX_RST_R = crate::BitReader;
        ///Field `TRX_RST` writer - parallel if tx and rx logic clear, high action
        pub type TRX_RST_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - parallel if enable
            #[inline(always)]
            pub fn enable(&self) -> ENABLE_R {
                ENABLE_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - parallel if dma enable
            #[inline(always)]
            pub fn dma_en(&self) -> DMA_EN_R {
                DMA_EN_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - parallel if transmit software trigger
            #[inline(always)]
            pub fn sw_act(&self) -> SW_ACT_R {
                SW_ACT_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - parallel if all clear
            #[inline(always)]
            pub fn all_clr(&self) -> ALL_CLR_R {
                ALL_CLR_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - parallel if tx and rx logic clear, high action
            #[inline(always)]
            pub fn trx_rst(&self) -> TRX_RST_R {
                TRX_RST_R::new(((self.bits >> 4) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - parallel if enable
            #[inline(always)]
            #[must_use]
            pub fn enable(&mut self) -> ENABLE_W<CTRL_SPEC> {
                ENABLE_W::new(self, 0)
            }
            ///Bit 1 - parallel if dma enable
            #[inline(always)]
            #[must_use]
            pub fn dma_en(&mut self) -> DMA_EN_W<CTRL_SPEC> {
                DMA_EN_W::new(self, 1)
            }
            ///Bit 2 - parallel if transmit software trigger
            #[inline(always)]
            #[must_use]
            pub fn sw_act(&mut self) -> SW_ACT_W<CTRL_SPEC> {
                SW_ACT_W::new(self, 2)
            }
            ///Bit 3 - parallel if all clear
            #[inline(always)]
            #[must_use]
            pub fn all_clr(&mut self) -> ALL_CLR_W<CTRL_SPEC> {
                ALL_CLR_W::new(self, 3)
            }
            ///Bit 4 - parallel if tx and rx logic clear, high action
            #[inline(always)]
            #[must_use]
            pub fn trx_rst(&mut self) -> TRX_RST_W<CTRL_SPEC> {
                TRX_RST_W::new(self, 4)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///parallel if tx or rx control
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`ctrl::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ctrl::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct CTRL_SPEC;
        impl crate::RegisterSpec for CTRL_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`ctrl::R`](R) reader structure
        impl crate::Readable for CTRL_SPEC {}
        ///`write(|w| ..)` method takes [`ctrl::W`](W) writer structure
        impl crate::Writable for CTRL_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets CTRL to value 0x18
        impl crate::Resettable for CTRL_SPEC {
            const RESET_VALUE: u8 = 0x18;
        }
    }
    ///INT_EN (rw) register accessor: parallel if interrupt enable register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`int_en::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`int_en::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@int_en`]
    ///module
    pub type INT_EN = crate::Reg<int_en::INT_EN_SPEC>;
    ///parallel if interrupt enable register
    pub mod int_en {
        ///Register `INT_EN` reader
        pub type R = crate::R<INT_EN_SPEC>;
        ///Register `INT_EN` writer
        pub type W = crate::W<INT_EN_SPEC>;
        ///Field `IE_T_DONE` reader - parallel if transmit done interrupt enable
        pub type IE_T_DONE_R = crate::BitReader;
        ///Field `IE_T_DONE` writer - parallel if transmit done interrupt enable
        pub type IE_T_DONE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `IE_R_DONE` reader - parallel if receive done interrupt enable
        pub type IE_R_DONE_R = crate::BitReader;
        ///Field `IE_R_DONE` writer - parallel if receive done interrupt enable
        pub type IE_R_DONE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `IE_FIFO_OV` reader - parallel if fifo overflow interrupt enable
        pub type IE_FIFO_OV_R = crate::BitReader;
        ///Field `IE_FIFO_OV` writer - parallel if fifo overflow interrupt enable
        pub type IE_FIFO_OV_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `IE_B_DONE` reader - parallel if tx burst done interrupt enable
        pub type IE_B_DONE_R = crate::BitReader;
        ///Field `IE_B_DONE` writer - parallel if tx burst done interrupt enable
        pub type IE_B_DONE_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - parallel if transmit done interrupt enable
            #[inline(always)]
            pub fn ie_t_done(&self) -> IE_T_DONE_R {
                IE_T_DONE_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - parallel if receive done interrupt enable
            #[inline(always)]
            pub fn ie_r_done(&self) -> IE_R_DONE_R {
                IE_R_DONE_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - parallel if fifo overflow interrupt enable
            #[inline(always)]
            pub fn ie_fifo_ov(&self) -> IE_FIFO_OV_R {
                IE_FIFO_OV_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - parallel if tx burst done interrupt enable
            #[inline(always)]
            pub fn ie_b_done(&self) -> IE_B_DONE_R {
                IE_B_DONE_R::new(((self.bits >> 3) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - parallel if transmit done interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn ie_t_done(&mut self) -> IE_T_DONE_W<INT_EN_SPEC> {
                IE_T_DONE_W::new(self, 0)
            }
            ///Bit 1 - parallel if receive done interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn ie_r_done(&mut self) -> IE_R_DONE_W<INT_EN_SPEC> {
                IE_R_DONE_W::new(self, 1)
            }
            ///Bit 2 - parallel if fifo overflow interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn ie_fifo_ov(&mut self) -> IE_FIFO_OV_W<INT_EN_SPEC> {
                IE_FIFO_OV_W::new(self, 2)
            }
            ///Bit 3 - parallel if tx burst done interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn ie_b_done(&mut self) -> IE_B_DONE_W<INT_EN_SPEC> {
                IE_B_DONE_W::new(self, 3)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///parallel if interrupt enable register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`int_en::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`int_en::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct INT_EN_SPEC;
        impl crate::RegisterSpec for INT_EN_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`int_en::R`](R) reader structure
        impl crate::Readable for INT_EN_SPEC {}
        ///`write(|w| ..)` method takes [`int_en::W`](W) writer structure
        impl crate::Writable for INT_EN_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets INT_EN to value 0
        impl crate::Resettable for INT_EN_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///AUX (rw) register accessor: parallel if aux
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`aux::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`aux::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@aux`]
    ///module
    pub type AUX = crate::Reg<aux::AUX_SPEC>;
    ///parallel if aux
    pub mod aux {
        ///Register `AUX` reader
        pub type R = crate::R<AUX_SPEC>;
        ///Register `AUX` writer
        pub type W = crate::W<AUX_SPEC>;
        ///Field `TCK_MOD` reader - parallel if tx clk polar control
        pub type TCK_MOD_R = crate::BitReader;
        ///Field `TCK_MOD` writer - parallel if tx clk polar control
        pub type TCK_MOD_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `RCK_MOD` reader - parallel if rx clk polar control
        pub type RCK_MOD_R = crate::BitReader;
        ///Field `RCK_MOD` writer - parallel if rx clk polar control
        pub type RCK_MOD_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `ACK_TX_MOD` reader - parallel if tx ack mode cfg
        pub type ACK_TX_MOD_R = crate::BitReader;
        ///Field `ACK_TX_MOD` writer - parallel if tx ack mode cfg
        pub type ACK_TX_MOD_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `ACK_CNT_SEL` reader - delay time of parallel if send ack when receive done
        pub type ACK_CNT_SEL_R = crate::FieldReader;
        ///Field `ACK_CNT_SEL` writer - delay time of parallel if send ack when receive done
        pub type ACK_CNT_SEL_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        impl R {
            ///Bit 0 - parallel if tx clk polar control
            #[inline(always)]
            pub fn tck_mod(&self) -> TCK_MOD_R {
                TCK_MOD_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - parallel if rx clk polar control
            #[inline(always)]
            pub fn rck_mod(&self) -> RCK_MOD_R {
                RCK_MOD_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - parallel if tx ack mode cfg
            #[inline(always)]
            pub fn ack_tx_mod(&self) -> ACK_TX_MOD_R {
                ACK_TX_MOD_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bits 3:4 - delay time of parallel if send ack when receive done
            #[inline(always)]
            pub fn ack_cnt_sel(&self) -> ACK_CNT_SEL_R {
                ACK_CNT_SEL_R::new((self.bits >> 3) & 3)
            }
        }
        impl W {
            ///Bit 0 - parallel if tx clk polar control
            #[inline(always)]
            #[must_use]
            pub fn tck_mod(&mut self) -> TCK_MOD_W<AUX_SPEC> {
                TCK_MOD_W::new(self, 0)
            }
            ///Bit 1 - parallel if rx clk polar control
            #[inline(always)]
            #[must_use]
            pub fn rck_mod(&mut self) -> RCK_MOD_W<AUX_SPEC> {
                RCK_MOD_W::new(self, 1)
            }
            ///Bit 2 - parallel if tx ack mode cfg
            #[inline(always)]
            #[must_use]
            pub fn ack_tx_mod(&mut self) -> ACK_TX_MOD_W<AUX_SPEC> {
                ACK_TX_MOD_W::new(self, 2)
            }
            ///Bits 3:4 - delay time of parallel if send ack when receive done
            #[inline(always)]
            #[must_use]
            pub fn ack_cnt_sel(&mut self) -> ACK_CNT_SEL_W<AUX_SPEC> {
                ACK_CNT_SEL_W::new(self, 3)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///parallel if aux
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`aux::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`aux::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct AUX_SPEC;
        impl crate::RegisterSpec for AUX_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`aux::R`](R) reader structure
        impl crate::Readable for AUX_SPEC {}
        ///`write(|w| ..)` method takes [`aux::W`](W) writer structure
        impl crate::Writable for AUX_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets AUX to value 0
        impl crate::Resettable for AUX_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///TX_ADDR0 (rw) register accessor: parallel if dma tx addr0
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`tx_addr0::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`tx_addr0::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@tx_addr0`]
    ///module
    pub type TX_ADDR0 = crate::Reg<tx_addr0::TX_ADDR0_SPEC>;
    ///parallel if dma tx addr0
    pub mod tx_addr0 {
        ///Register `TX_ADDR0` reader
        pub type R = crate::R<TX_ADDR0_SPEC>;
        ///Register `TX_ADDR0` writer
        pub type W = crate::W<TX_ADDR0_SPEC>;
        ///Field `TX_ADDR0` reader - parallel if dma tx addr0
        pub type TX_ADDR0_R = crate::FieldReader<u32>;
        ///Field `TX_ADDR0` writer - parallel if dma tx addr0
        pub type TX_ADDR0_W<'a, REG> = crate::FieldWriter<'a, REG, 17, u32>;
        impl R {
            ///Bits 0:16 - parallel if dma tx addr0
            #[inline(always)]
            pub fn tx_addr0(&self) -> TX_ADDR0_R {
                TX_ADDR0_R::new(self.bits & 0x0001_ffff)
            }
        }
        impl W {
            ///Bits 0:16 - parallel if dma tx addr0
            #[inline(always)]
            #[must_use]
            pub fn tx_addr0(&mut self) -> TX_ADDR0_W<TX_ADDR0_SPEC> {
                TX_ADDR0_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///parallel if dma tx addr0
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`tx_addr0::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`tx_addr0::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct TX_ADDR0_SPEC;
        impl crate::RegisterSpec for TX_ADDR0_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`tx_addr0::R`](R) reader structure
        impl crate::Readable for TX_ADDR0_SPEC {}
        ///`write(|w| ..)` method takes [`tx_addr0::W`](W) writer structure
        impl crate::Writable for TX_ADDR0_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets TX_ADDR0 to value 0
        impl crate::Resettable for TX_ADDR0_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///TX_ADDR1 (rw) register accessor: parallel if dma tx addr1
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`tx_addr1::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`tx_addr1::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@tx_addr1`]
    ///module
    pub type TX_ADDR1 = crate::Reg<tx_addr1::TX_ADDR1_SPEC>;
    ///parallel if dma tx addr1
    pub mod tx_addr1 {
        ///Register `TX_ADDR1` reader
        pub type R = crate::R<TX_ADDR1_SPEC>;
        ///Register `TX_ADDR1` writer
        pub type W = crate::W<TX_ADDR1_SPEC>;
        ///Field `TX_ADDR1` reader - parallel if dma tx addr1
        pub type TX_ADDR1_R = crate::FieldReader<u32>;
        ///Field `TX_ADDR1` writer - parallel if dma tx addr1
        pub type TX_ADDR1_W<'a, REG> = crate::FieldWriter<'a, REG, 17, u32>;
        impl R {
            ///Bits 0:16 - parallel if dma tx addr1
            #[inline(always)]
            pub fn tx_addr1(&self) -> TX_ADDR1_R {
                TX_ADDR1_R::new(self.bits & 0x0001_ffff)
            }
        }
        impl W {
            ///Bits 0:16 - parallel if dma tx addr1
            #[inline(always)]
            #[must_use]
            pub fn tx_addr1(&mut self) -> TX_ADDR1_W<TX_ADDR1_SPEC> {
                TX_ADDR1_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///parallel if dma tx addr1
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`tx_addr1::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`tx_addr1::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct TX_ADDR1_SPEC;
        impl crate::RegisterSpec for TX_ADDR1_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`tx_addr1::R`](R) reader structure
        impl crate::Readable for TX_ADDR1_SPEC {}
        ///`write(|w| ..)` method takes [`tx_addr1::W`](W) writer structure
        impl crate::Writable for TX_ADDR1_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets TX_ADDR1 to value 0
        impl crate::Resettable for TX_ADDR1_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///RX_ADDR0 (rw) register accessor: parallel if dma rx addr0
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`rx_addr0::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`rx_addr0::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@rx_addr0`]
    ///module
    pub type RX_ADDR0 = crate::Reg<rx_addr0::RX_ADDR0_SPEC>;
    ///parallel if dma rx addr0
    pub mod rx_addr0 {
        ///Register `RX_ADDR0` reader
        pub type R = crate::R<RX_ADDR0_SPEC>;
        ///Register `RX_ADDR0` writer
        pub type W = crate::W<RX_ADDR0_SPEC>;
        ///Field `RX_ADDR0` reader - parallel if dma rx addr0
        pub type RX_ADDR0_R = crate::FieldReader<u32>;
        ///Field `RX_ADDR0` writer - parallel if dma rx addr0
        pub type RX_ADDR0_W<'a, REG> = crate::FieldWriter<'a, REG, 17, u32>;
        impl R {
            ///Bits 0:16 - parallel if dma rx addr0
            #[inline(always)]
            pub fn rx_addr0(&self) -> RX_ADDR0_R {
                RX_ADDR0_R::new(self.bits & 0x0001_ffff)
            }
        }
        impl W {
            ///Bits 0:16 - parallel if dma rx addr0
            #[inline(always)]
            #[must_use]
            pub fn rx_addr0(&mut self) -> RX_ADDR0_W<RX_ADDR0_SPEC> {
                RX_ADDR0_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///parallel if dma rx addr0
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`rx_addr0::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`rx_addr0::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct RX_ADDR0_SPEC;
        impl crate::RegisterSpec for RX_ADDR0_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`rx_addr0::R`](R) reader structure
        impl crate::Readable for RX_ADDR0_SPEC {}
        ///`write(|w| ..)` method takes [`rx_addr0::W`](W) writer structure
        impl crate::Writable for RX_ADDR0_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets RX_ADDR0 to value 0
        impl crate::Resettable for RX_ADDR0_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///RX_ADDR1 (rw) register accessor: parallel if dma rx addr1
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`rx_addr1::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`rx_addr1::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@rx_addr1`]
    ///module
    pub type RX_ADDR1 = crate::Reg<rx_addr1::RX_ADDR1_SPEC>;
    ///parallel if dma rx addr1
    pub mod rx_addr1 {
        ///Register `RX_ADDR1` reader
        pub type R = crate::R<RX_ADDR1_SPEC>;
        ///Register `RX_ADDR1` writer
        pub type W = crate::W<RX_ADDR1_SPEC>;
        ///Field `RX_ADDR1` reader - parallel if dma rx addr1
        pub type RX_ADDR1_R = crate::FieldReader<u32>;
        ///Field `RX_ADDR1` writer - parallel if dma rx addr1
        pub type RX_ADDR1_W<'a, REG> = crate::FieldWriter<'a, REG, 17, u32>;
        impl R {
            ///Bits 0:16 - parallel if dma rx addr1
            #[inline(always)]
            pub fn rx_addr1(&self) -> RX_ADDR1_R {
                RX_ADDR1_R::new(self.bits & 0x0001_ffff)
            }
        }
        impl W {
            ///Bits 0:16 - parallel if dma rx addr1
            #[inline(always)]
            #[must_use]
            pub fn rx_addr1(&mut self) -> RX_ADDR1_W<RX_ADDR1_SPEC> {
                RX_ADDR1_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///parallel if dma rx addr1
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`rx_addr1::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`rx_addr1::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct RX_ADDR1_SPEC;
        impl crate::RegisterSpec for RX_ADDR1_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`rx_addr1::R`](R) reader structure
        impl crate::Readable for RX_ADDR1_SPEC {}
        ///`write(|w| ..)` method takes [`rx_addr1::W`](W) writer structure
        impl crate::Writable for RX_ADDR1_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets RX_ADDR1 to value 0
        impl crate::Resettable for RX_ADDR1_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///DMA_LEN0 (rw) register accessor: parallel if dma length0
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`dma_len0::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dma_len0::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@dma_len0`]
    ///module
    pub type DMA_LEN0 = crate::Reg<dma_len0::DMA_LEN0_SPEC>;
    ///parallel if dma length0
    pub mod dma_len0 {
        ///Register `DMA_LEN0` reader
        pub type R = crate::R<DMA_LEN0_SPEC>;
        ///Register `DMA_LEN0` writer
        pub type W = crate::W<DMA_LEN0_SPEC>;
        ///Field `DMA_LEN0` reader - parallel if dma length0
        pub type DMA_LEN0_R = crate::FieldReader<u16>;
        ///Field `DMA_LEN0` writer - parallel if dma length0
        pub type DMA_LEN0_W<'a, REG> = crate::FieldWriter<'a, REG, 12, u16>;
        impl R {
            ///Bits 0:11 - parallel if dma length0
            #[inline(always)]
            pub fn dma_len0(&self) -> DMA_LEN0_R {
                DMA_LEN0_R::new(self.bits & 0x0fff)
            }
        }
        impl W {
            ///Bits 0:11 - parallel if dma length0
            #[inline(always)]
            #[must_use]
            pub fn dma_len0(&mut self) -> DMA_LEN0_W<DMA_LEN0_SPEC> {
                DMA_LEN0_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///parallel if dma length0
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`dma_len0::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dma_len0::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct DMA_LEN0_SPEC;
        impl crate::RegisterSpec for DMA_LEN0_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`dma_len0::R`](R) reader structure
        impl crate::Readable for DMA_LEN0_SPEC {}
        ///`write(|w| ..)` method takes [`dma_len0::W`](W) writer structure
        impl crate::Writable for DMA_LEN0_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets DMA_LEN0 to value 0
        impl crate::Resettable for DMA_LEN0_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///RX_LEN0 (rw) register accessor: parallel if receive length0
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`rx_len0::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`rx_len0::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@rx_len0`]
    ///module
    pub type RX_LEN0 = crate::Reg<rx_len0::RX_LEN0_SPEC>;
    ///parallel if receive length0
    pub mod rx_len0 {
        ///Register `RX_LEN0` reader
        pub type R = crate::R<RX_LEN0_SPEC>;
        ///Register `RX_LEN0` writer
        pub type W = crate::W<RX_LEN0_SPEC>;
        ///Field `RX_LEN0` reader - parallel if dma length0
        pub type RX_LEN0_R = crate::FieldReader<u16>;
        ///Field `RX_LEN0` writer - parallel if dma length0
        pub type RX_LEN0_W<'a, REG> = crate::FieldWriter<'a, REG, 12, u16>;
        impl R {
            ///Bits 0:11 - parallel if dma length0
            #[inline(always)]
            pub fn rx_len0(&self) -> RX_LEN0_R {
                RX_LEN0_R::new(self.bits & 0x0fff)
            }
        }
        impl W {
            ///Bits 0:11 - parallel if dma length0
            #[inline(always)]
            #[must_use]
            pub fn rx_len0(&mut self) -> RX_LEN0_W<RX_LEN0_SPEC> {
                RX_LEN0_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///parallel if receive length0
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`rx_len0::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`rx_len0::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct RX_LEN0_SPEC;
        impl crate::RegisterSpec for RX_LEN0_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`rx_len0::R`](R) reader structure
        impl crate::Readable for RX_LEN0_SPEC {}
        ///`write(|w| ..)` method takes [`rx_len0::W`](W) writer structure
        impl crate::Writable for RX_LEN0_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets RX_LEN0 to value 0
        impl crate::Resettable for RX_LEN0_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///DMA_LEN1 (rw) register accessor: parallel if dma length1
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`dma_len1::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dma_len1::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@dma_len1`]
    ///module
    pub type DMA_LEN1 = crate::Reg<dma_len1::DMA_LEN1_SPEC>;
    ///parallel if dma length1
    pub mod dma_len1 {
        ///Register `DMA_LEN1` reader
        pub type R = crate::R<DMA_LEN1_SPEC>;
        ///Register `DMA_LEN1` writer
        pub type W = crate::W<DMA_LEN1_SPEC>;
        ///Field `DMA_LEN1` reader - parallel if dma length1
        pub type DMA_LEN1_R = crate::FieldReader<u16>;
        ///Field `DMA_LEN1` writer - parallel if dma length1
        pub type DMA_LEN1_W<'a, REG> = crate::FieldWriter<'a, REG, 12, u16>;
        impl R {
            ///Bits 0:11 - parallel if dma length1
            #[inline(always)]
            pub fn dma_len1(&self) -> DMA_LEN1_R {
                DMA_LEN1_R::new(self.bits & 0x0fff)
            }
        }
        impl W {
            ///Bits 0:11 - parallel if dma length1
            #[inline(always)]
            #[must_use]
            pub fn dma_len1(&mut self) -> DMA_LEN1_W<DMA_LEN1_SPEC> {
                DMA_LEN1_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///parallel if dma length1
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`dma_len1::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dma_len1::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct DMA_LEN1_SPEC;
        impl crate::RegisterSpec for DMA_LEN1_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`dma_len1::R`](R) reader structure
        impl crate::Readable for DMA_LEN1_SPEC {}
        ///`write(|w| ..)` method takes [`dma_len1::W`](W) writer structure
        impl crate::Writable for DMA_LEN1_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets DMA_LEN1 to value 0
        impl crate::Resettable for DMA_LEN1_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///RX_LEN1 (rw) register accessor: parallel if receive length1
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`rx_len1::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`rx_len1::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@rx_len1`]
    ///module
    pub type RX_LEN1 = crate::Reg<rx_len1::RX_LEN1_SPEC>;
    ///parallel if receive length1
    pub mod rx_len1 {
        ///Register `RX_LEN1` reader
        pub type R = crate::R<RX_LEN1_SPEC>;
        ///Register `RX_LEN1` writer
        pub type W = crate::W<RX_LEN1_SPEC>;
        ///Field `RX_LEN1` reader - parallel if dma length1
        pub type RX_LEN1_R = crate::FieldReader<u16>;
        ///Field `RX_LEN1` writer - parallel if dma length1
        pub type RX_LEN1_W<'a, REG> = crate::FieldWriter<'a, REG, 12, u16>;
        impl R {
            ///Bits 0:11 - parallel if dma length1
            #[inline(always)]
            pub fn rx_len1(&self) -> RX_LEN1_R {
                RX_LEN1_R::new(self.bits & 0x0fff)
            }
        }
        impl W {
            ///Bits 0:11 - parallel if dma length1
            #[inline(always)]
            #[must_use]
            pub fn rx_len1(&mut self) -> RX_LEN1_W<RX_LEN1_SPEC> {
                RX_LEN1_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///parallel if receive length1
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`rx_len1::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`rx_len1::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct RX_LEN1_SPEC;
        impl crate::RegisterSpec for RX_LEN1_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`rx_len1::R`](R) reader structure
        impl crate::Readable for RX_LEN1_SPEC {}
        ///`write(|w| ..)` method takes [`rx_len1::W`](W) writer structure
        impl crate::Writable for RX_LEN1_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets RX_LEN1 to value 0
        impl crate::Resettable for RX_LEN1_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///BURST_CFG (rw) register accessor: parallel if tx burst config register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`burst_cfg::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`burst_cfg::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@burst_cfg`]
    ///module
    pub type BURST_CFG = crate::Reg<burst_cfg::BURST_CFG_SPEC>;
    ///parallel if tx burst config register
    pub mod burst_cfg {
        ///Register `BURST_CFG` reader
        pub type R = crate::R<BURST_CFG_SPEC>;
        ///Register `BURST_CFG` writer
        pub type W = crate::W<BURST_CFG_SPEC>;
        ///Field `BURST_EN` reader - burst transmit enable
        pub type BURST_EN_R = crate::BitReader;
        ///Field `BURST_EN` writer - burst transmit enable
        pub type BURST_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `BURST_LEN` reader - burst transmit length
        pub type BURST_LEN_R = crate::FieldReader;
        ///Field `BURST_LEN` writer - burst transmit length
        pub type BURST_LEN_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            ///Bit 0 - burst transmit enable
            #[inline(always)]
            pub fn burst_en(&self) -> BURST_EN_R {
                BURST_EN_R::new((self.bits & 1) != 0)
            }
            ///Bits 8:15 - burst transmit length
            #[inline(always)]
            pub fn burst_len(&self) -> BURST_LEN_R {
                BURST_LEN_R::new(((self.bits >> 8) & 0xff) as u8)
            }
        }
        impl W {
            ///Bit 0 - burst transmit enable
            #[inline(always)]
            #[must_use]
            pub fn burst_en(&mut self) -> BURST_EN_W<BURST_CFG_SPEC> {
                BURST_EN_W::new(self, 0)
            }
            ///Bits 8:15 - burst transmit length
            #[inline(always)]
            #[must_use]
            pub fn burst_len(&mut self) -> BURST_LEN_W<BURST_CFG_SPEC> {
                BURST_LEN_W::new(self, 8)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///parallel if tx burst config register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`burst_cfg::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`burst_cfg::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct BURST_CFG_SPEC;
        impl crate::RegisterSpec for BURST_CFG_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`burst_cfg::R`](R) reader structure
        impl crate::Readable for BURST_CFG_SPEC {}
        ///`write(|w| ..)` method takes [`burst_cfg::W`](W) writer structure
        impl crate::Writable for BURST_CFG_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets BURST_CFG to value 0
        impl crate::Resettable for BURST_CFG_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///BURST_CNT (rw) register accessor: parallel if tx burst count
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`burst_cnt::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`burst_cnt::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@burst_cnt`]
    ///module
    pub type BURST_CNT = crate::Reg<burst_cnt::BURST_CNT_SPEC>;
    ///parallel if tx burst count
    pub mod burst_cnt {
        ///Register `BURST_CNT` reader
        pub type R = crate::R<BURST_CNT_SPEC>;
        ///Register `BURST_CNT` writer
        pub type W = crate::W<BURST_CNT_SPEC>;
        ///Field `BURST_CNT` reader - parallel if tx burst count
        pub type BURST_CNT_R = crate::FieldReader;
        ///Field `BURST_CNT` writer - parallel if tx burst count
        pub type BURST_CNT_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            ///Bits 0:7 - parallel if tx burst count
            #[inline(always)]
            pub fn burst_cnt(&self) -> BURST_CNT_R {
                BURST_CNT_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:7 - parallel if tx burst count
            #[inline(always)]
            #[must_use]
            pub fn burst_cnt(&mut self) -> BURST_CNT_W<BURST_CNT_SPEC> {
                BURST_CNT_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///parallel if tx burst count
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`burst_cnt::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`burst_cnt::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct BURST_CNT_SPEC;
        impl crate::RegisterSpec for BURST_CNT_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`burst_cnt::R`](R) reader structure
        impl crate::Readable for BURST_CNT_SPEC {}
        ///`write(|w| ..)` method takes [`burst_cnt::W`](W) writer structure
        impl crate::Writable for BURST_CNT_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets BURST_CNT to value 0
        impl crate::Resettable for BURST_CNT_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///UDF0 (rw) register accessor: parallel if user defined field 0 register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`udf0::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`udf0::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@udf0`]
    ///module
    pub type UDF0 = crate::Reg<udf0::UDF0_SPEC>;
    ///parallel if user defined field 0 register
    pub mod udf0 {
        ///Register `UDF0` reader
        pub type R = crate::R<UDF0_SPEC>;
        ///Register `UDF0` writer
        pub type W = crate::W<UDF0_SPEC>;
        ///Field `UDF0` reader - parallel if user defined field 0 register
        pub type UDF0_R = crate::FieldReader<u32>;
        ///Field `UDF0` writer - parallel if user defined field 0 register
        pub type UDF0_W<'a, REG> = crate::FieldWriter<'a, REG, 26, u32>;
        impl R {
            ///Bits 0:25 - parallel if user defined field 0 register
            #[inline(always)]
            pub fn udf0(&self) -> UDF0_R {
                UDF0_R::new(self.bits & 0x03ff_ffff)
            }
        }
        impl W {
            ///Bits 0:25 - parallel if user defined field 0 register
            #[inline(always)]
            #[must_use]
            pub fn udf0(&mut self) -> UDF0_W<UDF0_SPEC> {
                UDF0_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///parallel if user defined field 0 register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`udf0::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`udf0::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct UDF0_SPEC;
        impl crate::RegisterSpec for UDF0_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`udf0::R`](R) reader structure
        impl crate::Readable for UDF0_SPEC {}
        ///`write(|w| ..)` method takes [`udf0::W`](W) writer structure
        impl crate::Writable for UDF0_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets UDF0 to value 0
        impl crate::Resettable for UDF0_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///UDF1 (rw) register accessor: parallel if user defined field 1 register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`udf1::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`udf1::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@udf1`]
    ///module
    pub type UDF1 = crate::Reg<udf1::UDF1_SPEC>;
    ///parallel if user defined field 1 register
    pub mod udf1 {
        ///Register `UDF1` reader
        pub type R = crate::R<UDF1_SPEC>;
        ///Register `UDF1` writer
        pub type W = crate::W<UDF1_SPEC>;
        ///Field `UDF1` reader - parallel if user defined field 1 register
        pub type UDF1_R = crate::FieldReader<u32>;
        ///Field `UDF1` writer - parallel if user defined field 1 register
        pub type UDF1_W<'a, REG> = crate::FieldWriter<'a, REG, 26, u32>;
        impl R {
            ///Bits 0:25 - parallel if user defined field 1 register
            #[inline(always)]
            pub fn udf1(&self) -> UDF1_R {
                UDF1_R::new(self.bits & 0x03ff_ffff)
            }
        }
        impl W {
            ///Bits 0:25 - parallel if user defined field 1 register
            #[inline(always)]
            #[must_use]
            pub fn udf1(&mut self) -> UDF1_W<UDF1_SPEC> {
                UDF1_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///parallel if user defined field 1 register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`udf1::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`udf1::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct UDF1_SPEC;
        impl crate::RegisterSpec for UDF1_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`udf1::R`](R) reader structure
        impl crate::Readable for UDF1_SPEC {}
        ///`write(|w| ..)` method takes [`udf1::W`](W) writer structure
        impl crate::Writable for UDF1_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets UDF1 to value 0
        impl crate::Resettable for UDF1_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///INT_FLAG (rw) register accessor: parallel if interrupt flag
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`int_flag::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`int_flag::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@int_flag`]
    ///module
    pub type INT_FLAG = crate::Reg<int_flag::INT_FLAG_SPEC>;
    ///parallel if interrupt flag
    pub mod int_flag {
        ///Register `INT_FLAG` reader
        pub type R = crate::R<INT_FLAG_SPEC>;
        ///Register `INT_FLAG` writer
        pub type W = crate::W<INT_FLAG_SPEC>;
        ///Field `IF_T_DONE` reader - interrupt flag for parallel if transmit done
        pub type IF_T_DONE_R = crate::BitReader;
        ///Field `IF_T_DONE` writer - interrupt flag for parallel if transmit done
        pub type IF_T_DONE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `IF_R_DONE` reader - interrupt flag for parallel if receive done
        pub type IF_R_DONE_R = crate::BitReader;
        ///Field `IF_R_DONE` writer - interrupt flag for parallel if receive done
        pub type IF_R_DONE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `IF_FIFO_OV` reader - interrupt flag for parallel if FIFO overflow
        pub type IF_FIFO_OV_R = crate::BitReader;
        ///Field `IF_FIFO_OV` writer - interrupt flag for parallel if FIFO overflow
        pub type IF_FIFO_OV_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `IF_B_DONE` reader - interrupt flag for parallel if tx burst done
        pub type IF_B_DONE_R = crate::BitReader;
        ///Field `IF_B_DONE` writer - interrupt flag for parallel if tx burst done
        pub type IF_B_DONE_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - interrupt flag for parallel if transmit done
            #[inline(always)]
            pub fn if_t_done(&self) -> IF_T_DONE_R {
                IF_T_DONE_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - interrupt flag for parallel if receive done
            #[inline(always)]
            pub fn if_r_done(&self) -> IF_R_DONE_R {
                IF_R_DONE_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - interrupt flag for parallel if FIFO overflow
            #[inline(always)]
            pub fn if_fifo_ov(&self) -> IF_FIFO_OV_R {
                IF_FIFO_OV_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - interrupt flag for parallel if tx burst done
            #[inline(always)]
            pub fn if_b_done(&self) -> IF_B_DONE_R {
                IF_B_DONE_R::new(((self.bits >> 3) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - interrupt flag for parallel if transmit done
            #[inline(always)]
            #[must_use]
            pub fn if_t_done(&mut self) -> IF_T_DONE_W<INT_FLAG_SPEC> {
                IF_T_DONE_W::new(self, 0)
            }
            ///Bit 1 - interrupt flag for parallel if receive done
            #[inline(always)]
            #[must_use]
            pub fn if_r_done(&mut self) -> IF_R_DONE_W<INT_FLAG_SPEC> {
                IF_R_DONE_W::new(self, 1)
            }
            ///Bit 2 - interrupt flag for parallel if FIFO overflow
            #[inline(always)]
            #[must_use]
            pub fn if_fifo_ov(&mut self) -> IF_FIFO_OV_W<INT_FLAG_SPEC> {
                IF_FIFO_OV_W::new(self, 2)
            }
            ///Bit 3 - interrupt flag for parallel if tx burst done
            #[inline(always)]
            #[must_use]
            pub fn if_b_done(&mut self) -> IF_B_DONE_W<INT_FLAG_SPEC> {
                IF_B_DONE_W::new(self, 3)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///parallel if interrupt flag
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`int_flag::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`int_flag::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct INT_FLAG_SPEC;
        impl crate::RegisterSpec for INT_FLAG_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`int_flag::R`](R) reader structure
        impl crate::Readable for INT_FLAG_SPEC {}
        ///`write(|w| ..)` method takes [`int_flag::W`](W) writer structure
        impl crate::Writable for INT_FLAG_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets INT_FLAG to value 0
        impl crate::Resettable for INT_FLAG_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///RTX_STATUS (rw) register accessor: parallel rtx status
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`rtx_status::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`rtx_status::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@rtx_status`]
    ///module
    pub type RTX_STATUS = crate::Reg<rtx_status::RTX_STATUS_SPEC>;
    ///parallel rtx status
    pub mod rtx_status {
        ///Register `RTX_STATUS` reader
        pub type R = crate::R<RTX_STATUS_SPEC>;
        ///Register `RTX_STATUS` writer
        pub type W = crate::W<RTX_STATUS_SPEC>;
        ///Field `CRC_ERR` reader - CRC error occur
        pub type CRC_ERR_R = crate::BitReader;
        ///Field `CRC_ERR` writer - CRC error occur
        pub type CRC_ERR_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `NUM_MIS` reader - rx and tx sequence number mismatch
        pub type NUM_MIS_R = crate::BitReader;
        ///Field `NUM_MIS` writer - rx and tx sequence number mismatch
        pub type NUM_MIS_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 1 - CRC error occur
            #[inline(always)]
            pub fn crc_err(&self) -> CRC_ERR_R {
                CRC_ERR_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - rx and tx sequence number mismatch
            #[inline(always)]
            pub fn num_mis(&self) -> NUM_MIS_R {
                NUM_MIS_R::new(((self.bits >> 2) & 1) != 0)
            }
        }
        impl W {
            ///Bit 1 - CRC error occur
            #[inline(always)]
            #[must_use]
            pub fn crc_err(&mut self) -> CRC_ERR_W<RTX_STATUS_SPEC> {
                CRC_ERR_W::new(self, 1)
            }
            ///Bit 2 - rx and tx sequence number mismatch
            #[inline(always)]
            #[must_use]
            pub fn num_mis(&mut self) -> NUM_MIS_W<RTX_STATUS_SPEC> {
                NUM_MIS_W::new(self, 2)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///parallel rtx status
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`rtx_status::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`rtx_status::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct RTX_STATUS_SPEC;
        impl crate::RegisterSpec for RTX_STATUS_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`rtx_status::R`](R) reader structure
        impl crate::Readable for RTX_STATUS_SPEC {}
        ///`write(|w| ..)` method takes [`rtx_status::W`](W) writer structure
        impl crate::Writable for RTX_STATUS_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets RTX_STATUS to value 0
        impl crate::Resettable for RTX_STATUS_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///TX_SC (rw) register accessor: parallel TX sequence ctrl
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`tx_sc::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`tx_sc::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@tx_sc`]
    ///module
    pub type TX_SC = crate::Reg<tx_sc::TX_SC_SPEC>;
    ///parallel TX sequence ctrl
    pub mod tx_sc {
        ///Register `TX_SC` reader
        pub type R = crate::R<TX_SC_SPEC>;
        ///Register `TX_SC` writer
        pub type W = crate::W<TX_SC_SPEC>;
        ///Field `TX_NUM` reader - parallel if tx sequence num
        pub type TX_NUM_R = crate::FieldReader;
        ///Field `TX_NUM` writer - parallel if tx sequence num
        pub type TX_NUM_W<'a, REG> = crate::FieldWriter<'a, REG, 4>;
        ///Field `TX_TOG` reader - parallel if tx addr toggle flag
        pub type TX_TOG_R = crate::BitReader;
        ///Field `TX_TOG` writer - parallel if tx addr toggle flag
        pub type TX_TOG_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bits 0:3 - parallel if tx sequence num
            #[inline(always)]
            pub fn tx_num(&self) -> TX_NUM_R {
                TX_NUM_R::new(self.bits & 0x0f)
            }
            ///Bit 4 - parallel if tx addr toggle flag
            #[inline(always)]
            pub fn tx_tog(&self) -> TX_TOG_R {
                TX_TOG_R::new(((self.bits >> 4) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:3 - parallel if tx sequence num
            #[inline(always)]
            #[must_use]
            pub fn tx_num(&mut self) -> TX_NUM_W<TX_SC_SPEC> {
                TX_NUM_W::new(self, 0)
            }
            ///Bit 4 - parallel if tx addr toggle flag
            #[inline(always)]
            #[must_use]
            pub fn tx_tog(&mut self) -> TX_TOG_W<TX_SC_SPEC> {
                TX_TOG_W::new(self, 4)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///parallel TX sequence ctrl
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`tx_sc::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`tx_sc::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct TX_SC_SPEC;
        impl crate::RegisterSpec for TX_SC_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`tx_sc::R`](R) reader structure
        impl crate::Readable for TX_SC_SPEC {}
        ///`write(|w| ..)` method takes [`tx_sc::W`](W) writer structure
        impl crate::Writable for TX_SC_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets TX_SC to value 0
        impl crate::Resettable for TX_SC_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///RX_SC (rw) register accessor: parallel RX sequence ctrl
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`rx_sc::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`rx_sc::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@rx_sc`]
    ///module
    pub type RX_SC = crate::Reg<rx_sc::RX_SC_SPEC>;
    ///parallel RX sequence ctrl
    pub mod rx_sc {
        ///Register `RX_SC` reader
        pub type R = crate::R<RX_SC_SPEC>;
        ///Register `RX_SC` writer
        pub type W = crate::W<RX_SC_SPEC>;
        ///Field `RX_NUM` reader - parallel if rx sequence num
        pub type RX_NUM_R = crate::FieldReader;
        ///Field `RX_NUM` writer - parallel if rx sequence num
        pub type RX_NUM_W<'a, REG> = crate::FieldWriter<'a, REG, 4>;
        ///Field `RX_TOG` reader - parallel if rx addr toggle flag
        pub type RX_TOG_R = crate::BitReader;
        ///Field `RX_TOG` writer - parallel if rx addr toggle flag
        pub type RX_TOG_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bits 0:3 - parallel if rx sequence num
            #[inline(always)]
            pub fn rx_num(&self) -> RX_NUM_R {
                RX_NUM_R::new(self.bits & 0x0f)
            }
            ///Bit 4 - parallel if rx addr toggle flag
            #[inline(always)]
            pub fn rx_tog(&self) -> RX_TOG_R {
                RX_TOG_R::new(((self.bits >> 4) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:3 - parallel if rx sequence num
            #[inline(always)]
            #[must_use]
            pub fn rx_num(&mut self) -> RX_NUM_W<RX_SC_SPEC> {
                RX_NUM_W::new(self, 0)
            }
            ///Bit 4 - parallel if rx addr toggle flag
            #[inline(always)]
            #[must_use]
            pub fn rx_tog(&mut self) -> RX_TOG_W<RX_SC_SPEC> {
                RX_TOG_W::new(self, 4)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///parallel RX sequence ctrl
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`rx_sc::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`rx_sc::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct RX_SC_SPEC;
        impl crate::RegisterSpec for RX_SC_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`rx_sc::R`](R) reader structure
        impl crate::Readable for RX_SC_SPEC {}
        ///`write(|w| ..)` method takes [`rx_sc::W`](W) writer structure
        impl crate::Writable for RX_SC_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets RX_SC to value 0
        impl crate::Resettable for RX_SC_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
}
///ECDC register
pub struct ECDC {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for ECDC {}
impl ECDC {
    ///Pointer to the register block
    pub const PTR: *const ecdc::RegisterBlock = 0x4000_7000 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const ecdc::RegisterBlock {
        Self::PTR
    }
    /// Steal an instance of this peripheral
    ///
    /// # Safety
    ///
    /// Ensure that the new instance of the peripheral cannot be used in a way
    /// that may race with any existing instances, for example by only
    /// accessing read-only or write-only registers, or by consuming the
    /// original peripheral and using critical sections to coordinate
    /// access between multiple new instances.
    ///
    /// Additionally, other software such as HALs may rely on only one
    /// peripheral instance existing to ensure memory safety; ensure
    /// no stolen instances are passed to such software.
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for ECDC {
    type Target = ecdc::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for ECDC {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("ECDC").finish()
    }
}
///ECDC register
pub mod ecdc {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        ecec_ctrl: ECEC_CTRL,
        int_en: INT_EN,
        _reserved2: [u8; 0x03],
        int_fg: INT_FG,
        _reserved3: [u8; 0x01],
        key_255t224: KEY_255T224,
        key_223t192: KEY_223T192,
        key_191t160: KEY_191T160,
        key_159t128: KEY_159T128,
        key_127t96: KEY_127T96,
        key_95t64: KEY_95T64,
        key_63t32: KEY_63T32,
        key_31t0: KEY_31T0,
        iv_127t96: IV_127T96,
        iv_95t64: IV_95T64,
        iv_63t32: IV_63T32,
        iv_31t0: IV_31T0,
        _reserved15: [u8; 0x08],
        sgsd_127t96: SGSD_127T96,
        sgsd_95t64: SGSD_95T64,
        sgsd_63t32: SGSD_63T32,
        sgsd_31t0: SGSD_31T0,
        sgrt_127t96: SGRT_127T96,
        sgrt_95t64: SGRT_95T64,
        sgrt_63t32: SGRT_63T32,
        sgrt_31t0: SGRT_31T0,
        sram_addr: SRAM_ADDR,
        sram_len: SRAM_LEN,
    }
    impl RegisterBlock {
        ///0x00 - ECED AES/SM4 register
        #[inline(always)]
        pub const fn ecec_ctrl(&self) -> &ECEC_CTRL {
            &self.ecec_ctrl
        }
        ///0x02 - Interupt enable register
        #[inline(always)]
        pub const fn int_en(&self) -> &INT_EN {
            &self.int_en
        }
        ///0x06 - Interupt flag register
        #[inline(always)]
        pub const fn int_fg(&self) -> &INT_FG {
            &self.int_fg
        }
        ///0x08 - User key 224-255 register
        #[inline(always)]
        pub const fn key_255t224(&self) -> &KEY_255T224 {
            &self.key_255t224
        }
        ///0x0c - User key 192-223 register
        #[inline(always)]
        pub const fn key_223t192(&self) -> &KEY_223T192 {
            &self.key_223t192
        }
        ///0x10 - User key 160-191 register
        #[inline(always)]
        pub const fn key_191t160(&self) -> &KEY_191T160 {
            &self.key_191t160
        }
        ///0x14 - User key 128-159 register
        #[inline(always)]
        pub const fn key_159t128(&self) -> &KEY_159T128 {
            &self.key_159t128
        }
        ///0x18 - User key 96-127 register
        #[inline(always)]
        pub const fn key_127t96(&self) -> &KEY_127T96 {
            &self.key_127t96
        }
        ///0x1c - User key 64-95 register
        #[inline(always)]
        pub const fn key_95t64(&self) -> &KEY_95T64 {
            &self.key_95t64
        }
        ///0x20 - User key 32-63 register
        #[inline(always)]
        pub const fn key_63t32(&self) -> &KEY_63T32 {
            &self.key_63t32
        }
        ///0x24 - User key 0-31 register
        #[inline(always)]
        pub const fn key_31t0(&self) -> &KEY_31T0 {
            &self.key_31t0
        }
        ///0x28 - CTR mode count 96-127 register
        #[inline(always)]
        pub const fn iv_127t96(&self) -> &IV_127T96 {
            &self.iv_127t96
        }
        ///0x2c - CTR mode count 64-95 register
        #[inline(always)]
        pub const fn iv_95t64(&self) -> &IV_95T64 {
            &self.iv_95t64
        }
        ///0x30 - CTR mode count 32-63 register
        #[inline(always)]
        pub const fn iv_63t32(&self) -> &IV_63T32 {
            &self.iv_63t32
        }
        ///0x34 - CTR mode count 0-31 register
        #[inline(always)]
        pub const fn iv_31t0(&self) -> &IV_31T0 {
            &self.iv_31t0
        }
        ///0x40 - Single encryption and decryption of original data 96-127 register
        #[inline(always)]
        pub const fn sgsd_127t96(&self) -> &SGSD_127T96 {
            &self.sgsd_127t96
        }
        ///0x44 - Single encryption and decryption of original data 64-95 register
        #[inline(always)]
        pub const fn sgsd_95t64(&self) -> &SGSD_95T64 {
            &self.sgsd_95t64
        }
        ///0x48 - Single encryption and decryption of original data 32-63 register
        #[inline(always)]
        pub const fn sgsd_63t32(&self) -> &SGSD_63T32 {
            &self.sgsd_63t32
        }
        ///0x4c - Single encryption and decryption of original data 0-31 register
        #[inline(always)]
        pub const fn sgsd_31t0(&self) -> &SGSD_31T0 {
            &self.sgsd_31t0
        }
        ///0x50 - Single encryption and decryption result 96-127 register
        #[inline(always)]
        pub const fn sgrt_127t96(&self) -> &SGRT_127T96 {
            &self.sgrt_127t96
        }
        ///0x54 - Single encryption and decryption result 64-95 register
        #[inline(always)]
        pub const fn sgrt_95t64(&self) -> &SGRT_95T64 {
            &self.sgrt_95t64
        }
        ///0x58 - Single encryption and decryption result 0-31 register
        #[inline(always)]
        pub const fn sgrt_63t32(&self) -> &SGRT_63T32 {
            &self.sgrt_63t32
        }
        ///0x5c - Single encryption and decryption result 0-31 register
        #[inline(always)]
        pub const fn sgrt_31t0(&self) -> &SGRT_31T0 {
            &self.sgrt_31t0
        }
        ///0x60 - encryption and decryption sram start address register
        #[inline(always)]
        pub const fn sram_addr(&self) -> &SRAM_ADDR {
            &self.sram_addr
        }
        ///0x64 - encryption and decryption sram size register
        #[inline(always)]
        pub const fn sram_len(&self) -> &SRAM_LEN {
            &self.sram_len
        }
    }
    ///ECEC_CTRL (rw) register accessor: ECED AES/SM4 register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`ecec_ctrl::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ecec_ctrl::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@ecec_ctrl`]
    ///module
    pub type ECEC_CTRL = crate::Reg<ecec_ctrl::ECEC_CTRL_SPEC>;
    ///ECED AES/SM4 register
    pub mod ecec_ctrl {
        ///Register `ECEC_CTRL` reader
        pub type R = crate::R<ECEC_CTRL_SPEC>;
        ///Register `ECEC_CTRL` writer
        pub type W = crate::W<ECEC_CTRL_SPEC>;
        ///Field `KEYEX_EN` reader - enable key expansion
        pub type KEYEX_EN_R = crate::BitReader;
        ///Field `KEYEX_EN` writer - enable key expansion
        pub type KEYEX_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `RDPERI_EN` reader - when write data to dma
        pub type RDPERI_EN_R = crate::BitReader;
        ///Field `RDPERI_EN` writer - when write data to dma
        pub type RDPERI_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `WRPERI_EN` reader - when read data from dma
        pub type WRPERI_EN_R = crate::BitReader;
        ///Field `WRPERI_EN` writer - when read data from dma
        pub type WRPERI_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `MODE_SEL` reader - ECDC mode select
        pub type MODE_SEL_R = crate::BitReader;
        ///Field `MODE_SEL` writer - ECDC mode select
        pub type MODE_SEL_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CLKDIV_MASK` reader - Clock divide factor
        pub type CLKDIV_MASK_R = crate::FieldReader;
        ///Field `CLKDIV_MASK` writer - Clock divide factor
        pub type CLKDIV_MASK_W<'a, REG> = crate::FieldWriter<'a, REG, 3>;
        ///Field `WRSRAM_EN` reader - module dma enable
        pub type WRSRAM_EN_R = crate::BitReader;
        ///Field `WRSRAM_EN` writer - module dma enable
        pub type WRSRAM_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `ALGRM_MOD` reader - Encryption and decryption algorithm mode selection
        pub type ALGRM_MOD_R = crate::BitReader;
        ///Field `ALGRM_MOD` writer - Encryption and decryption algorithm mode selection
        pub type ALGRM_MOD_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CIPHER_MOD` reader - Block cipher mode selection
        pub type CIPHER_MOD_R = crate::BitReader;
        ///Field `CIPHER_MOD` writer - Block cipher mode selection
        pub type CIPHER_MOD_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `KLEN_MASK` reader - Key length setting
        pub type KLEN_MASK_R = crate::FieldReader;
        ///Field `KLEN_MASK` writer - Key length setting
        pub type KLEN_MASK_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `DAT_MOD` reader - source data and result data is bit endian
        pub type DAT_MOD_R = crate::BitReader;
        ///Field `DAT_MOD` writer - source data and result data is bit endian
        pub type DAT_MOD_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - enable key expansion
            #[inline(always)]
            pub fn keyex_en(&self) -> KEYEX_EN_R {
                KEYEX_EN_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - when write data to dma
            #[inline(always)]
            pub fn rdperi_en(&self) -> RDPERI_EN_R {
                RDPERI_EN_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - when read data from dma
            #[inline(always)]
            pub fn wrperi_en(&self) -> WRPERI_EN_R {
                WRPERI_EN_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - ECDC mode select
            #[inline(always)]
            pub fn mode_sel(&self) -> MODE_SEL_R {
                MODE_SEL_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bits 4:6 - Clock divide factor
            #[inline(always)]
            pub fn clkdiv_mask(&self) -> CLKDIV_MASK_R {
                CLKDIV_MASK_R::new(((self.bits >> 4) & 7) as u8)
            }
            ///Bit 7 - module dma enable
            #[inline(always)]
            pub fn wrsram_en(&self) -> WRSRAM_EN_R {
                WRSRAM_EN_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bit 8 - Encryption and decryption algorithm mode selection
            #[inline(always)]
            pub fn algrm_mod(&self) -> ALGRM_MOD_R {
                ALGRM_MOD_R::new(((self.bits >> 8) & 1) != 0)
            }
            ///Bit 9 - Block cipher mode selection
            #[inline(always)]
            pub fn cipher_mod(&self) -> CIPHER_MOD_R {
                CIPHER_MOD_R::new(((self.bits >> 9) & 1) != 0)
            }
            ///Bits 10:11 - Key length setting
            #[inline(always)]
            pub fn klen_mask(&self) -> KLEN_MASK_R {
                KLEN_MASK_R::new(((self.bits >> 10) & 3) as u8)
            }
            ///Bit 13 - source data and result data is bit endian
            #[inline(always)]
            pub fn dat_mod(&self) -> DAT_MOD_R {
                DAT_MOD_R::new(((self.bits >> 13) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - enable key expansion
            #[inline(always)]
            #[must_use]
            pub fn keyex_en(&mut self) -> KEYEX_EN_W<ECEC_CTRL_SPEC> {
                KEYEX_EN_W::new(self, 0)
            }
            ///Bit 1 - when write data to dma
            #[inline(always)]
            #[must_use]
            pub fn rdperi_en(&mut self) -> RDPERI_EN_W<ECEC_CTRL_SPEC> {
                RDPERI_EN_W::new(self, 1)
            }
            ///Bit 2 - when read data from dma
            #[inline(always)]
            #[must_use]
            pub fn wrperi_en(&mut self) -> WRPERI_EN_W<ECEC_CTRL_SPEC> {
                WRPERI_EN_W::new(self, 2)
            }
            ///Bit 3 - ECDC mode select
            #[inline(always)]
            #[must_use]
            pub fn mode_sel(&mut self) -> MODE_SEL_W<ECEC_CTRL_SPEC> {
                MODE_SEL_W::new(self, 3)
            }
            ///Bits 4:6 - Clock divide factor
            #[inline(always)]
            #[must_use]
            pub fn clkdiv_mask(&mut self) -> CLKDIV_MASK_W<ECEC_CTRL_SPEC> {
                CLKDIV_MASK_W::new(self, 4)
            }
            ///Bit 7 - module dma enable
            #[inline(always)]
            #[must_use]
            pub fn wrsram_en(&mut self) -> WRSRAM_EN_W<ECEC_CTRL_SPEC> {
                WRSRAM_EN_W::new(self, 7)
            }
            ///Bit 8 - Encryption and decryption algorithm mode selection
            #[inline(always)]
            #[must_use]
            pub fn algrm_mod(&mut self) -> ALGRM_MOD_W<ECEC_CTRL_SPEC> {
                ALGRM_MOD_W::new(self, 8)
            }
            ///Bit 9 - Block cipher mode selection
            #[inline(always)]
            #[must_use]
            pub fn cipher_mod(&mut self) -> CIPHER_MOD_W<ECEC_CTRL_SPEC> {
                CIPHER_MOD_W::new(self, 9)
            }
            ///Bits 10:11 - Key length setting
            #[inline(always)]
            #[must_use]
            pub fn klen_mask(&mut self) -> KLEN_MASK_W<ECEC_CTRL_SPEC> {
                KLEN_MASK_W::new(self, 10)
            }
            ///Bit 13 - source data and result data is bit endian
            #[inline(always)]
            #[must_use]
            pub fn dat_mod(&mut self) -> DAT_MOD_W<ECEC_CTRL_SPEC> {
                DAT_MOD_W::new(self, 13)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///ECED AES/SM4 register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`ecec_ctrl::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ecec_ctrl::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct ECEC_CTRL_SPEC;
        impl crate::RegisterSpec for ECEC_CTRL_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`ecec_ctrl::R`](R) reader structure
        impl crate::Readable for ECEC_CTRL_SPEC {}
        ///`write(|w| ..)` method takes [`ecec_ctrl::W`](W) writer structure
        impl crate::Writable for ECEC_CTRL_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets ECEC_CTRL to value 0x20
        impl crate::Resettable for ECEC_CTRL_SPEC {
            const RESET_VALUE: u16 = 0x20;
        }
    }
    ///INT_EN (rw) register accessor: Interupt enable register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`int_en::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`int_en::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@int_en`]
    ///module
    pub type INT_EN = crate::Reg<int_en::INT_EN_SPEC>;
    ///Interupt enable register
    pub mod int_en {
        ///Register `INT_EN` reader
        pub type R = crate::R<INT_EN_SPEC>;
        ///Register `INT_EN` writer
        pub type W = crate::W<INT_EN_SPEC>;
        ///Field `IE_EKDONE` reader - Key extension completion interrupt enable
        pub type IE_EKDONE_R = crate::BitReader;
        ///Field `IE_EKDONE` writer - Key extension completion interrupt enable
        pub type IE_EKDONE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `IE_SINGLE` reader - Single encryption and decryption completion interrupt enable
        pub type IE_SINGLE_R = crate::BitReader;
        ///Field `IE_SINGLE` writer - Single encryption and decryption completion interrupt enable
        pub type IE_SINGLE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `IE_WRSRAM` reader - Memory to memory encryption and decryption completion interrupt enable
        pub type IE_WRSRAM_R = crate::BitReader;
        ///Field `IE_WRSRAM` writer - Memory to memory encryption and decryption completion interrupt enable
        pub type IE_WRSRAM_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - Key extension completion interrupt enable
            #[inline(always)]
            pub fn ie_ekdone(&self) -> IE_EKDONE_R {
                IE_EKDONE_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Single encryption and decryption completion interrupt enable
            #[inline(always)]
            pub fn ie_single(&self) -> IE_SINGLE_R {
                IE_SINGLE_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - Memory to memory encryption and decryption completion interrupt enable
            #[inline(always)]
            pub fn ie_wrsram(&self) -> IE_WRSRAM_R {
                IE_WRSRAM_R::new(((self.bits >> 2) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - Key extension completion interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn ie_ekdone(&mut self) -> IE_EKDONE_W<INT_EN_SPEC> {
                IE_EKDONE_W::new(self, 0)
            }
            ///Bit 1 - Single encryption and decryption completion interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn ie_single(&mut self) -> IE_SINGLE_W<INT_EN_SPEC> {
                IE_SINGLE_W::new(self, 1)
            }
            ///Bit 2 - Memory to memory encryption and decryption completion interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn ie_wrsram(&mut self) -> IE_WRSRAM_W<INT_EN_SPEC> {
                IE_WRSRAM_W::new(self, 2)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interupt enable register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`int_en::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`int_en::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct INT_EN_SPEC;
        impl crate::RegisterSpec for INT_EN_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`int_en::R`](R) reader structure
        impl crate::Readable for INT_EN_SPEC {}
        ///`write(|w| ..)` method takes [`int_en::W`](W) writer structure
        impl crate::Writable for INT_EN_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets INT_EN to value 0
        impl crate::Resettable for INT_EN_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///INT_FG (rw) register accessor: Interupt flag register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`int_fg::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`int_fg::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@int_fg`]
    ///module
    pub type INT_FG = crate::Reg<int_fg::INT_FG_SPEC>;
    ///Interupt flag register
    pub mod int_fg {
        ///Register `INT_FG` reader
        pub type R = crate::R<INT_FG_SPEC>;
        ///Register `INT_FG` writer
        pub type W = crate::W<INT_FG_SPEC>;
        ///Field `IF_EKDONE` reader - Key extension completion interrupt flag
        pub type IF_EKDONE_R = crate::BitReader;
        ///Field `IF_EKDONE` writer - Key extension completion interrupt flag
        pub type IF_EKDONE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `IF_SINGLE` reader - Single encryption and decryption completion interrupt flag
        pub type IF_SINGLE_R = crate::BitReader;
        ///Field `IF_SINGLE` writer - Single encryption and decryption completion interrupt flag
        pub type IF_SINGLE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `IF_WRSRAM` reader - Memory to memory encryption and decryption completion interrupt flag
        pub type IF_WRSRAM_R = crate::BitReader;
        ///Field `IF_WRSRAM` writer - Memory to memory encryption and decryption completion interrupt flag
        pub type IF_WRSRAM_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - Key extension completion interrupt flag
            #[inline(always)]
            pub fn if_ekdone(&self) -> IF_EKDONE_R {
                IF_EKDONE_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Single encryption and decryption completion interrupt flag
            #[inline(always)]
            pub fn if_single(&self) -> IF_SINGLE_R {
                IF_SINGLE_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - Memory to memory encryption and decryption completion interrupt flag
            #[inline(always)]
            pub fn if_wrsram(&self) -> IF_WRSRAM_R {
                IF_WRSRAM_R::new(((self.bits >> 2) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - Key extension completion interrupt flag
            #[inline(always)]
            #[must_use]
            pub fn if_ekdone(&mut self) -> IF_EKDONE_W<INT_FG_SPEC> {
                IF_EKDONE_W::new(self, 0)
            }
            ///Bit 1 - Single encryption and decryption completion interrupt flag
            #[inline(always)]
            #[must_use]
            pub fn if_single(&mut self) -> IF_SINGLE_W<INT_FG_SPEC> {
                IF_SINGLE_W::new(self, 1)
            }
            ///Bit 2 - Memory to memory encryption and decryption completion interrupt flag
            #[inline(always)]
            #[must_use]
            pub fn if_wrsram(&mut self) -> IF_WRSRAM_W<INT_FG_SPEC> {
                IF_WRSRAM_W::new(self, 2)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interupt flag register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`int_fg::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`int_fg::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct INT_FG_SPEC;
        impl crate::RegisterSpec for INT_FG_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`int_fg::R`](R) reader structure
        impl crate::Readable for INT_FG_SPEC {}
        ///`write(|w| ..)` method takes [`int_fg::W`](W) writer structure
        impl crate::Writable for INT_FG_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets INT_FG to value 0
        impl crate::Resettable for INT_FG_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///KEY_255T224 (rw) register accessor: User key 224-255 register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`key_255t224::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`key_255t224::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@key_255t224`]
    ///module
    pub type KEY_255T224 = crate::Reg<key_255t224::KEY_255T224_SPEC>;
    ///User key 224-255 register
    pub mod key_255t224 {
        ///Register `KEY_255T224` reader
        pub type R = crate::R<KEY_255T224_SPEC>;
        ///Register `KEY_255T224` writer
        pub type W = crate::W<KEY_255T224_SPEC>;
        ///Field `KEY_255T224` reader - User key 224-255 register
        pub type KEY_255T224_R = crate::FieldReader<u32>;
        ///Field `KEY_255T224` writer - User key 224-255 register
        pub type KEY_255T224_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - User key 224-255 register
            #[inline(always)]
            pub fn key_255t224(&self) -> KEY_255T224_R {
                KEY_255T224_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - User key 224-255 register
            #[inline(always)]
            #[must_use]
            pub fn key_255t224(&mut self) -> KEY_255T224_W<KEY_255T224_SPEC> {
                KEY_255T224_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///User key 224-255 register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`key_255t224::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`key_255t224::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct KEY_255T224_SPEC;
        impl crate::RegisterSpec for KEY_255T224_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`key_255t224::R`](R) reader structure
        impl crate::Readable for KEY_255T224_SPEC {}
        ///`write(|w| ..)` method takes [`key_255t224::W`](W) writer structure
        impl crate::Writable for KEY_255T224_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets KEY_255T224 to value 0
        impl crate::Resettable for KEY_255T224_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///KEY_223T192 (rw) register accessor: User key 192-223 register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`key_223t192::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`key_223t192::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@key_223t192`]
    ///module
    pub type KEY_223T192 = crate::Reg<key_223t192::KEY_223T192_SPEC>;
    ///User key 192-223 register
    pub mod key_223t192 {
        ///Register `KEY_223T192` reader
        pub type R = crate::R<KEY_223T192_SPEC>;
        ///Register `KEY_223T192` writer
        pub type W = crate::W<KEY_223T192_SPEC>;
        ///Field `KEY_223T192` reader - User key 192-223 register
        pub type KEY_223T192_R = crate::FieldReader<u32>;
        ///Field `KEY_223T192` writer - User key 192-223 register
        pub type KEY_223T192_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - User key 192-223 register
            #[inline(always)]
            pub fn key_223t192(&self) -> KEY_223T192_R {
                KEY_223T192_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - User key 192-223 register
            #[inline(always)]
            #[must_use]
            pub fn key_223t192(&mut self) -> KEY_223T192_W<KEY_223T192_SPEC> {
                KEY_223T192_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///User key 192-223 register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`key_223t192::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`key_223t192::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct KEY_223T192_SPEC;
        impl crate::RegisterSpec for KEY_223T192_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`key_223t192::R`](R) reader structure
        impl crate::Readable for KEY_223T192_SPEC {}
        ///`write(|w| ..)` method takes [`key_223t192::W`](W) writer structure
        impl crate::Writable for KEY_223T192_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets KEY_223T192 to value 0
        impl crate::Resettable for KEY_223T192_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///KEY_191T160 (rw) register accessor: User key 160-191 register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`key_191t160::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`key_191t160::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@key_191t160`]
    ///module
    pub type KEY_191T160 = crate::Reg<key_191t160::KEY_191T160_SPEC>;
    ///User key 160-191 register
    pub mod key_191t160 {
        ///Register `KEY_191T160` reader
        pub type R = crate::R<KEY_191T160_SPEC>;
        ///Register `KEY_191T160` writer
        pub type W = crate::W<KEY_191T160_SPEC>;
        ///Field `KEY_191T160` reader - User key 160-191 register
        pub type KEY_191T160_R = crate::FieldReader<u32>;
        ///Field `KEY_191T160` writer - User key 160-191 register
        pub type KEY_191T160_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - User key 160-191 register
            #[inline(always)]
            pub fn key_191t160(&self) -> KEY_191T160_R {
                KEY_191T160_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - User key 160-191 register
            #[inline(always)]
            #[must_use]
            pub fn key_191t160(&mut self) -> KEY_191T160_W<KEY_191T160_SPEC> {
                KEY_191T160_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///User key 160-191 register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`key_191t160::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`key_191t160::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct KEY_191T160_SPEC;
        impl crate::RegisterSpec for KEY_191T160_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`key_191t160::R`](R) reader structure
        impl crate::Readable for KEY_191T160_SPEC {}
        ///`write(|w| ..)` method takes [`key_191t160::W`](W) writer structure
        impl crate::Writable for KEY_191T160_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets KEY_191T160 to value 0
        impl crate::Resettable for KEY_191T160_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///KEY_159T128 (rw) register accessor: User key 128-159 register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`key_159t128::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`key_159t128::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@key_159t128`]
    ///module
    pub type KEY_159T128 = crate::Reg<key_159t128::KEY_159T128_SPEC>;
    ///User key 128-159 register
    pub mod key_159t128 {
        ///Register `KEY_159T128` reader
        pub type R = crate::R<KEY_159T128_SPEC>;
        ///Register `KEY_159T128` writer
        pub type W = crate::W<KEY_159T128_SPEC>;
        ///Field `KEY_159T128` reader - User key 128-159 register
        pub type KEY_159T128_R = crate::FieldReader<u32>;
        ///Field `KEY_159T128` writer - User key 128-159 register
        pub type KEY_159T128_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - User key 128-159 register
            #[inline(always)]
            pub fn key_159t128(&self) -> KEY_159T128_R {
                KEY_159T128_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - User key 128-159 register
            #[inline(always)]
            #[must_use]
            pub fn key_159t128(&mut self) -> KEY_159T128_W<KEY_159T128_SPEC> {
                KEY_159T128_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///User key 128-159 register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`key_159t128::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`key_159t128::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct KEY_159T128_SPEC;
        impl crate::RegisterSpec for KEY_159T128_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`key_159t128::R`](R) reader structure
        impl crate::Readable for KEY_159T128_SPEC {}
        ///`write(|w| ..)` method takes [`key_159t128::W`](W) writer structure
        impl crate::Writable for KEY_159T128_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets KEY_159T128 to value 0
        impl crate::Resettable for KEY_159T128_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///KEY_127T96 (rw) register accessor: User key 96-127 register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`key_127t96::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`key_127t96::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@key_127t96`]
    ///module
    pub type KEY_127T96 = crate::Reg<key_127t96::KEY_127T96_SPEC>;
    ///User key 96-127 register
    pub mod key_127t96 {
        ///Register `KEY_127T96` reader
        pub type R = crate::R<KEY_127T96_SPEC>;
        ///Register `KEY_127T96` writer
        pub type W = crate::W<KEY_127T96_SPEC>;
        ///Field `KEY_127T96` reader - User key 96-127 register
        pub type KEY_127T96_R = crate::FieldReader<u32>;
        ///Field `KEY_127T96` writer - User key 96-127 register
        pub type KEY_127T96_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - User key 96-127 register
            #[inline(always)]
            pub fn key_127t96(&self) -> KEY_127T96_R {
                KEY_127T96_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - User key 96-127 register
            #[inline(always)]
            #[must_use]
            pub fn key_127t96(&mut self) -> KEY_127T96_W<KEY_127T96_SPEC> {
                KEY_127T96_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///User key 96-127 register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`key_127t96::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`key_127t96::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct KEY_127T96_SPEC;
        impl crate::RegisterSpec for KEY_127T96_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`key_127t96::R`](R) reader structure
        impl crate::Readable for KEY_127T96_SPEC {}
        ///`write(|w| ..)` method takes [`key_127t96::W`](W) writer structure
        impl crate::Writable for KEY_127T96_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets KEY_127T96 to value 0
        impl crate::Resettable for KEY_127T96_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///KEY_95T64 (rw) register accessor: User key 64-95 register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`key_95t64::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`key_95t64::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@key_95t64`]
    ///module
    pub type KEY_95T64 = crate::Reg<key_95t64::KEY_95T64_SPEC>;
    ///User key 64-95 register
    pub mod key_95t64 {
        ///Register `KEY_95T64` reader
        pub type R = crate::R<KEY_95T64_SPEC>;
        ///Register `KEY_95T64` writer
        pub type W = crate::W<KEY_95T64_SPEC>;
        ///Field `KEY_95T64` reader - User key 64-95 register
        pub type KEY_95T64_R = crate::FieldReader<u32>;
        ///Field `KEY_95T64` writer - User key 64-95 register
        pub type KEY_95T64_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - User key 64-95 register
            #[inline(always)]
            pub fn key_95t64(&self) -> KEY_95T64_R {
                KEY_95T64_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - User key 64-95 register
            #[inline(always)]
            #[must_use]
            pub fn key_95t64(&mut self) -> KEY_95T64_W<KEY_95T64_SPEC> {
                KEY_95T64_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///User key 64-95 register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`key_95t64::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`key_95t64::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct KEY_95T64_SPEC;
        impl crate::RegisterSpec for KEY_95T64_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`key_95t64::R`](R) reader structure
        impl crate::Readable for KEY_95T64_SPEC {}
        ///`write(|w| ..)` method takes [`key_95t64::W`](W) writer structure
        impl crate::Writable for KEY_95T64_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets KEY_95T64 to value 0
        impl crate::Resettable for KEY_95T64_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///KEY_63T32 (rw) register accessor: User key 32-63 register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`key_63t32::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`key_63t32::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@key_63t32`]
    ///module
    pub type KEY_63T32 = crate::Reg<key_63t32::KEY_63T32_SPEC>;
    ///User key 32-63 register
    pub mod key_63t32 {
        ///Register `KEY_63T32` reader
        pub type R = crate::R<KEY_63T32_SPEC>;
        ///Register `KEY_63T32` writer
        pub type W = crate::W<KEY_63T32_SPEC>;
        ///Field `KEY_63T32` reader - User key 32-63 register
        pub type KEY_63T32_R = crate::FieldReader<u32>;
        ///Field `KEY_63T32` writer - User key 32-63 register
        pub type KEY_63T32_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - User key 32-63 register
            #[inline(always)]
            pub fn key_63t32(&self) -> KEY_63T32_R {
                KEY_63T32_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - User key 32-63 register
            #[inline(always)]
            #[must_use]
            pub fn key_63t32(&mut self) -> KEY_63T32_W<KEY_63T32_SPEC> {
                KEY_63T32_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///User key 32-63 register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`key_63t32::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`key_63t32::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct KEY_63T32_SPEC;
        impl crate::RegisterSpec for KEY_63T32_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`key_63t32::R`](R) reader structure
        impl crate::Readable for KEY_63T32_SPEC {}
        ///`write(|w| ..)` method takes [`key_63t32::W`](W) writer structure
        impl crate::Writable for KEY_63T32_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets KEY_63T32 to value 0
        impl crate::Resettable for KEY_63T32_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///KEY_31T0 (rw) register accessor: User key 0-31 register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`key_31t0::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`key_31t0::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@key_31t0`]
    ///module
    pub type KEY_31T0 = crate::Reg<key_31t0::KEY_31T0_SPEC>;
    ///User key 0-31 register
    pub mod key_31t0 {
        ///Register `KEY_31T0` reader
        pub type R = crate::R<KEY_31T0_SPEC>;
        ///Register `KEY_31T0` writer
        pub type W = crate::W<KEY_31T0_SPEC>;
        ///Field `KEY_31T0` reader - User key 0-31 register
        pub type KEY_31T0_R = crate::FieldReader<u32>;
        ///Field `KEY_31T0` writer - User key 0-31 register
        pub type KEY_31T0_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - User key 0-31 register
            #[inline(always)]
            pub fn key_31t0(&self) -> KEY_31T0_R {
                KEY_31T0_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - User key 0-31 register
            #[inline(always)]
            #[must_use]
            pub fn key_31t0(&mut self) -> KEY_31T0_W<KEY_31T0_SPEC> {
                KEY_31T0_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///User key 0-31 register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`key_31t0::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`key_31t0::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct KEY_31T0_SPEC;
        impl crate::RegisterSpec for KEY_31T0_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`key_31t0::R`](R) reader structure
        impl crate::Readable for KEY_31T0_SPEC {}
        ///`write(|w| ..)` method takes [`key_31t0::W`](W) writer structure
        impl crate::Writable for KEY_31T0_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets KEY_31T0 to value 0
        impl crate::Resettable for KEY_31T0_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IV_127T96 (rw) register accessor: CTR mode count 96-127 register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iv_127t96::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iv_127t96::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iv_127t96`]
    ///module
    pub type IV_127T96 = crate::Reg<iv_127t96::IV_127T96_SPEC>;
    ///CTR mode count 96-127 register
    pub mod iv_127t96 {
        ///Register `IV_127T96` reader
        pub type R = crate::R<IV_127T96_SPEC>;
        ///Register `IV_127T96` writer
        pub type W = crate::W<IV_127T96_SPEC>;
        ///Field `IV_127T96` reader - CTR mode count 96-127 register
        pub type IV_127T96_R = crate::FieldReader<u32>;
        ///Field `IV_127T96` writer - CTR mode count 96-127 register
        pub type IV_127T96_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - CTR mode count 96-127 register
            #[inline(always)]
            pub fn iv_127t96(&self) -> IV_127T96_R {
                IV_127T96_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - CTR mode count 96-127 register
            #[inline(always)]
            #[must_use]
            pub fn iv_127t96(&mut self) -> IV_127T96_W<IV_127T96_SPEC> {
                IV_127T96_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///CTR mode count 96-127 register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iv_127t96::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iv_127t96::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IV_127T96_SPEC;
        impl crate::RegisterSpec for IV_127T96_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iv_127t96::R`](R) reader structure
        impl crate::Readable for IV_127T96_SPEC {}
        ///`write(|w| ..)` method takes [`iv_127t96::W`](W) writer structure
        impl crate::Writable for IV_127T96_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IV_127T96 to value 0
        impl crate::Resettable for IV_127T96_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IV_95T64 (rw) register accessor: CTR mode count 64-95 register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iv_95t64::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iv_95t64::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iv_95t64`]
    ///module
    pub type IV_95T64 = crate::Reg<iv_95t64::IV_95T64_SPEC>;
    ///CTR mode count 64-95 register
    pub mod iv_95t64 {
        ///Register `IV_95T64` reader
        pub type R = crate::R<IV_95T64_SPEC>;
        ///Register `IV_95T64` writer
        pub type W = crate::W<IV_95T64_SPEC>;
        ///Field `IV_95T64` reader - CTR mode count 64-95 register
        pub type IV_95T64_R = crate::FieldReader<u32>;
        ///Field `IV_95T64` writer - CTR mode count 64-95 register
        pub type IV_95T64_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - CTR mode count 64-95 register
            #[inline(always)]
            pub fn iv_95t64(&self) -> IV_95T64_R {
                IV_95T64_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - CTR mode count 64-95 register
            #[inline(always)]
            #[must_use]
            pub fn iv_95t64(&mut self) -> IV_95T64_W<IV_95T64_SPEC> {
                IV_95T64_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///CTR mode count 64-95 register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iv_95t64::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iv_95t64::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IV_95T64_SPEC;
        impl crate::RegisterSpec for IV_95T64_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iv_95t64::R`](R) reader structure
        impl crate::Readable for IV_95T64_SPEC {}
        ///`write(|w| ..)` method takes [`iv_95t64::W`](W) writer structure
        impl crate::Writable for IV_95T64_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IV_95T64 to value 0
        impl crate::Resettable for IV_95T64_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IV_63T32 (rw) register accessor: CTR mode count 32-63 register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iv_63t32::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iv_63t32::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iv_63t32`]
    ///module
    pub type IV_63T32 = crate::Reg<iv_63t32::IV_63T32_SPEC>;
    ///CTR mode count 32-63 register
    pub mod iv_63t32 {
        ///Register `IV_63T32` reader
        pub type R = crate::R<IV_63T32_SPEC>;
        ///Register `IV_63T32` writer
        pub type W = crate::W<IV_63T32_SPEC>;
        ///Field `IV_63T32` reader - CTR mode count 32-63 register
        pub type IV_63T32_R = crate::FieldReader<u32>;
        ///Field `IV_63T32` writer - CTR mode count 32-63 register
        pub type IV_63T32_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - CTR mode count 32-63 register
            #[inline(always)]
            pub fn iv_63t32(&self) -> IV_63T32_R {
                IV_63T32_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - CTR mode count 32-63 register
            #[inline(always)]
            #[must_use]
            pub fn iv_63t32(&mut self) -> IV_63T32_W<IV_63T32_SPEC> {
                IV_63T32_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///CTR mode count 32-63 register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iv_63t32::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iv_63t32::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IV_63T32_SPEC;
        impl crate::RegisterSpec for IV_63T32_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iv_63t32::R`](R) reader structure
        impl crate::Readable for IV_63T32_SPEC {}
        ///`write(|w| ..)` method takes [`iv_63t32::W`](W) writer structure
        impl crate::Writable for IV_63T32_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IV_63T32 to value 0
        impl crate::Resettable for IV_63T32_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IV_31T0 (rw) register accessor: CTR mode count 0-31 register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iv_31t0::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iv_31t0::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iv_31t0`]
    ///module
    pub type IV_31T0 = crate::Reg<iv_31t0::IV_31T0_SPEC>;
    ///CTR mode count 0-31 register
    pub mod iv_31t0 {
        ///Register `IV_31T0` reader
        pub type R = crate::R<IV_31T0_SPEC>;
        ///Register `IV_31T0` writer
        pub type W = crate::W<IV_31T0_SPEC>;
        ///Field `IV_31T0` reader - CTR mode count 0-31 register
        pub type IV_31T0_R = crate::FieldReader<u32>;
        ///Field `IV_31T0` writer - CTR mode count 0-31 register
        pub type IV_31T0_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - CTR mode count 0-31 register
            #[inline(always)]
            pub fn iv_31t0(&self) -> IV_31T0_R {
                IV_31T0_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - CTR mode count 0-31 register
            #[inline(always)]
            #[must_use]
            pub fn iv_31t0(&mut self) -> IV_31T0_W<IV_31T0_SPEC> {
                IV_31T0_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///CTR mode count 0-31 register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iv_31t0::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iv_31t0::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IV_31T0_SPEC;
        impl crate::RegisterSpec for IV_31T0_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iv_31t0::R`](R) reader structure
        impl crate::Readable for IV_31T0_SPEC {}
        ///`write(|w| ..)` method takes [`iv_31t0::W`](W) writer structure
        impl crate::Writable for IV_31T0_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IV_31T0 to value 0
        impl crate::Resettable for IV_31T0_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///SGSD_127T96 (rw) register accessor: Single encryption and decryption of original data 96-127 register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`sgsd_127t96::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`sgsd_127t96::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@sgsd_127t96`]
    ///module
    pub type SGSD_127T96 = crate::Reg<sgsd_127t96::SGSD_127T96_SPEC>;
    ///Single encryption and decryption of original data 96-127 register
    pub mod sgsd_127t96 {
        ///Register `SGSD_127T96` reader
        pub type R = crate::R<SGSD_127T96_SPEC>;
        ///Register `SGSD_127T96` writer
        pub type W = crate::W<SGSD_127T96_SPEC>;
        ///Field `SGSD_127T96` reader - Single encryption and decryption of original data 96-127 register
        pub type SGSD_127T96_R = crate::FieldReader<u32>;
        ///Field `SGSD_127T96` writer - Single encryption and decryption of original data 96-127 register
        pub type SGSD_127T96_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - Single encryption and decryption of original data 96-127 register
            #[inline(always)]
            pub fn sgsd_127t96(&self) -> SGSD_127T96_R {
                SGSD_127T96_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - Single encryption and decryption of original data 96-127 register
            #[inline(always)]
            #[must_use]
            pub fn sgsd_127t96(&mut self) -> SGSD_127T96_W<SGSD_127T96_SPEC> {
                SGSD_127T96_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Single encryption and decryption of original data 96-127 register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`sgsd_127t96::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`sgsd_127t96::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct SGSD_127T96_SPEC;
        impl crate::RegisterSpec for SGSD_127T96_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`sgsd_127t96::R`](R) reader structure
        impl crate::Readable for SGSD_127T96_SPEC {}
        ///`write(|w| ..)` method takes [`sgsd_127t96::W`](W) writer structure
        impl crate::Writable for SGSD_127T96_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets SGSD_127T96 to value 0
        impl crate::Resettable for SGSD_127T96_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///SGSD_95T64 (rw) register accessor: Single encryption and decryption of original data 64-95 register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`sgsd_95t64::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`sgsd_95t64::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@sgsd_95t64`]
    ///module
    pub type SGSD_95T64 = crate::Reg<sgsd_95t64::SGSD_95T64_SPEC>;
    ///Single encryption and decryption of original data 64-95 register
    pub mod sgsd_95t64 {
        ///Register `SGSD_95T64` reader
        pub type R = crate::R<SGSD_95T64_SPEC>;
        ///Register `SGSD_95T64` writer
        pub type W = crate::W<SGSD_95T64_SPEC>;
        ///Field `SGSD_95T64` reader - Single encryption and decryption of original data 64-95 register
        pub type SGSD_95T64_R = crate::FieldReader<u32>;
        ///Field `SGSD_95T64` writer - Single encryption and decryption of original data 64-95 register
        pub type SGSD_95T64_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - Single encryption and decryption of original data 64-95 register
            #[inline(always)]
            pub fn sgsd_95t64(&self) -> SGSD_95T64_R {
                SGSD_95T64_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - Single encryption and decryption of original data 64-95 register
            #[inline(always)]
            #[must_use]
            pub fn sgsd_95t64(&mut self) -> SGSD_95T64_W<SGSD_95T64_SPEC> {
                SGSD_95T64_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Single encryption and decryption of original data 64-95 register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`sgsd_95t64::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`sgsd_95t64::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct SGSD_95T64_SPEC;
        impl crate::RegisterSpec for SGSD_95T64_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`sgsd_95t64::R`](R) reader structure
        impl crate::Readable for SGSD_95T64_SPEC {}
        ///`write(|w| ..)` method takes [`sgsd_95t64::W`](W) writer structure
        impl crate::Writable for SGSD_95T64_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets SGSD_95T64 to value 0
        impl crate::Resettable for SGSD_95T64_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///SGSD_63T32 (rw) register accessor: Single encryption and decryption of original data 32-63 register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`sgsd_63t32::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`sgsd_63t32::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@sgsd_63t32`]
    ///module
    pub type SGSD_63T32 = crate::Reg<sgsd_63t32::SGSD_63T32_SPEC>;
    ///Single encryption and decryption of original data 32-63 register
    pub mod sgsd_63t32 {
        ///Register `SGSD_63T32` reader
        pub type R = crate::R<SGSD_63T32_SPEC>;
        ///Register `SGSD_63T32` writer
        pub type W = crate::W<SGSD_63T32_SPEC>;
        ///Field `SGSD_63T32` reader - Single encryption and decryption of original data 32-63 register
        pub type SGSD_63T32_R = crate::FieldReader<u32>;
        ///Field `SGSD_63T32` writer - Single encryption and decryption of original data 32-63 register
        pub type SGSD_63T32_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - Single encryption and decryption of original data 32-63 register
            #[inline(always)]
            pub fn sgsd_63t32(&self) -> SGSD_63T32_R {
                SGSD_63T32_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - Single encryption and decryption of original data 32-63 register
            #[inline(always)]
            #[must_use]
            pub fn sgsd_63t32(&mut self) -> SGSD_63T32_W<SGSD_63T32_SPEC> {
                SGSD_63T32_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Single encryption and decryption of original data 32-63 register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`sgsd_63t32::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`sgsd_63t32::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct SGSD_63T32_SPEC;
        impl crate::RegisterSpec for SGSD_63T32_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`sgsd_63t32::R`](R) reader structure
        impl crate::Readable for SGSD_63T32_SPEC {}
        ///`write(|w| ..)` method takes [`sgsd_63t32::W`](W) writer structure
        impl crate::Writable for SGSD_63T32_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets SGSD_63T32 to value 0
        impl crate::Resettable for SGSD_63T32_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///SGSD_31T0 (rw) register accessor: Single encryption and decryption of original data 0-31 register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`sgsd_31t0::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`sgsd_31t0::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@sgsd_31t0`]
    ///module
    pub type SGSD_31T0 = crate::Reg<sgsd_31t0::SGSD_31T0_SPEC>;
    ///Single encryption and decryption of original data 0-31 register
    pub mod sgsd_31t0 {
        ///Register `SGSD_31T0` reader
        pub type R = crate::R<SGSD_31T0_SPEC>;
        ///Register `SGSD_31T0` writer
        pub type W = crate::W<SGSD_31T0_SPEC>;
        ///Field `SGSD_31T0` reader - Single encryption and decryption of original data 0-31 register
        pub type SGSD_31T0_R = crate::FieldReader<u32>;
        ///Field `SGSD_31T0` writer - Single encryption and decryption of original data 0-31 register
        pub type SGSD_31T0_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - Single encryption and decryption of original data 0-31 register
            #[inline(always)]
            pub fn sgsd_31t0(&self) -> SGSD_31T0_R {
                SGSD_31T0_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - Single encryption and decryption of original data 0-31 register
            #[inline(always)]
            #[must_use]
            pub fn sgsd_31t0(&mut self) -> SGSD_31T0_W<SGSD_31T0_SPEC> {
                SGSD_31T0_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Single encryption and decryption of original data 0-31 register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`sgsd_31t0::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`sgsd_31t0::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct SGSD_31T0_SPEC;
        impl crate::RegisterSpec for SGSD_31T0_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`sgsd_31t0::R`](R) reader structure
        impl crate::Readable for SGSD_31T0_SPEC {}
        ///`write(|w| ..)` method takes [`sgsd_31t0::W`](W) writer structure
        impl crate::Writable for SGSD_31T0_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets SGSD_31T0 to value 0
        impl crate::Resettable for SGSD_31T0_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///SGRT_127T96 (rw) register accessor: Single encryption and decryption result 96-127 register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`sgrt_127t96::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`sgrt_127t96::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@sgrt_127t96`]
    ///module
    pub type SGRT_127T96 = crate::Reg<sgrt_127t96::SGRT_127T96_SPEC>;
    ///Single encryption and decryption result 96-127 register
    pub mod sgrt_127t96 {
        ///Register `SGRT_127T96` reader
        pub type R = crate::R<SGRT_127T96_SPEC>;
        ///Register `SGRT_127T96` writer
        pub type W = crate::W<SGRT_127T96_SPEC>;
        ///Field `SGRT_127T96` reader - Single encryption and decryption result 96-127 register
        pub type SGRT_127T96_R = crate::FieldReader<u32>;
        ///Field `SGRT_127T96` writer - Single encryption and decryption result 96-127 register
        pub type SGRT_127T96_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - Single encryption and decryption result 96-127 register
            #[inline(always)]
            pub fn sgrt_127t96(&self) -> SGRT_127T96_R {
                SGRT_127T96_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - Single encryption and decryption result 96-127 register
            #[inline(always)]
            #[must_use]
            pub fn sgrt_127t96(&mut self) -> SGRT_127T96_W<SGRT_127T96_SPEC> {
                SGRT_127T96_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Single encryption and decryption result 96-127 register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`sgrt_127t96::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`sgrt_127t96::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct SGRT_127T96_SPEC;
        impl crate::RegisterSpec for SGRT_127T96_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`sgrt_127t96::R`](R) reader structure
        impl crate::Readable for SGRT_127T96_SPEC {}
        ///`write(|w| ..)` method takes [`sgrt_127t96::W`](W) writer structure
        impl crate::Writable for SGRT_127T96_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets SGRT_127T96 to value 0
        impl crate::Resettable for SGRT_127T96_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///SGRT_95T64 (rw) register accessor: Single encryption and decryption result 64-95 register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`sgrt_95t64::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`sgrt_95t64::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@sgrt_95t64`]
    ///module
    pub type SGRT_95T64 = crate::Reg<sgrt_95t64::SGRT_95T64_SPEC>;
    ///Single encryption and decryption result 64-95 register
    pub mod sgrt_95t64 {
        ///Register `SGRT_95T64` reader
        pub type R = crate::R<SGRT_95T64_SPEC>;
        ///Register `SGRT_95T64` writer
        pub type W = crate::W<SGRT_95T64_SPEC>;
        ///Field `SGRT_95T64` reader - Single encryption and decryption result 64-95 register
        pub type SGRT_95T64_R = crate::FieldReader<u32>;
        ///Field `SGRT_95T64` writer - Single encryption and decryption result 64-95 register
        pub type SGRT_95T64_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - Single encryption and decryption result 64-95 register
            #[inline(always)]
            pub fn sgrt_95t64(&self) -> SGRT_95T64_R {
                SGRT_95T64_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - Single encryption and decryption result 64-95 register
            #[inline(always)]
            #[must_use]
            pub fn sgrt_95t64(&mut self) -> SGRT_95T64_W<SGRT_95T64_SPEC> {
                SGRT_95T64_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Single encryption and decryption result 64-95 register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`sgrt_95t64::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`sgrt_95t64::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct SGRT_95T64_SPEC;
        impl crate::RegisterSpec for SGRT_95T64_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`sgrt_95t64::R`](R) reader structure
        impl crate::Readable for SGRT_95T64_SPEC {}
        ///`write(|w| ..)` method takes [`sgrt_95t64::W`](W) writer structure
        impl crate::Writable for SGRT_95T64_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets SGRT_95T64 to value 0
        impl crate::Resettable for SGRT_95T64_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///SGRT_63T32 (rw) register accessor: Single encryption and decryption result 0-31 register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`sgrt_63t32::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`sgrt_63t32::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@sgrt_63t32`]
    ///module
    pub type SGRT_63T32 = crate::Reg<sgrt_63t32::SGRT_63T32_SPEC>;
    ///Single encryption and decryption result 0-31 register
    pub mod sgrt_63t32 {
        ///Register `SGRT_63T32` reader
        pub type R = crate::R<SGRT_63T32_SPEC>;
        ///Register `SGRT_63T32` writer
        pub type W = crate::W<SGRT_63T32_SPEC>;
        ///Field `SGRT_63T32` reader - Single encryption and decryption result 0-31 register
        pub type SGRT_63T32_R = crate::FieldReader<u32>;
        ///Field `SGRT_63T32` writer - Single encryption and decryption result 0-31 register
        pub type SGRT_63T32_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - Single encryption and decryption result 0-31 register
            #[inline(always)]
            pub fn sgrt_63t32(&self) -> SGRT_63T32_R {
                SGRT_63T32_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - Single encryption and decryption result 0-31 register
            #[inline(always)]
            #[must_use]
            pub fn sgrt_63t32(&mut self) -> SGRT_63T32_W<SGRT_63T32_SPEC> {
                SGRT_63T32_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Single encryption and decryption result 0-31 register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`sgrt_63t32::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`sgrt_63t32::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct SGRT_63T32_SPEC;
        impl crate::RegisterSpec for SGRT_63T32_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`sgrt_63t32::R`](R) reader structure
        impl crate::Readable for SGRT_63T32_SPEC {}
        ///`write(|w| ..)` method takes [`sgrt_63t32::W`](W) writer structure
        impl crate::Writable for SGRT_63T32_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets SGRT_63T32 to value 0
        impl crate::Resettable for SGRT_63T32_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///SGRT_31T0 (rw) register accessor: Single encryption and decryption result 0-31 register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`sgrt_31t0::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`sgrt_31t0::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@sgrt_31t0`]
    ///module
    pub type SGRT_31T0 = crate::Reg<sgrt_31t0::SGRT_31T0_SPEC>;
    ///Single encryption and decryption result 0-31 register
    pub mod sgrt_31t0 {
        ///Register `SGRT_31T0` reader
        pub type R = crate::R<SGRT_31T0_SPEC>;
        ///Register `SGRT_31T0` writer
        pub type W = crate::W<SGRT_31T0_SPEC>;
        ///Field `SGRT_31T0` reader - Single encryption and decryption result 0-31 register
        pub type SGRT_31T0_R = crate::FieldReader<u32>;
        ///Field `SGRT_31T0` writer - Single encryption and decryption result 0-31 register
        pub type SGRT_31T0_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - Single encryption and decryption result 0-31 register
            #[inline(always)]
            pub fn sgrt_31t0(&self) -> SGRT_31T0_R {
                SGRT_31T0_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - Single encryption and decryption result 0-31 register
            #[inline(always)]
            #[must_use]
            pub fn sgrt_31t0(&mut self) -> SGRT_31T0_W<SGRT_31T0_SPEC> {
                SGRT_31T0_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Single encryption and decryption result 0-31 register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`sgrt_31t0::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`sgrt_31t0::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct SGRT_31T0_SPEC;
        impl crate::RegisterSpec for SGRT_31T0_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`sgrt_31t0::R`](R) reader structure
        impl crate::Readable for SGRT_31T0_SPEC {}
        ///`write(|w| ..)` method takes [`sgrt_31t0::W`](W) writer structure
        impl crate::Writable for SGRT_31T0_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets SGRT_31T0 to value 0
        impl crate::Resettable for SGRT_31T0_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///SRAM_ADDR (rw) register accessor: encryption and decryption sram start address register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`sram_addr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`sram_addr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@sram_addr`]
    ///module
    pub type SRAM_ADDR = crate::Reg<sram_addr::SRAM_ADDR_SPEC>;
    ///encryption and decryption sram start address register
    pub mod sram_addr {
        ///Register `SRAM_ADDR` reader
        pub type R = crate::R<SRAM_ADDR_SPEC>;
        ///Register `SRAM_ADDR` writer
        pub type W = crate::W<SRAM_ADDR_SPEC>;
        ///Field `SRAM_ADDR` reader - encryption and decryption sram start address register
        pub type SRAM_ADDR_R = crate::FieldReader<u32>;
        ///Field `SRAM_ADDR` writer - encryption and decryption sram start address register
        pub type SRAM_ADDR_W<'a, REG> = crate::FieldWriter<'a, REG, 17, u32>;
        impl R {
            ///Bits 0:16 - encryption and decryption sram start address register
            #[inline(always)]
            pub fn sram_addr(&self) -> SRAM_ADDR_R {
                SRAM_ADDR_R::new(self.bits & 0x0001_ffff)
            }
        }
        impl W {
            ///Bits 0:16 - encryption and decryption sram start address register
            #[inline(always)]
            #[must_use]
            pub fn sram_addr(&mut self) -> SRAM_ADDR_W<SRAM_ADDR_SPEC> {
                SRAM_ADDR_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///encryption and decryption sram start address register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`sram_addr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`sram_addr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct SRAM_ADDR_SPEC;
        impl crate::RegisterSpec for SRAM_ADDR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`sram_addr::R`](R) reader structure
        impl crate::Readable for SRAM_ADDR_SPEC {}
        ///`write(|w| ..)` method takes [`sram_addr::W`](W) writer structure
        impl crate::Writable for SRAM_ADDR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets SRAM_ADDR to value 0
        impl crate::Resettable for SRAM_ADDR_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///SRAM_LEN (rw) register accessor: encryption and decryption sram size register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`sram_len::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`sram_len::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@sram_len`]
    ///module
    pub type SRAM_LEN = crate::Reg<sram_len::SRAM_LEN_SPEC>;
    ///encryption and decryption sram size register
    pub mod sram_len {
        ///Register `SRAM_LEN` reader
        pub type R = crate::R<SRAM_LEN_SPEC>;
        ///Register `SRAM_LEN` writer
        pub type W = crate::W<SRAM_LEN_SPEC>;
        ///Field `SRAM_LEN` reader - encryption and decryption sram size register
        pub type SRAM_LEN_R = crate::FieldReader<u32>;
        ///Field `SRAM_LEN` writer - encryption and decryption sram size register
        pub type SRAM_LEN_W<'a, REG> = crate::FieldWriter<'a, REG, 17, u32>;
        impl R {
            ///Bits 0:16 - encryption and decryption sram size register
            #[inline(always)]
            pub fn sram_len(&self) -> SRAM_LEN_R {
                SRAM_LEN_R::new(self.bits & 0x0001_ffff)
            }
        }
        impl W {
            ///Bits 0:16 - encryption and decryption sram size register
            #[inline(always)]
            #[must_use]
            pub fn sram_len(&mut self) -> SRAM_LEN_W<SRAM_LEN_SPEC> {
                SRAM_LEN_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///encryption and decryption sram size register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`sram_len::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`sram_len::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct SRAM_LEN_SPEC;
        impl crate::RegisterSpec for SRAM_LEN_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`sram_len::R`](R) reader structure
        impl crate::Readable for SRAM_LEN_SPEC {}
        ///`write(|w| ..)` method takes [`sram_len::W`](W) writer structure
        impl crate::Writable for SRAM_LEN_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets SRAM_LEN to value 0
        impl crate::Resettable for SRAM_LEN_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
}
///USBHS register
pub struct USBHS {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for USBHS {}
impl USBHS {
    ///Pointer to the register block
    pub const PTR: *const usbhs::RegisterBlock = 0x4000_9000 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const usbhs::RegisterBlock {
        Self::PTR
    }
    /// Steal an instance of this peripheral
    ///
    /// # Safety
    ///
    /// Ensure that the new instance of the peripheral cannot be used in a way
    /// that may race with any existing instances, for example by only
    /// accessing read-only or write-only registers, or by consuming the
    /// original peripheral and using critical sections to coordinate
    /// access between multiple new instances.
    ///
    /// Additionally, other software such as HALs may rely on only one
    /// peripheral instance existing to ensure memory safety; ensure
    /// no stolen instances are passed to such software.
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for USBHS {
    type Target = usbhs::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for USBHS {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("USBHS").finish()
    }
}
///USBHS register
pub mod usbhs {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        usb_ctrl: USB_CTRL,
        uhost_ctrl: UHOST_CTRL,
        usb_int_en: USB_INT_EN,
        usb_dev_ad: USB_DEV_AD,
        usb_frame_no: USB_FRAME_NO,
        usb_suspend: USB_SUSPEND,
        _reserved6: [u8; 0x01],
        usb_spd_type: USB_SPD_TYPE,
        usb_mis_st: USB_MIS_ST,
        usb_int_fg: USB_INT_FG,
        usb_int_st: USB_INT_ST,
        r6_usb_rx_len: R6_USB_RX_LEN,
        _reserved11: [u8; 0x02],
        uep4_1_mod: UEP4_1_MOD,
        uep2_3_mod_r8_uh_ep_mod: UEP2_3_MOD_R8_UH_EP_MOD,
        uep5_6_mod: UEP5_6_MOD,
        uep7_mod: UEP7_MOD,
        uep0_rt_dma: UEP0_RT_DMA,
        uep1_rx_dma: UEP1_RX_DMA,
        uep2_rx_dma_r32_uh_rx_dma: UEP2_RX_DMA_R32_UH_RX_DMA,
        uep3_rx_dma: UEP3_RX_DMA,
        uep4_rx_dma: UEP4_RX_DMA,
        uep5_rx_dma: UEP5_RX_DMA,
        uep6_rx_dma: UEP6_RX_DMA,
        uep7_rx_dma: UEP7_RX_DMA,
        uep1_tx_dma: UEP1_TX_DMA,
        uep2_tx_dma: UEP2_TX_DMA,
        uep3_tx_dma_r32_uh_tx_dma: UEP3_TX_DMA_R32_UH_TX_DMA,
        uep4_tx_dma: UEP4_TX_DMA,
        uep5_tx_dma: UEP5_TX_DMA,
        uep6_tx_dma: UEP6_TX_DMA,
        uep7_tx_dma: UEP7_TX_DMA,
        uep0_max_len: UEP0_MAX_LEN,
        _reserved31: [u8; 0x02],
        uep1_max_len: UEP1_MAX_LEN,
        _reserved32: [u8; 0x02],
        uep2_max_len_r16_uh_max_len: UEP2_MAX_LEN_R16_UH_MAX_LEN,
        _reserved33: [u8; 0x02],
        uep3_max_len: UEP3_MAX_LEN,
        _reserved34: [u8; 0x02],
        uep4_max_len: UEP4_MAX_LEN,
        _reserved35: [u8; 0x02],
        uep5_max_len: UEP5_MAX_LEN,
        _reserved36: [u8; 0x02],
        uep6_max_len: UEP6_MAX_LEN,
        _reserved37: [u8; 0x02],
        uep7_max_len: UEP7_MAX_LEN,
        _reserved38: [u8; 0x02],
        uep0_t_len: UEP0_T_LEN,
        uep0_tx_ctrl: UEP0_TX_CTRL,
        uep0_rx_ctrl: UEP0_RX_CTRL,
        uep1_t_len: UEP1_T_LEN,
        uep1_tx_ctrl: UEP1_TX_CTRL,
        uep1_rx_ctrl: UEP1_RX_CTRL,
        uep2_t_len_r16_uh_ep_pid: UEP2_T_LEN_R16_UH_EP_PID,
        uep2_tx_ctrl: UEP2_TX_CTRL,
        uep2_rx_ctrl_r8_uh_rx_ctrl: UEP2_RX_CTRL_R8_UH_RX_CTRL,
        uep3_t_len_r16_uh_tx_len: UEP3_T_LEN_R16_UH_TX_LEN,
        uep3_tx_ctrl_r8_uh_tx_ctrl: UEP3_TX_CTRL_R8_UH_TX_CTRL,
        uep3_rx_ctrl: UEP3_RX_CTRL,
        uep4_t_len_r16_uh_split_data: UEP4_T_LEN_R16_UH_SPLIT_DATA,
        uep4_tx_ctrl: UEP4_TX_CTRL,
        uep4_rx_ctrl: UEP4_RX_CTRL,
        uep5_t_len: UEP5_T_LEN,
        uep5_tx_ctrl: UEP5_TX_CTRL,
        uep5_rx_ctrl: UEP5_RX_CTRL,
        uep6_t_len: UEP6_T_LEN,
        uep6_tx_ctrl: UEP6_TX_CTRL,
        uep6_rx_ctrl: UEP6_RX_CTRL,
        uep7_t_len: UEP7_T_LEN,
        uep7_tx_ctrl: UEP7_TX_CTRL,
        uep7_rx_ctrl: UEP7_RX_CTRL,
    }
    impl RegisterBlock {
        ///0x00 - USB base control
        #[inline(always)]
        pub const fn usb_ctrl(&self) -> &USB_CTRL {
            &self.usb_ctrl
        }
        ///0x01 - USB host control register
        #[inline(always)]
        pub const fn uhost_ctrl(&self) -> &UHOST_CTRL {
            &self.uhost_ctrl
        }
        ///0x02 - USB interrupt enable
        #[inline(always)]
        pub const fn usb_int_en(&self) -> &USB_INT_EN {
            &self.usb_int_en
        }
        ///0x03 - USB device address
        #[inline(always)]
        pub const fn usb_dev_ad(&self) -> &USB_DEV_AD {
            &self.usb_dev_ad
        }
        ///0x04 - USB frame number register
        #[inline(always)]
        pub const fn usb_frame_no(&self) -> &USB_FRAME_NO {
            &self.usb_frame_no
        }
        ///0x06 - USB suspend register
        #[inline(always)]
        pub const fn usb_suspend(&self) -> &USB_SUSPEND {
            &self.usb_suspend
        }
        ///0x08 - USB actual speed register
        #[inline(always)]
        pub const fn usb_spd_type(&self) -> &USB_SPD_TYPE {
            &self.usb_spd_type
        }
        ///0x09 - USB miscellaneous status
        #[inline(always)]
        pub const fn usb_mis_st(&self) -> &USB_MIS_ST {
            &self.usb_mis_st
        }
        ///0x0a - USB interrupt flag
        #[inline(always)]
        pub const fn usb_int_fg(&self) -> &USB_INT_FG {
            &self.usb_int_fg
        }
        ///0x0b - USB interrupt status
        #[inline(always)]
        pub const fn usb_int_st(&self) -> &USB_INT_ST {
            &self.usb_int_st
        }
        ///0x0c - USB receiving length
        #[inline(always)]
        pub const fn r6_usb_rx_len(&self) -> &R6_USB_RX_LEN {
            &self.r6_usb_rx_len
        }
        ///0x10 - endpoint 1(9) 4(8,12) mode
        #[inline(always)]
        pub const fn uep4_1_mod(&self) -> &UEP4_1_MOD {
            &self.uep4_1_mod
        }
        ///0x11 - endpoint 2(10) 3(11) mode and USB host endpoint mode control register
        #[inline(always)]
        pub const fn uep2_3_mod_r8_uh_ep_mod(&self) -> &UEP2_3_MOD_R8_UH_EP_MOD {
            &self.uep2_3_mod_r8_uh_ep_mod
        }
        ///0x12 - endpoint 5(13) 6(14) mode
        #[inline(always)]
        pub const fn uep5_6_mod(&self) -> &UEP5_6_MOD {
            &self.uep5_6_mod
        }
        ///0x13 - endpoint 7(15) mode
        #[inline(always)]
        pub const fn uep7_mod(&self) -> &UEP7_MOD {
            &self.uep7_mod
        }
        ///0x14 - endpoint 0 DMA buffer address
        #[inline(always)]
        pub const fn uep0_rt_dma(&self) -> &UEP0_RT_DMA {
            &self.uep0_rt_dma
        }
        ///0x18 - endpoint 1 DMA buffer address
        #[inline(always)]
        pub const fn uep1_rx_dma(&self) -> &UEP1_RX_DMA {
            &self.uep1_rx_dma
        }
        ///0x1c - endpoint 2 DMA buffer address _ host rx endpoint buffer start address
        #[inline(always)]
        pub const fn uep2_rx_dma_r32_uh_rx_dma(&self) -> &UEP2_RX_DMA_R32_UH_RX_DMA {
            &self.uep2_rx_dma_r32_uh_rx_dma
        }
        ///0x20 - endpoint 3 DMA buffer address;host tx endpoint buffer high address
        #[inline(always)]
        pub const fn uep3_rx_dma(&self) -> &UEP3_RX_DMA {
            &self.uep3_rx_dma
        }
        ///0x24 - endpoint 4 DMA buffer address
        #[inline(always)]
        pub const fn uep4_rx_dma(&self) -> &UEP4_RX_DMA {
            &self.uep4_rx_dma
        }
        ///0x28 - endpoint 5 DMA buffer address
        #[inline(always)]
        pub const fn uep5_rx_dma(&self) -> &UEP5_RX_DMA {
            &self.uep5_rx_dma
        }
        ///0x2c - endpoint 6 DMA buffer address
        #[inline(always)]
        pub const fn uep6_rx_dma(&self) -> &UEP6_RX_DMA {
            &self.uep6_rx_dma
        }
        ///0x30 - endpoint 7 DMA buffer address
        #[inline(always)]
        pub const fn uep7_rx_dma(&self) -> &UEP7_RX_DMA {
            &self.uep7_rx_dma
        }
        ///0x34 - endpoint 1 DMA TX buffer address
        #[inline(always)]
        pub const fn uep1_tx_dma(&self) -> &UEP1_TX_DMA {
            &self.uep1_tx_dma
        }
        ///0x38 - endpoint 2 DMA TX buffer address
        #[inline(always)]
        pub const fn uep2_tx_dma(&self) -> &UEP2_TX_DMA {
            &self.uep2_tx_dma
        }
        ///0x3c - endpoint 3 DMA TX buffer address and host tx endpoint buffer start address
        #[inline(always)]
        pub const fn uep3_tx_dma_r32_uh_tx_dma(&self) -> &UEP3_TX_DMA_R32_UH_TX_DMA {
            &self.uep3_tx_dma_r32_uh_tx_dma
        }
        ///0x40 - endpoint 4 DMA TX buffer address
        #[inline(always)]
        pub const fn uep4_tx_dma(&self) -> &UEP4_TX_DMA {
            &self.uep4_tx_dma
        }
        ///0x44 - endpoint 5 DMA TX buffer address
        #[inline(always)]
        pub const fn uep5_tx_dma(&self) -> &UEP5_TX_DMA {
            &self.uep5_tx_dma
        }
        ///0x48 - endpoint 4 DMA TX buffer address
        #[inline(always)]
        pub const fn uep6_tx_dma(&self) -> &UEP6_TX_DMA {
            &self.uep6_tx_dma
        }
        ///0x4c - endpoint 7 DMA TX buffer address
        #[inline(always)]
        pub const fn uep7_tx_dma(&self) -> &UEP7_TX_DMA {
            &self.uep7_tx_dma
        }
        ///0x50 - endpoint 0 receive max length
        #[inline(always)]
        pub const fn uep0_max_len(&self) -> &UEP0_MAX_LEN {
            &self.uep0_max_len
        }
        ///0x54 - endpoint 1 receive max length
        #[inline(always)]
        pub const fn uep1_max_len(&self) -> &UEP1_MAX_LEN {
            &self.uep1_max_len
        }
        ///0x58 - endpoint 2 receive max length and USB host receive max packet length register
        #[inline(always)]
        pub const fn uep2_max_len_r16_uh_max_len(&self) -> &UEP2_MAX_LEN_R16_UH_MAX_LEN {
            &self.uep2_max_len_r16_uh_max_len
        }
        ///0x5c - endpoint 3 receive max length
        #[inline(always)]
        pub const fn uep3_max_len(&self) -> &UEP3_MAX_LEN {
            &self.uep3_max_len
        }
        ///0x60 - endpoint 4 receive max length
        #[inline(always)]
        pub const fn uep4_max_len(&self) -> &UEP4_MAX_LEN {
            &self.uep4_max_len
        }
        ///0x64 - endpoint 5 receive max length
        #[inline(always)]
        pub const fn uep5_max_len(&self) -> &UEP5_MAX_LEN {
            &self.uep5_max_len
        }
        ///0x68 - endpoint 6 receive max length
        #[inline(always)]
        pub const fn uep6_max_len(&self) -> &UEP6_MAX_LEN {
            &self.uep6_max_len
        }
        ///0x6c - endpoint 7 receive max length
        #[inline(always)]
        pub const fn uep7_max_len(&self) -> &UEP7_MAX_LEN {
            &self.uep7_max_len
        }
        ///0x70 - endpoint 0 transmittal length
        #[inline(always)]
        pub const fn uep0_t_len(&self) -> &UEP0_T_LEN {
            &self.uep0_t_len
        }
        ///0x72 - endpoint 0 tx control
        #[inline(always)]
        pub const fn uep0_tx_ctrl(&self) -> &UEP0_TX_CTRL {
            &self.uep0_tx_ctrl
        }
        ///0x73 - endpoint 0 rx control
        #[inline(always)]
        pub const fn uep0_rx_ctrl(&self) -> &UEP0_RX_CTRL {
            &self.uep0_rx_ctrl
        }
        ///0x74 - endpoint 1 transmittal length
        #[inline(always)]
        pub const fn uep1_t_len(&self) -> &UEP1_T_LEN {
            &self.uep1_t_len
        }
        ///0x76 - endpoint 1 tx control
        #[inline(always)]
        pub const fn uep1_tx_ctrl(&self) -> &UEP1_TX_CTRL {
            &self.uep1_tx_ctrl
        }
        ///0x77 - endpoint 1 rx control
        #[inline(always)]
        pub const fn uep1_rx_ctrl(&self) -> &UEP1_RX_CTRL {
            &self.uep1_rx_ctrl
        }
        ///0x78 - endpoint 2 transmittal length and Set usb host token register
        #[inline(always)]
        pub const fn uep2_t_len_r16_uh_ep_pid(&self) -> &UEP2_T_LEN_R16_UH_EP_PID {
            &self.uep2_t_len_r16_uh_ep_pid
        }
        ///0x7a - endpoint 2 tx control
        #[inline(always)]
        pub const fn uep2_tx_ctrl(&self) -> &UEP2_TX_CTRL {
            &self.uep2_tx_ctrl
        }
        ///0x7b - endpoint 2 rx control and USb host receive endpoint control register
        #[inline(always)]
        pub const fn uep2_rx_ctrl_r8_uh_rx_ctrl(&self) -> &UEP2_RX_CTRL_R8_UH_RX_CTRL {
            &self.uep2_rx_ctrl_r8_uh_rx_ctrl
        }
        ///0x7c - endpoint 3 transmittal length and host transmittal endpoint transmittal length
        #[inline(always)]
        pub const fn uep3_t_len_r16_uh_tx_len(&self) -> &UEP3_T_LEN_R16_UH_TX_LEN {
            &self.uep3_t_len_r16_uh_tx_len
        }
        ///0x7e - endpoint 3 tx control and host transmittal endpoint control
        #[inline(always)]
        pub const fn uep3_tx_ctrl_r8_uh_tx_ctrl(&self) -> &UEP3_TX_CTRL_R8_UH_TX_CTRL {
            &self.uep3_tx_ctrl_r8_uh_tx_ctrl
        }
        ///0x7f - endpoint 3 rx control
        #[inline(always)]
        pub const fn uep3_rx_ctrl(&self) -> &UEP3_RX_CTRL {
            &self.uep3_rx_ctrl
        }
        ///0x80 - endpoint 4 transmittal length and USB host Tx SPLIT packet data
        #[inline(always)]
        pub const fn uep4_t_len_r16_uh_split_data(&self) -> &UEP4_T_LEN_R16_UH_SPLIT_DATA {
            &self.uep4_t_len_r16_uh_split_data
        }
        ///0x82 - endpoint 4 tx control
        #[inline(always)]
        pub const fn uep4_tx_ctrl(&self) -> &UEP4_TX_CTRL {
            &self.uep4_tx_ctrl
        }
        ///0x83 - endpoint 4 rx control
        #[inline(always)]
        pub const fn uep4_rx_ctrl(&self) -> &UEP4_RX_CTRL {
            &self.uep4_rx_ctrl
        }
        ///0x84 - endpoint 5 transmittal length
        #[inline(always)]
        pub const fn uep5_t_len(&self) -> &UEP5_T_LEN {
            &self.uep5_t_len
        }
        ///0x86 - endpoint 5 tx control
        #[inline(always)]
        pub const fn uep5_tx_ctrl(&self) -> &UEP5_TX_CTRL {
            &self.uep5_tx_ctrl
        }
        ///0x87 - endpoint 5 rx control
        #[inline(always)]
        pub const fn uep5_rx_ctrl(&self) -> &UEP5_RX_CTRL {
            &self.uep5_rx_ctrl
        }
        ///0x88 - endpoint 6 transmittal length
        #[inline(always)]
        pub const fn uep6_t_len(&self) -> &UEP6_T_LEN {
            &self.uep6_t_len
        }
        ///0x8a - endpoint 6 tx control
        #[inline(always)]
        pub const fn uep6_tx_ctrl(&self) -> &UEP6_TX_CTRL {
            &self.uep6_tx_ctrl
        }
        ///0x8b - endpoint 6 rx control
        #[inline(always)]
        pub const fn uep6_rx_ctrl(&self) -> &UEP6_RX_CTRL {
            &self.uep6_rx_ctrl
        }
        ///0x8c - endpoint 7 transmittal length
        #[inline(always)]
        pub const fn uep7_t_len(&self) -> &UEP7_T_LEN {
            &self.uep7_t_len
        }
        ///0x8e - endpoint 7 tx control
        #[inline(always)]
        pub const fn uep7_tx_ctrl(&self) -> &UEP7_TX_CTRL {
            &self.uep7_tx_ctrl
        }
        ///0x8f - endpoint 7 rx control
        #[inline(always)]
        pub const fn uep7_rx_ctrl(&self) -> &UEP7_RX_CTRL {
            &self.uep7_rx_ctrl
        }
    }
    ///USB_CTRL (rw) register accessor: USB base control
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`usb_ctrl::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`usb_ctrl::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@usb_ctrl`]
    ///module
    pub type USB_CTRL = crate::Reg<usb_ctrl::USB_CTRL_SPEC>;
    ///USB base control
    pub mod usb_ctrl {
        ///Register `USB_CTRL` reader
        pub type R = crate::R<USB_CTRL_SPEC>;
        ///Register `USB_CTRL` writer
        pub type W = crate::W<USB_CTRL_SPEC>;
        ///Field `USB_DMA_EN` reader - DMA enable and DMA interrupt enable for USB
        pub type USB_DMA_EN_R = crate::BitReader;
        ///Field `USB_DMA_EN` writer - DMA enable and DMA interrupt enable for USB
        pub type USB_DMA_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `USB_CLR_ALL` reader - force clear FIFO and count of USB
        pub type USB_CLR_ALL_R = crate::BitReader;
        ///Field `USB_CLR_ALL` writer - force clear FIFO and count of USB
        pub type USB_CLR_ALL_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `USB_RESET_SIE` reader - force reset USB SIE, need software clear
        pub type USB_RESET_SIE_R = crate::BitReader;
        ///Field `USB_RESET_SIE` writer - force reset USB SIE, need software clear
        pub type USB_RESET_SIE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `USB_INT_BUSY` reader - enable automatic responding busy for device mode or automatic pause for host mode during interrupt flag UIF_TRANSFER valid
        pub type USB_INT_BUSY_R = crate::BitReader;
        ///Field `USB_INT_BUSY` writer - enable automatic responding busy for device mode or automatic pause for host mode during interrupt flag UIF_TRANSFER valid
        pub type USB_INT_BUSY_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `DEV_PU_EN` reader - USB device enable and internal pullup resistance enable
        pub type DEV_PU_EN_R = crate::BitReader;
        ///Field `DEV_PU_EN` writer - USB device enable and internal pullup resistance enable
        pub type DEV_PU_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `USB_SPTP_MASK` reader - enable USB low speed
        pub type USB_SPTP_MASK_R = crate::FieldReader;
        ///Field `USB_SPTP_MASK` writer - enable USB low speed
        pub type USB_SPTP_MASK_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `USB_MODE` reader - enable USB host mode: 0=device mode, 1=host mode
        pub type USB_MODE_R = crate::BitReader;
        ///Field `USB_MODE` writer - enable USB host mode: 0=device mode, 1=host mode
        pub type USB_MODE_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - DMA enable and DMA interrupt enable for USB
            #[inline(always)]
            pub fn usb_dma_en(&self) -> USB_DMA_EN_R {
                USB_DMA_EN_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - force clear FIFO and count of USB
            #[inline(always)]
            pub fn usb_clr_all(&self) -> USB_CLR_ALL_R {
                USB_CLR_ALL_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - force reset USB SIE, need software clear
            #[inline(always)]
            pub fn usb_reset_sie(&self) -> USB_RESET_SIE_R {
                USB_RESET_SIE_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - enable automatic responding busy for device mode or automatic pause for host mode during interrupt flag UIF_TRANSFER valid
            #[inline(always)]
            pub fn usb_int_busy(&self) -> USB_INT_BUSY_R {
                USB_INT_BUSY_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - USB device enable and internal pullup resistance enable
            #[inline(always)]
            pub fn dev_pu_en(&self) -> DEV_PU_EN_R {
                DEV_PU_EN_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bits 5:6 - enable USB low speed
            #[inline(always)]
            pub fn usb_sptp_mask(&self) -> USB_SPTP_MASK_R {
                USB_SPTP_MASK_R::new((self.bits >> 5) & 3)
            }
            ///Bit 7 - enable USB host mode: 0=device mode, 1=host mode
            #[inline(always)]
            pub fn usb_mode(&self) -> USB_MODE_R {
                USB_MODE_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - DMA enable and DMA interrupt enable for USB
            #[inline(always)]
            #[must_use]
            pub fn usb_dma_en(&mut self) -> USB_DMA_EN_W<USB_CTRL_SPEC> {
                USB_DMA_EN_W::new(self, 0)
            }
            ///Bit 1 - force clear FIFO and count of USB
            #[inline(always)]
            #[must_use]
            pub fn usb_clr_all(&mut self) -> USB_CLR_ALL_W<USB_CTRL_SPEC> {
                USB_CLR_ALL_W::new(self, 1)
            }
            ///Bit 2 - force reset USB SIE, need software clear
            #[inline(always)]
            #[must_use]
            pub fn usb_reset_sie(&mut self) -> USB_RESET_SIE_W<USB_CTRL_SPEC> {
                USB_RESET_SIE_W::new(self, 2)
            }
            ///Bit 3 - enable automatic responding busy for device mode or automatic pause for host mode during interrupt flag UIF_TRANSFER valid
            #[inline(always)]
            #[must_use]
            pub fn usb_int_busy(&mut self) -> USB_INT_BUSY_W<USB_CTRL_SPEC> {
                USB_INT_BUSY_W::new(self, 3)
            }
            ///Bit 4 - USB device enable and internal pullup resistance enable
            #[inline(always)]
            #[must_use]
            pub fn dev_pu_en(&mut self) -> DEV_PU_EN_W<USB_CTRL_SPEC> {
                DEV_PU_EN_W::new(self, 4)
            }
            ///Bits 5:6 - enable USB low speed
            #[inline(always)]
            #[must_use]
            pub fn usb_sptp_mask(&mut self) -> USB_SPTP_MASK_W<USB_CTRL_SPEC> {
                USB_SPTP_MASK_W::new(self, 5)
            }
            ///Bit 7 - enable USB host mode: 0=device mode, 1=host mode
            #[inline(always)]
            #[must_use]
            pub fn usb_mode(&mut self) -> USB_MODE_W<USB_CTRL_SPEC> {
                USB_MODE_W::new(self, 7)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///USB base control
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`usb_ctrl::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`usb_ctrl::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct USB_CTRL_SPEC;
        impl crate::RegisterSpec for USB_CTRL_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`usb_ctrl::R`](R) reader structure
        impl crate::Readable for USB_CTRL_SPEC {}
        ///`write(|w| ..)` method takes [`usb_ctrl::W`](W) writer structure
        impl crate::Writable for USB_CTRL_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets USB_CTRL to value 0x06
        impl crate::Resettable for USB_CTRL_SPEC {
            const RESET_VALUE: u8 = 0x06;
        }
    }
    ///UHOST_CTRL (rw) register accessor: USB host control register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`uhost_ctrl::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uhost_ctrl::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@uhost_ctrl`]
    ///module
    pub type UHOST_CTRL = crate::Reg<uhost_ctrl::UHOST_CTRL_SPEC>;
    ///USB host control register
    pub mod uhost_ctrl {
        ///Register `UHOST_CTRL` reader
        pub type R = crate::R<UHOST_CTRL_SPEC>;
        ///Register `UHOST_CTRL` writer
        pub type W = crate::W<UHOST_CTRL_SPEC>;
        ///Field `UH_BUS_RESET` reader - USB host send bus reset signal
        pub type UH_BUS_RESET_R = crate::BitReader;
        ///Field `UH_BUS_RESET` writer - USB host send bus reset signal
        pub type UH_BUS_RESET_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UH_BUS_SUSPEND` reader - USB host send bus suspend signal
        pub type UH_BUS_SUSPEND_R = crate::BitReader;
        ///Field `UH_BUS_SUSPEND` writer - USB host send bus suspend signal
        pub type UH_BUS_SUSPEND_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UH_BUS_RESUME` reader - USB host suspend state and wake up device
        pub type UH_BUS_RESUME_R = crate::BitReader;
        ///Field `UH_BUS_RESUME` writer - USB host suspend state and wake up device
        pub type UH_BUS_RESUME_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UH_AUTOSOF_EN` reader - Automatically generate sof packet enable control
        pub type UH_AUTOSOF_EN_R = crate::BitReader;
        ///Field `UH_AUTOSOF_EN` writer - Automatically generate sof packet enable control
        pub type UH_AUTOSOF_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - USB host send bus reset signal
            #[inline(always)]
            pub fn uh_bus_reset(&self) -> UH_BUS_RESET_R {
                UH_BUS_RESET_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - USB host send bus suspend signal
            #[inline(always)]
            pub fn uh_bus_suspend(&self) -> UH_BUS_SUSPEND_R {
                UH_BUS_SUSPEND_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - USB host suspend state and wake up device
            #[inline(always)]
            pub fn uh_bus_resume(&self) -> UH_BUS_RESUME_R {
                UH_BUS_RESUME_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 7 - Automatically generate sof packet enable control
            #[inline(always)]
            pub fn uh_autosof_en(&self) -> UH_AUTOSOF_EN_R {
                UH_AUTOSOF_EN_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - USB host send bus reset signal
            #[inline(always)]
            #[must_use]
            pub fn uh_bus_reset(&mut self) -> UH_BUS_RESET_W<UHOST_CTRL_SPEC> {
                UH_BUS_RESET_W::new(self, 0)
            }
            ///Bit 1 - USB host send bus suspend signal
            #[inline(always)]
            #[must_use]
            pub fn uh_bus_suspend(&mut self) -> UH_BUS_SUSPEND_W<UHOST_CTRL_SPEC> {
                UH_BUS_SUSPEND_W::new(self, 1)
            }
            ///Bit 2 - USB host suspend state and wake up device
            #[inline(always)]
            #[must_use]
            pub fn uh_bus_resume(&mut self) -> UH_BUS_RESUME_W<UHOST_CTRL_SPEC> {
                UH_BUS_RESUME_W::new(self, 2)
            }
            ///Bit 7 - Automatically generate sof packet enable control
            #[inline(always)]
            #[must_use]
            pub fn uh_autosof_en(&mut self) -> UH_AUTOSOF_EN_W<UHOST_CTRL_SPEC> {
                UH_AUTOSOF_EN_W::new(self, 7)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///USB host control register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`uhost_ctrl::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uhost_ctrl::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct UHOST_CTRL_SPEC;
        impl crate::RegisterSpec for UHOST_CTRL_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`uhost_ctrl::R`](R) reader structure
        impl crate::Readable for UHOST_CTRL_SPEC {}
        ///`write(|w| ..)` method takes [`uhost_ctrl::W`](W) writer structure
        impl crate::Writable for UHOST_CTRL_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets UHOST_CTRL to value 0
        impl crate::Resettable for UHOST_CTRL_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///USB_INT_EN (rw) register accessor: USB interrupt enable
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`usb_int_en::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`usb_int_en::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@usb_int_en`]
    ///module
    pub type USB_INT_EN = crate::Reg<usb_int_en::USB_INT_EN_SPEC>;
    ///USB interrupt enable
    pub mod usb_int_en {
        ///Register `USB_INT_EN` reader
        pub type R = crate::R<USB_INT_EN_SPEC>;
        ///Register `USB_INT_EN` writer
        pub type W = crate::W<USB_INT_EN_SPEC>;
        ///Field `USB_IE_BUSRST_RB_USB_IE_DETECT` reader - enable interrupt for USB bus reset event for USB device mode _ enable interrupt for USB device detected event for USB host mode
        pub type USB_IE_BUSRST_RB_USB_IE_DETECT_R = crate::BitReader;
        ///Field `USB_IE_BUSRST_RB_USB_IE_DETECT` writer - enable interrupt for USB bus reset event for USB device mode _ enable interrupt for USB device detected event for USB host mode
        pub type USB_IE_BUSRST_RB_USB_IE_DETECT_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `USB_IE_TRANS` reader - enable interrupt for USB transfer completion
        pub type USB_IE_TRANS_R = crate::BitReader;
        ///Field `USB_IE_TRANS` writer - enable interrupt for USB transfer completion
        pub type USB_IE_TRANS_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `USB_IE_SUSPEND` reader - enable interrupt for USB suspend or resume event
        pub type USB_IE_SUSPEND_R = crate::BitReader;
        ///Field `USB_IE_SUSPEND` writer - enable interrupt for USB suspend or resume event
        pub type USB_IE_SUSPEND_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `USB_IE_SOF` reader - enable interrupt for host SOF timer action for USB host mode
        pub type USB_IE_SOF_R = crate::BitReader;
        ///Field `USB_IE_SOF` writer - enable interrupt for host SOF timer action for USB host mode
        pub type USB_IE_SOF_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `USB_IE_FIFOOV` reader - enable interrupt for FIFO overflow
        pub type USB_IE_FIFOOV_R = crate::BitReader;
        ///Field `USB_IE_FIFOOV` writer - enable interrupt for FIFO overflow
        pub type USB_IE_FIFOOV_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `USB_IE_SETUPACT` reader - Setup packet end interrupt
        pub type USB_IE_SETUPACT_R = crate::BitReader;
        ///Field `USB_IE_SETUPACT` writer - Setup packet end interrupt
        pub type USB_IE_SETUPACT_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `USB_IE_ISOACT` reader - Synchronous transmission received control token packet interrupt
        pub type USB_IE_ISOACT_R = crate::BitReader;
        ///Field `USB_IE_ISOACT` writer - Synchronous transmission received control token packet interrupt
        pub type USB_IE_ISOACT_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `USB_IE_DEV_NAK` reader - enable interrupt for NAK responded for USB device mode
        pub type USB_IE_DEV_NAK_R = crate::BitReader;
        ///Field `USB_IE_DEV_NAK` writer - enable interrupt for NAK responded for USB device mode
        pub type USB_IE_DEV_NAK_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - enable interrupt for USB bus reset event for USB device mode _ enable interrupt for USB device detected event for USB host mode
            #[inline(always)]
            pub fn usb_ie_busrst_rb_usb_ie_detect(&self) -> USB_IE_BUSRST_RB_USB_IE_DETECT_R {
                USB_IE_BUSRST_RB_USB_IE_DETECT_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - enable interrupt for USB transfer completion
            #[inline(always)]
            pub fn usb_ie_trans(&self) -> USB_IE_TRANS_R {
                USB_IE_TRANS_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - enable interrupt for USB suspend or resume event
            #[inline(always)]
            pub fn usb_ie_suspend(&self) -> USB_IE_SUSPEND_R {
                USB_IE_SUSPEND_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - enable interrupt for host SOF timer action for USB host mode
            #[inline(always)]
            pub fn usb_ie_sof(&self) -> USB_IE_SOF_R {
                USB_IE_SOF_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - enable interrupt for FIFO overflow
            #[inline(always)]
            pub fn usb_ie_fifoov(&self) -> USB_IE_FIFOOV_R {
                USB_IE_FIFOOV_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - Setup packet end interrupt
            #[inline(always)]
            pub fn usb_ie_setupact(&self) -> USB_IE_SETUPACT_R {
                USB_IE_SETUPACT_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - Synchronous transmission received control token packet interrupt
            #[inline(always)]
            pub fn usb_ie_isoact(&self) -> USB_IE_ISOACT_R {
                USB_IE_ISOACT_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - enable interrupt for NAK responded for USB device mode
            #[inline(always)]
            pub fn usb_ie_dev_nak(&self) -> USB_IE_DEV_NAK_R {
                USB_IE_DEV_NAK_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - enable interrupt for USB bus reset event for USB device mode _ enable interrupt for USB device detected event for USB host mode
            #[inline(always)]
            #[must_use]
            pub fn usb_ie_busrst_rb_usb_ie_detect(
                &mut self,
            ) -> USB_IE_BUSRST_RB_USB_IE_DETECT_W<USB_INT_EN_SPEC> {
                USB_IE_BUSRST_RB_USB_IE_DETECT_W::new(self, 0)
            }
            ///Bit 1 - enable interrupt for USB transfer completion
            #[inline(always)]
            #[must_use]
            pub fn usb_ie_trans(&mut self) -> USB_IE_TRANS_W<USB_INT_EN_SPEC> {
                USB_IE_TRANS_W::new(self, 1)
            }
            ///Bit 2 - enable interrupt for USB suspend or resume event
            #[inline(always)]
            #[must_use]
            pub fn usb_ie_suspend(&mut self) -> USB_IE_SUSPEND_W<USB_INT_EN_SPEC> {
                USB_IE_SUSPEND_W::new(self, 2)
            }
            ///Bit 3 - enable interrupt for host SOF timer action for USB host mode
            #[inline(always)]
            #[must_use]
            pub fn usb_ie_sof(&mut self) -> USB_IE_SOF_W<USB_INT_EN_SPEC> {
                USB_IE_SOF_W::new(self, 3)
            }
            ///Bit 4 - enable interrupt for FIFO overflow
            #[inline(always)]
            #[must_use]
            pub fn usb_ie_fifoov(&mut self) -> USB_IE_FIFOOV_W<USB_INT_EN_SPEC> {
                USB_IE_FIFOOV_W::new(self, 4)
            }
            ///Bit 5 - Setup packet end interrupt
            #[inline(always)]
            #[must_use]
            pub fn usb_ie_setupact(&mut self) -> USB_IE_SETUPACT_W<USB_INT_EN_SPEC> {
                USB_IE_SETUPACT_W::new(self, 5)
            }
            ///Bit 6 - Synchronous transmission received control token packet interrupt
            #[inline(always)]
            #[must_use]
            pub fn usb_ie_isoact(&mut self) -> USB_IE_ISOACT_W<USB_INT_EN_SPEC> {
                USB_IE_ISOACT_W::new(self, 6)
            }
            ///Bit 7 - enable interrupt for NAK responded for USB device mode
            #[inline(always)]
            #[must_use]
            pub fn usb_ie_dev_nak(&mut self) -> USB_IE_DEV_NAK_W<USB_INT_EN_SPEC> {
                USB_IE_DEV_NAK_W::new(self, 7)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///USB interrupt enable
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`usb_int_en::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`usb_int_en::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct USB_INT_EN_SPEC;
        impl crate::RegisterSpec for USB_INT_EN_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`usb_int_en::R`](R) reader structure
        impl crate::Readable for USB_INT_EN_SPEC {}
        ///`write(|w| ..)` method takes [`usb_int_en::W`](W) writer structure
        impl crate::Writable for USB_INT_EN_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets USB_INT_EN to value 0
        impl crate::Resettable for USB_INT_EN_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///USB_DEV_AD (rw) register accessor: USB device address
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`usb_dev_ad::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`usb_dev_ad::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@usb_dev_ad`]
    ///module
    pub type USB_DEV_AD = crate::Reg<usb_dev_ad::USB_DEV_AD_SPEC>;
    ///USB device address
    pub mod usb_dev_ad {
        ///Register `USB_DEV_AD` reader
        pub type R = crate::R<USB_DEV_AD_SPEC>;
        ///Register `USB_DEV_AD` writer
        pub type W = crate::W<USB_DEV_AD_SPEC>;
        ///Field `USB_ADDR_MASK` reader - bit mask for USB device address
        pub type USB_ADDR_MASK_R = crate::FieldReader;
        ///Field `USB_ADDR_MASK` writer - bit mask for USB device address
        pub type USB_ADDR_MASK_W<'a, REG> = crate::FieldWriter<'a, REG, 7>;
        impl R {
            ///Bits 0:6 - bit mask for USB device address
            #[inline(always)]
            pub fn usb_addr_mask(&self) -> USB_ADDR_MASK_R {
                USB_ADDR_MASK_R::new(self.bits & 0x7f)
            }
        }
        impl W {
            ///Bits 0:6 - bit mask for USB device address
            #[inline(always)]
            #[must_use]
            pub fn usb_addr_mask(&mut self) -> USB_ADDR_MASK_W<USB_DEV_AD_SPEC> {
                USB_ADDR_MASK_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///USB device address
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`usb_dev_ad::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`usb_dev_ad::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct USB_DEV_AD_SPEC;
        impl crate::RegisterSpec for USB_DEV_AD_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`usb_dev_ad::R`](R) reader structure
        impl crate::Readable for USB_DEV_AD_SPEC {}
        ///`write(|w| ..)` method takes [`usb_dev_ad::W`](W) writer structure
        impl crate::Writable for USB_DEV_AD_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets USB_DEV_AD to value 0
        impl crate::Resettable for USB_DEV_AD_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///USB_FRAME_NO (r) register accessor: USB frame number register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`usb_frame_no::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@usb_frame_no`]
    ///module
    pub type USB_FRAME_NO = crate::Reg<usb_frame_no::USB_FRAME_NO_SPEC>;
    ///USB frame number register
    pub mod usb_frame_no {
        ///Register `USB_FRAME_NO` reader
        pub type R = crate::R<USB_FRAME_NO_SPEC>;
        ///Field `USB_FRAME_NO` reader - USB frame number
        pub type USB_FRAME_NO_R = crate::FieldReader<u16>;
        impl R {
            ///Bits 0:15 - USB frame number
            #[inline(always)]
            pub fn usb_frame_no(&self) -> USB_FRAME_NO_R {
                USB_FRAME_NO_R::new(self.bits)
            }
        }
        ///USB frame number register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`usb_frame_no::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct USB_FRAME_NO_SPEC;
        impl crate::RegisterSpec for USB_FRAME_NO_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`usb_frame_no::R`](R) reader structure
        impl crate::Readable for USB_FRAME_NO_SPEC {}
        ///`reset()` method sets USB_FRAME_NO to value 0
        impl crate::Resettable for USB_FRAME_NO_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///USB_SUSPEND (rw) register accessor: USB suspend register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`usb_suspend::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`usb_suspend::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@usb_suspend`]
    ///module
    pub type USB_SUSPEND = crate::Reg<usb_suspend::USB_SUSPEND_SPEC>;
    ///USB suspend register
    pub mod usb_suspend {
        ///Register `USB_SUSPEND` reader
        pub type R = crate::R<USB_SUSPEND_SPEC>;
        ///Register `USB_SUSPEND` writer
        pub type W = crate::W<USB_SUSPEND_SPEC>;
        ///Field `DEV_WAKEUP` reader - Remote wake-up control bit
        pub type DEV_WAKEUP_R = crate::BitReader;
        ///Field `DEV_WAKEUP` writer - Remote wake-up control bit
        pub type DEV_WAKEUP_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 1 - Remote wake-up control bit
            #[inline(always)]
            pub fn dev_wakeup(&self) -> DEV_WAKEUP_R {
                DEV_WAKEUP_R::new(((self.bits >> 1) & 1) != 0)
            }
        }
        impl W {
            ///Bit 1 - Remote wake-up control bit
            #[inline(always)]
            #[must_use]
            pub fn dev_wakeup(&mut self) -> DEV_WAKEUP_W<USB_SUSPEND_SPEC> {
                DEV_WAKEUP_W::new(self, 1)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///USB suspend register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`usb_suspend::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`usb_suspend::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct USB_SUSPEND_SPEC;
        impl crate::RegisterSpec for USB_SUSPEND_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`usb_suspend::R`](R) reader structure
        impl crate::Readable for USB_SUSPEND_SPEC {}
        ///`write(|w| ..)` method takes [`usb_suspend::W`](W) writer structure
        impl crate::Writable for USB_SUSPEND_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets USB_SUSPEND to value 0
        impl crate::Resettable for USB_SUSPEND_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///USB_SPD_TYPE (r) register accessor: USB actual speed register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`usb_spd_type::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@usb_spd_type`]
    ///module
    pub type USB_SPD_TYPE = crate::Reg<usb_spd_type::USB_SPD_TYPE_SPEC>;
    ///USB actual speed register
    pub mod usb_spd_type {
        ///Register `USB_SPD_TYPE` reader
        pub type R = crate::R<USB_SPD_TYPE_SPEC>;
        ///Field `USBSPEED_MASK` reader - USB actual speed
        pub type USBSPEED_MASK_R = crate::FieldReader;
        impl R {
            ///Bits 0:1 - USB actual speed
            #[inline(always)]
            pub fn usbspeed_mask(&self) -> USBSPEED_MASK_R {
                USBSPEED_MASK_R::new(self.bits & 3)
            }
        }
        ///USB actual speed register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`usb_spd_type::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct USB_SPD_TYPE_SPEC;
        impl crate::RegisterSpec for USB_SPD_TYPE_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`usb_spd_type::R`](R) reader structure
        impl crate::Readable for USB_SPD_TYPE_SPEC {}
        ///`reset()` method sets USB_SPD_TYPE to value 0
        impl crate::Resettable for USB_SPD_TYPE_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///USB_MIS_ST (r) register accessor: USB miscellaneous status
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`usb_mis_st::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@usb_mis_st`]
    ///module
    pub type USB_MIS_ST = crate::Reg<usb_mis_st::USB_MIS_ST_SPEC>;
    ///USB miscellaneous status
    pub mod usb_mis_st {
        ///Register `USB_MIS_ST` reader
        pub type R = crate::R<USB_MIS_ST_SPEC>;
        ///Field `USB_SPLIT_EN` reader - RO,indicate host allow SPLIT packet
        pub type USB_SPLIT_EN_R = crate::BitReader;
        ///Field `USB_ATTACH` reader - RO, indicate device attached status on USB host
        pub type USB_ATTACH_R = crate::BitReader;
        ///Field `USBBUS_SUSPEND` reader - RO, indicate USB suspend status
        pub type USBBUS_SUSPEND_R = crate::BitReader;
        ///Field `USBBUS_RESET` reader - RO, indicate USB bus reset status
        pub type USBBUS_RESET_R = crate::BitReader;
        ///Field `USB_FIFO_RDY` reader - RO, indicate USB receiving FIFO ready status (not empty)
        pub type USB_FIFO_RDY_R = crate::BitReader;
        ///Field `USB_SIE_FREE` reader - RO, indicate USB SIE free status
        pub type USB_SIE_FREE_R = crate::BitReader;
        ///Field `USB_SOF_ACT` reader - RO, indicate host SOF timer action status for USB host
        pub type USB_SOF_ACT_R = crate::BitReader;
        ///Field `USB_SOF_PRES` reader - RO, indicate host SOF timer presage status
        pub type USB_SOF_PRES_R = crate::BitReader;
        impl R {
            ///Bit 0 - RO,indicate host allow SPLIT packet
            #[inline(always)]
            pub fn usb_split_en(&self) -> USB_SPLIT_EN_R {
                USB_SPLIT_EN_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RO, indicate device attached status on USB host
            #[inline(always)]
            pub fn usb_attach(&self) -> USB_ATTACH_R {
                USB_ATTACH_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RO, indicate USB suspend status
            #[inline(always)]
            pub fn usbbus_suspend(&self) -> USBBUS_SUSPEND_R {
                USBBUS_SUSPEND_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RO, indicate USB bus reset status
            #[inline(always)]
            pub fn usbbus_reset(&self) -> USBBUS_RESET_R {
                USBBUS_RESET_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RO, indicate USB receiving FIFO ready status (not empty)
            #[inline(always)]
            pub fn usb_fifo_rdy(&self) -> USB_FIFO_RDY_R {
                USB_FIFO_RDY_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - RO, indicate USB SIE free status
            #[inline(always)]
            pub fn usb_sie_free(&self) -> USB_SIE_FREE_R {
                USB_SIE_FREE_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - RO, indicate host SOF timer action status for USB host
            #[inline(always)]
            pub fn usb_sof_act(&self) -> USB_SOF_ACT_R {
                USB_SOF_ACT_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - RO, indicate host SOF timer presage status
            #[inline(always)]
            pub fn usb_sof_pres(&self) -> USB_SOF_PRES_R {
                USB_SOF_PRES_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        ///USB miscellaneous status
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`usb_mis_st::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct USB_MIS_ST_SPEC;
        impl crate::RegisterSpec for USB_MIS_ST_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`usb_mis_st::R`](R) reader structure
        impl crate::Readable for USB_MIS_ST_SPEC {}
        ///`reset()` method sets USB_MIS_ST to value 0x20
        impl crate::Resettable for USB_MIS_ST_SPEC {
            const RESET_VALUE: u8 = 0x20;
        }
    }
    ///USB_INT_FG (rw) register accessor: USB interrupt flag
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`usb_int_fg::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`usb_int_fg::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@usb_int_fg`]
    ///module
    pub type USB_INT_FG = crate::Reg<usb_int_fg::USB_INT_FG_SPEC>;
    ///USB interrupt flag
    pub mod usb_int_fg {
        ///Register `USB_INT_FG` reader
        pub type R = crate::R<USB_INT_FG_SPEC>;
        ///Register `USB_INT_FG` writer
        pub type W = crate::W<USB_INT_FG_SPEC>;
        ///Field `USB_IF_BUSRST_RB_USB_IF_DETECT` reader - bus reset event interrupt flag for USB device mode, direct bit address clear or write 1 to clear;device detected event interrupt flag for USB host mode, direct bit address clear or write 1 to clear
        pub type USB_IF_BUSRST_RB_USB_IF_DETECT_R = crate::BitReader;
        ///Field `USB_IF_BUSRST_RB_USB_IF_DETECT` writer - bus reset event interrupt flag for USB device mode, direct bit address clear or write 1 to clear;device detected event interrupt flag for USB host mode, direct bit address clear or write 1 to clear
        pub type USB_IF_BUSRST_RB_USB_IF_DETECT_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `USB_IF_TRANSFER` reader - USB transfer completion interrupt flag, direct bit address clear or write 1 to clear
        pub type USB_IF_TRANSFER_R = crate::BitReader;
        ///Field `USB_IF_TRANSFER` writer - USB transfer completion interrupt flag, direct bit address clear or write 1 to clear
        pub type USB_IF_TRANSFER_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `USB_IF_SUSPEND` reader - USB suspend or resume event interrupt flag, direct bit address clear or write 1 to clear
        pub type USB_IF_SUSPEND_R = crate::BitReader;
        ///Field `USB_IF_SUSPEND` writer - USB suspend or resume event interrupt flag, direct bit address clear or write 1 to clear
        pub type USB_IF_SUSPEND_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `USB_IF_HST_SOF` reader - host SOF timer interrupt flag for USB host, direct bit address clear or write 1 to clear
        pub type USB_IF_HST_SOF_R = crate::BitReader;
        ///Field `USB_IF_HST_SOF` writer - host SOF timer interrupt flag for USB host, direct bit address clear or write 1 to clear
        pub type USB_IF_HST_SOF_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `USB_IF_FIFOOV` reader - FIFO overflow interrupt flag for USB, direct bit address clear or write 1 to clear
        pub type USB_IF_FIFOOV_R = crate::BitReader;
        ///Field `USB_IF_FIFOOV` writer - FIFO overflow interrupt flag for USB, direct bit address clear or write 1 to clear
        pub type USB_IF_FIFOOV_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `USB_IF_SETUOACT` reader - RO, Setup transaction end interrupt flag
        pub type USB_IF_SETUOACT_R = crate::BitReader;
        ///Field `USB_IF_SETUOACT` writer - RO, Setup transaction end interrupt flag
        pub type USB_IF_SETUOACT_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `USB_IF_ISOACT` reader - RO, Synchronous transmission received control token packet interrupt flag
        pub type USB_IF_ISOACT_R = crate::BitReader;
        ///Field `USB_IF_ISOACT` writer - RO, Synchronous transmission received control token packet interrupt flag
        pub type USB_IF_ISOACT_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - bus reset event interrupt flag for USB device mode, direct bit address clear or write 1 to clear;device detected event interrupt flag for USB host mode, direct bit address clear or write 1 to clear
            #[inline(always)]
            pub fn usb_if_busrst_rb_usb_if_detect(&self) -> USB_IF_BUSRST_RB_USB_IF_DETECT_R {
                USB_IF_BUSRST_RB_USB_IF_DETECT_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - USB transfer completion interrupt flag, direct bit address clear or write 1 to clear
            #[inline(always)]
            pub fn usb_if_transfer(&self) -> USB_IF_TRANSFER_R {
                USB_IF_TRANSFER_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - USB suspend or resume event interrupt flag, direct bit address clear or write 1 to clear
            #[inline(always)]
            pub fn usb_if_suspend(&self) -> USB_IF_SUSPEND_R {
                USB_IF_SUSPEND_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - host SOF timer interrupt flag for USB host, direct bit address clear or write 1 to clear
            #[inline(always)]
            pub fn usb_if_hst_sof(&self) -> USB_IF_HST_SOF_R {
                USB_IF_HST_SOF_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - FIFO overflow interrupt flag for USB, direct bit address clear or write 1 to clear
            #[inline(always)]
            pub fn usb_if_fifoov(&self) -> USB_IF_FIFOOV_R {
                USB_IF_FIFOOV_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - RO, Setup transaction end interrupt flag
            #[inline(always)]
            pub fn usb_if_setuoact(&self) -> USB_IF_SETUOACT_R {
                USB_IF_SETUOACT_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - RO, Synchronous transmission received control token packet interrupt flag
            #[inline(always)]
            pub fn usb_if_isoact(&self) -> USB_IF_ISOACT_R {
                USB_IF_ISOACT_R::new(((self.bits >> 6) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - bus reset event interrupt flag for USB device mode, direct bit address clear or write 1 to clear;device detected event interrupt flag for USB host mode, direct bit address clear or write 1 to clear
            #[inline(always)]
            #[must_use]
            pub fn usb_if_busrst_rb_usb_if_detect(
                &mut self,
            ) -> USB_IF_BUSRST_RB_USB_IF_DETECT_W<USB_INT_FG_SPEC> {
                USB_IF_BUSRST_RB_USB_IF_DETECT_W::new(self, 0)
            }
            ///Bit 1 - USB transfer completion interrupt flag, direct bit address clear or write 1 to clear
            #[inline(always)]
            #[must_use]
            pub fn usb_if_transfer(&mut self) -> USB_IF_TRANSFER_W<USB_INT_FG_SPEC> {
                USB_IF_TRANSFER_W::new(self, 1)
            }
            ///Bit 2 - USB suspend or resume event interrupt flag, direct bit address clear or write 1 to clear
            #[inline(always)]
            #[must_use]
            pub fn usb_if_suspend(&mut self) -> USB_IF_SUSPEND_W<USB_INT_FG_SPEC> {
                USB_IF_SUSPEND_W::new(self, 2)
            }
            ///Bit 3 - host SOF timer interrupt flag for USB host, direct bit address clear or write 1 to clear
            #[inline(always)]
            #[must_use]
            pub fn usb_if_hst_sof(&mut self) -> USB_IF_HST_SOF_W<USB_INT_FG_SPEC> {
                USB_IF_HST_SOF_W::new(self, 3)
            }
            ///Bit 4 - FIFO overflow interrupt flag for USB, direct bit address clear or write 1 to clear
            #[inline(always)]
            #[must_use]
            pub fn usb_if_fifoov(&mut self) -> USB_IF_FIFOOV_W<USB_INT_FG_SPEC> {
                USB_IF_FIFOOV_W::new(self, 4)
            }
            ///Bit 5 - RO, Setup transaction end interrupt flag
            #[inline(always)]
            #[must_use]
            pub fn usb_if_setuoact(&mut self) -> USB_IF_SETUOACT_W<USB_INT_FG_SPEC> {
                USB_IF_SETUOACT_W::new(self, 5)
            }
            ///Bit 6 - RO, Synchronous transmission received control token packet interrupt flag
            #[inline(always)]
            #[must_use]
            pub fn usb_if_isoact(&mut self) -> USB_IF_ISOACT_W<USB_INT_FG_SPEC> {
                USB_IF_ISOACT_W::new(self, 6)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///USB interrupt flag
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`usb_int_fg::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`usb_int_fg::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct USB_INT_FG_SPEC;
        impl crate::RegisterSpec for USB_INT_FG_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`usb_int_fg::R`](R) reader structure
        impl crate::Readable for USB_INT_FG_SPEC {}
        ///`write(|w| ..)` method takes [`usb_int_fg::W`](W) writer structure
        impl crate::Writable for USB_INT_FG_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets USB_INT_FG to value 0
        impl crate::Resettable for USB_INT_FG_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///USB_INT_ST (r) register accessor: USB interrupt status
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`usb_int_st::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@usb_int_st`]
    ///module
    pub type USB_INT_ST = crate::Reg<usb_int_st::USB_INT_ST_SPEC>;
    ///USB interrupt status
    pub mod usb_int_st {
        ///Register `USB_INT_ST` reader
        pub type R = crate::R<USB_INT_ST_SPEC>;
        ///Field `HOST_RES_MASK_RB_DEV_ENDP_MASK` reader - RO, bit mask of current transfer handshake response for USB host mode: 0000=no response, time out from device, others=handshake response PID received;RO, bit mask of current transfer endpoint number for USB device mode
        pub type HOST_RES_MASK_RB_DEV_ENDP_MASK_R = crate::FieldReader;
        ///Field `DEV_TOKEN_MASK` reader - RO, bit mask of current token PID code received for USB device mode
        pub type DEV_TOKEN_MASK_R = crate::FieldReader;
        ///Field `USB_ST_TOGOK` reader - RO, indicate current USB transfer toggle is OK
        pub type USB_ST_TOGOK_R = crate::BitReader;
        ///Field `USB_ST_NAK` reader - RO, indicate current USB transfer is NAK received for USB device mode
        pub type USB_ST_NAK_R = crate::BitReader;
        impl R {
            ///Bits 0:3 - RO, bit mask of current transfer handshake response for USB host mode: 0000=no response, time out from device, others=handshake response PID received;RO, bit mask of current transfer endpoint number for USB device mode
            #[inline(always)]
            pub fn host_res_mask_rb_dev_endp_mask(&self) -> HOST_RES_MASK_RB_DEV_ENDP_MASK_R {
                HOST_RES_MASK_RB_DEV_ENDP_MASK_R::new(self.bits & 0x0f)
            }
            ///Bits 4:5 - RO, bit mask of current token PID code received for USB device mode
            #[inline(always)]
            pub fn dev_token_mask(&self) -> DEV_TOKEN_MASK_R {
                DEV_TOKEN_MASK_R::new((self.bits >> 4) & 3)
            }
            ///Bit 6 - RO, indicate current USB transfer toggle is OK
            #[inline(always)]
            pub fn usb_st_togok(&self) -> USB_ST_TOGOK_R {
                USB_ST_TOGOK_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - RO, indicate current USB transfer is NAK received for USB device mode
            #[inline(always)]
            pub fn usb_st_nak(&self) -> USB_ST_NAK_R {
                USB_ST_NAK_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        ///USB interrupt status
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`usb_int_st::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct USB_INT_ST_SPEC;
        impl crate::RegisterSpec for USB_INT_ST_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`usb_int_st::R`](R) reader structure
        impl crate::Readable for USB_INT_ST_SPEC {}
        ///`reset()` method sets USB_INT_ST to value 0
        impl crate::Resettable for USB_INT_ST_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///R6_USB_RX_LEN (r) register accessor: USB receiving length
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`r6_usb_rx_len::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@r6_usb_rx_len`]
    ///module
    pub type R6_USB_RX_LEN = crate::Reg<r6_usb_rx_len::R6_USB_RX_LEN_SPEC>;
    ///USB receiving length
    pub mod r6_usb_rx_len {
        ///Register `R6_USB_RX_LEN` reader
        pub type R = crate::R<R6_USB_RX_LEN_SPEC>;
        ///Field `USB_RX_LEN` reader - length of received bytes
        pub type USB_RX_LEN_R = crate::FieldReader<u16>;
        impl R {
            ///Bits 0:15 - length of received bytes
            #[inline(always)]
            pub fn usb_rx_len(&self) -> USB_RX_LEN_R {
                USB_RX_LEN_R::new(self.bits)
            }
        }
        ///USB receiving length
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`r6_usb_rx_len::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct R6_USB_RX_LEN_SPEC;
        impl crate::RegisterSpec for R6_USB_RX_LEN_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`r6_usb_rx_len::R`](R) reader structure
        impl crate::Readable for R6_USB_RX_LEN_SPEC {}
        ///`reset()` method sets R6_USB_RX_LEN to value 0
        impl crate::Resettable for R6_USB_RX_LEN_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///UEP4_1_MOD (rw) register accessor: endpoint 1(9) 4(8,12) mode
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`uep4_1_mod::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep4_1_mod::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@uep4_1_mod`]
    ///module
    pub type UEP4_1_MOD = crate::Reg<uep4_1_mod::UEP4_1_MOD_SPEC>;
    ///endpoint 1(9) 4(8,12) mode
    pub mod uep4_1_mod {
        ///Register `UEP4_1_MOD` reader
        pub type R = crate::R<UEP4_1_MOD_SPEC>;
        ///Register `UEP4_1_MOD` writer
        pub type W = crate::W<UEP4_1_MOD_SPEC>;
        ///Field `UEP4_BUF_MOD` reader - buffer mode of USB endpoint 4(8,12)
        pub type UEP4_BUF_MOD_R = crate::BitReader;
        ///Field `UEP4_BUF_MOD` writer - buffer mode of USB endpoint 4(8,12)
        pub type UEP4_BUF_MOD_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UEP4_TX_EN` reader - enable USB endpoint 4(8,12) transmittal (IN)
        pub type UEP4_TX_EN_R = crate::BitReader;
        ///Field `UEP4_TX_EN` writer - enable USB endpoint 4(8,12) transmittal (IN)
        pub type UEP4_TX_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UEP4_RX_EN` reader - enable USB endpoint 4(8,12) receiving (OUT)
        pub type UEP4_RX_EN_R = crate::BitReader;
        ///Field `UEP4_RX_EN` writer - enable USB endpoint 4(8,12) receiving (OUT)
        pub type UEP4_RX_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UEP1_BUF_MOD` reader - buffer mode of USB endpoint 1(9)
        pub type UEP1_BUF_MOD_R = crate::BitReader;
        ///Field `UEP1_BUF_MOD` writer - buffer mode of USB endpoint 1(9)
        pub type UEP1_BUF_MOD_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UEP1_TX_EN` reader - enable USB endpoint 1(9) transmittal (IN)
        pub type UEP1_TX_EN_R = crate::BitReader;
        ///Field `UEP1_TX_EN` writer - enable USB endpoint 1(9) transmittal (IN)
        pub type UEP1_TX_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UEP1_RX_EN` reader - enable USB endpoint 1(9) receiving (OUT)
        pub type UEP1_RX_EN_R = crate::BitReader;
        ///Field `UEP1_RX_EN` writer - enable USB endpoint 1(9) receiving (OUT)
        pub type UEP1_RX_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - buffer mode of USB endpoint 4(8,12)
            #[inline(always)]
            pub fn uep4_buf_mod(&self) -> UEP4_BUF_MOD_R {
                UEP4_BUF_MOD_R::new((self.bits & 1) != 0)
            }
            ///Bit 2 - enable USB endpoint 4(8,12) transmittal (IN)
            #[inline(always)]
            pub fn uep4_tx_en(&self) -> UEP4_TX_EN_R {
                UEP4_TX_EN_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - enable USB endpoint 4(8,12) receiving (OUT)
            #[inline(always)]
            pub fn uep4_rx_en(&self) -> UEP4_RX_EN_R {
                UEP4_RX_EN_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - buffer mode of USB endpoint 1(9)
            #[inline(always)]
            pub fn uep1_buf_mod(&self) -> UEP1_BUF_MOD_R {
                UEP1_BUF_MOD_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 6 - enable USB endpoint 1(9) transmittal (IN)
            #[inline(always)]
            pub fn uep1_tx_en(&self) -> UEP1_TX_EN_R {
                UEP1_TX_EN_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - enable USB endpoint 1(9) receiving (OUT)
            #[inline(always)]
            pub fn uep1_rx_en(&self) -> UEP1_RX_EN_R {
                UEP1_RX_EN_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - buffer mode of USB endpoint 4(8,12)
            #[inline(always)]
            #[must_use]
            pub fn uep4_buf_mod(&mut self) -> UEP4_BUF_MOD_W<UEP4_1_MOD_SPEC> {
                UEP4_BUF_MOD_W::new(self, 0)
            }
            ///Bit 2 - enable USB endpoint 4(8,12) transmittal (IN)
            #[inline(always)]
            #[must_use]
            pub fn uep4_tx_en(&mut self) -> UEP4_TX_EN_W<UEP4_1_MOD_SPEC> {
                UEP4_TX_EN_W::new(self, 2)
            }
            ///Bit 3 - enable USB endpoint 4(8,12) receiving (OUT)
            #[inline(always)]
            #[must_use]
            pub fn uep4_rx_en(&mut self) -> UEP4_RX_EN_W<UEP4_1_MOD_SPEC> {
                UEP4_RX_EN_W::new(self, 3)
            }
            ///Bit 4 - buffer mode of USB endpoint 1(9)
            #[inline(always)]
            #[must_use]
            pub fn uep1_buf_mod(&mut self) -> UEP1_BUF_MOD_W<UEP4_1_MOD_SPEC> {
                UEP1_BUF_MOD_W::new(self, 4)
            }
            ///Bit 6 - enable USB endpoint 1(9) transmittal (IN)
            #[inline(always)]
            #[must_use]
            pub fn uep1_tx_en(&mut self) -> UEP1_TX_EN_W<UEP4_1_MOD_SPEC> {
                UEP1_TX_EN_W::new(self, 6)
            }
            ///Bit 7 - enable USB endpoint 1(9) receiving (OUT)
            #[inline(always)]
            #[must_use]
            pub fn uep1_rx_en(&mut self) -> UEP1_RX_EN_W<UEP4_1_MOD_SPEC> {
                UEP1_RX_EN_W::new(self, 7)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///endpoint 1(9) 4(8,12) mode
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`uep4_1_mod::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep4_1_mod::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct UEP4_1_MOD_SPEC;
        impl crate::RegisterSpec for UEP4_1_MOD_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`uep4_1_mod::R`](R) reader structure
        impl crate::Readable for UEP4_1_MOD_SPEC {}
        ///`write(|w| ..)` method takes [`uep4_1_mod::W`](W) writer structure
        impl crate::Writable for UEP4_1_MOD_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets UEP4_1_MOD to value 0
        impl crate::Resettable for UEP4_1_MOD_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///UEP2_3_MOD_R8_UH_EP_MOD (rw) register accessor: endpoint 2(10) 3(11) mode and USB host endpoint mode control register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`uep2_3_mod_r8_uh_ep_mod::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep2_3_mod_r8_uh_ep_mod::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@uep2_3_mod_r8_uh_ep_mod`]
    ///module
    pub type UEP2_3_MOD_R8_UH_EP_MOD =
        crate::Reg<uep2_3_mod_r8_uh_ep_mod::UEP2_3_MOD_R8_UH_EP_MOD_SPEC>;
    ///endpoint 2(10) 3(11) mode and USB host endpoint mode control register
    pub mod uep2_3_mod_r8_uh_ep_mod {
        ///Register `UEP2_3_MOD_R8_UH_EP_MOD` reader
        pub type R = crate::R<UEP2_3_MOD_R8_UH_EP_MOD_SPEC>;
        ///Register `UEP2_3_MOD_R8_UH_EP_MOD` writer
        pub type W = crate::W<UEP2_3_MOD_R8_UH_EP_MOD_SPEC>;
        ///Field `UEP2_BUF_MOD_RB_UH_RX_EN` reader - buffer mode of USB endpoint 2(10) and USB host receive endpoint (IN) enable
        pub type UEP2_BUF_MOD_RB_UH_RX_EN_R = crate::BitReader;
        ///Field `UEP2_BUF_MOD_RB_UH_RX_EN` writer - buffer mode of USB endpoint 2(10) and USB host receive endpoint (IN) enable
        pub type UEP2_BUF_MOD_RB_UH_RX_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UEP2_TX_EN` reader - enable USB endpoint 2(10) transmittal (IN)
        pub type UEP2_TX_EN_R = crate::BitReader;
        ///Field `UEP2_TX_EN` writer - enable USB endpoint 2(10) transmittal (IN)
        pub type UEP2_TX_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UEP2_RX_EN` reader - enable USB endpoint 2(10) receiving (OUT)
        pub type UEP2_RX_EN_R = crate::BitReader;
        ///Field `UEP2_RX_EN` writer - enable USB endpoint 2(10) receiving (OUT)
        pub type UEP2_RX_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UEP3_BUF_MOD` reader - buffer mode of USB endpoint 3(11)
        pub type UEP3_BUF_MOD_R = crate::BitReader;
        ///Field `UEP3_BUF_MOD` writer - buffer mode of USB endpoint 3(11)
        pub type UEP3_BUF_MOD_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UEP3_TX_EN_RB_UH_TX_EN` reader - enable USB endpoint 3(11) transmittal (IN) and USB host send endpoint (SETUP/OUT) enable
        pub type UEP3_TX_EN_RB_UH_TX_EN_R = crate::BitReader;
        ///Field `UEP3_TX_EN_RB_UH_TX_EN` writer - enable USB endpoint 3(11) transmittal (IN) and USB host send endpoint (SETUP/OUT) enable
        pub type UEP3_TX_EN_RB_UH_TX_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UEP3_RX_EN` reader - enable USB endpoint 3(11) receiving (OUT)
        pub type UEP3_RX_EN_R = crate::BitReader;
        ///Field `UEP3_RX_EN` writer - enable USB endpoint 3(11) receiving (OUT)
        pub type UEP3_RX_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - buffer mode of USB endpoint 2(10) and USB host receive endpoint (IN) enable
            #[inline(always)]
            pub fn uep2_buf_mod_rb_uh_rx_en(&self) -> UEP2_BUF_MOD_RB_UH_RX_EN_R {
                UEP2_BUF_MOD_RB_UH_RX_EN_R::new((self.bits & 1) != 0)
            }
            ///Bit 2 - enable USB endpoint 2(10) transmittal (IN)
            #[inline(always)]
            pub fn uep2_tx_en(&self) -> UEP2_TX_EN_R {
                UEP2_TX_EN_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - enable USB endpoint 2(10) receiving (OUT)
            #[inline(always)]
            pub fn uep2_rx_en(&self) -> UEP2_RX_EN_R {
                UEP2_RX_EN_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - buffer mode of USB endpoint 3(11)
            #[inline(always)]
            pub fn uep3_buf_mod(&self) -> UEP3_BUF_MOD_R {
                UEP3_BUF_MOD_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 6 - enable USB endpoint 3(11) transmittal (IN) and USB host send endpoint (SETUP/OUT) enable
            #[inline(always)]
            pub fn uep3_tx_en_rb_uh_tx_en(&self) -> UEP3_TX_EN_RB_UH_TX_EN_R {
                UEP3_TX_EN_RB_UH_TX_EN_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - enable USB endpoint 3(11) receiving (OUT)
            #[inline(always)]
            pub fn uep3_rx_en(&self) -> UEP3_RX_EN_R {
                UEP3_RX_EN_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - buffer mode of USB endpoint 2(10) and USB host receive endpoint (IN) enable
            #[inline(always)]
            #[must_use]
            pub fn uep2_buf_mod_rb_uh_rx_en(
                &mut self,
            ) -> UEP2_BUF_MOD_RB_UH_RX_EN_W<UEP2_3_MOD_R8_UH_EP_MOD_SPEC> {
                UEP2_BUF_MOD_RB_UH_RX_EN_W::new(self, 0)
            }
            ///Bit 2 - enable USB endpoint 2(10) transmittal (IN)
            #[inline(always)]
            #[must_use]
            pub fn uep2_tx_en(&mut self) -> UEP2_TX_EN_W<UEP2_3_MOD_R8_UH_EP_MOD_SPEC> {
                UEP2_TX_EN_W::new(self, 2)
            }
            ///Bit 3 - enable USB endpoint 2(10) receiving (OUT)
            #[inline(always)]
            #[must_use]
            pub fn uep2_rx_en(&mut self) -> UEP2_RX_EN_W<UEP2_3_MOD_R8_UH_EP_MOD_SPEC> {
                UEP2_RX_EN_W::new(self, 3)
            }
            ///Bit 4 - buffer mode of USB endpoint 3(11)
            #[inline(always)]
            #[must_use]
            pub fn uep3_buf_mod(&mut self) -> UEP3_BUF_MOD_W<UEP2_3_MOD_R8_UH_EP_MOD_SPEC> {
                UEP3_BUF_MOD_W::new(self, 4)
            }
            ///Bit 6 - enable USB endpoint 3(11) transmittal (IN) and USB host send endpoint (SETUP/OUT) enable
            #[inline(always)]
            #[must_use]
            pub fn uep3_tx_en_rb_uh_tx_en(
                &mut self,
            ) -> UEP3_TX_EN_RB_UH_TX_EN_W<UEP2_3_MOD_R8_UH_EP_MOD_SPEC> {
                UEP3_TX_EN_RB_UH_TX_EN_W::new(self, 6)
            }
            ///Bit 7 - enable USB endpoint 3(11) receiving (OUT)
            #[inline(always)]
            #[must_use]
            pub fn uep3_rx_en(&mut self) -> UEP3_RX_EN_W<UEP2_3_MOD_R8_UH_EP_MOD_SPEC> {
                UEP3_RX_EN_W::new(self, 7)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///endpoint 2(10) 3(11) mode and USB host endpoint mode control register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`uep2_3_mod_r8_uh_ep_mod::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep2_3_mod_r8_uh_ep_mod::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct UEP2_3_MOD_R8_UH_EP_MOD_SPEC;
        impl crate::RegisterSpec for UEP2_3_MOD_R8_UH_EP_MOD_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`uep2_3_mod_r8_uh_ep_mod::R`](R) reader structure
        impl crate::Readable for UEP2_3_MOD_R8_UH_EP_MOD_SPEC {}
        ///`write(|w| ..)` method takes [`uep2_3_mod_r8_uh_ep_mod::W`](W) writer structure
        impl crate::Writable for UEP2_3_MOD_R8_UH_EP_MOD_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets UEP2_3_MOD_R8_UH_EP_MOD to value 0
        impl crate::Resettable for UEP2_3_MOD_R8_UH_EP_MOD_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///UEP5_6_MOD (rw) register accessor: endpoint 5(13) 6(14) mode
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`uep5_6_mod::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep5_6_mod::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@uep5_6_mod`]
    ///module
    pub type UEP5_6_MOD = crate::Reg<uep5_6_mod::UEP5_6_MOD_SPEC>;
    ///endpoint 5(13) 6(14) mode
    pub mod uep5_6_mod {
        ///Register `UEP5_6_MOD` reader
        pub type R = crate::R<UEP5_6_MOD_SPEC>;
        ///Register `UEP5_6_MOD` writer
        pub type W = crate::W<UEP5_6_MOD_SPEC>;
        ///Field `UEP5_BUF_MOD` reader - buffer mode of USB endpoint 5(13)
        pub type UEP5_BUF_MOD_R = crate::BitReader;
        ///Field `UEP5_BUF_MOD` writer - buffer mode of USB endpoint 5(13)
        pub type UEP5_BUF_MOD_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UEP5_TX_EN` reader - enable USB endpoint 5(13) transmittal (IN)
        pub type UEP5_TX_EN_R = crate::BitReader;
        ///Field `UEP5_TX_EN` writer - enable USB endpoint 5(13) transmittal (IN)
        pub type UEP5_TX_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UEP5_RX_EN` reader - enable USB endpoint 5(13) receiving (OUT)
        pub type UEP5_RX_EN_R = crate::BitReader;
        ///Field `UEP5_RX_EN` writer - enable USB endpoint 5(13) receiving (OUT)
        pub type UEP5_RX_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UEP6_BUF_MOD` reader - buffer mode of USB endpoint 6(14)
        pub type UEP6_BUF_MOD_R = crate::BitReader;
        ///Field `UEP6_BUF_MOD` writer - buffer mode of USB endpoint 6(14)
        pub type UEP6_BUF_MOD_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UEP6_TX_EN` reader - enable USB endpoint 6(14) transmittal (IN)
        pub type UEP6_TX_EN_R = crate::BitReader;
        ///Field `UEP6_TX_EN` writer - enable USB endpoint 6(14) transmittal (IN)
        pub type UEP6_TX_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UEP6_RX_EN` reader - enable USB endpoint 6(14) receiving (OUT)
        pub type UEP6_RX_EN_R = crate::BitReader;
        ///Field `UEP6_RX_EN` writer - enable USB endpoint 6(14) receiving (OUT)
        pub type UEP6_RX_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - buffer mode of USB endpoint 5(13)
            #[inline(always)]
            pub fn uep5_buf_mod(&self) -> UEP5_BUF_MOD_R {
                UEP5_BUF_MOD_R::new((self.bits & 1) != 0)
            }
            ///Bit 2 - enable USB endpoint 5(13) transmittal (IN)
            #[inline(always)]
            pub fn uep5_tx_en(&self) -> UEP5_TX_EN_R {
                UEP5_TX_EN_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - enable USB endpoint 5(13) receiving (OUT)
            #[inline(always)]
            pub fn uep5_rx_en(&self) -> UEP5_RX_EN_R {
                UEP5_RX_EN_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - buffer mode of USB endpoint 6(14)
            #[inline(always)]
            pub fn uep6_buf_mod(&self) -> UEP6_BUF_MOD_R {
                UEP6_BUF_MOD_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 6 - enable USB endpoint 6(14) transmittal (IN)
            #[inline(always)]
            pub fn uep6_tx_en(&self) -> UEP6_TX_EN_R {
                UEP6_TX_EN_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - enable USB endpoint 6(14) receiving (OUT)
            #[inline(always)]
            pub fn uep6_rx_en(&self) -> UEP6_RX_EN_R {
                UEP6_RX_EN_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - buffer mode of USB endpoint 5(13)
            #[inline(always)]
            #[must_use]
            pub fn uep5_buf_mod(&mut self) -> UEP5_BUF_MOD_W<UEP5_6_MOD_SPEC> {
                UEP5_BUF_MOD_W::new(self, 0)
            }
            ///Bit 2 - enable USB endpoint 5(13) transmittal (IN)
            #[inline(always)]
            #[must_use]
            pub fn uep5_tx_en(&mut self) -> UEP5_TX_EN_W<UEP5_6_MOD_SPEC> {
                UEP5_TX_EN_W::new(self, 2)
            }
            ///Bit 3 - enable USB endpoint 5(13) receiving (OUT)
            #[inline(always)]
            #[must_use]
            pub fn uep5_rx_en(&mut self) -> UEP5_RX_EN_W<UEP5_6_MOD_SPEC> {
                UEP5_RX_EN_W::new(self, 3)
            }
            ///Bit 4 - buffer mode of USB endpoint 6(14)
            #[inline(always)]
            #[must_use]
            pub fn uep6_buf_mod(&mut self) -> UEP6_BUF_MOD_W<UEP5_6_MOD_SPEC> {
                UEP6_BUF_MOD_W::new(self, 4)
            }
            ///Bit 6 - enable USB endpoint 6(14) transmittal (IN)
            #[inline(always)]
            #[must_use]
            pub fn uep6_tx_en(&mut self) -> UEP6_TX_EN_W<UEP5_6_MOD_SPEC> {
                UEP6_TX_EN_W::new(self, 6)
            }
            ///Bit 7 - enable USB endpoint 6(14) receiving (OUT)
            #[inline(always)]
            #[must_use]
            pub fn uep6_rx_en(&mut self) -> UEP6_RX_EN_W<UEP5_6_MOD_SPEC> {
                UEP6_RX_EN_W::new(self, 7)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///endpoint 5(13) 6(14) mode
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`uep5_6_mod::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep5_6_mod::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct UEP5_6_MOD_SPEC;
        impl crate::RegisterSpec for UEP5_6_MOD_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`uep5_6_mod::R`](R) reader structure
        impl crate::Readable for UEP5_6_MOD_SPEC {}
        ///`write(|w| ..)` method takes [`uep5_6_mod::W`](W) writer structure
        impl crate::Writable for UEP5_6_MOD_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets UEP5_6_MOD to value 0
        impl crate::Resettable for UEP5_6_MOD_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///UEP7_MOD (rw) register accessor: endpoint 7(15) mode
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`uep7_mod::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep7_mod::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@uep7_mod`]
    ///module
    pub type UEP7_MOD = crate::Reg<uep7_mod::UEP7_MOD_SPEC>;
    ///endpoint 7(15) mode
    pub mod uep7_mod {
        ///Register `UEP7_MOD` reader
        pub type R = crate::R<UEP7_MOD_SPEC>;
        ///Register `UEP7_MOD` writer
        pub type W = crate::W<UEP7_MOD_SPEC>;
        ///Field `UEP7_BUF_MOD` reader - buffer mode of USB endpoint 7(15)
        pub type UEP7_BUF_MOD_R = crate::BitReader;
        ///Field `UEP7_BUF_MOD` writer - buffer mode of USB endpoint 7(15)
        pub type UEP7_BUF_MOD_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UEP7_TX_EN` reader - enable USB endpoint 7(15) transmittal (IN)
        pub type UEP7_TX_EN_R = crate::BitReader;
        ///Field `UEP7_TX_EN` writer - enable USB endpoint 7(15) transmittal (IN)
        pub type UEP7_TX_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UEP7_RX_EN` reader - enable USB endpoint 7(15) receiving (OUT)
        pub type UEP7_RX_EN_R = crate::BitReader;
        ///Field `UEP7_RX_EN` writer - enable USB endpoint 7(15) receiving (OUT)
        pub type UEP7_RX_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - buffer mode of USB endpoint 7(15)
            #[inline(always)]
            pub fn uep7_buf_mod(&self) -> UEP7_BUF_MOD_R {
                UEP7_BUF_MOD_R::new((self.bits & 1) != 0)
            }
            ///Bit 2 - enable USB endpoint 7(15) transmittal (IN)
            #[inline(always)]
            pub fn uep7_tx_en(&self) -> UEP7_TX_EN_R {
                UEP7_TX_EN_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - enable USB endpoint 7(15) receiving (OUT)
            #[inline(always)]
            pub fn uep7_rx_en(&self) -> UEP7_RX_EN_R {
                UEP7_RX_EN_R::new(((self.bits >> 3) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - buffer mode of USB endpoint 7(15)
            #[inline(always)]
            #[must_use]
            pub fn uep7_buf_mod(&mut self) -> UEP7_BUF_MOD_W<UEP7_MOD_SPEC> {
                UEP7_BUF_MOD_W::new(self, 0)
            }
            ///Bit 2 - enable USB endpoint 7(15) transmittal (IN)
            #[inline(always)]
            #[must_use]
            pub fn uep7_tx_en(&mut self) -> UEP7_TX_EN_W<UEP7_MOD_SPEC> {
                UEP7_TX_EN_W::new(self, 2)
            }
            ///Bit 3 - enable USB endpoint 7(15) receiving (OUT)
            #[inline(always)]
            #[must_use]
            pub fn uep7_rx_en(&mut self) -> UEP7_RX_EN_W<UEP7_MOD_SPEC> {
                UEP7_RX_EN_W::new(self, 3)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///endpoint 7(15) mode
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`uep7_mod::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep7_mod::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct UEP7_MOD_SPEC;
        impl crate::RegisterSpec for UEP7_MOD_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`uep7_mod::R`](R) reader structure
        impl crate::Readable for UEP7_MOD_SPEC {}
        ///`write(|w| ..)` method takes [`uep7_mod::W`](W) writer structure
        impl crate::Writable for UEP7_MOD_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets UEP7_MOD to value 0
        impl crate::Resettable for UEP7_MOD_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///UEP0_RT_DMA (rw) register accessor: endpoint 0 DMA buffer address
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`uep0_rt_dma::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep0_rt_dma::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@uep0_rt_dma`]
    ///module
    pub type UEP0_RT_DMA = crate::Reg<uep0_rt_dma::UEP0_RT_DMA_SPEC>;
    ///endpoint 0 DMA buffer address
    pub mod uep0_rt_dma {
        ///Register `UEP0_RT_DMA` reader
        pub type R = crate::R<UEP0_RT_DMA_SPEC>;
        ///Register `UEP0_RT_DMA` writer
        pub type W = crate::W<UEP0_RT_DMA_SPEC>;
        ///Field `UEP0_RT_DMA` reader - endpoint 0 DMA buffer address
        pub type UEP0_RT_DMA_R = crate::FieldReader<u32>;
        ///Field `UEP0_RT_DMA` writer - endpoint 0 DMA buffer address
        pub type UEP0_RT_DMA_W<'a, REG> = crate::FieldWriter<'a, REG, 17, u32>;
        impl R {
            ///Bits 0:16 - endpoint 0 DMA buffer address
            #[inline(always)]
            pub fn uep0_rt_dma(&self) -> UEP0_RT_DMA_R {
                UEP0_RT_DMA_R::new(self.bits & 0x0001_ffff)
            }
        }
        impl W {
            ///Bits 0:16 - endpoint 0 DMA buffer address
            #[inline(always)]
            #[must_use]
            pub fn uep0_rt_dma(&mut self) -> UEP0_RT_DMA_W<UEP0_RT_DMA_SPEC> {
                UEP0_RT_DMA_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///endpoint 0 DMA buffer address
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`uep0_rt_dma::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep0_rt_dma::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct UEP0_RT_DMA_SPEC;
        impl crate::RegisterSpec for UEP0_RT_DMA_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`uep0_rt_dma::R`](R) reader structure
        impl crate::Readable for UEP0_RT_DMA_SPEC {}
        ///`write(|w| ..)` method takes [`uep0_rt_dma::W`](W) writer structure
        impl crate::Writable for UEP0_RT_DMA_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets UEP0_RT_DMA to value 0
        impl crate::Resettable for UEP0_RT_DMA_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///UEP1_RX_DMA (rw) register accessor: endpoint 1 DMA buffer address
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`uep1_rx_dma::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep1_rx_dma::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@uep1_rx_dma`]
    ///module
    pub type UEP1_RX_DMA = crate::Reg<uep1_rx_dma::UEP1_RX_DMA_SPEC>;
    ///endpoint 1 DMA buffer address
    pub mod uep1_rx_dma {
        ///Register `UEP1_RX_DMA` reader
        pub type R = crate::R<UEP1_RX_DMA_SPEC>;
        ///Register `UEP1_RX_DMA` writer
        pub type W = crate::W<UEP1_RX_DMA_SPEC>;
        ///Field `UEP1_RX_DMA` reader - endpoint 1 DMA buffer address
        pub type UEP1_RX_DMA_R = crate::FieldReader<u32>;
        ///Field `UEP1_RX_DMA` writer - endpoint 1 DMA buffer address
        pub type UEP1_RX_DMA_W<'a, REG> = crate::FieldWriter<'a, REG, 17, u32>;
        impl R {
            ///Bits 0:16 - endpoint 1 DMA buffer address
            #[inline(always)]
            pub fn uep1_rx_dma(&self) -> UEP1_RX_DMA_R {
                UEP1_RX_DMA_R::new(self.bits & 0x0001_ffff)
            }
        }
        impl W {
            ///Bits 0:16 - endpoint 1 DMA buffer address
            #[inline(always)]
            #[must_use]
            pub fn uep1_rx_dma(&mut self) -> UEP1_RX_DMA_W<UEP1_RX_DMA_SPEC> {
                UEP1_RX_DMA_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///endpoint 1 DMA buffer address
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`uep1_rx_dma::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep1_rx_dma::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct UEP1_RX_DMA_SPEC;
        impl crate::RegisterSpec for UEP1_RX_DMA_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`uep1_rx_dma::R`](R) reader structure
        impl crate::Readable for UEP1_RX_DMA_SPEC {}
        ///`write(|w| ..)` method takes [`uep1_rx_dma::W`](W) writer structure
        impl crate::Writable for UEP1_RX_DMA_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets UEP1_RX_DMA to value 0
        impl crate::Resettable for UEP1_RX_DMA_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///UEP2_RX_DMA_R32_UH_RX_DMA (rw) register accessor: endpoint 2 DMA buffer address _ host rx endpoint buffer start address
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`uep2_rx_dma_r32_uh_rx_dma::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep2_rx_dma_r32_uh_rx_dma::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@uep2_rx_dma_r32_uh_rx_dma`]
    ///module
    pub type UEP2_RX_DMA_R32_UH_RX_DMA =
        crate::Reg<uep2_rx_dma_r32_uh_rx_dma::UEP2_RX_DMA_R32_UH_RX_DMA_SPEC>;
    ///endpoint 2 DMA buffer address _ host rx endpoint buffer start address
    pub mod uep2_rx_dma_r32_uh_rx_dma {
        ///Register `UEP2_RX_DMA_R32_UH_RX_DMA` reader
        pub type R = crate::R<UEP2_RX_DMA_R32_UH_RX_DMA_SPEC>;
        ///Register `UEP2_RX_DMA_R32_UH_RX_DMA` writer
        pub type W = crate::W<UEP2_RX_DMA_R32_UH_RX_DMA_SPEC>;
        ///Field `UEP2_RX_DMA_UH_RX_DMA` reader - endpoint 2 DMA buffer address _ host rx endpoint buffer start address
        pub type UEP2_RX_DMA_UH_RX_DMA_R = crate::FieldReader<u32>;
        ///Field `UEP2_RX_DMA_UH_RX_DMA` writer - endpoint 2 DMA buffer address _ host rx endpoint buffer start address
        pub type UEP2_RX_DMA_UH_RX_DMA_W<'a, REG> = crate::FieldWriter<'a, REG, 17, u32>;
        impl R {
            ///Bits 0:16 - endpoint 2 DMA buffer address _ host rx endpoint buffer start address
            #[inline(always)]
            pub fn uep2_rx_dma_uh_rx_dma(&self) -> UEP2_RX_DMA_UH_RX_DMA_R {
                UEP2_RX_DMA_UH_RX_DMA_R::new(self.bits & 0x0001_ffff)
            }
        }
        impl W {
            ///Bits 0:16 - endpoint 2 DMA buffer address _ host rx endpoint buffer start address
            #[inline(always)]
            #[must_use]
            pub fn uep2_rx_dma_uh_rx_dma(
                &mut self,
            ) -> UEP2_RX_DMA_UH_RX_DMA_W<UEP2_RX_DMA_R32_UH_RX_DMA_SPEC> {
                UEP2_RX_DMA_UH_RX_DMA_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///endpoint 2 DMA buffer address _ host rx endpoint buffer start address
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`uep2_rx_dma_r32_uh_rx_dma::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep2_rx_dma_r32_uh_rx_dma::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct UEP2_RX_DMA_R32_UH_RX_DMA_SPEC;
        impl crate::RegisterSpec for UEP2_RX_DMA_R32_UH_RX_DMA_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`uep2_rx_dma_r32_uh_rx_dma::R`](R) reader structure
        impl crate::Readable for UEP2_RX_DMA_R32_UH_RX_DMA_SPEC {}
        ///`write(|w| ..)` method takes [`uep2_rx_dma_r32_uh_rx_dma::W`](W) writer structure
        impl crate::Writable for UEP2_RX_DMA_R32_UH_RX_DMA_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets UEP2_RX_DMA_R32_UH_RX_DMA to value 0
        impl crate::Resettable for UEP2_RX_DMA_R32_UH_RX_DMA_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///UEP3_RX_DMA (rw) register accessor: endpoint 3 DMA buffer address;host tx endpoint buffer high address
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`uep3_rx_dma::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep3_rx_dma::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@uep3_rx_dma`]
    ///module
    pub type UEP3_RX_DMA = crate::Reg<uep3_rx_dma::UEP3_RX_DMA_SPEC>;
    ///endpoint 3 DMA buffer address;host tx endpoint buffer high address
    pub mod uep3_rx_dma {
        ///Register `UEP3_RX_DMA` reader
        pub type R = crate::R<UEP3_RX_DMA_SPEC>;
        ///Register `UEP3_RX_DMA` writer
        pub type W = crate::W<UEP3_RX_DMA_SPEC>;
        ///Field `UEP3_RX_DMA` reader - endpoint 3 DMA buffer address
        pub type UEP3_RX_DMA_R = crate::FieldReader<u32>;
        ///Field `UEP3_RX_DMA` writer - endpoint 3 DMA buffer address
        pub type UEP3_RX_DMA_W<'a, REG> = crate::FieldWriter<'a, REG, 17, u32>;
        impl R {
            ///Bits 0:16 - endpoint 3 DMA buffer address
            #[inline(always)]
            pub fn uep3_rx_dma(&self) -> UEP3_RX_DMA_R {
                UEP3_RX_DMA_R::new(self.bits & 0x0001_ffff)
            }
        }
        impl W {
            ///Bits 0:16 - endpoint 3 DMA buffer address
            #[inline(always)]
            #[must_use]
            pub fn uep3_rx_dma(&mut self) -> UEP3_RX_DMA_W<UEP3_RX_DMA_SPEC> {
                UEP3_RX_DMA_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///endpoint 3 DMA buffer address;host tx endpoint buffer high address
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`uep3_rx_dma::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep3_rx_dma::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct UEP3_RX_DMA_SPEC;
        impl crate::RegisterSpec for UEP3_RX_DMA_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`uep3_rx_dma::R`](R) reader structure
        impl crate::Readable for UEP3_RX_DMA_SPEC {}
        ///`write(|w| ..)` method takes [`uep3_rx_dma::W`](W) writer structure
        impl crate::Writable for UEP3_RX_DMA_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets UEP3_RX_DMA to value 0
        impl crate::Resettable for UEP3_RX_DMA_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///UEP4_RX_DMA (rw) register accessor: endpoint 4 DMA buffer address
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`uep4_rx_dma::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep4_rx_dma::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@uep4_rx_dma`]
    ///module
    pub type UEP4_RX_DMA = crate::Reg<uep4_rx_dma::UEP4_RX_DMA_SPEC>;
    ///endpoint 4 DMA buffer address
    pub mod uep4_rx_dma {
        ///Register `UEP4_RX_DMA` reader
        pub type R = crate::R<UEP4_RX_DMA_SPEC>;
        ///Register `UEP4_RX_DMA` writer
        pub type W = crate::W<UEP4_RX_DMA_SPEC>;
        ///Field `UEP4_RX_DMA` reader - endpoint 4 DMA buffer address
        pub type UEP4_RX_DMA_R = crate::FieldReader<u32>;
        ///Field `UEP4_RX_DMA` writer - endpoint 4 DMA buffer address
        pub type UEP4_RX_DMA_W<'a, REG> = crate::FieldWriter<'a, REG, 17, u32>;
        impl R {
            ///Bits 0:16 - endpoint 4 DMA buffer address
            #[inline(always)]
            pub fn uep4_rx_dma(&self) -> UEP4_RX_DMA_R {
                UEP4_RX_DMA_R::new(self.bits & 0x0001_ffff)
            }
        }
        impl W {
            ///Bits 0:16 - endpoint 4 DMA buffer address
            #[inline(always)]
            #[must_use]
            pub fn uep4_rx_dma(&mut self) -> UEP4_RX_DMA_W<UEP4_RX_DMA_SPEC> {
                UEP4_RX_DMA_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///endpoint 4 DMA buffer address
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`uep4_rx_dma::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep4_rx_dma::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct UEP4_RX_DMA_SPEC;
        impl crate::RegisterSpec for UEP4_RX_DMA_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`uep4_rx_dma::R`](R) reader structure
        impl crate::Readable for UEP4_RX_DMA_SPEC {}
        ///`write(|w| ..)` method takes [`uep4_rx_dma::W`](W) writer structure
        impl crate::Writable for UEP4_RX_DMA_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets UEP4_RX_DMA to value 0
        impl crate::Resettable for UEP4_RX_DMA_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///UEP5_RX_DMA (rw) register accessor: endpoint 5 DMA buffer address
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`uep5_rx_dma::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep5_rx_dma::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@uep5_rx_dma`]
    ///module
    pub type UEP5_RX_DMA = crate::Reg<uep5_rx_dma::UEP5_RX_DMA_SPEC>;
    ///endpoint 5 DMA buffer address
    pub mod uep5_rx_dma {
        ///Register `UEP5_RX_DMA` reader
        pub type R = crate::R<UEP5_RX_DMA_SPEC>;
        ///Register `UEP5_RX_DMA` writer
        pub type W = crate::W<UEP5_RX_DMA_SPEC>;
        ///Field `UEP5_RX_DMA` reader - endpoint 5 DMA buffer address
        pub type UEP5_RX_DMA_R = crate::FieldReader<u32>;
        ///Field `UEP5_RX_DMA` writer - endpoint 5 DMA buffer address
        pub type UEP5_RX_DMA_W<'a, REG> = crate::FieldWriter<'a, REG, 17, u32>;
        impl R {
            ///Bits 0:16 - endpoint 5 DMA buffer address
            #[inline(always)]
            pub fn uep5_rx_dma(&self) -> UEP5_RX_DMA_R {
                UEP5_RX_DMA_R::new(self.bits & 0x0001_ffff)
            }
        }
        impl W {
            ///Bits 0:16 - endpoint 5 DMA buffer address
            #[inline(always)]
            #[must_use]
            pub fn uep5_rx_dma(&mut self) -> UEP5_RX_DMA_W<UEP5_RX_DMA_SPEC> {
                UEP5_RX_DMA_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///endpoint 5 DMA buffer address
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`uep5_rx_dma::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep5_rx_dma::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct UEP5_RX_DMA_SPEC;
        impl crate::RegisterSpec for UEP5_RX_DMA_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`uep5_rx_dma::R`](R) reader structure
        impl crate::Readable for UEP5_RX_DMA_SPEC {}
        ///`write(|w| ..)` method takes [`uep5_rx_dma::W`](W) writer structure
        impl crate::Writable for UEP5_RX_DMA_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets UEP5_RX_DMA to value 0
        impl crate::Resettable for UEP5_RX_DMA_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///UEP6_RX_DMA (rw) register accessor: endpoint 6 DMA buffer address
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`uep6_rx_dma::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep6_rx_dma::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@uep6_rx_dma`]
    ///module
    pub type UEP6_RX_DMA = crate::Reg<uep6_rx_dma::UEP6_RX_DMA_SPEC>;
    ///endpoint 6 DMA buffer address
    pub mod uep6_rx_dma {
        ///Register `UEP6_RX_DMA` reader
        pub type R = crate::R<UEP6_RX_DMA_SPEC>;
        ///Register `UEP6_RX_DMA` writer
        pub type W = crate::W<UEP6_RX_DMA_SPEC>;
        ///Field `UEP6_RX_DMA` reader - endpoint 6 DMA buffer address
        pub type UEP6_RX_DMA_R = crate::FieldReader<u32>;
        ///Field `UEP6_RX_DMA` writer - endpoint 6 DMA buffer address
        pub type UEP6_RX_DMA_W<'a, REG> = crate::FieldWriter<'a, REG, 17, u32>;
        impl R {
            ///Bits 0:16 - endpoint 6 DMA buffer address
            #[inline(always)]
            pub fn uep6_rx_dma(&self) -> UEP6_RX_DMA_R {
                UEP6_RX_DMA_R::new(self.bits & 0x0001_ffff)
            }
        }
        impl W {
            ///Bits 0:16 - endpoint 6 DMA buffer address
            #[inline(always)]
            #[must_use]
            pub fn uep6_rx_dma(&mut self) -> UEP6_RX_DMA_W<UEP6_RX_DMA_SPEC> {
                UEP6_RX_DMA_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///endpoint 6 DMA buffer address
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`uep6_rx_dma::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep6_rx_dma::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct UEP6_RX_DMA_SPEC;
        impl crate::RegisterSpec for UEP6_RX_DMA_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`uep6_rx_dma::R`](R) reader structure
        impl crate::Readable for UEP6_RX_DMA_SPEC {}
        ///`write(|w| ..)` method takes [`uep6_rx_dma::W`](W) writer structure
        impl crate::Writable for UEP6_RX_DMA_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets UEP6_RX_DMA to value 0
        impl crate::Resettable for UEP6_RX_DMA_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///UEP7_RX_DMA (rw) register accessor: endpoint 7 DMA buffer address
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`uep7_rx_dma::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep7_rx_dma::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@uep7_rx_dma`]
    ///module
    pub type UEP7_RX_DMA = crate::Reg<uep7_rx_dma::UEP7_RX_DMA_SPEC>;
    ///endpoint 7 DMA buffer address
    pub mod uep7_rx_dma {
        ///Register `UEP7_RX_DMA` reader
        pub type R = crate::R<UEP7_RX_DMA_SPEC>;
        ///Register `UEP7_RX_DMA` writer
        pub type W = crate::W<UEP7_RX_DMA_SPEC>;
        ///Field `UEP7_RX_DMA` reader - endpoint 7 DMA buffer address
        pub type UEP7_RX_DMA_R = crate::FieldReader<u32>;
        ///Field `UEP7_RX_DMA` writer - endpoint 7 DMA buffer address
        pub type UEP7_RX_DMA_W<'a, REG> = crate::FieldWriter<'a, REG, 17, u32>;
        impl R {
            ///Bits 0:16 - endpoint 7 DMA buffer address
            #[inline(always)]
            pub fn uep7_rx_dma(&self) -> UEP7_RX_DMA_R {
                UEP7_RX_DMA_R::new(self.bits & 0x0001_ffff)
            }
        }
        impl W {
            ///Bits 0:16 - endpoint 7 DMA buffer address
            #[inline(always)]
            #[must_use]
            pub fn uep7_rx_dma(&mut self) -> UEP7_RX_DMA_W<UEP7_RX_DMA_SPEC> {
                UEP7_RX_DMA_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///endpoint 7 DMA buffer address
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`uep7_rx_dma::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep7_rx_dma::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct UEP7_RX_DMA_SPEC;
        impl crate::RegisterSpec for UEP7_RX_DMA_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`uep7_rx_dma::R`](R) reader structure
        impl crate::Readable for UEP7_RX_DMA_SPEC {}
        ///`write(|w| ..)` method takes [`uep7_rx_dma::W`](W) writer structure
        impl crate::Writable for UEP7_RX_DMA_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets UEP7_RX_DMA to value 0
        impl crate::Resettable for UEP7_RX_DMA_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///UEP1_TX_DMA (rw) register accessor: endpoint 1 DMA TX buffer address
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`uep1_tx_dma::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep1_tx_dma::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@uep1_tx_dma`]
    ///module
    pub type UEP1_TX_DMA = crate::Reg<uep1_tx_dma::UEP1_TX_DMA_SPEC>;
    ///endpoint 1 DMA TX buffer address
    pub mod uep1_tx_dma {
        ///Register `UEP1_TX_DMA` reader
        pub type R = crate::R<UEP1_TX_DMA_SPEC>;
        ///Register `UEP1_TX_DMA` writer
        pub type W = crate::W<UEP1_TX_DMA_SPEC>;
        ///Field `UEP1_TX_DMA` reader - endpoint 1 DMA TX buffer address
        pub type UEP1_TX_DMA_R = crate::FieldReader<u32>;
        ///Field `UEP1_TX_DMA` writer - endpoint 1 DMA TX buffer address
        pub type UEP1_TX_DMA_W<'a, REG> = crate::FieldWriter<'a, REG, 17, u32>;
        impl R {
            ///Bits 0:16 - endpoint 1 DMA TX buffer address
            #[inline(always)]
            pub fn uep1_tx_dma(&self) -> UEP1_TX_DMA_R {
                UEP1_TX_DMA_R::new(self.bits & 0x0001_ffff)
            }
        }
        impl W {
            ///Bits 0:16 - endpoint 1 DMA TX buffer address
            #[inline(always)]
            #[must_use]
            pub fn uep1_tx_dma(&mut self) -> UEP1_TX_DMA_W<UEP1_TX_DMA_SPEC> {
                UEP1_TX_DMA_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///endpoint 1 DMA TX buffer address
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`uep1_tx_dma::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep1_tx_dma::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct UEP1_TX_DMA_SPEC;
        impl crate::RegisterSpec for UEP1_TX_DMA_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`uep1_tx_dma::R`](R) reader structure
        impl crate::Readable for UEP1_TX_DMA_SPEC {}
        ///`write(|w| ..)` method takes [`uep1_tx_dma::W`](W) writer structure
        impl crate::Writable for UEP1_TX_DMA_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets UEP1_TX_DMA to value 0
        impl crate::Resettable for UEP1_TX_DMA_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///UEP2_TX_DMA (rw) register accessor: endpoint 2 DMA TX buffer address
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`uep2_tx_dma::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep2_tx_dma::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@uep2_tx_dma`]
    ///module
    pub type UEP2_TX_DMA = crate::Reg<uep2_tx_dma::UEP2_TX_DMA_SPEC>;
    ///endpoint 2 DMA TX buffer address
    pub mod uep2_tx_dma {
        ///Register `UEP2_TX_DMA` reader
        pub type R = crate::R<UEP2_TX_DMA_SPEC>;
        ///Register `UEP2_TX_DMA` writer
        pub type W = crate::W<UEP2_TX_DMA_SPEC>;
        ///Field `UEP2_TX_DMA` reader - endpoint 2 DMA TX buffer address
        pub type UEP2_TX_DMA_R = crate::FieldReader<u32>;
        ///Field `UEP2_TX_DMA` writer - endpoint 2 DMA TX buffer address
        pub type UEP2_TX_DMA_W<'a, REG> = crate::FieldWriter<'a, REG, 17, u32>;
        impl R {
            ///Bits 0:16 - endpoint 2 DMA TX buffer address
            #[inline(always)]
            pub fn uep2_tx_dma(&self) -> UEP2_TX_DMA_R {
                UEP2_TX_DMA_R::new(self.bits & 0x0001_ffff)
            }
        }
        impl W {
            ///Bits 0:16 - endpoint 2 DMA TX buffer address
            #[inline(always)]
            #[must_use]
            pub fn uep2_tx_dma(&mut self) -> UEP2_TX_DMA_W<UEP2_TX_DMA_SPEC> {
                UEP2_TX_DMA_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///endpoint 2 DMA TX buffer address
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`uep2_tx_dma::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep2_tx_dma::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct UEP2_TX_DMA_SPEC;
        impl crate::RegisterSpec for UEP2_TX_DMA_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`uep2_tx_dma::R`](R) reader structure
        impl crate::Readable for UEP2_TX_DMA_SPEC {}
        ///`write(|w| ..)` method takes [`uep2_tx_dma::W`](W) writer structure
        impl crate::Writable for UEP2_TX_DMA_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets UEP2_TX_DMA to value 0
        impl crate::Resettable for UEP2_TX_DMA_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///UEP3_TX_DMA_R32_UH_TX_DMA (rw) register accessor: endpoint 3 DMA TX buffer address and host tx endpoint buffer start address
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`uep3_tx_dma_r32_uh_tx_dma::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep3_tx_dma_r32_uh_tx_dma::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@uep3_tx_dma_r32_uh_tx_dma`]
    ///module
    pub type UEP3_TX_DMA_R32_UH_TX_DMA =
        crate::Reg<uep3_tx_dma_r32_uh_tx_dma::UEP3_TX_DMA_R32_UH_TX_DMA_SPEC>;
    ///endpoint 3 DMA TX buffer address and host tx endpoint buffer start address
    pub mod uep3_tx_dma_r32_uh_tx_dma {
        ///Register `UEP3_TX_DMA_R32_UH_TX_DMA` reader
        pub type R = crate::R<UEP3_TX_DMA_R32_UH_TX_DMA_SPEC>;
        ///Register `UEP3_TX_DMA_R32_UH_TX_DMA` writer
        pub type W = crate::W<UEP3_TX_DMA_R32_UH_TX_DMA_SPEC>;
        ///Field `UEP3_TX_DMA_UH_TX_DMA` reader - endpoint 3 DMA TX buffer address and host tx endpoint buffer start address
        pub type UEP3_TX_DMA_UH_TX_DMA_R = crate::FieldReader<u32>;
        ///Field `UEP3_TX_DMA_UH_TX_DMA` writer - endpoint 3 DMA TX buffer address and host tx endpoint buffer start address
        pub type UEP3_TX_DMA_UH_TX_DMA_W<'a, REG> = crate::FieldWriter<'a, REG, 17, u32>;
        impl R {
            ///Bits 0:16 - endpoint 3 DMA TX buffer address and host tx endpoint buffer start address
            #[inline(always)]
            pub fn uep3_tx_dma_uh_tx_dma(&self) -> UEP3_TX_DMA_UH_TX_DMA_R {
                UEP3_TX_DMA_UH_TX_DMA_R::new(self.bits & 0x0001_ffff)
            }
        }
        impl W {
            ///Bits 0:16 - endpoint 3 DMA TX buffer address and host tx endpoint buffer start address
            #[inline(always)]
            #[must_use]
            pub fn uep3_tx_dma_uh_tx_dma(
                &mut self,
            ) -> UEP3_TX_DMA_UH_TX_DMA_W<UEP3_TX_DMA_R32_UH_TX_DMA_SPEC> {
                UEP3_TX_DMA_UH_TX_DMA_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///endpoint 3 DMA TX buffer address and host tx endpoint buffer start address
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`uep3_tx_dma_r32_uh_tx_dma::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep3_tx_dma_r32_uh_tx_dma::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct UEP3_TX_DMA_R32_UH_TX_DMA_SPEC;
        impl crate::RegisterSpec for UEP3_TX_DMA_R32_UH_TX_DMA_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`uep3_tx_dma_r32_uh_tx_dma::R`](R) reader structure
        impl crate::Readable for UEP3_TX_DMA_R32_UH_TX_DMA_SPEC {}
        ///`write(|w| ..)` method takes [`uep3_tx_dma_r32_uh_tx_dma::W`](W) writer structure
        impl crate::Writable for UEP3_TX_DMA_R32_UH_TX_DMA_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets UEP3_TX_DMA_R32_UH_TX_DMA to value 0
        impl crate::Resettable for UEP3_TX_DMA_R32_UH_TX_DMA_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///UEP4_TX_DMA (rw) register accessor: endpoint 4 DMA TX buffer address
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`uep4_tx_dma::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep4_tx_dma::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@uep4_tx_dma`]
    ///module
    pub type UEP4_TX_DMA = crate::Reg<uep4_tx_dma::UEP4_TX_DMA_SPEC>;
    ///endpoint 4 DMA TX buffer address
    pub mod uep4_tx_dma {
        ///Register `UEP4_TX_DMA` reader
        pub type R = crate::R<UEP4_TX_DMA_SPEC>;
        ///Register `UEP4_TX_DMA` writer
        pub type W = crate::W<UEP4_TX_DMA_SPEC>;
        ///Field `UEP4_TX_DMA` reader - endpoint 4 DMA TX buffer address
        pub type UEP4_TX_DMA_R = crate::FieldReader<u32>;
        ///Field `UEP4_TX_DMA` writer - endpoint 4 DMA TX buffer address
        pub type UEP4_TX_DMA_W<'a, REG> = crate::FieldWriter<'a, REG, 17, u32>;
        impl R {
            ///Bits 0:16 - endpoint 4 DMA TX buffer address
            #[inline(always)]
            pub fn uep4_tx_dma(&self) -> UEP4_TX_DMA_R {
                UEP4_TX_DMA_R::new(self.bits & 0x0001_ffff)
            }
        }
        impl W {
            ///Bits 0:16 - endpoint 4 DMA TX buffer address
            #[inline(always)]
            #[must_use]
            pub fn uep4_tx_dma(&mut self) -> UEP4_TX_DMA_W<UEP4_TX_DMA_SPEC> {
                UEP4_TX_DMA_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///endpoint 4 DMA TX buffer address
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`uep4_tx_dma::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep4_tx_dma::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct UEP4_TX_DMA_SPEC;
        impl crate::RegisterSpec for UEP4_TX_DMA_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`uep4_tx_dma::R`](R) reader structure
        impl crate::Readable for UEP4_TX_DMA_SPEC {}
        ///`write(|w| ..)` method takes [`uep4_tx_dma::W`](W) writer structure
        impl crate::Writable for UEP4_TX_DMA_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets UEP4_TX_DMA to value 0
        impl crate::Resettable for UEP4_TX_DMA_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///UEP5_TX_DMA (rw) register accessor: endpoint 5 DMA TX buffer address
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`uep5_tx_dma::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep5_tx_dma::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@uep5_tx_dma`]
    ///module
    pub type UEP5_TX_DMA = crate::Reg<uep5_tx_dma::UEP5_TX_DMA_SPEC>;
    ///endpoint 5 DMA TX buffer address
    pub mod uep5_tx_dma {
        ///Register `UEP5_TX_DMA` reader
        pub type R = crate::R<UEP5_TX_DMA_SPEC>;
        ///Register `UEP5_TX_DMA` writer
        pub type W = crate::W<UEP5_TX_DMA_SPEC>;
        ///Field `UEP5_TX_DMA` reader - endpoint 5 DMA TX buffer address
        pub type UEP5_TX_DMA_R = crate::FieldReader<u32>;
        ///Field `UEP5_TX_DMA` writer - endpoint 5 DMA TX buffer address
        pub type UEP5_TX_DMA_W<'a, REG> = crate::FieldWriter<'a, REG, 17, u32>;
        impl R {
            ///Bits 0:16 - endpoint 5 DMA TX buffer address
            #[inline(always)]
            pub fn uep5_tx_dma(&self) -> UEP5_TX_DMA_R {
                UEP5_TX_DMA_R::new(self.bits & 0x0001_ffff)
            }
        }
        impl W {
            ///Bits 0:16 - endpoint 5 DMA TX buffer address
            #[inline(always)]
            #[must_use]
            pub fn uep5_tx_dma(&mut self) -> UEP5_TX_DMA_W<UEP5_TX_DMA_SPEC> {
                UEP5_TX_DMA_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///endpoint 5 DMA TX buffer address
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`uep5_tx_dma::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep5_tx_dma::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct UEP5_TX_DMA_SPEC;
        impl crate::RegisterSpec for UEP5_TX_DMA_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`uep5_tx_dma::R`](R) reader structure
        impl crate::Readable for UEP5_TX_DMA_SPEC {}
        ///`write(|w| ..)` method takes [`uep5_tx_dma::W`](W) writer structure
        impl crate::Writable for UEP5_TX_DMA_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets UEP5_TX_DMA to value 0
        impl crate::Resettable for UEP5_TX_DMA_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///UEP6_TX_DMA (rw) register accessor: endpoint 4 DMA TX buffer address
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`uep6_tx_dma::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep6_tx_dma::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@uep6_tx_dma`]
    ///module
    pub type UEP6_TX_DMA = crate::Reg<uep6_tx_dma::UEP6_TX_DMA_SPEC>;
    ///endpoint 4 DMA TX buffer address
    pub mod uep6_tx_dma {
        ///Register `UEP6_TX_DMA` reader
        pub type R = crate::R<UEP6_TX_DMA_SPEC>;
        ///Register `UEP6_TX_DMA` writer
        pub type W = crate::W<UEP6_TX_DMA_SPEC>;
        ///Field `UEP6_TX_DMA` reader - endpoint 6 DMA TX buffer address
        pub type UEP6_TX_DMA_R = crate::FieldReader<u32>;
        ///Field `UEP6_TX_DMA` writer - endpoint 6 DMA TX buffer address
        pub type UEP6_TX_DMA_W<'a, REG> = crate::FieldWriter<'a, REG, 17, u32>;
        impl R {
            ///Bits 0:16 - endpoint 6 DMA TX buffer address
            #[inline(always)]
            pub fn uep6_tx_dma(&self) -> UEP6_TX_DMA_R {
                UEP6_TX_DMA_R::new(self.bits & 0x0001_ffff)
            }
        }
        impl W {
            ///Bits 0:16 - endpoint 6 DMA TX buffer address
            #[inline(always)]
            #[must_use]
            pub fn uep6_tx_dma(&mut self) -> UEP6_TX_DMA_W<UEP6_TX_DMA_SPEC> {
                UEP6_TX_DMA_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///endpoint 4 DMA TX buffer address
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`uep6_tx_dma::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep6_tx_dma::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct UEP6_TX_DMA_SPEC;
        impl crate::RegisterSpec for UEP6_TX_DMA_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`uep6_tx_dma::R`](R) reader structure
        impl crate::Readable for UEP6_TX_DMA_SPEC {}
        ///`write(|w| ..)` method takes [`uep6_tx_dma::W`](W) writer structure
        impl crate::Writable for UEP6_TX_DMA_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets UEP6_TX_DMA to value 0
        impl crate::Resettable for UEP6_TX_DMA_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///UEP7_TX_DMA (rw) register accessor: endpoint 7 DMA TX buffer address
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`uep7_tx_dma::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep7_tx_dma::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@uep7_tx_dma`]
    ///module
    pub type UEP7_TX_DMA = crate::Reg<uep7_tx_dma::UEP7_TX_DMA_SPEC>;
    ///endpoint 7 DMA TX buffer address
    pub mod uep7_tx_dma {
        ///Register `UEP7_TX_DMA` reader
        pub type R = crate::R<UEP7_TX_DMA_SPEC>;
        ///Register `UEP7_TX_DMA` writer
        pub type W = crate::W<UEP7_TX_DMA_SPEC>;
        ///Field `UEP7_TX_DMA` reader - endpoint 7 DMA TX buffer address
        pub type UEP7_TX_DMA_R = crate::FieldReader<u32>;
        ///Field `UEP7_TX_DMA` writer - endpoint 7 DMA TX buffer address
        pub type UEP7_TX_DMA_W<'a, REG> = crate::FieldWriter<'a, REG, 17, u32>;
        impl R {
            ///Bits 0:16 - endpoint 7 DMA TX buffer address
            #[inline(always)]
            pub fn uep7_tx_dma(&self) -> UEP7_TX_DMA_R {
                UEP7_TX_DMA_R::new(self.bits & 0x0001_ffff)
            }
        }
        impl W {
            ///Bits 0:16 - endpoint 7 DMA TX buffer address
            #[inline(always)]
            #[must_use]
            pub fn uep7_tx_dma(&mut self) -> UEP7_TX_DMA_W<UEP7_TX_DMA_SPEC> {
                UEP7_TX_DMA_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///endpoint 7 DMA TX buffer address
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`uep7_tx_dma::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep7_tx_dma::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct UEP7_TX_DMA_SPEC;
        impl crate::RegisterSpec for UEP7_TX_DMA_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`uep7_tx_dma::R`](R) reader structure
        impl crate::Readable for UEP7_TX_DMA_SPEC {}
        ///`write(|w| ..)` method takes [`uep7_tx_dma::W`](W) writer structure
        impl crate::Writable for UEP7_TX_DMA_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets UEP7_TX_DMA to value 0
        impl crate::Resettable for UEP7_TX_DMA_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///UEP0_MAX_LEN (rw) register accessor: endpoint 0 receive max length
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`uep0_max_len::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep0_max_len::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@uep0_max_len`]
    ///module
    pub type UEP0_MAX_LEN = crate::Reg<uep0_max_len::UEP0_MAX_LEN_SPEC>;
    ///endpoint 0 receive max length
    pub mod uep0_max_len {
        ///Register `UEP0_MAX_LEN` reader
        pub type R = crate::R<UEP0_MAX_LEN_SPEC>;
        ///Register `UEP0_MAX_LEN` writer
        pub type W = crate::W<UEP0_MAX_LEN_SPEC>;
        ///Field `UEP0_MAX_LEN` reader - endpoint 0 receive max length
        pub type UEP0_MAX_LEN_R = crate::FieldReader<u16>;
        ///Field `UEP0_MAX_LEN` writer - endpoint 0 receive max length
        pub type UEP0_MAX_LEN_W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            ///Bits 0:15 - endpoint 0 receive max length
            #[inline(always)]
            pub fn uep0_max_len(&self) -> UEP0_MAX_LEN_R {
                UEP0_MAX_LEN_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - endpoint 0 receive max length
            #[inline(always)]
            #[must_use]
            pub fn uep0_max_len(&mut self) -> UEP0_MAX_LEN_W<UEP0_MAX_LEN_SPEC> {
                UEP0_MAX_LEN_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///endpoint 0 receive max length
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`uep0_max_len::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep0_max_len::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct UEP0_MAX_LEN_SPEC;
        impl crate::RegisterSpec for UEP0_MAX_LEN_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`uep0_max_len::R`](R) reader structure
        impl crate::Readable for UEP0_MAX_LEN_SPEC {}
        ///`write(|w| ..)` method takes [`uep0_max_len::W`](W) writer structure
        impl crate::Writable for UEP0_MAX_LEN_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets UEP0_MAX_LEN to value 0
        impl crate::Resettable for UEP0_MAX_LEN_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///UEP1_MAX_LEN (rw) register accessor: endpoint 1 receive max length
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`uep1_max_len::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep1_max_len::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@uep1_max_len`]
    ///module
    pub type UEP1_MAX_LEN = crate::Reg<uep1_max_len::UEP1_MAX_LEN_SPEC>;
    ///endpoint 1 receive max length
    pub mod uep1_max_len {
        ///Register `UEP1_MAX_LEN` reader
        pub type R = crate::R<UEP1_MAX_LEN_SPEC>;
        ///Register `UEP1_MAX_LEN` writer
        pub type W = crate::W<UEP1_MAX_LEN_SPEC>;
        ///Field `UEP1_MAX_LEN` reader - endpoint 1 receive max length
        pub type UEP1_MAX_LEN_R = crate::FieldReader<u16>;
        ///Field `UEP1_MAX_LEN` writer - endpoint 1 receive max length
        pub type UEP1_MAX_LEN_W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            ///Bits 0:15 - endpoint 1 receive max length
            #[inline(always)]
            pub fn uep1_max_len(&self) -> UEP1_MAX_LEN_R {
                UEP1_MAX_LEN_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - endpoint 1 receive max length
            #[inline(always)]
            #[must_use]
            pub fn uep1_max_len(&mut self) -> UEP1_MAX_LEN_W<UEP1_MAX_LEN_SPEC> {
                UEP1_MAX_LEN_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///endpoint 1 receive max length
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`uep1_max_len::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep1_max_len::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct UEP1_MAX_LEN_SPEC;
        impl crate::RegisterSpec for UEP1_MAX_LEN_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`uep1_max_len::R`](R) reader structure
        impl crate::Readable for UEP1_MAX_LEN_SPEC {}
        ///`write(|w| ..)` method takes [`uep1_max_len::W`](W) writer structure
        impl crate::Writable for UEP1_MAX_LEN_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets UEP1_MAX_LEN to value 0
        impl crate::Resettable for UEP1_MAX_LEN_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///UEP2_MAX_LEN_R16_UH_MAX_LEN (rw) register accessor: endpoint 2 receive max length and USB host receive max packet length register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`uep2_max_len_r16_uh_max_len::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep2_max_len_r16_uh_max_len::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@uep2_max_len_r16_uh_max_len`]
    ///module
    pub type UEP2_MAX_LEN_R16_UH_MAX_LEN =
        crate::Reg<uep2_max_len_r16_uh_max_len::UEP2_MAX_LEN_R16_UH_MAX_LEN_SPEC>;
    ///endpoint 2 receive max length and USB host receive max packet length register
    pub mod uep2_max_len_r16_uh_max_len {
        ///Register `UEP2_MAX_LEN_R16_UH_MAX_LEN` reader
        pub type R = crate::R<UEP2_MAX_LEN_R16_UH_MAX_LEN_SPEC>;
        ///Register `UEP2_MAX_LEN_R16_UH_MAX_LEN` writer
        pub type W = crate::W<UEP2_MAX_LEN_R16_UH_MAX_LEN_SPEC>;
        ///Field `UEP2_MAX_LEN_UH_MAX_LEN` reader - endpoint 2 receive max length and USB host receive max packet length register
        pub type UEP2_MAX_LEN_UH_MAX_LEN_R = crate::FieldReader<u16>;
        ///Field `UEP2_MAX_LEN_UH_MAX_LEN` writer - endpoint 2 receive max length and USB host receive max packet length register
        pub type UEP2_MAX_LEN_UH_MAX_LEN_W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            ///Bits 0:15 - endpoint 2 receive max length and USB host receive max packet length register
            #[inline(always)]
            pub fn uep2_max_len_uh_max_len(&self) -> UEP2_MAX_LEN_UH_MAX_LEN_R {
                UEP2_MAX_LEN_UH_MAX_LEN_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - endpoint 2 receive max length and USB host receive max packet length register
            #[inline(always)]
            #[must_use]
            pub fn uep2_max_len_uh_max_len(
                &mut self,
            ) -> UEP2_MAX_LEN_UH_MAX_LEN_W<UEP2_MAX_LEN_R16_UH_MAX_LEN_SPEC> {
                UEP2_MAX_LEN_UH_MAX_LEN_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///endpoint 2 receive max length and USB host receive max packet length register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`uep2_max_len_r16_uh_max_len::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep2_max_len_r16_uh_max_len::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct UEP2_MAX_LEN_R16_UH_MAX_LEN_SPEC;
        impl crate::RegisterSpec for UEP2_MAX_LEN_R16_UH_MAX_LEN_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`uep2_max_len_r16_uh_max_len::R`](R) reader structure
        impl crate::Readable for UEP2_MAX_LEN_R16_UH_MAX_LEN_SPEC {}
        ///`write(|w| ..)` method takes [`uep2_max_len_r16_uh_max_len::W`](W) writer structure
        impl crate::Writable for UEP2_MAX_LEN_R16_UH_MAX_LEN_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets UEP2_MAX_LEN_R16_UH_MAX_LEN to value 0
        impl crate::Resettable for UEP2_MAX_LEN_R16_UH_MAX_LEN_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///UEP3_MAX_LEN (rw) register accessor: endpoint 3 receive max length
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`uep3_max_len::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep3_max_len::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@uep3_max_len`]
    ///module
    pub type UEP3_MAX_LEN = crate::Reg<uep3_max_len::UEP3_MAX_LEN_SPEC>;
    ///endpoint 3 receive max length
    pub mod uep3_max_len {
        ///Register `UEP3_MAX_LEN` reader
        pub type R = crate::R<UEP3_MAX_LEN_SPEC>;
        ///Register `UEP3_MAX_LEN` writer
        pub type W = crate::W<UEP3_MAX_LEN_SPEC>;
        ///Field `UEP3_MAX_LEN` reader - endpoint 3 receive max length
        pub type UEP3_MAX_LEN_R = crate::FieldReader<u16>;
        ///Field `UEP3_MAX_LEN` writer - endpoint 3 receive max length
        pub type UEP3_MAX_LEN_W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            ///Bits 0:15 - endpoint 3 receive max length
            #[inline(always)]
            pub fn uep3_max_len(&self) -> UEP3_MAX_LEN_R {
                UEP3_MAX_LEN_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - endpoint 3 receive max length
            #[inline(always)]
            #[must_use]
            pub fn uep3_max_len(&mut self) -> UEP3_MAX_LEN_W<UEP3_MAX_LEN_SPEC> {
                UEP3_MAX_LEN_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///endpoint 3 receive max length
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`uep3_max_len::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep3_max_len::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct UEP3_MAX_LEN_SPEC;
        impl crate::RegisterSpec for UEP3_MAX_LEN_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`uep3_max_len::R`](R) reader structure
        impl crate::Readable for UEP3_MAX_LEN_SPEC {}
        ///`write(|w| ..)` method takes [`uep3_max_len::W`](W) writer structure
        impl crate::Writable for UEP3_MAX_LEN_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets UEP3_MAX_LEN to value 0
        impl crate::Resettable for UEP3_MAX_LEN_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///UEP4_MAX_LEN (rw) register accessor: endpoint 4 receive max length
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`uep4_max_len::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep4_max_len::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@uep4_max_len`]
    ///module
    pub type UEP4_MAX_LEN = crate::Reg<uep4_max_len::UEP4_MAX_LEN_SPEC>;
    ///endpoint 4 receive max length
    pub mod uep4_max_len {
        ///Register `UEP4_MAX_LEN` reader
        pub type R = crate::R<UEP4_MAX_LEN_SPEC>;
        ///Register `UEP4_MAX_LEN` writer
        pub type W = crate::W<UEP4_MAX_LEN_SPEC>;
        ///Field `UEP4_MAX_LEN` reader - endpoint 4 receive max length
        pub type UEP4_MAX_LEN_R = crate::FieldReader<u16>;
        ///Field `UEP4_MAX_LEN` writer - endpoint 4 receive max length
        pub type UEP4_MAX_LEN_W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            ///Bits 0:15 - endpoint 4 receive max length
            #[inline(always)]
            pub fn uep4_max_len(&self) -> UEP4_MAX_LEN_R {
                UEP4_MAX_LEN_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - endpoint 4 receive max length
            #[inline(always)]
            #[must_use]
            pub fn uep4_max_len(&mut self) -> UEP4_MAX_LEN_W<UEP4_MAX_LEN_SPEC> {
                UEP4_MAX_LEN_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///endpoint 4 receive max length
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`uep4_max_len::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep4_max_len::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct UEP4_MAX_LEN_SPEC;
        impl crate::RegisterSpec for UEP4_MAX_LEN_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`uep4_max_len::R`](R) reader structure
        impl crate::Readable for UEP4_MAX_LEN_SPEC {}
        ///`write(|w| ..)` method takes [`uep4_max_len::W`](W) writer structure
        impl crate::Writable for UEP4_MAX_LEN_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets UEP4_MAX_LEN to value 0
        impl crate::Resettable for UEP4_MAX_LEN_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///UEP5_MAX_LEN (rw) register accessor: endpoint 5 receive max length
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`uep5_max_len::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep5_max_len::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@uep5_max_len`]
    ///module
    pub type UEP5_MAX_LEN = crate::Reg<uep5_max_len::UEP5_MAX_LEN_SPEC>;
    ///endpoint 5 receive max length
    pub mod uep5_max_len {
        ///Register `UEP5_MAX_LEN` reader
        pub type R = crate::R<UEP5_MAX_LEN_SPEC>;
        ///Register `UEP5_MAX_LEN` writer
        pub type W = crate::W<UEP5_MAX_LEN_SPEC>;
        ///Field `UEP5_MAX_LEN` reader - endpoint 5 receive max length
        pub type UEP5_MAX_LEN_R = crate::FieldReader<u16>;
        ///Field `UEP5_MAX_LEN` writer - endpoint 5 receive max length
        pub type UEP5_MAX_LEN_W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            ///Bits 0:15 - endpoint 5 receive max length
            #[inline(always)]
            pub fn uep5_max_len(&self) -> UEP5_MAX_LEN_R {
                UEP5_MAX_LEN_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - endpoint 5 receive max length
            #[inline(always)]
            #[must_use]
            pub fn uep5_max_len(&mut self) -> UEP5_MAX_LEN_W<UEP5_MAX_LEN_SPEC> {
                UEP5_MAX_LEN_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///endpoint 5 receive max length
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`uep5_max_len::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep5_max_len::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct UEP5_MAX_LEN_SPEC;
        impl crate::RegisterSpec for UEP5_MAX_LEN_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`uep5_max_len::R`](R) reader structure
        impl crate::Readable for UEP5_MAX_LEN_SPEC {}
        ///`write(|w| ..)` method takes [`uep5_max_len::W`](W) writer structure
        impl crate::Writable for UEP5_MAX_LEN_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets UEP5_MAX_LEN to value 0
        impl crate::Resettable for UEP5_MAX_LEN_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///UEP6_MAX_LEN (rw) register accessor: endpoint 6 receive max length
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`uep6_max_len::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep6_max_len::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@uep6_max_len`]
    ///module
    pub type UEP6_MAX_LEN = crate::Reg<uep6_max_len::UEP6_MAX_LEN_SPEC>;
    ///endpoint 6 receive max length
    pub mod uep6_max_len {
        ///Register `UEP6_MAX_LEN` reader
        pub type R = crate::R<UEP6_MAX_LEN_SPEC>;
        ///Register `UEP6_MAX_LEN` writer
        pub type W = crate::W<UEP6_MAX_LEN_SPEC>;
        ///Field `UEP6_MAX_LEN` reader - endpoint 6 receive max length
        pub type UEP6_MAX_LEN_R = crate::FieldReader<u16>;
        ///Field `UEP6_MAX_LEN` writer - endpoint 6 receive max length
        pub type UEP6_MAX_LEN_W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            ///Bits 0:15 - endpoint 6 receive max length
            #[inline(always)]
            pub fn uep6_max_len(&self) -> UEP6_MAX_LEN_R {
                UEP6_MAX_LEN_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - endpoint 6 receive max length
            #[inline(always)]
            #[must_use]
            pub fn uep6_max_len(&mut self) -> UEP6_MAX_LEN_W<UEP6_MAX_LEN_SPEC> {
                UEP6_MAX_LEN_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///endpoint 6 receive max length
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`uep6_max_len::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep6_max_len::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct UEP6_MAX_LEN_SPEC;
        impl crate::RegisterSpec for UEP6_MAX_LEN_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`uep6_max_len::R`](R) reader structure
        impl crate::Readable for UEP6_MAX_LEN_SPEC {}
        ///`write(|w| ..)` method takes [`uep6_max_len::W`](W) writer structure
        impl crate::Writable for UEP6_MAX_LEN_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets UEP6_MAX_LEN to value 0
        impl crate::Resettable for UEP6_MAX_LEN_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///UEP7_MAX_LEN (rw) register accessor: endpoint 7 receive max length
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`uep7_max_len::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep7_max_len::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@uep7_max_len`]
    ///module
    pub type UEP7_MAX_LEN = crate::Reg<uep7_max_len::UEP7_MAX_LEN_SPEC>;
    ///endpoint 7 receive max length
    pub mod uep7_max_len {
        ///Register `UEP7_MAX_LEN` reader
        pub type R = crate::R<UEP7_MAX_LEN_SPEC>;
        ///Register `UEP7_MAX_LEN` writer
        pub type W = crate::W<UEP7_MAX_LEN_SPEC>;
        ///Field `UEP7_MAX_LEN` reader - endpoint 7 receive max length
        pub type UEP7_MAX_LEN_R = crate::FieldReader<u16>;
        ///Field `UEP7_MAX_LEN` writer - endpoint 7 receive max length
        pub type UEP7_MAX_LEN_W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            ///Bits 0:15 - endpoint 7 receive max length
            #[inline(always)]
            pub fn uep7_max_len(&self) -> UEP7_MAX_LEN_R {
                UEP7_MAX_LEN_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - endpoint 7 receive max length
            #[inline(always)]
            #[must_use]
            pub fn uep7_max_len(&mut self) -> UEP7_MAX_LEN_W<UEP7_MAX_LEN_SPEC> {
                UEP7_MAX_LEN_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///endpoint 7 receive max length
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`uep7_max_len::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep7_max_len::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct UEP7_MAX_LEN_SPEC;
        impl crate::RegisterSpec for UEP7_MAX_LEN_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`uep7_max_len::R`](R) reader structure
        impl crate::Readable for UEP7_MAX_LEN_SPEC {}
        ///`write(|w| ..)` method takes [`uep7_max_len::W`](W) writer structure
        impl crate::Writable for UEP7_MAX_LEN_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets UEP7_MAX_LEN to value 0
        impl crate::Resettable for UEP7_MAX_LEN_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///UEP0_T_LEN (rw) register accessor: endpoint 0 transmittal length
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`uep0_t_len::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep0_t_len::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@uep0_t_len`]
    ///module
    pub type UEP0_T_LEN = crate::Reg<uep0_t_len::UEP0_T_LEN_SPEC>;
    ///endpoint 0 transmittal length
    pub mod uep0_t_len {
        ///Register `UEP0_T_LEN` reader
        pub type R = crate::R<UEP0_T_LEN_SPEC>;
        ///Register `UEP0_T_LEN` writer
        pub type W = crate::W<UEP0_T_LEN_SPEC>;
        ///Field `UEP0_T_LEN` reader - endpoint 0 transmittal length
        pub type UEP0_T_LEN_R = crate::FieldReader<u16>;
        ///Field `UEP0_T_LEN` writer - endpoint 0 transmittal length
        pub type UEP0_T_LEN_W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            ///Bits 0:15 - endpoint 0 transmittal length
            #[inline(always)]
            pub fn uep0_t_len(&self) -> UEP0_T_LEN_R {
                UEP0_T_LEN_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - endpoint 0 transmittal length
            #[inline(always)]
            #[must_use]
            pub fn uep0_t_len(&mut self) -> UEP0_T_LEN_W<UEP0_T_LEN_SPEC> {
                UEP0_T_LEN_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///endpoint 0 transmittal length
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`uep0_t_len::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep0_t_len::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct UEP0_T_LEN_SPEC;
        impl crate::RegisterSpec for UEP0_T_LEN_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`uep0_t_len::R`](R) reader structure
        impl crate::Readable for UEP0_T_LEN_SPEC {}
        ///`write(|w| ..)` method takes [`uep0_t_len::W`](W) writer structure
        impl crate::Writable for UEP0_T_LEN_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets UEP0_T_LEN to value 0
        impl crate::Resettable for UEP0_T_LEN_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///UEP0_TX_CTRL (rw) register accessor: endpoint 0 tx control
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`uep0_tx_ctrl::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep0_tx_ctrl::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@uep0_tx_ctrl`]
    ///module
    pub type UEP0_TX_CTRL = crate::Reg<uep0_tx_ctrl::UEP0_TX_CTRL_SPEC>;
    ///endpoint 0 tx control
    pub mod uep0_tx_ctrl {
        ///Register `UEP0_TX_CTRL` reader
        pub type R = crate::R<UEP0_TX_CTRL_SPEC>;
        ///Register `UEP0_TX_CTRL` writer
        pub type W = crate::W<UEP0_TX_CTRL_SPEC>;
        ///Field `UEP_TRES_MASK` reader - bit mask of handshake response type for USB endpoint X transmittal (IN)
        pub type UEP_TRES_MASK_R = crate::FieldReader;
        ///Field `UEP_TRES_MASK` writer - bit mask of handshake response type for USB endpoint X transmittal (IN)
        pub type UEP_TRES_MASK_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `UEP_TRES_NO` reader - expected no response
        pub type UEP_TRES_NO_R = crate::BitReader;
        ///Field `UEP_TRES_NO` writer - expected no response
        pub type UEP_TRES_NO_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UEP_T_TOG_MASK` reader - prepared data toggle flag of USB endpoint X transmittal
        pub type UEP_T_TOG_MASK_R = crate::FieldReader;
        ///Field `UEP_T_TOG_MASK` writer - prepared data toggle flag of USB endpoint X transmittal
        pub type UEP_T_TOG_MASK_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `UEP_T_AUTOTOG` reader - enable automatic toggle after successful transfer completion on endpoint 0
        pub type UEP_T_AUTOTOG_R = crate::BitReader;
        ///Field `UEP_T_AUTOTOG` writer - enable automatic toggle after successful transfer completion on endpoint 0
        pub type UEP_T_AUTOTOG_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)
            #[inline(always)]
            pub fn uep_tres_mask(&self) -> UEP_TRES_MASK_R {
                UEP_TRES_MASK_R::new(self.bits & 3)
            }
            ///Bit 2 - expected no response
            #[inline(always)]
            pub fn uep_tres_no(&self) -> UEP_TRES_NO_R {
                UEP_TRES_NO_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bits 3:4 - prepared data toggle flag of USB endpoint X transmittal
            #[inline(always)]
            pub fn uep_t_tog_mask(&self) -> UEP_T_TOG_MASK_R {
                UEP_T_TOG_MASK_R::new((self.bits >> 3) & 3)
            }
            ///Bit 5 - enable automatic toggle after successful transfer completion on endpoint 0
            #[inline(always)]
            pub fn uep_t_autotog(&self) -> UEP_T_AUTOTOG_R {
                UEP_T_AUTOTOG_R::new(((self.bits >> 5) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)
            #[inline(always)]
            #[must_use]
            pub fn uep_tres_mask(&mut self) -> UEP_TRES_MASK_W<UEP0_TX_CTRL_SPEC> {
                UEP_TRES_MASK_W::new(self, 0)
            }
            ///Bit 2 - expected no response
            #[inline(always)]
            #[must_use]
            pub fn uep_tres_no(&mut self) -> UEP_TRES_NO_W<UEP0_TX_CTRL_SPEC> {
                UEP_TRES_NO_W::new(self, 2)
            }
            ///Bits 3:4 - prepared data toggle flag of USB endpoint X transmittal
            #[inline(always)]
            #[must_use]
            pub fn uep_t_tog_mask(&mut self) -> UEP_T_TOG_MASK_W<UEP0_TX_CTRL_SPEC> {
                UEP_T_TOG_MASK_W::new(self, 3)
            }
            ///Bit 5 - enable automatic toggle after successful transfer completion on endpoint 0
            #[inline(always)]
            #[must_use]
            pub fn uep_t_autotog(&mut self) -> UEP_T_AUTOTOG_W<UEP0_TX_CTRL_SPEC> {
                UEP_T_AUTOTOG_W::new(self, 5)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///endpoint 0 tx control
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`uep0_tx_ctrl::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep0_tx_ctrl::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct UEP0_TX_CTRL_SPEC;
        impl crate::RegisterSpec for UEP0_TX_CTRL_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`uep0_tx_ctrl::R`](R) reader structure
        impl crate::Readable for UEP0_TX_CTRL_SPEC {}
        ///`write(|w| ..)` method takes [`uep0_tx_ctrl::W`](W) writer structure
        impl crate::Writable for UEP0_TX_CTRL_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets UEP0_TX_CTRL to value 0
        impl crate::Resettable for UEP0_TX_CTRL_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///UEP0_RX_CTRL (rw) register accessor: endpoint 0 rx control
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`uep0_rx_ctrl::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep0_rx_ctrl::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@uep0_rx_ctrl`]
    ///module
    pub type UEP0_RX_CTRL = crate::Reg<uep0_rx_ctrl::UEP0_RX_CTRL_SPEC>;
    ///endpoint 0 rx control
    pub mod uep0_rx_ctrl {
        ///Register `UEP0_RX_CTRL` reader
        pub type R = crate::R<UEP0_RX_CTRL_SPEC>;
        ///Register `UEP0_RX_CTRL` writer
        pub type W = crate::W<UEP0_RX_CTRL_SPEC>;
        ///Field `UEP_RRES_MASK` reader - bit mask of handshake response type for USB endpoint X receiving (OUT)
        pub type UEP_RRES_MASK_R = crate::FieldReader;
        ///Field `UEP_RRES_MASK` writer - bit mask of handshake response type for USB endpoint X receiving (OUT)
        pub type UEP_RRES_MASK_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `UEP_RRES_NO` reader - prepared no response
        pub type UEP_RRES_NO_R = crate::BitReader;
        ///Field `UEP_RRES_NO` writer - prepared no response
        pub type UEP_RRES_NO_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UEP_R_TOG_MASK` reader - expected data toggle flag of USB endpoint X receiving
        pub type UEP_R_TOG_MASK_R = crate::FieldReader;
        ///Field `UEP_R_TOG_MASK` writer - expected data toggle flag of USB endpoint X receiving
        pub type UEP_R_TOG_MASK_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `UEP_R_AUTOTOG` reader - enable automatic toggle after successful transfer completion on endpoint
        pub type UEP_R_AUTOTOG_R = crate::BitReader;
        ///Field `UEP_R_AUTOTOG` writer - enable automatic toggle after successful transfer completion on endpoint
        pub type UEP_R_AUTOTOG_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bits 0:1 - bit mask of handshake response type for USB endpoint X receiving (OUT)
            #[inline(always)]
            pub fn uep_rres_mask(&self) -> UEP_RRES_MASK_R {
                UEP_RRES_MASK_R::new(self.bits & 3)
            }
            ///Bit 2 - prepared no response
            #[inline(always)]
            pub fn uep_rres_no(&self) -> UEP_RRES_NO_R {
                UEP_RRES_NO_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bits 3:4 - expected data toggle flag of USB endpoint X receiving
            #[inline(always)]
            pub fn uep_r_tog_mask(&self) -> UEP_R_TOG_MASK_R {
                UEP_R_TOG_MASK_R::new((self.bits >> 3) & 3)
            }
            ///Bit 5 - enable automatic toggle after successful transfer completion on endpoint
            #[inline(always)]
            pub fn uep_r_autotog(&self) -> UEP_R_AUTOTOG_R {
                UEP_R_AUTOTOG_R::new(((self.bits >> 5) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:1 - bit mask of handshake response type for USB endpoint X receiving (OUT)
            #[inline(always)]
            #[must_use]
            pub fn uep_rres_mask(&mut self) -> UEP_RRES_MASK_W<UEP0_RX_CTRL_SPEC> {
                UEP_RRES_MASK_W::new(self, 0)
            }
            ///Bit 2 - prepared no response
            #[inline(always)]
            #[must_use]
            pub fn uep_rres_no(&mut self) -> UEP_RRES_NO_W<UEP0_RX_CTRL_SPEC> {
                UEP_RRES_NO_W::new(self, 2)
            }
            ///Bits 3:4 - expected data toggle flag of USB endpoint X receiving
            #[inline(always)]
            #[must_use]
            pub fn uep_r_tog_mask(&mut self) -> UEP_R_TOG_MASK_W<UEP0_RX_CTRL_SPEC> {
                UEP_R_TOG_MASK_W::new(self, 3)
            }
            ///Bit 5 - enable automatic toggle after successful transfer completion on endpoint
            #[inline(always)]
            #[must_use]
            pub fn uep_r_autotog(&mut self) -> UEP_R_AUTOTOG_W<UEP0_RX_CTRL_SPEC> {
                UEP_R_AUTOTOG_W::new(self, 5)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///endpoint 0 rx control
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`uep0_rx_ctrl::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep0_rx_ctrl::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct UEP0_RX_CTRL_SPEC;
        impl crate::RegisterSpec for UEP0_RX_CTRL_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`uep0_rx_ctrl::R`](R) reader structure
        impl crate::Readable for UEP0_RX_CTRL_SPEC {}
        ///`write(|w| ..)` method takes [`uep0_rx_ctrl::W`](W) writer structure
        impl crate::Writable for UEP0_RX_CTRL_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets UEP0_RX_CTRL to value 0
        impl crate::Resettable for UEP0_RX_CTRL_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///UEP1_T_LEN (rw) register accessor: endpoint 1 transmittal length
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`uep1_t_len::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep1_t_len::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@uep1_t_len`]
    ///module
    pub type UEP1_T_LEN = crate::Reg<uep1_t_len::UEP1_T_LEN_SPEC>;
    ///endpoint 1 transmittal length
    pub mod uep1_t_len {
        ///Register `UEP1_T_LEN` reader
        pub type R = crate::R<UEP1_T_LEN_SPEC>;
        ///Register `UEP1_T_LEN` writer
        pub type W = crate::W<UEP1_T_LEN_SPEC>;
        ///Field `UEP1_T_LEN` reader - endpoint 1 transmittal length
        pub type UEP1_T_LEN_R = crate::FieldReader<u16>;
        ///Field `UEP1_T_LEN` writer - endpoint 1 transmittal length
        pub type UEP1_T_LEN_W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            ///Bits 0:15 - endpoint 1 transmittal length
            #[inline(always)]
            pub fn uep1_t_len(&self) -> UEP1_T_LEN_R {
                UEP1_T_LEN_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - endpoint 1 transmittal length
            #[inline(always)]
            #[must_use]
            pub fn uep1_t_len(&mut self) -> UEP1_T_LEN_W<UEP1_T_LEN_SPEC> {
                UEP1_T_LEN_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///endpoint 1 transmittal length
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`uep1_t_len::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep1_t_len::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct UEP1_T_LEN_SPEC;
        impl crate::RegisterSpec for UEP1_T_LEN_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`uep1_t_len::R`](R) reader structure
        impl crate::Readable for UEP1_T_LEN_SPEC {}
        ///`write(|w| ..)` method takes [`uep1_t_len::W`](W) writer structure
        impl crate::Writable for UEP1_T_LEN_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets UEP1_T_LEN to value 0
        impl crate::Resettable for UEP1_T_LEN_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///UEP1_TX_CTRL (rw) register accessor: endpoint 1 tx control
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`uep1_tx_ctrl::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep1_tx_ctrl::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@uep1_tx_ctrl`]
    ///module
    pub type UEP1_TX_CTRL = crate::Reg<uep1_tx_ctrl::UEP1_TX_CTRL_SPEC>;
    ///endpoint 1 tx control
    pub mod uep1_tx_ctrl {
        ///Register `UEP1_TX_CTRL` reader
        pub type R = crate::R<UEP1_TX_CTRL_SPEC>;
        ///Register `UEP1_TX_CTRL` writer
        pub type W = crate::W<UEP1_TX_CTRL_SPEC>;
        ///Field `UEP_TRES_MASK` reader - bit mask of handshake response type for USB endpoint X transmittal (IN)
        pub type UEP_TRES_MASK_R = crate::FieldReader;
        ///Field `UEP_TRES_MASK` writer - bit mask of handshake response type for USB endpoint X transmittal (IN)
        pub type UEP_TRES_MASK_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `UEP_TRES_NO` reader - expected no response
        pub type UEP_TRES_NO_R = crate::BitReader;
        ///Field `UEP_TRES_NO` writer - expected no response
        pub type UEP_TRES_NO_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UEP_T_TOG_MASK` reader - prepared data toggle flag of USB endpoint X transmittal
        pub type UEP_T_TOG_MASK_R = crate::FieldReader;
        ///Field `UEP_T_TOG_MASK` writer - prepared data toggle flag of USB endpoint X transmittal
        pub type UEP_T_TOG_MASK_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `UEP_T_AUTOTOG` reader - enable automatic toggle after successful transfer completion on endpoint 0
        pub type UEP_T_AUTOTOG_R = crate::BitReader;
        ///Field `UEP_T_AUTOTOG` writer - enable automatic toggle after successful transfer completion on endpoint 0
        pub type UEP_T_AUTOTOG_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)
            #[inline(always)]
            pub fn uep_tres_mask(&self) -> UEP_TRES_MASK_R {
                UEP_TRES_MASK_R::new(self.bits & 3)
            }
            ///Bit 2 - expected no response
            #[inline(always)]
            pub fn uep_tres_no(&self) -> UEP_TRES_NO_R {
                UEP_TRES_NO_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bits 3:4 - prepared data toggle flag of USB endpoint X transmittal
            #[inline(always)]
            pub fn uep_t_tog_mask(&self) -> UEP_T_TOG_MASK_R {
                UEP_T_TOG_MASK_R::new((self.bits >> 3) & 3)
            }
            ///Bit 5 - enable automatic toggle after successful transfer completion on endpoint 0
            #[inline(always)]
            pub fn uep_t_autotog(&self) -> UEP_T_AUTOTOG_R {
                UEP_T_AUTOTOG_R::new(((self.bits >> 5) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)
            #[inline(always)]
            #[must_use]
            pub fn uep_tres_mask(&mut self) -> UEP_TRES_MASK_W<UEP1_TX_CTRL_SPEC> {
                UEP_TRES_MASK_W::new(self, 0)
            }
            ///Bit 2 - expected no response
            #[inline(always)]
            #[must_use]
            pub fn uep_tres_no(&mut self) -> UEP_TRES_NO_W<UEP1_TX_CTRL_SPEC> {
                UEP_TRES_NO_W::new(self, 2)
            }
            ///Bits 3:4 - prepared data toggle flag of USB endpoint X transmittal
            #[inline(always)]
            #[must_use]
            pub fn uep_t_tog_mask(&mut self) -> UEP_T_TOG_MASK_W<UEP1_TX_CTRL_SPEC> {
                UEP_T_TOG_MASK_W::new(self, 3)
            }
            ///Bit 5 - enable automatic toggle after successful transfer completion on endpoint 0
            #[inline(always)]
            #[must_use]
            pub fn uep_t_autotog(&mut self) -> UEP_T_AUTOTOG_W<UEP1_TX_CTRL_SPEC> {
                UEP_T_AUTOTOG_W::new(self, 5)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///endpoint 1 tx control
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`uep1_tx_ctrl::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep1_tx_ctrl::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct UEP1_TX_CTRL_SPEC;
        impl crate::RegisterSpec for UEP1_TX_CTRL_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`uep1_tx_ctrl::R`](R) reader structure
        impl crate::Readable for UEP1_TX_CTRL_SPEC {}
        ///`write(|w| ..)` method takes [`uep1_tx_ctrl::W`](W) writer structure
        impl crate::Writable for UEP1_TX_CTRL_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets UEP1_TX_CTRL to value 0
        impl crate::Resettable for UEP1_TX_CTRL_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///UEP1_RX_CTRL (rw) register accessor: endpoint 1 rx control
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`uep1_rx_ctrl::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep1_rx_ctrl::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@uep1_rx_ctrl`]
    ///module
    pub type UEP1_RX_CTRL = crate::Reg<uep1_rx_ctrl::UEP1_RX_CTRL_SPEC>;
    ///endpoint 1 rx control
    pub mod uep1_rx_ctrl {
        ///Register `UEP1_RX_CTRL` reader
        pub type R = crate::R<UEP1_RX_CTRL_SPEC>;
        ///Register `UEP1_RX_CTRL` writer
        pub type W = crate::W<UEP1_RX_CTRL_SPEC>;
        ///Field `UEP_RRES_MASK` reader - bit mask of handshake response type for USB endpoint X receiving (OUT)
        pub type UEP_RRES_MASK_R = crate::FieldReader;
        ///Field `UEP_RRES_MASK` writer - bit mask of handshake response type for USB endpoint X receiving (OUT)
        pub type UEP_RRES_MASK_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `UEP_RRES_NO` reader - prepared no response
        pub type UEP_RRES_NO_R = crate::BitReader;
        ///Field `UEP_RRES_NO` writer - prepared no response
        pub type UEP_RRES_NO_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UEP_R_TOG_MASK` reader - expected data toggle flag of USB endpoint X receiving
        pub type UEP_R_TOG_MASK_R = crate::FieldReader;
        ///Field `UEP_R_TOG_MASK` writer - expected data toggle flag of USB endpoint X receiving
        pub type UEP_R_TOG_MASK_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `UEP_R_AUTOTOG` reader - enable automatic toggle after successful transfer completion on endpoint
        pub type UEP_R_AUTOTOG_R = crate::BitReader;
        ///Field `UEP_R_AUTOTOG` writer - enable automatic toggle after successful transfer completion on endpoint
        pub type UEP_R_AUTOTOG_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bits 0:1 - bit mask of handshake response type for USB endpoint X receiving (OUT)
            #[inline(always)]
            pub fn uep_rres_mask(&self) -> UEP_RRES_MASK_R {
                UEP_RRES_MASK_R::new(self.bits & 3)
            }
            ///Bit 2 - prepared no response
            #[inline(always)]
            pub fn uep_rres_no(&self) -> UEP_RRES_NO_R {
                UEP_RRES_NO_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bits 3:4 - expected data toggle flag of USB endpoint X receiving
            #[inline(always)]
            pub fn uep_r_tog_mask(&self) -> UEP_R_TOG_MASK_R {
                UEP_R_TOG_MASK_R::new((self.bits >> 3) & 3)
            }
            ///Bit 5 - enable automatic toggle after successful transfer completion on endpoint
            #[inline(always)]
            pub fn uep_r_autotog(&self) -> UEP_R_AUTOTOG_R {
                UEP_R_AUTOTOG_R::new(((self.bits >> 5) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:1 - bit mask of handshake response type for USB endpoint X receiving (OUT)
            #[inline(always)]
            #[must_use]
            pub fn uep_rres_mask(&mut self) -> UEP_RRES_MASK_W<UEP1_RX_CTRL_SPEC> {
                UEP_RRES_MASK_W::new(self, 0)
            }
            ///Bit 2 - prepared no response
            #[inline(always)]
            #[must_use]
            pub fn uep_rres_no(&mut self) -> UEP_RRES_NO_W<UEP1_RX_CTRL_SPEC> {
                UEP_RRES_NO_W::new(self, 2)
            }
            ///Bits 3:4 - expected data toggle flag of USB endpoint X receiving
            #[inline(always)]
            #[must_use]
            pub fn uep_r_tog_mask(&mut self) -> UEP_R_TOG_MASK_W<UEP1_RX_CTRL_SPEC> {
                UEP_R_TOG_MASK_W::new(self, 3)
            }
            ///Bit 5 - enable automatic toggle after successful transfer completion on endpoint
            #[inline(always)]
            #[must_use]
            pub fn uep_r_autotog(&mut self) -> UEP_R_AUTOTOG_W<UEP1_RX_CTRL_SPEC> {
                UEP_R_AUTOTOG_W::new(self, 5)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///endpoint 1 rx control
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`uep1_rx_ctrl::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep1_rx_ctrl::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct UEP1_RX_CTRL_SPEC;
        impl crate::RegisterSpec for UEP1_RX_CTRL_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`uep1_rx_ctrl::R`](R) reader structure
        impl crate::Readable for UEP1_RX_CTRL_SPEC {}
        ///`write(|w| ..)` method takes [`uep1_rx_ctrl::W`](W) writer structure
        impl crate::Writable for UEP1_RX_CTRL_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets UEP1_RX_CTRL to value 0
        impl crate::Resettable for UEP1_RX_CTRL_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///UEP2_T_LEN_R16_UH_EP_PID (rw) register accessor: endpoint 2 transmittal length and Set usb host token register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`uep2_t_len_r16_uh_ep_pid::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep2_t_len_r16_uh_ep_pid::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@uep2_t_len_r16_uh_ep_pid`]
    ///module
    pub type UEP2_T_LEN_R16_UH_EP_PID =
        crate::Reg<uep2_t_len_r16_uh_ep_pid::UEP2_T_LEN_R16_UH_EP_PID_SPEC>;
    ///endpoint 2 transmittal length and Set usb host token register
    pub mod uep2_t_len_r16_uh_ep_pid {
        ///Register `UEP2_T_LEN_R16_UH_EP_PID` reader
        pub type R = crate::R<UEP2_T_LEN_R16_UH_EP_PID_SPEC>;
        ///Register `UEP2_T_LEN_R16_UH_EP_PID` writer
        pub type W = crate::W<UEP2_T_LEN_R16_UH_EP_PID_SPEC>;
        ///Field `UH_EPNUM_MASK` reader - The endpoint number of the target of this operation
        pub type UH_EPNUM_MASK_R = crate::FieldReader;
        ///Field `UH_EPNUM_MASK` writer - The endpoint number of the target of this operation
        pub type UH_EPNUM_MASK_W<'a, REG> = crate::FieldWriter<'a, REG, 4>;
        ///Field `UEP2_T_LEN` reader - endpoint 2 transmittal length
        pub type UEP2_T_LEN_R = crate::FieldReader<u16>;
        ///Field `UEP2_T_LEN` writer - endpoint 2 transmittal length
        pub type UEP2_T_LEN_W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        ///Field `UH_TOKEN_MASK` reader - The token PID packet identification of this USB transfer transaction
        pub type UH_TOKEN_MASK_R = crate::FieldReader;
        ///Field `UH_TOKEN_MASK` writer - The token PID packet identification of this USB transfer transaction
        pub type UH_TOKEN_MASK_W<'a, REG> = crate::FieldWriter<'a, REG, 4>;
        impl R {
            ///Bits 0:3 - The endpoint number of the target of this operation
            #[inline(always)]
            pub fn uh_epnum_mask(&self) -> UH_EPNUM_MASK_R {
                UH_EPNUM_MASK_R::new((self.bits & 0x0f) as u8)
            }
            ///Bits 0:15 - endpoint 2 transmittal length
            #[inline(always)]
            pub fn uep2_t_len(&self) -> UEP2_T_LEN_R {
                UEP2_T_LEN_R::new(self.bits)
            }
            ///Bits 4:7 - The token PID packet identification of this USB transfer transaction
            #[inline(always)]
            pub fn uh_token_mask(&self) -> UH_TOKEN_MASK_R {
                UH_TOKEN_MASK_R::new(((self.bits >> 4) & 0x0f) as u8)
            }
        }
        impl W {
            ///Bits 0:3 - The endpoint number of the target of this operation
            #[inline(always)]
            #[must_use]
            pub fn uh_epnum_mask(&mut self) -> UH_EPNUM_MASK_W<UEP2_T_LEN_R16_UH_EP_PID_SPEC> {
                UH_EPNUM_MASK_W::new(self, 0)
            }
            ///Bits 0:15 - endpoint 2 transmittal length
            #[inline(always)]
            #[must_use]
            pub fn uep2_t_len(&mut self) -> UEP2_T_LEN_W<UEP2_T_LEN_R16_UH_EP_PID_SPEC> {
                UEP2_T_LEN_W::new(self, 0)
            }
            ///Bits 4:7 - The token PID packet identification of this USB transfer transaction
            #[inline(always)]
            #[must_use]
            pub fn uh_token_mask(&mut self) -> UH_TOKEN_MASK_W<UEP2_T_LEN_R16_UH_EP_PID_SPEC> {
                UH_TOKEN_MASK_W::new(self, 4)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///endpoint 2 transmittal length and Set usb host token register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`uep2_t_len_r16_uh_ep_pid::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep2_t_len_r16_uh_ep_pid::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct UEP2_T_LEN_R16_UH_EP_PID_SPEC;
        impl crate::RegisterSpec for UEP2_T_LEN_R16_UH_EP_PID_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`uep2_t_len_r16_uh_ep_pid::R`](R) reader structure
        impl crate::Readable for UEP2_T_LEN_R16_UH_EP_PID_SPEC {}
        ///`write(|w| ..)` method takes [`uep2_t_len_r16_uh_ep_pid::W`](W) writer structure
        impl crate::Writable for UEP2_T_LEN_R16_UH_EP_PID_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets UEP2_T_LEN_R16_UH_EP_PID to value 0
        impl crate::Resettable for UEP2_T_LEN_R16_UH_EP_PID_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///UEP2_TX_CTRL (rw) register accessor: endpoint 2 tx control
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`uep2_tx_ctrl::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep2_tx_ctrl::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@uep2_tx_ctrl`]
    ///module
    pub type UEP2_TX_CTRL = crate::Reg<uep2_tx_ctrl::UEP2_TX_CTRL_SPEC>;
    ///endpoint 2 tx control
    pub mod uep2_tx_ctrl {
        ///Register `UEP2_TX_CTRL` reader
        pub type R = crate::R<UEP2_TX_CTRL_SPEC>;
        ///Register `UEP2_TX_CTRL` writer
        pub type W = crate::W<UEP2_TX_CTRL_SPEC>;
        ///Field `UEP_TRES_MASK` reader - bit mask of handshake response type for USB endpoint X transmittal (IN)
        pub type UEP_TRES_MASK_R = crate::FieldReader;
        ///Field `UEP_TRES_MASK` writer - bit mask of handshake response type for USB endpoint X transmittal (IN)
        pub type UEP_TRES_MASK_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `UEP_TRES_NO` reader - expected no response
        pub type UEP_TRES_NO_R = crate::BitReader;
        ///Field `UEP_TRES_NO` writer - expected no response
        pub type UEP_TRES_NO_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UEP_T_TOG_MASK` reader - prepared data toggle flag of USB endpoint X transmittal
        pub type UEP_T_TOG_MASK_R = crate::FieldReader;
        ///Field `UEP_T_TOG_MASK` writer - prepared data toggle flag of USB endpoint X transmittal
        pub type UEP_T_TOG_MASK_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `UEP_T_AUTOTOG` reader - enable automatic toggle after successful transfer completion on endpoint 0
        pub type UEP_T_AUTOTOG_R = crate::BitReader;
        ///Field `UEP_T_AUTOTOG` writer - enable automatic toggle after successful transfer completion on endpoint 0
        pub type UEP_T_AUTOTOG_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)
            #[inline(always)]
            pub fn uep_tres_mask(&self) -> UEP_TRES_MASK_R {
                UEP_TRES_MASK_R::new(self.bits & 3)
            }
            ///Bit 2 - expected no response
            #[inline(always)]
            pub fn uep_tres_no(&self) -> UEP_TRES_NO_R {
                UEP_TRES_NO_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bits 3:4 - prepared data toggle flag of USB endpoint X transmittal
            #[inline(always)]
            pub fn uep_t_tog_mask(&self) -> UEP_T_TOG_MASK_R {
                UEP_T_TOG_MASK_R::new((self.bits >> 3) & 3)
            }
            ///Bit 5 - enable automatic toggle after successful transfer completion on endpoint 0
            #[inline(always)]
            pub fn uep_t_autotog(&self) -> UEP_T_AUTOTOG_R {
                UEP_T_AUTOTOG_R::new(((self.bits >> 5) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)
            #[inline(always)]
            #[must_use]
            pub fn uep_tres_mask(&mut self) -> UEP_TRES_MASK_W<UEP2_TX_CTRL_SPEC> {
                UEP_TRES_MASK_W::new(self, 0)
            }
            ///Bit 2 - expected no response
            #[inline(always)]
            #[must_use]
            pub fn uep_tres_no(&mut self) -> UEP_TRES_NO_W<UEP2_TX_CTRL_SPEC> {
                UEP_TRES_NO_W::new(self, 2)
            }
            ///Bits 3:4 - prepared data toggle flag of USB endpoint X transmittal
            #[inline(always)]
            #[must_use]
            pub fn uep_t_tog_mask(&mut self) -> UEP_T_TOG_MASK_W<UEP2_TX_CTRL_SPEC> {
                UEP_T_TOG_MASK_W::new(self, 3)
            }
            ///Bit 5 - enable automatic toggle after successful transfer completion on endpoint 0
            #[inline(always)]
            #[must_use]
            pub fn uep_t_autotog(&mut self) -> UEP_T_AUTOTOG_W<UEP2_TX_CTRL_SPEC> {
                UEP_T_AUTOTOG_W::new(self, 5)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///endpoint 2 tx control
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`uep2_tx_ctrl::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep2_tx_ctrl::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct UEP2_TX_CTRL_SPEC;
        impl crate::RegisterSpec for UEP2_TX_CTRL_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`uep2_tx_ctrl::R`](R) reader structure
        impl crate::Readable for UEP2_TX_CTRL_SPEC {}
        ///`write(|w| ..)` method takes [`uep2_tx_ctrl::W`](W) writer structure
        impl crate::Writable for UEP2_TX_CTRL_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets UEP2_TX_CTRL to value 0
        impl crate::Resettable for UEP2_TX_CTRL_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///UEP2_RX_CTRL_R8_UH_RX_CTRL (rw) register accessor: endpoint 2 rx control and USb host receive endpoint control register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`uep2_rx_ctrl_r8_uh_rx_ctrl::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep2_rx_ctrl_r8_uh_rx_ctrl::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@uep2_rx_ctrl_r8_uh_rx_ctrl`]
    ///module
    pub type UEP2_RX_CTRL_R8_UH_RX_CTRL =
        crate::Reg<uep2_rx_ctrl_r8_uh_rx_ctrl::UEP2_RX_CTRL_R8_UH_RX_CTRL_SPEC>;
    ///endpoint 2 rx control and USb host receive endpoint control register
    pub mod uep2_rx_ctrl_r8_uh_rx_ctrl {
        ///Register `UEP2_RX_CTRL_R8_UH_RX_CTRL` reader
        pub type R = crate::R<UEP2_RX_CTRL_R8_UH_RX_CTRL_SPEC>;
        ///Register `UEP2_RX_CTRL_R8_UH_RX_CTRL` writer
        pub type W = crate::W<UEP2_RX_CTRL_R8_UH_RX_CTRL_SPEC>;
        ///Field `UEP_RRES_MASK_RB_UH_RRES_MASK` reader - bit mask of handshake response type for USB endpoint X receiving (OUT) and Host reeiver response control bit
        pub type UEP_RRES_MASK_RB_UH_RRES_MASK_R = crate::FieldReader;
        ///Field `UEP_RRES_MASK_RB_UH_RRES_MASK` writer - bit mask of handshake response type for USB endpoint X receiving (OUT) and Host reeiver response control bit
        pub type UEP_RRES_MASK_RB_UH_RRES_MASK_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `UEP_RRES_NO_RB_UH_RRES_NO` reader - Prepared no response and Response control bit of host receiver
        pub type UEP_RRES_NO_RB_UH_RRES_NO_R = crate::BitReader;
        ///Field `UEP_RRES_NO_RB_UH_RRES_NO` writer - Prepared no response and Response control bit of host receiver
        pub type UEP_RRES_NO_RB_UH_RRES_NO_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UEP_R_TOG_MASK_RB_UH_R_TOG_MASK` reader - expected data toggle flag of USB endpoint X receiving and expected data toggle flag of host receiving (IN)
        pub type UEP_R_TOG_MASK_RB_UH_R_TOG_MASK_R = crate::FieldReader;
        ///Field `UEP_R_TOG_MASK_RB_UH_R_TOG_MASK` writer - expected data toggle flag of USB endpoint X receiving and expected data toggle flag of host receiving (IN)
        pub type UEP_R_TOG_MASK_RB_UH_R_TOG_MASK_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `UEP_R_AUTOTOG_RB_UH_R_AUTOTOG` reader - enable automatic toggle after successful transfer completion on endpoint and enable automatic toggle after successful receiver completion
        pub type UEP_R_AUTOTOG_RB_UH_R_AUTOTOG_R = crate::BitReader;
        ///Field `UEP_R_AUTOTOG_RB_UH_R_AUTOTOG` writer - enable automatic toggle after successful transfer completion on endpoint and enable automatic toggle after successful receiver completion
        pub type UEP_R_AUTOTOG_RB_UH_R_AUTOTOG_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UH_RDATA_NO` reader - expect no data packet, for high speed hub in host mode
        pub type UH_RDATA_NO_R = crate::BitReader;
        ///Field `UH_RDATA_NO` writer - expect no data packet, for high speed hub in host mode
        pub type UH_RDATA_NO_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bits 0:1 - bit mask of handshake response type for USB endpoint X receiving (OUT) and Host reeiver response control bit
            #[inline(always)]
            pub fn uep_rres_mask_rb_uh_rres_mask(&self) -> UEP_RRES_MASK_RB_UH_RRES_MASK_R {
                UEP_RRES_MASK_RB_UH_RRES_MASK_R::new(self.bits & 3)
            }
            ///Bit 2 - Prepared no response and Response control bit of host receiver
            #[inline(always)]
            pub fn uep_rres_no_rb_uh_rres_no(&self) -> UEP_RRES_NO_RB_UH_RRES_NO_R {
                UEP_RRES_NO_RB_UH_RRES_NO_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bits 3:4 - expected data toggle flag of USB endpoint X receiving and expected data toggle flag of host receiving (IN)
            #[inline(always)]
            pub fn uep_r_tog_mask_rb_uh_r_tog_mask(&self) -> UEP_R_TOG_MASK_RB_UH_R_TOG_MASK_R {
                UEP_R_TOG_MASK_RB_UH_R_TOG_MASK_R::new((self.bits >> 3) & 3)
            }
            ///Bit 5 - enable automatic toggle after successful transfer completion on endpoint and enable automatic toggle after successful receiver completion
            #[inline(always)]
            pub fn uep_r_autotog_rb_uh_r_autotog(&self) -> UEP_R_AUTOTOG_RB_UH_R_AUTOTOG_R {
                UEP_R_AUTOTOG_RB_UH_R_AUTOTOG_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - expect no data packet, for high speed hub in host mode
            #[inline(always)]
            pub fn uh_rdata_no(&self) -> UH_RDATA_NO_R {
                UH_RDATA_NO_R::new(((self.bits >> 6) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:1 - bit mask of handshake response type for USB endpoint X receiving (OUT) and Host reeiver response control bit
            #[inline(always)]
            #[must_use]
            pub fn uep_rres_mask_rb_uh_rres_mask(
                &mut self,
            ) -> UEP_RRES_MASK_RB_UH_RRES_MASK_W<UEP2_RX_CTRL_R8_UH_RX_CTRL_SPEC> {
                UEP_RRES_MASK_RB_UH_RRES_MASK_W::new(self, 0)
            }
            ///Bit 2 - Prepared no response and Response control bit of host receiver
            #[inline(always)]
            #[must_use]
            pub fn uep_rres_no_rb_uh_rres_no(
                &mut self,
            ) -> UEP_RRES_NO_RB_UH_RRES_NO_W<UEP2_RX_CTRL_R8_UH_RX_CTRL_SPEC> {
                UEP_RRES_NO_RB_UH_RRES_NO_W::new(self, 2)
            }
            ///Bits 3:4 - expected data toggle flag of USB endpoint X receiving and expected data toggle flag of host receiving (IN)
            #[inline(always)]
            #[must_use]
            pub fn uep_r_tog_mask_rb_uh_r_tog_mask(
                &mut self,
            ) -> UEP_R_TOG_MASK_RB_UH_R_TOG_MASK_W<UEP2_RX_CTRL_R8_UH_RX_CTRL_SPEC> {
                UEP_R_TOG_MASK_RB_UH_R_TOG_MASK_W::new(self, 3)
            }
            ///Bit 5 - enable automatic toggle after successful transfer completion on endpoint and enable automatic toggle after successful receiver completion
            #[inline(always)]
            #[must_use]
            pub fn uep_r_autotog_rb_uh_r_autotog(
                &mut self,
            ) -> UEP_R_AUTOTOG_RB_UH_R_AUTOTOG_W<UEP2_RX_CTRL_R8_UH_RX_CTRL_SPEC> {
                UEP_R_AUTOTOG_RB_UH_R_AUTOTOG_W::new(self, 5)
            }
            ///Bit 6 - expect no data packet, for high speed hub in host mode
            #[inline(always)]
            #[must_use]
            pub fn uh_rdata_no(&mut self) -> UH_RDATA_NO_W<UEP2_RX_CTRL_R8_UH_RX_CTRL_SPEC> {
                UH_RDATA_NO_W::new(self, 6)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///endpoint 2 rx control and USb host receive endpoint control register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`uep2_rx_ctrl_r8_uh_rx_ctrl::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep2_rx_ctrl_r8_uh_rx_ctrl::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct UEP2_RX_CTRL_R8_UH_RX_CTRL_SPEC;
        impl crate::RegisterSpec for UEP2_RX_CTRL_R8_UH_RX_CTRL_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`uep2_rx_ctrl_r8_uh_rx_ctrl::R`](R) reader structure
        impl crate::Readable for UEP2_RX_CTRL_R8_UH_RX_CTRL_SPEC {}
        ///`write(|w| ..)` method takes [`uep2_rx_ctrl_r8_uh_rx_ctrl::W`](W) writer structure
        impl crate::Writable for UEP2_RX_CTRL_R8_UH_RX_CTRL_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets UEP2_RX_CTRL_R8_UH_RX_CTRL to value 0
        impl crate::Resettable for UEP2_RX_CTRL_R8_UH_RX_CTRL_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///UEP3_T_LEN_R16_UH_TX_LEN (rw) register accessor: endpoint 3 transmittal length and host transmittal endpoint transmittal length
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`uep3_t_len_r16_uh_tx_len::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep3_t_len_r16_uh_tx_len::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@uep3_t_len_r16_uh_tx_len`]
    ///module
    pub type UEP3_T_LEN_R16_UH_TX_LEN =
        crate::Reg<uep3_t_len_r16_uh_tx_len::UEP3_T_LEN_R16_UH_TX_LEN_SPEC>;
    ///endpoint 3 transmittal length and host transmittal endpoint transmittal length
    pub mod uep3_t_len_r16_uh_tx_len {
        ///Register `UEP3_T_LEN_R16_UH_TX_LEN` reader
        pub type R = crate::R<UEP3_T_LEN_R16_UH_TX_LEN_SPEC>;
        ///Register `UEP3_T_LEN_R16_UH_TX_LEN` writer
        pub type W = crate::W<UEP3_T_LEN_R16_UH_TX_LEN_SPEC>;
        ///Field `UEP3_T_LEN_UH_TX_LEN` reader - endpoint 3 transmittal length and host transmittal endpoint transmittal length
        pub type UEP3_T_LEN_UH_TX_LEN_R = crate::FieldReader<u16>;
        ///Field `UEP3_T_LEN_UH_TX_LEN` writer - endpoint 3 transmittal length and host transmittal endpoint transmittal length
        pub type UEP3_T_LEN_UH_TX_LEN_W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            ///Bits 0:15 - endpoint 3 transmittal length and host transmittal endpoint transmittal length
            #[inline(always)]
            pub fn uep3_t_len_uh_tx_len(&self) -> UEP3_T_LEN_UH_TX_LEN_R {
                UEP3_T_LEN_UH_TX_LEN_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - endpoint 3 transmittal length and host transmittal endpoint transmittal length
            #[inline(always)]
            #[must_use]
            pub fn uep3_t_len_uh_tx_len(
                &mut self,
            ) -> UEP3_T_LEN_UH_TX_LEN_W<UEP3_T_LEN_R16_UH_TX_LEN_SPEC> {
                UEP3_T_LEN_UH_TX_LEN_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///endpoint 3 transmittal length and host transmittal endpoint transmittal length
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`uep3_t_len_r16_uh_tx_len::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep3_t_len_r16_uh_tx_len::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct UEP3_T_LEN_R16_UH_TX_LEN_SPEC;
        impl crate::RegisterSpec for UEP3_T_LEN_R16_UH_TX_LEN_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`uep3_t_len_r16_uh_tx_len::R`](R) reader structure
        impl crate::Readable for UEP3_T_LEN_R16_UH_TX_LEN_SPEC {}
        ///`write(|w| ..)` method takes [`uep3_t_len_r16_uh_tx_len::W`](W) writer structure
        impl crate::Writable for UEP3_T_LEN_R16_UH_TX_LEN_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets UEP3_T_LEN_R16_UH_TX_LEN to value 0
        impl crate::Resettable for UEP3_T_LEN_R16_UH_TX_LEN_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///UEP3_TX_CTRL_R8_UH_TX_CTRL (rw) register accessor: endpoint 3 tx control and host transmittal endpoint control
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`uep3_tx_ctrl_r8_uh_tx_ctrl::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep3_tx_ctrl_r8_uh_tx_ctrl::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@uep3_tx_ctrl_r8_uh_tx_ctrl`]
    ///module
    pub type UEP3_TX_CTRL_R8_UH_TX_CTRL =
        crate::Reg<uep3_tx_ctrl_r8_uh_tx_ctrl::UEP3_TX_CTRL_R8_UH_TX_CTRL_SPEC>;
    ///endpoint 3 tx control and host transmittal endpoint control
    pub mod uep3_tx_ctrl_r8_uh_tx_ctrl {
        ///Register `UEP3_TX_CTRL_R8_UH_TX_CTRL` reader
        pub type R = crate::R<UEP3_TX_CTRL_R8_UH_TX_CTRL_SPEC>;
        ///Register `UEP3_TX_CTRL_R8_UH_TX_CTRL` writer
        pub type W = crate::W<UEP3_TX_CTRL_R8_UH_TX_CTRL_SPEC>;
        ///Field `UEP_TRES_MASK_RB_UH_TRES_MASK` reader - bit mask of handshake response type for USB endpoint X transmittal (IN) and expected handshake response type for host transmittal (SETUP/OUT)
        pub type UEP_TRES_MASK_RB_UH_TRES_MASK_R = crate::FieldReader;
        ///Field `UEP_TRES_MASK_RB_UH_TRES_MASK` writer - bit mask of handshake response type for USB endpoint X transmittal (IN) and expected handshake response type for host transmittal (SETUP/OUT)
        pub type UEP_TRES_MASK_RB_UH_TRES_MASK_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `UEP_TRES_NO_RB_UH_TRES_NO` reader - expected no response and expected no response, 1=enable, 0=disable, for non-zero endpoint isochronous transactions
        pub type UEP_TRES_NO_RB_UH_TRES_NO_R = crate::BitReader;
        ///Field `UEP_TRES_NO_RB_UH_TRES_NO` writer - expected no response and expected no response, 1=enable, 0=disable, for non-zero endpoint isochronous transactions
        pub type UEP_TRES_NO_RB_UH_TRES_NO_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UEP_T_TOG_MASK_RB_UH_T_TOG_MASK` reader - prepared data toggle flag of USB endpoint X transmittal and prepared data toggle flag of host transmittal (SETUP/OUT)
        pub type UEP_T_TOG_MASK_RB_UH_T_TOG_MASK_R = crate::FieldReader;
        ///Field `UEP_T_TOG_MASK_RB_UH_T_TOG_MASK` writer - prepared data toggle flag of USB endpoint X transmittal and prepared data toggle flag of host transmittal (SETUP/OUT)
        pub type UEP_T_TOG_MASK_RB_UH_T_TOG_MASK_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `UEP_T_AUTOTOG_RB_UH_T_AUTOTOG` reader - enable automatic toggle after successful transfer completion on endpoint 0 and enable automatic toggle after successful transfer completion
        pub type UEP_T_AUTOTOG_RB_UH_T_AUTOTOG_R = crate::BitReader;
        ///Field `UEP_T_AUTOTOG_RB_UH_T_AUTOTOG` writer - enable automatic toggle after successful transfer completion on endpoint 0 and enable automatic toggle after successful transfer completion
        pub type UEP_T_AUTOTOG_RB_UH_T_AUTOTOG_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UH_TDATA_NO` reader - prepared no data packet, for high speed hub in host mode
        pub type UH_TDATA_NO_R = crate::BitReader;
        ///Field `UH_TDATA_NO` writer - prepared no data packet, for high speed hub in host mode
        pub type UH_TDATA_NO_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN) and expected handshake response type for host transmittal (SETUP/OUT)
            #[inline(always)]
            pub fn uep_tres_mask_rb_uh_tres_mask(&self) -> UEP_TRES_MASK_RB_UH_TRES_MASK_R {
                UEP_TRES_MASK_RB_UH_TRES_MASK_R::new(self.bits & 3)
            }
            ///Bit 2 - expected no response and expected no response, 1=enable, 0=disable, for non-zero endpoint isochronous transactions
            #[inline(always)]
            pub fn uep_tres_no_rb_uh_tres_no(&self) -> UEP_TRES_NO_RB_UH_TRES_NO_R {
                UEP_TRES_NO_RB_UH_TRES_NO_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bits 3:4 - prepared data toggle flag of USB endpoint X transmittal and prepared data toggle flag of host transmittal (SETUP/OUT)
            #[inline(always)]
            pub fn uep_t_tog_mask_rb_uh_t_tog_mask(&self) -> UEP_T_TOG_MASK_RB_UH_T_TOG_MASK_R {
                UEP_T_TOG_MASK_RB_UH_T_TOG_MASK_R::new((self.bits >> 3) & 3)
            }
            ///Bit 5 - enable automatic toggle after successful transfer completion on endpoint 0 and enable automatic toggle after successful transfer completion
            #[inline(always)]
            pub fn uep_t_autotog_rb_uh_t_autotog(&self) -> UEP_T_AUTOTOG_RB_UH_T_AUTOTOG_R {
                UEP_T_AUTOTOG_RB_UH_T_AUTOTOG_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - prepared no data packet, for high speed hub in host mode
            #[inline(always)]
            pub fn uh_tdata_no(&self) -> UH_TDATA_NO_R {
                UH_TDATA_NO_R::new(((self.bits >> 6) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN) and expected handshake response type for host transmittal (SETUP/OUT)
            #[inline(always)]
            #[must_use]
            pub fn uep_tres_mask_rb_uh_tres_mask(
                &mut self,
            ) -> UEP_TRES_MASK_RB_UH_TRES_MASK_W<UEP3_TX_CTRL_R8_UH_TX_CTRL_SPEC> {
                UEP_TRES_MASK_RB_UH_TRES_MASK_W::new(self, 0)
            }
            ///Bit 2 - expected no response and expected no response, 1=enable, 0=disable, for non-zero endpoint isochronous transactions
            #[inline(always)]
            #[must_use]
            pub fn uep_tres_no_rb_uh_tres_no(
                &mut self,
            ) -> UEP_TRES_NO_RB_UH_TRES_NO_W<UEP3_TX_CTRL_R8_UH_TX_CTRL_SPEC> {
                UEP_TRES_NO_RB_UH_TRES_NO_W::new(self, 2)
            }
            ///Bits 3:4 - prepared data toggle flag of USB endpoint X transmittal and prepared data toggle flag of host transmittal (SETUP/OUT)
            #[inline(always)]
            #[must_use]
            pub fn uep_t_tog_mask_rb_uh_t_tog_mask(
                &mut self,
            ) -> UEP_T_TOG_MASK_RB_UH_T_TOG_MASK_W<UEP3_TX_CTRL_R8_UH_TX_CTRL_SPEC> {
                UEP_T_TOG_MASK_RB_UH_T_TOG_MASK_W::new(self, 3)
            }
            ///Bit 5 - enable automatic toggle after successful transfer completion on endpoint 0 and enable automatic toggle after successful transfer completion
            #[inline(always)]
            #[must_use]
            pub fn uep_t_autotog_rb_uh_t_autotog(
                &mut self,
            ) -> UEP_T_AUTOTOG_RB_UH_T_AUTOTOG_W<UEP3_TX_CTRL_R8_UH_TX_CTRL_SPEC> {
                UEP_T_AUTOTOG_RB_UH_T_AUTOTOG_W::new(self, 5)
            }
            ///Bit 6 - prepared no data packet, for high speed hub in host mode
            #[inline(always)]
            #[must_use]
            pub fn uh_tdata_no(&mut self) -> UH_TDATA_NO_W<UEP3_TX_CTRL_R8_UH_TX_CTRL_SPEC> {
                UH_TDATA_NO_W::new(self, 6)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///endpoint 3 tx control and host transmittal endpoint control
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`uep3_tx_ctrl_r8_uh_tx_ctrl::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep3_tx_ctrl_r8_uh_tx_ctrl::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct UEP3_TX_CTRL_R8_UH_TX_CTRL_SPEC;
        impl crate::RegisterSpec for UEP3_TX_CTRL_R8_UH_TX_CTRL_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`uep3_tx_ctrl_r8_uh_tx_ctrl::R`](R) reader structure
        impl crate::Readable for UEP3_TX_CTRL_R8_UH_TX_CTRL_SPEC {}
        ///`write(|w| ..)` method takes [`uep3_tx_ctrl_r8_uh_tx_ctrl::W`](W) writer structure
        impl crate::Writable for UEP3_TX_CTRL_R8_UH_TX_CTRL_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets UEP3_TX_CTRL_R8_UH_TX_CTRL to value 0
        impl crate::Resettable for UEP3_TX_CTRL_R8_UH_TX_CTRL_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///UEP3_RX_CTRL (rw) register accessor: endpoint 3 rx control
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`uep3_rx_ctrl::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep3_rx_ctrl::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@uep3_rx_ctrl`]
    ///module
    pub type UEP3_RX_CTRL = crate::Reg<uep3_rx_ctrl::UEP3_RX_CTRL_SPEC>;
    ///endpoint 3 rx control
    pub mod uep3_rx_ctrl {
        ///Register `UEP3_RX_CTRL` reader
        pub type R = crate::R<UEP3_RX_CTRL_SPEC>;
        ///Register `UEP3_RX_CTRL` writer
        pub type W = crate::W<UEP3_RX_CTRL_SPEC>;
        ///Field `UEP_RRES_MASK` reader - bit mask of handshake response type for USB endpoint X receiving (OUT)
        pub type UEP_RRES_MASK_R = crate::FieldReader;
        ///Field `UEP_RRES_MASK` writer - bit mask of handshake response type for USB endpoint X receiving (OUT)
        pub type UEP_RRES_MASK_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `UEP_RRES_NO` reader - prepared no response
        pub type UEP_RRES_NO_R = crate::BitReader;
        ///Field `UEP_RRES_NO` writer - prepared no response
        pub type UEP_RRES_NO_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UEP_R_TOG_MASK` reader - expected data toggle flag of USB endpoint X receiving
        pub type UEP_R_TOG_MASK_R = crate::FieldReader;
        ///Field `UEP_R_TOG_MASK` writer - expected data toggle flag of USB endpoint X receiving
        pub type UEP_R_TOG_MASK_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `UEP_R_AUTOTOG` reader - enable automatic toggle after successful transfer completion on endpoint
        pub type UEP_R_AUTOTOG_R = crate::BitReader;
        ///Field `UEP_R_AUTOTOG` writer - enable automatic toggle after successful transfer completion on endpoint
        pub type UEP_R_AUTOTOG_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bits 0:1 - bit mask of handshake response type for USB endpoint X receiving (OUT)
            #[inline(always)]
            pub fn uep_rres_mask(&self) -> UEP_RRES_MASK_R {
                UEP_RRES_MASK_R::new(self.bits & 3)
            }
            ///Bit 2 - prepared no response
            #[inline(always)]
            pub fn uep_rres_no(&self) -> UEP_RRES_NO_R {
                UEP_RRES_NO_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bits 3:4 - expected data toggle flag of USB endpoint X receiving
            #[inline(always)]
            pub fn uep_r_tog_mask(&self) -> UEP_R_TOG_MASK_R {
                UEP_R_TOG_MASK_R::new((self.bits >> 3) & 3)
            }
            ///Bit 5 - enable automatic toggle after successful transfer completion on endpoint
            #[inline(always)]
            pub fn uep_r_autotog(&self) -> UEP_R_AUTOTOG_R {
                UEP_R_AUTOTOG_R::new(((self.bits >> 5) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:1 - bit mask of handshake response type for USB endpoint X receiving (OUT)
            #[inline(always)]
            #[must_use]
            pub fn uep_rres_mask(&mut self) -> UEP_RRES_MASK_W<UEP3_RX_CTRL_SPEC> {
                UEP_RRES_MASK_W::new(self, 0)
            }
            ///Bit 2 - prepared no response
            #[inline(always)]
            #[must_use]
            pub fn uep_rres_no(&mut self) -> UEP_RRES_NO_W<UEP3_RX_CTRL_SPEC> {
                UEP_RRES_NO_W::new(self, 2)
            }
            ///Bits 3:4 - expected data toggle flag of USB endpoint X receiving
            #[inline(always)]
            #[must_use]
            pub fn uep_r_tog_mask(&mut self) -> UEP_R_TOG_MASK_W<UEP3_RX_CTRL_SPEC> {
                UEP_R_TOG_MASK_W::new(self, 3)
            }
            ///Bit 5 - enable automatic toggle after successful transfer completion on endpoint
            #[inline(always)]
            #[must_use]
            pub fn uep_r_autotog(&mut self) -> UEP_R_AUTOTOG_W<UEP3_RX_CTRL_SPEC> {
                UEP_R_AUTOTOG_W::new(self, 5)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///endpoint 3 rx control
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`uep3_rx_ctrl::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep3_rx_ctrl::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct UEP3_RX_CTRL_SPEC;
        impl crate::RegisterSpec for UEP3_RX_CTRL_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`uep3_rx_ctrl::R`](R) reader structure
        impl crate::Readable for UEP3_RX_CTRL_SPEC {}
        ///`write(|w| ..)` method takes [`uep3_rx_ctrl::W`](W) writer structure
        impl crate::Writable for UEP3_RX_CTRL_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets UEP3_RX_CTRL to value 0
        impl crate::Resettable for UEP3_RX_CTRL_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///UEP4_T_LEN_R16_UH_SPLIT_DATA (rw) register accessor: endpoint 4 transmittal length and USB host Tx SPLIT packet data
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`uep4_t_len_r16_uh_split_data::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep4_t_len_r16_uh_split_data::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@uep4_t_len_r16_uh_split_data`]
    ///module
    pub type UEP4_T_LEN_R16_UH_SPLIT_DATA =
        crate::Reg<uep4_t_len_r16_uh_split_data::UEP4_T_LEN_R16_UH_SPLIT_DATA_SPEC>;
    ///endpoint 4 transmittal length and USB host Tx SPLIT packet data
    pub mod uep4_t_len_r16_uh_split_data {
        ///Register `UEP4_T_LEN_R16_UH_SPLIT_DATA` reader
        pub type R = crate::R<UEP4_T_LEN_R16_UH_SPLIT_DATA_SPEC>;
        ///Register `UEP4_T_LEN_R16_UH_SPLIT_DATA` writer
        pub type W = crate::W<UEP4_T_LEN_R16_UH_SPLIT_DATA_SPEC>;
        ///Field `UEP4_T_LEN_UH_SPLIT_DATA` reader - endpoint 4 transmittal length and USB host Tx SPLIT packet data
        pub type UEP4_T_LEN_UH_SPLIT_DATA_R = crate::FieldReader<u16>;
        ///Field `UEP4_T_LEN_UH_SPLIT_DATA` writer - endpoint 4 transmittal length and USB host Tx SPLIT packet data
        pub type UEP4_T_LEN_UH_SPLIT_DATA_W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            ///Bits 0:15 - endpoint 4 transmittal length and USB host Tx SPLIT packet data
            #[inline(always)]
            pub fn uep4_t_len_uh_split_data(&self) -> UEP4_T_LEN_UH_SPLIT_DATA_R {
                UEP4_T_LEN_UH_SPLIT_DATA_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - endpoint 4 transmittal length and USB host Tx SPLIT packet data
            #[inline(always)]
            #[must_use]
            pub fn uep4_t_len_uh_split_data(
                &mut self,
            ) -> UEP4_T_LEN_UH_SPLIT_DATA_W<UEP4_T_LEN_R16_UH_SPLIT_DATA_SPEC> {
                UEP4_T_LEN_UH_SPLIT_DATA_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///endpoint 4 transmittal length and USB host Tx SPLIT packet data
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`uep4_t_len_r16_uh_split_data::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep4_t_len_r16_uh_split_data::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct UEP4_T_LEN_R16_UH_SPLIT_DATA_SPEC;
        impl crate::RegisterSpec for UEP4_T_LEN_R16_UH_SPLIT_DATA_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`uep4_t_len_r16_uh_split_data::R`](R) reader structure
        impl crate::Readable for UEP4_T_LEN_R16_UH_SPLIT_DATA_SPEC {}
        ///`write(|w| ..)` method takes [`uep4_t_len_r16_uh_split_data::W`](W) writer structure
        impl crate::Writable for UEP4_T_LEN_R16_UH_SPLIT_DATA_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets UEP4_T_LEN_R16_UH_SPLIT_DATA to value 0
        impl crate::Resettable for UEP4_T_LEN_R16_UH_SPLIT_DATA_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///UEP4_TX_CTRL (rw) register accessor: endpoint 4 tx control
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`uep4_tx_ctrl::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep4_tx_ctrl::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@uep4_tx_ctrl`]
    ///module
    pub type UEP4_TX_CTRL = crate::Reg<uep4_tx_ctrl::UEP4_TX_CTRL_SPEC>;
    ///endpoint 4 tx control
    pub mod uep4_tx_ctrl {
        ///Register `UEP4_TX_CTRL` reader
        pub type R = crate::R<UEP4_TX_CTRL_SPEC>;
        ///Register `UEP4_TX_CTRL` writer
        pub type W = crate::W<UEP4_TX_CTRL_SPEC>;
        ///Field `UEP_TRES_MASK` reader - bit mask of handshake response type for USB endpoint X transmittal (IN)
        pub type UEP_TRES_MASK_R = crate::FieldReader;
        ///Field `UEP_TRES_MASK` writer - bit mask of handshake response type for USB endpoint X transmittal (IN)
        pub type UEP_TRES_MASK_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `UEP_TRES_NO` reader - expected no response
        pub type UEP_TRES_NO_R = crate::BitReader;
        ///Field `UEP_TRES_NO` writer - expected no response
        pub type UEP_TRES_NO_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UEP_T_TOG_MASK` reader - prepared data toggle flag of USB endpoint X transmittal
        pub type UEP_T_TOG_MASK_R = crate::FieldReader;
        ///Field `UEP_T_TOG_MASK` writer - prepared data toggle flag of USB endpoint X transmittal
        pub type UEP_T_TOG_MASK_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `UEP_T_AUTOTOG` reader - enable automatic toggle after successful transfer completion on endpoint 0
        pub type UEP_T_AUTOTOG_R = crate::BitReader;
        ///Field `UEP_T_AUTOTOG` writer - enable automatic toggle after successful transfer completion on endpoint 0
        pub type UEP_T_AUTOTOG_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)
            #[inline(always)]
            pub fn uep_tres_mask(&self) -> UEP_TRES_MASK_R {
                UEP_TRES_MASK_R::new(self.bits & 3)
            }
            ///Bit 2 - expected no response
            #[inline(always)]
            pub fn uep_tres_no(&self) -> UEP_TRES_NO_R {
                UEP_TRES_NO_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bits 3:4 - prepared data toggle flag of USB endpoint X transmittal
            #[inline(always)]
            pub fn uep_t_tog_mask(&self) -> UEP_T_TOG_MASK_R {
                UEP_T_TOG_MASK_R::new((self.bits >> 3) & 3)
            }
            ///Bit 5 - enable automatic toggle after successful transfer completion on endpoint 0
            #[inline(always)]
            pub fn uep_t_autotog(&self) -> UEP_T_AUTOTOG_R {
                UEP_T_AUTOTOG_R::new(((self.bits >> 5) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)
            #[inline(always)]
            #[must_use]
            pub fn uep_tres_mask(&mut self) -> UEP_TRES_MASK_W<UEP4_TX_CTRL_SPEC> {
                UEP_TRES_MASK_W::new(self, 0)
            }
            ///Bit 2 - expected no response
            #[inline(always)]
            #[must_use]
            pub fn uep_tres_no(&mut self) -> UEP_TRES_NO_W<UEP4_TX_CTRL_SPEC> {
                UEP_TRES_NO_W::new(self, 2)
            }
            ///Bits 3:4 - prepared data toggle flag of USB endpoint X transmittal
            #[inline(always)]
            #[must_use]
            pub fn uep_t_tog_mask(&mut self) -> UEP_T_TOG_MASK_W<UEP4_TX_CTRL_SPEC> {
                UEP_T_TOG_MASK_W::new(self, 3)
            }
            ///Bit 5 - enable automatic toggle after successful transfer completion on endpoint 0
            #[inline(always)]
            #[must_use]
            pub fn uep_t_autotog(&mut self) -> UEP_T_AUTOTOG_W<UEP4_TX_CTRL_SPEC> {
                UEP_T_AUTOTOG_W::new(self, 5)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///endpoint 4 tx control
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`uep4_tx_ctrl::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep4_tx_ctrl::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct UEP4_TX_CTRL_SPEC;
        impl crate::RegisterSpec for UEP4_TX_CTRL_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`uep4_tx_ctrl::R`](R) reader structure
        impl crate::Readable for UEP4_TX_CTRL_SPEC {}
        ///`write(|w| ..)` method takes [`uep4_tx_ctrl::W`](W) writer structure
        impl crate::Writable for UEP4_TX_CTRL_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets UEP4_TX_CTRL to value 0
        impl crate::Resettable for UEP4_TX_CTRL_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///UEP4_RX_CTRL (rw) register accessor: endpoint 4 rx control
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`uep4_rx_ctrl::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep4_rx_ctrl::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@uep4_rx_ctrl`]
    ///module
    pub type UEP4_RX_CTRL = crate::Reg<uep4_rx_ctrl::UEP4_RX_CTRL_SPEC>;
    ///endpoint 4 rx control
    pub mod uep4_rx_ctrl {
        ///Register `UEP4_RX_CTRL` reader
        pub type R = crate::R<UEP4_RX_CTRL_SPEC>;
        ///Register `UEP4_RX_CTRL` writer
        pub type W = crate::W<UEP4_RX_CTRL_SPEC>;
        ///Field `UEP_RRES_MASK` reader - bit mask of handshake response type for USB endpoint X receiving (OUT)
        pub type UEP_RRES_MASK_R = crate::FieldReader;
        ///Field `UEP_RRES_MASK` writer - bit mask of handshake response type for USB endpoint X receiving (OUT)
        pub type UEP_RRES_MASK_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `UEP_RRES_NO` reader - prepared no response
        pub type UEP_RRES_NO_R = crate::BitReader;
        ///Field `UEP_RRES_NO` writer - prepared no response
        pub type UEP_RRES_NO_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UEP_R_TOG_MASK` reader - expected data toggle flag of USB endpoint X receiving
        pub type UEP_R_TOG_MASK_R = crate::FieldReader;
        ///Field `UEP_R_TOG_MASK` writer - expected data toggle flag of USB endpoint X receiving
        pub type UEP_R_TOG_MASK_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `UEP_R_AUTOTOG` reader - enable automatic toggle after successful transfer completion on endpoint
        pub type UEP_R_AUTOTOG_R = crate::BitReader;
        ///Field `UEP_R_AUTOTOG` writer - enable automatic toggle after successful transfer completion on endpoint
        pub type UEP_R_AUTOTOG_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bits 0:1 - bit mask of handshake response type for USB endpoint X receiving (OUT)
            #[inline(always)]
            pub fn uep_rres_mask(&self) -> UEP_RRES_MASK_R {
                UEP_RRES_MASK_R::new(self.bits & 3)
            }
            ///Bit 2 - prepared no response
            #[inline(always)]
            pub fn uep_rres_no(&self) -> UEP_RRES_NO_R {
                UEP_RRES_NO_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bits 3:4 - expected data toggle flag of USB endpoint X receiving
            #[inline(always)]
            pub fn uep_r_tog_mask(&self) -> UEP_R_TOG_MASK_R {
                UEP_R_TOG_MASK_R::new((self.bits >> 3) & 3)
            }
            ///Bit 5 - enable automatic toggle after successful transfer completion on endpoint
            #[inline(always)]
            pub fn uep_r_autotog(&self) -> UEP_R_AUTOTOG_R {
                UEP_R_AUTOTOG_R::new(((self.bits >> 5) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:1 - bit mask of handshake response type for USB endpoint X receiving (OUT)
            #[inline(always)]
            #[must_use]
            pub fn uep_rres_mask(&mut self) -> UEP_RRES_MASK_W<UEP4_RX_CTRL_SPEC> {
                UEP_RRES_MASK_W::new(self, 0)
            }
            ///Bit 2 - prepared no response
            #[inline(always)]
            #[must_use]
            pub fn uep_rres_no(&mut self) -> UEP_RRES_NO_W<UEP4_RX_CTRL_SPEC> {
                UEP_RRES_NO_W::new(self, 2)
            }
            ///Bits 3:4 - expected data toggle flag of USB endpoint X receiving
            #[inline(always)]
            #[must_use]
            pub fn uep_r_tog_mask(&mut self) -> UEP_R_TOG_MASK_W<UEP4_RX_CTRL_SPEC> {
                UEP_R_TOG_MASK_W::new(self, 3)
            }
            ///Bit 5 - enable automatic toggle after successful transfer completion on endpoint
            #[inline(always)]
            #[must_use]
            pub fn uep_r_autotog(&mut self) -> UEP_R_AUTOTOG_W<UEP4_RX_CTRL_SPEC> {
                UEP_R_AUTOTOG_W::new(self, 5)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///endpoint 4 rx control
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`uep4_rx_ctrl::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep4_rx_ctrl::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct UEP4_RX_CTRL_SPEC;
        impl crate::RegisterSpec for UEP4_RX_CTRL_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`uep4_rx_ctrl::R`](R) reader structure
        impl crate::Readable for UEP4_RX_CTRL_SPEC {}
        ///`write(|w| ..)` method takes [`uep4_rx_ctrl::W`](W) writer structure
        impl crate::Writable for UEP4_RX_CTRL_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets UEP4_RX_CTRL to value 0
        impl crate::Resettable for UEP4_RX_CTRL_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///UEP5_T_LEN (rw) register accessor: endpoint 5 transmittal length
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`uep5_t_len::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep5_t_len::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@uep5_t_len`]
    ///module
    pub type UEP5_T_LEN = crate::Reg<uep5_t_len::UEP5_T_LEN_SPEC>;
    ///endpoint 5 transmittal length
    pub mod uep5_t_len {
        ///Register `UEP5_T_LEN` reader
        pub type R = crate::R<UEP5_T_LEN_SPEC>;
        ///Register `UEP5_T_LEN` writer
        pub type W = crate::W<UEP5_T_LEN_SPEC>;
        ///Field `UEP5_T_LEN` reader - endpoint 5 transmittal length
        pub type UEP5_T_LEN_R = crate::FieldReader<u16>;
        ///Field `UEP5_T_LEN` writer - endpoint 5 transmittal length
        pub type UEP5_T_LEN_W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            ///Bits 0:15 - endpoint 5 transmittal length
            #[inline(always)]
            pub fn uep5_t_len(&self) -> UEP5_T_LEN_R {
                UEP5_T_LEN_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - endpoint 5 transmittal length
            #[inline(always)]
            #[must_use]
            pub fn uep5_t_len(&mut self) -> UEP5_T_LEN_W<UEP5_T_LEN_SPEC> {
                UEP5_T_LEN_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///endpoint 5 transmittal length
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`uep5_t_len::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep5_t_len::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct UEP5_T_LEN_SPEC;
        impl crate::RegisterSpec for UEP5_T_LEN_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`uep5_t_len::R`](R) reader structure
        impl crate::Readable for UEP5_T_LEN_SPEC {}
        ///`write(|w| ..)` method takes [`uep5_t_len::W`](W) writer structure
        impl crate::Writable for UEP5_T_LEN_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets UEP5_T_LEN to value 0
        impl crate::Resettable for UEP5_T_LEN_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///UEP5_TX_CTRL (rw) register accessor: endpoint 5 tx control
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`uep5_tx_ctrl::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep5_tx_ctrl::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@uep5_tx_ctrl`]
    ///module
    pub type UEP5_TX_CTRL = crate::Reg<uep5_tx_ctrl::UEP5_TX_CTRL_SPEC>;
    ///endpoint 5 tx control
    pub mod uep5_tx_ctrl {
        ///Register `UEP5_TX_CTRL` reader
        pub type R = crate::R<UEP5_TX_CTRL_SPEC>;
        ///Register `UEP5_TX_CTRL` writer
        pub type W = crate::W<UEP5_TX_CTRL_SPEC>;
        ///Field `UEP_TRES_MASK` reader - bit mask of handshake response type for USB endpoint X transmittal (IN)
        pub type UEP_TRES_MASK_R = crate::FieldReader;
        ///Field `UEP_TRES_MASK` writer - bit mask of handshake response type for USB endpoint X transmittal (IN)
        pub type UEP_TRES_MASK_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `UEP_TRES_NO` reader - expected no response
        pub type UEP_TRES_NO_R = crate::BitReader;
        ///Field `UEP_TRES_NO` writer - expected no response
        pub type UEP_TRES_NO_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UEP_T_TOG_MASK` reader - prepared data toggle flag of USB endpoint X transmittal
        pub type UEP_T_TOG_MASK_R = crate::FieldReader;
        ///Field `UEP_T_TOG_MASK` writer - prepared data toggle flag of USB endpoint X transmittal
        pub type UEP_T_TOG_MASK_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `UEP_T_AUTOTOG` reader - enable automatic toggle after successful transfer completion on endpoint 0
        pub type UEP_T_AUTOTOG_R = crate::BitReader;
        ///Field `UEP_T_AUTOTOG` writer - enable automatic toggle after successful transfer completion on endpoint 0
        pub type UEP_T_AUTOTOG_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)
            #[inline(always)]
            pub fn uep_tres_mask(&self) -> UEP_TRES_MASK_R {
                UEP_TRES_MASK_R::new(self.bits & 3)
            }
            ///Bit 2 - expected no response
            #[inline(always)]
            pub fn uep_tres_no(&self) -> UEP_TRES_NO_R {
                UEP_TRES_NO_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bits 3:4 - prepared data toggle flag of USB endpoint X transmittal
            #[inline(always)]
            pub fn uep_t_tog_mask(&self) -> UEP_T_TOG_MASK_R {
                UEP_T_TOG_MASK_R::new((self.bits >> 3) & 3)
            }
            ///Bit 5 - enable automatic toggle after successful transfer completion on endpoint 0
            #[inline(always)]
            pub fn uep_t_autotog(&self) -> UEP_T_AUTOTOG_R {
                UEP_T_AUTOTOG_R::new(((self.bits >> 5) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)
            #[inline(always)]
            #[must_use]
            pub fn uep_tres_mask(&mut self) -> UEP_TRES_MASK_W<UEP5_TX_CTRL_SPEC> {
                UEP_TRES_MASK_W::new(self, 0)
            }
            ///Bit 2 - expected no response
            #[inline(always)]
            #[must_use]
            pub fn uep_tres_no(&mut self) -> UEP_TRES_NO_W<UEP5_TX_CTRL_SPEC> {
                UEP_TRES_NO_W::new(self, 2)
            }
            ///Bits 3:4 - prepared data toggle flag of USB endpoint X transmittal
            #[inline(always)]
            #[must_use]
            pub fn uep_t_tog_mask(&mut self) -> UEP_T_TOG_MASK_W<UEP5_TX_CTRL_SPEC> {
                UEP_T_TOG_MASK_W::new(self, 3)
            }
            ///Bit 5 - enable automatic toggle after successful transfer completion on endpoint 0
            #[inline(always)]
            #[must_use]
            pub fn uep_t_autotog(&mut self) -> UEP_T_AUTOTOG_W<UEP5_TX_CTRL_SPEC> {
                UEP_T_AUTOTOG_W::new(self, 5)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///endpoint 5 tx control
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`uep5_tx_ctrl::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep5_tx_ctrl::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct UEP5_TX_CTRL_SPEC;
        impl crate::RegisterSpec for UEP5_TX_CTRL_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`uep5_tx_ctrl::R`](R) reader structure
        impl crate::Readable for UEP5_TX_CTRL_SPEC {}
        ///`write(|w| ..)` method takes [`uep5_tx_ctrl::W`](W) writer structure
        impl crate::Writable for UEP5_TX_CTRL_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets UEP5_TX_CTRL to value 0
        impl crate::Resettable for UEP5_TX_CTRL_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///UEP5_RX_CTRL (rw) register accessor: endpoint 5 rx control
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`uep5_rx_ctrl::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep5_rx_ctrl::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@uep5_rx_ctrl`]
    ///module
    pub type UEP5_RX_CTRL = crate::Reg<uep5_rx_ctrl::UEP5_RX_CTRL_SPEC>;
    ///endpoint 5 rx control
    pub mod uep5_rx_ctrl {
        ///Register `UEP5_RX_CTRL` reader
        pub type R = crate::R<UEP5_RX_CTRL_SPEC>;
        ///Register `UEP5_RX_CTRL` writer
        pub type W = crate::W<UEP5_RX_CTRL_SPEC>;
        ///Field `UEP_RRES_MASK` reader - bit mask of handshake response type for USB endpoint X receiving (OUT)
        pub type UEP_RRES_MASK_R = crate::FieldReader;
        ///Field `UEP_RRES_MASK` writer - bit mask of handshake response type for USB endpoint X receiving (OUT)
        pub type UEP_RRES_MASK_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `UEP_RRES_NO` reader - prepared no response
        pub type UEP_RRES_NO_R = crate::BitReader;
        ///Field `UEP_RRES_NO` writer - prepared no response
        pub type UEP_RRES_NO_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UEP_R_TOG_MASK` reader - expected data toggle flag of USB endpoint X receiving
        pub type UEP_R_TOG_MASK_R = crate::FieldReader;
        ///Field `UEP_R_TOG_MASK` writer - expected data toggle flag of USB endpoint X receiving
        pub type UEP_R_TOG_MASK_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `UEP_R_AUTOTOG` reader - enable automatic toggle after successful transfer completion on endpoint
        pub type UEP_R_AUTOTOG_R = crate::BitReader;
        ///Field `UEP_R_AUTOTOG` writer - enable automatic toggle after successful transfer completion on endpoint
        pub type UEP_R_AUTOTOG_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bits 0:1 - bit mask of handshake response type for USB endpoint X receiving (OUT)
            #[inline(always)]
            pub fn uep_rres_mask(&self) -> UEP_RRES_MASK_R {
                UEP_RRES_MASK_R::new(self.bits & 3)
            }
            ///Bit 2 - prepared no response
            #[inline(always)]
            pub fn uep_rres_no(&self) -> UEP_RRES_NO_R {
                UEP_RRES_NO_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bits 3:4 - expected data toggle flag of USB endpoint X receiving
            #[inline(always)]
            pub fn uep_r_tog_mask(&self) -> UEP_R_TOG_MASK_R {
                UEP_R_TOG_MASK_R::new((self.bits >> 3) & 3)
            }
            ///Bit 5 - enable automatic toggle after successful transfer completion on endpoint
            #[inline(always)]
            pub fn uep_r_autotog(&self) -> UEP_R_AUTOTOG_R {
                UEP_R_AUTOTOG_R::new(((self.bits >> 5) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:1 - bit mask of handshake response type for USB endpoint X receiving (OUT)
            #[inline(always)]
            #[must_use]
            pub fn uep_rres_mask(&mut self) -> UEP_RRES_MASK_W<UEP5_RX_CTRL_SPEC> {
                UEP_RRES_MASK_W::new(self, 0)
            }
            ///Bit 2 - prepared no response
            #[inline(always)]
            #[must_use]
            pub fn uep_rres_no(&mut self) -> UEP_RRES_NO_W<UEP5_RX_CTRL_SPEC> {
                UEP_RRES_NO_W::new(self, 2)
            }
            ///Bits 3:4 - expected data toggle flag of USB endpoint X receiving
            #[inline(always)]
            #[must_use]
            pub fn uep_r_tog_mask(&mut self) -> UEP_R_TOG_MASK_W<UEP5_RX_CTRL_SPEC> {
                UEP_R_TOG_MASK_W::new(self, 3)
            }
            ///Bit 5 - enable automatic toggle after successful transfer completion on endpoint
            #[inline(always)]
            #[must_use]
            pub fn uep_r_autotog(&mut self) -> UEP_R_AUTOTOG_W<UEP5_RX_CTRL_SPEC> {
                UEP_R_AUTOTOG_W::new(self, 5)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///endpoint 5 rx control
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`uep5_rx_ctrl::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep5_rx_ctrl::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct UEP5_RX_CTRL_SPEC;
        impl crate::RegisterSpec for UEP5_RX_CTRL_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`uep5_rx_ctrl::R`](R) reader structure
        impl crate::Readable for UEP5_RX_CTRL_SPEC {}
        ///`write(|w| ..)` method takes [`uep5_rx_ctrl::W`](W) writer structure
        impl crate::Writable for UEP5_RX_CTRL_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets UEP5_RX_CTRL to value 0
        impl crate::Resettable for UEP5_RX_CTRL_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///UEP6_T_LEN (rw) register accessor: endpoint 6 transmittal length
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`uep6_t_len::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep6_t_len::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@uep6_t_len`]
    ///module
    pub type UEP6_T_LEN = crate::Reg<uep6_t_len::UEP6_T_LEN_SPEC>;
    ///endpoint 6 transmittal length
    pub mod uep6_t_len {
        ///Register `UEP6_T_LEN` reader
        pub type R = crate::R<UEP6_T_LEN_SPEC>;
        ///Register `UEP6_T_LEN` writer
        pub type W = crate::W<UEP6_T_LEN_SPEC>;
        ///Field `UEP6_T_LEN` reader - endpoint 6 transmittal length
        pub type UEP6_T_LEN_R = crate::FieldReader<u16>;
        ///Field `UEP6_T_LEN` writer - endpoint 6 transmittal length
        pub type UEP6_T_LEN_W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            ///Bits 0:15 - endpoint 6 transmittal length
            #[inline(always)]
            pub fn uep6_t_len(&self) -> UEP6_T_LEN_R {
                UEP6_T_LEN_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - endpoint 6 transmittal length
            #[inline(always)]
            #[must_use]
            pub fn uep6_t_len(&mut self) -> UEP6_T_LEN_W<UEP6_T_LEN_SPEC> {
                UEP6_T_LEN_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///endpoint 6 transmittal length
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`uep6_t_len::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep6_t_len::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct UEP6_T_LEN_SPEC;
        impl crate::RegisterSpec for UEP6_T_LEN_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`uep6_t_len::R`](R) reader structure
        impl crate::Readable for UEP6_T_LEN_SPEC {}
        ///`write(|w| ..)` method takes [`uep6_t_len::W`](W) writer structure
        impl crate::Writable for UEP6_T_LEN_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets UEP6_T_LEN to value 0
        impl crate::Resettable for UEP6_T_LEN_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///UEP6_TX_CTRL (rw) register accessor: endpoint 6 tx control
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`uep6_tx_ctrl::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep6_tx_ctrl::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@uep6_tx_ctrl`]
    ///module
    pub type UEP6_TX_CTRL = crate::Reg<uep6_tx_ctrl::UEP6_TX_CTRL_SPEC>;
    ///endpoint 6 tx control
    pub mod uep6_tx_ctrl {
        ///Register `UEP6_TX_CTRL` reader
        pub type R = crate::R<UEP6_TX_CTRL_SPEC>;
        ///Register `UEP6_TX_CTRL` writer
        pub type W = crate::W<UEP6_TX_CTRL_SPEC>;
        ///Field `UEP_TRES_MASK` reader - bit mask of handshake response type for USB endpoint X transmittal (IN)
        pub type UEP_TRES_MASK_R = crate::FieldReader;
        ///Field `UEP_TRES_MASK` writer - bit mask of handshake response type for USB endpoint X transmittal (IN)
        pub type UEP_TRES_MASK_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `UEP_TRES_NO` reader - expected no response
        pub type UEP_TRES_NO_R = crate::BitReader;
        ///Field `UEP_TRES_NO` writer - expected no response
        pub type UEP_TRES_NO_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UEP_T_TOG_MASK` reader - prepared data toggle flag of USB endpoint X transmittal
        pub type UEP_T_TOG_MASK_R = crate::FieldReader;
        ///Field `UEP_T_TOG_MASK` writer - prepared data toggle flag of USB endpoint X transmittal
        pub type UEP_T_TOG_MASK_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `UEP_T_AUTOTOG` reader - enable automatic toggle after successful transfer completion on endpoint 0
        pub type UEP_T_AUTOTOG_R = crate::BitReader;
        ///Field `UEP_T_AUTOTOG` writer - enable automatic toggle after successful transfer completion on endpoint 0
        pub type UEP_T_AUTOTOG_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)
            #[inline(always)]
            pub fn uep_tres_mask(&self) -> UEP_TRES_MASK_R {
                UEP_TRES_MASK_R::new(self.bits & 3)
            }
            ///Bit 2 - expected no response
            #[inline(always)]
            pub fn uep_tres_no(&self) -> UEP_TRES_NO_R {
                UEP_TRES_NO_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bits 3:4 - prepared data toggle flag of USB endpoint X transmittal
            #[inline(always)]
            pub fn uep_t_tog_mask(&self) -> UEP_T_TOG_MASK_R {
                UEP_T_TOG_MASK_R::new((self.bits >> 3) & 3)
            }
            ///Bit 5 - enable automatic toggle after successful transfer completion on endpoint 0
            #[inline(always)]
            pub fn uep_t_autotog(&self) -> UEP_T_AUTOTOG_R {
                UEP_T_AUTOTOG_R::new(((self.bits >> 5) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)
            #[inline(always)]
            #[must_use]
            pub fn uep_tres_mask(&mut self) -> UEP_TRES_MASK_W<UEP6_TX_CTRL_SPEC> {
                UEP_TRES_MASK_W::new(self, 0)
            }
            ///Bit 2 - expected no response
            #[inline(always)]
            #[must_use]
            pub fn uep_tres_no(&mut self) -> UEP_TRES_NO_W<UEP6_TX_CTRL_SPEC> {
                UEP_TRES_NO_W::new(self, 2)
            }
            ///Bits 3:4 - prepared data toggle flag of USB endpoint X transmittal
            #[inline(always)]
            #[must_use]
            pub fn uep_t_tog_mask(&mut self) -> UEP_T_TOG_MASK_W<UEP6_TX_CTRL_SPEC> {
                UEP_T_TOG_MASK_W::new(self, 3)
            }
            ///Bit 5 - enable automatic toggle after successful transfer completion on endpoint 0
            #[inline(always)]
            #[must_use]
            pub fn uep_t_autotog(&mut self) -> UEP_T_AUTOTOG_W<UEP6_TX_CTRL_SPEC> {
                UEP_T_AUTOTOG_W::new(self, 5)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///endpoint 6 tx control
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`uep6_tx_ctrl::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep6_tx_ctrl::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct UEP6_TX_CTRL_SPEC;
        impl crate::RegisterSpec for UEP6_TX_CTRL_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`uep6_tx_ctrl::R`](R) reader structure
        impl crate::Readable for UEP6_TX_CTRL_SPEC {}
        ///`write(|w| ..)` method takes [`uep6_tx_ctrl::W`](W) writer structure
        impl crate::Writable for UEP6_TX_CTRL_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets UEP6_TX_CTRL to value 0
        impl crate::Resettable for UEP6_TX_CTRL_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///UEP6_RX_CTRL (rw) register accessor: endpoint 6 rx control
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`uep6_rx_ctrl::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep6_rx_ctrl::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@uep6_rx_ctrl`]
    ///module
    pub type UEP6_RX_CTRL = crate::Reg<uep6_rx_ctrl::UEP6_RX_CTRL_SPEC>;
    ///endpoint 6 rx control
    pub mod uep6_rx_ctrl {
        ///Register `UEP6_RX_CTRL` reader
        pub type R = crate::R<UEP6_RX_CTRL_SPEC>;
        ///Register `UEP6_RX_CTRL` writer
        pub type W = crate::W<UEP6_RX_CTRL_SPEC>;
        ///Field `UEP_RRES_MASK` reader - bit mask of handshake response type for USB endpoint X receiving (OUT)
        pub type UEP_RRES_MASK_R = crate::FieldReader;
        ///Field `UEP_RRES_MASK` writer - bit mask of handshake response type for USB endpoint X receiving (OUT)
        pub type UEP_RRES_MASK_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `UEP_RRES_NO` reader - prepared no response
        pub type UEP_RRES_NO_R = crate::BitReader;
        ///Field `UEP_RRES_NO` writer - prepared no response
        pub type UEP_RRES_NO_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UEP_R_TOG_MASK` reader - expected data toggle flag of USB endpoint X receiving
        pub type UEP_R_TOG_MASK_R = crate::FieldReader;
        ///Field `UEP_R_TOG_MASK` writer - expected data toggle flag of USB endpoint X receiving
        pub type UEP_R_TOG_MASK_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `UEP_R_AUTOTOG` reader - enable automatic toggle after successful transfer completion on endpoint
        pub type UEP_R_AUTOTOG_R = crate::BitReader;
        ///Field `UEP_R_AUTOTOG` writer - enable automatic toggle after successful transfer completion on endpoint
        pub type UEP_R_AUTOTOG_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bits 0:1 - bit mask of handshake response type for USB endpoint X receiving (OUT)
            #[inline(always)]
            pub fn uep_rres_mask(&self) -> UEP_RRES_MASK_R {
                UEP_RRES_MASK_R::new(self.bits & 3)
            }
            ///Bit 2 - prepared no response
            #[inline(always)]
            pub fn uep_rres_no(&self) -> UEP_RRES_NO_R {
                UEP_RRES_NO_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bits 3:4 - expected data toggle flag of USB endpoint X receiving
            #[inline(always)]
            pub fn uep_r_tog_mask(&self) -> UEP_R_TOG_MASK_R {
                UEP_R_TOG_MASK_R::new((self.bits >> 3) & 3)
            }
            ///Bit 5 - enable automatic toggle after successful transfer completion on endpoint
            #[inline(always)]
            pub fn uep_r_autotog(&self) -> UEP_R_AUTOTOG_R {
                UEP_R_AUTOTOG_R::new(((self.bits >> 5) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:1 - bit mask of handshake response type for USB endpoint X receiving (OUT)
            #[inline(always)]
            #[must_use]
            pub fn uep_rres_mask(&mut self) -> UEP_RRES_MASK_W<UEP6_RX_CTRL_SPEC> {
                UEP_RRES_MASK_W::new(self, 0)
            }
            ///Bit 2 - prepared no response
            #[inline(always)]
            #[must_use]
            pub fn uep_rres_no(&mut self) -> UEP_RRES_NO_W<UEP6_RX_CTRL_SPEC> {
                UEP_RRES_NO_W::new(self, 2)
            }
            ///Bits 3:4 - expected data toggle flag of USB endpoint X receiving
            #[inline(always)]
            #[must_use]
            pub fn uep_r_tog_mask(&mut self) -> UEP_R_TOG_MASK_W<UEP6_RX_CTRL_SPEC> {
                UEP_R_TOG_MASK_W::new(self, 3)
            }
            ///Bit 5 - enable automatic toggle after successful transfer completion on endpoint
            #[inline(always)]
            #[must_use]
            pub fn uep_r_autotog(&mut self) -> UEP_R_AUTOTOG_W<UEP6_RX_CTRL_SPEC> {
                UEP_R_AUTOTOG_W::new(self, 5)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///endpoint 6 rx control
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`uep6_rx_ctrl::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep6_rx_ctrl::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct UEP6_RX_CTRL_SPEC;
        impl crate::RegisterSpec for UEP6_RX_CTRL_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`uep6_rx_ctrl::R`](R) reader structure
        impl crate::Readable for UEP6_RX_CTRL_SPEC {}
        ///`write(|w| ..)` method takes [`uep6_rx_ctrl::W`](W) writer structure
        impl crate::Writable for UEP6_RX_CTRL_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets UEP6_RX_CTRL to value 0
        impl crate::Resettable for UEP6_RX_CTRL_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///UEP7_T_LEN (rw) register accessor: endpoint 7 transmittal length
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`uep7_t_len::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep7_t_len::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@uep7_t_len`]
    ///module
    pub type UEP7_T_LEN = crate::Reg<uep7_t_len::UEP7_T_LEN_SPEC>;
    ///endpoint 7 transmittal length
    pub mod uep7_t_len {
        ///Register `UEP7_T_LEN` reader
        pub type R = crate::R<UEP7_T_LEN_SPEC>;
        ///Register `UEP7_T_LEN` writer
        pub type W = crate::W<UEP7_T_LEN_SPEC>;
        ///Field `UEP7_T_LEN` reader - endpoint 7 transmittal length
        pub type UEP7_T_LEN_R = crate::FieldReader<u16>;
        ///Field `UEP7_T_LEN` writer - endpoint 7 transmittal length
        pub type UEP7_T_LEN_W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            ///Bits 0:15 - endpoint 7 transmittal length
            #[inline(always)]
            pub fn uep7_t_len(&self) -> UEP7_T_LEN_R {
                UEP7_T_LEN_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - endpoint 7 transmittal length
            #[inline(always)]
            #[must_use]
            pub fn uep7_t_len(&mut self) -> UEP7_T_LEN_W<UEP7_T_LEN_SPEC> {
                UEP7_T_LEN_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///endpoint 7 transmittal length
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`uep7_t_len::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep7_t_len::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct UEP7_T_LEN_SPEC;
        impl crate::RegisterSpec for UEP7_T_LEN_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`uep7_t_len::R`](R) reader structure
        impl crate::Readable for UEP7_T_LEN_SPEC {}
        ///`write(|w| ..)` method takes [`uep7_t_len::W`](W) writer structure
        impl crate::Writable for UEP7_T_LEN_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets UEP7_T_LEN to value 0
        impl crate::Resettable for UEP7_T_LEN_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///UEP7_TX_CTRL (rw) register accessor: endpoint 7 tx control
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`uep7_tx_ctrl::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep7_tx_ctrl::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@uep7_tx_ctrl`]
    ///module
    pub type UEP7_TX_CTRL = crate::Reg<uep7_tx_ctrl::UEP7_TX_CTRL_SPEC>;
    ///endpoint 7 tx control
    pub mod uep7_tx_ctrl {
        ///Register `UEP7_TX_CTRL` reader
        pub type R = crate::R<UEP7_TX_CTRL_SPEC>;
        ///Register `UEP7_TX_CTRL` writer
        pub type W = crate::W<UEP7_TX_CTRL_SPEC>;
        ///Field `UEP_TRES_MASK` reader - bit mask of handshake response type for USB endpoint X transmittal (IN)
        pub type UEP_TRES_MASK_R = crate::FieldReader;
        ///Field `UEP_TRES_MASK` writer - bit mask of handshake response type for USB endpoint X transmittal (IN)
        pub type UEP_TRES_MASK_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `UEP_TRES_NO` reader - expected no response
        pub type UEP_TRES_NO_R = crate::BitReader;
        ///Field `UEP_TRES_NO` writer - expected no response
        pub type UEP_TRES_NO_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UEP_T_TOG_MASK` reader - prepared data toggle flag of USB endpoint X transmittal
        pub type UEP_T_TOG_MASK_R = crate::FieldReader;
        ///Field `UEP_T_TOG_MASK` writer - prepared data toggle flag of USB endpoint X transmittal
        pub type UEP_T_TOG_MASK_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `UEP_T_AUTOTOG` reader - enable automatic toggle after successful transfer completion on endpoint 0
        pub type UEP_T_AUTOTOG_R = crate::BitReader;
        ///Field `UEP_T_AUTOTOG` writer - enable automatic toggle after successful transfer completion on endpoint 0
        pub type UEP_T_AUTOTOG_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)
            #[inline(always)]
            pub fn uep_tres_mask(&self) -> UEP_TRES_MASK_R {
                UEP_TRES_MASK_R::new(self.bits & 3)
            }
            ///Bit 2 - expected no response
            #[inline(always)]
            pub fn uep_tres_no(&self) -> UEP_TRES_NO_R {
                UEP_TRES_NO_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bits 3:4 - prepared data toggle flag of USB endpoint X transmittal
            #[inline(always)]
            pub fn uep_t_tog_mask(&self) -> UEP_T_TOG_MASK_R {
                UEP_T_TOG_MASK_R::new((self.bits >> 3) & 3)
            }
            ///Bit 5 - enable automatic toggle after successful transfer completion on endpoint 0
            #[inline(always)]
            pub fn uep_t_autotog(&self) -> UEP_T_AUTOTOG_R {
                UEP_T_AUTOTOG_R::new(((self.bits >> 5) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)
            #[inline(always)]
            #[must_use]
            pub fn uep_tres_mask(&mut self) -> UEP_TRES_MASK_W<UEP7_TX_CTRL_SPEC> {
                UEP_TRES_MASK_W::new(self, 0)
            }
            ///Bit 2 - expected no response
            #[inline(always)]
            #[must_use]
            pub fn uep_tres_no(&mut self) -> UEP_TRES_NO_W<UEP7_TX_CTRL_SPEC> {
                UEP_TRES_NO_W::new(self, 2)
            }
            ///Bits 3:4 - prepared data toggle flag of USB endpoint X transmittal
            #[inline(always)]
            #[must_use]
            pub fn uep_t_tog_mask(&mut self) -> UEP_T_TOG_MASK_W<UEP7_TX_CTRL_SPEC> {
                UEP_T_TOG_MASK_W::new(self, 3)
            }
            ///Bit 5 - enable automatic toggle after successful transfer completion on endpoint 0
            #[inline(always)]
            #[must_use]
            pub fn uep_t_autotog(&mut self) -> UEP_T_AUTOTOG_W<UEP7_TX_CTRL_SPEC> {
                UEP_T_AUTOTOG_W::new(self, 5)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///endpoint 7 tx control
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`uep7_tx_ctrl::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep7_tx_ctrl::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct UEP7_TX_CTRL_SPEC;
        impl crate::RegisterSpec for UEP7_TX_CTRL_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`uep7_tx_ctrl::R`](R) reader structure
        impl crate::Readable for UEP7_TX_CTRL_SPEC {}
        ///`write(|w| ..)` method takes [`uep7_tx_ctrl::W`](W) writer structure
        impl crate::Writable for UEP7_TX_CTRL_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets UEP7_TX_CTRL to value 0
        impl crate::Resettable for UEP7_TX_CTRL_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///UEP7_RX_CTRL (rw) register accessor: endpoint 7 rx control
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`uep7_rx_ctrl::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep7_rx_ctrl::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@uep7_rx_ctrl`]
    ///module
    pub type UEP7_RX_CTRL = crate::Reg<uep7_rx_ctrl::UEP7_RX_CTRL_SPEC>;
    ///endpoint 7 rx control
    pub mod uep7_rx_ctrl {
        ///Register `UEP7_RX_CTRL` reader
        pub type R = crate::R<UEP7_RX_CTRL_SPEC>;
        ///Register `UEP7_RX_CTRL` writer
        pub type W = crate::W<UEP7_RX_CTRL_SPEC>;
        ///Field `UEP_RRES_MASK` reader - bit mask of handshake response type for USB endpoint X receiving (OUT)
        pub type UEP_RRES_MASK_R = crate::FieldReader;
        ///Field `UEP_RRES_MASK` writer - bit mask of handshake response type for USB endpoint X receiving (OUT)
        pub type UEP_RRES_MASK_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `UEP_RRES_NO` reader - prepared no response
        pub type UEP_RRES_NO_R = crate::BitReader;
        ///Field `UEP_RRES_NO` writer - prepared no response
        pub type UEP_RRES_NO_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UEP_R_TOG_MASK` reader - expected data toggle flag of USB endpoint X receiving
        pub type UEP_R_TOG_MASK_R = crate::FieldReader;
        ///Field `UEP_R_TOG_MASK` writer - expected data toggle flag of USB endpoint X receiving
        pub type UEP_R_TOG_MASK_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `UEP_R_AUTOTOG` reader - enable automatic toggle after successful transfer completion on endpoint
        pub type UEP_R_AUTOTOG_R = crate::BitReader;
        ///Field `UEP_R_AUTOTOG` writer - enable automatic toggle after successful transfer completion on endpoint
        pub type UEP_R_AUTOTOG_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bits 0:1 - bit mask of handshake response type for USB endpoint X receiving (OUT)
            #[inline(always)]
            pub fn uep_rres_mask(&self) -> UEP_RRES_MASK_R {
                UEP_RRES_MASK_R::new(self.bits & 3)
            }
            ///Bit 2 - prepared no response
            #[inline(always)]
            pub fn uep_rres_no(&self) -> UEP_RRES_NO_R {
                UEP_RRES_NO_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bits 3:4 - expected data toggle flag of USB endpoint X receiving
            #[inline(always)]
            pub fn uep_r_tog_mask(&self) -> UEP_R_TOG_MASK_R {
                UEP_R_TOG_MASK_R::new((self.bits >> 3) & 3)
            }
            ///Bit 5 - enable automatic toggle after successful transfer completion on endpoint
            #[inline(always)]
            pub fn uep_r_autotog(&self) -> UEP_R_AUTOTOG_R {
                UEP_R_AUTOTOG_R::new(((self.bits >> 5) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:1 - bit mask of handshake response type for USB endpoint X receiving (OUT)
            #[inline(always)]
            #[must_use]
            pub fn uep_rres_mask(&mut self) -> UEP_RRES_MASK_W<UEP7_RX_CTRL_SPEC> {
                UEP_RRES_MASK_W::new(self, 0)
            }
            ///Bit 2 - prepared no response
            #[inline(always)]
            #[must_use]
            pub fn uep_rres_no(&mut self) -> UEP_RRES_NO_W<UEP7_RX_CTRL_SPEC> {
                UEP_RRES_NO_W::new(self, 2)
            }
            ///Bits 3:4 - expected data toggle flag of USB endpoint X receiving
            #[inline(always)]
            #[must_use]
            pub fn uep_r_tog_mask(&mut self) -> UEP_R_TOG_MASK_W<UEP7_RX_CTRL_SPEC> {
                UEP_R_TOG_MASK_W::new(self, 3)
            }
            ///Bit 5 - enable automatic toggle after successful transfer completion on endpoint
            #[inline(always)]
            #[must_use]
            pub fn uep_r_autotog(&mut self) -> UEP_R_AUTOTOG_W<UEP7_RX_CTRL_SPEC> {
                UEP_R_AUTOTOG_W::new(self, 5)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///endpoint 7 rx control
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`uep7_rx_ctrl::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep7_rx_ctrl::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct UEP7_RX_CTRL_SPEC;
        impl crate::RegisterSpec for UEP7_RX_CTRL_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`uep7_rx_ctrl::R`](R) reader structure
        impl crate::Readable for UEP7_RX_CTRL_SPEC {}
        ///`write(|w| ..)` method takes [`uep7_rx_ctrl::W`](W) writer structure
        impl crate::Writable for UEP7_RX_CTRL_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets UEP7_RX_CTRL to value 0
        impl crate::Resettable for UEP7_RX_CTRL_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
}
///DVP register
pub struct DVP {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for DVP {}
impl DVP {
    ///Pointer to the register block
    pub const PTR: *const dvp::RegisterBlock = 0x4000_e000 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const dvp::RegisterBlock {
        Self::PTR
    }
    /// Steal an instance of this peripheral
    ///
    /// # Safety
    ///
    /// Ensure that the new instance of the peripheral cannot be used in a way
    /// that may race with any existing instances, for example by only
    /// accessing read-only or write-only registers, or by consuming the
    /// original peripheral and using critical sections to coordinate
    /// access between multiple new instances.
    ///
    /// Additionally, other software such as HALs may rely on only one
    /// peripheral instance existing to ensure memory safety; ensure
    /// no stolen instances are passed to such software.
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for DVP {
    type Target = dvp::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for DVP {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("DVP").finish()
    }
}
///DVP register
pub mod dvp {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        cr0: CR0,
        cr1: CR1,
        int_en: INT_EN,
        _reserved3: [u8; 0x01],
        row_num: ROW_NUM,
        col_num: COL_NUM,
        dma_buf0: DMA_BUF0,
        dma_buf1: DMA_BUF1,
        _reserved_7_fifo_st: [u8; 0x04],
        row_cnt: ROW_CNT,
        col_cnt: COL_CNT,
    }
    impl RegisterBlock {
        ///0x00 - DVP control register0
        #[inline(always)]
        pub const fn cr0(&self) -> &CR0 {
            &self.cr0
        }
        ///0x01 - DVP control register1
        #[inline(always)]
        pub const fn cr1(&self) -> &CR1 {
            &self.cr1
        }
        ///0x02 - DVP interrupt enable register
        #[inline(always)]
        pub const fn int_en(&self) -> &INT_EN {
            &self.int_en
        }
        ///0x04 - DVP row number of a frame indicator register
        #[inline(always)]
        pub const fn row_num(&self) -> &ROW_NUM {
            &self.row_num
        }
        ///0x06 - DVP row number of a frame indicator register
        #[inline(always)]
        pub const fn col_num(&self) -> &COL_NUM {
            &self.col_num
        }
        ///0x08 - DVP dma buffer0 addr
        #[inline(always)]
        pub const fn dma_buf0(&self) -> &DMA_BUF0 {
            &self.dma_buf0
        }
        ///0x0c - DVP dma buffer1 addr
        #[inline(always)]
        pub const fn dma_buf1(&self) -> &DMA_BUF1 {
            &self.dma_buf1
        }
        ///0x10 - DVP interrupt flag register
        #[inline(always)]
        pub const fn int_flag(&self) -> &INT_FLAG {
            unsafe { &*(self as *const Self).cast::<u8>().add(16).cast() }
        }
        ///0x11 - DVP receive fifo status
        #[inline(always)]
        pub const fn fifo_st(&self) -> &FIFO_ST {
            unsafe { &*(self as *const Self).cast::<u8>().add(17).cast() }
        }
        ///0x14 - DVP row count value
        #[inline(always)]
        pub const fn row_cnt(&self) -> &ROW_CNT {
            &self.row_cnt
        }
        ///0x16 - DVP col count value
        #[inline(always)]
        pub const fn col_cnt(&self) -> &COL_CNT {
            &self.col_cnt
        }
    }
    ///CR0 (rw) register accessor: DVP control register0
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`cr0::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cr0::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@cr0`]
    ///module
    pub type CR0 = crate::Reg<cr0::CR0_SPEC>;
    ///DVP control register0
    pub mod cr0 {
        ///Register `CR0` reader
        pub type R = crate::R<CR0_SPEC>;
        ///Register `CR0` writer
        pub type W = crate::W<CR0_SPEC>;
        ///Field `ENABLE` reader - DVP enable
        pub type ENABLE_R = crate::BitReader;
        ///Field `ENABLE` writer - DVP enable
        pub type ENABLE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `V_POLAR` reader - DVP VSYNC polarity control
        pub type V_POLAR_R = crate::BitReader;
        ///Field `V_POLAR` writer - DVP VSYNC polarity control
        pub type V_POLAR_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `H_POLAR` reader - DVP HSYNC polarity control
        pub type H_POLAR_R = crate::BitReader;
        ///Field `H_POLAR` writer - DVP HSYNC polarity control
        pub type H_POLAR_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `P_POLAR` reader - DVP PCLK polarity control
        pub type P_POLAR_R = crate::BitReader;
        ///Field `P_POLAR` writer - DVP PCLK polarity control
        pub type P_POLAR_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `MSK_DAT_MOD` reader - DVP data bit width confguration
        pub type MSK_DAT_MOD_R = crate::FieldReader;
        ///Field `MSK_DAT_MOD` writer - DVP data bit width confguration
        pub type MSK_DAT_MOD_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `JPEG` reader - DVP JPEG mode
        pub type JPEG_R = crate::BitReader;
        ///Field `JPEG` writer - DVP JPEG mode
        pub type JPEG_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `RAW_CM` reader - DVP row count mode
        pub type RAW_CM_R = crate::BitReader;
        ///Field `RAW_CM` writer - DVP row count mode
        pub type RAW_CM_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - DVP enable
            #[inline(always)]
            pub fn enable(&self) -> ENABLE_R {
                ENABLE_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - DVP VSYNC polarity control
            #[inline(always)]
            pub fn v_polar(&self) -> V_POLAR_R {
                V_POLAR_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - DVP HSYNC polarity control
            #[inline(always)]
            pub fn h_polar(&self) -> H_POLAR_R {
                H_POLAR_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - DVP PCLK polarity control
            #[inline(always)]
            pub fn p_polar(&self) -> P_POLAR_R {
                P_POLAR_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bits 4:5 - DVP data bit width confguration
            #[inline(always)]
            pub fn msk_dat_mod(&self) -> MSK_DAT_MOD_R {
                MSK_DAT_MOD_R::new((self.bits >> 4) & 3)
            }
            ///Bit 6 - DVP JPEG mode
            #[inline(always)]
            pub fn jpeg(&self) -> JPEG_R {
                JPEG_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - DVP row count mode
            #[inline(always)]
            pub fn raw_cm(&self) -> RAW_CM_R {
                RAW_CM_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - DVP enable
            #[inline(always)]
            #[must_use]
            pub fn enable(&mut self) -> ENABLE_W<CR0_SPEC> {
                ENABLE_W::new(self, 0)
            }
            ///Bit 1 - DVP VSYNC polarity control
            #[inline(always)]
            #[must_use]
            pub fn v_polar(&mut self) -> V_POLAR_W<CR0_SPEC> {
                V_POLAR_W::new(self, 1)
            }
            ///Bit 2 - DVP HSYNC polarity control
            #[inline(always)]
            #[must_use]
            pub fn h_polar(&mut self) -> H_POLAR_W<CR0_SPEC> {
                H_POLAR_W::new(self, 2)
            }
            ///Bit 3 - DVP PCLK polarity control
            #[inline(always)]
            #[must_use]
            pub fn p_polar(&mut self) -> P_POLAR_W<CR0_SPEC> {
                P_POLAR_W::new(self, 3)
            }
            ///Bits 4:5 - DVP data bit width confguration
            #[inline(always)]
            #[must_use]
            pub fn msk_dat_mod(&mut self) -> MSK_DAT_MOD_W<CR0_SPEC> {
                MSK_DAT_MOD_W::new(self, 4)
            }
            ///Bit 6 - DVP JPEG mode
            #[inline(always)]
            #[must_use]
            pub fn jpeg(&mut self) -> JPEG_W<CR0_SPEC> {
                JPEG_W::new(self, 6)
            }
            ///Bit 7 - DVP row count mode
            #[inline(always)]
            #[must_use]
            pub fn raw_cm(&mut self) -> RAW_CM_W<CR0_SPEC> {
                RAW_CM_W::new(self, 7)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///DVP control register0
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`cr0::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cr0::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct CR0_SPEC;
        impl crate::RegisterSpec for CR0_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`cr0::R`](R) reader structure
        impl crate::Readable for CR0_SPEC {}
        ///`write(|w| ..)` method takes [`cr0::W`](W) writer structure
        impl crate::Writable for CR0_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets CR0 to value 0
        impl crate::Resettable for CR0_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///CR1 (rw) register accessor: DVP control register1
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`cr1::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cr1::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@cr1`]
    ///module
    pub type CR1 = crate::Reg<cr1::CR1_SPEC>;
    ///DVP control register1
    pub mod cr1 {
        ///Register `CR1` reader
        pub type R = crate::R<CR1_SPEC>;
        ///Register `CR1` writer
        pub type W = crate::W<CR1_SPEC>;
        ///Field `DMA_ENABLE` reader - DVP dma enable
        pub type DMA_ENABLE_R = crate::BitReader;
        ///Field `DMA_ENABLE` writer - DVP dma enable
        pub type DMA_ENABLE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `ALL_CLR` reader - DVP all clear, high action
        pub type ALL_CLR_R = crate::BitReader;
        ///Field `ALL_CLR` writer - DVP all clear, high action
        pub type ALL_CLR_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `RCV_CLR` reader - DVP receive logic clear, high action
        pub type RCV_CLR_R = crate::BitReader;
        ///Field `RCV_CLR` writer - DVP receive logic clear, high action
        pub type RCV_CLR_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `BUF_TOG` reader - DVP bug toggle by software
        pub type BUF_TOG_R = crate::BitReader;
        ///Field `BUF_TOG` writer - DVP bug toggle by software
        pub type BUF_TOG_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - DVP dma enable
            #[inline(always)]
            pub fn dma_enable(&self) -> DMA_ENABLE_R {
                DMA_ENABLE_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - DVP all clear, high action
            #[inline(always)]
            pub fn all_clr(&self) -> ALL_CLR_R {
                ALL_CLR_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - DVP receive logic clear, high action
            #[inline(always)]
            pub fn rcv_clr(&self) -> RCV_CLR_R {
                RCV_CLR_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - DVP bug toggle by software
            #[inline(always)]
            pub fn buf_tog(&self) -> BUF_TOG_R {
                BUF_TOG_R::new(((self.bits >> 3) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - DVP dma enable
            #[inline(always)]
            #[must_use]
            pub fn dma_enable(&mut self) -> DMA_ENABLE_W<CR1_SPEC> {
                DMA_ENABLE_W::new(self, 0)
            }
            ///Bit 1 - DVP all clear, high action
            #[inline(always)]
            #[must_use]
            pub fn all_clr(&mut self) -> ALL_CLR_W<CR1_SPEC> {
                ALL_CLR_W::new(self, 1)
            }
            ///Bit 2 - DVP receive logic clear, high action
            #[inline(always)]
            #[must_use]
            pub fn rcv_clr(&mut self) -> RCV_CLR_W<CR1_SPEC> {
                RCV_CLR_W::new(self, 2)
            }
            ///Bit 3 - DVP bug toggle by software
            #[inline(always)]
            #[must_use]
            pub fn buf_tog(&mut self) -> BUF_TOG_W<CR1_SPEC> {
                BUF_TOG_W::new(self, 3)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///DVP control register1
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`cr1::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cr1::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct CR1_SPEC;
        impl crate::RegisterSpec for CR1_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`cr1::R`](R) reader structure
        impl crate::Readable for CR1_SPEC {}
        ///`write(|w| ..)` method takes [`cr1::W`](W) writer structure
        impl crate::Writable for CR1_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets CR1 to value 0x06
        impl crate::Resettable for CR1_SPEC {
            const RESET_VALUE: u8 = 0x06;
        }
    }
    ///INT_EN (rw) register accessor: DVP interrupt enable register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`int_en::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`int_en::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@int_en`]
    ///module
    pub type INT_EN = crate::Reg<int_en::INT_EN_SPEC>;
    ///DVP interrupt enable register
    pub mod int_en {
        ///Register `INT_EN` reader
        pub type R = crate::R<INT_EN_SPEC>;
        ///Register `INT_EN` writer
        pub type W = crate::W<INT_EN_SPEC>;
        ///Field `IE_STR_FRM` reader - DVP frame start interrupt enable
        pub type IE_STR_FRM_R = crate::BitReader;
        ///Field `IE_STR_FRM` writer - DVP frame start interrupt enable
        pub type IE_STR_FRM_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `IE_ROW_DONE` reader - DVP row received done interrupt enable
        pub type IE_ROW_DONE_R = crate::BitReader;
        ///Field `IE_ROW_DONE` writer - DVP row received done interrupt enable
        pub type IE_ROW_DONE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `IE_FRM_DONE` reader - DVP frame received done interrupt enable
        pub type IE_FRM_DONE_R = crate::BitReader;
        ///Field `IE_FRM_DONE` writer - DVP frame received done interrupt enable
        pub type IE_FRM_DONE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `IE_FIFO_OV` reader - DVP receive fifo overflow interrupt enable
        pub type IE_FIFO_OV_R = crate::BitReader;
        ///Field `IE_FIFO_OV` writer - DVP receive fifo overflow interrupt enable
        pub type IE_FIFO_OV_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `IE_STP_FRM` reader - DVP frame stop interrupt enable
        pub type IE_STP_FRM_R = crate::BitReader;
        ///Field `IE_STP_FRM` writer - DVP frame stop interrupt enable
        pub type IE_STP_FRM_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - DVP frame start interrupt enable
            #[inline(always)]
            pub fn ie_str_frm(&self) -> IE_STR_FRM_R {
                IE_STR_FRM_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - DVP row received done interrupt enable
            #[inline(always)]
            pub fn ie_row_done(&self) -> IE_ROW_DONE_R {
                IE_ROW_DONE_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - DVP frame received done interrupt enable
            #[inline(always)]
            pub fn ie_frm_done(&self) -> IE_FRM_DONE_R {
                IE_FRM_DONE_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - DVP receive fifo overflow interrupt enable
            #[inline(always)]
            pub fn ie_fifo_ov(&self) -> IE_FIFO_OV_R {
                IE_FIFO_OV_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - DVP frame stop interrupt enable
            #[inline(always)]
            pub fn ie_stp_frm(&self) -> IE_STP_FRM_R {
                IE_STP_FRM_R::new(((self.bits >> 4) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - DVP frame start interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn ie_str_frm(&mut self) -> IE_STR_FRM_W<INT_EN_SPEC> {
                IE_STR_FRM_W::new(self, 0)
            }
            ///Bit 1 - DVP row received done interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn ie_row_done(&mut self) -> IE_ROW_DONE_W<INT_EN_SPEC> {
                IE_ROW_DONE_W::new(self, 1)
            }
            ///Bit 2 - DVP frame received done interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn ie_frm_done(&mut self) -> IE_FRM_DONE_W<INT_EN_SPEC> {
                IE_FRM_DONE_W::new(self, 2)
            }
            ///Bit 3 - DVP receive fifo overflow interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn ie_fifo_ov(&mut self) -> IE_FIFO_OV_W<INT_EN_SPEC> {
                IE_FIFO_OV_W::new(self, 3)
            }
            ///Bit 4 - DVP frame stop interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn ie_stp_frm(&mut self) -> IE_STP_FRM_W<INT_EN_SPEC> {
                IE_STP_FRM_W::new(self, 4)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///DVP interrupt enable register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`int_en::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`int_en::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct INT_EN_SPEC;
        impl crate::RegisterSpec for INT_EN_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`int_en::R`](R) reader structure
        impl crate::Readable for INT_EN_SPEC {}
        ///`write(|w| ..)` method takes [`int_en::W`](W) writer structure
        impl crate::Writable for INT_EN_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets INT_EN to value 0
        impl crate::Resettable for INT_EN_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///ROW_NUM (rw) register accessor: DVP row number of a frame indicator register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`row_num::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`row_num::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@row_num`]
    ///module
    pub type ROW_NUM = crate::Reg<row_num::ROW_NUM_SPEC>;
    ///DVP row number of a frame indicator register
    pub mod row_num {
        ///Register `ROW_NUM` reader
        pub type R = crate::R<ROW_NUM_SPEC>;
        ///Register `ROW_NUM` writer
        pub type W = crate::W<ROW_NUM_SPEC>;
        ///Field `ROW_NUM` reader - the number of rows contained in a frame of image data
        pub type ROW_NUM_R = crate::FieldReader<u16>;
        ///Field `ROW_NUM` writer - the number of rows contained in a frame of image data
        pub type ROW_NUM_W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            ///Bits 0:15 - the number of rows contained in a frame of image data
            #[inline(always)]
            pub fn row_num(&self) -> ROW_NUM_R {
                ROW_NUM_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - the number of rows contained in a frame of image data
            #[inline(always)]
            #[must_use]
            pub fn row_num(&mut self) -> ROW_NUM_W<ROW_NUM_SPEC> {
                ROW_NUM_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///DVP row number of a frame indicator register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`row_num::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`row_num::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct ROW_NUM_SPEC;
        impl crate::RegisterSpec for ROW_NUM_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`row_num::R`](R) reader structure
        impl crate::Readable for ROW_NUM_SPEC {}
        ///`write(|w| ..)` method takes [`row_num::W`](W) writer structure
        impl crate::Writable for ROW_NUM_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets ROW_NUM to value 0
        impl crate::Resettable for ROW_NUM_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///COL_NUM (rw) register accessor: DVP row number of a frame indicator register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`col_num::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`col_num::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@col_num`]
    ///module
    pub type COL_NUM = crate::Reg<col_num::COL_NUM_SPEC>;
    ///DVP row number of a frame indicator register
    pub mod col_num {
        ///Register `COL_NUM` reader
        pub type R = crate::R<COL_NUM_SPEC>;
        ///Register `COL_NUM` writer
        pub type W = crate::W<COL_NUM_SPEC>;
        ///Field `COL_NUM` reader - the number of PCLK cyccles contained in a row of data in RGB mode
        pub type COL_NUM_R = crate::FieldReader<u16>;
        ///Field `COL_NUM` writer - the number of PCLK cyccles contained in a row of data in RGB mode
        pub type COL_NUM_W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            ///Bits 0:15 - the number of PCLK cyccles contained in a row of data in RGB mode
            #[inline(always)]
            pub fn col_num(&self) -> COL_NUM_R {
                COL_NUM_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - the number of PCLK cyccles contained in a row of data in RGB mode
            #[inline(always)]
            #[must_use]
            pub fn col_num(&mut self) -> COL_NUM_W<COL_NUM_SPEC> {
                COL_NUM_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///DVP row number of a frame indicator register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`col_num::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`col_num::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct COL_NUM_SPEC;
        impl crate::RegisterSpec for COL_NUM_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`col_num::R`](R) reader structure
        impl crate::Readable for COL_NUM_SPEC {}
        ///`write(|w| ..)` method takes [`col_num::W`](W) writer structure
        impl crate::Writable for COL_NUM_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets COL_NUM to value 0
        impl crate::Resettable for COL_NUM_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///DMA_BUF0 (rw) register accessor: DVP dma buffer0 addr
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`dma_buf0::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dma_buf0::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@dma_buf0`]
    ///module
    pub type DMA_BUF0 = crate::Reg<dma_buf0::DMA_BUF0_SPEC>;
    ///DVP dma buffer0 addr
    pub mod dma_buf0 {
        ///Register `DMA_BUF0` reader
        pub type R = crate::R<DMA_BUF0_SPEC>;
        ///Register `DMA_BUF0` writer
        pub type W = crate::W<DMA_BUF0_SPEC>;
        ///Field `DMA_BUF0` reader - the receiving address 0 of DMA
        pub type DMA_BUF0_R = crate::FieldReader<u32>;
        ///Field `DMA_BUF0` writer - the receiving address 0 of DMA
        pub type DMA_BUF0_W<'a, REG> = crate::FieldWriter<'a, REG, 17, u32>;
        impl R {
            ///Bits 0:16 - the receiving address 0 of DMA
            #[inline(always)]
            pub fn dma_buf0(&self) -> DMA_BUF0_R {
                DMA_BUF0_R::new(self.bits & 0x0001_ffff)
            }
        }
        impl W {
            ///Bits 0:16 - the receiving address 0 of DMA
            #[inline(always)]
            #[must_use]
            pub fn dma_buf0(&mut self) -> DMA_BUF0_W<DMA_BUF0_SPEC> {
                DMA_BUF0_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///DVP dma buffer0 addr
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`dma_buf0::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dma_buf0::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct DMA_BUF0_SPEC;
        impl crate::RegisterSpec for DMA_BUF0_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`dma_buf0::R`](R) reader structure
        impl crate::Readable for DMA_BUF0_SPEC {}
        ///`write(|w| ..)` method takes [`dma_buf0::W`](W) writer structure
        impl crate::Writable for DMA_BUF0_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets DMA_BUF0 to value 0
        impl crate::Resettable for DMA_BUF0_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///DMA_BUF1 (rw) register accessor: DVP dma buffer1 addr
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`dma_buf1::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dma_buf1::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@dma_buf1`]
    ///module
    pub type DMA_BUF1 = crate::Reg<dma_buf1::DMA_BUF1_SPEC>;
    ///DVP dma buffer1 addr
    pub mod dma_buf1 {
        ///Register `DMA_BUF1` reader
        pub type R = crate::R<DMA_BUF1_SPEC>;
        ///Register `DMA_BUF1` writer
        pub type W = crate::W<DMA_BUF1_SPEC>;
        ///Field `DMA_BUF1` reader - the receiving address1 of DMA
        pub type DMA_BUF1_R = crate::FieldReader<u32>;
        ///Field `DMA_BUF1` writer - the receiving address1 of DMA
        pub type DMA_BUF1_W<'a, REG> = crate::FieldWriter<'a, REG, 17, u32>;
        impl R {
            ///Bits 0:16 - the receiving address1 of DMA
            #[inline(always)]
            pub fn dma_buf1(&self) -> DMA_BUF1_R {
                DMA_BUF1_R::new(self.bits & 0x0001_ffff)
            }
        }
        impl W {
            ///Bits 0:16 - the receiving address1 of DMA
            #[inline(always)]
            #[must_use]
            pub fn dma_buf1(&mut self) -> DMA_BUF1_W<DMA_BUF1_SPEC> {
                DMA_BUF1_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///DVP dma buffer1 addr
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`dma_buf1::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dma_buf1::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct DMA_BUF1_SPEC;
        impl crate::RegisterSpec for DMA_BUF1_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`dma_buf1::R`](R) reader structure
        impl crate::Readable for DMA_BUF1_SPEC {}
        ///`write(|w| ..)` method takes [`dma_buf1::W`](W) writer structure
        impl crate::Writable for DMA_BUF1_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets DMA_BUF1 to value 0
        impl crate::Resettable for DMA_BUF1_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///INT_FLAG (rw) register accessor: DVP interrupt flag register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`int_flag::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`int_flag::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@int_flag`]
    ///module
    pub type INT_FLAG = crate::Reg<int_flag::INT_FLAG_SPEC>;
    ///DVP interrupt flag register
    pub mod int_flag {
        ///Register `INT_FLAG` reader
        pub type R = crate::R<INT_FLAG_SPEC>;
        ///Register `INT_FLAG` writer
        pub type W = crate::W<INT_FLAG_SPEC>;
        ///Field `IF_STR_FRM` reader - interrupt flag for DVP frame start
        pub type IF_STR_FRM_R = crate::BitReader;
        ///Field `IF_STR_FRM` writer - interrupt flag for DVP frame start
        pub type IF_STR_FRM_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `IF_ROW_DONE` reader - interrupt flag for DVP row receive done
        pub type IF_ROW_DONE_R = crate::BitReader;
        ///Field `IF_ROW_DONE` writer - interrupt flag for DVP row receive done
        pub type IF_ROW_DONE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `IF_FRM_DONE` reader - interrupt flag for DVP frame receive done
        pub type IF_FRM_DONE_R = crate::BitReader;
        ///Field `IF_FRM_DONE` writer - interrupt flag for DVP frame receive done
        pub type IF_FRM_DONE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `IF_FIFO_OV` reader - interrupt flag for DVP receive fifo overflow
        pub type IF_FIFO_OV_R = crate::BitReader;
        ///Field `IF_FIFO_OV` writer - interrupt flag for DVP receive fifo overflow
        pub type IF_FIFO_OV_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `IF_STP_FRM` reader - interrupt flag for DVP frame stop
        pub type IF_STP_FRM_R = crate::BitReader;
        ///Field `IF_STP_FRM` writer - interrupt flag for DVP frame stop
        pub type IF_STP_FRM_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - interrupt flag for DVP frame start
            #[inline(always)]
            pub fn if_str_frm(&self) -> IF_STR_FRM_R {
                IF_STR_FRM_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - interrupt flag for DVP row receive done
            #[inline(always)]
            pub fn if_row_done(&self) -> IF_ROW_DONE_R {
                IF_ROW_DONE_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - interrupt flag for DVP frame receive done
            #[inline(always)]
            pub fn if_frm_done(&self) -> IF_FRM_DONE_R {
                IF_FRM_DONE_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - interrupt flag for DVP receive fifo overflow
            #[inline(always)]
            pub fn if_fifo_ov(&self) -> IF_FIFO_OV_R {
                IF_FIFO_OV_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - interrupt flag for DVP frame stop
            #[inline(always)]
            pub fn if_stp_frm(&self) -> IF_STP_FRM_R {
                IF_STP_FRM_R::new(((self.bits >> 4) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - interrupt flag for DVP frame start
            #[inline(always)]
            #[must_use]
            pub fn if_str_frm(&mut self) -> IF_STR_FRM_W<INT_FLAG_SPEC> {
                IF_STR_FRM_W::new(self, 0)
            }
            ///Bit 1 - interrupt flag for DVP row receive done
            #[inline(always)]
            #[must_use]
            pub fn if_row_done(&mut self) -> IF_ROW_DONE_W<INT_FLAG_SPEC> {
                IF_ROW_DONE_W::new(self, 1)
            }
            ///Bit 2 - interrupt flag for DVP frame receive done
            #[inline(always)]
            #[must_use]
            pub fn if_frm_done(&mut self) -> IF_FRM_DONE_W<INT_FLAG_SPEC> {
                IF_FRM_DONE_W::new(self, 2)
            }
            ///Bit 3 - interrupt flag for DVP receive fifo overflow
            #[inline(always)]
            #[must_use]
            pub fn if_fifo_ov(&mut self) -> IF_FIFO_OV_W<INT_FLAG_SPEC> {
                IF_FIFO_OV_W::new(self, 3)
            }
            ///Bit 4 - interrupt flag for DVP frame stop
            #[inline(always)]
            #[must_use]
            pub fn if_stp_frm(&mut self) -> IF_STP_FRM_W<INT_FLAG_SPEC> {
                IF_STP_FRM_W::new(self, 4)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///DVP interrupt flag register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`int_flag::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`int_flag::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct INT_FLAG_SPEC;
        impl crate::RegisterSpec for INT_FLAG_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`int_flag::R`](R) reader structure
        impl crate::Readable for INT_FLAG_SPEC {}
        ///`write(|w| ..)` method takes [`int_flag::W`](W) writer structure
        impl crate::Writable for INT_FLAG_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets INT_FLAG to value 0
        impl crate::Resettable for INT_FLAG_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///FIFO_ST (r) register accessor: DVP receive fifo status
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`fifo_st::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@fifo_st`]
    ///module
    pub type FIFO_ST = crate::Reg<fifo_st::FIFO_ST_SPEC>;
    ///DVP receive fifo status
    pub mod fifo_st {
        ///Register `FIFO_ST` reader
        pub type R = crate::R<FIFO_ST_SPEC>;
        ///Field `FIFO_RDY` reader - DVP receive fifo ready
        pub type FIFO_RDY_R = crate::BitReader;
        ///Field `FIFO_FULL` reader - DVP receive fifo full
        pub type FIFO_FULL_R = crate::BitReader;
        ///Field `FIFO_OV` reader - DVP receive fifo overflow
        pub type FIFO_OV_R = crate::BitReader;
        ///Field `MSK_FIFO_CNT` reader - DVP receive fifo count
        pub type MSK_FIFO_CNT_R = crate::FieldReader;
        impl R {
            ///Bit 0 - DVP receive fifo ready
            #[inline(always)]
            pub fn fifo_rdy(&self) -> FIFO_RDY_R {
                FIFO_RDY_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - DVP receive fifo full
            #[inline(always)]
            pub fn fifo_full(&self) -> FIFO_FULL_R {
                FIFO_FULL_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - DVP receive fifo overflow
            #[inline(always)]
            pub fn fifo_ov(&self) -> FIFO_OV_R {
                FIFO_OV_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bits 4:6 - DVP receive fifo count
            #[inline(always)]
            pub fn msk_fifo_cnt(&self) -> MSK_FIFO_CNT_R {
                MSK_FIFO_CNT_R::new((self.bits >> 4) & 7)
            }
        }
        ///DVP receive fifo status
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`fifo_st::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct FIFO_ST_SPEC;
        impl crate::RegisterSpec for FIFO_ST_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`fifo_st::R`](R) reader structure
        impl crate::Readable for FIFO_ST_SPEC {}
        ///`reset()` method sets FIFO_ST to value 0
        impl crate::Resettable for FIFO_ST_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///ROW_CNT (r) register accessor: DVP row count value
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`row_cnt::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@row_cnt`]
    ///module
    pub type ROW_CNT = crate::Reg<row_cnt::ROW_CNT_SPEC>;
    ///DVP row count value
    pub mod row_cnt {
        ///Register `ROW_CNT` reader
        pub type R = crate::R<ROW_CNT_SPEC>;
        ///Field `ROW_CNT` reader - DVP receive fifo full
        pub type ROW_CNT_R = crate::FieldReader<u16>;
        impl R {
            ///Bits 0:15 - DVP receive fifo full
            #[inline(always)]
            pub fn row_cnt(&self) -> ROW_CNT_R {
                ROW_CNT_R::new(self.bits)
            }
        }
        ///DVP row count value
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`row_cnt::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct ROW_CNT_SPEC;
        impl crate::RegisterSpec for ROW_CNT_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`row_cnt::R`](R) reader structure
        impl crate::Readable for ROW_CNT_SPEC {}
        ///`reset()` method sets ROW_CNT to value 0
        impl crate::Resettable for ROW_CNT_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///COL_CNT (r) register accessor: DVP col count value
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`col_cnt::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@col_cnt`]
    ///module
    pub type COL_CNT = crate::Reg<col_cnt::COL_CNT_SPEC>;
    ///DVP col count value
    pub mod col_cnt {
        ///Register `COL_CNT` reader
        pub type R = crate::R<COL_CNT_SPEC>;
        ///Field `COL_CNT` reader - DVP receive fifo ready
        pub type COL_CNT_R = crate::FieldReader<u16>;
        impl R {
            ///Bits 0:15 - DVP receive fifo ready
            #[inline(always)]
            pub fn col_cnt(&self) -> COL_CNT_R {
                COL_CNT_R::new(self.bits)
            }
        }
        ///DVP col count value
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`col_cnt::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct COL_CNT_SPEC;
        impl crate::RegisterSpec for COL_CNT_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`col_cnt::R`](R) reader structure
        impl crate::Readable for COL_CNT_SPEC {}
        ///`reset()` method sets COL_CNT to value 0
        impl crate::Resettable for COL_CNT_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
}
///Program Fast Interrupt Controller
pub struct PFIC {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for PFIC {}
impl PFIC {
    ///Pointer to the register block
    pub const PTR: *const pfic::RegisterBlock = 0xe000_e000 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const pfic::RegisterBlock {
        Self::PTR
    }
    /// Steal an instance of this peripheral
    ///
    /// # Safety
    ///
    /// Ensure that the new instance of the peripheral cannot be used in a way
    /// that may race with any existing instances, for example by only
    /// accessing read-only or write-only registers, or by consuming the
    /// original peripheral and using critical sections to coordinate
    /// access between multiple new instances.
    ///
    /// Additionally, other software such as HALs may rely on only one
    /// peripheral instance existing to ensure memory safety; ensure
    /// no stolen instances are passed to such software.
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for PFIC {
    type Target = pfic::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for PFIC {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("PFIC").finish()
    }
}
///Program Fast Interrupt Controller
pub mod pfic {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        isr1: ISR1,
        isr2: ISR2,
        _reserved2: [u8; 0x18],
        ipr1: IPR1,
        ipr2: IPR2,
        _reserved4: [u8; 0x18],
        ithresdr: ITHRESDR,
        fibaddrr: FIBADDRR,
        cfgr: CFGR,
        gisr: GISR,
        _reserved8: [u8; 0x10],
        fifoaddrr0: FIFOADDRR0,
        fifoaddrr1: FIFOADDRR1,
        fifoaddrr2: FIFOADDRR2,
        fifoaddrr3: FIFOADDRR3,
        _reserved12: [u8; 0x90],
        ienr1: IENR1,
        ienr2: IENR2,
        _reserved14: [u8; 0x78],
        irer1: IRER1,
        irer2: IRER2,
        _reserved16: [u8; 0x78],
        ipsr1: IPSR1,
        ipsr2: IPSR2,
        _reserved18: [u8; 0x78],
        iprr1: IPRR1,
        iprr2: IPRR2,
        _reserved20: [u8; 0x78],
        iactr1: IACTR1,
        iactr2: IACTR2,
        _reserved22: [u8; 0xf8],
        iprior0: IPRIOR0,
        _reserved23: [u8; 0x1c],
        iprior1: IPRIOR1,
        _reserved24: [u8; 0x1c],
        iprior2: IPRIOR2,
        _reserved25: [u8; 0x1c],
        iprior3: IPRIOR3,
        _reserved26: [u8; 0x1c],
        iprior4: IPRIOR4,
        _reserved27: [u8; 0x1c],
        iprior5: IPRIOR5,
        _reserved28: [u8; 0x1c],
        iprior6: IPRIOR6,
        _reserved29: [u8; 0x1c],
        iprior7: IPRIOR7,
        _reserved30: [u8; 0x1c],
        iprior8: IPRIOR8,
        _reserved31: [u8; 0x1c],
        iprior9: IPRIOR9,
        _reserved32: [u8; 0x1c],
        iprior10: IPRIOR10,
        _reserved33: [u8; 0x1c],
        iprior11: IPRIOR11,
        _reserved34: [u8; 0x1c],
        iprior12: IPRIOR12,
        _reserved35: [u8; 0x1c],
        iprior13: IPRIOR13,
        _reserved36: [u8; 0x1c],
        iprior14: IPRIOR14,
        _reserved37: [u8; 0x1c],
        iprior15: IPRIOR15,
        _reserved38: [u8; 0x1c],
        iprior16: IPRIOR16,
        _reserved39: [u8; 0x1c],
        iprior17: IPRIOR17,
        _reserved40: [u8; 0x1c],
        iprior18: IPRIOR18,
        _reserved41: [u8; 0x1c],
        iprior19: IPRIOR19,
        _reserved42: [u8; 0x1c],
        iprior20: IPRIOR20,
        _reserved43: [u8; 0x1c],
        iprior21: IPRIOR21,
        _reserved44: [u8; 0x1c],
        iprior22: IPRIOR22,
        _reserved45: [u8; 0x1c],
        iprior23: IPRIOR23,
        _reserved46: [u8; 0x1c],
        iprior24: IPRIOR24,
        _reserved47: [u8; 0x1c],
        iprior25: IPRIOR25,
        _reserved48: [u8; 0x1c],
        iprior26: IPRIOR26,
        _reserved49: [u8; 0x1c],
        iprior27: IPRIOR27,
        _reserved50: [u8; 0x1c],
        iprior28: IPRIOR28,
        _reserved51: [u8; 0x1c],
        iprior29: IPRIOR29,
        _reserved52: [u8; 0x1c],
        iprior30: IPRIOR30,
        _reserved53: [u8; 0x1c],
        iprior31: IPRIOR31,
        _reserved54: [u8; 0x1c],
        iprior32: IPRIOR32,
        _reserved55: [u8; 0x1c],
        iprior33: IPRIOR33,
        _reserved56: [u8; 0x1c],
        iprior34: IPRIOR34,
        _reserved57: [u8; 0x1c],
        iprior35: IPRIOR35,
        _reserved58: [u8; 0x1c],
        iprior36: IPRIOR36,
        _reserved59: [u8; 0x1c],
        iprior37: IPRIOR37,
        _reserved60: [u8; 0x1c],
        iprior38: IPRIOR38,
        _reserved61: [u8; 0x1c],
        iprior39: IPRIOR39,
        _reserved62: [u8; 0x1c],
        iprior40: IPRIOR40,
        _reserved63: [u8; 0x1c],
        iprior41: IPRIOR41,
        _reserved64: [u8; 0x1c],
        iprior42: IPRIOR42,
        _reserved65: [u8; 0x1c],
        iprior43: IPRIOR43,
        _reserved66: [u8; 0x1c],
        iprior44: IPRIOR44,
        _reserved67: [u8; 0x1c],
        iprior45: IPRIOR45,
        _reserved68: [u8; 0x1c],
        iprior46: IPRIOR46,
        _reserved69: [u8; 0x1c],
        iprior47: IPRIOR47,
        _reserved70: [u8; 0x1c],
        iprior48: IPRIOR48,
        _reserved71: [u8; 0x1c],
        iprior49: IPRIOR49,
        _reserved72: [u8; 0x1c],
        iprior50: IPRIOR50,
        _reserved73: [u8; 0x1c],
        iprior51: IPRIOR51,
        _reserved74: [u8; 0x1c],
        iprior52: IPRIOR52,
        _reserved75: [u8; 0x1c],
        iprior53: IPRIOR53,
        _reserved76: [u8; 0x2c],
        iprior54: IPRIOR54,
        _reserved77: [u8; 0x0c],
        iprior55: IPRIOR55,
        _reserved78: [u8; 0x1c],
        iprior56: IPRIOR56,
        _reserved79: [u8; 0x1c],
        iprior57: IPRIOR57,
        _reserved80: [u8; 0x1c],
        iprior58: IPRIOR58,
        _reserved81: [u8; 0x1c],
        iprior59: IPRIOR59,
        _reserved82: [u8; 0x1c],
        iprior60: IPRIOR60,
        _reserved83: [u8; 0x1c],
        iprior61: IPRIOR61,
        _reserved84: [u8; 0x3c],
        iprior62: IPRIOR62,
        _reserved85: [u8; 0x1c],
        iprior63: IPRIOR63,
        _reserved86: [u8; 0x010c],
        sctlr: SCTLR,
    }
    impl RegisterBlock {
        ///0x00 - Interrupt Status Register
        #[inline(always)]
        pub const fn isr1(&self) -> &ISR1 {
            &self.isr1
        }
        ///0x04 - Interrupt Status Register
        #[inline(always)]
        pub const fn isr2(&self) -> &ISR2 {
            &self.isr2
        }
        ///0x20 - Interrupt Pending Register
        #[inline(always)]
        pub const fn ipr1(&self) -> &IPR1 {
            &self.ipr1
        }
        ///0x24 - Interrupt Pending Register
        #[inline(always)]
        pub const fn ipr2(&self) -> &IPR2 {
            &self.ipr2
        }
        ///0x40 - Interrupt Priority Register
        #[inline(always)]
        pub const fn ithresdr(&self) -> &ITHRESDR {
            &self.ithresdr
        }
        ///0x44 - Interrupt Fast Address Register
        #[inline(always)]
        pub const fn fibaddrr(&self) -> &FIBADDRR {
            &self.fibaddrr
        }
        ///0x48 - Interrupt Config Register
        #[inline(always)]
        pub const fn cfgr(&self) -> &CFGR {
            &self.cfgr
        }
        ///0x4c - Interrupt Global Register
        #[inline(always)]
        pub const fn gisr(&self) -> &GISR {
            &self.gisr
        }
        ///0x60 - Interrupt 0 address Register
        #[inline(always)]
        pub const fn fifoaddrr0(&self) -> &FIFOADDRR0 {
            &self.fifoaddrr0
        }
        ///0x64 - Interrupt 1 address Register
        #[inline(always)]
        pub const fn fifoaddrr1(&self) -> &FIFOADDRR1 {
            &self.fifoaddrr1
        }
        ///0x68 - Interrupt 2 address Register
        #[inline(always)]
        pub const fn fifoaddrr2(&self) -> &FIFOADDRR2 {
            &self.fifoaddrr2
        }
        ///0x6c - Interrupt 3 address Register
        #[inline(always)]
        pub const fn fifoaddrr3(&self) -> &FIFOADDRR3 {
            &self.fifoaddrr3
        }
        ///0x100 - Interrupt Setting Register
        #[inline(always)]
        pub const fn ienr1(&self) -> &IENR1 {
            &self.ienr1
        }
        ///0x104 - Interrupt Setting Register
        #[inline(always)]
        pub const fn ienr2(&self) -> &IENR2 {
            &self.ienr2
        }
        ///0x180 - Interrupt Clear Register
        #[inline(always)]
        pub const fn irer1(&self) -> &IRER1 {
            &self.irer1
        }
        ///0x184 - Interrupt Clear Register
        #[inline(always)]
        pub const fn irer2(&self) -> &IRER2 {
            &self.irer2
        }
        ///0x200 - Interrupt Pending Register
        #[inline(always)]
        pub const fn ipsr1(&self) -> &IPSR1 {
            &self.ipsr1
        }
        ///0x204 - Interrupt Pending Register
        #[inline(always)]
        pub const fn ipsr2(&self) -> &IPSR2 {
            &self.ipsr2
        }
        ///0x280 - Interrupt Pending Clear Register
        #[inline(always)]
        pub const fn iprr1(&self) -> &IPRR1 {
            &self.iprr1
        }
        ///0x284 - Interrupt Pending Clear Register
        #[inline(always)]
        pub const fn iprr2(&self) -> &IPRR2 {
            &self.iprr2
        }
        ///0x300 - Interrupt ACTIVE Register
        #[inline(always)]
        pub const fn iactr1(&self) -> &IACTR1 {
            &self.iactr1
        }
        ///0x304 - Interrupt ACTIVE Register
        #[inline(always)]
        pub const fn iactr2(&self) -> &IACTR2 {
            &self.iactr2
        }
        ///0x400 - Interrupt Priority configuration Register
        #[inline(always)]
        pub const fn iprior0(&self) -> &IPRIOR0 {
            &self.iprior0
        }
        ///0x420 - Interrupt Priority configuration Register
        #[inline(always)]
        pub const fn iprior1(&self) -> &IPRIOR1 {
            &self.iprior1
        }
        ///0x440 - Interrupt Priority configuration Register
        #[inline(always)]
        pub const fn iprior2(&self) -> &IPRIOR2 {
            &self.iprior2
        }
        ///0x460 - Interrupt Priority configuration Register
        #[inline(always)]
        pub const fn iprior3(&self) -> &IPRIOR3 {
            &self.iprior3
        }
        ///0x480 - Interrupt Priority configuration Register
        #[inline(always)]
        pub const fn iprior4(&self) -> &IPRIOR4 {
            &self.iprior4
        }
        ///0x4a0 - Interrupt Priority configuration Register
        #[inline(always)]
        pub const fn iprior5(&self) -> &IPRIOR5 {
            &self.iprior5
        }
        ///0x4c0 - Interrupt Priority configuration Register
        #[inline(always)]
        pub const fn iprior6(&self) -> &IPRIOR6 {
            &self.iprior6
        }
        ///0x4e0 - Interrupt Priority configuration Register
        #[inline(always)]
        pub const fn iprior7(&self) -> &IPRIOR7 {
            &self.iprior7
        }
        ///0x500 - Interrupt Priority configuration Register
        #[inline(always)]
        pub const fn iprior8(&self) -> &IPRIOR8 {
            &self.iprior8
        }
        ///0x520 - Interrupt Priority configuration Register
        #[inline(always)]
        pub const fn iprior9(&self) -> &IPRIOR9 {
            &self.iprior9
        }
        ///0x540 - Interrupt Priority configuration Register
        #[inline(always)]
        pub const fn iprior10(&self) -> &IPRIOR10 {
            &self.iprior10
        }
        ///0x560 - Interrupt Priority configuration Register
        #[inline(always)]
        pub const fn iprior11(&self) -> &IPRIOR11 {
            &self.iprior11
        }
        ///0x580 - Interrupt Priority configuration Register
        #[inline(always)]
        pub const fn iprior12(&self) -> &IPRIOR12 {
            &self.iprior12
        }
        ///0x5a0 - Interrupt Priority configuration Register
        #[inline(always)]
        pub const fn iprior13(&self) -> &IPRIOR13 {
            &self.iprior13
        }
        ///0x5c0 - Interrupt Priority configuration Register
        #[inline(always)]
        pub const fn iprior14(&self) -> &IPRIOR14 {
            &self.iprior14
        }
        ///0x5e0 - Interrupt Priority configuration Register
        #[inline(always)]
        pub const fn iprior15(&self) -> &IPRIOR15 {
            &self.iprior15
        }
        ///0x600 - Interrupt Priority configuration Register
        #[inline(always)]
        pub const fn iprior16(&self) -> &IPRIOR16 {
            &self.iprior16
        }
        ///0x620 - Interrupt Priority configuration Register
        #[inline(always)]
        pub const fn iprior17(&self) -> &IPRIOR17 {
            &self.iprior17
        }
        ///0x640 - Interrupt Priority configuration Register
        #[inline(always)]
        pub const fn iprior18(&self) -> &IPRIOR18 {
            &self.iprior18
        }
        ///0x660 - Interrupt Priority configuration Register
        #[inline(always)]
        pub const fn iprior19(&self) -> &IPRIOR19 {
            &self.iprior19
        }
        ///0x680 - Interrupt Priority configuration Register
        #[inline(always)]
        pub const fn iprior20(&self) -> &IPRIOR20 {
            &self.iprior20
        }
        ///0x6a0 - Interrupt Priority configuration Register
        #[inline(always)]
        pub const fn iprior21(&self) -> &IPRIOR21 {
            &self.iprior21
        }
        ///0x6c0 - Interrupt Priority configuration Register
        #[inline(always)]
        pub const fn iprior22(&self) -> &IPRIOR22 {
            &self.iprior22
        }
        ///0x6e0 - Interrupt Priority configuration Register
        #[inline(always)]
        pub const fn iprior23(&self) -> &IPRIOR23 {
            &self.iprior23
        }
        ///0x700 - Interrupt Priority configuration Register
        #[inline(always)]
        pub const fn iprior24(&self) -> &IPRIOR24 {
            &self.iprior24
        }
        ///0x720 - Interrupt Priority configuration Register
        #[inline(always)]
        pub const fn iprior25(&self) -> &IPRIOR25 {
            &self.iprior25
        }
        ///0x740 - Interrupt Priority configuration Register
        #[inline(always)]
        pub const fn iprior26(&self) -> &IPRIOR26 {
            &self.iprior26
        }
        ///0x760 - Interrupt Priority configuration Register
        #[inline(always)]
        pub const fn iprior27(&self) -> &IPRIOR27 {
            &self.iprior27
        }
        ///0x780 - Interrupt Priority configuration Register
        #[inline(always)]
        pub const fn iprior28(&self) -> &IPRIOR28 {
            &self.iprior28
        }
        ///0x7a0 - Interrupt Priority configuration Register
        #[inline(always)]
        pub const fn iprior29(&self) -> &IPRIOR29 {
            &self.iprior29
        }
        ///0x7c0 - Interrupt Priority configuration Register
        #[inline(always)]
        pub const fn iprior30(&self) -> &IPRIOR30 {
            &self.iprior30
        }
        ///0x7e0 - Interrupt Priority configuration Register
        #[inline(always)]
        pub const fn iprior31(&self) -> &IPRIOR31 {
            &self.iprior31
        }
        ///0x800 - Interrupt Priority configuration Register
        #[inline(always)]
        pub const fn iprior32(&self) -> &IPRIOR32 {
            &self.iprior32
        }
        ///0x820 - Interrupt Priority configuration Register
        #[inline(always)]
        pub const fn iprior33(&self) -> &IPRIOR33 {
            &self.iprior33
        }
        ///0x840 - Interrupt Priority configuration Register
        #[inline(always)]
        pub const fn iprior34(&self) -> &IPRIOR34 {
            &self.iprior34
        }
        ///0x860 - Interrupt Priority configuration Register
        #[inline(always)]
        pub const fn iprior35(&self) -> &IPRIOR35 {
            &self.iprior35
        }
        ///0x880 - Interrupt Priority configuration Register
        #[inline(always)]
        pub const fn iprior36(&self) -> &IPRIOR36 {
            &self.iprior36
        }
        ///0x8a0 - Interrupt Priority configuration Register
        #[inline(always)]
        pub const fn iprior37(&self) -> &IPRIOR37 {
            &self.iprior37
        }
        ///0x8c0 - Interrupt Priority configuration Register
        #[inline(always)]
        pub const fn iprior38(&self) -> &IPRIOR38 {
            &self.iprior38
        }
        ///0x8e0 - Interrupt Priority configuration Register
        #[inline(always)]
        pub const fn iprior39(&self) -> &IPRIOR39 {
            &self.iprior39
        }
        ///0x900 - Interrupt Priority configuration Register
        #[inline(always)]
        pub const fn iprior40(&self) -> &IPRIOR40 {
            &self.iprior40
        }
        ///0x920 - Interrupt Priority configuration Register
        #[inline(always)]
        pub const fn iprior41(&self) -> &IPRIOR41 {
            &self.iprior41
        }
        ///0x940 - Interrupt Priority configuration Register
        #[inline(always)]
        pub const fn iprior42(&self) -> &IPRIOR42 {
            &self.iprior42
        }
        ///0x960 - Interrupt Priority configuration Register
        #[inline(always)]
        pub const fn iprior43(&self) -> &IPRIOR43 {
            &self.iprior43
        }
        ///0x980 - Interrupt Priority configuration Register
        #[inline(always)]
        pub const fn iprior44(&self) -> &IPRIOR44 {
            &self.iprior44
        }
        ///0x9a0 - Interrupt Priority configuration Register
        #[inline(always)]
        pub const fn iprior45(&self) -> &IPRIOR45 {
            &self.iprior45
        }
        ///0x9c0 - Interrupt Priority configuration Register
        #[inline(always)]
        pub const fn iprior46(&self) -> &IPRIOR46 {
            &self.iprior46
        }
        ///0x9e0 - Interrupt Priority configuration Register
        #[inline(always)]
        pub const fn iprior47(&self) -> &IPRIOR47 {
            &self.iprior47
        }
        ///0xa00 - Interrupt Priority configuration Register
        #[inline(always)]
        pub const fn iprior48(&self) -> &IPRIOR48 {
            &self.iprior48
        }
        ///0xa20 - Interrupt Priority configuration Register
        #[inline(always)]
        pub const fn iprior49(&self) -> &IPRIOR49 {
            &self.iprior49
        }
        ///0xa40 - Interrupt Priority configuration Register
        #[inline(always)]
        pub const fn iprior50(&self) -> &IPRIOR50 {
            &self.iprior50
        }
        ///0xa60 - Interrupt Priority configuration Register
        #[inline(always)]
        pub const fn iprior51(&self) -> &IPRIOR51 {
            &self.iprior51
        }
        ///0xa80 - Interrupt Priority configuration Register
        #[inline(always)]
        pub const fn iprior52(&self) -> &IPRIOR52 {
            &self.iprior52
        }
        ///0xaa0 - Interrupt Priority configuration Register
        #[inline(always)]
        pub const fn iprior53(&self) -> &IPRIOR53 {
            &self.iprior53
        }
        ///0xad0 - Interrupt Priority configuration Register
        #[inline(always)]
        pub const fn iprior54(&self) -> &IPRIOR54 {
            &self.iprior54
        }
        ///0xae0 - Interrupt Priority configuration Register
        #[inline(always)]
        pub const fn iprior55(&self) -> &IPRIOR55 {
            &self.iprior55
        }
        ///0xb00 - Interrupt Priority configuration Register
        #[inline(always)]
        pub const fn iprior56(&self) -> &IPRIOR56 {
            &self.iprior56
        }
        ///0xb20 - Interrupt Priority configuration Register
        #[inline(always)]
        pub const fn iprior57(&self) -> &IPRIOR57 {
            &self.iprior57
        }
        ///0xb40 - Interrupt Priority configuration Register
        #[inline(always)]
        pub const fn iprior58(&self) -> &IPRIOR58 {
            &self.iprior58
        }
        ///0xb60 - Interrupt Priority configuration Register
        #[inline(always)]
        pub const fn iprior59(&self) -> &IPRIOR59 {
            &self.iprior59
        }
        ///0xb80 - Interrupt Priority configuration Register
        #[inline(always)]
        pub const fn iprior60(&self) -> &IPRIOR60 {
            &self.iprior60
        }
        ///0xba0 - Interrupt Priority configuration Register
        #[inline(always)]
        pub const fn iprior61(&self) -> &IPRIOR61 {
            &self.iprior61
        }
        ///0xbe0 - Interrupt Priority configuration Register
        #[inline(always)]
        pub const fn iprior62(&self) -> &IPRIOR62 {
            &self.iprior62
        }
        ///0xc00 - Interrupt Priority configuration Register
        #[inline(always)]
        pub const fn iprior63(&self) -> &IPRIOR63 {
            &self.iprior63
        }
        ///0xd10 - System Control Register
        #[inline(always)]
        pub const fn sctlr(&self) -> &SCTLR {
            &self.sctlr
        }
    }
    ///ISR1 (r) register accessor: Interrupt Status Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`isr1::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@isr1`]
    ///module
    pub type ISR1 = crate::Reg<isr1::ISR1_SPEC>;
    ///Interrupt Status Register
    pub mod isr1 {
        ///Register `ISR1` reader
        pub type R = crate::R<ISR1_SPEC>;
        ///Field `INTSTA` reader - Interrupt ID Status
        pub type INTSTA_R = crate::FieldReader<u32>;
        impl R {
            ///Bits 12:31 - Interrupt ID Status
            #[inline(always)]
            pub fn intsta(&self) -> INTSTA_R {
                INTSTA_R::new((self.bits >> 12) & 0x000f_ffff)
            }
        }
        ///Interrupt Status Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`isr1::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct ISR1_SPEC;
        impl crate::RegisterSpec for ISR1_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`isr1::R`](R) reader structure
        impl crate::Readable for ISR1_SPEC {}
        ///`reset()` method sets ISR1 to value 0
        impl crate::Resettable for ISR1_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///ISR2 (r) register accessor: Interrupt Status Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`isr2::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@isr2`]
    ///module
    pub type ISR2 = crate::Reg<isr2::ISR2_SPEC>;
    ///Interrupt Status Register
    pub mod isr2 {
        ///Register `ISR2` reader
        pub type R = crate::R<ISR2_SPEC>;
        ///Field `INTENSTA` reader - Interrupt ID Status
        pub type INTENSTA_R = crate::FieldReader<u32>;
        impl R {
            ///Bits 0:27 - Interrupt ID Status
            #[inline(always)]
            pub fn intensta(&self) -> INTENSTA_R {
                INTENSTA_R::new(self.bits & 0x0fff_ffff)
            }
        }
        ///Interrupt Status Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`isr2::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct ISR2_SPEC;
        impl crate::RegisterSpec for ISR2_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`isr2::R`](R) reader structure
        impl crate::Readable for ISR2_SPEC {}
        ///`reset()` method sets ISR2 to value 0
        impl crate::Resettable for ISR2_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPR1 (r) register accessor: Interrupt Pending Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`ipr1::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@ipr1`]
    ///module
    pub type IPR1 = crate::Reg<ipr1::IPR1_SPEC>;
    ///Interrupt Pending Register
    pub mod ipr1 {
        ///Register `IPR1` reader
        pub type R = crate::R<IPR1_SPEC>;
        ///Field `PENDSTA` reader - PENDSTA
        pub type PENDSTA_R = crate::FieldReader<u32>;
        impl R {
            ///Bits 12:31 - PENDSTA
            #[inline(always)]
            pub fn pendsta(&self) -> PENDSTA_R {
                PENDSTA_R::new((self.bits >> 12) & 0x000f_ffff)
            }
        }
        ///Interrupt Pending Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`ipr1::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPR1_SPEC;
        impl crate::RegisterSpec for IPR1_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`ipr1::R`](R) reader structure
        impl crate::Readable for IPR1_SPEC {}
        ///`reset()` method sets IPR1 to value 0
        impl crate::Resettable for IPR1_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPR2 (r) register accessor: Interrupt Pending Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`ipr2::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@ipr2`]
    ///module
    pub type IPR2 = crate::Reg<ipr2::IPR2_SPEC>;
    ///Interrupt Pending Register
    pub mod ipr2 {
        ///Register `IPR2` reader
        pub type R = crate::R<IPR2_SPEC>;
        ///Field `PENDSTA` reader - PENDSTA
        pub type PENDSTA_R = crate::FieldReader<u32>;
        impl R {
            ///Bits 0:27 - PENDSTA
            #[inline(always)]
            pub fn pendsta(&self) -> PENDSTA_R {
                PENDSTA_R::new(self.bits & 0x0fff_ffff)
            }
        }
        ///Interrupt Pending Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`ipr2::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPR2_SPEC;
        impl crate::RegisterSpec for IPR2_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`ipr2::R`](R) reader structure
        impl crate::Readable for IPR2_SPEC {}
        ///`reset()` method sets IPR2 to value 0
        impl crate::Resettable for IPR2_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///ITHRESDR (rw) register accessor: Interrupt Priority Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`ithresdr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ithresdr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@ithresdr`]
    ///module
    pub type ITHRESDR = crate::Reg<ithresdr::ITHRESDR_SPEC>;
    ///Interrupt Priority Register
    pub mod ithresdr {
        ///Register `ITHRESDR` reader
        pub type R = crate::R<ITHRESDR_SPEC>;
        ///Register `ITHRESDR` writer
        pub type W = crate::W<ITHRESDR_SPEC>;
        ///Field `THRESHOLD` reader - THRESHOLD
        pub type THRESHOLD_R = crate::FieldReader;
        ///Field `THRESHOLD` writer - THRESHOLD
        pub type THRESHOLD_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            ///Bits 0:7 - THRESHOLD
            #[inline(always)]
            pub fn threshold(&self) -> THRESHOLD_R {
                THRESHOLD_R::new((self.bits & 0xff) as u8)
            }
        }
        impl W {
            ///Bits 0:7 - THRESHOLD
            #[inline(always)]
            #[must_use]
            pub fn threshold(&mut self) -> THRESHOLD_W<ITHRESDR_SPEC> {
                THRESHOLD_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`ithresdr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ithresdr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct ITHRESDR_SPEC;
        impl crate::RegisterSpec for ITHRESDR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`ithresdr::R`](R) reader structure
        impl crate::Readable for ITHRESDR_SPEC {}
        ///`write(|w| ..)` method takes [`ithresdr::W`](W) writer structure
        impl crate::Writable for ITHRESDR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets ITHRESDR to value 0
        impl crate::Resettable for ITHRESDR_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///FIBADDRR (rw) register accessor: Interrupt Fast Address Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`fibaddrr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`fibaddrr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@fibaddrr`]
    ///module
    pub type FIBADDRR = crate::Reg<fibaddrr::FIBADDRR_SPEC>;
    ///Interrupt Fast Address Register
    pub mod fibaddrr {
        ///Register `FIBADDRR` reader
        pub type R = crate::R<FIBADDRR_SPEC>;
        ///Register `FIBADDRR` writer
        pub type W = crate::W<FIBADDRR_SPEC>;
        ///Field `BASEADDR` reader - BASEADDR
        pub type BASEADDR_R = crate::FieldReader;
        ///Field `BASEADDR` writer - BASEADDR
        pub type BASEADDR_W<'a, REG> = crate::FieldWriter<'a, REG, 4>;
        impl R {
            ///Bits 28:31 - BASEADDR
            #[inline(always)]
            pub fn baseaddr(&self) -> BASEADDR_R {
                BASEADDR_R::new(((self.bits >> 28) & 0x0f) as u8)
            }
        }
        impl W {
            ///Bits 28:31 - BASEADDR
            #[inline(always)]
            #[must_use]
            pub fn baseaddr(&mut self) -> BASEADDR_W<FIBADDRR_SPEC> {
                BASEADDR_W::new(self, 28)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Fast Address Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`fibaddrr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`fibaddrr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct FIBADDRR_SPEC;
        impl crate::RegisterSpec for FIBADDRR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`fibaddrr::R`](R) reader structure
        impl crate::Readable for FIBADDRR_SPEC {}
        ///`write(|w| ..)` method takes [`fibaddrr::W`](W) writer structure
        impl crate::Writable for FIBADDRR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets FIBADDRR to value 0
        impl crate::Resettable for FIBADDRR_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///CFGR (rw) register accessor: Interrupt Config Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`cfgr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cfgr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@cfgr`]
    ///module
    pub type CFGR = crate::Reg<cfgr::CFGR_SPEC>;
    ///Interrupt Config Register
    pub mod cfgr {
        ///Register `CFGR` reader
        pub type R = crate::R<CFGR_SPEC>;
        ///Register `CFGR` writer
        pub type W = crate::W<CFGR_SPEC>;
        ///Field `HWSTKCTRL` reader - HWSTKCTRL
        pub type HWSTKCTRL_R = crate::BitReader;
        ///Field `HWSTKCTRL` writer - HWSTKCTRL
        pub type HWSTKCTRL_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `NESTCTRL` reader - NESTCTRL
        pub type NESTCTRL_R = crate::BitReader;
        ///Field `NESTCTRL` writer - NESTCTRL
        pub type NESTCTRL_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `NMISET` writer - NMISET
        pub type NMISET_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `NMIRESET` writer - NMIRESET
        pub type NMIRESET_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `EXCSET` writer - EXCSET
        pub type EXCSET_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `EXCRESET` writer - EXCRESET
        pub type EXCRESET_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PFICRESET` writer - PFICRSET
        pub type PFICRESET_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `SYSRESET` writer - SYSRESET
        pub type SYSRESET_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `KEYCODE` writer - KEYCODE
        pub type KEYCODE_W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            ///Bit 0 - HWSTKCTRL
            #[inline(always)]
            pub fn hwstkctrl(&self) -> HWSTKCTRL_R {
                HWSTKCTRL_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - NESTCTRL
            #[inline(always)]
            pub fn nestctrl(&self) -> NESTCTRL_R {
                NESTCTRL_R::new(((self.bits >> 1) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - HWSTKCTRL
            #[inline(always)]
            #[must_use]
            pub fn hwstkctrl(&mut self) -> HWSTKCTRL_W<CFGR_SPEC> {
                HWSTKCTRL_W::new(self, 0)
            }
            ///Bit 1 - NESTCTRL
            #[inline(always)]
            #[must_use]
            pub fn nestctrl(&mut self) -> NESTCTRL_W<CFGR_SPEC> {
                NESTCTRL_W::new(self, 1)
            }
            ///Bit 2 - NMISET
            #[inline(always)]
            #[must_use]
            pub fn nmiset(&mut self) -> NMISET_W<CFGR_SPEC> {
                NMISET_W::new(self, 2)
            }
            ///Bit 3 - NMIRESET
            #[inline(always)]
            #[must_use]
            pub fn nmireset(&mut self) -> NMIRESET_W<CFGR_SPEC> {
                NMIRESET_W::new(self, 3)
            }
            ///Bit 4 - EXCSET
            #[inline(always)]
            #[must_use]
            pub fn excset(&mut self) -> EXCSET_W<CFGR_SPEC> {
                EXCSET_W::new(self, 4)
            }
            ///Bit 5 - EXCRESET
            #[inline(always)]
            #[must_use]
            pub fn excreset(&mut self) -> EXCRESET_W<CFGR_SPEC> {
                EXCRESET_W::new(self, 5)
            }
            ///Bit 6 - PFICRSET
            #[inline(always)]
            #[must_use]
            pub fn pficreset(&mut self) -> PFICRESET_W<CFGR_SPEC> {
                PFICRESET_W::new(self, 6)
            }
            ///Bit 7 - SYSRESET
            #[inline(always)]
            #[must_use]
            pub fn sysreset(&mut self) -> SYSRESET_W<CFGR_SPEC> {
                SYSRESET_W::new(self, 7)
            }
            ///Bits 16:31 - KEYCODE
            #[inline(always)]
            #[must_use]
            pub fn keycode(&mut self) -> KEYCODE_W<CFGR_SPEC> {
                KEYCODE_W::new(self, 16)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Config Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`cfgr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cfgr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct CFGR_SPEC;
        impl crate::RegisterSpec for CFGR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`cfgr::R`](R) reader structure
        impl crate::Readable for CFGR_SPEC {}
        ///`write(|w| ..)` method takes [`cfgr::W`](W) writer structure
        impl crate::Writable for CFGR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets CFGR to value 0
        impl crate::Resettable for CFGR_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///GISR (r) register accessor: Interrupt Global Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`gisr::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@gisr`]
    ///module
    pub type GISR = crate::Reg<gisr::GISR_SPEC>;
    ///Interrupt Global Register
    pub mod gisr {
        ///Register `GISR` reader
        pub type R = crate::R<GISR_SPEC>;
        ///Field `NESTSTA` reader - NESTSTA
        pub type NESTSTA_R = crate::FieldReader;
        ///Field `GACTSTA` reader - GACTSTA
        pub type GACTSTA_R = crate::BitReader;
        ///Field `GPENDSTA` reader - GPENDSTA
        pub type GPENDSTA_R = crate::BitReader;
        impl R {
            ///Bits 0:7 - NESTSTA
            #[inline(always)]
            pub fn neststa(&self) -> NESTSTA_R {
                NESTSTA_R::new((self.bits & 0xff) as u8)
            }
            ///Bit 8 - GACTSTA
            #[inline(always)]
            pub fn gactsta(&self) -> GACTSTA_R {
                GACTSTA_R::new(((self.bits >> 8) & 1) != 0)
            }
            ///Bit 9 - GPENDSTA
            #[inline(always)]
            pub fn gpendsta(&self) -> GPENDSTA_R {
                GPENDSTA_R::new(((self.bits >> 9) & 1) != 0)
            }
        }
        ///Interrupt Global Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`gisr::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct GISR_SPEC;
        impl crate::RegisterSpec for GISR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`gisr::R`](R) reader structure
        impl crate::Readable for GISR_SPEC {}
        ///`reset()` method sets GISR to value 0
        impl crate::Resettable for GISR_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///FIFOADDRR0 (rw) register accessor: Interrupt 0 address Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`fifoaddrr0::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`fifoaddrr0::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@fifoaddrr0`]
    ///module
    pub type FIFOADDRR0 = crate::Reg<fifoaddrr0::FIFOADDRR0_SPEC>;
    ///Interrupt 0 address Register
    pub mod fifoaddrr0 {
        ///Register `FIFOADDRR0` reader
        pub type R = crate::R<FIFOADDRR0_SPEC>;
        ///Register `FIFOADDRR0` writer
        pub type W = crate::W<FIFOADDRR0_SPEC>;
        ///Field `OFFADDR0` reader - OFFADDR0
        pub type OFFADDR0_R = crate::FieldReader<u32>;
        ///Field `OFFADDR0` writer - OFFADDR0
        pub type OFFADDR0_W<'a, REG> = crate::FieldWriter<'a, REG, 24, u32>;
        ///Field `IRQID0` reader - IRQID0
        pub type IRQID0_R = crate::FieldReader;
        ///Field `IRQID0` writer - IRQID0
        pub type IRQID0_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            ///Bits 0:23 - OFFADDR0
            #[inline(always)]
            pub fn offaddr0(&self) -> OFFADDR0_R {
                OFFADDR0_R::new(self.bits & 0x00ff_ffff)
            }
            ///Bits 24:31 - IRQID0
            #[inline(always)]
            pub fn irqid0(&self) -> IRQID0_R {
                IRQID0_R::new(((self.bits >> 24) & 0xff) as u8)
            }
        }
        impl W {
            ///Bits 0:23 - OFFADDR0
            #[inline(always)]
            #[must_use]
            pub fn offaddr0(&mut self) -> OFFADDR0_W<FIFOADDRR0_SPEC> {
                OFFADDR0_W::new(self, 0)
            }
            ///Bits 24:31 - IRQID0
            #[inline(always)]
            #[must_use]
            pub fn irqid0(&mut self) -> IRQID0_W<FIFOADDRR0_SPEC> {
                IRQID0_W::new(self, 24)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt 0 address Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`fifoaddrr0::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`fifoaddrr0::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct FIFOADDRR0_SPEC;
        impl crate::RegisterSpec for FIFOADDRR0_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`fifoaddrr0::R`](R) reader structure
        impl crate::Readable for FIFOADDRR0_SPEC {}
        ///`write(|w| ..)` method takes [`fifoaddrr0::W`](W) writer structure
        impl crate::Writable for FIFOADDRR0_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets FIFOADDRR0 to value 0
        impl crate::Resettable for FIFOADDRR0_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///FIFOADDRR1 (rw) register accessor: Interrupt 1 address Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`fifoaddrr1::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`fifoaddrr1::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@fifoaddrr1`]
    ///module
    pub type FIFOADDRR1 = crate::Reg<fifoaddrr1::FIFOADDRR1_SPEC>;
    ///Interrupt 1 address Register
    pub mod fifoaddrr1 {
        ///Register `FIFOADDRR1` reader
        pub type R = crate::R<FIFOADDRR1_SPEC>;
        ///Register `FIFOADDRR1` writer
        pub type W = crate::W<FIFOADDRR1_SPEC>;
        ///Field `OFFADDR1` reader - OFFADDR1
        pub type OFFADDR1_R = crate::FieldReader<u32>;
        ///Field `OFFADDR1` writer - OFFADDR1
        pub type OFFADDR1_W<'a, REG> = crate::FieldWriter<'a, REG, 24, u32>;
        ///Field `IRQID1` reader - IRQID1
        pub type IRQID1_R = crate::FieldReader;
        ///Field `IRQID1` writer - IRQID1
        pub type IRQID1_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            ///Bits 0:23 - OFFADDR1
            #[inline(always)]
            pub fn offaddr1(&self) -> OFFADDR1_R {
                OFFADDR1_R::new(self.bits & 0x00ff_ffff)
            }
            ///Bits 24:31 - IRQID1
            #[inline(always)]
            pub fn irqid1(&self) -> IRQID1_R {
                IRQID1_R::new(((self.bits >> 24) & 0xff) as u8)
            }
        }
        impl W {
            ///Bits 0:23 - OFFADDR1
            #[inline(always)]
            #[must_use]
            pub fn offaddr1(&mut self) -> OFFADDR1_W<FIFOADDRR1_SPEC> {
                OFFADDR1_W::new(self, 0)
            }
            ///Bits 24:31 - IRQID1
            #[inline(always)]
            #[must_use]
            pub fn irqid1(&mut self) -> IRQID1_W<FIFOADDRR1_SPEC> {
                IRQID1_W::new(self, 24)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt 1 address Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`fifoaddrr1::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`fifoaddrr1::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct FIFOADDRR1_SPEC;
        impl crate::RegisterSpec for FIFOADDRR1_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`fifoaddrr1::R`](R) reader structure
        impl crate::Readable for FIFOADDRR1_SPEC {}
        ///`write(|w| ..)` method takes [`fifoaddrr1::W`](W) writer structure
        impl crate::Writable for FIFOADDRR1_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets FIFOADDRR1 to value 0
        impl crate::Resettable for FIFOADDRR1_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///FIFOADDRR2 (rw) register accessor: Interrupt 2 address Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`fifoaddrr2::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`fifoaddrr2::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@fifoaddrr2`]
    ///module
    pub type FIFOADDRR2 = crate::Reg<fifoaddrr2::FIFOADDRR2_SPEC>;
    ///Interrupt 2 address Register
    pub mod fifoaddrr2 {
        ///Register `FIFOADDRR2` reader
        pub type R = crate::R<FIFOADDRR2_SPEC>;
        ///Register `FIFOADDRR2` writer
        pub type W = crate::W<FIFOADDRR2_SPEC>;
        ///Field `OFFADDR2` reader - OFFADDR2
        pub type OFFADDR2_R = crate::FieldReader<u32>;
        ///Field `OFFADDR2` writer - OFFADDR2
        pub type OFFADDR2_W<'a, REG> = crate::FieldWriter<'a, REG, 24, u32>;
        ///Field `IRQID2` reader - IRQID2
        pub type IRQID2_R = crate::FieldReader;
        ///Field `IRQID2` writer - IRQID2
        pub type IRQID2_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            ///Bits 0:23 - OFFADDR2
            #[inline(always)]
            pub fn offaddr2(&self) -> OFFADDR2_R {
                OFFADDR2_R::new(self.bits & 0x00ff_ffff)
            }
            ///Bits 24:31 - IRQID2
            #[inline(always)]
            pub fn irqid2(&self) -> IRQID2_R {
                IRQID2_R::new(((self.bits >> 24) & 0xff) as u8)
            }
        }
        impl W {
            ///Bits 0:23 - OFFADDR2
            #[inline(always)]
            #[must_use]
            pub fn offaddr2(&mut self) -> OFFADDR2_W<FIFOADDRR2_SPEC> {
                OFFADDR2_W::new(self, 0)
            }
            ///Bits 24:31 - IRQID2
            #[inline(always)]
            #[must_use]
            pub fn irqid2(&mut self) -> IRQID2_W<FIFOADDRR2_SPEC> {
                IRQID2_W::new(self, 24)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt 2 address Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`fifoaddrr2::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`fifoaddrr2::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct FIFOADDRR2_SPEC;
        impl crate::RegisterSpec for FIFOADDRR2_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`fifoaddrr2::R`](R) reader structure
        impl crate::Readable for FIFOADDRR2_SPEC {}
        ///`write(|w| ..)` method takes [`fifoaddrr2::W`](W) writer structure
        impl crate::Writable for FIFOADDRR2_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets FIFOADDRR2 to value 0
        impl crate::Resettable for FIFOADDRR2_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///FIFOADDRR3 (rw) register accessor: Interrupt 3 address Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`fifoaddrr3::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`fifoaddrr3::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@fifoaddrr3`]
    ///module
    pub type FIFOADDRR3 = crate::Reg<fifoaddrr3::FIFOADDRR3_SPEC>;
    ///Interrupt 3 address Register
    pub mod fifoaddrr3 {
        ///Register `FIFOADDRR3` reader
        pub type R = crate::R<FIFOADDRR3_SPEC>;
        ///Register `FIFOADDRR3` writer
        pub type W = crate::W<FIFOADDRR3_SPEC>;
        ///Field `OFFADDR3` reader - OFFADDR3
        pub type OFFADDR3_R = crate::FieldReader<u32>;
        ///Field `OFFADDR3` writer - OFFADDR3
        pub type OFFADDR3_W<'a, REG> = crate::FieldWriter<'a, REG, 24, u32>;
        ///Field `IRQID3` reader - IRQID3
        pub type IRQID3_R = crate::FieldReader;
        ///Field `IRQID3` writer - IRQID3
        pub type IRQID3_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            ///Bits 0:23 - OFFADDR3
            #[inline(always)]
            pub fn offaddr3(&self) -> OFFADDR3_R {
                OFFADDR3_R::new(self.bits & 0x00ff_ffff)
            }
            ///Bits 24:31 - IRQID3
            #[inline(always)]
            pub fn irqid3(&self) -> IRQID3_R {
                IRQID3_R::new(((self.bits >> 24) & 0xff) as u8)
            }
        }
        impl W {
            ///Bits 0:23 - OFFADDR3
            #[inline(always)]
            #[must_use]
            pub fn offaddr3(&mut self) -> OFFADDR3_W<FIFOADDRR3_SPEC> {
                OFFADDR3_W::new(self, 0)
            }
            ///Bits 24:31 - IRQID3
            #[inline(always)]
            #[must_use]
            pub fn irqid3(&mut self) -> IRQID3_W<FIFOADDRR3_SPEC> {
                IRQID3_W::new(self, 24)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt 3 address Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`fifoaddrr3::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`fifoaddrr3::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct FIFOADDRR3_SPEC;
        impl crate::RegisterSpec for FIFOADDRR3_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`fifoaddrr3::R`](R) reader structure
        impl crate::Readable for FIFOADDRR3_SPEC {}
        ///`write(|w| ..)` method takes [`fifoaddrr3::W`](W) writer structure
        impl crate::Writable for FIFOADDRR3_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets FIFOADDRR3 to value 0
        impl crate::Resettable for FIFOADDRR3_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IENR1 (rw) register accessor: Interrupt Setting Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`ienr1::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ienr1::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@ienr1`]
    ///module
    pub type IENR1 = crate::Reg<ienr1::IENR1_SPEC>;
    ///Interrupt Setting Register
    pub mod ienr1 {
        ///Register `IENR1` reader
        pub type R = crate::R<IENR1_SPEC>;
        ///Register `IENR1` writer
        pub type W = crate::W<IENR1_SPEC>;
        ///Field `INTEN` reader - INTEN
        pub type INTEN_R = crate::FieldReader<u32>;
        ///Field `INTEN` writer - INTEN
        pub type INTEN_W<'a, REG> = crate::FieldWriter<'a, REG, 20, u32>;
        impl R {
            ///Bits 12:31 - INTEN
            #[inline(always)]
            pub fn inten(&self) -> INTEN_R {
                INTEN_R::new((self.bits >> 12) & 0x000f_ffff)
            }
        }
        impl W {
            ///Bits 12:31 - INTEN
            #[inline(always)]
            #[must_use]
            pub fn inten(&mut self) -> INTEN_W<IENR1_SPEC> {
                INTEN_W::new(self, 12)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Setting Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`ienr1::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ienr1::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IENR1_SPEC;
        impl crate::RegisterSpec for IENR1_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`ienr1::R`](R) reader structure
        impl crate::Readable for IENR1_SPEC {}
        ///`write(|w| ..)` method takes [`ienr1::W`](W) writer structure
        impl crate::Writable for IENR1_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IENR1 to value 0
        impl crate::Resettable for IENR1_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IENR2 (rw) register accessor: Interrupt Setting Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`ienr2::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ienr2::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@ienr2`]
    ///module
    pub type IENR2 = crate::Reg<ienr2::IENR2_SPEC>;
    ///Interrupt Setting Register
    pub mod ienr2 {
        ///Register `IENR2` reader
        pub type R = crate::R<IENR2_SPEC>;
        ///Register `IENR2` writer
        pub type W = crate::W<IENR2_SPEC>;
        ///Field `INTEN` reader - INTEN
        pub type INTEN_R = crate::FieldReader<u32>;
        ///Field `INTEN` writer - INTEN
        pub type INTEN_W<'a, REG> = crate::FieldWriter<'a, REG, 28, u32>;
        impl R {
            ///Bits 0:27 - INTEN
            #[inline(always)]
            pub fn inten(&self) -> INTEN_R {
                INTEN_R::new(self.bits & 0x0fff_ffff)
            }
        }
        impl W {
            ///Bits 0:27 - INTEN
            #[inline(always)]
            #[must_use]
            pub fn inten(&mut self) -> INTEN_W<IENR2_SPEC> {
                INTEN_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Setting Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`ienr2::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ienr2::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IENR2_SPEC;
        impl crate::RegisterSpec for IENR2_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`ienr2::R`](R) reader structure
        impl crate::Readable for IENR2_SPEC {}
        ///`write(|w| ..)` method takes [`ienr2::W`](W) writer structure
        impl crate::Writable for IENR2_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IENR2 to value 0
        impl crate::Resettable for IENR2_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IRER1 (rw) register accessor: Interrupt Clear Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`irer1::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`irer1::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@irer1`]
    ///module
    pub type IRER1 = crate::Reg<irer1::IRER1_SPEC>;
    ///Interrupt Clear Register
    pub mod irer1 {
        ///Register `IRER1` reader
        pub type R = crate::R<IRER1_SPEC>;
        ///Register `IRER1` writer
        pub type W = crate::W<IRER1_SPEC>;
        ///Field `INTRESET` reader - INTRESET
        pub type INTRESET_R = crate::FieldReader<u32>;
        ///Field `INTRESET` writer - INTRESET
        pub type INTRESET_W<'a, REG> = crate::FieldWriter<'a, REG, 20, u32>;
        impl R {
            ///Bits 12:31 - INTRESET
            #[inline(always)]
            pub fn intreset(&self) -> INTRESET_R {
                INTRESET_R::new((self.bits >> 12) & 0x000f_ffff)
            }
        }
        impl W {
            ///Bits 12:31 - INTRESET
            #[inline(always)]
            #[must_use]
            pub fn intreset(&mut self) -> INTRESET_W<IRER1_SPEC> {
                INTRESET_W::new(self, 12)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Clear Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`irer1::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`irer1::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IRER1_SPEC;
        impl crate::RegisterSpec for IRER1_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`irer1::R`](R) reader structure
        impl crate::Readable for IRER1_SPEC {}
        ///`write(|w| ..)` method takes [`irer1::W`](W) writer structure
        impl crate::Writable for IRER1_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IRER1 to value 0
        impl crate::Resettable for IRER1_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IRER2 (rw) register accessor: Interrupt Clear Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`irer2::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`irer2::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@irer2`]
    ///module
    pub type IRER2 = crate::Reg<irer2::IRER2_SPEC>;
    ///Interrupt Clear Register
    pub mod irer2 {
        ///Register `IRER2` reader
        pub type R = crate::R<IRER2_SPEC>;
        ///Register `IRER2` writer
        pub type W = crate::W<IRER2_SPEC>;
        ///Field `INTRESET` reader - INTRESET
        pub type INTRESET_R = crate::FieldReader<u32>;
        ///Field `INTRESET` writer - INTRESET
        pub type INTRESET_W<'a, REG> = crate::FieldWriter<'a, REG, 28, u32>;
        impl R {
            ///Bits 0:27 - INTRESET
            #[inline(always)]
            pub fn intreset(&self) -> INTRESET_R {
                INTRESET_R::new(self.bits & 0x0fff_ffff)
            }
        }
        impl W {
            ///Bits 0:27 - INTRESET
            #[inline(always)]
            #[must_use]
            pub fn intreset(&mut self) -> INTRESET_W<IRER2_SPEC> {
                INTRESET_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Clear Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`irer2::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`irer2::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IRER2_SPEC;
        impl crate::RegisterSpec for IRER2_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`irer2::R`](R) reader structure
        impl crate::Readable for IRER2_SPEC {}
        ///`write(|w| ..)` method takes [`irer2::W`](W) writer structure
        impl crate::Writable for IRER2_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IRER2 to value 0
        impl crate::Resettable for IRER2_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPSR1 (rw) register accessor: Interrupt Pending Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`ipsr1::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ipsr1::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@ipsr1`]
    ///module
    pub type IPSR1 = crate::Reg<ipsr1::IPSR1_SPEC>;
    ///Interrupt Pending Register
    pub mod ipsr1 {
        ///Register `IPSR1` reader
        pub type R = crate::R<IPSR1_SPEC>;
        ///Register `IPSR1` writer
        pub type W = crate::W<IPSR1_SPEC>;
        ///Field `PENDSET` reader - PENDSET
        pub type PENDSET_R = crate::FieldReader<u32>;
        ///Field `PENDSET` writer - PENDSET
        pub type PENDSET_W<'a, REG> = crate::FieldWriter<'a, REG, 20, u32>;
        impl R {
            ///Bits 12:31 - PENDSET
            #[inline(always)]
            pub fn pendset(&self) -> PENDSET_R {
                PENDSET_R::new((self.bits >> 12) & 0x000f_ffff)
            }
        }
        impl W {
            ///Bits 12:31 - PENDSET
            #[inline(always)]
            #[must_use]
            pub fn pendset(&mut self) -> PENDSET_W<IPSR1_SPEC> {
                PENDSET_W::new(self, 12)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Pending Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`ipsr1::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ipsr1::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPSR1_SPEC;
        impl crate::RegisterSpec for IPSR1_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`ipsr1::R`](R) reader structure
        impl crate::Readable for IPSR1_SPEC {}
        ///`write(|w| ..)` method takes [`ipsr1::W`](W) writer structure
        impl crate::Writable for IPSR1_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPSR1 to value 0
        impl crate::Resettable for IPSR1_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPSR2 (rw) register accessor: Interrupt Pending Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`ipsr2::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ipsr2::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@ipsr2`]
    ///module
    pub type IPSR2 = crate::Reg<ipsr2::IPSR2_SPEC>;
    ///Interrupt Pending Register
    pub mod ipsr2 {
        ///Register `IPSR2` reader
        pub type R = crate::R<IPSR2_SPEC>;
        ///Register `IPSR2` writer
        pub type W = crate::W<IPSR2_SPEC>;
        ///Field `PENDSET` reader - PENDSET
        pub type PENDSET_R = crate::FieldReader<u32>;
        ///Field `PENDSET` writer - PENDSET
        pub type PENDSET_W<'a, REG> = crate::FieldWriter<'a, REG, 28, u32>;
        impl R {
            ///Bits 0:27 - PENDSET
            #[inline(always)]
            pub fn pendset(&self) -> PENDSET_R {
                PENDSET_R::new(self.bits & 0x0fff_ffff)
            }
        }
        impl W {
            ///Bits 0:27 - PENDSET
            #[inline(always)]
            #[must_use]
            pub fn pendset(&mut self) -> PENDSET_W<IPSR2_SPEC> {
                PENDSET_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Pending Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`ipsr2::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ipsr2::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPSR2_SPEC;
        impl crate::RegisterSpec for IPSR2_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`ipsr2::R`](R) reader structure
        impl crate::Readable for IPSR2_SPEC {}
        ///`write(|w| ..)` method takes [`ipsr2::W`](W) writer structure
        impl crate::Writable for IPSR2_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPSR2 to value 0
        impl crate::Resettable for IPSR2_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRR1 (rw) register accessor: Interrupt Pending Clear Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprr1::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprr1::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprr1`]
    ///module
    pub type IPRR1 = crate::Reg<iprr1::IPRR1_SPEC>;
    ///Interrupt Pending Clear Register
    pub mod iprr1 {
        ///Register `IPRR1` reader
        pub type R = crate::R<IPRR1_SPEC>;
        ///Register `IPRR1` writer
        pub type W = crate::W<IPRR1_SPEC>;
        ///Field `PENDRESET` reader - PENDRESET
        pub type PENDRESET_R = crate::FieldReader<u32>;
        ///Field `PENDRESET` writer - PENDRESET
        pub type PENDRESET_W<'a, REG> = crate::FieldWriter<'a, REG, 20, u32>;
        impl R {
            ///Bits 12:31 - PENDRESET
            #[inline(always)]
            pub fn pendreset(&self) -> PENDRESET_R {
                PENDRESET_R::new((self.bits >> 12) & 0x000f_ffff)
            }
        }
        impl W {
            ///Bits 12:31 - PENDRESET
            #[inline(always)]
            #[must_use]
            pub fn pendreset(&mut self) -> PENDRESET_W<IPRR1_SPEC> {
                PENDRESET_W::new(self, 12)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Pending Clear Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprr1::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprr1::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRR1_SPEC;
        impl crate::RegisterSpec for IPRR1_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprr1::R`](R) reader structure
        impl crate::Readable for IPRR1_SPEC {}
        ///`write(|w| ..)` method takes [`iprr1::W`](W) writer structure
        impl crate::Writable for IPRR1_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRR1 to value 0
        impl crate::Resettable for IPRR1_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRR2 (rw) register accessor: Interrupt Pending Clear Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprr2::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprr2::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprr2`]
    ///module
    pub type IPRR2 = crate::Reg<iprr2::IPRR2_SPEC>;
    ///Interrupt Pending Clear Register
    pub mod iprr2 {
        ///Register `IPRR2` reader
        pub type R = crate::R<IPRR2_SPEC>;
        ///Register `IPRR2` writer
        pub type W = crate::W<IPRR2_SPEC>;
        ///Field `PENDRESET` reader - PENDRESET
        pub type PENDRESET_R = crate::FieldReader<u32>;
        ///Field `PENDRESET` writer - PENDRESET
        pub type PENDRESET_W<'a, REG> = crate::FieldWriter<'a, REG, 28, u32>;
        impl R {
            ///Bits 0:27 - PENDRESET
            #[inline(always)]
            pub fn pendreset(&self) -> PENDRESET_R {
                PENDRESET_R::new(self.bits & 0x0fff_ffff)
            }
        }
        impl W {
            ///Bits 0:27 - PENDRESET
            #[inline(always)]
            #[must_use]
            pub fn pendreset(&mut self) -> PENDRESET_W<IPRR2_SPEC> {
                PENDRESET_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Pending Clear Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprr2::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprr2::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRR2_SPEC;
        impl crate::RegisterSpec for IPRR2_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprr2::R`](R) reader structure
        impl crate::Readable for IPRR2_SPEC {}
        ///`write(|w| ..)` method takes [`iprr2::W`](W) writer structure
        impl crate::Writable for IPRR2_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRR2 to value 0
        impl crate::Resettable for IPRR2_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IACTR1 (rw) register accessor: Interrupt ACTIVE Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iactr1::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iactr1::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iactr1`]
    ///module
    pub type IACTR1 = crate::Reg<iactr1::IACTR1_SPEC>;
    ///Interrupt ACTIVE Register
    pub mod iactr1 {
        ///Register `IACTR1` reader
        pub type R = crate::R<IACTR1_SPEC>;
        ///Register `IACTR1` writer
        pub type W = crate::W<IACTR1_SPEC>;
        ///Field `IACTS` reader - IACTS
        pub type IACTS_R = crate::FieldReader<u32>;
        ///Field `IACTS` writer - IACTS
        pub type IACTS_W<'a, REG> = crate::FieldWriter<'a, REG, 20, u32>;
        impl R {
            ///Bits 12:31 - IACTS
            #[inline(always)]
            pub fn iacts(&self) -> IACTS_R {
                IACTS_R::new((self.bits >> 12) & 0x000f_ffff)
            }
        }
        impl W {
            ///Bits 12:31 - IACTS
            #[inline(always)]
            #[must_use]
            pub fn iacts(&mut self) -> IACTS_W<IACTR1_SPEC> {
                IACTS_W::new(self, 12)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt ACTIVE Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iactr1::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iactr1::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IACTR1_SPEC;
        impl crate::RegisterSpec for IACTR1_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iactr1::R`](R) reader structure
        impl crate::Readable for IACTR1_SPEC {}
        ///`write(|w| ..)` method takes [`iactr1::W`](W) writer structure
        impl crate::Writable for IACTR1_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IACTR1 to value 0
        impl crate::Resettable for IACTR1_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IACTR2 (rw) register accessor: Interrupt ACTIVE Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iactr2::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iactr2::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iactr2`]
    ///module
    pub type IACTR2 = crate::Reg<iactr2::IACTR2_SPEC>;
    ///Interrupt ACTIVE Register
    pub mod iactr2 {
        ///Register `IACTR2` reader
        pub type R = crate::R<IACTR2_SPEC>;
        ///Register `IACTR2` writer
        pub type W = crate::W<IACTR2_SPEC>;
        ///Field `IACTS` reader - IACTS
        pub type IACTS_R = crate::FieldReader<u32>;
        ///Field `IACTS` writer - IACTS
        pub type IACTS_W<'a, REG> = crate::FieldWriter<'a, REG, 28, u32>;
        impl R {
            ///Bits 0:27 - IACTS
            #[inline(always)]
            pub fn iacts(&self) -> IACTS_R {
                IACTS_R::new(self.bits & 0x0fff_ffff)
            }
        }
        impl W {
            ///Bits 0:27 - IACTS
            #[inline(always)]
            #[must_use]
            pub fn iacts(&mut self) -> IACTS_W<IACTR2_SPEC> {
                IACTS_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt ACTIVE Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iactr2::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iactr2::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IACTR2_SPEC;
        impl crate::RegisterSpec for IACTR2_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iactr2::R`](R) reader structure
        impl crate::Readable for IACTR2_SPEC {}
        ///`write(|w| ..)` method takes [`iactr2::W`](W) writer structure
        impl crate::Writable for IACTR2_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IACTR2 to value 0
        impl crate::Resettable for IACTR2_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR0 (rw) register accessor: Interrupt Priority configuration Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior0::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior0::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior0`]
    ///module
    pub type IPRIOR0 = crate::Reg<iprior0::IPRIOR0_SPEC>;
    ///Interrupt Priority configuration Register
    pub mod iprior0 {
        ///Register `IPRIOR0` reader
        pub type R = crate::R<IPRIOR0_SPEC>;
        ///Register `IPRIOR0` writer
        pub type W = crate::W<IPRIOR0_SPEC>;
        ///Field `IPRIOR0` reader - IPRIOR0
        pub type IPRIOR0_R = crate::FieldReader<u32>;
        ///Field `IPRIOR0` writer - IPRIOR0
        pub type IPRIOR0_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - IPRIOR0
            #[inline(always)]
            pub fn iprior0(&self) -> IPRIOR0_R {
                IPRIOR0_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - IPRIOR0
            #[inline(always)]
            #[must_use]
            pub fn iprior0(&mut self) -> IPRIOR0_W<IPRIOR0_SPEC> {
                IPRIOR0_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior0::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior0::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR0_SPEC;
        impl crate::RegisterSpec for IPRIOR0_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior0::R`](R) reader structure
        impl crate::Readable for IPRIOR0_SPEC {}
        ///`write(|w| ..)` method takes [`iprior0::W`](W) writer structure
        impl crate::Writable for IPRIOR0_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR0 to value 0
        impl crate::Resettable for IPRIOR0_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR1 (rw) register accessor: Interrupt Priority configuration Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior1::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior1::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior1`]
    ///module
    pub type IPRIOR1 = crate::Reg<iprior1::IPRIOR1_SPEC>;
    ///Interrupt Priority configuration Register
    pub mod iprior1 {
        ///Register `IPRIOR1` reader
        pub type R = crate::R<IPRIOR1_SPEC>;
        ///Register `IPRIOR1` writer
        pub type W = crate::W<IPRIOR1_SPEC>;
        ///Field `IPRIOR1` reader - IPRIOR1
        pub type IPRIOR1_R = crate::FieldReader<u32>;
        ///Field `IPRIOR1` writer - IPRIOR1
        pub type IPRIOR1_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - IPRIOR1
            #[inline(always)]
            pub fn iprior1(&self) -> IPRIOR1_R {
                IPRIOR1_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - IPRIOR1
            #[inline(always)]
            #[must_use]
            pub fn iprior1(&mut self) -> IPRIOR1_W<IPRIOR1_SPEC> {
                IPRIOR1_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior1::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior1::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR1_SPEC;
        impl crate::RegisterSpec for IPRIOR1_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior1::R`](R) reader structure
        impl crate::Readable for IPRIOR1_SPEC {}
        ///`write(|w| ..)` method takes [`iprior1::W`](W) writer structure
        impl crate::Writable for IPRIOR1_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR1 to value 0
        impl crate::Resettable for IPRIOR1_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR2 (rw) register accessor: Interrupt Priority configuration Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior2::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior2::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior2`]
    ///module
    pub type IPRIOR2 = crate::Reg<iprior2::IPRIOR2_SPEC>;
    ///Interrupt Priority configuration Register
    pub mod iprior2 {
        ///Register `IPRIOR2` reader
        pub type R = crate::R<IPRIOR2_SPEC>;
        ///Register `IPRIOR2` writer
        pub type W = crate::W<IPRIOR2_SPEC>;
        ///Field `IPRIOR2` reader - IPRIOR2
        pub type IPRIOR2_R = crate::FieldReader<u32>;
        ///Field `IPRIOR2` writer - IPRIOR2
        pub type IPRIOR2_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - IPRIOR2
            #[inline(always)]
            pub fn iprior2(&self) -> IPRIOR2_R {
                IPRIOR2_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - IPRIOR2
            #[inline(always)]
            #[must_use]
            pub fn iprior2(&mut self) -> IPRIOR2_W<IPRIOR2_SPEC> {
                IPRIOR2_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior2::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior2::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR2_SPEC;
        impl crate::RegisterSpec for IPRIOR2_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior2::R`](R) reader structure
        impl crate::Readable for IPRIOR2_SPEC {}
        ///`write(|w| ..)` method takes [`iprior2::W`](W) writer structure
        impl crate::Writable for IPRIOR2_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR2 to value 0
        impl crate::Resettable for IPRIOR2_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR3 (rw) register accessor: Interrupt Priority configuration Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior3::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior3::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior3`]
    ///module
    pub type IPRIOR3 = crate::Reg<iprior3::IPRIOR3_SPEC>;
    ///Interrupt Priority configuration Register
    pub mod iprior3 {
        ///Register `IPRIOR3` reader
        pub type R = crate::R<IPRIOR3_SPEC>;
        ///Register `IPRIOR3` writer
        pub type W = crate::W<IPRIOR3_SPEC>;
        ///Field `IPRIOR3` reader - IPRIOR3
        pub type IPRIOR3_R = crate::FieldReader<u32>;
        ///Field `IPRIOR3` writer - IPRIOR3
        pub type IPRIOR3_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - IPRIOR3
            #[inline(always)]
            pub fn iprior3(&self) -> IPRIOR3_R {
                IPRIOR3_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - IPRIOR3
            #[inline(always)]
            #[must_use]
            pub fn iprior3(&mut self) -> IPRIOR3_W<IPRIOR3_SPEC> {
                IPRIOR3_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior3::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior3::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR3_SPEC;
        impl crate::RegisterSpec for IPRIOR3_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior3::R`](R) reader structure
        impl crate::Readable for IPRIOR3_SPEC {}
        ///`write(|w| ..)` method takes [`iprior3::W`](W) writer structure
        impl crate::Writable for IPRIOR3_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR3 to value 0
        impl crate::Resettable for IPRIOR3_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR4 (rw) register accessor: Interrupt Priority configuration Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior4::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior4::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior4`]
    ///module
    pub type IPRIOR4 = crate::Reg<iprior4::IPRIOR4_SPEC>;
    ///Interrupt Priority configuration Register
    pub mod iprior4 {
        ///Register `IPRIOR4` reader
        pub type R = crate::R<IPRIOR4_SPEC>;
        ///Register `IPRIOR4` writer
        pub type W = crate::W<IPRIOR4_SPEC>;
        ///Field `IPRIOR4` reader - IPRIOR4
        pub type IPRIOR4_R = crate::FieldReader<u32>;
        ///Field `IPRIOR4` writer - IPRIOR4
        pub type IPRIOR4_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - IPRIOR4
            #[inline(always)]
            pub fn iprior4(&self) -> IPRIOR4_R {
                IPRIOR4_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - IPRIOR4
            #[inline(always)]
            #[must_use]
            pub fn iprior4(&mut self) -> IPRIOR4_W<IPRIOR4_SPEC> {
                IPRIOR4_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior4::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior4::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR4_SPEC;
        impl crate::RegisterSpec for IPRIOR4_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior4::R`](R) reader structure
        impl crate::Readable for IPRIOR4_SPEC {}
        ///`write(|w| ..)` method takes [`iprior4::W`](W) writer structure
        impl crate::Writable for IPRIOR4_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR4 to value 0
        impl crate::Resettable for IPRIOR4_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR5 (rw) register accessor: Interrupt Priority configuration Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior5::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior5::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior5`]
    ///module
    pub type IPRIOR5 = crate::Reg<iprior5::IPRIOR5_SPEC>;
    ///Interrupt Priority configuration Register
    pub mod iprior5 {
        ///Register `IPRIOR5` reader
        pub type R = crate::R<IPRIOR5_SPEC>;
        ///Register `IPRIOR5` writer
        pub type W = crate::W<IPRIOR5_SPEC>;
        ///Field `IPRIOR5` reader - IPRIOR5
        pub type IPRIOR5_R = crate::FieldReader<u32>;
        ///Field `IPRIOR5` writer - IPRIOR5
        pub type IPRIOR5_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - IPRIOR5
            #[inline(always)]
            pub fn iprior5(&self) -> IPRIOR5_R {
                IPRIOR5_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - IPRIOR5
            #[inline(always)]
            #[must_use]
            pub fn iprior5(&mut self) -> IPRIOR5_W<IPRIOR5_SPEC> {
                IPRIOR5_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior5::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior5::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR5_SPEC;
        impl crate::RegisterSpec for IPRIOR5_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior5::R`](R) reader structure
        impl crate::Readable for IPRIOR5_SPEC {}
        ///`write(|w| ..)` method takes [`iprior5::W`](W) writer structure
        impl crate::Writable for IPRIOR5_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR5 to value 0
        impl crate::Resettable for IPRIOR5_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR6 (rw) register accessor: Interrupt Priority configuration Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior6::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior6::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior6`]
    ///module
    pub type IPRIOR6 = crate::Reg<iprior6::IPRIOR6_SPEC>;
    ///Interrupt Priority configuration Register
    pub mod iprior6 {
        ///Register `IPRIOR6` reader
        pub type R = crate::R<IPRIOR6_SPEC>;
        ///Register `IPRIOR6` writer
        pub type W = crate::W<IPRIOR6_SPEC>;
        ///Field `IPRIOR6` reader - IPRIOR6
        pub type IPRIOR6_R = crate::FieldReader<u32>;
        ///Field `IPRIOR6` writer - IPRIOR6
        pub type IPRIOR6_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - IPRIOR6
            #[inline(always)]
            pub fn iprior6(&self) -> IPRIOR6_R {
                IPRIOR6_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - IPRIOR6
            #[inline(always)]
            #[must_use]
            pub fn iprior6(&mut self) -> IPRIOR6_W<IPRIOR6_SPEC> {
                IPRIOR6_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior6::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior6::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR6_SPEC;
        impl crate::RegisterSpec for IPRIOR6_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior6::R`](R) reader structure
        impl crate::Readable for IPRIOR6_SPEC {}
        ///`write(|w| ..)` method takes [`iprior6::W`](W) writer structure
        impl crate::Writable for IPRIOR6_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR6 to value 0
        impl crate::Resettable for IPRIOR6_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR7 (rw) register accessor: Interrupt Priority configuration Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior7::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior7::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior7`]
    ///module
    pub type IPRIOR7 = crate::Reg<iprior7::IPRIOR7_SPEC>;
    ///Interrupt Priority configuration Register
    pub mod iprior7 {
        ///Register `IPRIOR7` reader
        pub type R = crate::R<IPRIOR7_SPEC>;
        ///Register `IPRIOR7` writer
        pub type W = crate::W<IPRIOR7_SPEC>;
        ///Field `IPRIOR7` reader - IPRIOR7
        pub type IPRIOR7_R = crate::FieldReader<u32>;
        ///Field `IPRIOR7` writer - IPRIOR7
        pub type IPRIOR7_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - IPRIOR7
            #[inline(always)]
            pub fn iprior7(&self) -> IPRIOR7_R {
                IPRIOR7_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - IPRIOR7
            #[inline(always)]
            #[must_use]
            pub fn iprior7(&mut self) -> IPRIOR7_W<IPRIOR7_SPEC> {
                IPRIOR7_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior7::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior7::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR7_SPEC;
        impl crate::RegisterSpec for IPRIOR7_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior7::R`](R) reader structure
        impl crate::Readable for IPRIOR7_SPEC {}
        ///`write(|w| ..)` method takes [`iprior7::W`](W) writer structure
        impl crate::Writable for IPRIOR7_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR7 to value 0
        impl crate::Resettable for IPRIOR7_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR8 (rw) register accessor: Interrupt Priority configuration Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior8::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior8::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior8`]
    ///module
    pub type IPRIOR8 = crate::Reg<iprior8::IPRIOR8_SPEC>;
    ///Interrupt Priority configuration Register
    pub mod iprior8 {
        ///Register `IPRIOR8` reader
        pub type R = crate::R<IPRIOR8_SPEC>;
        ///Register `IPRIOR8` writer
        pub type W = crate::W<IPRIOR8_SPEC>;
        ///Field `IPRIOR8` reader - IPRIOR8
        pub type IPRIOR8_R = crate::FieldReader<u32>;
        ///Field `IPRIOR8` writer - IPRIOR8
        pub type IPRIOR8_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - IPRIOR8
            #[inline(always)]
            pub fn iprior8(&self) -> IPRIOR8_R {
                IPRIOR8_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - IPRIOR8
            #[inline(always)]
            #[must_use]
            pub fn iprior8(&mut self) -> IPRIOR8_W<IPRIOR8_SPEC> {
                IPRIOR8_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior8::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior8::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR8_SPEC;
        impl crate::RegisterSpec for IPRIOR8_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior8::R`](R) reader structure
        impl crate::Readable for IPRIOR8_SPEC {}
        ///`write(|w| ..)` method takes [`iprior8::W`](W) writer structure
        impl crate::Writable for IPRIOR8_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR8 to value 0
        impl crate::Resettable for IPRIOR8_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR9 (rw) register accessor: Interrupt Priority configuration Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior9::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior9::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior9`]
    ///module
    pub type IPRIOR9 = crate::Reg<iprior9::IPRIOR9_SPEC>;
    ///Interrupt Priority configuration Register
    pub mod iprior9 {
        ///Register `IPRIOR9` reader
        pub type R = crate::R<IPRIOR9_SPEC>;
        ///Register `IPRIOR9` writer
        pub type W = crate::W<IPRIOR9_SPEC>;
        ///Field `IPRIOR9` reader - IPRIOR9
        pub type IPRIOR9_R = crate::FieldReader<u32>;
        ///Field `IPRIOR9` writer - IPRIOR9
        pub type IPRIOR9_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - IPRIOR9
            #[inline(always)]
            pub fn iprior9(&self) -> IPRIOR9_R {
                IPRIOR9_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - IPRIOR9
            #[inline(always)]
            #[must_use]
            pub fn iprior9(&mut self) -> IPRIOR9_W<IPRIOR9_SPEC> {
                IPRIOR9_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior9::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior9::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR9_SPEC;
        impl crate::RegisterSpec for IPRIOR9_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior9::R`](R) reader structure
        impl crate::Readable for IPRIOR9_SPEC {}
        ///`write(|w| ..)` method takes [`iprior9::W`](W) writer structure
        impl crate::Writable for IPRIOR9_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR9 to value 0
        impl crate::Resettable for IPRIOR9_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR10 (rw) register accessor: Interrupt Priority configuration Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior10::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior10::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior10`]
    ///module
    pub type IPRIOR10 = crate::Reg<iprior10::IPRIOR10_SPEC>;
    ///Interrupt Priority configuration Register
    pub mod iprior10 {
        ///Register `IPRIOR10` reader
        pub type R = crate::R<IPRIOR10_SPEC>;
        ///Register `IPRIOR10` writer
        pub type W = crate::W<IPRIOR10_SPEC>;
        ///Field `IPRIOR10` reader - IPRIOR10
        pub type IPRIOR10_R = crate::FieldReader<u32>;
        ///Field `IPRIOR10` writer - IPRIOR10
        pub type IPRIOR10_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - IPRIOR10
            #[inline(always)]
            pub fn iprior10(&self) -> IPRIOR10_R {
                IPRIOR10_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - IPRIOR10
            #[inline(always)]
            #[must_use]
            pub fn iprior10(&mut self) -> IPRIOR10_W<IPRIOR10_SPEC> {
                IPRIOR10_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior10::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior10::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR10_SPEC;
        impl crate::RegisterSpec for IPRIOR10_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior10::R`](R) reader structure
        impl crate::Readable for IPRIOR10_SPEC {}
        ///`write(|w| ..)` method takes [`iprior10::W`](W) writer structure
        impl crate::Writable for IPRIOR10_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR10 to value 0
        impl crate::Resettable for IPRIOR10_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR11 (rw) register accessor: Interrupt Priority configuration Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior11::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior11::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior11`]
    ///module
    pub type IPRIOR11 = crate::Reg<iprior11::IPRIOR11_SPEC>;
    ///Interrupt Priority configuration Register
    pub mod iprior11 {
        ///Register `IPRIOR11` reader
        pub type R = crate::R<IPRIOR11_SPEC>;
        ///Register `IPRIOR11` writer
        pub type W = crate::W<IPRIOR11_SPEC>;
        ///Field `IPRIOR11` reader - IPRIOR11
        pub type IPRIOR11_R = crate::FieldReader<u32>;
        ///Field `IPRIOR11` writer - IPRIOR11
        pub type IPRIOR11_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - IPRIOR11
            #[inline(always)]
            pub fn iprior11(&self) -> IPRIOR11_R {
                IPRIOR11_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - IPRIOR11
            #[inline(always)]
            #[must_use]
            pub fn iprior11(&mut self) -> IPRIOR11_W<IPRIOR11_SPEC> {
                IPRIOR11_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior11::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior11::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR11_SPEC;
        impl crate::RegisterSpec for IPRIOR11_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior11::R`](R) reader structure
        impl crate::Readable for IPRIOR11_SPEC {}
        ///`write(|w| ..)` method takes [`iprior11::W`](W) writer structure
        impl crate::Writable for IPRIOR11_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR11 to value 0
        impl crate::Resettable for IPRIOR11_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR12 (rw) register accessor: Interrupt Priority configuration Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior12::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior12::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior12`]
    ///module
    pub type IPRIOR12 = crate::Reg<iprior12::IPRIOR12_SPEC>;
    ///Interrupt Priority configuration Register
    pub mod iprior12 {
        ///Register `IPRIOR12` reader
        pub type R = crate::R<IPRIOR12_SPEC>;
        ///Register `IPRIOR12` writer
        pub type W = crate::W<IPRIOR12_SPEC>;
        ///Field `IPRIOR12` reader - IPRIOR12
        pub type IPRIOR12_R = crate::FieldReader<u32>;
        ///Field `IPRIOR12` writer - IPRIOR12
        pub type IPRIOR12_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - IPRIOR12
            #[inline(always)]
            pub fn iprior12(&self) -> IPRIOR12_R {
                IPRIOR12_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - IPRIOR12
            #[inline(always)]
            #[must_use]
            pub fn iprior12(&mut self) -> IPRIOR12_W<IPRIOR12_SPEC> {
                IPRIOR12_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior12::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior12::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR12_SPEC;
        impl crate::RegisterSpec for IPRIOR12_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior12::R`](R) reader structure
        impl crate::Readable for IPRIOR12_SPEC {}
        ///`write(|w| ..)` method takes [`iprior12::W`](W) writer structure
        impl crate::Writable for IPRIOR12_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR12 to value 0
        impl crate::Resettable for IPRIOR12_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR13 (rw) register accessor: Interrupt Priority configuration Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior13::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior13::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior13`]
    ///module
    pub type IPRIOR13 = crate::Reg<iprior13::IPRIOR13_SPEC>;
    ///Interrupt Priority configuration Register
    pub mod iprior13 {
        ///Register `IPRIOR13` reader
        pub type R = crate::R<IPRIOR13_SPEC>;
        ///Register `IPRIOR13` writer
        pub type W = crate::W<IPRIOR13_SPEC>;
        ///Field `IPRIOR13` reader - IPRIOR13
        pub type IPRIOR13_R = crate::FieldReader<u32>;
        ///Field `IPRIOR13` writer - IPRIOR13
        pub type IPRIOR13_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - IPRIOR13
            #[inline(always)]
            pub fn iprior13(&self) -> IPRIOR13_R {
                IPRIOR13_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - IPRIOR13
            #[inline(always)]
            #[must_use]
            pub fn iprior13(&mut self) -> IPRIOR13_W<IPRIOR13_SPEC> {
                IPRIOR13_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior13::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior13::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR13_SPEC;
        impl crate::RegisterSpec for IPRIOR13_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior13::R`](R) reader structure
        impl crate::Readable for IPRIOR13_SPEC {}
        ///`write(|w| ..)` method takes [`iprior13::W`](W) writer structure
        impl crate::Writable for IPRIOR13_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR13 to value 0
        impl crate::Resettable for IPRIOR13_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR14 (rw) register accessor: Interrupt Priority configuration Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior14::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior14::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior14`]
    ///module
    pub type IPRIOR14 = crate::Reg<iprior14::IPRIOR14_SPEC>;
    ///Interrupt Priority configuration Register
    pub mod iprior14 {
        ///Register `IPRIOR14` reader
        pub type R = crate::R<IPRIOR14_SPEC>;
        ///Register `IPRIOR14` writer
        pub type W = crate::W<IPRIOR14_SPEC>;
        ///Field `IPRIOR14` reader - IPRIOR14
        pub type IPRIOR14_R = crate::FieldReader<u32>;
        ///Field `IPRIOR14` writer - IPRIOR14
        pub type IPRIOR14_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - IPRIOR14
            #[inline(always)]
            pub fn iprior14(&self) -> IPRIOR14_R {
                IPRIOR14_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - IPRIOR14
            #[inline(always)]
            #[must_use]
            pub fn iprior14(&mut self) -> IPRIOR14_W<IPRIOR14_SPEC> {
                IPRIOR14_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior14::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior14::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR14_SPEC;
        impl crate::RegisterSpec for IPRIOR14_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior14::R`](R) reader structure
        impl crate::Readable for IPRIOR14_SPEC {}
        ///`write(|w| ..)` method takes [`iprior14::W`](W) writer structure
        impl crate::Writable for IPRIOR14_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR14 to value 0
        impl crate::Resettable for IPRIOR14_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR15 (rw) register accessor: Interrupt Priority configuration Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior15::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior15::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior15`]
    ///module
    pub type IPRIOR15 = crate::Reg<iprior15::IPRIOR15_SPEC>;
    ///Interrupt Priority configuration Register
    pub mod iprior15 {
        ///Register `IPRIOR15` reader
        pub type R = crate::R<IPRIOR15_SPEC>;
        ///Register `IPRIOR15` writer
        pub type W = crate::W<IPRIOR15_SPEC>;
        ///Field `IPRIOR15` reader - IPRIOR15
        pub type IPRIOR15_R = crate::FieldReader<u32>;
        ///Field `IPRIOR15` writer - IPRIOR15
        pub type IPRIOR15_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - IPRIOR15
            #[inline(always)]
            pub fn iprior15(&self) -> IPRIOR15_R {
                IPRIOR15_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - IPRIOR15
            #[inline(always)]
            #[must_use]
            pub fn iprior15(&mut self) -> IPRIOR15_W<IPRIOR15_SPEC> {
                IPRIOR15_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior15::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior15::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR15_SPEC;
        impl crate::RegisterSpec for IPRIOR15_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior15::R`](R) reader structure
        impl crate::Readable for IPRIOR15_SPEC {}
        ///`write(|w| ..)` method takes [`iprior15::W`](W) writer structure
        impl crate::Writable for IPRIOR15_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR15 to value 0
        impl crate::Resettable for IPRIOR15_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR16 (rw) register accessor: Interrupt Priority configuration Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior16::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior16::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior16`]
    ///module
    pub type IPRIOR16 = crate::Reg<iprior16::IPRIOR16_SPEC>;
    ///Interrupt Priority configuration Register
    pub mod iprior16 {
        ///Register `IPRIOR16` reader
        pub type R = crate::R<IPRIOR16_SPEC>;
        ///Register `IPRIOR16` writer
        pub type W = crate::W<IPRIOR16_SPEC>;
        ///Field `IPRIOR16` reader - IPRIOR16
        pub type IPRIOR16_R = crate::FieldReader<u32>;
        ///Field `IPRIOR16` writer - IPRIOR16
        pub type IPRIOR16_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - IPRIOR16
            #[inline(always)]
            pub fn iprior16(&self) -> IPRIOR16_R {
                IPRIOR16_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - IPRIOR16
            #[inline(always)]
            #[must_use]
            pub fn iprior16(&mut self) -> IPRIOR16_W<IPRIOR16_SPEC> {
                IPRIOR16_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior16::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior16::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR16_SPEC;
        impl crate::RegisterSpec for IPRIOR16_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior16::R`](R) reader structure
        impl crate::Readable for IPRIOR16_SPEC {}
        ///`write(|w| ..)` method takes [`iprior16::W`](W) writer structure
        impl crate::Writable for IPRIOR16_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR16 to value 0
        impl crate::Resettable for IPRIOR16_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR17 (rw) register accessor: Interrupt Priority configuration Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior17::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior17::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior17`]
    ///module
    pub type IPRIOR17 = crate::Reg<iprior17::IPRIOR17_SPEC>;
    ///Interrupt Priority configuration Register
    pub mod iprior17 {
        ///Register `IPRIOR17` reader
        pub type R = crate::R<IPRIOR17_SPEC>;
        ///Register `IPRIOR17` writer
        pub type W = crate::W<IPRIOR17_SPEC>;
        ///Field `IPRIOR17` reader - IPRIOR17
        pub type IPRIOR17_R = crate::FieldReader<u32>;
        ///Field `IPRIOR17` writer - IPRIOR17
        pub type IPRIOR17_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - IPRIOR17
            #[inline(always)]
            pub fn iprior17(&self) -> IPRIOR17_R {
                IPRIOR17_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - IPRIOR17
            #[inline(always)]
            #[must_use]
            pub fn iprior17(&mut self) -> IPRIOR17_W<IPRIOR17_SPEC> {
                IPRIOR17_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior17::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior17::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR17_SPEC;
        impl crate::RegisterSpec for IPRIOR17_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior17::R`](R) reader structure
        impl crate::Readable for IPRIOR17_SPEC {}
        ///`write(|w| ..)` method takes [`iprior17::W`](W) writer structure
        impl crate::Writable for IPRIOR17_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR17 to value 0
        impl crate::Resettable for IPRIOR17_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR18 (rw) register accessor: Interrupt Priority configuration Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior18::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior18::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior18`]
    ///module
    pub type IPRIOR18 = crate::Reg<iprior18::IPRIOR18_SPEC>;
    ///Interrupt Priority configuration Register
    pub mod iprior18 {
        ///Register `IPRIOR18` reader
        pub type R = crate::R<IPRIOR18_SPEC>;
        ///Register `IPRIOR18` writer
        pub type W = crate::W<IPRIOR18_SPEC>;
        ///Field `IPRIOR18` reader - IPRIOR18
        pub type IPRIOR18_R = crate::FieldReader<u32>;
        ///Field `IPRIOR18` writer - IPRIOR18
        pub type IPRIOR18_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - IPRIOR18
            #[inline(always)]
            pub fn iprior18(&self) -> IPRIOR18_R {
                IPRIOR18_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - IPRIOR18
            #[inline(always)]
            #[must_use]
            pub fn iprior18(&mut self) -> IPRIOR18_W<IPRIOR18_SPEC> {
                IPRIOR18_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior18::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior18::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR18_SPEC;
        impl crate::RegisterSpec for IPRIOR18_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior18::R`](R) reader structure
        impl crate::Readable for IPRIOR18_SPEC {}
        ///`write(|w| ..)` method takes [`iprior18::W`](W) writer structure
        impl crate::Writable for IPRIOR18_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR18 to value 0
        impl crate::Resettable for IPRIOR18_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR19 (rw) register accessor: Interrupt Priority configuration Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior19::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior19::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior19`]
    ///module
    pub type IPRIOR19 = crate::Reg<iprior19::IPRIOR19_SPEC>;
    ///Interrupt Priority configuration Register
    pub mod iprior19 {
        ///Register `IPRIOR19` reader
        pub type R = crate::R<IPRIOR19_SPEC>;
        ///Register `IPRIOR19` writer
        pub type W = crate::W<IPRIOR19_SPEC>;
        ///Field `IPRIOR19` reader - IPRIOR19
        pub type IPRIOR19_R = crate::FieldReader<u32>;
        ///Field `IPRIOR19` writer - IPRIOR19
        pub type IPRIOR19_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - IPRIOR19
            #[inline(always)]
            pub fn iprior19(&self) -> IPRIOR19_R {
                IPRIOR19_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - IPRIOR19
            #[inline(always)]
            #[must_use]
            pub fn iprior19(&mut self) -> IPRIOR19_W<IPRIOR19_SPEC> {
                IPRIOR19_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior19::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior19::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR19_SPEC;
        impl crate::RegisterSpec for IPRIOR19_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior19::R`](R) reader structure
        impl crate::Readable for IPRIOR19_SPEC {}
        ///`write(|w| ..)` method takes [`iprior19::W`](W) writer structure
        impl crate::Writable for IPRIOR19_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR19 to value 0
        impl crate::Resettable for IPRIOR19_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR20 (rw) register accessor: Interrupt Priority configuration Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior20::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior20::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior20`]
    ///module
    pub type IPRIOR20 = crate::Reg<iprior20::IPRIOR20_SPEC>;
    ///Interrupt Priority configuration Register
    pub mod iprior20 {
        ///Register `IPRIOR20` reader
        pub type R = crate::R<IPRIOR20_SPEC>;
        ///Register `IPRIOR20` writer
        pub type W = crate::W<IPRIOR20_SPEC>;
        ///Field `IPRIOR20` reader - IPRIOR20
        pub type IPRIOR20_R = crate::FieldReader<u32>;
        ///Field `IPRIOR20` writer - IPRIOR20
        pub type IPRIOR20_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - IPRIOR20
            #[inline(always)]
            pub fn iprior20(&self) -> IPRIOR20_R {
                IPRIOR20_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - IPRIOR20
            #[inline(always)]
            #[must_use]
            pub fn iprior20(&mut self) -> IPRIOR20_W<IPRIOR20_SPEC> {
                IPRIOR20_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior20::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior20::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR20_SPEC;
        impl crate::RegisterSpec for IPRIOR20_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior20::R`](R) reader structure
        impl crate::Readable for IPRIOR20_SPEC {}
        ///`write(|w| ..)` method takes [`iprior20::W`](W) writer structure
        impl crate::Writable for IPRIOR20_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR20 to value 0
        impl crate::Resettable for IPRIOR20_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR21 (rw) register accessor: Interrupt Priority configuration Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior21::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior21::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior21`]
    ///module
    pub type IPRIOR21 = crate::Reg<iprior21::IPRIOR21_SPEC>;
    ///Interrupt Priority configuration Register
    pub mod iprior21 {
        ///Register `IPRIOR21` reader
        pub type R = crate::R<IPRIOR21_SPEC>;
        ///Register `IPRIOR21` writer
        pub type W = crate::W<IPRIOR21_SPEC>;
        ///Field `IPRIOR21` reader - IPRIOR21
        pub type IPRIOR21_R = crate::FieldReader<u32>;
        ///Field `IPRIOR21` writer - IPRIOR21
        pub type IPRIOR21_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - IPRIOR21
            #[inline(always)]
            pub fn iprior21(&self) -> IPRIOR21_R {
                IPRIOR21_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - IPRIOR21
            #[inline(always)]
            #[must_use]
            pub fn iprior21(&mut self) -> IPRIOR21_W<IPRIOR21_SPEC> {
                IPRIOR21_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior21::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior21::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR21_SPEC;
        impl crate::RegisterSpec for IPRIOR21_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior21::R`](R) reader structure
        impl crate::Readable for IPRIOR21_SPEC {}
        ///`write(|w| ..)` method takes [`iprior21::W`](W) writer structure
        impl crate::Writable for IPRIOR21_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR21 to value 0
        impl crate::Resettable for IPRIOR21_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR22 (rw) register accessor: Interrupt Priority configuration Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior22::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior22::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior22`]
    ///module
    pub type IPRIOR22 = crate::Reg<iprior22::IPRIOR22_SPEC>;
    ///Interrupt Priority configuration Register
    pub mod iprior22 {
        ///Register `IPRIOR22` reader
        pub type R = crate::R<IPRIOR22_SPEC>;
        ///Register `IPRIOR22` writer
        pub type W = crate::W<IPRIOR22_SPEC>;
        ///Field `IPRIOR22` reader - IPRIOR22
        pub type IPRIOR22_R = crate::FieldReader<u32>;
        ///Field `IPRIOR22` writer - IPRIOR22
        pub type IPRIOR22_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - IPRIOR22
            #[inline(always)]
            pub fn iprior22(&self) -> IPRIOR22_R {
                IPRIOR22_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - IPRIOR22
            #[inline(always)]
            #[must_use]
            pub fn iprior22(&mut self) -> IPRIOR22_W<IPRIOR22_SPEC> {
                IPRIOR22_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior22::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior22::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR22_SPEC;
        impl crate::RegisterSpec for IPRIOR22_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior22::R`](R) reader structure
        impl crate::Readable for IPRIOR22_SPEC {}
        ///`write(|w| ..)` method takes [`iprior22::W`](W) writer structure
        impl crate::Writable for IPRIOR22_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR22 to value 0
        impl crate::Resettable for IPRIOR22_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR23 (rw) register accessor: Interrupt Priority configuration Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior23::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior23::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior23`]
    ///module
    pub type IPRIOR23 = crate::Reg<iprior23::IPRIOR23_SPEC>;
    ///Interrupt Priority configuration Register
    pub mod iprior23 {
        ///Register `IPRIOR23` reader
        pub type R = crate::R<IPRIOR23_SPEC>;
        ///Register `IPRIOR23` writer
        pub type W = crate::W<IPRIOR23_SPEC>;
        ///Field `IPRIOR23` reader - IPRIOR23
        pub type IPRIOR23_R = crate::FieldReader<u32>;
        ///Field `IPRIOR23` writer - IPRIOR23
        pub type IPRIOR23_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - IPRIOR23
            #[inline(always)]
            pub fn iprior23(&self) -> IPRIOR23_R {
                IPRIOR23_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - IPRIOR23
            #[inline(always)]
            #[must_use]
            pub fn iprior23(&mut self) -> IPRIOR23_W<IPRIOR23_SPEC> {
                IPRIOR23_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior23::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior23::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR23_SPEC;
        impl crate::RegisterSpec for IPRIOR23_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior23::R`](R) reader structure
        impl crate::Readable for IPRIOR23_SPEC {}
        ///`write(|w| ..)` method takes [`iprior23::W`](W) writer structure
        impl crate::Writable for IPRIOR23_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR23 to value 0
        impl crate::Resettable for IPRIOR23_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR24 (rw) register accessor: Interrupt Priority configuration Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior24::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior24::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior24`]
    ///module
    pub type IPRIOR24 = crate::Reg<iprior24::IPRIOR24_SPEC>;
    ///Interrupt Priority configuration Register
    pub mod iprior24 {
        ///Register `IPRIOR24` reader
        pub type R = crate::R<IPRIOR24_SPEC>;
        ///Register `IPRIOR24` writer
        pub type W = crate::W<IPRIOR24_SPEC>;
        ///Field `IPRIOR24` reader - IPRIOR24
        pub type IPRIOR24_R = crate::FieldReader<u32>;
        ///Field `IPRIOR24` writer - IPRIOR24
        pub type IPRIOR24_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - IPRIOR24
            #[inline(always)]
            pub fn iprior24(&self) -> IPRIOR24_R {
                IPRIOR24_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - IPRIOR24
            #[inline(always)]
            #[must_use]
            pub fn iprior24(&mut self) -> IPRIOR24_W<IPRIOR24_SPEC> {
                IPRIOR24_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior24::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior24::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR24_SPEC;
        impl crate::RegisterSpec for IPRIOR24_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior24::R`](R) reader structure
        impl crate::Readable for IPRIOR24_SPEC {}
        ///`write(|w| ..)` method takes [`iprior24::W`](W) writer structure
        impl crate::Writable for IPRIOR24_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR24 to value 0
        impl crate::Resettable for IPRIOR24_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR25 (rw) register accessor: Interrupt Priority configuration Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior25::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior25::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior25`]
    ///module
    pub type IPRIOR25 = crate::Reg<iprior25::IPRIOR25_SPEC>;
    ///Interrupt Priority configuration Register
    pub mod iprior25 {
        ///Register `IPRIOR25` reader
        pub type R = crate::R<IPRIOR25_SPEC>;
        ///Register `IPRIOR25` writer
        pub type W = crate::W<IPRIOR25_SPEC>;
        ///Field `IPRIOR25` reader - IPRIOR25
        pub type IPRIOR25_R = crate::FieldReader<u32>;
        ///Field `IPRIOR25` writer - IPRIOR25
        pub type IPRIOR25_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - IPRIOR25
            #[inline(always)]
            pub fn iprior25(&self) -> IPRIOR25_R {
                IPRIOR25_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - IPRIOR25
            #[inline(always)]
            #[must_use]
            pub fn iprior25(&mut self) -> IPRIOR25_W<IPRIOR25_SPEC> {
                IPRIOR25_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior25::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior25::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR25_SPEC;
        impl crate::RegisterSpec for IPRIOR25_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior25::R`](R) reader structure
        impl crate::Readable for IPRIOR25_SPEC {}
        ///`write(|w| ..)` method takes [`iprior25::W`](W) writer structure
        impl crate::Writable for IPRIOR25_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR25 to value 0
        impl crate::Resettable for IPRIOR25_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR26 (rw) register accessor: Interrupt Priority configuration Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior26::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior26::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior26`]
    ///module
    pub type IPRIOR26 = crate::Reg<iprior26::IPRIOR26_SPEC>;
    ///Interrupt Priority configuration Register
    pub mod iprior26 {
        ///Register `IPRIOR26` reader
        pub type R = crate::R<IPRIOR26_SPEC>;
        ///Register `IPRIOR26` writer
        pub type W = crate::W<IPRIOR26_SPEC>;
        ///Field `IPRIOR26` reader - IPRIOR26
        pub type IPRIOR26_R = crate::FieldReader<u32>;
        ///Field `IPRIOR26` writer - IPRIOR26
        pub type IPRIOR26_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - IPRIOR26
            #[inline(always)]
            pub fn iprior26(&self) -> IPRIOR26_R {
                IPRIOR26_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - IPRIOR26
            #[inline(always)]
            #[must_use]
            pub fn iprior26(&mut self) -> IPRIOR26_W<IPRIOR26_SPEC> {
                IPRIOR26_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior26::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior26::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR26_SPEC;
        impl crate::RegisterSpec for IPRIOR26_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior26::R`](R) reader structure
        impl crate::Readable for IPRIOR26_SPEC {}
        ///`write(|w| ..)` method takes [`iprior26::W`](W) writer structure
        impl crate::Writable for IPRIOR26_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR26 to value 0
        impl crate::Resettable for IPRIOR26_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR27 (rw) register accessor: Interrupt Priority configuration Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior27::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior27::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior27`]
    ///module
    pub type IPRIOR27 = crate::Reg<iprior27::IPRIOR27_SPEC>;
    ///Interrupt Priority configuration Register
    pub mod iprior27 {
        ///Register `IPRIOR27` reader
        pub type R = crate::R<IPRIOR27_SPEC>;
        ///Register `IPRIOR27` writer
        pub type W = crate::W<IPRIOR27_SPEC>;
        ///Field `IPRIOR27` reader - IPRIOR27
        pub type IPRIOR27_R = crate::FieldReader<u32>;
        ///Field `IPRIOR27` writer - IPRIOR27
        pub type IPRIOR27_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - IPRIOR27
            #[inline(always)]
            pub fn iprior27(&self) -> IPRIOR27_R {
                IPRIOR27_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - IPRIOR27
            #[inline(always)]
            #[must_use]
            pub fn iprior27(&mut self) -> IPRIOR27_W<IPRIOR27_SPEC> {
                IPRIOR27_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior27::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior27::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR27_SPEC;
        impl crate::RegisterSpec for IPRIOR27_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior27::R`](R) reader structure
        impl crate::Readable for IPRIOR27_SPEC {}
        ///`write(|w| ..)` method takes [`iprior27::W`](W) writer structure
        impl crate::Writable for IPRIOR27_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR27 to value 0
        impl crate::Resettable for IPRIOR27_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR28 (rw) register accessor: Interrupt Priority configuration Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior28::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior28::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior28`]
    ///module
    pub type IPRIOR28 = crate::Reg<iprior28::IPRIOR28_SPEC>;
    ///Interrupt Priority configuration Register
    pub mod iprior28 {
        ///Register `IPRIOR28` reader
        pub type R = crate::R<IPRIOR28_SPEC>;
        ///Register `IPRIOR28` writer
        pub type W = crate::W<IPRIOR28_SPEC>;
        ///Field `IPRIOR28` reader - IPRIOR28
        pub type IPRIOR28_R = crate::FieldReader<u32>;
        ///Field `IPRIOR28` writer - IPRIOR28
        pub type IPRIOR28_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - IPRIOR28
            #[inline(always)]
            pub fn iprior28(&self) -> IPRIOR28_R {
                IPRIOR28_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - IPRIOR28
            #[inline(always)]
            #[must_use]
            pub fn iprior28(&mut self) -> IPRIOR28_W<IPRIOR28_SPEC> {
                IPRIOR28_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior28::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior28::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR28_SPEC;
        impl crate::RegisterSpec for IPRIOR28_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior28::R`](R) reader structure
        impl crate::Readable for IPRIOR28_SPEC {}
        ///`write(|w| ..)` method takes [`iprior28::W`](W) writer structure
        impl crate::Writable for IPRIOR28_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR28 to value 0
        impl crate::Resettable for IPRIOR28_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR29 (rw) register accessor: Interrupt Priority configuration Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior29::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior29::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior29`]
    ///module
    pub type IPRIOR29 = crate::Reg<iprior29::IPRIOR29_SPEC>;
    ///Interrupt Priority configuration Register
    pub mod iprior29 {
        ///Register `IPRIOR29` reader
        pub type R = crate::R<IPRIOR29_SPEC>;
        ///Register `IPRIOR29` writer
        pub type W = crate::W<IPRIOR29_SPEC>;
        ///Field `IPRIOR29` reader - IPRIOR29
        pub type IPRIOR29_R = crate::FieldReader<u32>;
        ///Field `IPRIOR29` writer - IPRIOR29
        pub type IPRIOR29_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - IPRIOR29
            #[inline(always)]
            pub fn iprior29(&self) -> IPRIOR29_R {
                IPRIOR29_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - IPRIOR29
            #[inline(always)]
            #[must_use]
            pub fn iprior29(&mut self) -> IPRIOR29_W<IPRIOR29_SPEC> {
                IPRIOR29_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior29::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior29::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR29_SPEC;
        impl crate::RegisterSpec for IPRIOR29_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior29::R`](R) reader structure
        impl crate::Readable for IPRIOR29_SPEC {}
        ///`write(|w| ..)` method takes [`iprior29::W`](W) writer structure
        impl crate::Writable for IPRIOR29_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR29 to value 0
        impl crate::Resettable for IPRIOR29_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR30 (rw) register accessor: Interrupt Priority configuration Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior30::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior30::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior30`]
    ///module
    pub type IPRIOR30 = crate::Reg<iprior30::IPRIOR30_SPEC>;
    ///Interrupt Priority configuration Register
    pub mod iprior30 {
        ///Register `IPRIOR30` reader
        pub type R = crate::R<IPRIOR30_SPEC>;
        ///Register `IPRIOR30` writer
        pub type W = crate::W<IPRIOR30_SPEC>;
        ///Field `IPRIOR30` reader - IPRIOR30
        pub type IPRIOR30_R = crate::FieldReader<u32>;
        ///Field `IPRIOR30` writer - IPRIOR30
        pub type IPRIOR30_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - IPRIOR30
            #[inline(always)]
            pub fn iprior30(&self) -> IPRIOR30_R {
                IPRIOR30_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - IPRIOR30
            #[inline(always)]
            #[must_use]
            pub fn iprior30(&mut self) -> IPRIOR30_W<IPRIOR30_SPEC> {
                IPRIOR30_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior30::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior30::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR30_SPEC;
        impl crate::RegisterSpec for IPRIOR30_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior30::R`](R) reader structure
        impl crate::Readable for IPRIOR30_SPEC {}
        ///`write(|w| ..)` method takes [`iprior30::W`](W) writer structure
        impl crate::Writable for IPRIOR30_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR30 to value 0
        impl crate::Resettable for IPRIOR30_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR31 (rw) register accessor: Interrupt Priority configuration Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior31::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior31::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior31`]
    ///module
    pub type IPRIOR31 = crate::Reg<iprior31::IPRIOR31_SPEC>;
    ///Interrupt Priority configuration Register
    pub mod iprior31 {
        ///Register `IPRIOR31` reader
        pub type R = crate::R<IPRIOR31_SPEC>;
        ///Register `IPRIOR31` writer
        pub type W = crate::W<IPRIOR31_SPEC>;
        ///Field `IPRIOR31` reader - IPRIOR31
        pub type IPRIOR31_R = crate::FieldReader<u32>;
        ///Field `IPRIOR31` writer - IPRIOR31
        pub type IPRIOR31_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - IPRIOR31
            #[inline(always)]
            pub fn iprior31(&self) -> IPRIOR31_R {
                IPRIOR31_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - IPRIOR31
            #[inline(always)]
            #[must_use]
            pub fn iprior31(&mut self) -> IPRIOR31_W<IPRIOR31_SPEC> {
                IPRIOR31_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior31::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior31::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR31_SPEC;
        impl crate::RegisterSpec for IPRIOR31_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior31::R`](R) reader structure
        impl crate::Readable for IPRIOR31_SPEC {}
        ///`write(|w| ..)` method takes [`iprior31::W`](W) writer structure
        impl crate::Writable for IPRIOR31_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR31 to value 0
        impl crate::Resettable for IPRIOR31_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR32 (rw) register accessor: Interrupt Priority configuration Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior32::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior32::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior32`]
    ///module
    pub type IPRIOR32 = crate::Reg<iprior32::IPRIOR32_SPEC>;
    ///Interrupt Priority configuration Register
    pub mod iprior32 {
        ///Register `IPRIOR32` reader
        pub type R = crate::R<IPRIOR32_SPEC>;
        ///Register `IPRIOR32` writer
        pub type W = crate::W<IPRIOR32_SPEC>;
        ///Field `IPRIOR32` reader - IPRIOR32
        pub type IPRIOR32_R = crate::FieldReader<u32>;
        ///Field `IPRIOR32` writer - IPRIOR32
        pub type IPRIOR32_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - IPRIOR32
            #[inline(always)]
            pub fn iprior32(&self) -> IPRIOR32_R {
                IPRIOR32_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - IPRIOR32
            #[inline(always)]
            #[must_use]
            pub fn iprior32(&mut self) -> IPRIOR32_W<IPRIOR32_SPEC> {
                IPRIOR32_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior32::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior32::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR32_SPEC;
        impl crate::RegisterSpec for IPRIOR32_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior32::R`](R) reader structure
        impl crate::Readable for IPRIOR32_SPEC {}
        ///`write(|w| ..)` method takes [`iprior32::W`](W) writer structure
        impl crate::Writable for IPRIOR32_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR32 to value 0
        impl crate::Resettable for IPRIOR32_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR33 (rw) register accessor: Interrupt Priority configuration Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior33::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior33::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior33`]
    ///module
    pub type IPRIOR33 = crate::Reg<iprior33::IPRIOR33_SPEC>;
    ///Interrupt Priority configuration Register
    pub mod iprior33 {
        ///Register `IPRIOR33` reader
        pub type R = crate::R<IPRIOR33_SPEC>;
        ///Register `IPRIOR33` writer
        pub type W = crate::W<IPRIOR33_SPEC>;
        ///Field `IPRIOR33` reader - IPRIOR33
        pub type IPRIOR33_R = crate::FieldReader<u32>;
        ///Field `IPRIOR33` writer - IPRIOR33
        pub type IPRIOR33_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - IPRIOR33
            #[inline(always)]
            pub fn iprior33(&self) -> IPRIOR33_R {
                IPRIOR33_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - IPRIOR33
            #[inline(always)]
            #[must_use]
            pub fn iprior33(&mut self) -> IPRIOR33_W<IPRIOR33_SPEC> {
                IPRIOR33_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior33::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior33::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR33_SPEC;
        impl crate::RegisterSpec for IPRIOR33_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior33::R`](R) reader structure
        impl crate::Readable for IPRIOR33_SPEC {}
        ///`write(|w| ..)` method takes [`iprior33::W`](W) writer structure
        impl crate::Writable for IPRIOR33_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR33 to value 0
        impl crate::Resettable for IPRIOR33_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR34 (rw) register accessor: Interrupt Priority configuration Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior34::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior34::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior34`]
    ///module
    pub type IPRIOR34 = crate::Reg<iprior34::IPRIOR34_SPEC>;
    ///Interrupt Priority configuration Register
    pub mod iprior34 {
        ///Register `IPRIOR34` reader
        pub type R = crate::R<IPRIOR34_SPEC>;
        ///Register `IPRIOR34` writer
        pub type W = crate::W<IPRIOR34_SPEC>;
        ///Field `IPRIOR34` reader - IPRIOR34
        pub type IPRIOR34_R = crate::FieldReader<u32>;
        ///Field `IPRIOR34` writer - IPRIOR34
        pub type IPRIOR34_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - IPRIOR34
            #[inline(always)]
            pub fn iprior34(&self) -> IPRIOR34_R {
                IPRIOR34_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - IPRIOR34
            #[inline(always)]
            #[must_use]
            pub fn iprior34(&mut self) -> IPRIOR34_W<IPRIOR34_SPEC> {
                IPRIOR34_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior34::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior34::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR34_SPEC;
        impl crate::RegisterSpec for IPRIOR34_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior34::R`](R) reader structure
        impl crate::Readable for IPRIOR34_SPEC {}
        ///`write(|w| ..)` method takes [`iprior34::W`](W) writer structure
        impl crate::Writable for IPRIOR34_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR34 to value 0
        impl crate::Resettable for IPRIOR34_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR35 (rw) register accessor: Interrupt Priority configuration Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior35::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior35::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior35`]
    ///module
    pub type IPRIOR35 = crate::Reg<iprior35::IPRIOR35_SPEC>;
    ///Interrupt Priority configuration Register
    pub mod iprior35 {
        ///Register `IPRIOR35` reader
        pub type R = crate::R<IPRIOR35_SPEC>;
        ///Register `IPRIOR35` writer
        pub type W = crate::W<IPRIOR35_SPEC>;
        ///Field `IPRIOR35` reader - IPRIOR35
        pub type IPRIOR35_R = crate::FieldReader<u32>;
        ///Field `IPRIOR35` writer - IPRIOR35
        pub type IPRIOR35_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - IPRIOR35
            #[inline(always)]
            pub fn iprior35(&self) -> IPRIOR35_R {
                IPRIOR35_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - IPRIOR35
            #[inline(always)]
            #[must_use]
            pub fn iprior35(&mut self) -> IPRIOR35_W<IPRIOR35_SPEC> {
                IPRIOR35_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior35::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior35::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR35_SPEC;
        impl crate::RegisterSpec for IPRIOR35_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior35::R`](R) reader structure
        impl crate::Readable for IPRIOR35_SPEC {}
        ///`write(|w| ..)` method takes [`iprior35::W`](W) writer structure
        impl crate::Writable for IPRIOR35_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR35 to value 0
        impl crate::Resettable for IPRIOR35_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR36 (rw) register accessor: Interrupt Priority configuration Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior36::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior36::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior36`]
    ///module
    pub type IPRIOR36 = crate::Reg<iprior36::IPRIOR36_SPEC>;
    ///Interrupt Priority configuration Register
    pub mod iprior36 {
        ///Register `IPRIOR36` reader
        pub type R = crate::R<IPRIOR36_SPEC>;
        ///Register `IPRIOR36` writer
        pub type W = crate::W<IPRIOR36_SPEC>;
        ///Field `IPRIOR36` reader - IPRIOR36
        pub type IPRIOR36_R = crate::FieldReader<u32>;
        ///Field `IPRIOR36` writer - IPRIOR36
        pub type IPRIOR36_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - IPRIOR36
            #[inline(always)]
            pub fn iprior36(&self) -> IPRIOR36_R {
                IPRIOR36_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - IPRIOR36
            #[inline(always)]
            #[must_use]
            pub fn iprior36(&mut self) -> IPRIOR36_W<IPRIOR36_SPEC> {
                IPRIOR36_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior36::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior36::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR36_SPEC;
        impl crate::RegisterSpec for IPRIOR36_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior36::R`](R) reader structure
        impl crate::Readable for IPRIOR36_SPEC {}
        ///`write(|w| ..)` method takes [`iprior36::W`](W) writer structure
        impl crate::Writable for IPRIOR36_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR36 to value 0
        impl crate::Resettable for IPRIOR36_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR37 (rw) register accessor: Interrupt Priority configuration Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior37::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior37::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior37`]
    ///module
    pub type IPRIOR37 = crate::Reg<iprior37::IPRIOR37_SPEC>;
    ///Interrupt Priority configuration Register
    pub mod iprior37 {
        ///Register `IPRIOR37` reader
        pub type R = crate::R<IPRIOR37_SPEC>;
        ///Register `IPRIOR37` writer
        pub type W = crate::W<IPRIOR37_SPEC>;
        ///Field `IPRIOR37` reader - IPRIOR37
        pub type IPRIOR37_R = crate::FieldReader<u32>;
        ///Field `IPRIOR37` writer - IPRIOR37
        pub type IPRIOR37_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - IPRIOR37
            #[inline(always)]
            pub fn iprior37(&self) -> IPRIOR37_R {
                IPRIOR37_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - IPRIOR37
            #[inline(always)]
            #[must_use]
            pub fn iprior37(&mut self) -> IPRIOR37_W<IPRIOR37_SPEC> {
                IPRIOR37_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior37::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior37::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR37_SPEC;
        impl crate::RegisterSpec for IPRIOR37_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior37::R`](R) reader structure
        impl crate::Readable for IPRIOR37_SPEC {}
        ///`write(|w| ..)` method takes [`iprior37::W`](W) writer structure
        impl crate::Writable for IPRIOR37_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR37 to value 0
        impl crate::Resettable for IPRIOR37_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR38 (rw) register accessor: Interrupt Priority configuration Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior38::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior38::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior38`]
    ///module
    pub type IPRIOR38 = crate::Reg<iprior38::IPRIOR38_SPEC>;
    ///Interrupt Priority configuration Register
    pub mod iprior38 {
        ///Register `IPRIOR38` reader
        pub type R = crate::R<IPRIOR38_SPEC>;
        ///Register `IPRIOR38` writer
        pub type W = crate::W<IPRIOR38_SPEC>;
        ///Field `IPRIOR38` reader - IPRIOR38
        pub type IPRIOR38_R = crate::FieldReader<u32>;
        ///Field `IPRIOR38` writer - IPRIOR38
        pub type IPRIOR38_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - IPRIOR38
            #[inline(always)]
            pub fn iprior38(&self) -> IPRIOR38_R {
                IPRIOR38_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - IPRIOR38
            #[inline(always)]
            #[must_use]
            pub fn iprior38(&mut self) -> IPRIOR38_W<IPRIOR38_SPEC> {
                IPRIOR38_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior38::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior38::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR38_SPEC;
        impl crate::RegisterSpec for IPRIOR38_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior38::R`](R) reader structure
        impl crate::Readable for IPRIOR38_SPEC {}
        ///`write(|w| ..)` method takes [`iprior38::W`](W) writer structure
        impl crate::Writable for IPRIOR38_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR38 to value 0
        impl crate::Resettable for IPRIOR38_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR39 (rw) register accessor: Interrupt Priority configuration Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior39::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior39::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior39`]
    ///module
    pub type IPRIOR39 = crate::Reg<iprior39::IPRIOR39_SPEC>;
    ///Interrupt Priority configuration Register
    pub mod iprior39 {
        ///Register `IPRIOR39` reader
        pub type R = crate::R<IPRIOR39_SPEC>;
        ///Register `IPRIOR39` writer
        pub type W = crate::W<IPRIOR39_SPEC>;
        ///Field `IPRIOR39` reader - IPRIOR39
        pub type IPRIOR39_R = crate::FieldReader<u32>;
        ///Field `IPRIOR39` writer - IPRIOR39
        pub type IPRIOR39_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - IPRIOR39
            #[inline(always)]
            pub fn iprior39(&self) -> IPRIOR39_R {
                IPRIOR39_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - IPRIOR39
            #[inline(always)]
            #[must_use]
            pub fn iprior39(&mut self) -> IPRIOR39_W<IPRIOR39_SPEC> {
                IPRIOR39_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior39::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior39::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR39_SPEC;
        impl crate::RegisterSpec for IPRIOR39_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior39::R`](R) reader structure
        impl crate::Readable for IPRIOR39_SPEC {}
        ///`write(|w| ..)` method takes [`iprior39::W`](W) writer structure
        impl crate::Writable for IPRIOR39_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR39 to value 0
        impl crate::Resettable for IPRIOR39_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR40 (rw) register accessor: Interrupt Priority configuration Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior40::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior40::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior40`]
    ///module
    pub type IPRIOR40 = crate::Reg<iprior40::IPRIOR40_SPEC>;
    ///Interrupt Priority configuration Register
    pub mod iprior40 {
        ///Register `IPRIOR40` reader
        pub type R = crate::R<IPRIOR40_SPEC>;
        ///Register `IPRIOR40` writer
        pub type W = crate::W<IPRIOR40_SPEC>;
        ///Field `IPRIOR40` reader - IPRIOR40
        pub type IPRIOR40_R = crate::FieldReader<u32>;
        ///Field `IPRIOR40` writer - IPRIOR40
        pub type IPRIOR40_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - IPRIOR40
            #[inline(always)]
            pub fn iprior40(&self) -> IPRIOR40_R {
                IPRIOR40_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - IPRIOR40
            #[inline(always)]
            #[must_use]
            pub fn iprior40(&mut self) -> IPRIOR40_W<IPRIOR40_SPEC> {
                IPRIOR40_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior40::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior40::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR40_SPEC;
        impl crate::RegisterSpec for IPRIOR40_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior40::R`](R) reader structure
        impl crate::Readable for IPRIOR40_SPEC {}
        ///`write(|w| ..)` method takes [`iprior40::W`](W) writer structure
        impl crate::Writable for IPRIOR40_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR40 to value 0
        impl crate::Resettable for IPRIOR40_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR41 (rw) register accessor: Interrupt Priority configuration Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior41::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior41::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior41`]
    ///module
    pub type IPRIOR41 = crate::Reg<iprior41::IPRIOR41_SPEC>;
    ///Interrupt Priority configuration Register
    pub mod iprior41 {
        ///Register `IPRIOR41` reader
        pub type R = crate::R<IPRIOR41_SPEC>;
        ///Register `IPRIOR41` writer
        pub type W = crate::W<IPRIOR41_SPEC>;
        ///Field `IPRIOR41` reader - IPRIOR41
        pub type IPRIOR41_R = crate::FieldReader<u32>;
        ///Field `IPRIOR41` writer - IPRIOR41
        pub type IPRIOR41_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - IPRIOR41
            #[inline(always)]
            pub fn iprior41(&self) -> IPRIOR41_R {
                IPRIOR41_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - IPRIOR41
            #[inline(always)]
            #[must_use]
            pub fn iprior41(&mut self) -> IPRIOR41_W<IPRIOR41_SPEC> {
                IPRIOR41_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior41::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior41::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR41_SPEC;
        impl crate::RegisterSpec for IPRIOR41_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior41::R`](R) reader structure
        impl crate::Readable for IPRIOR41_SPEC {}
        ///`write(|w| ..)` method takes [`iprior41::W`](W) writer structure
        impl crate::Writable for IPRIOR41_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR41 to value 0
        impl crate::Resettable for IPRIOR41_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR42 (rw) register accessor: Interrupt Priority configuration Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior42::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior42::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior42`]
    ///module
    pub type IPRIOR42 = crate::Reg<iprior42::IPRIOR42_SPEC>;
    ///Interrupt Priority configuration Register
    pub mod iprior42 {
        ///Register `IPRIOR42` reader
        pub type R = crate::R<IPRIOR42_SPEC>;
        ///Register `IPRIOR42` writer
        pub type W = crate::W<IPRIOR42_SPEC>;
        ///Field `IPRIOR42` reader - IPRIOR42
        pub type IPRIOR42_R = crate::FieldReader<u32>;
        ///Field `IPRIOR42` writer - IPRIOR42
        pub type IPRIOR42_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - IPRIOR42
            #[inline(always)]
            pub fn iprior42(&self) -> IPRIOR42_R {
                IPRIOR42_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - IPRIOR42
            #[inline(always)]
            #[must_use]
            pub fn iprior42(&mut self) -> IPRIOR42_W<IPRIOR42_SPEC> {
                IPRIOR42_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior42::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior42::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR42_SPEC;
        impl crate::RegisterSpec for IPRIOR42_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior42::R`](R) reader structure
        impl crate::Readable for IPRIOR42_SPEC {}
        ///`write(|w| ..)` method takes [`iprior42::W`](W) writer structure
        impl crate::Writable for IPRIOR42_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR42 to value 0
        impl crate::Resettable for IPRIOR42_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR43 (rw) register accessor: Interrupt Priority configuration Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior43::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior43::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior43`]
    ///module
    pub type IPRIOR43 = crate::Reg<iprior43::IPRIOR43_SPEC>;
    ///Interrupt Priority configuration Register
    pub mod iprior43 {
        ///Register `IPRIOR43` reader
        pub type R = crate::R<IPRIOR43_SPEC>;
        ///Register `IPRIOR43` writer
        pub type W = crate::W<IPRIOR43_SPEC>;
        ///Field `IPRIOR43` reader - IPRIOR43
        pub type IPRIOR43_R = crate::FieldReader<u32>;
        ///Field `IPRIOR43` writer - IPRIOR43
        pub type IPRIOR43_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - IPRIOR43
            #[inline(always)]
            pub fn iprior43(&self) -> IPRIOR43_R {
                IPRIOR43_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - IPRIOR43
            #[inline(always)]
            #[must_use]
            pub fn iprior43(&mut self) -> IPRIOR43_W<IPRIOR43_SPEC> {
                IPRIOR43_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior43::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior43::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR43_SPEC;
        impl crate::RegisterSpec for IPRIOR43_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior43::R`](R) reader structure
        impl crate::Readable for IPRIOR43_SPEC {}
        ///`write(|w| ..)` method takes [`iprior43::W`](W) writer structure
        impl crate::Writable for IPRIOR43_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR43 to value 0
        impl crate::Resettable for IPRIOR43_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR44 (rw) register accessor: Interrupt Priority configuration Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior44::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior44::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior44`]
    ///module
    pub type IPRIOR44 = crate::Reg<iprior44::IPRIOR44_SPEC>;
    ///Interrupt Priority configuration Register
    pub mod iprior44 {
        ///Register `IPRIOR44` reader
        pub type R = crate::R<IPRIOR44_SPEC>;
        ///Register `IPRIOR44` writer
        pub type W = crate::W<IPRIOR44_SPEC>;
        ///Field `IPRIOR44` reader - IPRIOR44
        pub type IPRIOR44_R = crate::FieldReader<u32>;
        ///Field `IPRIOR44` writer - IPRIOR44
        pub type IPRIOR44_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - IPRIOR44
            #[inline(always)]
            pub fn iprior44(&self) -> IPRIOR44_R {
                IPRIOR44_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - IPRIOR44
            #[inline(always)]
            #[must_use]
            pub fn iprior44(&mut self) -> IPRIOR44_W<IPRIOR44_SPEC> {
                IPRIOR44_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior44::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior44::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR44_SPEC;
        impl crate::RegisterSpec for IPRIOR44_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior44::R`](R) reader structure
        impl crate::Readable for IPRIOR44_SPEC {}
        ///`write(|w| ..)` method takes [`iprior44::W`](W) writer structure
        impl crate::Writable for IPRIOR44_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR44 to value 0
        impl crate::Resettable for IPRIOR44_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR45 (rw) register accessor: Interrupt Priority configuration Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior45::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior45::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior45`]
    ///module
    pub type IPRIOR45 = crate::Reg<iprior45::IPRIOR45_SPEC>;
    ///Interrupt Priority configuration Register
    pub mod iprior45 {
        ///Register `IPRIOR45` reader
        pub type R = crate::R<IPRIOR45_SPEC>;
        ///Register `IPRIOR45` writer
        pub type W = crate::W<IPRIOR45_SPEC>;
        ///Field `IPRIOR45` reader - IPRIOR45
        pub type IPRIOR45_R = crate::FieldReader<u32>;
        ///Field `IPRIOR45` writer - IPRIOR45
        pub type IPRIOR45_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - IPRIOR45
            #[inline(always)]
            pub fn iprior45(&self) -> IPRIOR45_R {
                IPRIOR45_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - IPRIOR45
            #[inline(always)]
            #[must_use]
            pub fn iprior45(&mut self) -> IPRIOR45_W<IPRIOR45_SPEC> {
                IPRIOR45_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior45::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior45::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR45_SPEC;
        impl crate::RegisterSpec for IPRIOR45_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior45::R`](R) reader structure
        impl crate::Readable for IPRIOR45_SPEC {}
        ///`write(|w| ..)` method takes [`iprior45::W`](W) writer structure
        impl crate::Writable for IPRIOR45_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR45 to value 0
        impl crate::Resettable for IPRIOR45_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR46 (rw) register accessor: Interrupt Priority configuration Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior46::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior46::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior46`]
    ///module
    pub type IPRIOR46 = crate::Reg<iprior46::IPRIOR46_SPEC>;
    ///Interrupt Priority configuration Register
    pub mod iprior46 {
        ///Register `IPRIOR46` reader
        pub type R = crate::R<IPRIOR46_SPEC>;
        ///Register `IPRIOR46` writer
        pub type W = crate::W<IPRIOR46_SPEC>;
        ///Field `IPRIOR46` reader - IPRIOR46
        pub type IPRIOR46_R = crate::FieldReader<u32>;
        ///Field `IPRIOR46` writer - IPRIOR46
        pub type IPRIOR46_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - IPRIOR46
            #[inline(always)]
            pub fn iprior46(&self) -> IPRIOR46_R {
                IPRIOR46_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - IPRIOR46
            #[inline(always)]
            #[must_use]
            pub fn iprior46(&mut self) -> IPRIOR46_W<IPRIOR46_SPEC> {
                IPRIOR46_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior46::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior46::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR46_SPEC;
        impl crate::RegisterSpec for IPRIOR46_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior46::R`](R) reader structure
        impl crate::Readable for IPRIOR46_SPEC {}
        ///`write(|w| ..)` method takes [`iprior46::W`](W) writer structure
        impl crate::Writable for IPRIOR46_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR46 to value 0
        impl crate::Resettable for IPRIOR46_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR47 (rw) register accessor: Interrupt Priority configuration Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior47::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior47::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior47`]
    ///module
    pub type IPRIOR47 = crate::Reg<iprior47::IPRIOR47_SPEC>;
    ///Interrupt Priority configuration Register
    pub mod iprior47 {
        ///Register `IPRIOR47` reader
        pub type R = crate::R<IPRIOR47_SPEC>;
        ///Register `IPRIOR47` writer
        pub type W = crate::W<IPRIOR47_SPEC>;
        ///Field `IPRIOR47` reader - IPRIOR47
        pub type IPRIOR47_R = crate::FieldReader<u32>;
        ///Field `IPRIOR47` writer - IPRIOR47
        pub type IPRIOR47_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - IPRIOR47
            #[inline(always)]
            pub fn iprior47(&self) -> IPRIOR47_R {
                IPRIOR47_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - IPRIOR47
            #[inline(always)]
            #[must_use]
            pub fn iprior47(&mut self) -> IPRIOR47_W<IPRIOR47_SPEC> {
                IPRIOR47_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior47::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior47::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR47_SPEC;
        impl crate::RegisterSpec for IPRIOR47_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior47::R`](R) reader structure
        impl crate::Readable for IPRIOR47_SPEC {}
        ///`write(|w| ..)` method takes [`iprior47::W`](W) writer structure
        impl crate::Writable for IPRIOR47_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR47 to value 0
        impl crate::Resettable for IPRIOR47_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR48 (rw) register accessor: Interrupt Priority configuration Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior48::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior48::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior48`]
    ///module
    pub type IPRIOR48 = crate::Reg<iprior48::IPRIOR48_SPEC>;
    ///Interrupt Priority configuration Register
    pub mod iprior48 {
        ///Register `IPRIOR48` reader
        pub type R = crate::R<IPRIOR48_SPEC>;
        ///Register `IPRIOR48` writer
        pub type W = crate::W<IPRIOR48_SPEC>;
        ///Field `IPRIOR48` reader - IPRIOR48
        pub type IPRIOR48_R = crate::FieldReader<u32>;
        ///Field `IPRIOR48` writer - IPRIOR48
        pub type IPRIOR48_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - IPRIOR48
            #[inline(always)]
            pub fn iprior48(&self) -> IPRIOR48_R {
                IPRIOR48_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - IPRIOR48
            #[inline(always)]
            #[must_use]
            pub fn iprior48(&mut self) -> IPRIOR48_W<IPRIOR48_SPEC> {
                IPRIOR48_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior48::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior48::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR48_SPEC;
        impl crate::RegisterSpec for IPRIOR48_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior48::R`](R) reader structure
        impl crate::Readable for IPRIOR48_SPEC {}
        ///`write(|w| ..)` method takes [`iprior48::W`](W) writer structure
        impl crate::Writable for IPRIOR48_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR48 to value 0
        impl crate::Resettable for IPRIOR48_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR49 (rw) register accessor: Interrupt Priority configuration Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior49::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior49::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior49`]
    ///module
    pub type IPRIOR49 = crate::Reg<iprior49::IPRIOR49_SPEC>;
    ///Interrupt Priority configuration Register
    pub mod iprior49 {
        ///Register `IPRIOR49` reader
        pub type R = crate::R<IPRIOR49_SPEC>;
        ///Register `IPRIOR49` writer
        pub type W = crate::W<IPRIOR49_SPEC>;
        ///Field `IPRIOR49` reader - IPRIOR49
        pub type IPRIOR49_R = crate::FieldReader<u32>;
        ///Field `IPRIOR49` writer - IPRIOR49
        pub type IPRIOR49_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - IPRIOR49
            #[inline(always)]
            pub fn iprior49(&self) -> IPRIOR49_R {
                IPRIOR49_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - IPRIOR49
            #[inline(always)]
            #[must_use]
            pub fn iprior49(&mut self) -> IPRIOR49_W<IPRIOR49_SPEC> {
                IPRIOR49_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior49::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior49::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR49_SPEC;
        impl crate::RegisterSpec for IPRIOR49_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior49::R`](R) reader structure
        impl crate::Readable for IPRIOR49_SPEC {}
        ///`write(|w| ..)` method takes [`iprior49::W`](W) writer structure
        impl crate::Writable for IPRIOR49_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR49 to value 0
        impl crate::Resettable for IPRIOR49_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR50 (rw) register accessor: Interrupt Priority configuration Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior50::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior50::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior50`]
    ///module
    pub type IPRIOR50 = crate::Reg<iprior50::IPRIOR50_SPEC>;
    ///Interrupt Priority configuration Register
    pub mod iprior50 {
        ///Register `IPRIOR50` reader
        pub type R = crate::R<IPRIOR50_SPEC>;
        ///Register `IPRIOR50` writer
        pub type W = crate::W<IPRIOR50_SPEC>;
        ///Field `IPRIOR50` reader - IPRIOR50
        pub type IPRIOR50_R = crate::FieldReader<u32>;
        ///Field `IPRIOR50` writer - IPRIOR50
        pub type IPRIOR50_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - IPRIOR50
            #[inline(always)]
            pub fn iprior50(&self) -> IPRIOR50_R {
                IPRIOR50_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - IPRIOR50
            #[inline(always)]
            #[must_use]
            pub fn iprior50(&mut self) -> IPRIOR50_W<IPRIOR50_SPEC> {
                IPRIOR50_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior50::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior50::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR50_SPEC;
        impl crate::RegisterSpec for IPRIOR50_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior50::R`](R) reader structure
        impl crate::Readable for IPRIOR50_SPEC {}
        ///`write(|w| ..)` method takes [`iprior50::W`](W) writer structure
        impl crate::Writable for IPRIOR50_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR50 to value 0
        impl crate::Resettable for IPRIOR50_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR51 (rw) register accessor: Interrupt Priority configuration Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior51::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior51::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior51`]
    ///module
    pub type IPRIOR51 = crate::Reg<iprior51::IPRIOR51_SPEC>;
    ///Interrupt Priority configuration Register
    pub mod iprior51 {
        ///Register `IPRIOR51` reader
        pub type R = crate::R<IPRIOR51_SPEC>;
        ///Register `IPRIOR51` writer
        pub type W = crate::W<IPRIOR51_SPEC>;
        ///Field `IPRIOR51` reader - IPRIOR51
        pub type IPRIOR51_R = crate::FieldReader<u32>;
        ///Field `IPRIOR51` writer - IPRIOR51
        pub type IPRIOR51_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - IPRIOR51
            #[inline(always)]
            pub fn iprior51(&self) -> IPRIOR51_R {
                IPRIOR51_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - IPRIOR51
            #[inline(always)]
            #[must_use]
            pub fn iprior51(&mut self) -> IPRIOR51_W<IPRIOR51_SPEC> {
                IPRIOR51_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior51::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior51::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR51_SPEC;
        impl crate::RegisterSpec for IPRIOR51_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior51::R`](R) reader structure
        impl crate::Readable for IPRIOR51_SPEC {}
        ///`write(|w| ..)` method takes [`iprior51::W`](W) writer structure
        impl crate::Writable for IPRIOR51_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR51 to value 0
        impl crate::Resettable for IPRIOR51_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR52 (rw) register accessor: Interrupt Priority configuration Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior52::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior52::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior52`]
    ///module
    pub type IPRIOR52 = crate::Reg<iprior52::IPRIOR52_SPEC>;
    ///Interrupt Priority configuration Register
    pub mod iprior52 {
        ///Register `IPRIOR52` reader
        pub type R = crate::R<IPRIOR52_SPEC>;
        ///Register `IPRIOR52` writer
        pub type W = crate::W<IPRIOR52_SPEC>;
        ///Field `IPRIOR52` reader - IPRIOR52
        pub type IPRIOR52_R = crate::FieldReader<u32>;
        ///Field `IPRIOR52` writer - IPRIOR52
        pub type IPRIOR52_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - IPRIOR52
            #[inline(always)]
            pub fn iprior52(&self) -> IPRIOR52_R {
                IPRIOR52_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - IPRIOR52
            #[inline(always)]
            #[must_use]
            pub fn iprior52(&mut self) -> IPRIOR52_W<IPRIOR52_SPEC> {
                IPRIOR52_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior52::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior52::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR52_SPEC;
        impl crate::RegisterSpec for IPRIOR52_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior52::R`](R) reader structure
        impl crate::Readable for IPRIOR52_SPEC {}
        ///`write(|w| ..)` method takes [`iprior52::W`](W) writer structure
        impl crate::Writable for IPRIOR52_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR52 to value 0
        impl crate::Resettable for IPRIOR52_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR53 (rw) register accessor: Interrupt Priority configuration Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior53::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior53::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior53`]
    ///module
    pub type IPRIOR53 = crate::Reg<iprior53::IPRIOR53_SPEC>;
    ///Interrupt Priority configuration Register
    pub mod iprior53 {
        ///Register `IPRIOR53` reader
        pub type R = crate::R<IPRIOR53_SPEC>;
        ///Register `IPRIOR53` writer
        pub type W = crate::W<IPRIOR53_SPEC>;
        ///Field `IPRIOR53` reader - IPRIOR53
        pub type IPRIOR53_R = crate::FieldReader<u32>;
        ///Field `IPRIOR53` writer - IPRIOR53
        pub type IPRIOR53_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - IPRIOR53
            #[inline(always)]
            pub fn iprior53(&self) -> IPRIOR53_R {
                IPRIOR53_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - IPRIOR53
            #[inline(always)]
            #[must_use]
            pub fn iprior53(&mut self) -> IPRIOR53_W<IPRIOR53_SPEC> {
                IPRIOR53_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior53::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior53::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR53_SPEC;
        impl crate::RegisterSpec for IPRIOR53_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior53::R`](R) reader structure
        impl crate::Readable for IPRIOR53_SPEC {}
        ///`write(|w| ..)` method takes [`iprior53::W`](W) writer structure
        impl crate::Writable for IPRIOR53_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR53 to value 0
        impl crate::Resettable for IPRIOR53_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR54 (rw) register accessor: Interrupt Priority configuration Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior54::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior54::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior54`]
    ///module
    pub type IPRIOR54 = crate::Reg<iprior54::IPRIOR54_SPEC>;
    ///Interrupt Priority configuration Register
    pub mod iprior54 {
        ///Register `IPRIOR54` reader
        pub type R = crate::R<IPRIOR54_SPEC>;
        ///Register `IPRIOR54` writer
        pub type W = crate::W<IPRIOR54_SPEC>;
        ///Field `IPRIOR54` reader - IPRIOR54
        pub type IPRIOR54_R = crate::FieldReader<u32>;
        ///Field `IPRIOR54` writer - IPRIOR54
        pub type IPRIOR54_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - IPRIOR54
            #[inline(always)]
            pub fn iprior54(&self) -> IPRIOR54_R {
                IPRIOR54_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - IPRIOR54
            #[inline(always)]
            #[must_use]
            pub fn iprior54(&mut self) -> IPRIOR54_W<IPRIOR54_SPEC> {
                IPRIOR54_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior54::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior54::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR54_SPEC;
        impl crate::RegisterSpec for IPRIOR54_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior54::R`](R) reader structure
        impl crate::Readable for IPRIOR54_SPEC {}
        ///`write(|w| ..)` method takes [`iprior54::W`](W) writer structure
        impl crate::Writable for IPRIOR54_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR54 to value 0
        impl crate::Resettable for IPRIOR54_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR55 (rw) register accessor: Interrupt Priority configuration Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior55::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior55::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior55`]
    ///module
    pub type IPRIOR55 = crate::Reg<iprior55::IPRIOR55_SPEC>;
    ///Interrupt Priority configuration Register
    pub mod iprior55 {
        ///Register `IPRIOR55` reader
        pub type R = crate::R<IPRIOR55_SPEC>;
        ///Register `IPRIOR55` writer
        pub type W = crate::W<IPRIOR55_SPEC>;
        ///Field `IPRIOR55` reader - IPRIOR55
        pub type IPRIOR55_R = crate::FieldReader<u32>;
        ///Field `IPRIOR55` writer - IPRIOR55
        pub type IPRIOR55_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - IPRIOR55
            #[inline(always)]
            pub fn iprior55(&self) -> IPRIOR55_R {
                IPRIOR55_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - IPRIOR55
            #[inline(always)]
            #[must_use]
            pub fn iprior55(&mut self) -> IPRIOR55_W<IPRIOR55_SPEC> {
                IPRIOR55_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior55::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior55::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR55_SPEC;
        impl crate::RegisterSpec for IPRIOR55_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior55::R`](R) reader structure
        impl crate::Readable for IPRIOR55_SPEC {}
        ///`write(|w| ..)` method takes [`iprior55::W`](W) writer structure
        impl crate::Writable for IPRIOR55_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR55 to value 0
        impl crate::Resettable for IPRIOR55_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR56 (rw) register accessor: Interrupt Priority configuration Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior56::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior56::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior56`]
    ///module
    pub type IPRIOR56 = crate::Reg<iprior56::IPRIOR56_SPEC>;
    ///Interrupt Priority configuration Register
    pub mod iprior56 {
        ///Register `IPRIOR56` reader
        pub type R = crate::R<IPRIOR56_SPEC>;
        ///Register `IPRIOR56` writer
        pub type W = crate::W<IPRIOR56_SPEC>;
        ///Field `IPRIOR56` reader - IPRIOR56
        pub type IPRIOR56_R = crate::FieldReader<u32>;
        ///Field `IPRIOR56` writer - IPRIOR56
        pub type IPRIOR56_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - IPRIOR56
            #[inline(always)]
            pub fn iprior56(&self) -> IPRIOR56_R {
                IPRIOR56_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - IPRIOR56
            #[inline(always)]
            #[must_use]
            pub fn iprior56(&mut self) -> IPRIOR56_W<IPRIOR56_SPEC> {
                IPRIOR56_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior56::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior56::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR56_SPEC;
        impl crate::RegisterSpec for IPRIOR56_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior56::R`](R) reader structure
        impl crate::Readable for IPRIOR56_SPEC {}
        ///`write(|w| ..)` method takes [`iprior56::W`](W) writer structure
        impl crate::Writable for IPRIOR56_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR56 to value 0
        impl crate::Resettable for IPRIOR56_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR57 (rw) register accessor: Interrupt Priority configuration Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior57::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior57::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior57`]
    ///module
    pub type IPRIOR57 = crate::Reg<iprior57::IPRIOR57_SPEC>;
    ///Interrupt Priority configuration Register
    pub mod iprior57 {
        ///Register `IPRIOR57` reader
        pub type R = crate::R<IPRIOR57_SPEC>;
        ///Register `IPRIOR57` writer
        pub type W = crate::W<IPRIOR57_SPEC>;
        ///Field `IPRIOR57` reader - IPRIOR57
        pub type IPRIOR57_R = crate::FieldReader<u32>;
        ///Field `IPRIOR57` writer - IPRIOR57
        pub type IPRIOR57_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - IPRIOR57
            #[inline(always)]
            pub fn iprior57(&self) -> IPRIOR57_R {
                IPRIOR57_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - IPRIOR57
            #[inline(always)]
            #[must_use]
            pub fn iprior57(&mut self) -> IPRIOR57_W<IPRIOR57_SPEC> {
                IPRIOR57_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior57::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior57::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR57_SPEC;
        impl crate::RegisterSpec for IPRIOR57_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior57::R`](R) reader structure
        impl crate::Readable for IPRIOR57_SPEC {}
        ///`write(|w| ..)` method takes [`iprior57::W`](W) writer structure
        impl crate::Writable for IPRIOR57_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR57 to value 0
        impl crate::Resettable for IPRIOR57_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR58 (rw) register accessor: Interrupt Priority configuration Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior58::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior58::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior58`]
    ///module
    pub type IPRIOR58 = crate::Reg<iprior58::IPRIOR58_SPEC>;
    ///Interrupt Priority configuration Register
    pub mod iprior58 {
        ///Register `IPRIOR58` reader
        pub type R = crate::R<IPRIOR58_SPEC>;
        ///Register `IPRIOR58` writer
        pub type W = crate::W<IPRIOR58_SPEC>;
        ///Field `IPRIOR58` reader - IPRIOR58
        pub type IPRIOR58_R = crate::FieldReader<u32>;
        ///Field `IPRIOR58` writer - IPRIOR58
        pub type IPRIOR58_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - IPRIOR58
            #[inline(always)]
            pub fn iprior58(&self) -> IPRIOR58_R {
                IPRIOR58_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - IPRIOR58
            #[inline(always)]
            #[must_use]
            pub fn iprior58(&mut self) -> IPRIOR58_W<IPRIOR58_SPEC> {
                IPRIOR58_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior58::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior58::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR58_SPEC;
        impl crate::RegisterSpec for IPRIOR58_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior58::R`](R) reader structure
        impl crate::Readable for IPRIOR58_SPEC {}
        ///`write(|w| ..)` method takes [`iprior58::W`](W) writer structure
        impl crate::Writable for IPRIOR58_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR58 to value 0
        impl crate::Resettable for IPRIOR58_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR59 (rw) register accessor: Interrupt Priority configuration Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior59::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior59::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior59`]
    ///module
    pub type IPRIOR59 = crate::Reg<iprior59::IPRIOR59_SPEC>;
    ///Interrupt Priority configuration Register
    pub mod iprior59 {
        ///Register `IPRIOR59` reader
        pub type R = crate::R<IPRIOR59_SPEC>;
        ///Register `IPRIOR59` writer
        pub type W = crate::W<IPRIOR59_SPEC>;
        ///Field `IPRIOR59` reader - IPRIOR59
        pub type IPRIOR59_R = crate::FieldReader<u32>;
        ///Field `IPRIOR59` writer - IPRIOR59
        pub type IPRIOR59_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - IPRIOR59
            #[inline(always)]
            pub fn iprior59(&self) -> IPRIOR59_R {
                IPRIOR59_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - IPRIOR59
            #[inline(always)]
            #[must_use]
            pub fn iprior59(&mut self) -> IPRIOR59_W<IPRIOR59_SPEC> {
                IPRIOR59_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior59::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior59::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR59_SPEC;
        impl crate::RegisterSpec for IPRIOR59_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior59::R`](R) reader structure
        impl crate::Readable for IPRIOR59_SPEC {}
        ///`write(|w| ..)` method takes [`iprior59::W`](W) writer structure
        impl crate::Writable for IPRIOR59_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR59 to value 0
        impl crate::Resettable for IPRIOR59_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR60 (rw) register accessor: Interrupt Priority configuration Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior60::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior60::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior60`]
    ///module
    pub type IPRIOR60 = crate::Reg<iprior60::IPRIOR60_SPEC>;
    ///Interrupt Priority configuration Register
    pub mod iprior60 {
        ///Register `IPRIOR60` reader
        pub type R = crate::R<IPRIOR60_SPEC>;
        ///Register `IPRIOR60` writer
        pub type W = crate::W<IPRIOR60_SPEC>;
        ///Field `IPRIOR60` reader - IPRIOR60
        pub type IPRIOR60_R = crate::FieldReader<u32>;
        ///Field `IPRIOR60` writer - IPRIOR60
        pub type IPRIOR60_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - IPRIOR60
            #[inline(always)]
            pub fn iprior60(&self) -> IPRIOR60_R {
                IPRIOR60_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - IPRIOR60
            #[inline(always)]
            #[must_use]
            pub fn iprior60(&mut self) -> IPRIOR60_W<IPRIOR60_SPEC> {
                IPRIOR60_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior60::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior60::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR60_SPEC;
        impl crate::RegisterSpec for IPRIOR60_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior60::R`](R) reader structure
        impl crate::Readable for IPRIOR60_SPEC {}
        ///`write(|w| ..)` method takes [`iprior60::W`](W) writer structure
        impl crate::Writable for IPRIOR60_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR60 to value 0
        impl crate::Resettable for IPRIOR60_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR61 (rw) register accessor: Interrupt Priority configuration Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior61::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior61::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior61`]
    ///module
    pub type IPRIOR61 = crate::Reg<iprior61::IPRIOR61_SPEC>;
    ///Interrupt Priority configuration Register
    pub mod iprior61 {
        ///Register `IPRIOR61` reader
        pub type R = crate::R<IPRIOR61_SPEC>;
        ///Register `IPRIOR61` writer
        pub type W = crate::W<IPRIOR61_SPEC>;
        ///Field `IPRIOR61` reader - IPRIOR61
        pub type IPRIOR61_R = crate::FieldReader<u32>;
        ///Field `IPRIOR61` writer - IPRIOR61
        pub type IPRIOR61_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - IPRIOR61
            #[inline(always)]
            pub fn iprior61(&self) -> IPRIOR61_R {
                IPRIOR61_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - IPRIOR61
            #[inline(always)]
            #[must_use]
            pub fn iprior61(&mut self) -> IPRIOR61_W<IPRIOR61_SPEC> {
                IPRIOR61_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior61::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior61::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR61_SPEC;
        impl crate::RegisterSpec for IPRIOR61_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior61::R`](R) reader structure
        impl crate::Readable for IPRIOR61_SPEC {}
        ///`write(|w| ..)` method takes [`iprior61::W`](W) writer structure
        impl crate::Writable for IPRIOR61_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR61 to value 0
        impl crate::Resettable for IPRIOR61_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR62 (rw) register accessor: Interrupt Priority configuration Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior62::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior62::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior62`]
    ///module
    pub type IPRIOR62 = crate::Reg<iprior62::IPRIOR62_SPEC>;
    ///Interrupt Priority configuration Register
    pub mod iprior62 {
        ///Register `IPRIOR62` reader
        pub type R = crate::R<IPRIOR62_SPEC>;
        ///Register `IPRIOR62` writer
        pub type W = crate::W<IPRIOR62_SPEC>;
        ///Field `IPRIOR62` reader - IPRIOR62
        pub type IPRIOR62_R = crate::FieldReader<u32>;
        ///Field `IPRIOR62` writer - IPRIOR62
        pub type IPRIOR62_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - IPRIOR62
            #[inline(always)]
            pub fn iprior62(&self) -> IPRIOR62_R {
                IPRIOR62_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - IPRIOR62
            #[inline(always)]
            #[must_use]
            pub fn iprior62(&mut self) -> IPRIOR62_W<IPRIOR62_SPEC> {
                IPRIOR62_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior62::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior62::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR62_SPEC;
        impl crate::RegisterSpec for IPRIOR62_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior62::R`](R) reader structure
        impl crate::Readable for IPRIOR62_SPEC {}
        ///`write(|w| ..)` method takes [`iprior62::W`](W) writer structure
        impl crate::Writable for IPRIOR62_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR62 to value 0
        impl crate::Resettable for IPRIOR62_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR63 (rw) register accessor: Interrupt Priority configuration Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior63::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior63::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior63`]
    ///module
    pub type IPRIOR63 = crate::Reg<iprior63::IPRIOR63_SPEC>;
    ///Interrupt Priority configuration Register
    pub mod iprior63 {
        ///Register `IPRIOR63` reader
        pub type R = crate::R<IPRIOR63_SPEC>;
        ///Register `IPRIOR63` writer
        pub type W = crate::W<IPRIOR63_SPEC>;
        ///Field `IPRIOR63` reader - IPRIOR63
        pub type IPRIOR63_R = crate::FieldReader<u32>;
        ///Field `IPRIOR63` writer - IPRIOR63
        pub type IPRIOR63_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - IPRIOR63
            #[inline(always)]
            pub fn iprior63(&self) -> IPRIOR63_R {
                IPRIOR63_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - IPRIOR63
            #[inline(always)]
            #[must_use]
            pub fn iprior63(&mut self) -> IPRIOR63_W<IPRIOR63_SPEC> {
                IPRIOR63_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior63::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior63::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR63_SPEC;
        impl crate::RegisterSpec for IPRIOR63_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior63::R`](R) reader structure
        impl crate::Readable for IPRIOR63_SPEC {}
        ///`write(|w| ..)` method takes [`iprior63::W`](W) writer structure
        impl crate::Writable for IPRIOR63_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR63 to value 0
        impl crate::Resettable for IPRIOR63_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///SCTLR (rw) register accessor: System Control Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`sctlr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`sctlr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@sctlr`]
    ///module
    pub type SCTLR = crate::Reg<sctlr::SCTLR_SPEC>;
    ///System Control Register
    pub mod sctlr {
        ///Register `SCTLR` reader
        pub type R = crate::R<SCTLR_SPEC>;
        ///Register `SCTLR` writer
        pub type W = crate::W<SCTLR_SPEC>;
        ///Field `SLEEPONEXIT` reader - SLEEPONEXIT
        pub type SLEEPONEXIT_R = crate::BitReader;
        ///Field `SLEEPONEXIT` writer - SLEEPONEXIT
        pub type SLEEPONEXIT_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `SLEEPDEEP` reader - SLEEPDEEP
        pub type SLEEPDEEP_R = crate::BitReader;
        ///Field `SLEEPDEEP` writer - SLEEPDEEP
        pub type SLEEPDEEP_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `WFITOWFE` reader - WFITOWFE
        pub type WFITOWFE_R = crate::BitReader;
        ///Field `WFITOWFE` writer - WFITOWFE
        pub type WFITOWFE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `SEVONPEND` reader - SEVONPEND
        pub type SEVONPEND_R = crate::BitReader;
        ///Field `SEVONPEND` writer - SEVONPEND
        pub type SEVONPEND_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `SETEVENT` reader - SETEVENT
        pub type SETEVENT_R = crate::BitReader;
        ///Field `SETEVENT` writer - SETEVENT
        pub type SETEVENT_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 1 - SLEEPONEXIT
            #[inline(always)]
            pub fn sleeponexit(&self) -> SLEEPONEXIT_R {
                SLEEPONEXIT_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - SLEEPDEEP
            #[inline(always)]
            pub fn sleepdeep(&self) -> SLEEPDEEP_R {
                SLEEPDEEP_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - WFITOWFE
            #[inline(always)]
            pub fn wfitowfe(&self) -> WFITOWFE_R {
                WFITOWFE_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - SEVONPEND
            #[inline(always)]
            pub fn sevonpend(&self) -> SEVONPEND_R {
                SEVONPEND_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - SETEVENT
            #[inline(always)]
            pub fn setevent(&self) -> SETEVENT_R {
                SETEVENT_R::new(((self.bits >> 5) & 1) != 0)
            }
        }
        impl W {
            ///Bit 1 - SLEEPONEXIT
            #[inline(always)]
            #[must_use]
            pub fn sleeponexit(&mut self) -> SLEEPONEXIT_W<SCTLR_SPEC> {
                SLEEPONEXIT_W::new(self, 1)
            }
            ///Bit 2 - SLEEPDEEP
            #[inline(always)]
            #[must_use]
            pub fn sleepdeep(&mut self) -> SLEEPDEEP_W<SCTLR_SPEC> {
                SLEEPDEEP_W::new(self, 2)
            }
            ///Bit 3 - WFITOWFE
            #[inline(always)]
            #[must_use]
            pub fn wfitowfe(&mut self) -> WFITOWFE_W<SCTLR_SPEC> {
                WFITOWFE_W::new(self, 3)
            }
            ///Bit 4 - SEVONPEND
            #[inline(always)]
            #[must_use]
            pub fn sevonpend(&mut self) -> SEVONPEND_W<SCTLR_SPEC> {
                SEVONPEND_W::new(self, 4)
            }
            ///Bit 5 - SETEVENT
            #[inline(always)]
            #[must_use]
            pub fn setevent(&mut self) -> SETEVENT_W<SCTLR_SPEC> {
                SETEVENT_W::new(self, 5)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///System Control Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`sctlr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`sctlr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct SCTLR_SPEC;
        impl crate::RegisterSpec for SCTLR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`sctlr::R`](R) reader structure
        impl crate::Readable for SCTLR_SPEC {}
        ///`write(|w| ..)` method takes [`sctlr::W`](W) writer structure
        impl crate::Writable for SCTLR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets SCTLR to value 0
        impl crate::Resettable for SCTLR_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
}
///Systick register
pub struct SYSTICK {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for SYSTICK {}
impl SYSTICK {
    ///Pointer to the register block
    pub const PTR: *const systick::RegisterBlock = 0xe000_f000 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const systick::RegisterBlock {
        Self::PTR
    }
    /// Steal an instance of this peripheral
    ///
    /// # Safety
    ///
    /// Ensure that the new instance of the peripheral cannot be used in a way
    /// that may race with any existing instances, for example by only
    /// accessing read-only or write-only registers, or by consuming the
    /// original peripheral and using critical sections to coordinate
    /// access between multiple new instances.
    ///
    /// Additionally, other software such as HALs may rely on only one
    /// peripheral instance existing to ensure memory safety; ensure
    /// no stolen instances are passed to such software.
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for SYSTICK {
    type Target = systick::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for SYSTICK {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("SYSTICK").finish()
    }
}
///Systick register
pub mod systick {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        stk_ctlr: STK_CTLR,
        stk_cntl: STK_CNTL,
        stk_cnth: STK_CNTH,
        stk_cmplr: STK_CMPLR,
        stk_cmphr: STK_CMPHR,
        stk_cntfg: STK_CNTFG,
    }
    impl RegisterBlock {
        ///0x00 - Systick counter control register
        #[inline(always)]
        pub const fn stk_ctlr(&self) -> &STK_CTLR {
            &self.stk_ctlr
        }
        ///0x04 - Systick counter low register
        #[inline(always)]
        pub const fn stk_cntl(&self) -> &STK_CNTL {
            &self.stk_cntl
        }
        ///0x08 - Systick counter high register
        #[inline(always)]
        pub const fn stk_cnth(&self) -> &STK_CNTH {
            &self.stk_cnth
        }
        ///0x0c - Systick compare low register
        #[inline(always)]
        pub const fn stk_cmplr(&self) -> &STK_CMPLR {
            &self.stk_cmplr
        }
        ///0x10 - Systick compare high register
        #[inline(always)]
        pub const fn stk_cmphr(&self) -> &STK_CMPHR {
            &self.stk_cmphr
        }
        ///0x14 - Systick counter flag
        #[inline(always)]
        pub const fn stk_cntfg(&self) -> &STK_CNTFG {
            &self.stk_cntfg
        }
    }
    ///STK_CTLR (rw) register accessor: Systick counter control register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`stk_ctlr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`stk_ctlr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@stk_ctlr`]
    ///module
    pub type STK_CTLR = crate::Reg<stk_ctlr::STK_CTLR_SPEC>;
    ///Systick counter control register
    pub mod stk_ctlr {
        ///Register `STK_CTLR` reader
        pub type R = crate::R<STK_CTLR_SPEC>;
        ///Register `STK_CTLR` writer
        pub type W = crate::W<STK_CTLR_SPEC>;
        ///Field `STE` reader - Systick counter enable
        pub type STE_R = crate::BitReader;
        ///Field `STE` writer - Systick counter enable
        pub type STE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `STIE` reader - Systick counter interrupt enable
        pub type STIE_R = crate::BitReader;
        ///Field `STIE` writer - Systick counter interrupt enable
        pub type STIE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `STCLK` reader - System counter clock Source selection
        pub type STCLK_R = crate::BitReader;
        ///Field `STCLK` writer - System counter clock Source selection
        pub type STCLK_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `STRELOAD` reader - System counter reload control
        pub type STRELOAD_R = crate::BitReader;
        ///Field `STRELOAD` writer - System counter reload control
        pub type STRELOAD_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - Systick counter enable
            #[inline(always)]
            pub fn ste(&self) -> STE_R {
                STE_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Systick counter interrupt enable
            #[inline(always)]
            pub fn stie(&self) -> STIE_R {
                STIE_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - System counter clock Source selection
            #[inline(always)]
            pub fn stclk(&self) -> STCLK_R {
                STCLK_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 8 - System counter reload control
            #[inline(always)]
            pub fn streload(&self) -> STRELOAD_R {
                STRELOAD_R::new(((self.bits >> 8) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - Systick counter enable
            #[inline(always)]
            #[must_use]
            pub fn ste(&mut self) -> STE_W<STK_CTLR_SPEC> {
                STE_W::new(self, 0)
            }
            ///Bit 1 - Systick counter interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn stie(&mut self) -> STIE_W<STK_CTLR_SPEC> {
                STIE_W::new(self, 1)
            }
            ///Bit 2 - System counter clock Source selection
            #[inline(always)]
            #[must_use]
            pub fn stclk(&mut self) -> STCLK_W<STK_CTLR_SPEC> {
                STCLK_W::new(self, 2)
            }
            ///Bit 8 - System counter reload control
            #[inline(always)]
            #[must_use]
            pub fn streload(&mut self) -> STRELOAD_W<STK_CTLR_SPEC> {
                STRELOAD_W::new(self, 8)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Systick counter control register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`stk_ctlr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`stk_ctlr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct STK_CTLR_SPEC;
        impl crate::RegisterSpec for STK_CTLR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`stk_ctlr::R`](R) reader structure
        impl crate::Readable for STK_CTLR_SPEC {}
        ///`write(|w| ..)` method takes [`stk_ctlr::W`](W) writer structure
        impl crate::Writable for STK_CTLR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets STK_CTLR to value 0
        impl crate::Resettable for STK_CTLR_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///STK_CNTL (rw) register accessor: Systick counter low register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`stk_cntl::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`stk_cntl::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@stk_cntl`]
    ///module
    pub type STK_CNTL = crate::Reg<stk_cntl::STK_CNTL_SPEC>;
    ///Systick counter low register
    pub mod stk_cntl {
        ///Register `STK_CNTL` reader
        pub type R = crate::R<STK_CNTL_SPEC>;
        ///Register `STK_CNTL` writer
        pub type W = crate::W<STK_CNTL_SPEC>;
        ///Field `CNTL` reader - CNTL
        pub type CNTL_R = crate::FieldReader<u32>;
        ///Field `CNTL` writer - CNTL
        pub type CNTL_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - CNTL
            #[inline(always)]
            pub fn cntl(&self) -> CNTL_R {
                CNTL_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - CNTL
            #[inline(always)]
            #[must_use]
            pub fn cntl(&mut self) -> CNTL_W<STK_CNTL_SPEC> {
                CNTL_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Systick counter low register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`stk_cntl::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`stk_cntl::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct STK_CNTL_SPEC;
        impl crate::RegisterSpec for STK_CNTL_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`stk_cntl::R`](R) reader structure
        impl crate::Readable for STK_CNTL_SPEC {}
        ///`write(|w| ..)` method takes [`stk_cntl::W`](W) writer structure
        impl crate::Writable for STK_CNTL_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets STK_CNTL to value 0
        impl crate::Resettable for STK_CNTL_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///STK_CNTH (rw) register accessor: Systick counter high register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`stk_cnth::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`stk_cnth::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@stk_cnth`]
    ///module
    pub type STK_CNTH = crate::Reg<stk_cnth::STK_CNTH_SPEC>;
    ///Systick counter high register
    pub mod stk_cnth {
        ///Register `STK_CNTH` reader
        pub type R = crate::R<STK_CNTH_SPEC>;
        ///Register `STK_CNTH` writer
        pub type W = crate::W<STK_CNTH_SPEC>;
        ///Field `CNTH` reader - CNTH
        pub type CNTH_R = crate::FieldReader<u32>;
        ///Field `CNTH` writer - CNTH
        pub type CNTH_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - CNTH
            #[inline(always)]
            pub fn cnth(&self) -> CNTH_R {
                CNTH_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - CNTH
            #[inline(always)]
            #[must_use]
            pub fn cnth(&mut self) -> CNTH_W<STK_CNTH_SPEC> {
                CNTH_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Systick counter high register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`stk_cnth::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`stk_cnth::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct STK_CNTH_SPEC;
        impl crate::RegisterSpec for STK_CNTH_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`stk_cnth::R`](R) reader structure
        impl crate::Readable for STK_CNTH_SPEC {}
        ///`write(|w| ..)` method takes [`stk_cnth::W`](W) writer structure
        impl crate::Writable for STK_CNTH_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets STK_CNTH to value 0
        impl crate::Resettable for STK_CNTH_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///STK_CMPLR (rw) register accessor: Systick compare low register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`stk_cmplr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`stk_cmplr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@stk_cmplr`]
    ///module
    pub type STK_CMPLR = crate::Reg<stk_cmplr::STK_CMPLR_SPEC>;
    ///Systick compare low register
    pub mod stk_cmplr {
        ///Register `STK_CMPLR` reader
        pub type R = crate::R<STK_CMPLR_SPEC>;
        ///Register `STK_CMPLR` writer
        pub type W = crate::W<STK_CMPLR_SPEC>;
        ///Field `CMPL` reader - CMPL
        pub type CMPL_R = crate::FieldReader<u32>;
        ///Field `CMPL` writer - CMPL
        pub type CMPL_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - CMPL
            #[inline(always)]
            pub fn cmpl(&self) -> CMPL_R {
                CMPL_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - CMPL
            #[inline(always)]
            #[must_use]
            pub fn cmpl(&mut self) -> CMPL_W<STK_CMPLR_SPEC> {
                CMPL_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Systick compare low register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`stk_cmplr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`stk_cmplr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct STK_CMPLR_SPEC;
        impl crate::RegisterSpec for STK_CMPLR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`stk_cmplr::R`](R) reader structure
        impl crate::Readable for STK_CMPLR_SPEC {}
        ///`write(|w| ..)` method takes [`stk_cmplr::W`](W) writer structure
        impl crate::Writable for STK_CMPLR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets STK_CMPLR to value 0
        impl crate::Resettable for STK_CMPLR_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///STK_CMPHR (rw) register accessor: Systick compare high register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`stk_cmphr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`stk_cmphr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@stk_cmphr`]
    ///module
    pub type STK_CMPHR = crate::Reg<stk_cmphr::STK_CMPHR_SPEC>;
    ///Systick compare high register
    pub mod stk_cmphr {
        ///Register `STK_CMPHR` reader
        pub type R = crate::R<STK_CMPHR_SPEC>;
        ///Register `STK_CMPHR` writer
        pub type W = crate::W<STK_CMPHR_SPEC>;
        ///Field `CMPH` reader - CMPH
        pub type CMPH_R = crate::FieldReader<u32>;
        ///Field `CMPH` writer - CMPH
        pub type CMPH_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - CMPH
            #[inline(always)]
            pub fn cmph(&self) -> CMPH_R {
                CMPH_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - CMPH
            #[inline(always)]
            #[must_use]
            pub fn cmph(&mut self) -> CMPH_W<STK_CMPHR_SPEC> {
                CMPH_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Systick compare high register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`stk_cmphr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`stk_cmphr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct STK_CMPHR_SPEC;
        impl crate::RegisterSpec for STK_CMPHR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`stk_cmphr::R`](R) reader structure
        impl crate::Readable for STK_CMPHR_SPEC {}
        ///`write(|w| ..)` method takes [`stk_cmphr::W`](W) writer structure
        impl crate::Writable for STK_CMPHR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets STK_CMPHR to value 0
        impl crate::Resettable for STK_CMPHR_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///STK_CNTFG (rw) register accessor: Systick counter flag
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`stk_cntfg::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`stk_cntfg::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@stk_cntfg`]
    ///module
    pub type STK_CNTFG = crate::Reg<stk_cntfg::STK_CNTFG_SPEC>;
    ///Systick counter flag
    pub mod stk_cntfg {
        ///Register `STK_CNTFG` reader
        pub type R = crate::R<STK_CNTFG_SPEC>;
        ///Register `STK_CNTFG` writer
        pub type W = crate::W<STK_CNTFG_SPEC>;
        ///Field `SWIE` reader - System soft interrupt enable
        pub type SWIE_R = crate::BitReader;
        ///Field `SWIE` writer - System soft interrupt enable
        pub type SWIE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CNTIF` reader - Systick counter clear zero flag
        pub type CNTIF_R = crate::BitReader;
        ///Field `CNTIF` writer - Systick counter clear zero flag
        pub type CNTIF_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - System soft interrupt enable
            #[inline(always)]
            pub fn swie(&self) -> SWIE_R {
                SWIE_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Systick counter clear zero flag
            #[inline(always)]
            pub fn cntif(&self) -> CNTIF_R {
                CNTIF_R::new(((self.bits >> 1) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - System soft interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn swie(&mut self) -> SWIE_W<STK_CNTFG_SPEC> {
                SWIE_W::new(self, 0)
            }
            ///Bit 1 - Systick counter clear zero flag
            #[inline(always)]
            #[must_use]
            pub fn cntif(&mut self) -> CNTIF_W<STK_CNTFG_SPEC> {
                CNTIF_W::new(self, 1)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Systick counter flag
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`stk_cntfg::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`stk_cntfg::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct STK_CNTFG_SPEC;
        impl crate::RegisterSpec for STK_CNTFG_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`stk_cntfg::R`](R) reader structure
        impl crate::Readable for STK_CNTFG_SPEC {}
        ///`write(|w| ..)` method takes [`stk_cntfg::W`](W) writer structure
        impl crate::Writable for STK_CNTFG_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets STK_CNTFG to value 0
        impl crate::Resettable for STK_CNTFG_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
}
///EMMC register
pub struct EMMC {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for EMMC {}
impl EMMC {
    ///Pointer to the register block
    pub const PTR: *const emmc::RegisterBlock = 0x4000_a000 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const emmc::RegisterBlock {
        Self::PTR
    }
    /// Steal an instance of this peripheral
    ///
    /// # Safety
    ///
    /// Ensure that the new instance of the peripheral cannot be used in a way
    /// that may race with any existing instances, for example by only
    /// accessing read-only or write-only registers, or by consuming the
    /// original peripheral and using critical sections to coordinate
    /// access between multiple new instances.
    ///
    /// Additionally, other software such as HALs may rely on only one
    /// peripheral instance existing to ensure memory safety; ensure
    /// no stolen instances are passed to such software.
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for EMMC {
    type Target = emmc::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for EMMC {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("EMMC").finish()
    }
}
///EMMC register
pub mod emmc {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        argument: ARGUMENT,
        cmd_set: CMD_SET,
        _reserved2: [u8; 0x02],
        response0: RESPONSE0,
        response1: RESPONSE1,
        response2: RESPONSE2,
        _reserved_5_response3: [u8; 0x04],
        control: CONTROL,
        _reserved7: [u8; 0x03],
        timeout: TIMEOUT,
        _reserved8: [u8; 0x03],
        status: STATUS,
        int_fg: INT_FG,
        _reserved10: [u8; 0x02],
        int_en: INT_EN,
        _reserved11: [u8; 0x02],
        dma_beg1: DMA_BEG1,
        block_cfg: BLOCK_CFG,
        tran_mode: TRAN_MODE,
        clk_div: CLK_DIV,
        _reserved15: [u8; 0x02],
        dma_beg2: DMA_BEG2,
    }
    impl RegisterBlock {
        ///0x00 - SD 32bits command argument register
        #[inline(always)]
        pub const fn argument(&self) -> &ARGUMENT {
            &self.argument
        }
        ///0x04 - SD 16bits cmd setting register
        #[inline(always)]
        pub const fn cmd_set(&self) -> &CMD_SET {
            &self.cmd_set
        }
        ///0x08 - SD 128bits response register, \[31:0\]
        ///32bits
        #[inline(always)]
        pub const fn response0(&self) -> &RESPONSE0 {
            &self.response0
        }
        ///0x0c - SD 128bits response register, \[63:32\]
        ///32bits
        #[inline(always)]
        pub const fn response1(&self) -> &RESPONSE1 {
            &self.response1
        }
        ///0x10 - SD 128bits response register, \[95:64\]
        ///32bits
        #[inline(always)]
        pub const fn response2(&self) -> &RESPONSE2 {
            &self.response2
        }
        ///0x14 - Multiplexing register of the EMMC_RESPONSE3,\[127:96\]
        ///32bits
        #[inline(always)]
        pub const fn write_cont(&self) -> &WRITE_CONT {
            unsafe { &*(self as *const Self).cast::<u8>().add(20).cast() }
        }
        ///0x14 - SD 128bits response register, \[127:96\]
        ///32bits
        #[inline(always)]
        pub const fn response3(&self) -> &RESPONSE3 {
            unsafe { &*(self as *const Self).cast::<u8>().add(20).cast() }
        }
        ///0x18 - SD 8bits control register
        #[inline(always)]
        pub const fn control(&self) -> &CONTROL {
            &self.control
        }
        ///0x1c - SD 8bits data timeout value
        #[inline(always)]
        pub const fn timeout(&self) -> &TIMEOUT {
            &self.timeout
        }
        ///0x20 - SD status
        #[inline(always)]
        pub const fn status(&self) -> &STATUS {
            &self.status
        }
        ///0x24 - SD 16bits interrupt flag register
        #[inline(always)]
        pub const fn int_fg(&self) -> &INT_FG {
            &self.int_fg
        }
        ///0x28 - SD 16bits interrupt enable register
        #[inline(always)]
        pub const fn int_en(&self) -> &INT_EN {
            &self.int_en
        }
        ///0x2c - SD 16bits DMA start address register when to operate
        #[inline(always)]
        pub const fn dma_beg1(&self) -> &DMA_BEG1 {
            &self.dma_beg1
        }
        ///0x30 - SD 32bits data counter, \[15:0\]
        ///number of blocks this time will tran/recv, \[27:16\]
        ///block sise(byte number) of every block in this time tran/recv
        #[inline(always)]
        pub const fn block_cfg(&self) -> &BLOCK_CFG {
            &self.block_cfg
        }
        ///0x34 - SD TRANSFER MODE register
        #[inline(always)]
        pub const fn tran_mode(&self) -> &TRAN_MODE {
            &self.tran_mode
        }
        ///0x38 - SD clock divider register
        #[inline(always)]
        pub const fn clk_div(&self) -> &CLK_DIV {
            &self.clk_div
        }
        ///0x3c - SD 16bits DMA start address register when to operate
        #[inline(always)]
        pub const fn dma_beg2(&self) -> &DMA_BEG2 {
            &self.dma_beg2
        }
    }
    ///CLK_DIV (rw) register accessor: SD clock divider register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`clk_div::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`clk_div::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@clk_div`]
    ///module
    pub type CLK_DIV = crate::Reg<clk_div::CLK_DIV_SPEC>;
    ///SD clock divider register
    pub mod clk_div {
        ///Register `CLK_DIV` reader
        pub type R = crate::R<CLK_DIV_SPEC>;
        ///Register `CLK_DIV` writer
        pub type W = crate::W<CLK_DIV_SPEC>;
        ///Field `DIV_MASK` reader - clk div
        pub type DIV_MASK_R = crate::FieldReader;
        ///Field `DIV_MASK` writer - clk div
        pub type DIV_MASK_W<'a, REG> = crate::FieldWriter<'a, REG, 5>;
        ///Field `CLKOE` reader - chip output sdclk oe
        pub type CLKOE_R = crate::BitReader;
        ///Field `CLKOE` writer - chip output sdclk oe
        pub type CLKOE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CLKMode` reader - EMMC clock frequency mode selection bit
        pub type CLKMODE_R = crate::BitReader;
        ///Field `CLKMode` writer - EMMC clock frequency mode selection bit
        pub type CLKMODE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PHASEINV` reader - invert chip output sdclk phase
        pub type PHASEINV_R = crate::BitReader;
        ///Field `PHASEINV` writer - invert chip output sdclk phase
        pub type PHASEINV_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bits 0:4 - clk div
            #[inline(always)]
            pub fn div_mask(&self) -> DIV_MASK_R {
                DIV_MASK_R::new((self.bits & 0x1f) as u8)
            }
            ///Bit 8 - chip output sdclk oe
            #[inline(always)]
            pub fn clkoe(&self) -> CLKOE_R {
                CLKOE_R::new(((self.bits >> 8) & 1) != 0)
            }
            ///Bit 9 - EMMC clock frequency mode selection bit
            #[inline(always)]
            pub fn clkmode(&self) -> CLKMODE_R {
                CLKMODE_R::new(((self.bits >> 9) & 1) != 0)
            }
            ///Bit 10 - invert chip output sdclk phase
            #[inline(always)]
            pub fn phaseinv(&self) -> PHASEINV_R {
                PHASEINV_R::new(((self.bits >> 10) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:4 - clk div
            #[inline(always)]
            #[must_use]
            pub fn div_mask(&mut self) -> DIV_MASK_W<CLK_DIV_SPEC> {
                DIV_MASK_W::new(self, 0)
            }
            ///Bit 8 - chip output sdclk oe
            #[inline(always)]
            #[must_use]
            pub fn clkoe(&mut self) -> CLKOE_W<CLK_DIV_SPEC> {
                CLKOE_W::new(self, 8)
            }
            ///Bit 9 - EMMC clock frequency mode selection bit
            #[inline(always)]
            #[must_use]
            pub fn clkmode(&mut self) -> CLKMODE_W<CLK_DIV_SPEC> {
                CLKMODE_W::new(self, 9)
            }
            ///Bit 10 - invert chip output sdclk phase
            #[inline(always)]
            #[must_use]
            pub fn phaseinv(&mut self) -> PHASEINV_W<CLK_DIV_SPEC> {
                PHASEINV_W::new(self, 10)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///SD clock divider register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`clk_div::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`clk_div::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct CLK_DIV_SPEC;
        impl crate::RegisterSpec for CLK_DIV_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`clk_div::R`](R) reader structure
        impl crate::Readable for CLK_DIV_SPEC {}
        ///`write(|w| ..)` method takes [`clk_div::W`](W) writer structure
        impl crate::Writable for CLK_DIV_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets CLK_DIV to value 0x0213
        impl crate::Resettable for CLK_DIV_SPEC {
            const RESET_VALUE: u16 = 0x0213;
        }
    }
    ///ARGUMENT (rw) register accessor: SD 32bits command argument register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`argument::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`argument::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@argument`]
    ///module
    pub type ARGUMENT = crate::Reg<argument::ARGUMENT_SPEC>;
    ///SD 32bits command argument register
    pub mod argument {
        ///Register `ARGUMENT` reader
        pub type R = crate::R<ARGUMENT_SPEC>;
        ///Register `ARGUMENT` writer
        pub type W = crate::W<ARGUMENT_SPEC>;
        ///Field `ARGUMENT` reader - 32 bit command parameter register
        pub type ARGUMENT_R = crate::FieldReader<u32>;
        ///Field `ARGUMENT` writer - 32 bit command parameter register
        pub type ARGUMENT_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - 32 bit command parameter register
            #[inline(always)]
            pub fn argument(&self) -> ARGUMENT_R {
                ARGUMENT_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - 32 bit command parameter register
            #[inline(always)]
            #[must_use]
            pub fn argument(&mut self) -> ARGUMENT_W<ARGUMENT_SPEC> {
                ARGUMENT_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///SD 32bits command argument register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`argument::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`argument::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct ARGUMENT_SPEC;
        impl crate::RegisterSpec for ARGUMENT_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`argument::R`](R) reader structure
        impl crate::Readable for ARGUMENT_SPEC {}
        ///`write(|w| ..)` method takes [`argument::W`](W) writer structure
        impl crate::Writable for ARGUMENT_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets ARGUMENT to value 0
        impl crate::Resettable for ARGUMENT_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///CMD_SET (rw) register accessor: SD 16bits cmd setting register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`cmd_set::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cmd_set::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@cmd_set`]
    ///module
    pub type CMD_SET = crate::Reg<cmd_set::CMD_SET_SPEC>;
    ///SD 16bits cmd setting register
    pub mod cmd_set {
        ///Register `CMD_SET` reader
        pub type R = crate::R<CMD_SET_SPEC>;
        ///Register `CMD_SET` writer
        pub type W = crate::W<CMD_SET_SPEC>;
        ///Field `CMDIDX_MASK` reader - the index number of the currently sent command
        pub type CMDIDX_MASK_R = crate::FieldReader;
        ///Field `CMDIDX_MASK` writer - the index number of the currently sent command
        pub type CMDIDX_MASK_W<'a, REG> = crate::FieldWriter<'a, REG, 6>;
        ///Field `RPTY_MASK` reader - current respone type
        pub type RPTY_MASK_R = crate::FieldReader;
        ///Field `RPTY_MASK` writer - current respone type
        pub type RPTY_MASK_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `CKCRC` reader - check the response CRC
        pub type CKCRC_R = crate::BitReader;
        ///Field `CKCRC` writer - check the response CRC
        pub type CKCRC_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CKIDX` reader - check the response command index
        pub type CKIDX_R = crate::BitReader;
        ///Field `CKIDX` writer - check the response command index
        pub type CKIDX_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bits 0:5 - the index number of the currently sent command
            #[inline(always)]
            pub fn cmdidx_mask(&self) -> CMDIDX_MASK_R {
                CMDIDX_MASK_R::new((self.bits & 0x3f) as u8)
            }
            ///Bits 8:9 - current respone type
            #[inline(always)]
            pub fn rpty_mask(&self) -> RPTY_MASK_R {
                RPTY_MASK_R::new(((self.bits >> 8) & 3) as u8)
            }
            ///Bit 10 - check the response CRC
            #[inline(always)]
            pub fn ckcrc(&self) -> CKCRC_R {
                CKCRC_R::new(((self.bits >> 10) & 1) != 0)
            }
            ///Bit 11 - check the response command index
            #[inline(always)]
            pub fn ckidx(&self) -> CKIDX_R {
                CKIDX_R::new(((self.bits >> 11) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:5 - the index number of the currently sent command
            #[inline(always)]
            #[must_use]
            pub fn cmdidx_mask(&mut self) -> CMDIDX_MASK_W<CMD_SET_SPEC> {
                CMDIDX_MASK_W::new(self, 0)
            }
            ///Bits 8:9 - current respone type
            #[inline(always)]
            #[must_use]
            pub fn rpty_mask(&mut self) -> RPTY_MASK_W<CMD_SET_SPEC> {
                RPTY_MASK_W::new(self, 8)
            }
            ///Bit 10 - check the response CRC
            #[inline(always)]
            #[must_use]
            pub fn ckcrc(&mut self) -> CKCRC_W<CMD_SET_SPEC> {
                CKCRC_W::new(self, 10)
            }
            ///Bit 11 - check the response command index
            #[inline(always)]
            #[must_use]
            pub fn ckidx(&mut self) -> CKIDX_W<CMD_SET_SPEC> {
                CKIDX_W::new(self, 11)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///SD 16bits cmd setting register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`cmd_set::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cmd_set::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct CMD_SET_SPEC;
        impl crate::RegisterSpec for CMD_SET_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`cmd_set::R`](R) reader structure
        impl crate::Readable for CMD_SET_SPEC {}
        ///`write(|w| ..)` method takes [`cmd_set::W`](W) writer structure
        impl crate::Writable for CMD_SET_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets CMD_SET to value 0
        impl crate::Resettable for CMD_SET_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///RESPONSE0 (r) register accessor: SD 128bits response register, \[31:0\]
    ///32bits
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`response0::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@response0`]
    ///module
    pub type RESPONSE0 = crate::Reg<response0::RESPONSE0_SPEC>;
    ///SD 128bits response register, \[31:0\]
    ///32bits
    pub mod response0 {
        ///Register `RESPONSE0` reader
        pub type R = crate::R<RESPONSE0_SPEC>;
        ///Field `RESPONSE0` reader - response parameter register
        pub type RESPONSE0_R = crate::FieldReader<u32>;
        impl R {
            ///Bits 0:31 - response parameter register
            #[inline(always)]
            pub fn response0(&self) -> RESPONSE0_R {
                RESPONSE0_R::new(self.bits)
            }
        }
        ///SD 128bits response register, \[31:0\]
        ///32bits
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`response0::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct RESPONSE0_SPEC;
        impl crate::RegisterSpec for RESPONSE0_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`response0::R`](R) reader structure
        impl crate::Readable for RESPONSE0_SPEC {}
        ///`reset()` method sets RESPONSE0 to value 0
        impl crate::Resettable for RESPONSE0_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///RESPONSE1 (r) register accessor: SD 128bits response register, \[63:32\]
    ///32bits
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`response1::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@response1`]
    ///module
    pub type RESPONSE1 = crate::Reg<response1::RESPONSE1_SPEC>;
    ///SD 128bits response register, \[63:32\]
    ///32bits
    pub mod response1 {
        ///Register `RESPONSE1` reader
        pub type R = crate::R<RESPONSE1_SPEC>;
        ///Field `RESPONSE1` reader - response parameter register
        pub type RESPONSE1_R = crate::FieldReader<u32>;
        impl R {
            ///Bits 0:31 - response parameter register
            #[inline(always)]
            pub fn response1(&self) -> RESPONSE1_R {
                RESPONSE1_R::new(self.bits)
            }
        }
        ///SD 128bits response register, \[63:32\]
        ///32bits
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`response1::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct RESPONSE1_SPEC;
        impl crate::RegisterSpec for RESPONSE1_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`response1::R`](R) reader structure
        impl crate::Readable for RESPONSE1_SPEC {}
        ///`reset()` method sets RESPONSE1 to value 0
        impl crate::Resettable for RESPONSE1_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///RESPONSE2 (r) register accessor: SD 128bits response register, \[95:64\]
    ///32bits
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`response2::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@response2`]
    ///module
    pub type RESPONSE2 = crate::Reg<response2::RESPONSE2_SPEC>;
    ///SD 128bits response register, \[95:64\]
    ///32bits
    pub mod response2 {
        ///Register `RESPONSE2` reader
        pub type R = crate::R<RESPONSE2_SPEC>;
        ///Field `RESPONSE2` reader - response parameter register
        pub type RESPONSE2_R = crate::FieldReader<u32>;
        impl R {
            ///Bits 0:31 - response parameter register
            #[inline(always)]
            pub fn response2(&self) -> RESPONSE2_R {
                RESPONSE2_R::new(self.bits)
            }
        }
        ///SD 128bits response register, \[95:64\]
        ///32bits
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`response2::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct RESPONSE2_SPEC;
        impl crate::RegisterSpec for RESPONSE2_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`response2::R`](R) reader structure
        impl crate::Readable for RESPONSE2_SPEC {}
        ///`reset()` method sets RESPONSE2 to value 0
        impl crate::Resettable for RESPONSE2_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///RESPONSE3 (r) register accessor: SD 128bits response register, \[127:96\]
    ///32bits
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`response3::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@response3`]
    ///module
    pub type RESPONSE3 = crate::Reg<response3::RESPONSE3_SPEC>;
    ///SD 128bits response register, \[127:96\]
    ///32bits
    pub mod response3 {
        ///Register `RESPONSE3` reader
        pub type R = crate::R<RESPONSE3_SPEC>;
        ///Field `RESPONSE3` reader - response parameter register
        pub type RESPONSE3_R = crate::FieldReader<u32>;
        impl R {
            ///Bits 0:31 - response parameter register
            #[inline(always)]
            pub fn response3(&self) -> RESPONSE3_R {
                RESPONSE3_R::new(self.bits)
            }
        }
        ///SD 128bits response register, \[127:96\]
        ///32bits
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`response3::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct RESPONSE3_SPEC;
        impl crate::RegisterSpec for RESPONSE3_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`response3::R`](R) reader structure
        impl crate::Readable for RESPONSE3_SPEC {}
        ///`reset()` method sets RESPONSE3 to value 0
        impl crate::Resettable for RESPONSE3_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///WRITE_CONT (w) register accessor: Multiplexing register of the EMMC_RESPONSE3,\[127:96\]
    ///32bits
    ///
    ///You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`write_cont::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@write_cont`]
    ///module
    pub type WRITE_CONT = crate::Reg<write_cont::WRITE_CONT_SPEC>;
    ///Multiplexing register of the EMMC_RESPONSE3,\[127:96\]
    ///32bits
    pub mod write_cont {
        ///Register `WRITE_CONT` writer
        pub type W = crate::W<WRITE_CONT_SPEC>;
        ///Field `WRITE_CONT` writer - response parameter register
        pub type WRITE_CONT_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl W {
            ///Bits 0:31 - response parameter register
            #[inline(always)]
            #[must_use]
            pub fn write_cont(&mut self) -> WRITE_CONT_W<WRITE_CONT_SPEC> {
                WRITE_CONT_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Multiplexing register of the EMMC_RESPONSE3,\[127:96\]
        ///32bits
        ///
        ///You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`write_cont::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct WRITE_CONT_SPEC;
        impl crate::RegisterSpec for WRITE_CONT_SPEC {
            type Ux = u32;
        }
        ///`write(|w| ..)` method takes [`write_cont::W`](W) writer structure
        impl crate::Writable for WRITE_CONT_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets WRITE_CONT to value 0
        impl crate::Resettable for WRITE_CONT_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///CONTROL (rw) register accessor: SD 8bits control register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`control::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`control::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@control`]
    ///module
    pub type CONTROL = crate::Reg<control::CONTROL_SPEC>;
    ///SD 8bits control register
    pub mod control {
        ///Register `CONTROL` reader
        pub type R = crate::R<CONTROL_SPEC>;
        ///Register `CONTROL` writer
        pub type W = crate::W<CONTROL_SPEC>;
        ///Field `LW_MASK` reader - effctive data width for sending or receiving data
        pub type LW_MASK_R = crate::FieldReader;
        ///Field `LW_MASK` writer - effctive data width for sending or receiving data
        pub type LW_MASK_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `ALL_CLR` reader - reset all the inner logic, default is valid
        pub type ALL_CLR_R = crate::BitReader;
        ///Field `ALL_CLR` writer - reset all the inner logic, default is valid
        pub type ALL_CLR_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `DMAEN` reader - enable the dma
        pub type DMAEN_R = crate::BitReader;
        ///Field `DMAEN` writer - enable the dma
        pub type DMAEN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `RST_LGC` reader - reset the data tran/recv logic
        pub type RST_LGC_R = crate::BitReader;
        ///Field `RST_LGC` writer - reset the data tran/recv logic
        pub type RST_LGC_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `NEGSMP` reader - controller use nagedge sample cmd
        pub type NEGSMP_R = crate::BitReader;
        ///Field `NEGSMP` writer - controller use nagedge sample cmd
        pub type NEGSMP_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bits 0:1 - effctive data width for sending or receiving data
            #[inline(always)]
            pub fn lw_mask(&self) -> LW_MASK_R {
                LW_MASK_R::new(self.bits & 3)
            }
            ///Bit 2 - reset all the inner logic, default is valid
            #[inline(always)]
            pub fn all_clr(&self) -> ALL_CLR_R {
                ALL_CLR_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - enable the dma
            #[inline(always)]
            pub fn dmaen(&self) -> DMAEN_R {
                DMAEN_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - reset the data tran/recv logic
            #[inline(always)]
            pub fn rst_lgc(&self) -> RST_LGC_R {
                RST_LGC_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - controller use nagedge sample cmd
            #[inline(always)]
            pub fn negsmp(&self) -> NEGSMP_R {
                NEGSMP_R::new(((self.bits >> 5) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:1 - effctive data width for sending or receiving data
            #[inline(always)]
            #[must_use]
            pub fn lw_mask(&mut self) -> LW_MASK_W<CONTROL_SPEC> {
                LW_MASK_W::new(self, 0)
            }
            ///Bit 2 - reset all the inner logic, default is valid
            #[inline(always)]
            #[must_use]
            pub fn all_clr(&mut self) -> ALL_CLR_W<CONTROL_SPEC> {
                ALL_CLR_W::new(self, 2)
            }
            ///Bit 3 - enable the dma
            #[inline(always)]
            #[must_use]
            pub fn dmaen(&mut self) -> DMAEN_W<CONTROL_SPEC> {
                DMAEN_W::new(self, 3)
            }
            ///Bit 4 - reset the data tran/recv logic
            #[inline(always)]
            #[must_use]
            pub fn rst_lgc(&mut self) -> RST_LGC_W<CONTROL_SPEC> {
                RST_LGC_W::new(self, 4)
            }
            ///Bit 5 - controller use nagedge sample cmd
            #[inline(always)]
            #[must_use]
            pub fn negsmp(&mut self) -> NEGSMP_W<CONTROL_SPEC> {
                NEGSMP_W::new(self, 5)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///SD 8bits control register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`control::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`control::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct CONTROL_SPEC;
        impl crate::RegisterSpec for CONTROL_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`control::R`](R) reader structure
        impl crate::Readable for CONTROL_SPEC {}
        ///`write(|w| ..)` method takes [`control::W`](W) writer structure
        impl crate::Writable for CONTROL_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets CONTROL to value 0x15
        impl crate::Resettable for CONTROL_SPEC {
            const RESET_VALUE: u8 = 0x15;
        }
    }
    ///TIMEOUT (rw) register accessor: SD 8bits data timeout value
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`timeout::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`timeout::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@timeout`]
    ///module
    pub type TIMEOUT = crate::Reg<timeout::TIMEOUT_SPEC>;
    ///SD 8bits data timeout value
    pub mod timeout {
        ///Register `TIMEOUT` reader
        pub type R = crate::R<TIMEOUT_SPEC>;
        ///Register `TIMEOUT` writer
        pub type W = crate::W<TIMEOUT_SPEC>;
        ///Field `TOCNT_MASK` reader - response /data timeout configuration
        pub type TOCNT_MASK_R = crate::FieldReader;
        ///Field `TOCNT_MASK` writer - response /data timeout configuration
        pub type TOCNT_MASK_W<'a, REG> = crate::FieldWriter<'a, REG, 4>;
        impl R {
            ///Bits 0:3 - response /data timeout configuration
            #[inline(always)]
            pub fn tocnt_mask(&self) -> TOCNT_MASK_R {
                TOCNT_MASK_R::new(self.bits & 0x0f)
            }
        }
        impl W {
            ///Bits 0:3 - response /data timeout configuration
            #[inline(always)]
            #[must_use]
            pub fn tocnt_mask(&mut self) -> TOCNT_MASK_W<TIMEOUT_SPEC> {
                TOCNT_MASK_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///SD 8bits data timeout value
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`timeout::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`timeout::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct TIMEOUT_SPEC;
        impl crate::RegisterSpec for TIMEOUT_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`timeout::R`](R) reader structure
        impl crate::Readable for TIMEOUT_SPEC {}
        ///`write(|w| ..)` method takes [`timeout::W`](W) writer structure
        impl crate::Writable for TIMEOUT_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets TIMEOUT to value 0x0c
        impl crate::Resettable for TIMEOUT_SPEC {
            const RESET_VALUE: u8 = 0x0c;
        }
    }
    ///STATUS (r) register accessor: SD status
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`status::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@status`]
    ///module
    pub type STATUS = crate::Reg<status::STATUS_SPEC>;
    ///SD status
    pub mod status {
        ///Register `STATUS` reader
        pub type R = crate::R<STATUS_SPEC>;
        ///Field `MASK_BLOCK_NUM` reader - the number of blocks successfully transmitted in the current multi-block transmission
        pub type MASK_BLOCK_NUM_R = crate::FieldReader<u16>;
        ///Field `CMDSTA` reader - indicate cmd line is high level now
        pub type CMDSTA_R = crate::BitReader;
        ///Field `DAT0STA` reader - indicate dat\[0\]
        ///line is high level now
        pub type DAT0STA_R = crate::BitReader;
        impl R {
            ///Bits 0:15 - the number of blocks successfully transmitted in the current multi-block transmission
            #[inline(always)]
            pub fn mask_block_num(&self) -> MASK_BLOCK_NUM_R {
                MASK_BLOCK_NUM_R::new((self.bits & 0xffff) as u16)
            }
            ///Bit 16 - indicate cmd line is high level now
            #[inline(always)]
            pub fn cmdsta(&self) -> CMDSTA_R {
                CMDSTA_R::new(((self.bits >> 16) & 1) != 0)
            }
            ///Bit 17 - indicate dat\[0\]
            ///line is high level now
            #[inline(always)]
            pub fn dat0sta(&self) -> DAT0STA_R {
                DAT0STA_R::new(((self.bits >> 17) & 1) != 0)
            }
        }
        ///SD status
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`status::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct STATUS_SPEC;
        impl crate::RegisterSpec for STATUS_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`status::R`](R) reader structure
        impl crate::Readable for STATUS_SPEC {}
        ///`reset()` method sets STATUS to value 0
        impl crate::Resettable for STATUS_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///INT_FG (rw) register accessor: SD 16bits interrupt flag register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`int_fg::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`int_fg::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@int_fg`]
    ///module
    pub type INT_FG = crate::Reg<int_fg::INT_FG_SPEC>;
    ///SD 16bits interrupt flag register
    pub mod int_fg {
        ///Register `INT_FG` reader
        pub type R = crate::R<INT_FG_SPEC>;
        ///Register `INT_FG` writer
        pub type W = crate::W<INT_FG_SPEC>;
        ///Field `IF_RE_TMOUT` reader - indicate when expect the response, timeout
        pub type IF_RE_TMOUT_R = crate::BitReader;
        ///Field `IF_RE_TMOUT` writer - indicate when expect the response, timeout
        pub type IF_RE_TMOUT_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `IF_RECRC_WR` reader - indicate CRC error of the response
        pub type IF_RECRC_WR_R = crate::BitReader;
        ///Field `IF_RECRC_WR` writer - indicate CRC error of the response
        pub type IF_RECRC_WR_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `IF_REIDX_ER` reader - indicate INDEX error of the response
        pub type IF_REIDX_ER_R = crate::BitReader;
        ///Field `IF_REIDX_ER` writer - indicate INDEX error of the response
        pub type IF_REIDX_ER_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `IF_CMDDONE` reader - when cmd hasn't response, indicate cmd has been sent, when cmd has a response, indicate cmd has bee sent and has received the response
        pub type IF_CMDDONE_R = crate::BitReader;
        ///Field `IF_CMDDONE` writer - when cmd hasn't response, indicate cmd has been sent, when cmd has a response, indicate cmd has bee sent and has received the response
        pub type IF_CMDDONE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `IF_DATTMO` reader - data line busy timeout
        pub type IF_DATTMO_R = crate::BitReader;
        ///Field `IF_DATTMO` writer - data line busy timeout
        pub type IF_DATTMO_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `IF_TRANERR` reader - last block have encountered a CRC error
        pub type IF_TRANERR_R = crate::BitReader;
        ///Field `IF_TRANERR` writer - last block have encountered a CRC error
        pub type IF_TRANERR_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `IF_TRANDONE` reader - all the blocks have been tran/recv successfully
        pub type IF_TRANDONE_R = crate::BitReader;
        ///Field `IF_TRANDONE` writer - all the blocks have been tran/recv successfully
        pub type IF_TRANDONE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `IF_BKGAP` reader - every block gap interrupt when multiple read or write, allow drive change the DMA address at this moment
        pub type IF_BKGAP_R = crate::BitReader;
        ///Field `IF_BKGAP` writer - every block gap interrupt when multiple read or write, allow drive change the DMA address at this moment
        pub type IF_BKGAP_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `IF_FIFO_OV` reader - fifo overflow, when write sd, indicate empty overflow, when read sd, indicate full overflow
        pub type IF_FIFO_OV_R = crate::BitReader;
        ///Field `IF_FIFO_OV` writer - fifo overflow, when write sd, indicate empty overflow, when read sd, indicate full overflow
        pub type IF_FIFO_OV_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `IF_SDIOINT` reader - interrupt from SDIO card inside
        pub type IF_SDIOINT_R = crate::BitReader;
        ///Field `IF_SDIOINT` writer - interrupt from SDIO card inside
        pub type IF_SDIOINT_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - indicate when expect the response, timeout
            #[inline(always)]
            pub fn if_re_tmout(&self) -> IF_RE_TMOUT_R {
                IF_RE_TMOUT_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - indicate CRC error of the response
            #[inline(always)]
            pub fn if_recrc_wr(&self) -> IF_RECRC_WR_R {
                IF_RECRC_WR_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - indicate INDEX error of the response
            #[inline(always)]
            pub fn if_reidx_er(&self) -> IF_REIDX_ER_R {
                IF_REIDX_ER_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - when cmd hasn't response, indicate cmd has been sent, when cmd has a response, indicate cmd has bee sent and has received the response
            #[inline(always)]
            pub fn if_cmddone(&self) -> IF_CMDDONE_R {
                IF_CMDDONE_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - data line busy timeout
            #[inline(always)]
            pub fn if_dattmo(&self) -> IF_DATTMO_R {
                IF_DATTMO_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - last block have encountered a CRC error
            #[inline(always)]
            pub fn if_tranerr(&self) -> IF_TRANERR_R {
                IF_TRANERR_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - all the blocks have been tran/recv successfully
            #[inline(always)]
            pub fn if_trandone(&self) -> IF_TRANDONE_R {
                IF_TRANDONE_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - every block gap interrupt when multiple read or write, allow drive change the DMA address at this moment
            #[inline(always)]
            pub fn if_bkgap(&self) -> IF_BKGAP_R {
                IF_BKGAP_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bit 8 - fifo overflow, when write sd, indicate empty overflow, when read sd, indicate full overflow
            #[inline(always)]
            pub fn if_fifo_ov(&self) -> IF_FIFO_OV_R {
                IF_FIFO_OV_R::new(((self.bits >> 8) & 1) != 0)
            }
            ///Bit 9 - interrupt from SDIO card inside
            #[inline(always)]
            pub fn if_sdioint(&self) -> IF_SDIOINT_R {
                IF_SDIOINT_R::new(((self.bits >> 9) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - indicate when expect the response, timeout
            #[inline(always)]
            #[must_use]
            pub fn if_re_tmout(&mut self) -> IF_RE_TMOUT_W<INT_FG_SPEC> {
                IF_RE_TMOUT_W::new(self, 0)
            }
            ///Bit 1 - indicate CRC error of the response
            #[inline(always)]
            #[must_use]
            pub fn if_recrc_wr(&mut self) -> IF_RECRC_WR_W<INT_FG_SPEC> {
                IF_RECRC_WR_W::new(self, 1)
            }
            ///Bit 2 - indicate INDEX error of the response
            #[inline(always)]
            #[must_use]
            pub fn if_reidx_er(&mut self) -> IF_REIDX_ER_W<INT_FG_SPEC> {
                IF_REIDX_ER_W::new(self, 2)
            }
            ///Bit 3 - when cmd hasn't response, indicate cmd has been sent, when cmd has a response, indicate cmd has bee sent and has received the response
            #[inline(always)]
            #[must_use]
            pub fn if_cmddone(&mut self) -> IF_CMDDONE_W<INT_FG_SPEC> {
                IF_CMDDONE_W::new(self, 3)
            }
            ///Bit 4 - data line busy timeout
            #[inline(always)]
            #[must_use]
            pub fn if_dattmo(&mut self) -> IF_DATTMO_W<INT_FG_SPEC> {
                IF_DATTMO_W::new(self, 4)
            }
            ///Bit 5 - last block have encountered a CRC error
            #[inline(always)]
            #[must_use]
            pub fn if_tranerr(&mut self) -> IF_TRANERR_W<INT_FG_SPEC> {
                IF_TRANERR_W::new(self, 5)
            }
            ///Bit 6 - all the blocks have been tran/recv successfully
            #[inline(always)]
            #[must_use]
            pub fn if_trandone(&mut self) -> IF_TRANDONE_W<INT_FG_SPEC> {
                IF_TRANDONE_W::new(self, 6)
            }
            ///Bit 7 - every block gap interrupt when multiple read or write, allow drive change the DMA address at this moment
            #[inline(always)]
            #[must_use]
            pub fn if_bkgap(&mut self) -> IF_BKGAP_W<INT_FG_SPEC> {
                IF_BKGAP_W::new(self, 7)
            }
            ///Bit 8 - fifo overflow, when write sd, indicate empty overflow, when read sd, indicate full overflow
            #[inline(always)]
            #[must_use]
            pub fn if_fifo_ov(&mut self) -> IF_FIFO_OV_W<INT_FG_SPEC> {
                IF_FIFO_OV_W::new(self, 8)
            }
            ///Bit 9 - interrupt from SDIO card inside
            #[inline(always)]
            #[must_use]
            pub fn if_sdioint(&mut self) -> IF_SDIOINT_W<INT_FG_SPEC> {
                IF_SDIOINT_W::new(self, 9)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///SD 16bits interrupt flag register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`int_fg::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`int_fg::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct INT_FG_SPEC;
        impl crate::RegisterSpec for INT_FG_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`int_fg::R`](R) reader structure
        impl crate::Readable for INT_FG_SPEC {}
        ///`write(|w| ..)` method takes [`int_fg::W`](W) writer structure
        impl crate::Writable for INT_FG_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets INT_FG to value 0
        impl crate::Resettable for INT_FG_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///INT_EN (rw) register accessor: SD 16bits interrupt enable register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`int_en::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`int_en::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@int_en`]
    ///module
    pub type INT_EN = crate::Reg<int_en::INT_EN_SPEC>;
    ///SD 16bits interrupt enable register
    pub mod int_en {
        ///Register `INT_EN` reader
        pub type R = crate::R<INT_EN_SPEC>;
        ///Register `INT_EN` writer
        pub type W = crate::W<INT_EN_SPEC>;
        ///Field `IE_RE_TMOUT` reader - command response timeout interrupt enable
        pub type IE_RE_TMOUT_R = crate::BitReader;
        ///Field `IE_RE_TMOUT` writer - command response timeout interrupt enable
        pub type IE_RE_TMOUT_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `IE_RECRC_WR` reader - response CRC check error interrupt enable
        pub type IE_RECRC_WR_R = crate::BitReader;
        ///Field `IE_RECRC_WR` writer - response CRC check error interrupt enable
        pub type IE_RECRC_WR_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `IE_REIDX_ER` reader - response index check error interrupt enable
        pub type IE_REIDX_ER_R = crate::BitReader;
        ///Field `IE_REIDX_ER` writer - response index check error interrupt enable
        pub type IE_REIDX_ER_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `IE_CMDDONE` reader - command completion interrupt enable
        pub type IE_CMDDONE_R = crate::BitReader;
        ///Field `IE_CMDDONE` writer - command completion interrupt enable
        pub type IE_CMDDONE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `IE_DATTMO` reader - data timeout interrupt enable
        pub type IE_DATTMO_R = crate::BitReader;
        ///Field `IE_DATTMO` writer - data timeout interrupt enable
        pub type IE_DATTMO_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `IE_TRANERR` reader - blocks transfer CRC error interrupt enable
        pub type IE_TRANERR_R = crate::BitReader;
        ///Field `IE_TRANERR` writer - blocks transfer CRC error interrupt enable
        pub type IE_TRANERR_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `IE_TRANDONE` reader - all blocks transfer complete interrupt enable
        pub type IE_TRANDONE_R = crate::BitReader;
        ///Field `IE_TRANDONE` writer - all blocks transfer complete interrupt enable
        pub type IE_TRANDONE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `IE_BKGAP` reader - single block transmission completion interrupt enable
        pub type IE_BKGAP_R = crate::BitReader;
        ///Field `IE_BKGAP` writer - single block transmission completion interrupt enable
        pub type IE_BKGAP_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `IE_FIFO_OV` reader - FIFO overflow interrupt enable
        pub type IE_FIFO_OV_R = crate::BitReader;
        ///Field `IE_FIFO_OV` writer - FIFO overflow interrupt enable
        pub type IE_FIFO_OV_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `IE_SDIOINT` reader - SDIO card interrupt enable
        pub type IE_SDIOINT_R = crate::BitReader;
        ///Field `IE_SDIOINT` writer - SDIO card interrupt enable
        pub type IE_SDIOINT_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - command response timeout interrupt enable
            #[inline(always)]
            pub fn ie_re_tmout(&self) -> IE_RE_TMOUT_R {
                IE_RE_TMOUT_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - response CRC check error interrupt enable
            #[inline(always)]
            pub fn ie_recrc_wr(&self) -> IE_RECRC_WR_R {
                IE_RECRC_WR_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - response index check error interrupt enable
            #[inline(always)]
            pub fn ie_reidx_er(&self) -> IE_REIDX_ER_R {
                IE_REIDX_ER_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - command completion interrupt enable
            #[inline(always)]
            pub fn ie_cmddone(&self) -> IE_CMDDONE_R {
                IE_CMDDONE_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - data timeout interrupt enable
            #[inline(always)]
            pub fn ie_dattmo(&self) -> IE_DATTMO_R {
                IE_DATTMO_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - blocks transfer CRC error interrupt enable
            #[inline(always)]
            pub fn ie_tranerr(&self) -> IE_TRANERR_R {
                IE_TRANERR_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - all blocks transfer complete interrupt enable
            #[inline(always)]
            pub fn ie_trandone(&self) -> IE_TRANDONE_R {
                IE_TRANDONE_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - single block transmission completion interrupt enable
            #[inline(always)]
            pub fn ie_bkgap(&self) -> IE_BKGAP_R {
                IE_BKGAP_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bit 8 - FIFO overflow interrupt enable
            #[inline(always)]
            pub fn ie_fifo_ov(&self) -> IE_FIFO_OV_R {
                IE_FIFO_OV_R::new(((self.bits >> 8) & 1) != 0)
            }
            ///Bit 9 - SDIO card interrupt enable
            #[inline(always)]
            pub fn ie_sdioint(&self) -> IE_SDIOINT_R {
                IE_SDIOINT_R::new(((self.bits >> 9) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - command response timeout interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn ie_re_tmout(&mut self) -> IE_RE_TMOUT_W<INT_EN_SPEC> {
                IE_RE_TMOUT_W::new(self, 0)
            }
            ///Bit 1 - response CRC check error interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn ie_recrc_wr(&mut self) -> IE_RECRC_WR_W<INT_EN_SPEC> {
                IE_RECRC_WR_W::new(self, 1)
            }
            ///Bit 2 - response index check error interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn ie_reidx_er(&mut self) -> IE_REIDX_ER_W<INT_EN_SPEC> {
                IE_REIDX_ER_W::new(self, 2)
            }
            ///Bit 3 - command completion interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn ie_cmddone(&mut self) -> IE_CMDDONE_W<INT_EN_SPEC> {
                IE_CMDDONE_W::new(self, 3)
            }
            ///Bit 4 - data timeout interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn ie_dattmo(&mut self) -> IE_DATTMO_W<INT_EN_SPEC> {
                IE_DATTMO_W::new(self, 4)
            }
            ///Bit 5 - blocks transfer CRC error interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn ie_tranerr(&mut self) -> IE_TRANERR_W<INT_EN_SPEC> {
                IE_TRANERR_W::new(self, 5)
            }
            ///Bit 6 - all blocks transfer complete interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn ie_trandone(&mut self) -> IE_TRANDONE_W<INT_EN_SPEC> {
                IE_TRANDONE_W::new(self, 6)
            }
            ///Bit 7 - single block transmission completion interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn ie_bkgap(&mut self) -> IE_BKGAP_W<INT_EN_SPEC> {
                IE_BKGAP_W::new(self, 7)
            }
            ///Bit 8 - FIFO overflow interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn ie_fifo_ov(&mut self) -> IE_FIFO_OV_W<INT_EN_SPEC> {
                IE_FIFO_OV_W::new(self, 8)
            }
            ///Bit 9 - SDIO card interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn ie_sdioint(&mut self) -> IE_SDIOINT_W<INT_EN_SPEC> {
                IE_SDIOINT_W::new(self, 9)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///SD 16bits interrupt enable register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`int_en::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`int_en::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct INT_EN_SPEC;
        impl crate::RegisterSpec for INT_EN_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`int_en::R`](R) reader structure
        impl crate::Readable for INT_EN_SPEC {}
        ///`write(|w| ..)` method takes [`int_en::W`](W) writer structure
        impl crate::Writable for INT_EN_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets INT_EN to value 0
        impl crate::Resettable for INT_EN_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///DMA_BEG1 (rw) register accessor: SD 16bits DMA start address register when to operate
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`dma_beg1::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dma_beg1::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@dma_beg1`]
    ///module
    pub type DMA_BEG1 = crate::Reg<dma_beg1::DMA_BEG1_SPEC>;
    ///SD 16bits DMA start address register when to operate
    pub mod dma_beg1 {
        ///Register `DMA_BEG1` reader
        pub type R = crate::R<DMA_BEG1_SPEC>;
        ///Register `DMA_BEG1` writer
        pub type W = crate::W<DMA_BEG1_SPEC>;
        ///Field `DMAAD1_MASK` reader - start address of read-write data buffer,the lower 4 bits are fixed to 0
        pub type DMAAD1_MASK_R = crate::FieldReader<u32>;
        ///Field `DMAAD1_MASK` writer - start address of read-write data buffer,the lower 4 bits are fixed to 0
        pub type DMAAD1_MASK_W<'a, REG> = crate::FieldWriter<'a, REG, 17, u32>;
        impl R {
            ///Bits 0:16 - start address of read-write data buffer,the lower 4 bits are fixed to 0
            #[inline(always)]
            pub fn dmaad1_mask(&self) -> DMAAD1_MASK_R {
                DMAAD1_MASK_R::new(self.bits & 0x0001_ffff)
            }
        }
        impl W {
            ///Bits 0:16 - start address of read-write data buffer,the lower 4 bits are fixed to 0
            #[inline(always)]
            #[must_use]
            pub fn dmaad1_mask(&mut self) -> DMAAD1_MASK_W<DMA_BEG1_SPEC> {
                DMAAD1_MASK_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///SD 16bits DMA start address register when to operate
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`dma_beg1::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dma_beg1::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct DMA_BEG1_SPEC;
        impl crate::RegisterSpec for DMA_BEG1_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`dma_beg1::R`](R) reader structure
        impl crate::Readable for DMA_BEG1_SPEC {}
        ///`write(|w| ..)` method takes [`dma_beg1::W`](W) writer structure
        impl crate::Writable for DMA_BEG1_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets DMA_BEG1 to value 0
        impl crate::Resettable for DMA_BEG1_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///BLOCK_CFG (rw) register accessor: SD 32bits data counter, \[15:0\]
    ///number of blocks this time will tran/recv, \[27:16\]
    ///block sise(byte number) of every block in this time tran/recv
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`block_cfg::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`block_cfg::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@block_cfg`]
    ///module
    pub type BLOCK_CFG = crate::Reg<block_cfg::BLOCK_CFG_SPEC>;
    ///SD 32bits data counter, \[15:0\]
    ///number of blocks this time will tran/recv, \[27:16\]
    ///block sise(byte number) of every block in this time tran/recv
    pub mod block_cfg {
        ///Register `BLOCK_CFG` reader
        pub type R = crate::R<BLOCK_CFG_SPEC>;
        ///Register `BLOCK_CFG` writer
        pub type W = crate::W<BLOCK_CFG_SPEC>;
        ///Field `BKNUM_MASK` reader - the number of blocks to be transferred
        pub type BKNUM_MASK_R = crate::FieldReader<u16>;
        ///Field `BKNUM_MASK` writer - the number of blocks to be transferred
        pub type BKNUM_MASK_W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        ///Field `BKSIZE_MASK` reader - single block transfer size
        pub type BKSIZE_MASK_R = crate::FieldReader<u16>;
        ///Field `BKSIZE_MASK` writer - single block transfer size
        pub type BKSIZE_MASK_W<'a, REG> = crate::FieldWriter<'a, REG, 12, u16>;
        impl R {
            ///Bits 0:15 - the number of blocks to be transferred
            #[inline(always)]
            pub fn bknum_mask(&self) -> BKNUM_MASK_R {
                BKNUM_MASK_R::new((self.bits & 0xffff) as u16)
            }
            ///Bits 16:27 - single block transfer size
            #[inline(always)]
            pub fn bksize_mask(&self) -> BKSIZE_MASK_R {
                BKSIZE_MASK_R::new(((self.bits >> 16) & 0x0fff) as u16)
            }
        }
        impl W {
            ///Bits 0:15 - the number of blocks to be transferred
            #[inline(always)]
            #[must_use]
            pub fn bknum_mask(&mut self) -> BKNUM_MASK_W<BLOCK_CFG_SPEC> {
                BKNUM_MASK_W::new(self, 0)
            }
            ///Bits 16:27 - single block transfer size
            #[inline(always)]
            #[must_use]
            pub fn bksize_mask(&mut self) -> BKSIZE_MASK_W<BLOCK_CFG_SPEC> {
                BKSIZE_MASK_W::new(self, 16)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///SD 32bits data counter, \[15:0\]
        ///number of blocks this time will tran/recv, \[27:16\]
        ///block sise(byte number) of every block in this time tran/recv
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`block_cfg::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`block_cfg::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct BLOCK_CFG_SPEC;
        impl crate::RegisterSpec for BLOCK_CFG_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`block_cfg::R`](R) reader structure
        impl crate::Readable for BLOCK_CFG_SPEC {}
        ///`write(|w| ..)` method takes [`block_cfg::W`](W) writer structure
        impl crate::Writable for BLOCK_CFG_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets BLOCK_CFG to value 0
        impl crate::Resettable for BLOCK_CFG_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///TRAN_MODE (rw) register accessor: SD TRANSFER MODE register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`tran_mode::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`tran_mode::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@tran_mode`]
    ///module
    pub type TRAN_MODE = crate::Reg<tran_mode::TRAN_MODE_SPEC>;
    ///SD TRANSFER MODE register
    pub mod tran_mode {
        ///Register `TRAN_MODE` reader
        pub type R = crate::R<TRAN_MODE_SPEC>;
        ///Register `TRAN_MODE` writer
        pub type W = crate::W<TRAN_MODE_SPEC>;
        ///Field `DMA_DIR` reader - set DMA direction is controller to emmc card
        pub type DMA_DIR_R = crate::BitReader;
        ///Field `DMA_DIR` writer - set DMA direction is controller to emmc card
        pub type DMA_DIR_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `GAP_STOP` reader - clock stop mode after block completion
        pub type GAP_STOP_R = crate::BitReader;
        ///Field `GAP_STOP` writer - clock stop mode after block completion
        pub type GAP_STOP_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `MODE_BOOT` reader - enable emmc boot mode
        pub type MODE_BOOT_R = crate::BitReader;
        ///Field `MODE_BOOT` writer - enable emmc boot mode
        pub type MODE_BOOT_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `AUTOGAPSTOP` reader - enable auto set bTM_GAP_STOP when tran start
        pub type AUTOGAPSTOP_R = crate::BitReader;
        ///Field `AUTOGAPSTOP` writer - enable auto set bTM_GAP_STOP when tran start
        pub type AUTOGAPSTOP_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FIFO_RDY` reader - FIFO ready select signal when writing EMMC
        pub type FIFO_RDY_R = crate::FieldReader;
        ///Field `FIFO_RDY` writer - FIFO ready select signal when writing EMMC
        pub type FIFO_RDY_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `DMATN_CNT` reader - in double buffer mode,set the block count value of buffer switch
        pub type DMATN_CNT_R = crate::FieldReader;
        ///Field `DMATN_CNT` writer - in double buffer mode,set the block count value of buffer switch
        pub type DMATN_CNT_W<'a, REG> = crate::FieldWriter<'a, REG, 7>;
        ///Field `DULEDMA_EN` reader - enable double buffer dma
        pub type DULEDMA_EN_R = crate::BitReader;
        ///Field `DULEDMA_EN` writer - enable double buffer dma
        pub type DULEDMA_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - set DMA direction is controller to emmc card
            #[inline(always)]
            pub fn dma_dir(&self) -> DMA_DIR_R {
                DMA_DIR_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - clock stop mode after block completion
            #[inline(always)]
            pub fn gap_stop(&self) -> GAP_STOP_R {
                GAP_STOP_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - enable emmc boot mode
            #[inline(always)]
            pub fn mode_boot(&self) -> MODE_BOOT_R {
                MODE_BOOT_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 4 - enable auto set bTM_GAP_STOP when tran start
            #[inline(always)]
            pub fn autogapstop(&self) -> AUTOGAPSTOP_R {
                AUTOGAPSTOP_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bits 6:7 - FIFO ready select signal when writing EMMC
            #[inline(always)]
            pub fn fifo_rdy(&self) -> FIFO_RDY_R {
                FIFO_RDY_R::new(((self.bits >> 6) & 3) as u8)
            }
            ///Bits 8:14 - in double buffer mode,set the block count value of buffer switch
            #[inline(always)]
            pub fn dmatn_cnt(&self) -> DMATN_CNT_R {
                DMATN_CNT_R::new(((self.bits >> 8) & 0x7f) as u8)
            }
            ///Bit 16 - enable double buffer dma
            #[inline(always)]
            pub fn duledma_en(&self) -> DULEDMA_EN_R {
                DULEDMA_EN_R::new(((self.bits >> 16) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - set DMA direction is controller to emmc card
            #[inline(always)]
            #[must_use]
            pub fn dma_dir(&mut self) -> DMA_DIR_W<TRAN_MODE_SPEC> {
                DMA_DIR_W::new(self, 0)
            }
            ///Bit 1 - clock stop mode after block completion
            #[inline(always)]
            #[must_use]
            pub fn gap_stop(&mut self) -> GAP_STOP_W<TRAN_MODE_SPEC> {
                GAP_STOP_W::new(self, 1)
            }
            ///Bit 2 - enable emmc boot mode
            #[inline(always)]
            #[must_use]
            pub fn mode_boot(&mut self) -> MODE_BOOT_W<TRAN_MODE_SPEC> {
                MODE_BOOT_W::new(self, 2)
            }
            ///Bit 4 - enable auto set bTM_GAP_STOP when tran start
            #[inline(always)]
            #[must_use]
            pub fn autogapstop(&mut self) -> AUTOGAPSTOP_W<TRAN_MODE_SPEC> {
                AUTOGAPSTOP_W::new(self, 4)
            }
            ///Bits 6:7 - FIFO ready select signal when writing EMMC
            #[inline(always)]
            #[must_use]
            pub fn fifo_rdy(&mut self) -> FIFO_RDY_W<TRAN_MODE_SPEC> {
                FIFO_RDY_W::new(self, 6)
            }
            ///Bits 8:14 - in double buffer mode,set the block count value of buffer switch
            #[inline(always)]
            #[must_use]
            pub fn dmatn_cnt(&mut self) -> DMATN_CNT_W<TRAN_MODE_SPEC> {
                DMATN_CNT_W::new(self, 8)
            }
            ///Bit 16 - enable double buffer dma
            #[inline(always)]
            #[must_use]
            pub fn duledma_en(&mut self) -> DULEDMA_EN_W<TRAN_MODE_SPEC> {
                DULEDMA_EN_W::new(self, 16)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///SD TRANSFER MODE register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`tran_mode::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`tran_mode::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct TRAN_MODE_SPEC;
        impl crate::RegisterSpec for TRAN_MODE_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`tran_mode::R`](R) reader structure
        impl crate::Readable for TRAN_MODE_SPEC {}
        ///`write(|w| ..)` method takes [`tran_mode::W`](W) writer structure
        impl crate::Writable for TRAN_MODE_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets TRAN_MODE to value 0
        impl crate::Resettable for TRAN_MODE_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///DMA_BEG2 (rw) register accessor: SD 16bits DMA start address register when to operate
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`dma_beg2::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dma_beg2::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@dma_beg2`]
    ///module
    pub type DMA_BEG2 = crate::Reg<dma_beg2::DMA_BEG2_SPEC>;
    ///SD 16bits DMA start address register when to operate
    pub mod dma_beg2 {
        ///Register `DMA_BEG2` reader
        pub type R = crate::R<DMA_BEG2_SPEC>;
        ///Register `DMA_BEG2` writer
        pub type W = crate::W<DMA_BEG2_SPEC>;
        ///Field `DMAAD2_MASK` reader - block DMA start address register
        pub type DMAAD2_MASK_R = crate::FieldReader<u32>;
        ///Field `DMAAD2_MASK` writer - block DMA start address register
        pub type DMAAD2_MASK_W<'a, REG> = crate::FieldWriter<'a, REG, 17, u32>;
        impl R {
            ///Bits 0:16 - block DMA start address register
            #[inline(always)]
            pub fn dmaad2_mask(&self) -> DMAAD2_MASK_R {
                DMAAD2_MASK_R::new(self.bits & 0x0001_ffff)
            }
        }
        impl W {
            ///Bits 0:16 - block DMA start address register
            #[inline(always)]
            #[must_use]
            pub fn dmaad2_mask(&mut self) -> DMAAD2_MASK_W<DMA_BEG2_SPEC> {
                DMAAD2_MASK_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///SD 16bits DMA start address register when to operate
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`dma_beg2::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dma_beg2::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct DMA_BEG2_SPEC;
        impl crate::RegisterSpec for DMA_BEG2_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`dma_beg2::R`](R) reader structure
        impl crate::Readable for DMA_BEG2_SPEC {}
        ///`write(|w| ..)` method takes [`dma_beg2::W`](W) writer structure
        impl crate::Writable for DMA_BEG2_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets DMA_BEG2 to value 0
        impl crate::Resettable for DMA_BEG2_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
}
///GPIO
pub struct GPIO {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for GPIO {}
impl GPIO {
    ///Pointer to the register block
    pub const PTR: *const gpio::RegisterBlock = 0x4000_1000 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const gpio::RegisterBlock {
        Self::PTR
    }
    /// Steal an instance of this peripheral
    ///
    /// # Safety
    ///
    /// Ensure that the new instance of the peripheral cannot be used in a way
    /// that may race with any existing instances, for example by only
    /// accessing read-only or write-only registers, or by consuming the
    /// original peripheral and using critical sections to coordinate
    /// access between multiple new instances.
    ///
    /// Additionally, other software such as HALs may rely on only one
    /// peripheral instance existing to ensure memory safety; ensure
    /// no stolen instances are passed to such software.
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for GPIO {
    type Target = gpio::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for GPIO {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GPIO").finish()
    }
}
///GPIO
pub mod gpio {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        _reserved0: [u8; 0x12],
        pin_alternate: PIN_ALTERNATE,
        _reserved1: [u8; 0x09],
        int_flag: INT_FLAG,
        int_enable: INT_ENABLE,
        int_mode: INT_MODE,
        int_polar: INT_POLAR,
        _reserved5: [u8; 0x20],
        pa_dir: PA_DIR,
        pa_pin: PA_PIN,
        pa_out: PA_OUT,
        pa_clr: PA_CLR,
        pa_pu: PA_PU,
        pa_pd: PA_PD,
        pa_drv: PA_DRV,
        pa_smt: PA_SMT,
        pb_dir: PB_DIR,
        pb_pin: PB_PIN,
        pb_out: PB_OUT,
        pb_clr: PB_CLR,
        pb_pu: PB_PU,
        pb_pd: PB_PD,
        pb_drv: PB_DRV,
        pb_smt: PB_SMT,
    }
    impl RegisterBlock {
        ///0x12 - GPIO pin alternate function
        #[inline(always)]
        pub const fn pin_alternate(&self) -> &PIN_ALTERNATE {
            &self.pin_alternate
        }
        ///0x1c - GPIO interrupt flag
        #[inline(always)]
        pub const fn int_flag(&self) -> &INT_FLAG {
            &self.int_flag
        }
        ///0x1d - GPIO interrupt enable
        #[inline(always)]
        pub const fn int_enable(&self) -> &INT_ENABLE {
            &self.int_enable
        }
        ///0x1e - GPIO interrupt mode
        #[inline(always)]
        pub const fn int_mode(&self) -> &INT_MODE {
            &self.int_mode
        }
        ///0x1f - GPIO interrupt polarity
        #[inline(always)]
        pub const fn int_polar(&self) -> &INT_POLAR {
            &self.int_polar
        }
        ///0x40 - GPIO port A direction
        #[inline(always)]
        pub const fn pa_dir(&self) -> &PA_DIR {
            &self.pa_dir
        }
        ///0x44 - GPIO port A pin input value
        #[inline(always)]
        pub const fn pa_pin(&self) -> &PA_PIN {
            &self.pa_pin
        }
        ///0x48 - GPIO port A output value
        #[inline(always)]
        pub const fn pa_out(&self) -> &PA_OUT {
            &self.pa_out
        }
        ///0x4c - GPIO port A data clear
        #[inline(always)]
        pub const fn pa_clr(&self) -> &PA_CLR {
            &self.pa_clr
        }
        ///0x50 - GPIO port A pull-up enable
        #[inline(always)]
        pub const fn pa_pu(&self) -> &PA_PU {
            &self.pa_pu
        }
        ///0x54 - GPIO port A pull-down enable
        #[inline(always)]
        pub const fn pa_pd(&self) -> &PA_PD {
            &self.pa_pd
        }
        ///0x58 - GPIO port A drive capability
        #[inline(always)]
        pub const fn pa_drv(&self) -> &PA_DRV {
            &self.pa_drv
        }
        ///0x5c - GPIO port A Schmitt trigger enable
        #[inline(always)]
        pub const fn pa_smt(&self) -> &PA_SMT {
            &self.pa_smt
        }
        ///0x60 - GPIO port B direction
        #[inline(always)]
        pub const fn pb_dir(&self) -> &PB_DIR {
            &self.pb_dir
        }
        ///0x64 - GPIO port B pin input value
        #[inline(always)]
        pub const fn pb_pin(&self) -> &PB_PIN {
            &self.pb_pin
        }
        ///0x68 - GPIO port B output value
        #[inline(always)]
        pub const fn pb_out(&self) -> &PB_OUT {
            &self.pb_out
        }
        ///0x6c - GPIO port B data clear
        #[inline(always)]
        pub const fn pb_clr(&self) -> &PB_CLR {
            &self.pb_clr
        }
        ///0x70 - GPIO port B pull-up enable
        #[inline(always)]
        pub const fn pb_pu(&self) -> &PB_PU {
            &self.pb_pu
        }
        ///0x74 - GPIO port B pull-down enable
        #[inline(always)]
        pub const fn pb_pd(&self) -> &PB_PD {
            &self.pb_pd
        }
        ///0x78 - GPIO port B drive capability
        #[inline(always)]
        pub const fn pb_drv(&self) -> &PB_DRV {
            &self.pb_drv
        }
        ///0x7c - GPIO port B Schmitt trigger enable
        #[inline(always)]
        pub const fn pb_smt(&self) -> &PB_SMT {
            &self.pb_smt
        }
    }
    ///INT_FLAG (rw) register accessor: GPIO interrupt flag
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`int_flag::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`int_flag::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@int_flag`]
    ///module
    pub type INT_FLAG = crate::Reg<int_flag::INT_FLAG_SPEC>;
    ///GPIO interrupt flag
    pub mod int_flag {
        ///Register `INT_FLAG` reader
        pub type R = crate::R<INT_FLAG_SPEC>;
        ///Register `INT_FLAG` writer
        pub type W = crate::W<INT_FLAG_SPEC>;
        ///Field `PA2_IF` reader - PA2 interrupt flag
        pub type PA2_IF_R = crate::BitReader;
        ///Field `PA2_IF` writer - PA2 interrupt flag
        pub type PA2_IF_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PA3_IF` reader - PA3 interrupt flag
        pub type PA3_IF_R = crate::BitReader;
        ///Field `PA3_IF` writer - PA3 interrupt flag
        pub type PA3_IF_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PA4_IF` reader - PA4 interrupt flag
        pub type PA4_IF_R = crate::BitReader;
        ///Field `PA4_IF` writer - PA4 interrupt flag
        pub type PA4_IF_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PB3_IF` reader - PB3 interrupt flag
        pub type PB3_IF_R = crate::BitReader;
        ///Field `PB3_IF` writer - PB3 interrupt flag
        pub type PB3_IF_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PB4_IF` reader - PB4 interrupt flag
        pub type PB4_IF_R = crate::BitReader;
        ///Field `PB4_IF` writer - PB4 interrupt flag
        pub type PB4_IF_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PB11_IF` reader - PB11 interrupt flag
        pub type PB11_IF_R = crate::BitReader;
        ///Field `PB11_IF` writer - PB11 interrupt flag
        pub type PB11_IF_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PB12_IF` reader - PB12 interrupt flag
        pub type PB12_IF_R = crate::BitReader;
        ///Field `PB12_IF` writer - PB12 interrupt flag
        pub type PB12_IF_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PB15_IF` reader - PB15 interrupt flag
        pub type PB15_IF_R = crate::BitReader;
        ///Field `PB15_IF` writer - PB15 interrupt flag
        pub type PB15_IF_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - PA2 interrupt flag
            #[inline(always)]
            pub fn pa2_if(&self) -> PA2_IF_R {
                PA2_IF_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - PA3 interrupt flag
            #[inline(always)]
            pub fn pa3_if(&self) -> PA3_IF_R {
                PA3_IF_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - PA4 interrupt flag
            #[inline(always)]
            pub fn pa4_if(&self) -> PA4_IF_R {
                PA4_IF_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - PB3 interrupt flag
            #[inline(always)]
            pub fn pb3_if(&self) -> PB3_IF_R {
                PB3_IF_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - PB4 interrupt flag
            #[inline(always)]
            pub fn pb4_if(&self) -> PB4_IF_R {
                PB4_IF_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - PB11 interrupt flag
            #[inline(always)]
            pub fn pb11_if(&self) -> PB11_IF_R {
                PB11_IF_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - PB12 interrupt flag
            #[inline(always)]
            pub fn pb12_if(&self) -> PB12_IF_R {
                PB12_IF_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - PB15 interrupt flag
            #[inline(always)]
            pub fn pb15_if(&self) -> PB15_IF_R {
                PB15_IF_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - PA2 interrupt flag
            #[inline(always)]
            #[must_use]
            pub fn pa2_if(&mut self) -> PA2_IF_W<INT_FLAG_SPEC> {
                PA2_IF_W::new(self, 0)
            }
            ///Bit 1 - PA3 interrupt flag
            #[inline(always)]
            #[must_use]
            pub fn pa3_if(&mut self) -> PA3_IF_W<INT_FLAG_SPEC> {
                PA3_IF_W::new(self, 1)
            }
            ///Bit 2 - PA4 interrupt flag
            #[inline(always)]
            #[must_use]
            pub fn pa4_if(&mut self) -> PA4_IF_W<INT_FLAG_SPEC> {
                PA4_IF_W::new(self, 2)
            }
            ///Bit 3 - PB3 interrupt flag
            #[inline(always)]
            #[must_use]
            pub fn pb3_if(&mut self) -> PB3_IF_W<INT_FLAG_SPEC> {
                PB3_IF_W::new(self, 3)
            }
            ///Bit 4 - PB4 interrupt flag
            #[inline(always)]
            #[must_use]
            pub fn pb4_if(&mut self) -> PB4_IF_W<INT_FLAG_SPEC> {
                PB4_IF_W::new(self, 4)
            }
            ///Bit 5 - PB11 interrupt flag
            #[inline(always)]
            #[must_use]
            pub fn pb11_if(&mut self) -> PB11_IF_W<INT_FLAG_SPEC> {
                PB11_IF_W::new(self, 5)
            }
            ///Bit 6 - PB12 interrupt flag
            #[inline(always)]
            #[must_use]
            pub fn pb12_if(&mut self) -> PB12_IF_W<INT_FLAG_SPEC> {
                PB12_IF_W::new(self, 6)
            }
            ///Bit 7 - PB15 interrupt flag
            #[inline(always)]
            #[must_use]
            pub fn pb15_if(&mut self) -> PB15_IF_W<INT_FLAG_SPEC> {
                PB15_IF_W::new(self, 7)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///GPIO interrupt flag
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`int_flag::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`int_flag::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct INT_FLAG_SPEC;
        impl crate::RegisterSpec for INT_FLAG_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`int_flag::R`](R) reader structure
        impl crate::Readable for INT_FLAG_SPEC {}
        ///`write(|w| ..)` method takes [`int_flag::W`](W) writer structure
        impl crate::Writable for INT_FLAG_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets INT_FLAG to value 0
        impl crate::Resettable for INT_FLAG_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///INT_ENABLE (rw) register accessor: GPIO interrupt enable
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`int_enable::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`int_enable::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@int_enable`]
    ///module
    pub type INT_ENABLE = crate::Reg<int_enable::INT_ENABLE_SPEC>;
    ///GPIO interrupt enable
    pub mod int_enable {
        ///Register `INT_ENABLE` reader
        pub type R = crate::R<INT_ENABLE_SPEC>;
        ///Register `INT_ENABLE` writer
        pub type W = crate::W<INT_ENABLE_SPEC>;
        ///Field `PA2_IE` reader - PA2 interrupt enable flag
        pub type PA2_IE_R = crate::BitReader;
        ///Field `PA2_IE` writer - PA2 interrupt enable flag
        pub type PA2_IE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PA3_IE` reader - PA3 interrupt enable flag
        pub type PA3_IE_R = crate::BitReader;
        ///Field `PA3_IE` writer - PA3 interrupt enable flag
        pub type PA3_IE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PA4_IE` reader - PA4 interrupt enable flag
        pub type PA4_IE_R = crate::BitReader;
        ///Field `PA4_IE` writer - PA4 interrupt enable flag
        pub type PA4_IE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PB3_IE` reader - PB3 interrupt enable flag
        pub type PB3_IE_R = crate::BitReader;
        ///Field `PB3_IE` writer - PB3 interrupt enable flag
        pub type PB3_IE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PB4_IE` reader - PB4 interrupt enable flag
        pub type PB4_IE_R = crate::BitReader;
        ///Field `PB4_IE` writer - PB4 interrupt enable flag
        pub type PB4_IE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PB11_IE` reader - PB11 interrupt enable flag
        pub type PB11_IE_R = crate::BitReader;
        ///Field `PB11_IE` writer - PB11 interrupt enable flag
        pub type PB11_IE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PB12_IE` reader - PB12 interrupt enable flag
        pub type PB12_IE_R = crate::BitReader;
        ///Field `PB12_IE` writer - PB12 interrupt enable flag
        pub type PB12_IE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PB15_IE` reader - PB15 interrupt enable flag
        pub type PB15_IE_R = crate::BitReader;
        ///Field `PB15_IE` writer - PB15 interrupt enable flag
        pub type PB15_IE_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - PA2 interrupt enable flag
            #[inline(always)]
            pub fn pa2_ie(&self) -> PA2_IE_R {
                PA2_IE_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - PA3 interrupt enable flag
            #[inline(always)]
            pub fn pa3_ie(&self) -> PA3_IE_R {
                PA3_IE_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - PA4 interrupt enable flag
            #[inline(always)]
            pub fn pa4_ie(&self) -> PA4_IE_R {
                PA4_IE_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - PB3 interrupt enable flag
            #[inline(always)]
            pub fn pb3_ie(&self) -> PB3_IE_R {
                PB3_IE_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - PB4 interrupt enable flag
            #[inline(always)]
            pub fn pb4_ie(&self) -> PB4_IE_R {
                PB4_IE_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - PB11 interrupt enable flag
            #[inline(always)]
            pub fn pb11_ie(&self) -> PB11_IE_R {
                PB11_IE_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - PB12 interrupt enable flag
            #[inline(always)]
            pub fn pb12_ie(&self) -> PB12_IE_R {
                PB12_IE_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - PB15 interrupt enable flag
            #[inline(always)]
            pub fn pb15_ie(&self) -> PB15_IE_R {
                PB15_IE_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - PA2 interrupt enable flag
            #[inline(always)]
            #[must_use]
            pub fn pa2_ie(&mut self) -> PA2_IE_W<INT_ENABLE_SPEC> {
                PA2_IE_W::new(self, 0)
            }
            ///Bit 1 - PA3 interrupt enable flag
            #[inline(always)]
            #[must_use]
            pub fn pa3_ie(&mut self) -> PA3_IE_W<INT_ENABLE_SPEC> {
                PA3_IE_W::new(self, 1)
            }
            ///Bit 2 - PA4 interrupt enable flag
            #[inline(always)]
            #[must_use]
            pub fn pa4_ie(&mut self) -> PA4_IE_W<INT_ENABLE_SPEC> {
                PA4_IE_W::new(self, 2)
            }
            ///Bit 3 - PB3 interrupt enable flag
            #[inline(always)]
            #[must_use]
            pub fn pb3_ie(&mut self) -> PB3_IE_W<INT_ENABLE_SPEC> {
                PB3_IE_W::new(self, 3)
            }
            ///Bit 4 - PB4 interrupt enable flag
            #[inline(always)]
            #[must_use]
            pub fn pb4_ie(&mut self) -> PB4_IE_W<INT_ENABLE_SPEC> {
                PB4_IE_W::new(self, 4)
            }
            ///Bit 5 - PB11 interrupt enable flag
            #[inline(always)]
            #[must_use]
            pub fn pb11_ie(&mut self) -> PB11_IE_W<INT_ENABLE_SPEC> {
                PB11_IE_W::new(self, 5)
            }
            ///Bit 6 - PB12 interrupt enable flag
            #[inline(always)]
            #[must_use]
            pub fn pb12_ie(&mut self) -> PB12_IE_W<INT_ENABLE_SPEC> {
                PB12_IE_W::new(self, 6)
            }
            ///Bit 7 - PB15 interrupt enable flag
            #[inline(always)]
            #[must_use]
            pub fn pb15_ie(&mut self) -> PB15_IE_W<INT_ENABLE_SPEC> {
                PB15_IE_W::new(self, 7)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///GPIO interrupt enable
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`int_enable::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`int_enable::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct INT_ENABLE_SPEC;
        impl crate::RegisterSpec for INT_ENABLE_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`int_enable::R`](R) reader structure
        impl crate::Readable for INT_ENABLE_SPEC {}
        ///`write(|w| ..)` method takes [`int_enable::W`](W) writer structure
        impl crate::Writable for INT_ENABLE_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets INT_ENABLE to value 0
        impl crate::Resettable for INT_ENABLE_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///INT_MODE (rw) register accessor: GPIO interrupt mode
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`int_mode::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`int_mode::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@int_mode`]
    ///module
    pub type INT_MODE = crate::Reg<int_mode::INT_MODE_SPEC>;
    ///GPIO interrupt mode
    pub mod int_mode {
        ///Register `INT_MODE` reader
        pub type R = crate::R<INT_MODE_SPEC>;
        ///Register `INT_MODE` writer
        pub type W = crate::W<INT_MODE_SPEC>;
        ///Field `PA2_IM` reader - PA2 interrupt mode selection
        pub type PA2_IM_R = crate::BitReader;
        ///Field `PA2_IM` writer - PA2 interrupt mode selection
        pub type PA2_IM_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PA3_IM` reader - PA3 interrupt mode selection
        pub type PA3_IM_R = crate::BitReader;
        ///Field `PA3_IM` writer - PA3 interrupt mode selection
        pub type PA3_IM_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PA4_IM` reader - PA4 interrupt mode selection
        pub type PA4_IM_R = crate::BitReader;
        ///Field `PA4_IM` writer - PA4 interrupt mode selection
        pub type PA4_IM_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PB3_IM` reader - PB3 interrupt mode selection
        pub type PB3_IM_R = crate::BitReader;
        ///Field `PB3_IM` writer - PB3 interrupt mode selection
        pub type PB3_IM_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PB4_IM` reader - PB4 interrupt mode selection
        pub type PB4_IM_R = crate::BitReader;
        ///Field `PB4_IM` writer - PB4 interrupt mode selection
        pub type PB4_IM_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PB11_IM` reader - PB11 interrupt mode selection
        pub type PB11_IM_R = crate::BitReader;
        ///Field `PB11_IM` writer - PB11 interrupt mode selection
        pub type PB11_IM_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PB12_IM` reader - PB12 interrupt mode selection
        pub type PB12_IM_R = crate::BitReader;
        ///Field `PB12_IM` writer - PB12 interrupt mode selection
        pub type PB12_IM_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PB15_IM` reader - PB15 interrupt mode selection
        pub type PB15_IM_R = crate::BitReader;
        ///Field `PB15_IM` writer - PB15 interrupt mode selection
        pub type PB15_IM_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - PA2 interrupt mode selection
            #[inline(always)]
            pub fn pa2_im(&self) -> PA2_IM_R {
                PA2_IM_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - PA3 interrupt mode selection
            #[inline(always)]
            pub fn pa3_im(&self) -> PA3_IM_R {
                PA3_IM_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - PA4 interrupt mode selection
            #[inline(always)]
            pub fn pa4_im(&self) -> PA4_IM_R {
                PA4_IM_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - PB3 interrupt mode selection
            #[inline(always)]
            pub fn pb3_im(&self) -> PB3_IM_R {
                PB3_IM_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - PB4 interrupt mode selection
            #[inline(always)]
            pub fn pb4_im(&self) -> PB4_IM_R {
                PB4_IM_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - PB11 interrupt mode selection
            #[inline(always)]
            pub fn pb11_im(&self) -> PB11_IM_R {
                PB11_IM_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - PB12 interrupt mode selection
            #[inline(always)]
            pub fn pb12_im(&self) -> PB12_IM_R {
                PB12_IM_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - PB15 interrupt mode selection
            #[inline(always)]
            pub fn pb15_im(&self) -> PB15_IM_R {
                PB15_IM_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - PA2 interrupt mode selection
            #[inline(always)]
            #[must_use]
            pub fn pa2_im(&mut self) -> PA2_IM_W<INT_MODE_SPEC> {
                PA2_IM_W::new(self, 0)
            }
            ///Bit 1 - PA3 interrupt mode selection
            #[inline(always)]
            #[must_use]
            pub fn pa3_im(&mut self) -> PA3_IM_W<INT_MODE_SPEC> {
                PA3_IM_W::new(self, 1)
            }
            ///Bit 2 - PA4 interrupt mode selection
            #[inline(always)]
            #[must_use]
            pub fn pa4_im(&mut self) -> PA4_IM_W<INT_MODE_SPEC> {
                PA4_IM_W::new(self, 2)
            }
            ///Bit 3 - PB3 interrupt mode selection
            #[inline(always)]
            #[must_use]
            pub fn pb3_im(&mut self) -> PB3_IM_W<INT_MODE_SPEC> {
                PB3_IM_W::new(self, 3)
            }
            ///Bit 4 - PB4 interrupt mode selection
            #[inline(always)]
            #[must_use]
            pub fn pb4_im(&mut self) -> PB4_IM_W<INT_MODE_SPEC> {
                PB4_IM_W::new(self, 4)
            }
            ///Bit 5 - PB11 interrupt mode selection
            #[inline(always)]
            #[must_use]
            pub fn pb11_im(&mut self) -> PB11_IM_W<INT_MODE_SPEC> {
                PB11_IM_W::new(self, 5)
            }
            ///Bit 6 - PB12 interrupt mode selection
            #[inline(always)]
            #[must_use]
            pub fn pb12_im(&mut self) -> PB12_IM_W<INT_MODE_SPEC> {
                PB12_IM_W::new(self, 6)
            }
            ///Bit 7 - PB15 interrupt mode selection
            #[inline(always)]
            #[must_use]
            pub fn pb15_im(&mut self) -> PB15_IM_W<INT_MODE_SPEC> {
                PB15_IM_W::new(self, 7)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///GPIO interrupt mode
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`int_mode::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`int_mode::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct INT_MODE_SPEC;
        impl crate::RegisterSpec for INT_MODE_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`int_mode::R`](R) reader structure
        impl crate::Readable for INT_MODE_SPEC {}
        ///`write(|w| ..)` method takes [`int_mode::W`](W) writer structure
        impl crate::Writable for INT_MODE_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets INT_MODE to value 0
        impl crate::Resettable for INT_MODE_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///INT_POLAR (rw) register accessor: GPIO interrupt polarity
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`int_polar::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`int_polar::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@int_polar`]
    ///module
    pub type INT_POLAR = crate::Reg<int_polar::INT_POLAR_SPEC>;
    ///GPIO interrupt polarity
    pub mod int_polar {
        ///Register `INT_POLAR` reader
        pub type R = crate::R<INT_POLAR_SPEC>;
        ///Register `INT_POLAR` writer
        pub type W = crate::W<INT_POLAR_SPEC>;
        ///Field `PA2_IP` reader - PA2 interrupt polar selection
        pub type PA2_IP_R = crate::BitReader;
        ///Field `PA2_IP` writer - PA2 interrupt polar selection
        pub type PA2_IP_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PA3_IP` reader - PA3 interrupt polar selection
        pub type PA3_IP_R = crate::BitReader;
        ///Field `PA3_IP` writer - PA3 interrupt polar selection
        pub type PA3_IP_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PA4_IP` reader - PA4 interrupt polar selection
        pub type PA4_IP_R = crate::BitReader;
        ///Field `PA4_IP` writer - PA4 interrupt polar selection
        pub type PA4_IP_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PB3_IP` reader - PB3 interrupt polar selection
        pub type PB3_IP_R = crate::BitReader;
        ///Field `PB3_IP` writer - PB3 interrupt polar selection
        pub type PB3_IP_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PB4_IP` reader - PB4 interrupt polar selection
        pub type PB4_IP_R = crate::BitReader;
        ///Field `PB4_IP` writer - PB4 interrupt polar selection
        pub type PB4_IP_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PB11_IP` reader - PB11 interrupt polar selection
        pub type PB11_IP_R = crate::BitReader;
        ///Field `PB11_IP` writer - PB11 interrupt polar selection
        pub type PB11_IP_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PB12_IP` reader - PB12 interrupt polar selection
        pub type PB12_IP_R = crate::BitReader;
        ///Field `PB12_IP` writer - PB12 interrupt polar selection
        pub type PB12_IP_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PB15_IP` reader - PB15 interrupt polar selection
        pub type PB15_IP_R = crate::BitReader;
        ///Field `PB15_IP` writer - PB15 interrupt polar selection
        pub type PB15_IP_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - PA2 interrupt polar selection
            #[inline(always)]
            pub fn pa2_ip(&self) -> PA2_IP_R {
                PA2_IP_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - PA3 interrupt polar selection
            #[inline(always)]
            pub fn pa3_ip(&self) -> PA3_IP_R {
                PA3_IP_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - PA4 interrupt polar selection
            #[inline(always)]
            pub fn pa4_ip(&self) -> PA4_IP_R {
                PA4_IP_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - PB3 interrupt polar selection
            #[inline(always)]
            pub fn pb3_ip(&self) -> PB3_IP_R {
                PB3_IP_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - PB4 interrupt polar selection
            #[inline(always)]
            pub fn pb4_ip(&self) -> PB4_IP_R {
                PB4_IP_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - PB11 interrupt polar selection
            #[inline(always)]
            pub fn pb11_ip(&self) -> PB11_IP_R {
                PB11_IP_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - PB12 interrupt polar selection
            #[inline(always)]
            pub fn pb12_ip(&self) -> PB12_IP_R {
                PB12_IP_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - PB15 interrupt polar selection
            #[inline(always)]
            pub fn pb15_ip(&self) -> PB15_IP_R {
                PB15_IP_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - PA2 interrupt polar selection
            #[inline(always)]
            #[must_use]
            pub fn pa2_ip(&mut self) -> PA2_IP_W<INT_POLAR_SPEC> {
                PA2_IP_W::new(self, 0)
            }
            ///Bit 1 - PA3 interrupt polar selection
            #[inline(always)]
            #[must_use]
            pub fn pa3_ip(&mut self) -> PA3_IP_W<INT_POLAR_SPEC> {
                PA3_IP_W::new(self, 1)
            }
            ///Bit 2 - PA4 interrupt polar selection
            #[inline(always)]
            #[must_use]
            pub fn pa4_ip(&mut self) -> PA4_IP_W<INT_POLAR_SPEC> {
                PA4_IP_W::new(self, 2)
            }
            ///Bit 3 - PB3 interrupt polar selection
            #[inline(always)]
            #[must_use]
            pub fn pb3_ip(&mut self) -> PB3_IP_W<INT_POLAR_SPEC> {
                PB3_IP_W::new(self, 3)
            }
            ///Bit 4 - PB4 interrupt polar selection
            #[inline(always)]
            #[must_use]
            pub fn pb4_ip(&mut self) -> PB4_IP_W<INT_POLAR_SPEC> {
                PB4_IP_W::new(self, 4)
            }
            ///Bit 5 - PB11 interrupt polar selection
            #[inline(always)]
            #[must_use]
            pub fn pb11_ip(&mut self) -> PB11_IP_W<INT_POLAR_SPEC> {
                PB11_IP_W::new(self, 5)
            }
            ///Bit 6 - PB12 interrupt polar selection
            #[inline(always)]
            #[must_use]
            pub fn pb12_ip(&mut self) -> PB12_IP_W<INT_POLAR_SPEC> {
                PB12_IP_W::new(self, 6)
            }
            ///Bit 7 - PB15 interrupt polar selection
            #[inline(always)]
            #[must_use]
            pub fn pb15_ip(&mut self) -> PB15_IP_W<INT_POLAR_SPEC> {
                PB15_IP_W::new(self, 7)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///GPIO interrupt polarity
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`int_polar::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`int_polar::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct INT_POLAR_SPEC;
        impl crate::RegisterSpec for INT_POLAR_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`int_polar::R`](R) reader structure
        impl crate::Readable for INT_POLAR_SPEC {}
        ///`write(|w| ..)` method takes [`int_polar::W`](W) writer structure
        impl crate::Writable for INT_POLAR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets INT_POLAR to value 0
        impl crate::Resettable for INT_POLAR_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///PA_DIR (rw) register accessor: GPIO port A direction
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`pa_dir::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pa_dir::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@pa_dir`]
    ///module
    pub type PA_DIR = crate::Reg<pa_dir::PA_DIR_SPEC>;
    ///GPIO port A direction
    pub mod pa_dir {
        ///Register `PA_DIR` reader
        pub type R = crate::R<PA_DIR_SPEC>;
        ///Register `PA_DIR` writer
        pub type W = crate::W<PA_DIR_SPEC>;
        ///Field `PA_DIR` reader - GPIO port A direction
        pub type PA_DIR_R = crate::FieldReader<u32>;
        ///Field `PA_DIR` writer - GPIO port A direction
        pub type PA_DIR_W<'a, REG> = crate::FieldWriter<'a, REG, 24, u32>;
        impl R {
            ///Bits 0:23 - GPIO port A direction
            #[inline(always)]
            pub fn pa_dir(&self) -> PA_DIR_R {
                PA_DIR_R::new(self.bits & 0x00ff_ffff)
            }
        }
        impl W {
            ///Bits 0:23 - GPIO port A direction
            #[inline(always)]
            #[must_use]
            pub fn pa_dir(&mut self) -> PA_DIR_W<PA_DIR_SPEC> {
                PA_DIR_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///GPIO port A direction
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`pa_dir::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pa_dir::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct PA_DIR_SPEC;
        impl crate::RegisterSpec for PA_DIR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`pa_dir::R`](R) reader structure
        impl crate::Readable for PA_DIR_SPEC {}
        ///`write(|w| ..)` method takes [`pa_dir::W`](W) writer structure
        impl crate::Writable for PA_DIR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets PA_DIR to value 0
        impl crate::Resettable for PA_DIR_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///PA_PIN (rw) register accessor: GPIO port A pin input value
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`pa_pin::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pa_pin::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@pa_pin`]
    ///module
    pub type PA_PIN = crate::Reg<pa_pin::PA_PIN_SPEC>;
    ///GPIO port A pin input value
    pub mod pa_pin {
        ///Register `PA_PIN` reader
        pub type R = crate::R<PA_PIN_SPEC>;
        ///Register `PA_PIN` writer
        pub type W = crate::W<PA_PIN_SPEC>;
        ///Field `PA_PIN` reader - GPIO port A pin input value
        pub type PA_PIN_R = crate::FieldReader<u32>;
        ///Field `PA_PIN` writer - GPIO port A pin input value
        pub type PA_PIN_W<'a, REG> = crate::FieldWriter<'a, REG, 24, u32>;
        impl R {
            ///Bits 0:23 - GPIO port A pin input value
            #[inline(always)]
            pub fn pa_pin(&self) -> PA_PIN_R {
                PA_PIN_R::new(self.bits & 0x00ff_ffff)
            }
        }
        impl W {
            ///Bits 0:23 - GPIO port A pin input value
            #[inline(always)]
            #[must_use]
            pub fn pa_pin(&mut self) -> PA_PIN_W<PA_PIN_SPEC> {
                PA_PIN_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///GPIO port A pin input value
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`pa_pin::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pa_pin::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct PA_PIN_SPEC;
        impl crate::RegisterSpec for PA_PIN_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`pa_pin::R`](R) reader structure
        impl crate::Readable for PA_PIN_SPEC {}
        ///`write(|w| ..)` method takes [`pa_pin::W`](W) writer structure
        impl crate::Writable for PA_PIN_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets PA_PIN to value 0
        impl crate::Resettable for PA_PIN_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///PA_OUT (rw) register accessor: GPIO port A output value
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`pa_out::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pa_out::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@pa_out`]
    ///module
    pub type PA_OUT = crate::Reg<pa_out::PA_OUT_SPEC>;
    ///GPIO port A output value
    pub mod pa_out {
        ///Register `PA_OUT` reader
        pub type R = crate::R<PA_OUT_SPEC>;
        ///Register `PA_OUT` writer
        pub type W = crate::W<PA_OUT_SPEC>;
        ///Field `PA_OUT` reader - GPIO port A output value
        pub type PA_OUT_R = crate::FieldReader<u32>;
        ///Field `PA_OUT` writer - GPIO port A output value
        pub type PA_OUT_W<'a, REG> = crate::FieldWriter<'a, REG, 24, u32>;
        impl R {
            ///Bits 0:23 - GPIO port A output value
            #[inline(always)]
            pub fn pa_out(&self) -> PA_OUT_R {
                PA_OUT_R::new(self.bits & 0x00ff_ffff)
            }
        }
        impl W {
            ///Bits 0:23 - GPIO port A output value
            #[inline(always)]
            #[must_use]
            pub fn pa_out(&mut self) -> PA_OUT_W<PA_OUT_SPEC> {
                PA_OUT_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///GPIO port A output value
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`pa_out::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pa_out::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct PA_OUT_SPEC;
        impl crate::RegisterSpec for PA_OUT_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`pa_out::R`](R) reader structure
        impl crate::Readable for PA_OUT_SPEC {}
        ///`write(|w| ..)` method takes [`pa_out::W`](W) writer structure
        impl crate::Writable for PA_OUT_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets PA_OUT to value 0
        impl crate::Resettable for PA_OUT_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///PA_CLR (w) register accessor: GPIO port A data clear
    ///
    ///You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pa_clr::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@pa_clr`]
    ///module
    pub type PA_CLR = crate::Reg<pa_clr::PA_CLR_SPEC>;
    ///GPIO port A data clear
    pub mod pa_clr {
        ///Register `PA_CLR` writer
        pub type W = crate::W<PA_CLR_SPEC>;
        ///Field `PA_CLR` writer - GPIO port A data clear
        pub type PA_CLR_W<'a, REG> = crate::FieldWriter<'a, REG, 24, u32>;
        impl W {
            ///Bits 0:23 - GPIO port A data clear
            #[inline(always)]
            #[must_use]
            pub fn pa_clr(&mut self) -> PA_CLR_W<PA_CLR_SPEC> {
                PA_CLR_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///GPIO port A data clear
        ///
        ///You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pa_clr::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct PA_CLR_SPEC;
        impl crate::RegisterSpec for PA_CLR_SPEC {
            type Ux = u32;
        }
        ///`write(|w| ..)` method takes [`pa_clr::W`](W) writer structure
        impl crate::Writable for PA_CLR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets PA_CLR to value 0
        impl crate::Resettable for PA_CLR_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///PA_PU (rw) register accessor: GPIO port A pull-up enable
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`pa_pu::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pa_pu::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@pa_pu`]
    ///module
    pub type PA_PU = crate::Reg<pa_pu::PA_PU_SPEC>;
    ///GPIO port A pull-up enable
    pub mod pa_pu {
        ///Register `PA_PU` reader
        pub type R = crate::R<PA_PU_SPEC>;
        ///Register `PA_PU` writer
        pub type W = crate::W<PA_PU_SPEC>;
        ///Field `PA_PU` reader - GPIO port A pull-up enable
        pub type PA_PU_R = crate::FieldReader<u32>;
        ///Field `PA_PU` writer - GPIO port A pull-up enable
        pub type PA_PU_W<'a, REG> = crate::FieldWriter<'a, REG, 24, u32>;
        impl R {
            ///Bits 0:23 - GPIO port A pull-up enable
            #[inline(always)]
            pub fn pa_pu(&self) -> PA_PU_R {
                PA_PU_R::new(self.bits & 0x00ff_ffff)
            }
        }
        impl W {
            ///Bits 0:23 - GPIO port A pull-up enable
            #[inline(always)]
            #[must_use]
            pub fn pa_pu(&mut self) -> PA_PU_W<PA_PU_SPEC> {
                PA_PU_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///GPIO port A pull-up enable
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`pa_pu::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pa_pu::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct PA_PU_SPEC;
        impl crate::RegisterSpec for PA_PU_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`pa_pu::R`](R) reader structure
        impl crate::Readable for PA_PU_SPEC {}
        ///`write(|w| ..)` method takes [`pa_pu::W`](W) writer structure
        impl crate::Writable for PA_PU_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets PA_PU to value 0
        impl crate::Resettable for PA_PU_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///PA_PD (rw) register accessor: GPIO port A pull-down enable
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`pa_pd::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pa_pd::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@pa_pd`]
    ///module
    pub type PA_PD = crate::Reg<pa_pd::PA_PD_SPEC>;
    ///GPIO port A pull-down enable
    pub mod pa_pd {
        ///Register `PA_PD` reader
        pub type R = crate::R<PA_PD_SPEC>;
        ///Register `PA_PD` writer
        pub type W = crate::W<PA_PD_SPEC>;
        ///Field `PA_PD` reader - GPIO port A pull-down enable
        pub type PA_PD_R = crate::FieldReader<u32>;
        ///Field `PA_PD` writer - GPIO port A pull-down enable
        pub type PA_PD_W<'a, REG> = crate::FieldWriter<'a, REG, 24, u32>;
        impl R {
            ///Bits 0:23 - GPIO port A pull-down enable
            #[inline(always)]
            pub fn pa_pd(&self) -> PA_PD_R {
                PA_PD_R::new(self.bits & 0x00ff_ffff)
            }
        }
        impl W {
            ///Bits 0:23 - GPIO port A pull-down enable
            #[inline(always)]
            #[must_use]
            pub fn pa_pd(&mut self) -> PA_PD_W<PA_PD_SPEC> {
                PA_PD_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///GPIO port A pull-down enable
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`pa_pd::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pa_pd::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct PA_PD_SPEC;
        impl crate::RegisterSpec for PA_PD_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`pa_pd::R`](R) reader structure
        impl crate::Readable for PA_PD_SPEC {}
        ///`write(|w| ..)` method takes [`pa_pd::W`](W) writer structure
        impl crate::Writable for PA_PD_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets PA_PD to value 0
        impl crate::Resettable for PA_PD_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///PA_DRV (rw) register accessor: GPIO port A drive capability
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`pa_drv::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pa_drv::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@pa_drv`]
    ///module
    pub type PA_DRV = crate::Reg<pa_drv::PA_DRV_SPEC>;
    ///GPIO port A drive capability
    pub mod pa_drv {
        ///Register `PA_DRV` reader
        pub type R = crate::R<PA_DRV_SPEC>;
        ///Register `PA_DRV` writer
        pub type W = crate::W<PA_DRV_SPEC>;
        ///Field `PA_DRV` reader - GPIO port A drive capability
        pub type PA_DRV_R = crate::FieldReader<u32>;
        ///Field `PA_DRV` writer - GPIO port A drive capability
        pub type PA_DRV_W<'a, REG> = crate::FieldWriter<'a, REG, 24, u32>;
        impl R {
            ///Bits 0:23 - GPIO port A drive capability
            #[inline(always)]
            pub fn pa_drv(&self) -> PA_DRV_R {
                PA_DRV_R::new(self.bits & 0x00ff_ffff)
            }
        }
        impl W {
            ///Bits 0:23 - GPIO port A drive capability
            #[inline(always)]
            #[must_use]
            pub fn pa_drv(&mut self) -> PA_DRV_W<PA_DRV_SPEC> {
                PA_DRV_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///GPIO port A drive capability
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`pa_drv::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pa_drv::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct PA_DRV_SPEC;
        impl crate::RegisterSpec for PA_DRV_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`pa_drv::R`](R) reader structure
        impl crate::Readable for PA_DRV_SPEC {}
        ///`write(|w| ..)` method takes [`pa_drv::W`](W) writer structure
        impl crate::Writable for PA_DRV_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets PA_DRV to value 0
        impl crate::Resettable for PA_DRV_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///PA_SMT (rw) register accessor: GPIO port A Schmitt trigger enable
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`pa_smt::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pa_smt::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@pa_smt`]
    ///module
    pub type PA_SMT = crate::Reg<pa_smt::PA_SMT_SPEC>;
    ///GPIO port A Schmitt trigger enable
    pub mod pa_smt {
        ///Register `PA_SMT` reader
        pub type R = crate::R<PA_SMT_SPEC>;
        ///Register `PA_SMT` writer
        pub type W = crate::W<PA_SMT_SPEC>;
        ///Field `PA_SMT` reader - GPIO port A Schmitt trigger enable
        pub type PA_SMT_R = crate::FieldReader<u32>;
        ///Field `PA_SMT` writer - GPIO port A Schmitt trigger enable
        pub type PA_SMT_W<'a, REG> = crate::FieldWriter<'a, REG, 24, u32>;
        impl R {
            ///Bits 0:23 - GPIO port A Schmitt trigger enable
            #[inline(always)]
            pub fn pa_smt(&self) -> PA_SMT_R {
                PA_SMT_R::new(self.bits & 0x00ff_ffff)
            }
        }
        impl W {
            ///Bits 0:23 - GPIO port A Schmitt trigger enable
            #[inline(always)]
            #[must_use]
            pub fn pa_smt(&mut self) -> PA_SMT_W<PA_SMT_SPEC> {
                PA_SMT_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///GPIO port A Schmitt trigger enable
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`pa_smt::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pa_smt::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct PA_SMT_SPEC;
        impl crate::RegisterSpec for PA_SMT_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`pa_smt::R`](R) reader structure
        impl crate::Readable for PA_SMT_SPEC {}
        ///`write(|w| ..)` method takes [`pa_smt::W`](W) writer structure
        impl crate::Writable for PA_SMT_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets PA_SMT to value 0
        impl crate::Resettable for PA_SMT_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///PB_DIR (rw) register accessor: GPIO port B direction
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`pb_dir::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pb_dir::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@pb_dir`]
    ///module
    pub type PB_DIR = crate::Reg<pb_dir::PB_DIR_SPEC>;
    ///GPIO port B direction
    pub mod pb_dir {
        ///Register `PB_DIR` reader
        pub type R = crate::R<PB_DIR_SPEC>;
        ///Register `PB_DIR` writer
        pub type W = crate::W<PB_DIR_SPEC>;
        ///Field `PB_DIR` reader - GPIO port B direction
        pub type PB_DIR_R = crate::FieldReader<u32>;
        ///Field `PB_DIR` writer - GPIO port B direction
        pub type PB_DIR_W<'a, REG> = crate::FieldWriter<'a, REG, 24, u32>;
        impl R {
            ///Bits 0:23 - GPIO port B direction
            #[inline(always)]
            pub fn pb_dir(&self) -> PB_DIR_R {
                PB_DIR_R::new(self.bits & 0x00ff_ffff)
            }
        }
        impl W {
            ///Bits 0:23 - GPIO port B direction
            #[inline(always)]
            #[must_use]
            pub fn pb_dir(&mut self) -> PB_DIR_W<PB_DIR_SPEC> {
                PB_DIR_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///GPIO port B direction
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`pb_dir::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pb_dir::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct PB_DIR_SPEC;
        impl crate::RegisterSpec for PB_DIR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`pb_dir::R`](R) reader structure
        impl crate::Readable for PB_DIR_SPEC {}
        ///`write(|w| ..)` method takes [`pb_dir::W`](W) writer structure
        impl crate::Writable for PB_DIR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets PB_DIR to value 0
        impl crate::Resettable for PB_DIR_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///PB_PIN (rw) register accessor: GPIO port B pin input value
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`pb_pin::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pb_pin::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@pb_pin`]
    ///module
    pub type PB_PIN = crate::Reg<pb_pin::PB_PIN_SPEC>;
    ///GPIO port B pin input value
    pub mod pb_pin {
        ///Register `PB_PIN` reader
        pub type R = crate::R<PB_PIN_SPEC>;
        ///Register `PB_PIN` writer
        pub type W = crate::W<PB_PIN_SPEC>;
        ///Field `PB_PIN` reader - GPIO port B pin input value
        pub type PB_PIN_R = crate::FieldReader<u32>;
        ///Field `PB_PIN` writer - GPIO port B pin input value
        pub type PB_PIN_W<'a, REG> = crate::FieldWriter<'a, REG, 24, u32>;
        impl R {
            ///Bits 0:23 - GPIO port B pin input value
            #[inline(always)]
            pub fn pb_pin(&self) -> PB_PIN_R {
                PB_PIN_R::new(self.bits & 0x00ff_ffff)
            }
        }
        impl W {
            ///Bits 0:23 - GPIO port B pin input value
            #[inline(always)]
            #[must_use]
            pub fn pb_pin(&mut self) -> PB_PIN_W<PB_PIN_SPEC> {
                PB_PIN_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///GPIO port B pin input value
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`pb_pin::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pb_pin::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct PB_PIN_SPEC;
        impl crate::RegisterSpec for PB_PIN_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`pb_pin::R`](R) reader structure
        impl crate::Readable for PB_PIN_SPEC {}
        ///`write(|w| ..)` method takes [`pb_pin::W`](W) writer structure
        impl crate::Writable for PB_PIN_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets PB_PIN to value 0
        impl crate::Resettable for PB_PIN_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///PB_OUT (rw) register accessor: GPIO port B output value
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`pb_out::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pb_out::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@pb_out`]
    ///module
    pub type PB_OUT = crate::Reg<pb_out::PB_OUT_SPEC>;
    ///GPIO port B output value
    pub mod pb_out {
        ///Register `PB_OUT` reader
        pub type R = crate::R<PB_OUT_SPEC>;
        ///Register `PB_OUT` writer
        pub type W = crate::W<PB_OUT_SPEC>;
        ///Field `PB_OUT` reader - GPIO port B output value
        pub type PB_OUT_R = crate::FieldReader<u32>;
        ///Field `PB_OUT` writer - GPIO port B output value
        pub type PB_OUT_W<'a, REG> = crate::FieldWriter<'a, REG, 24, u32>;
        impl R {
            ///Bits 0:23 - GPIO port B output value
            #[inline(always)]
            pub fn pb_out(&self) -> PB_OUT_R {
                PB_OUT_R::new(self.bits & 0x00ff_ffff)
            }
        }
        impl W {
            ///Bits 0:23 - GPIO port B output value
            #[inline(always)]
            #[must_use]
            pub fn pb_out(&mut self) -> PB_OUT_W<PB_OUT_SPEC> {
                PB_OUT_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///GPIO port B output value
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`pb_out::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pb_out::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct PB_OUT_SPEC;
        impl crate::RegisterSpec for PB_OUT_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`pb_out::R`](R) reader structure
        impl crate::Readable for PB_OUT_SPEC {}
        ///`write(|w| ..)` method takes [`pb_out::W`](W) writer structure
        impl crate::Writable for PB_OUT_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets PB_OUT to value 0
        impl crate::Resettable for PB_OUT_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///PB_CLR (w) register accessor: GPIO port B data clear
    ///
    ///You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pb_clr::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@pb_clr`]
    ///module
    pub type PB_CLR = crate::Reg<pb_clr::PB_CLR_SPEC>;
    ///GPIO port B data clear
    pub mod pb_clr {
        ///Register `PB_CLR` writer
        pub type W = crate::W<PB_CLR_SPEC>;
        ///Field `PB_CLR` writer - GPIO port B data clear
        pub type PB_CLR_W<'a, REG> = crate::FieldWriter<'a, REG, 24, u32>;
        impl W {
            ///Bits 0:23 - GPIO port B data clear
            #[inline(always)]
            #[must_use]
            pub fn pb_clr(&mut self) -> PB_CLR_W<PB_CLR_SPEC> {
                PB_CLR_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///GPIO port B data clear
        ///
        ///You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pb_clr::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct PB_CLR_SPEC;
        impl crate::RegisterSpec for PB_CLR_SPEC {
            type Ux = u32;
        }
        ///`write(|w| ..)` method takes [`pb_clr::W`](W) writer structure
        impl crate::Writable for PB_CLR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets PB_CLR to value 0
        impl crate::Resettable for PB_CLR_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///PB_PU (rw) register accessor: GPIO port B pull-up enable
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`pb_pu::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pb_pu::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@pb_pu`]
    ///module
    pub type PB_PU = crate::Reg<pb_pu::PB_PU_SPEC>;
    ///GPIO port B pull-up enable
    pub mod pb_pu {
        ///Register `PB_PU` reader
        pub type R = crate::R<PB_PU_SPEC>;
        ///Register `PB_PU` writer
        pub type W = crate::W<PB_PU_SPEC>;
        ///Field `PB_PU` reader - GPIO port B pull-up enable
        pub type PB_PU_R = crate::FieldReader<u32>;
        ///Field `PB_PU` writer - GPIO port B pull-up enable
        pub type PB_PU_W<'a, REG> = crate::FieldWriter<'a, REG, 24, u32>;
        impl R {
            ///Bits 0:23 - GPIO port B pull-up enable
            #[inline(always)]
            pub fn pb_pu(&self) -> PB_PU_R {
                PB_PU_R::new(self.bits & 0x00ff_ffff)
            }
        }
        impl W {
            ///Bits 0:23 - GPIO port B pull-up enable
            #[inline(always)]
            #[must_use]
            pub fn pb_pu(&mut self) -> PB_PU_W<PB_PU_SPEC> {
                PB_PU_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///GPIO port B pull-up enable
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`pb_pu::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pb_pu::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct PB_PU_SPEC;
        impl crate::RegisterSpec for PB_PU_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`pb_pu::R`](R) reader structure
        impl crate::Readable for PB_PU_SPEC {}
        ///`write(|w| ..)` method takes [`pb_pu::W`](W) writer structure
        impl crate::Writable for PB_PU_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets PB_PU to value 0
        impl crate::Resettable for PB_PU_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///PB_PD (rw) register accessor: GPIO port B pull-down enable
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`pb_pd::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pb_pd::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@pb_pd`]
    ///module
    pub type PB_PD = crate::Reg<pb_pd::PB_PD_SPEC>;
    ///GPIO port B pull-down enable
    pub mod pb_pd {
        ///Register `PB_PD` reader
        pub type R = crate::R<PB_PD_SPEC>;
        ///Register `PB_PD` writer
        pub type W = crate::W<PB_PD_SPEC>;
        ///Field `PB_PD` reader - GPIO port B pull-down enable
        pub type PB_PD_R = crate::FieldReader<u32>;
        ///Field `PB_PD` writer - GPIO port B pull-down enable
        pub type PB_PD_W<'a, REG> = crate::FieldWriter<'a, REG, 24, u32>;
        impl R {
            ///Bits 0:23 - GPIO port B pull-down enable
            #[inline(always)]
            pub fn pb_pd(&self) -> PB_PD_R {
                PB_PD_R::new(self.bits & 0x00ff_ffff)
            }
        }
        impl W {
            ///Bits 0:23 - GPIO port B pull-down enable
            #[inline(always)]
            #[must_use]
            pub fn pb_pd(&mut self) -> PB_PD_W<PB_PD_SPEC> {
                PB_PD_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///GPIO port B pull-down enable
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`pb_pd::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pb_pd::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct PB_PD_SPEC;
        impl crate::RegisterSpec for PB_PD_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`pb_pd::R`](R) reader structure
        impl crate::Readable for PB_PD_SPEC {}
        ///`write(|w| ..)` method takes [`pb_pd::W`](W) writer structure
        impl crate::Writable for PB_PD_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets PB_PD to value 0
        impl crate::Resettable for PB_PD_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///PB_DRV (rw) register accessor: GPIO port B drive capability
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`pb_drv::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pb_drv::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@pb_drv`]
    ///module
    pub type PB_DRV = crate::Reg<pb_drv::PB_DRV_SPEC>;
    ///GPIO port B drive capability
    pub mod pb_drv {
        ///Register `PB_DRV` reader
        pub type R = crate::R<PB_DRV_SPEC>;
        ///Register `PB_DRV` writer
        pub type W = crate::W<PB_DRV_SPEC>;
        ///Field `PB_DRV` reader - GPIO port B drive capability
        pub type PB_DRV_R = crate::FieldReader<u32>;
        ///Field `PB_DRV` writer - GPIO port B drive capability
        pub type PB_DRV_W<'a, REG> = crate::FieldWriter<'a, REG, 24, u32>;
        impl R {
            ///Bits 0:23 - GPIO port B drive capability
            #[inline(always)]
            pub fn pb_drv(&self) -> PB_DRV_R {
                PB_DRV_R::new(self.bits & 0x00ff_ffff)
            }
        }
        impl W {
            ///Bits 0:23 - GPIO port B drive capability
            #[inline(always)]
            #[must_use]
            pub fn pb_drv(&mut self) -> PB_DRV_W<PB_DRV_SPEC> {
                PB_DRV_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///GPIO port B drive capability
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`pb_drv::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pb_drv::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct PB_DRV_SPEC;
        impl crate::RegisterSpec for PB_DRV_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`pb_drv::R`](R) reader structure
        impl crate::Readable for PB_DRV_SPEC {}
        ///`write(|w| ..)` method takes [`pb_drv::W`](W) writer structure
        impl crate::Writable for PB_DRV_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets PB_DRV to value 0
        impl crate::Resettable for PB_DRV_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///PB_SMT (rw) register accessor: GPIO port B Schmitt trigger enable
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`pb_smt::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pb_smt::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@pb_smt`]
    ///module
    pub type PB_SMT = crate::Reg<pb_smt::PB_SMT_SPEC>;
    ///GPIO port B Schmitt trigger enable
    pub mod pb_smt {
        ///Register `PB_SMT` reader
        pub type R = crate::R<PB_SMT_SPEC>;
        ///Register `PB_SMT` writer
        pub type W = crate::W<PB_SMT_SPEC>;
        ///Field `PB_SMT` reader - GPIO port B Schmitt trigger enable
        pub type PB_SMT_R = crate::FieldReader<u32>;
        ///Field `PB_SMT` writer - GPIO port B Schmitt trigger enable
        pub type PB_SMT_W<'a, REG> = crate::FieldWriter<'a, REG, 24, u32>;
        impl R {
            ///Bits 0:23 - GPIO port B Schmitt trigger enable
            #[inline(always)]
            pub fn pb_smt(&self) -> PB_SMT_R {
                PB_SMT_R::new(self.bits & 0x00ff_ffff)
            }
        }
        impl W {
            ///Bits 0:23 - GPIO port B Schmitt trigger enable
            #[inline(always)]
            #[must_use]
            pub fn pb_smt(&mut self) -> PB_SMT_W<PB_SMT_SPEC> {
                PB_SMT_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///GPIO port B Schmitt trigger enable
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`pb_smt::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pb_smt::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct PB_SMT_SPEC;
        impl crate::RegisterSpec for PB_SMT_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`pb_smt::R`](R) reader structure
        impl crate::Readable for PB_SMT_SPEC {}
        ///`write(|w| ..)` method takes [`pb_smt::W`](W) writer structure
        impl crate::Writable for PB_SMT_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets PB_SMT to value 0
        impl crate::Resettable for PB_SMT_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///PIN_ALTERNATE (rw) register accessor: GPIO pin alternate function
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`pin_alternate::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pin_alternate::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@pin_alternate`]
    ///module
    pub type PIN_ALTERNATE = crate::Reg<pin_alternate::PIN_ALTERNATE_SPEC>;
    ///GPIO pin alternate function
    pub mod pin_alternate {
        ///Register `PIN_ALTERNATE` reader
        pub type R = crate::R<PIN_ALTERNATE_SPEC>;
        ///Register `PIN_ALTERNATE` writer
        pub type W = crate::W<PIN_ALTERNATE_SPEC>;
        ///Field `MII` reader - ETH RMII/RGMII interface
        pub type MII_R = crate::BitReader;
        ///Field `MII` writer - ETH RMII/RGMII interface
        pub type MII_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TMR1` reader - TMR1 alternate function
        pub type TMR1_R = crate::BitReader;
        ///Field `TMR1` writer - TMR1 alternate function
        pub type TMR1_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TMR2` reader - TMR2 alternate function
        pub type TMR2_R = crate::BitReader;
        ///Field `TMR2` writer - TMR2 alternate function
        pub type TMR2_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UART0` reader - UART0 alternate function
        pub type UART0_R = crate::BitReader;
        ///Field `UART0` writer - UART0 alternate function
        pub type UART0_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - ETH RMII/RGMII interface
            #[inline(always)]
            pub fn mii(&self) -> MII_R {
                MII_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - TMR1 alternate function
            #[inline(always)]
            pub fn tmr1(&self) -> TMR1_R {
                TMR1_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - TMR2 alternate function
            #[inline(always)]
            pub fn tmr2(&self) -> TMR2_R {
                TMR2_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 4 - UART0 alternate function
            #[inline(always)]
            pub fn uart0(&self) -> UART0_R {
                UART0_R::new(((self.bits >> 4) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - ETH RMII/RGMII interface
            #[inline(always)]
            #[must_use]
            pub fn mii(&mut self) -> MII_W<PIN_ALTERNATE_SPEC> {
                MII_W::new(self, 0)
            }
            ///Bit 1 - TMR1 alternate function
            #[inline(always)]
            #[must_use]
            pub fn tmr1(&mut self) -> TMR1_W<PIN_ALTERNATE_SPEC> {
                TMR1_W::new(self, 1)
            }
            ///Bit 2 - TMR2 alternate function
            #[inline(always)]
            #[must_use]
            pub fn tmr2(&mut self) -> TMR2_W<PIN_ALTERNATE_SPEC> {
                TMR2_W::new(self, 2)
            }
            ///Bit 4 - UART0 alternate function
            #[inline(always)]
            #[must_use]
            pub fn uart0(&mut self) -> UART0_W<PIN_ALTERNATE_SPEC> {
                UART0_W::new(self, 4)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///GPIO pin alternate function
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`pin_alternate::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pin_alternate::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct PIN_ALTERNATE_SPEC;
        impl crate::RegisterSpec for PIN_ALTERNATE_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`pin_alternate::R`](R) reader structure
        impl crate::Readable for PIN_ALTERNATE_SPEC {}
        ///`write(|w| ..)` method takes [`pin_alternate::W`](W) writer structure
        impl crate::Writable for PIN_ALTERNATE_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets PIN_ALTERNATE to value 0
        impl crate::Resettable for PIN_ALTERNATE_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
}
///SerDes high-speed differential signal
pub struct SERDES {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for SERDES {}
impl SERDES {
    ///Pointer to the register block
    pub const PTR: *const serdes::RegisterBlock = 0x4000_b000 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const serdes::RegisterBlock {
        Self::PTR
    }
    /// Steal an instance of this peripheral
    ///
    /// # Safety
    ///
    /// Ensure that the new instance of the peripheral cannot be used in a way
    /// that may race with any existing instances, for example by only
    /// accessing read-only or write-only registers, or by consuming the
    /// original peripheral and using critical sections to coordinate
    /// access between multiple new instances.
    ///
    /// Additionally, other software such as HALs may rely on only one
    /// peripheral instance existing to ensure memory safety; ensure
    /// no stolen instances are passed to such software.
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for SERDES {
    type Target = serdes::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for SERDES {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("SERDES").finish()
    }
}
///SerDes high-speed differential signal
pub mod serdes {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        ctrl: CTRL,
        int_en: INT_EN,
        status: STATUS,
        rtx_ctrl: RTX_CTRL,
        rx_len0: RX_LEN0,
        data0: DATA0,
        dma0: DMA0,
        rx_len1: RX_LEN1,
        data1: DATA1,
        dma1: DMA1,
    }
    impl RegisterBlock {
        ///0x00 - None
        #[inline(always)]
        pub const fn ctrl(&self) -> &CTRL {
            &self.ctrl
        }
        ///0x04 - None
        #[inline(always)]
        pub const fn int_en(&self) -> &INT_EN {
            &self.int_en
        }
        ///0x08 - None
        #[inline(always)]
        pub const fn status(&self) -> &STATUS {
            &self.status
        }
        ///0x0c - None
        #[inline(always)]
        pub const fn rtx_ctrl(&self) -> &RTX_CTRL {
            &self.rtx_ctrl
        }
        ///0x10 - None
        #[inline(always)]
        pub const fn rx_len0(&self) -> &RX_LEN0 {
            &self.rx_len0
        }
        ///0x14 - None
        #[inline(always)]
        pub const fn data0(&self) -> &DATA0 {
            &self.data0
        }
        ///0x18 - DMA starting Address
        #[inline(always)]
        pub const fn dma0(&self) -> &DMA0 {
            &self.dma0
        }
        ///0x1c - None
        #[inline(always)]
        pub const fn rx_len1(&self) -> &RX_LEN1 {
            &self.rx_len1
        }
        ///0x20 - None
        #[inline(always)]
        pub const fn data1(&self) -> &DATA1 {
            &self.data1
        }
        ///0x24 - None
        #[inline(always)]
        pub const fn dma1(&self) -> &DMA1 {
            &self.dma1
        }
    }
    ///CTRL (rw) register accessor: None
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`ctrl::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ctrl::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@ctrl`]
    ///module
    pub type CTRL = crate::Reg<ctrl::CTRL_SPEC>;
    ///None
    pub mod ctrl {
        ///Register `CTRL` reader
        pub type R = crate::R<CTRL_SPEC>;
        ///Register `CTRL` writer
        pub type W = crate::W<CTRL_SPEC>;
        ///Field `ALL_CLR` reader -
        pub type ALL_CLR_R = crate::BitReader;
        ///Field `ALL_CLR` writer -
        pub type ALL_CLR_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `LINK_RESET` reader -
        pub type LINK_RESET_R = crate::BitReader;
        ///Field `LINK_RESET` writer -
        pub type LINK_RESET_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PHY_RESET` reader -
        pub type PHY_RESET_R = crate::BitReader;
        ///Field `PHY_RESET` writer -
        pub type PHY_RESET_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `INT_BUSY_EN` reader -
        pub type INT_BUSY_EN_R = crate::BitReader;
        ///Field `INT_BUSY_EN` writer -
        pub type INT_BUSY_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `RX_POLAR` reader -
        pub type RX_POLAR_R = crate::BitReader;
        ///Field `RX_POLAR` writer -
        pub type RX_POLAR_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `RX_EN` reader -
        pub type RX_EN_R = crate::BitReader;
        ///Field `RX_EN` writer -
        pub type RX_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TX_EN` reader -
        pub type TX_EN_R = crate::BitReader;
        ///Field `TX_EN` writer -
        pub type TX_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `DMA_EN` reader -
        pub type DMA_EN_R = crate::BitReader;
        ///Field `DMA_EN` writer -
        pub type DMA_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PLL_DIV` reader -
        pub type PLL_DIV_R = crate::FieldReader;
        ///Field `PLL_DIV` writer -
        pub type PLL_DIV_W<'a, REG> = crate::FieldWriter<'a, REG, 5>;
        ///Field `PLL_PU` reader -
        pub type PLL_PU_R = crate::BitReader;
        ///Field `PLL_PU` writer -
        pub type PLL_PU_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `RX_PU` reader -
        pub type RX_PU_R = crate::BitReader;
        ///Field `RX_PU` writer -
        pub type RX_PU_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TX_PU` reader -
        pub type TX_PU_R = crate::BitReader;
        ///Field `TX_PU` writer -
        pub type TX_PU_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `POWR_UP` reader -
        pub type POWR_UP_R = crate::BitReader;
        ///Field `POWR_UP` writer -
        pub type POWR_UP_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CONT_EN` reader -
        pub type CONT_EN_R = crate::BitReader;
        ///Field `CONT_EN` writer -
        pub type CONT_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `ALIGN_EN` reader - None
        pub type ALIGN_EN_R = crate::BitReader;
        ///Field `ALIGN_EN` writer - None
        pub type ALIGN_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0
            #[inline(always)]
            pub fn all_clr(&self) -> ALL_CLR_R {
                ALL_CLR_R::new((self.bits & 1) != 0)
            }
            ///Bit 1
            #[inline(always)]
            pub fn link_reset(&self) -> LINK_RESET_R {
                LINK_RESET_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2
            #[inline(always)]
            pub fn phy_reset(&self) -> PHY_RESET_R {
                PHY_RESET_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3
            #[inline(always)]
            pub fn int_busy_en(&self) -> INT_BUSY_EN_R {
                INT_BUSY_EN_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4
            #[inline(always)]
            pub fn rx_polar(&self) -> RX_POLAR_R {
                RX_POLAR_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5
            #[inline(always)]
            pub fn rx_en(&self) -> RX_EN_R {
                RX_EN_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6
            #[inline(always)]
            pub fn tx_en(&self) -> TX_EN_R {
                TX_EN_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7
            #[inline(always)]
            pub fn dma_en(&self) -> DMA_EN_R {
                DMA_EN_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bits 8:12
            #[inline(always)]
            pub fn pll_div(&self) -> PLL_DIV_R {
                PLL_DIV_R::new(((self.bits >> 8) & 0x1f) as u8)
            }
            ///Bit 13
            #[inline(always)]
            pub fn pll_pu(&self) -> PLL_PU_R {
                PLL_PU_R::new(((self.bits >> 13) & 1) != 0)
            }
            ///Bit 14
            #[inline(always)]
            pub fn rx_pu(&self) -> RX_PU_R {
                RX_PU_R::new(((self.bits >> 14) & 1) != 0)
            }
            ///Bit 15
            #[inline(always)]
            pub fn tx_pu(&self) -> TX_PU_R {
                TX_PU_R::new(((self.bits >> 15) & 1) != 0)
            }
            ///Bit 16
            #[inline(always)]
            pub fn powr_up(&self) -> POWR_UP_R {
                POWR_UP_R::new(((self.bits >> 16) & 1) != 0)
            }
            ///Bit 17
            #[inline(always)]
            pub fn cont_en(&self) -> CONT_EN_R {
                CONT_EN_R::new(((self.bits >> 17) & 1) != 0)
            }
            ///Bit 18 - None
            #[inline(always)]
            pub fn align_en(&self) -> ALIGN_EN_R {
                ALIGN_EN_R::new(((self.bits >> 18) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0
            #[inline(always)]
            #[must_use]
            pub fn all_clr(&mut self) -> ALL_CLR_W<CTRL_SPEC> {
                ALL_CLR_W::new(self, 0)
            }
            ///Bit 1
            #[inline(always)]
            #[must_use]
            pub fn link_reset(&mut self) -> LINK_RESET_W<CTRL_SPEC> {
                LINK_RESET_W::new(self, 1)
            }
            ///Bit 2
            #[inline(always)]
            #[must_use]
            pub fn phy_reset(&mut self) -> PHY_RESET_W<CTRL_SPEC> {
                PHY_RESET_W::new(self, 2)
            }
            ///Bit 3
            #[inline(always)]
            #[must_use]
            pub fn int_busy_en(&mut self) -> INT_BUSY_EN_W<CTRL_SPEC> {
                INT_BUSY_EN_W::new(self, 3)
            }
            ///Bit 4
            #[inline(always)]
            #[must_use]
            pub fn rx_polar(&mut self) -> RX_POLAR_W<CTRL_SPEC> {
                RX_POLAR_W::new(self, 4)
            }
            ///Bit 5
            #[inline(always)]
            #[must_use]
            pub fn rx_en(&mut self) -> RX_EN_W<CTRL_SPEC> {
                RX_EN_W::new(self, 5)
            }
            ///Bit 6
            #[inline(always)]
            #[must_use]
            pub fn tx_en(&mut self) -> TX_EN_W<CTRL_SPEC> {
                TX_EN_W::new(self, 6)
            }
            ///Bit 7
            #[inline(always)]
            #[must_use]
            pub fn dma_en(&mut self) -> DMA_EN_W<CTRL_SPEC> {
                DMA_EN_W::new(self, 7)
            }
            ///Bits 8:12
            #[inline(always)]
            #[must_use]
            pub fn pll_div(&mut self) -> PLL_DIV_W<CTRL_SPEC> {
                PLL_DIV_W::new(self, 8)
            }
            ///Bit 13
            #[inline(always)]
            #[must_use]
            pub fn pll_pu(&mut self) -> PLL_PU_W<CTRL_SPEC> {
                PLL_PU_W::new(self, 13)
            }
            ///Bit 14
            #[inline(always)]
            #[must_use]
            pub fn rx_pu(&mut self) -> RX_PU_W<CTRL_SPEC> {
                RX_PU_W::new(self, 14)
            }
            ///Bit 15
            #[inline(always)]
            #[must_use]
            pub fn tx_pu(&mut self) -> TX_PU_W<CTRL_SPEC> {
                TX_PU_W::new(self, 15)
            }
            ///Bit 16
            #[inline(always)]
            #[must_use]
            pub fn powr_up(&mut self) -> POWR_UP_W<CTRL_SPEC> {
                POWR_UP_W::new(self, 16)
            }
            ///Bit 17
            #[inline(always)]
            #[must_use]
            pub fn cont_en(&mut self) -> CONT_EN_W<CTRL_SPEC> {
                CONT_EN_W::new(self, 17)
            }
            ///Bit 18 - None
            #[inline(always)]
            #[must_use]
            pub fn align_en(&mut self) -> ALIGN_EN_W<CTRL_SPEC> {
                ALIGN_EN_W::new(self, 18)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///None
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`ctrl::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ctrl::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct CTRL_SPEC;
        impl crate::RegisterSpec for CTRL_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`ctrl::R`](R) reader structure
        impl crate::Readable for CTRL_SPEC {}
        ///`write(|w| ..)` method takes [`ctrl::W`](W) writer structure
        impl crate::Writable for CTRL_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets CTRL to value 0
        impl crate::Resettable for CTRL_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///INT_EN (rw) register accessor: None
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`int_en::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`int_en::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@int_en`]
    ///module
    pub type INT_EN = crate::Reg<int_en::INT_EN_SPEC>;
    ///None
    pub mod int_en {
        ///Register `INT_EN` reader
        pub type R = crate::R<INT_EN_SPEC>;
        ///Register `INT_EN` writer
        pub type W = crate::W<INT_EN_SPEC>;
        ///Field `PHY_RDY_EN` reader -
        pub type PHY_RDY_EN_R = crate::BitReader;
        ///Field `PHY_RDY_EN` writer -
        pub type PHY_RDY_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TX_INT_EN` reader -
        pub type TX_INT_EN_R = crate::BitReader;
        ///Field `TX_INT_EN` writer -
        pub type TX_INT_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `RX_ERR_EN` reader -
        pub type RX_ERR_EN_R = crate::BitReader;
        ///Field `RX_ERR_EN` writer -
        pub type RX_ERR_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `RX_INT_EN` reader -
        pub type RX_INT_EN_R = crate::BitReader;
        ///Field `RX_INT_EN` writer -
        pub type RX_INT_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FIFO_OV_EN` reader -
        pub type FIFO_OV_EN_R = crate::BitReader;
        ///Field `FIFO_OV_EN` writer -
        pub type FIFO_OV_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `COMMA_INT_EN` reader -
        pub type COMMA_INT_EN_R = crate::BitReader;
        ///Field `COMMA_INT_EN` writer -
        pub type COMMA_INT_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0
            #[inline(always)]
            pub fn phy_rdy_en(&self) -> PHY_RDY_EN_R {
                PHY_RDY_EN_R::new((self.bits & 1) != 0)
            }
            ///Bit 1
            #[inline(always)]
            pub fn tx_int_en(&self) -> TX_INT_EN_R {
                TX_INT_EN_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 1
            #[inline(always)]
            pub fn rx_err_en(&self) -> RX_ERR_EN_R {
                RX_ERR_EN_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2
            #[inline(always)]
            pub fn rx_int_en(&self) -> RX_INT_EN_R {
                RX_INT_EN_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3
            #[inline(always)]
            pub fn fifo_ov_en(&self) -> FIFO_OV_EN_R {
                FIFO_OV_EN_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 5
            #[inline(always)]
            pub fn comma_int_en(&self) -> COMMA_INT_EN_R {
                COMMA_INT_EN_R::new(((self.bits >> 5) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0
            #[inline(always)]
            #[must_use]
            pub fn phy_rdy_en(&mut self) -> PHY_RDY_EN_W<INT_EN_SPEC> {
                PHY_RDY_EN_W::new(self, 0)
            }
            ///Bit 1
            #[inline(always)]
            #[must_use]
            pub fn tx_int_en(&mut self) -> TX_INT_EN_W<INT_EN_SPEC> {
                TX_INT_EN_W::new(self, 1)
            }
            ///Bit 1
            #[inline(always)]
            #[must_use]
            pub fn rx_err_en(&mut self) -> RX_ERR_EN_W<INT_EN_SPEC> {
                RX_ERR_EN_W::new(self, 1)
            }
            ///Bit 2
            #[inline(always)]
            #[must_use]
            pub fn rx_int_en(&mut self) -> RX_INT_EN_W<INT_EN_SPEC> {
                RX_INT_EN_W::new(self, 2)
            }
            ///Bit 3
            #[inline(always)]
            #[must_use]
            pub fn fifo_ov_en(&mut self) -> FIFO_OV_EN_W<INT_EN_SPEC> {
                FIFO_OV_EN_W::new(self, 3)
            }
            ///Bit 5
            #[inline(always)]
            #[must_use]
            pub fn comma_int_en(&mut self) -> COMMA_INT_EN_W<INT_EN_SPEC> {
                COMMA_INT_EN_W::new(self, 5)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///None
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`int_en::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`int_en::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct INT_EN_SPEC;
        impl crate::RegisterSpec for INT_EN_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`int_en::R`](R) reader structure
        impl crate::Readable for INT_EN_SPEC {}
        ///`write(|w| ..)` method takes [`int_en::W`](W) writer structure
        impl crate::Writable for INT_EN_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets INT_EN to value 0
        impl crate::Resettable for INT_EN_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///STATUS (rw) register accessor: None
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`status::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`status::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@status`]
    ///module
    pub type STATUS = crate::Reg<status::STATUS_SPEC>;
    ///None
    pub mod status {
        ///Register `STATUS` reader
        pub type R = crate::R<STATUS_SPEC>;
        ///Register `STATUS` writer
        pub type W = crate::W<STATUS_SPEC>;
        ///Field `PHY_RDY_FLG` reader -
        pub type PHY_RDY_FLG_R = crate::BitReader;
        ///Field `PHY_RDY_FLG` writer -
        pub type PHY_RDY_FLG_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TX_INT_FLG` reader -
        pub type TX_INT_FLG_R = crate::BitReader;
        ///Field `TX_INT_FLG` writer -
        pub type TX_INT_FLG_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `RX_ERR_FLG` reader -
        pub type RX_ERR_FLG_R = crate::BitReader;
        ///Field `RX_ERR_FLG` writer -
        pub type RX_ERR_FLG_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `RX_INT_FLG` reader -
        pub type RX_INT_FLG_R = crate::BitReader;
        ///Field `RX_INT_FLG` writer -
        pub type RX_INT_FLG_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FIFO_OV_FLG` reader -
        pub type FIFO_OV_FLG_R = crate::BitReader;
        ///Field `FIFO_OV_FLG` writer -
        pub type FIFO_OV_FLG_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `COMMA_INT_FLG` reader -
        pub type COMMA_INT_FLG_R = crate::BitReader;
        ///Field `COMMA_INT_FLG` writer -
        pub type COMMA_INT_FLG_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `SEQ_MATCH` reader -
        pub type SEQ_MATCH_R = crate::BitReader;
        ///Field `SEQ_MATCH` writer -
        pub type SEQ_MATCH_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `RX_CRC_OK` reader -
        pub type RX_CRC_OK_R = crate::BitReader;
        ///Field `RX_CRC_OK` writer -
        pub type RX_CRC_OK_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PLL_READY` reader -
        pub type PLL_READY_R = crate::BitReader;
        ///Field `PLL_READY` writer -
        pub type PLL_READY_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TX_READY` reader -
        pub type TX_READY_R = crate::BitReader;
        ///Field `TX_READY` writer -
        pub type TX_READY_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0
            #[inline(always)]
            pub fn phy_rdy_flg(&self) -> PHY_RDY_FLG_R {
                PHY_RDY_FLG_R::new((self.bits & 1) != 0)
            }
            ///Bit 1
            #[inline(always)]
            pub fn tx_int_flg(&self) -> TX_INT_FLG_R {
                TX_INT_FLG_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 1
            #[inline(always)]
            pub fn rx_err_flg(&self) -> RX_ERR_FLG_R {
                RX_ERR_FLG_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2
            #[inline(always)]
            pub fn rx_int_flg(&self) -> RX_INT_FLG_R {
                RX_INT_FLG_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3
            #[inline(always)]
            pub fn fifo_ov_flg(&self) -> FIFO_OV_FLG_R {
                FIFO_OV_FLG_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 5
            #[inline(always)]
            pub fn comma_int_flg(&self) -> COMMA_INT_FLG_R {
                COMMA_INT_FLG_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 17
            #[inline(always)]
            pub fn seq_match(&self) -> SEQ_MATCH_R {
                SEQ_MATCH_R::new(((self.bits >> 17) & 1) != 0)
            }
            ///Bit 18
            #[inline(always)]
            pub fn rx_crc_ok(&self) -> RX_CRC_OK_R {
                RX_CRC_OK_R::new(((self.bits >> 18) & 1) != 0)
            }
            ///Bit 19
            #[inline(always)]
            pub fn pll_ready(&self) -> PLL_READY_R {
                PLL_READY_R::new(((self.bits >> 19) & 1) != 0)
            }
            ///Bit 20
            #[inline(always)]
            pub fn tx_ready(&self) -> TX_READY_R {
                TX_READY_R::new(((self.bits >> 20) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0
            #[inline(always)]
            #[must_use]
            pub fn phy_rdy_flg(&mut self) -> PHY_RDY_FLG_W<STATUS_SPEC> {
                PHY_RDY_FLG_W::new(self, 0)
            }
            ///Bit 1
            #[inline(always)]
            #[must_use]
            pub fn tx_int_flg(&mut self) -> TX_INT_FLG_W<STATUS_SPEC> {
                TX_INT_FLG_W::new(self, 1)
            }
            ///Bit 1
            #[inline(always)]
            #[must_use]
            pub fn rx_err_flg(&mut self) -> RX_ERR_FLG_W<STATUS_SPEC> {
                RX_ERR_FLG_W::new(self, 1)
            }
            ///Bit 2
            #[inline(always)]
            #[must_use]
            pub fn rx_int_flg(&mut self) -> RX_INT_FLG_W<STATUS_SPEC> {
                RX_INT_FLG_W::new(self, 2)
            }
            ///Bit 3
            #[inline(always)]
            #[must_use]
            pub fn fifo_ov_flg(&mut self) -> FIFO_OV_FLG_W<STATUS_SPEC> {
                FIFO_OV_FLG_W::new(self, 3)
            }
            ///Bit 5
            #[inline(always)]
            #[must_use]
            pub fn comma_int_flg(&mut self) -> COMMA_INT_FLG_W<STATUS_SPEC> {
                COMMA_INT_FLG_W::new(self, 5)
            }
            ///Bit 17
            #[inline(always)]
            #[must_use]
            pub fn seq_match(&mut self) -> SEQ_MATCH_W<STATUS_SPEC> {
                SEQ_MATCH_W::new(self, 17)
            }
            ///Bit 18
            #[inline(always)]
            #[must_use]
            pub fn rx_crc_ok(&mut self) -> RX_CRC_OK_W<STATUS_SPEC> {
                RX_CRC_OK_W::new(self, 18)
            }
            ///Bit 19
            #[inline(always)]
            #[must_use]
            pub fn pll_ready(&mut self) -> PLL_READY_W<STATUS_SPEC> {
                PLL_READY_W::new(self, 19)
            }
            ///Bit 20
            #[inline(always)]
            #[must_use]
            pub fn tx_ready(&mut self) -> TX_READY_W<STATUS_SPEC> {
                TX_READY_W::new(self, 20)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///None
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`status::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`status::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct STATUS_SPEC;
        impl crate::RegisterSpec for STATUS_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`status::R`](R) reader structure
        impl crate::Readable for STATUS_SPEC {}
        ///`write(|w| ..)` method takes [`status::W`](W) writer structure
        impl crate::Writable for STATUS_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets STATUS to value 0
        impl crate::Resettable for STATUS_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///RTX_CTRL (rw) register accessor: None
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`rtx_ctrl::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`rtx_ctrl::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@rtx_ctrl`]
    ///module
    pub type RTX_CTRL = crate::Reg<rtx_ctrl::RTX_CTRL_SPEC>;
    ///None
    pub mod rtx_ctrl {
        ///Register `RTX_CTRL` reader
        pub type R = crate::R<RTX_CTRL_SPEC>;
        ///Register `RTX_CTRL` writer
        pub type W = crate::W<RTX_CTRL_SPEC>;
        ///Field `LINK_INIT` reader -
        pub type LINK_INIT_R = crate::BitReader;
        ///Field `LINK_INIT` writer -
        pub type LINK_INIT_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TX_START` reader -
        pub type TX_START_R = crate::BitReader;
        ///Field `TX_START` writer -
        pub type TX_START_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `BUF_MODE` reader -
        pub type BUF_MODE_R = crate::BitReader;
        ///Field `BUF_MODE` writer -
        pub type BUF_MODE_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 16
            #[inline(always)]
            pub fn link_init(&self) -> LINK_INIT_R {
                LINK_INIT_R::new(((self.bits >> 16) & 1) != 0)
            }
            ///Bit 17
            #[inline(always)]
            pub fn tx_start(&self) -> TX_START_R {
                TX_START_R::new(((self.bits >> 17) & 1) != 0)
            }
            ///Bit 18
            #[inline(always)]
            pub fn buf_mode(&self) -> BUF_MODE_R {
                BUF_MODE_R::new(((self.bits >> 18) & 1) != 0)
            }
        }
        impl W {
            ///Bit 16
            #[inline(always)]
            #[must_use]
            pub fn link_init(&mut self) -> LINK_INIT_W<RTX_CTRL_SPEC> {
                LINK_INIT_W::new(self, 16)
            }
            ///Bit 17
            #[inline(always)]
            #[must_use]
            pub fn tx_start(&mut self) -> TX_START_W<RTX_CTRL_SPEC> {
                TX_START_W::new(self, 17)
            }
            ///Bit 18
            #[inline(always)]
            #[must_use]
            pub fn buf_mode(&mut self) -> BUF_MODE_W<RTX_CTRL_SPEC> {
                BUF_MODE_W::new(self, 18)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///None
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`rtx_ctrl::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`rtx_ctrl::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct RTX_CTRL_SPEC;
        impl crate::RegisterSpec for RTX_CTRL_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`rtx_ctrl::R`](R) reader structure
        impl crate::Readable for RTX_CTRL_SPEC {}
        ///`write(|w| ..)` method takes [`rtx_ctrl::W`](W) writer structure
        impl crate::Writable for RTX_CTRL_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets RTX_CTRL to value 0
        impl crate::Resettable for RTX_CTRL_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///RX_LEN0 (rw) register accessor: None
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`rx_len0::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`rx_len0::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@rx_len0`]
    ///module
    pub type RX_LEN0 = crate::Reg<rx_len0::RX_LEN0_SPEC>;
    ///None
    pub mod rx_len0 {
        ///Register `RX_LEN0` reader
        pub type R = crate::R<RX_LEN0_SPEC>;
        ///Register `RX_LEN0` writer
        pub type W = crate::W<RX_LEN0_SPEC>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<RX_LEN0_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                core::fmt::Debug::fmt(&self.read(), f)
            }
        }
        impl W {
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///None
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`rx_len0::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`rx_len0::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct RX_LEN0_SPEC;
        impl crate::RegisterSpec for RX_LEN0_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`rx_len0::R`](R) reader structure
        impl crate::Readable for RX_LEN0_SPEC {}
        ///`write(|w| ..)` method takes [`rx_len0::W`](W) writer structure
        impl crate::Writable for RX_LEN0_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets RX_LEN0 to value 0
        impl crate::Resettable for RX_LEN0_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///DATA0 (rw) register accessor: None
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`data0::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`data0::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@data0`]
    ///module
    pub type DATA0 = crate::Reg<data0::DATA0_SPEC>;
    ///None
    pub mod data0 {
        ///Register `DATA0` reader
        pub type R = crate::R<DATA0_SPEC>;
        ///Register `DATA0` writer
        pub type W = crate::W<DATA0_SPEC>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<DATA0_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                core::fmt::Debug::fmt(&self.read(), f)
            }
        }
        impl W {
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///None
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`data0::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`data0::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct DATA0_SPEC;
        impl crate::RegisterSpec for DATA0_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`data0::R`](R) reader structure
        impl crate::Readable for DATA0_SPEC {}
        ///`write(|w| ..)` method takes [`data0::W`](W) writer structure
        impl crate::Writable for DATA0_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets DATA0 to value 0
        impl crate::Resettable for DATA0_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///DMA0 (rw) register accessor: DMA starting Address
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`dma0::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dma0::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@dma0`]
    ///module
    pub type DMA0 = crate::Reg<dma0::DMA0_SPEC>;
    ///DMA starting Address
    pub mod dma0 {
        ///Register `DMA0` reader
        pub type R = crate::R<DMA0_SPEC>;
        ///Register `DMA0` writer
        pub type W = crate::W<DMA0_SPEC>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<DMA0_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                core::fmt::Debug::fmt(&self.read(), f)
            }
        }
        impl W {
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///DMA starting Address
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`dma0::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dma0::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct DMA0_SPEC;
        impl crate::RegisterSpec for DMA0_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`dma0::R`](R) reader structure
        impl crate::Readable for DMA0_SPEC {}
        ///`write(|w| ..)` method takes [`dma0::W`](W) writer structure
        impl crate::Writable for DMA0_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets DMA0 to value 0
        impl crate::Resettable for DMA0_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///RX_LEN1 (rw) register accessor: None
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`rx_len1::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`rx_len1::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@rx_len1`]
    ///module
    pub type RX_LEN1 = crate::Reg<rx_len1::RX_LEN1_SPEC>;
    ///None
    pub mod rx_len1 {
        ///Register `RX_LEN1` reader
        pub type R = crate::R<RX_LEN1_SPEC>;
        ///Register `RX_LEN1` writer
        pub type W = crate::W<RX_LEN1_SPEC>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<RX_LEN1_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                core::fmt::Debug::fmt(&self.read(), f)
            }
        }
        impl W {
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///None
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`rx_len1::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`rx_len1::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct RX_LEN1_SPEC;
        impl crate::RegisterSpec for RX_LEN1_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`rx_len1::R`](R) reader structure
        impl crate::Readable for RX_LEN1_SPEC {}
        ///`write(|w| ..)` method takes [`rx_len1::W`](W) writer structure
        impl crate::Writable for RX_LEN1_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets RX_LEN1 to value 0
        impl crate::Resettable for RX_LEN1_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///DATA1 (rw) register accessor: None
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`data1::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`data1::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@data1`]
    ///module
    pub type DATA1 = crate::Reg<data1::DATA1_SPEC>;
    ///None
    pub mod data1 {
        ///Register `DATA1` reader
        pub type R = crate::R<DATA1_SPEC>;
        ///Register `DATA1` writer
        pub type W = crate::W<DATA1_SPEC>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<DATA1_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                core::fmt::Debug::fmt(&self.read(), f)
            }
        }
        impl W {
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///None
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`data1::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`data1::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct DATA1_SPEC;
        impl crate::RegisterSpec for DATA1_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`data1::R`](R) reader structure
        impl crate::Readable for DATA1_SPEC {}
        ///`write(|w| ..)` method takes [`data1::W`](W) writer structure
        impl crate::Writable for DATA1_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets DATA1 to value 0
        impl crate::Resettable for DATA1_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///DMA1 (rw) register accessor: None
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`dma1::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dma1::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@dma1`]
    ///module
    pub type DMA1 = crate::Reg<dma1::DMA1_SPEC>;
    ///None
    pub mod dma1 {
        ///Register `DMA1` reader
        pub type R = crate::R<DMA1_SPEC>;
        ///Register `DMA1` writer
        pub type W = crate::W<DMA1_SPEC>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<DMA1_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                core::fmt::Debug::fmt(&self.read(), f)
            }
        }
        impl W {
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///None
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`dma1::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dma1::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct DMA1_SPEC;
        impl crate::RegisterSpec for DMA1_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`dma1::R`](R) reader structure
        impl crate::Readable for DMA1_SPEC {}
        ///`write(|w| ..)` method takes [`dma1::W`](W) writer structure
        impl crate::Writable for DMA1_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets DMA1 to value 0
        impl crate::Resettable for DMA1_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
}
#[no_mangle]
static mut DEVICE_PERIPHERALS: bool = false;
/// All the peripherals.
#[allow(non_snake_case)]
pub struct Peripherals {
    ///SYS
    pub SYS: SYS,
    ///TMR0
    pub TMR0: TMR0,
    ///TMR1
    pub TMR1: TMR1,
    ///TMR2
    pub TMR2: TMR2,
    ///UART0
    pub UART0: UART0,
    ///UART1
    pub UART1: UART1,
    ///UART2
    pub UART2: UART2,
    ///UART3
    pub UART3: UART3,
    ///SPI0
    pub SPI0: SPI0,
    ///SPI1
    pub SPI1: SPI1,
    ///PWMX
    pub PWMX: PWMX,
    ///HSPI
    pub HSPI: HSPI,
    ///ECDC
    pub ECDC: ECDC,
    ///USBHS
    pub USBHS: USBHS,
    ///DVP
    pub DVP: DVP,
    ///PFIC
    pub PFIC: PFIC,
    ///Systick
    pub SYSTICK: SYSTICK,
    ///EMMC
    pub EMMC: EMMC,
    ///GPIO
    pub GPIO: GPIO,
    ///SERDES
    pub SERDES: SERDES,
}
impl Peripherals {
    /// Returns all the peripherals *once*.
    #[cfg(feature = "critical-section")]
    #[inline]
    pub fn take() -> Option<Self> {
        critical_section::with(|_| {
            if unsafe { DEVICE_PERIPHERALS } {
                return None;
            }
            Some(unsafe { Peripherals::steal() })
        })
    }
    /// Unchecked version of `Peripherals::take`.
    ///
    /// # Safety
    ///
    /// Each of the returned peripherals must be used at most once.
    #[inline]
    pub unsafe fn steal() -> Self {
        DEVICE_PERIPHERALS = true;
        Peripherals {
            SYS: SYS {
                _marker: PhantomData,
            },
            TMR0: TMR0 {
                _marker: PhantomData,
            },
            TMR1: TMR1 {
                _marker: PhantomData,
            },
            TMR2: TMR2 {
                _marker: PhantomData,
            },
            UART0: UART0 {
                _marker: PhantomData,
            },
            UART1: UART1 {
                _marker: PhantomData,
            },
            UART2: UART2 {
                _marker: PhantomData,
            },
            UART3: UART3 {
                _marker: PhantomData,
            },
            SPI0: SPI0 {
                _marker: PhantomData,
            },
            SPI1: SPI1 {
                _marker: PhantomData,
            },
            PWMX: PWMX {
                _marker: PhantomData,
            },
            HSPI: HSPI {
                _marker: PhantomData,
            },
            ECDC: ECDC {
                _marker: PhantomData,
            },
            USBHS: USBHS {
                _marker: PhantomData,
            },
            DVP: DVP {
                _marker: PhantomData,
            },
            PFIC: PFIC {
                _marker: PhantomData,
            },
            SYSTICK: SYSTICK {
                _marker: PhantomData,
            },
            EMMC: EMMC {
                _marker: PhantomData,
            },
            GPIO: GPIO {
                _marker: PhantomData,
            },
            SERDES: SERDES {
                _marker: PhantomData,
            },
        }
    }
}
