//!Peripheral access API for CH32L103 microcontrollers (generated using svd2rust v0.31.5 ( ))
//!
//!You can find an overview of the generated API [here].
//!
//!API features to be included in the [next]
//!svd2rust release can be generated by cloning the svd2rust [repository], checking out the above commit, and running `cargo doc --open`.
//!
//![here]: https://docs.rs/svd2rust/0.31.5/svd2rust/#peripheral-api
//![next]: https://github.com/rust-embedded/svd2rust/blob/master/CHANGELOG.md#unreleased
//![repository]: https://github.com/rust-embedded/svd2rust
use core::marker::PhantomData;
use core::ops::Deref;
#[cfg(feature = "rt")]
extern "C" {
    fn WWDG();
    fn PVD();
    fn TAMPER();
    fn RTC();
    fn FLASH();
    fn RCC();
    fn EXTI0();
    fn EXTI1();
    fn EXTI2();
    fn EXTI3();
    fn EXTI4();
    fn DMA_CH1();
    fn DMA_CH2();
    fn DMA_CH3();
    fn DMA_CH4();
    fn DMA_CH5();
    fn DMA_CH6();
    fn DMA_CH7();
    fn ADC();
    fn USB_HP_CAN_TX();
    fn USB_LP_CAN_RX0();
    fn CAN_RX1();
    fn CAN_SCE();
    fn EXTI9_5();
    fn TIM1_BRK();
    fn TIM1_UP_();
    fn TIM1_TRG_COM();
    fn TIM1_CC();
    fn TIM2();
    fn TIM3();
    fn TIM4();
    fn I2C1_EV();
    fn I2C1_ER();
    fn I2C2_EV();
    fn I2C2_ER();
    fn SPI1();
    fn SPI2();
    fn USART1();
    fn USART2();
    fn USART3();
    fn EXTI15_10();
    fn RTCALARM();
    fn LPTIM_WKUP();
    fn USBFS();
    fn USBFS_WKUP();
    fn UART4();
    fn DMA_CH8();
    fn LPTIM();
    fn OPA();
    fn USBPD();
    fn TKEY_WKUP();
    fn USBPD_WKUP();
}
#[doc(hidden)]
#[repr(C)]
pub union Vector {
    pub _handler: unsafe extern "C" fn(),
    pub _reserved: usize,
}
#[cfg(feature = "rt")]
#[doc(hidden)]
#[no_mangle]
pub static __EXTERNAL_INTERRUPTS: [Vector; 68] = [
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _handler: WWDG },
    Vector { _handler: PVD },
    Vector { _handler: TAMPER },
    Vector { _handler: RTC },
    Vector { _handler: FLASH },
    Vector { _handler: RCC },
    Vector { _handler: EXTI0 },
    Vector { _handler: EXTI1 },
    Vector { _handler: EXTI2 },
    Vector { _handler: EXTI3 },
    Vector { _handler: EXTI4 },
    Vector { _handler: DMA_CH1 },
    Vector { _handler: DMA_CH2 },
    Vector { _handler: DMA_CH3 },
    Vector { _handler: DMA_CH4 },
    Vector { _handler: DMA_CH5 },
    Vector { _handler: DMA_CH6 },
    Vector { _handler: DMA_CH7 },
    Vector { _handler: ADC },
    Vector {
        _handler: USB_HP_CAN_TX,
    },
    Vector {
        _handler: USB_LP_CAN_RX0,
    },
    Vector { _handler: CAN_RX1 },
    Vector { _handler: CAN_SCE },
    Vector { _handler: EXTI9_5 },
    Vector { _handler: TIM1_BRK },
    Vector { _handler: TIM1_UP_ },
    Vector {
        _handler: TIM1_TRG_COM,
    },
    Vector { _handler: TIM1_CC },
    Vector { _handler: TIM2 },
    Vector { _handler: TIM3 },
    Vector { _handler: TIM4 },
    Vector { _handler: I2C1_EV },
    Vector { _handler: I2C1_ER },
    Vector { _handler: I2C2_EV },
    Vector { _handler: I2C2_ER },
    Vector { _handler: SPI1 },
    Vector { _handler: SPI2 },
    Vector { _handler: USART1 },
    Vector { _handler: USART2 },
    Vector { _handler: USART3 },
    Vector {
        _handler: EXTI15_10,
    },
    Vector { _handler: RTCALARM },
    Vector {
        _handler: LPTIM_WKUP,
    },
    Vector { _handler: USBFS },
    Vector {
        _handler: USBFS_WKUP,
    },
    Vector { _handler: UART4 },
    Vector { _handler: DMA_CH8 },
    Vector { _handler: LPTIM },
    Vector { _handler: OPA },
    Vector { _handler: USBPD },
    Vector {
        _handler: TKEY_WKUP,
    },
    Vector {
        _handler: USBPD_WKUP,
    },
];
#[doc(hidden)]
pub mod interrupt {
    ///Enumeration of all the interrupts.
    #[derive(Copy, Clone, Debug, PartialEq, Eq)]
    #[repr(u16)]
    pub enum Interrupt {
        ///16 - Window Watchdog interrupt
        WWDG = 16,
        ///17 - PVD through EXTI line detection interrupt
        PVD = 17,
        ///18 - Tamper interrupt
        TAMPER = 18,
        ///19 - RTC global interrupt
        RTC = 19,
        ///20 - Flash global interrupt
        FLASH = 20,
        ///21 - RCC global interrupt
        RCC = 21,
        ///22 - EXTI Line0 interrupt
        EXTI0 = 22,
        ///23 - EXTI Line1 interrupt
        EXTI1 = 23,
        ///24 - EXTI Line2 interrupt
        EXTI2 = 24,
        ///25 - EXTI Line3 interrupt
        EXTI3 = 25,
        ///26 - EXTI Line4 interrupt
        EXTI4 = 26,
        ///27 - DMA Channel1 global interrupt
        DMA_CH1 = 27,
        ///28 - DMA Channel2 global interrupt
        DMA_CH2 = 28,
        ///29 - DMA Channel3 global interrupt
        DMA_CH3 = 29,
        ///30 - DMA Channel4 global interrupt
        DMA_CH4 = 30,
        ///31 - DMA Channel5 global interrupt
        DMA_CH5 = 31,
        ///32 - DMA Channel6 global interrupt
        DMA_CH6 = 32,
        ///33 - DMA Channel7 global interrupt
        DMA_CH7 = 33,
        ///34 - ADC global interrupt
        ADC = 34,
        ///35 - CAN TX interrupts
        USB_HP_CAN_TX = 35,
        ///36 - CAN RX0 interrupts
        USB_LP_CAN_RX0 = 36,
        ///37 - CAN RX1 interrupt
        CAN_RX1 = 37,
        ///38 - CAN SCE interrupt
        CAN_SCE = 38,
        ///39 - EXTI Line\[9:5\]
        ///interrupts
        EXTI9_5 = 39,
        ///40 - TIM1 Break interrupt
        TIM1_BRK = 40,
        ///41 - TIM1 Update interrupt
        TIM1_UP_ = 41,
        ///42 - TIM1 Trigger and Commutation interrupts
        TIM1_TRG_COM = 42,
        ///43 - TIM1 Capture Compare interrupt
        TIM1_CC = 43,
        ///44 - TIM2 global interrupt
        TIM2 = 44,
        ///45 - TIM3 global interrupt
        TIM3 = 45,
        ///46 - TIM4 global interrupt
        TIM4 = 46,
        ///47 - I2C1 event interrupt
        I2C1_EV = 47,
        ///48 - I2C1 error interrupt
        I2C1_ER = 48,
        ///49 - I2C2 event interrupt
        I2C2_EV = 49,
        ///50 - I2C2 error interrupt
        I2C2_ER = 50,
        ///51 - SPI1 global interrupt
        SPI1 = 51,
        ///52 - SPI2 global interrupt
        SPI2 = 52,
        ///53 - USART1 global interrupt
        USART1 = 53,
        ///54 - USART2 global interrupt
        USART2 = 54,
        ///55 - USART3 global interrupt
        USART3 = 55,
        ///56 - EXTI Line\[15:10\]
        ///interrupts
        EXTI15_10 = 56,
        ///57 - RTC Alarms through EXTI line interrupt
        RTCALARM = 57,
        ///58 - LPTIM wake-up interrupt
        LPTIM_WKUP = 58,
        ///59 - USBFS global interrupt
        USBFS = 59,
        ///60 - USBFS wake-up interrupt
        USBFS_WKUP = 60,
        ///61 - UART4 global interrupt
        UART4 = 61,
        ///62 - DMA Channel8 global interrupt
        DMA_CH8 = 62,
        ///63 - LPTIM global interrupt
        LPTIM = 63,
        ///64 - OPA global interrupts
        OPA = 64,
        ///65 - USBPD global interrupt
        USBPD = 65,
        ///66 - TKEY wake-up interrupt
        TKEY_WKUP = 66,
        ///67 - USBPD wake-up interrupt
        USBPD_WKUP = 67,
    }
    /// TryFromInterruptError
    #[derive(Debug, Copy, Clone)]
    pub struct TryFromInterruptError(());
    impl Interrupt {
        /// Attempt to convert a given value into an `Interrupt`
        #[inline]
        pub fn try_from(value: u8) -> Result<Self, TryFromInterruptError> {
            match value {
                16 => Ok(Interrupt::WWDG),
                17 => Ok(Interrupt::PVD),
                18 => Ok(Interrupt::TAMPER),
                19 => Ok(Interrupt::RTC),
                20 => Ok(Interrupt::FLASH),
                21 => Ok(Interrupt::RCC),
                22 => Ok(Interrupt::EXTI0),
                23 => Ok(Interrupt::EXTI1),
                24 => Ok(Interrupt::EXTI2),
                25 => Ok(Interrupt::EXTI3),
                26 => Ok(Interrupt::EXTI4),
                27 => Ok(Interrupt::DMA_CH1),
                28 => Ok(Interrupt::DMA_CH2),
                29 => Ok(Interrupt::DMA_CH3),
                30 => Ok(Interrupt::DMA_CH4),
                31 => Ok(Interrupt::DMA_CH5),
                32 => Ok(Interrupt::DMA_CH6),
                33 => Ok(Interrupt::DMA_CH7),
                34 => Ok(Interrupt::ADC),
                35 => Ok(Interrupt::USB_HP_CAN_TX),
                36 => Ok(Interrupt::USB_LP_CAN_RX0),
                37 => Ok(Interrupt::CAN_RX1),
                38 => Ok(Interrupt::CAN_SCE),
                39 => Ok(Interrupt::EXTI9_5),
                40 => Ok(Interrupt::TIM1_BRK),
                41 => Ok(Interrupt::TIM1_UP_),
                42 => Ok(Interrupt::TIM1_TRG_COM),
                43 => Ok(Interrupt::TIM1_CC),
                44 => Ok(Interrupt::TIM2),
                45 => Ok(Interrupt::TIM3),
                46 => Ok(Interrupt::TIM4),
                47 => Ok(Interrupt::I2C1_EV),
                48 => Ok(Interrupt::I2C1_ER),
                49 => Ok(Interrupt::I2C2_EV),
                50 => Ok(Interrupt::I2C2_ER),
                51 => Ok(Interrupt::SPI1),
                52 => Ok(Interrupt::SPI2),
                53 => Ok(Interrupt::USART1),
                54 => Ok(Interrupt::USART2),
                55 => Ok(Interrupt::USART3),
                56 => Ok(Interrupt::EXTI15_10),
                57 => Ok(Interrupt::RTCALARM),
                58 => Ok(Interrupt::LPTIM_WKUP),
                59 => Ok(Interrupt::USBFS),
                60 => Ok(Interrupt::USBFS_WKUP),
                61 => Ok(Interrupt::UART4),
                62 => Ok(Interrupt::DMA_CH8),
                63 => Ok(Interrupt::LPTIM),
                64 => Ok(Interrupt::OPA),
                65 => Ok(Interrupt::USBPD),
                66 => Ok(Interrupt::TKEY_WKUP),
                67 => Ok(Interrupt::USBPD_WKUP),
                _ => Err(TryFromInterruptError(())),
            }
        }
    }
    #[cfg(feature = "rt")]
    #[macro_export]
    /// Assigns a handler to an interrupt
    ///
    /// This macro takes two arguments: the name of an interrupt and the path to the
    /// function that will be used as the handler of that interrupt. That function
    /// must have signature `fn()`.
    ///
    /// Optionally, a third argument may be used to declare interrupt local data.
    /// The handler will have exclusive access to these *local* variables on each
    /// invocation. If the third argument is used then the signature of the handler
    /// function must be `fn(&mut $NAME::Locals)` where `$NAME` is the first argument
    /// passed to the macro.
    ///
    /// # Example
    ///
    /// ``` ignore
    /// interrupt!(TIM2, periodic);
    ///
    /// fn periodic() {
    ///     print!(".");
    /// }
    ///
    /// interrupt!(TIM3, tick, locals: {
    ///     tick: bool = false;
    /// });
    ///
    /// fn tick(locals: &mut TIM3::Locals) {
    ///     locals.tick = !locals.tick;
    ///
    ///     if locals.tick {
    ///         println!("Tick");
    ///     } else {
    ///         println!("Tock");
    ///     }
    /// }
    /// ```
    macro_rules ! interrupt { ($ NAME : ident , $ path : path , locals : { $ ($ lvar : ident : $ lty : ty = $ lval : expr ;) * }) => { # [allow (non_snake_case)]
mod $ NAME { pub struct Locals { $ (pub $ lvar : $ lty ,) * } } # [allow (non_snake_case)]
# [no_mangle]
pub extern "C" fn $ NAME () { let _ = $ crate :: interrupt :: Interrupt :: $ NAME ; static mut LOCALS : self :: $ NAME :: Locals = self :: $ NAME :: Locals { $ ($ lvar : $ lval ,) * } ; let f : fn (& mut self :: $ NAME :: Locals) = $ path ; f (unsafe { & mut LOCALS }) ; } } ; ($ NAME : ident , $ path : path) => { # [allow (non_snake_case)]
# [no_mangle]
pub extern "C" fn $ NAME () { let _ = $ crate :: interrupt :: Interrupt :: $ NAME ; let f : fn () = $ path ; f () ; } } }
}
pub use self::interrupt::Interrupt;
///Controller area network
pub struct CAN {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for CAN {}
impl CAN {
    ///Pointer to the register block
    pub const PTR: *const can::RegisterBlock = 0x4000_6400 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const can::RegisterBlock {
        Self::PTR
    }
    /// Steal an instance of this peripheral
    ///
    /// # Safety
    ///
    /// Ensure that the new instance of the peripheral cannot be used in a way
    /// that may race with any existing instances, for example by only
    /// accessing read-only or write-only registers, or by consuming the
    /// original peripheral and using critical sections to coordinate
    /// access between multiple new instances.
    ///
    /// Additionally, other software such as HALs may rely on only one
    /// peripheral instance existing to ensure memory safety; ensure
    /// no stolen instances are passed to such software.
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for CAN {
    type Target = can::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for CAN {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("CAN").finish()
    }
}
///Controller area network
pub mod can {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        ctlr: CTLR,
        statr: STATR,
        tstatr: TSTATR,
        rfifo0: RFIFO0,
        rfifo1: RFIFO1,
        intenr: INTENR,
        errsr: ERRSR,
        btimr: BTIMR,
        ttctlr: TTCTLR,
        ttcnt: TTCNT,
        terr_cnt: TERR_CNT,
        cr: CR,
        btr: BTR,
        tdct: TDCT,
        psr: PSR,
        dma_t0: DMA_T0,
        dma_t1: DMA_T1,
        dma_t2: DMA_T2,
        dma_r0: DMA_R0,
        dma_r1: DMA_R1,
        _reserved20: [u8; 0x0130],
        txmir0: TXMIR0,
        txmdtr0: TXMDTR0,
        txmdlr0: TXMDLR0,
        txmdhr0: TXMDHR0,
        txmir1: TXMIR1,
        txmdtr1: TXMDTR1,
        txmdlr1: TXMDLR1,
        txmdhr1: TXMDHR1,
        txmir2: TXMIR2,
        txmdtr2: TXMDTR2,
        txmdlr2: TXMDLR2,
        txmdhr2: TXMDHR2,
        rxmir0: RXMIR0,
        rxmdtr0: RXMDTR0,
        rxmdlr0: RXMDLR0,
        rxmdhr0: RXMDHR0,
        rxmir1: RXMIR1,
        rxmdtr1: RXMDTR1,
        rxmdlr1: RXMDLR1,
        rxmdhr1: RXMDHR1,
        _reserved40: [u8; 0x30],
        fctlr: FCTLR,
        fmcfgr: FMCFGR,
        _reserved42: [u8; 0x04],
        fscfgr: FSCFGR,
        _reserved43: [u8; 0x04],
        fafifor: FAFIFOR,
        _reserved44: [u8; 0x04],
        fwr: FWR,
        _reserved45: [u8; 0x20],
        f0r1: F0R1,
        f0r2: F0R2,
        f1r1: F1R1,
        f1r2: F1R2,
        f2r1: F2R1,
        f2r2: F2R2,
        f3r1: F3R1,
        f3r2: F3R2,
        f4r1: F4R1,
        f4r2: F4R2,
        f5r1: F5R1,
        f5r2: F5R2,
        f6r1: F6R1,
        f6r2: F6R2,
        f7r1: F7R1,
        f7r2: F7R2,
        f8r1: F8R1,
        f8r2: F8R2,
        f9r1: F9R1,
        f9r2: F9R2,
        f10r1: F10R1,
        f10r2: F10R2,
        f11r1: F11R1,
        f11r2: F11R2,
        f12r1: F12R1,
        f12r2: F12R2,
        f13r1: F13R1,
        f13r2: F13R2,
    }
    impl RegisterBlock {
        ///0x00 - CAN Master control register
        #[inline(always)]
        pub const fn ctlr(&self) -> &CTLR {
            &self.ctlr
        }
        ///0x04 - CAN master status register
        #[inline(always)]
        pub const fn statr(&self) -> &STATR {
            &self.statr
        }
        ///0x08 - CAN transmit status register
        #[inline(always)]
        pub const fn tstatr(&self) -> &TSTATR {
            &self.tstatr
        }
        ///0x0c - CAN receive FIFO 0 register
        #[inline(always)]
        pub const fn rfifo0(&self) -> &RFIFO0 {
            &self.rfifo0
        }
        ///0x10 - CAN receive FIFO 1 register
        #[inline(always)]
        pub const fn rfifo1(&self) -> &RFIFO1 {
            &self.rfifo1
        }
        ///0x14 - CAN interrupt enable register
        #[inline(always)]
        pub const fn intenr(&self) -> &INTENR {
            &self.intenr
        }
        ///0x18 - CAN error status register
        #[inline(always)]
        pub const fn errsr(&self) -> &ERRSR {
            &self.errsr
        }
        ///0x1c - CAN bit timing register
        #[inline(always)]
        pub const fn btimr(&self) -> &BTIMR {
            &self.btimr
        }
        ///0x20 - CAN time trigger control register
        #[inline(always)]
        pub const fn ttctlr(&self) -> &TTCTLR {
            &self.ttctlr
        }
        ///0x24 - CAN Time Trigger Count Value Register
        #[inline(always)]
        pub const fn ttcnt(&self) -> &TTCNT {
            &self.ttcnt
        }
        ///0x28 - CAN offline recovery error counter
        #[inline(always)]
        pub const fn terr_cnt(&self) -> &TERR_CNT {
            &self.terr_cnt
        }
        ///0x2c - CANFD control register
        #[inline(always)]
        pub const fn cr(&self) -> &CR {
            &self.cr
        }
        ///0x30 - CANFD Sequential register
        #[inline(always)]
        pub const fn btr(&self) -> &BTR {
            &self.btr
        }
        ///0x34 - CANFD Send delay compensation register
        #[inline(always)]
        pub const fn tdct(&self) -> &TDCT {
            &self.tdct
        }
        ///0x38 - CANFD Send delay compensation value register
        #[inline(always)]
        pub const fn psr(&self) -> &PSR {
            &self.psr
        }
        ///0x3c - CANFD DMA send mailbox 0 address register
        #[inline(always)]
        pub const fn dma_t0(&self) -> &DMA_T0 {
            &self.dma_t0
        }
        ///0x40 - CANFD DMA send mailbox 1 address register
        #[inline(always)]
        pub const fn dma_t1(&self) -> &DMA_T1 {
            &self.dma_t1
        }
        ///0x44 - CANFD DMA send mailbox 2 address register
        #[inline(always)]
        pub const fn dma_t2(&self) -> &DMA_T2 {
            &self.dma_t2
        }
        ///0x48 - CANFD DMA receives mailbox 0 address register
        #[inline(always)]
        pub const fn dma_r0(&self) -> &DMA_R0 {
            &self.dma_r0
        }
        ///0x4c - CANFD DMA receives mailbox 1 address register
        #[inline(always)]
        pub const fn dma_r1(&self) -> &DMA_R1 {
            &self.dma_r1
        }
        ///0x180 - CAN TX mailbox identifier register
        #[inline(always)]
        pub const fn txmir0(&self) -> &TXMIR0 {
            &self.txmir0
        }
        ///0x184 - CAN mailbox data length control and time stamp register
        #[inline(always)]
        pub const fn txmdtr0(&self) -> &TXMDTR0 {
            &self.txmdtr0
        }
        ///0x188 - CAN mailbox data low register
        #[inline(always)]
        pub const fn txmdlr0(&self) -> &TXMDLR0 {
            &self.txmdlr0
        }
        ///0x18c - CAN mailbox data high register
        #[inline(always)]
        pub const fn txmdhr0(&self) -> &TXMDHR0 {
            &self.txmdhr0
        }
        ///0x190 - CAN TX mailbox identifier register
        #[inline(always)]
        pub const fn txmir1(&self) -> &TXMIR1 {
            &self.txmir1
        }
        ///0x194 - CAN mailbox data length control and time stamp register
        #[inline(always)]
        pub const fn txmdtr1(&self) -> &TXMDTR1 {
            &self.txmdtr1
        }
        ///0x198 - CAN mailbox data low register
        #[inline(always)]
        pub const fn txmdlr1(&self) -> &TXMDLR1 {
            &self.txmdlr1
        }
        ///0x19c - CAN mailbox data high register
        #[inline(always)]
        pub const fn txmdhr1(&self) -> &TXMDHR1 {
            &self.txmdhr1
        }
        ///0x1a0 - CAN TX mailbox identifier register
        #[inline(always)]
        pub const fn txmir2(&self) -> &TXMIR2 {
            &self.txmir2
        }
        ///0x1a4 - CAN mailbox data length control and time stamp register
        #[inline(always)]
        pub const fn txmdtr2(&self) -> &TXMDTR2 {
            &self.txmdtr2
        }
        ///0x1a8 - CAN mailbox data low register
        #[inline(always)]
        pub const fn txmdlr2(&self) -> &TXMDLR2 {
            &self.txmdlr2
        }
        ///0x1ac - CAN mailbox data high register
        #[inline(always)]
        pub const fn txmdhr2(&self) -> &TXMDHR2 {
            &self.txmdhr2
        }
        ///0x1b0 - CAN receive FIFO mailbox identifier register
        #[inline(always)]
        pub const fn rxmir0(&self) -> &RXMIR0 {
            &self.rxmir0
        }
        ///0x1b4 - CAN receive FIFO mailbox data length control and time stamp register
        #[inline(always)]
        pub const fn rxmdtr0(&self) -> &RXMDTR0 {
            &self.rxmdtr0
        }
        ///0x1b8 - CAN receive FIFO mailbox data low register
        #[inline(always)]
        pub const fn rxmdlr0(&self) -> &RXMDLR0 {
            &self.rxmdlr0
        }
        ///0x1bc - CAN receive FIFO mailbox data high register
        #[inline(always)]
        pub const fn rxmdhr0(&self) -> &RXMDHR0 {
            &self.rxmdhr0
        }
        ///0x1c0 - CAN receive FIFO mailbox identifier register
        #[inline(always)]
        pub const fn rxmir1(&self) -> &RXMIR1 {
            &self.rxmir1
        }
        ///0x1c4 - CAN receive FIFO mailbox data length control and time stamp register
        #[inline(always)]
        pub const fn rxmdtr1(&self) -> &RXMDTR1 {
            &self.rxmdtr1
        }
        ///0x1c8 - CAN receive FIFO mailbox data low register
        #[inline(always)]
        pub const fn rxmdlr1(&self) -> &RXMDLR1 {
            &self.rxmdlr1
        }
        ///0x1cc - CAN receive FIFO mailbox data high register
        #[inline(always)]
        pub const fn rxmdhr1(&self) -> &RXMDHR1 {
            &self.rxmdhr1
        }
        ///0x200 - CAN filter master register
        #[inline(always)]
        pub const fn fctlr(&self) -> &FCTLR {
            &self.fctlr
        }
        ///0x204 - CAN filter mode register
        #[inline(always)]
        pub const fn fmcfgr(&self) -> &FMCFGR {
            &self.fmcfgr
        }
        ///0x20c - CAN filter scale register
        #[inline(always)]
        pub const fn fscfgr(&self) -> &FSCFGR {
            &self.fscfgr
        }
        ///0x214 - CAN filter FIFO assignment register
        #[inline(always)]
        pub const fn fafifor(&self) -> &FAFIFOR {
            &self.fafifor
        }
        ///0x21c - CAN filter activation register
        #[inline(always)]
        pub const fn fwr(&self) -> &FWR {
            &self.fwr
        }
        ///0x240 - Filter bank 0 register 1
        #[inline(always)]
        pub const fn f0r1(&self) -> &F0R1 {
            &self.f0r1
        }
        ///0x244 - Filter bank 0 register 2
        #[inline(always)]
        pub const fn f0r2(&self) -> &F0R2 {
            &self.f0r2
        }
        ///0x248 - Filter bank 1 register 1
        #[inline(always)]
        pub const fn f1r1(&self) -> &F1R1 {
            &self.f1r1
        }
        ///0x24c - Filter bank 1 register 2
        #[inline(always)]
        pub const fn f1r2(&self) -> &F1R2 {
            &self.f1r2
        }
        ///0x250 - Filter bank 2 register 1
        #[inline(always)]
        pub const fn f2r1(&self) -> &F2R1 {
            &self.f2r1
        }
        ///0x254 - Filter bank 2 register 2
        #[inline(always)]
        pub const fn f2r2(&self) -> &F2R2 {
            &self.f2r2
        }
        ///0x258 - Filter bank 3 register 1
        #[inline(always)]
        pub const fn f3r1(&self) -> &F3R1 {
            &self.f3r1
        }
        ///0x25c - Filter bank 3 register 2
        #[inline(always)]
        pub const fn f3r2(&self) -> &F3R2 {
            &self.f3r2
        }
        ///0x260 - Filter bank 4 register 1
        #[inline(always)]
        pub const fn f4r1(&self) -> &F4R1 {
            &self.f4r1
        }
        ///0x264 - Filter bank 4 register 2
        #[inline(always)]
        pub const fn f4r2(&self) -> &F4R2 {
            &self.f4r2
        }
        ///0x268 - Filter bank 5 register 1
        #[inline(always)]
        pub const fn f5r1(&self) -> &F5R1 {
            &self.f5r1
        }
        ///0x26c - Filter bank 5 register 2
        #[inline(always)]
        pub const fn f5r2(&self) -> &F5R2 {
            &self.f5r2
        }
        ///0x270 - Filter bank 6 register 1
        #[inline(always)]
        pub const fn f6r1(&self) -> &F6R1 {
            &self.f6r1
        }
        ///0x274 - Filter bank 6 register 2
        #[inline(always)]
        pub const fn f6r2(&self) -> &F6R2 {
            &self.f6r2
        }
        ///0x278 - Filter bank 7 register 1
        #[inline(always)]
        pub const fn f7r1(&self) -> &F7R1 {
            &self.f7r1
        }
        ///0x27c - Filter bank 7 register 2
        #[inline(always)]
        pub const fn f7r2(&self) -> &F7R2 {
            &self.f7r2
        }
        ///0x280 - Filter bank 8 register 1
        #[inline(always)]
        pub const fn f8r1(&self) -> &F8R1 {
            &self.f8r1
        }
        ///0x284 - Filter bank 8 register 2
        #[inline(always)]
        pub const fn f8r2(&self) -> &F8R2 {
            &self.f8r2
        }
        ///0x288 - Filter bank 9 register 1
        #[inline(always)]
        pub const fn f9r1(&self) -> &F9R1 {
            &self.f9r1
        }
        ///0x28c - Filter bank 9 register 2
        #[inline(always)]
        pub const fn f9r2(&self) -> &F9R2 {
            &self.f9r2
        }
        ///0x290 - Filter bank 10 register 1
        #[inline(always)]
        pub const fn f10r1(&self) -> &F10R1 {
            &self.f10r1
        }
        ///0x294 - Filter bank 10 register 2
        #[inline(always)]
        pub const fn f10r2(&self) -> &F10R2 {
            &self.f10r2
        }
        ///0x298 - Filter bank 11 register 1
        #[inline(always)]
        pub const fn f11r1(&self) -> &F11R1 {
            &self.f11r1
        }
        ///0x29c - Filter bank 11 register 2
        #[inline(always)]
        pub const fn f11r2(&self) -> &F11R2 {
            &self.f11r2
        }
        ///0x2a0 - Filter bank 4 register 1
        #[inline(always)]
        pub const fn f12r1(&self) -> &F12R1 {
            &self.f12r1
        }
        ///0x2a4 - Filter bank 12 register 2
        #[inline(always)]
        pub const fn f12r2(&self) -> &F12R2 {
            &self.f12r2
        }
        ///0x2a8 - Filter bank 13 register 1
        #[inline(always)]
        pub const fn f13r1(&self) -> &F13R1 {
            &self.f13r1
        }
        ///0x2ac - Filter bank 13 register 2
        #[inline(always)]
        pub const fn f13r2(&self) -> &F13R2 {
            &self.f13r2
        }
    }
    ///CTLR (rw) register accessor: CAN Master control register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`ctlr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ctlr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@ctlr`]
    ///module
    pub type CTLR = crate::Reg<ctlr::CTLR_SPEC>;
    ///CAN Master control register
    pub mod ctlr {
        ///Register `CTLR` reader
        pub type R = crate::R<CTLR_SPEC>;
        ///Register `CTLR` writer
        pub type W = crate::W<CTLR_SPEC>;
        ///Field `INRQ` reader - Initialization request
        pub type INRQ_R = crate::BitReader;
        ///Field `INRQ` writer - Initialization request
        pub type INRQ_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `SLEEP` reader - Sleep mode request bit
        pub type SLEEP_R = crate::BitReader;
        ///Field `SLEEP` writer - Sleep mode request bit
        pub type SLEEP_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TXFP` reader - Transmit FIFO priority
        pub type TXFP_R = crate::BitReader;
        ///Field `TXFP` writer - Transmit FIFO priority
        pub type TXFP_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `RFLM` reader - Receive FIFO locked mode
        pub type RFLM_R = crate::BitReader;
        ///Field `RFLM` writer - Receive FIFO locked mode
        pub type RFLM_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `NART` reader - No automatic retransmission
        pub type NART_R = crate::BitReader;
        ///Field `NART` writer - No automatic retransmission
        pub type NART_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `AWUM` reader - Automatic wakeup mode
        pub type AWUM_R = crate::BitReader;
        ///Field `AWUM` writer - Automatic wakeup mode
        pub type AWUM_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `ABOM` reader - Automatic bus-off management
        pub type ABOM_R = crate::BitReader;
        ///Field `ABOM` writer - Automatic bus-off management
        pub type ABOM_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TTCM` reader - Time triggered communication mode
        pub type TTCM_R = crate::BitReader;
        ///Field `TTCM` writer - Time triggered communication mode
        pub type TTCM_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `RST` reader - Software master reset
        pub type RST_R = crate::BitReader;
        ///Field `RST` writer - Software master reset
        pub type RST_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `DBF` reader - Debug freeze
        pub type DBF_R = crate::BitReader;
        ///Field `DBF` writer - Debug freeze
        pub type DBF_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - Initialization request
            #[inline(always)]
            pub fn inrq(&self) -> INRQ_R {
                INRQ_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Sleep mode request bit
            #[inline(always)]
            pub fn sleep(&self) -> SLEEP_R {
                SLEEP_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - Transmit FIFO priority
            #[inline(always)]
            pub fn txfp(&self) -> TXFP_R {
                TXFP_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - Receive FIFO locked mode
            #[inline(always)]
            pub fn rflm(&self) -> RFLM_R {
                RFLM_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - No automatic retransmission
            #[inline(always)]
            pub fn nart(&self) -> NART_R {
                NART_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - Automatic wakeup mode
            #[inline(always)]
            pub fn awum(&self) -> AWUM_R {
                AWUM_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - Automatic bus-off management
            #[inline(always)]
            pub fn abom(&self) -> ABOM_R {
                ABOM_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - Time triggered communication mode
            #[inline(always)]
            pub fn ttcm(&self) -> TTCM_R {
                TTCM_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bit 15 - Software master reset
            #[inline(always)]
            pub fn rst(&self) -> RST_R {
                RST_R::new(((self.bits >> 15) & 1) != 0)
            }
            ///Bit 16 - Debug freeze
            #[inline(always)]
            pub fn dbf(&self) -> DBF_R {
                DBF_R::new(((self.bits >> 16) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - Initialization request
            #[inline(always)]
            #[must_use]
            pub fn inrq(&mut self) -> INRQ_W<CTLR_SPEC> {
                INRQ_W::new(self, 0)
            }
            ///Bit 1 - Sleep mode request bit
            #[inline(always)]
            #[must_use]
            pub fn sleep(&mut self) -> SLEEP_W<CTLR_SPEC> {
                SLEEP_W::new(self, 1)
            }
            ///Bit 2 - Transmit FIFO priority
            #[inline(always)]
            #[must_use]
            pub fn txfp(&mut self) -> TXFP_W<CTLR_SPEC> {
                TXFP_W::new(self, 2)
            }
            ///Bit 3 - Receive FIFO locked mode
            #[inline(always)]
            #[must_use]
            pub fn rflm(&mut self) -> RFLM_W<CTLR_SPEC> {
                RFLM_W::new(self, 3)
            }
            ///Bit 4 - No automatic retransmission
            #[inline(always)]
            #[must_use]
            pub fn nart(&mut self) -> NART_W<CTLR_SPEC> {
                NART_W::new(self, 4)
            }
            ///Bit 5 - Automatic wakeup mode
            #[inline(always)]
            #[must_use]
            pub fn awum(&mut self) -> AWUM_W<CTLR_SPEC> {
                AWUM_W::new(self, 5)
            }
            ///Bit 6 - Automatic bus-off management
            #[inline(always)]
            #[must_use]
            pub fn abom(&mut self) -> ABOM_W<CTLR_SPEC> {
                ABOM_W::new(self, 6)
            }
            ///Bit 7 - Time triggered communication mode
            #[inline(always)]
            #[must_use]
            pub fn ttcm(&mut self) -> TTCM_W<CTLR_SPEC> {
                TTCM_W::new(self, 7)
            }
            ///Bit 15 - Software master reset
            #[inline(always)]
            #[must_use]
            pub fn rst(&mut self) -> RST_W<CTLR_SPEC> {
                RST_W::new(self, 15)
            }
            ///Bit 16 - Debug freeze
            #[inline(always)]
            #[must_use]
            pub fn dbf(&mut self) -> DBF_W<CTLR_SPEC> {
                DBF_W::new(self, 16)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///CAN Master control register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`ctlr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ctlr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct CTLR_SPEC;
        impl crate::RegisterSpec for CTLR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`ctlr::R`](R) reader structure
        impl crate::Readable for CTLR_SPEC {}
        ///`write(|w| ..)` method takes [`ctlr::W`](W) writer structure
        impl crate::Writable for CTLR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets CTLR to value 0x0001_0002
        impl crate::Resettable for CTLR_SPEC {
            const RESET_VALUE: u32 = 0x0001_0002;
        }
    }
    ///STATR (rw) register accessor: CAN master status register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`statr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`statr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@statr`]
    ///module
    pub type STATR = crate::Reg<statr::STATR_SPEC>;
    ///CAN master status register
    pub mod statr {
        ///Register `STATR` reader
        pub type R = crate::R<STATR_SPEC>;
        ///Register `STATR` writer
        pub type W = crate::W<STATR_SPEC>;
        ///Field `INAK` reader - Initialization acknowledge
        pub type INAK_R = crate::BitReader;
        ///Field `SLAK` reader - Sleep acknowledge
        pub type SLAK_R = crate::BitReader;
        ///Field `ERRI` reader - Error interrupt
        pub type ERRI_R = crate::BitReader;
        ///Field `ERRI` writer - Error interrupt
        pub type ERRI_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `WKUI` reader - Wakeup interrupt
        pub type WKUI_R = crate::BitReader;
        ///Field `WKUI` writer - Wakeup interrupt
        pub type WKUI_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `SLAKI` reader - Sleep acknowledge interrupt
        pub type SLAKI_R = crate::BitReader;
        ///Field `SLAKI` writer - Sleep acknowledge interrupt
        pub type SLAKI_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TXM` reader - Transmit mode
        pub type TXM_R = crate::BitReader;
        ///Field `RXM` reader - Receive mode
        pub type RXM_R = crate::BitReader;
        ///Field `SAMP` reader - Last sample point
        pub type SAMP_R = crate::BitReader;
        ///Field `RX` reader - Rx signal
        pub type RX_R = crate::BitReader;
        impl R {
            ///Bit 0 - Initialization acknowledge
            #[inline(always)]
            pub fn inak(&self) -> INAK_R {
                INAK_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Sleep acknowledge
            #[inline(always)]
            pub fn slak(&self) -> SLAK_R {
                SLAK_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - Error interrupt
            #[inline(always)]
            pub fn erri(&self) -> ERRI_R {
                ERRI_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - Wakeup interrupt
            #[inline(always)]
            pub fn wkui(&self) -> WKUI_R {
                WKUI_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - Sleep acknowledge interrupt
            #[inline(always)]
            pub fn slaki(&self) -> SLAKI_R {
                SLAKI_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 8 - Transmit mode
            #[inline(always)]
            pub fn txm(&self) -> TXM_R {
                TXM_R::new(((self.bits >> 8) & 1) != 0)
            }
            ///Bit 9 - Receive mode
            #[inline(always)]
            pub fn rxm(&self) -> RXM_R {
                RXM_R::new(((self.bits >> 9) & 1) != 0)
            }
            ///Bit 10 - Last sample point
            #[inline(always)]
            pub fn samp(&self) -> SAMP_R {
                SAMP_R::new(((self.bits >> 10) & 1) != 0)
            }
            ///Bit 11 - Rx signal
            #[inline(always)]
            pub fn rx(&self) -> RX_R {
                RX_R::new(((self.bits >> 11) & 1) != 0)
            }
        }
        impl W {
            ///Bit 2 - Error interrupt
            #[inline(always)]
            #[must_use]
            pub fn erri(&mut self) -> ERRI_W<STATR_SPEC> {
                ERRI_W::new(self, 2)
            }
            ///Bit 3 - Wakeup interrupt
            #[inline(always)]
            #[must_use]
            pub fn wkui(&mut self) -> WKUI_W<STATR_SPEC> {
                WKUI_W::new(self, 3)
            }
            ///Bit 4 - Sleep acknowledge interrupt
            #[inline(always)]
            #[must_use]
            pub fn slaki(&mut self) -> SLAKI_W<STATR_SPEC> {
                SLAKI_W::new(self, 4)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///CAN master status register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`statr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`statr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct STATR_SPEC;
        impl crate::RegisterSpec for STATR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`statr::R`](R) reader structure
        impl crate::Readable for STATR_SPEC {}
        ///`write(|w| ..)` method takes [`statr::W`](W) writer structure
        impl crate::Writable for STATR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets STATR to value 0x0c02
        impl crate::Resettable for STATR_SPEC {
            const RESET_VALUE: u32 = 0x0c02;
        }
    }
    ///TSTATR (rw) register accessor: CAN transmit status register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`tstatr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`tstatr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@tstatr`]
    ///module
    pub type TSTATR = crate::Reg<tstatr::TSTATR_SPEC>;
    ///CAN transmit status register
    pub mod tstatr {
        ///Register `TSTATR` reader
        pub type R = crate::R<TSTATR_SPEC>;
        ///Register `TSTATR` writer
        pub type W = crate::W<TSTATR_SPEC>;
        ///Field `RQCP0` reader - Request completed mailbox0
        pub type RQCP0_R = crate::BitReader;
        ///Field `RQCP0` writer - Request completed mailbox0
        pub type RQCP0_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TXOK0` reader - Transmission OK of mailbox0
        pub type TXOK0_R = crate::BitReader;
        ///Field `TXOK0` writer - Transmission OK of mailbox0
        pub type TXOK0_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `ALST0` reader - Arbitration lost for mailbox0
        pub type ALST0_R = crate::BitReader;
        ///Field `ALST0` writer - Arbitration lost for mailbox0
        pub type ALST0_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TERR0` reader - Transmission error of mailbox0
        pub type TERR0_R = crate::BitReader;
        ///Field `TERR0` writer - Transmission error of mailbox0
        pub type TERR0_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `ABRQ0` reader - Abort request for mailbox0
        pub type ABRQ0_R = crate::BitReader;
        ///Field `ABRQ0` writer - Abort request for mailbox0
        pub type ABRQ0_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `RQCP1` reader - Request completed mailbox1
        pub type RQCP1_R = crate::BitReader;
        ///Field `RQCP1` writer - Request completed mailbox1
        pub type RQCP1_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TXOK1` reader - Transmission OK of mailbox1
        pub type TXOK1_R = crate::BitReader;
        ///Field `TXOK1` writer - Transmission OK of mailbox1
        pub type TXOK1_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `ALST1` reader - Arbitration lost for mailbox1
        pub type ALST1_R = crate::BitReader;
        ///Field `ALST1` writer - Arbitration lost for mailbox1
        pub type ALST1_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TERR1` reader - Transmission error of mailbox1
        pub type TERR1_R = crate::BitReader;
        ///Field `TERR1` writer - Transmission error of mailbox1
        pub type TERR1_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `ABRQ1` reader - Abort request for mailbox 1
        pub type ABRQ1_R = crate::BitReader;
        ///Field `ABRQ1` writer - Abort request for mailbox 1
        pub type ABRQ1_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `RQCP2` reader - Request completed mailbox2
        pub type RQCP2_R = crate::BitReader;
        ///Field `RQCP2` writer - Request completed mailbox2
        pub type RQCP2_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TXOK2` reader - Transmission OK of mailbox 2
        pub type TXOK2_R = crate::BitReader;
        ///Field `TXOK2` writer - Transmission OK of mailbox 2
        pub type TXOK2_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `ALST2` reader - Arbitration lost for mailbox 2
        pub type ALST2_R = crate::BitReader;
        ///Field `ALST2` writer - Arbitration lost for mailbox 2
        pub type ALST2_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TERR2` reader - Transmission error of mailbox 2
        pub type TERR2_R = crate::BitReader;
        ///Field `TERR2` writer - Transmission error of mailbox 2
        pub type TERR2_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `ABRQ2` reader - Abort request for mailbox 2
        pub type ABRQ2_R = crate::BitReader;
        ///Field `ABRQ2` writer - Abort request for mailbox 2
        pub type ABRQ2_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CODE` reader - Mailbox code
        pub type CODE_R = crate::FieldReader;
        ///Field `TME0` reader - Transmit mailbox 0 empty
        pub type TME0_R = crate::BitReader;
        ///Field `TME1` reader - Transmit mailbox 1 empty
        pub type TME1_R = crate::BitReader;
        ///Field `TME2` reader - Transmit mailbox 2 empty
        pub type TME2_R = crate::BitReader;
        ///Field `LOW0` reader - Lowest priority flag for mailbox0
        pub type LOW0_R = crate::BitReader;
        ///Field `LOW1` reader - Lowest priority flag for mailbox1
        pub type LOW1_R = crate::BitReader;
        ///Field `LOW2` reader - Lowest priority flag for mailbox2
        pub type LOW2_R = crate::BitReader;
        impl R {
            ///Bit 0 - Request completed mailbox0
            #[inline(always)]
            pub fn rqcp0(&self) -> RQCP0_R {
                RQCP0_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Transmission OK of mailbox0
            #[inline(always)]
            pub fn txok0(&self) -> TXOK0_R {
                TXOK0_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - Arbitration lost for mailbox0
            #[inline(always)]
            pub fn alst0(&self) -> ALST0_R {
                ALST0_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - Transmission error of mailbox0
            #[inline(always)]
            pub fn terr0(&self) -> TERR0_R {
                TERR0_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 7 - Abort request for mailbox0
            #[inline(always)]
            pub fn abrq0(&self) -> ABRQ0_R {
                ABRQ0_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bit 8 - Request completed mailbox1
            #[inline(always)]
            pub fn rqcp1(&self) -> RQCP1_R {
                RQCP1_R::new(((self.bits >> 8) & 1) != 0)
            }
            ///Bit 9 - Transmission OK of mailbox1
            #[inline(always)]
            pub fn txok1(&self) -> TXOK1_R {
                TXOK1_R::new(((self.bits >> 9) & 1) != 0)
            }
            ///Bit 10 - Arbitration lost for mailbox1
            #[inline(always)]
            pub fn alst1(&self) -> ALST1_R {
                ALST1_R::new(((self.bits >> 10) & 1) != 0)
            }
            ///Bit 11 - Transmission error of mailbox1
            #[inline(always)]
            pub fn terr1(&self) -> TERR1_R {
                TERR1_R::new(((self.bits >> 11) & 1) != 0)
            }
            ///Bit 15 - Abort request for mailbox 1
            #[inline(always)]
            pub fn abrq1(&self) -> ABRQ1_R {
                ABRQ1_R::new(((self.bits >> 15) & 1) != 0)
            }
            ///Bit 16 - Request completed mailbox2
            #[inline(always)]
            pub fn rqcp2(&self) -> RQCP2_R {
                RQCP2_R::new(((self.bits >> 16) & 1) != 0)
            }
            ///Bit 17 - Transmission OK of mailbox 2
            #[inline(always)]
            pub fn txok2(&self) -> TXOK2_R {
                TXOK2_R::new(((self.bits >> 17) & 1) != 0)
            }
            ///Bit 18 - Arbitration lost for mailbox 2
            #[inline(always)]
            pub fn alst2(&self) -> ALST2_R {
                ALST2_R::new(((self.bits >> 18) & 1) != 0)
            }
            ///Bit 19 - Transmission error of mailbox 2
            #[inline(always)]
            pub fn terr2(&self) -> TERR2_R {
                TERR2_R::new(((self.bits >> 19) & 1) != 0)
            }
            ///Bit 23 - Abort request for mailbox 2
            #[inline(always)]
            pub fn abrq2(&self) -> ABRQ2_R {
                ABRQ2_R::new(((self.bits >> 23) & 1) != 0)
            }
            ///Bits 24:25 - Mailbox code
            #[inline(always)]
            pub fn code(&self) -> CODE_R {
                CODE_R::new(((self.bits >> 24) & 3) as u8)
            }
            ///Bit 26 - Transmit mailbox 0 empty
            #[inline(always)]
            pub fn tme0(&self) -> TME0_R {
                TME0_R::new(((self.bits >> 26) & 1) != 0)
            }
            ///Bit 27 - Transmit mailbox 1 empty
            #[inline(always)]
            pub fn tme1(&self) -> TME1_R {
                TME1_R::new(((self.bits >> 27) & 1) != 0)
            }
            ///Bit 28 - Transmit mailbox 2 empty
            #[inline(always)]
            pub fn tme2(&self) -> TME2_R {
                TME2_R::new(((self.bits >> 28) & 1) != 0)
            }
            ///Bit 29 - Lowest priority flag for mailbox0
            #[inline(always)]
            pub fn low0(&self) -> LOW0_R {
                LOW0_R::new(((self.bits >> 29) & 1) != 0)
            }
            ///Bit 30 - Lowest priority flag for mailbox1
            #[inline(always)]
            pub fn low1(&self) -> LOW1_R {
                LOW1_R::new(((self.bits >> 30) & 1) != 0)
            }
            ///Bit 31 - Lowest priority flag for mailbox2
            #[inline(always)]
            pub fn low2(&self) -> LOW2_R {
                LOW2_R::new(((self.bits >> 31) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - Request completed mailbox0
            #[inline(always)]
            #[must_use]
            pub fn rqcp0(&mut self) -> RQCP0_W<TSTATR_SPEC> {
                RQCP0_W::new(self, 0)
            }
            ///Bit 1 - Transmission OK of mailbox0
            #[inline(always)]
            #[must_use]
            pub fn txok0(&mut self) -> TXOK0_W<TSTATR_SPEC> {
                TXOK0_W::new(self, 1)
            }
            ///Bit 2 - Arbitration lost for mailbox0
            #[inline(always)]
            #[must_use]
            pub fn alst0(&mut self) -> ALST0_W<TSTATR_SPEC> {
                ALST0_W::new(self, 2)
            }
            ///Bit 3 - Transmission error of mailbox0
            #[inline(always)]
            #[must_use]
            pub fn terr0(&mut self) -> TERR0_W<TSTATR_SPEC> {
                TERR0_W::new(self, 3)
            }
            ///Bit 7 - Abort request for mailbox0
            #[inline(always)]
            #[must_use]
            pub fn abrq0(&mut self) -> ABRQ0_W<TSTATR_SPEC> {
                ABRQ0_W::new(self, 7)
            }
            ///Bit 8 - Request completed mailbox1
            #[inline(always)]
            #[must_use]
            pub fn rqcp1(&mut self) -> RQCP1_W<TSTATR_SPEC> {
                RQCP1_W::new(self, 8)
            }
            ///Bit 9 - Transmission OK of mailbox1
            #[inline(always)]
            #[must_use]
            pub fn txok1(&mut self) -> TXOK1_W<TSTATR_SPEC> {
                TXOK1_W::new(self, 9)
            }
            ///Bit 10 - Arbitration lost for mailbox1
            #[inline(always)]
            #[must_use]
            pub fn alst1(&mut self) -> ALST1_W<TSTATR_SPEC> {
                ALST1_W::new(self, 10)
            }
            ///Bit 11 - Transmission error of mailbox1
            #[inline(always)]
            #[must_use]
            pub fn terr1(&mut self) -> TERR1_W<TSTATR_SPEC> {
                TERR1_W::new(self, 11)
            }
            ///Bit 15 - Abort request for mailbox 1
            #[inline(always)]
            #[must_use]
            pub fn abrq1(&mut self) -> ABRQ1_W<TSTATR_SPEC> {
                ABRQ1_W::new(self, 15)
            }
            ///Bit 16 - Request completed mailbox2
            #[inline(always)]
            #[must_use]
            pub fn rqcp2(&mut self) -> RQCP2_W<TSTATR_SPEC> {
                RQCP2_W::new(self, 16)
            }
            ///Bit 17 - Transmission OK of mailbox 2
            #[inline(always)]
            #[must_use]
            pub fn txok2(&mut self) -> TXOK2_W<TSTATR_SPEC> {
                TXOK2_W::new(self, 17)
            }
            ///Bit 18 - Arbitration lost for mailbox 2
            #[inline(always)]
            #[must_use]
            pub fn alst2(&mut self) -> ALST2_W<TSTATR_SPEC> {
                ALST2_W::new(self, 18)
            }
            ///Bit 19 - Transmission error of mailbox 2
            #[inline(always)]
            #[must_use]
            pub fn terr2(&mut self) -> TERR2_W<TSTATR_SPEC> {
                TERR2_W::new(self, 19)
            }
            ///Bit 23 - Abort request for mailbox 2
            #[inline(always)]
            #[must_use]
            pub fn abrq2(&mut self) -> ABRQ2_W<TSTATR_SPEC> {
                ABRQ2_W::new(self, 23)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///CAN transmit status register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`tstatr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`tstatr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct TSTATR_SPEC;
        impl crate::RegisterSpec for TSTATR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`tstatr::R`](R) reader structure
        impl crate::Readable for TSTATR_SPEC {}
        ///`write(|w| ..)` method takes [`tstatr::W`](W) writer structure
        impl crate::Writable for TSTATR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets TSTATR to value 0x1c00_0000
        impl crate::Resettable for TSTATR_SPEC {
            const RESET_VALUE: u32 = 0x1c00_0000;
        }
    }
    ///RFIFO0 (rw) register accessor: CAN receive FIFO 0 register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`rfifo0::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`rfifo0::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@rfifo0`]
    ///module
    pub type RFIFO0 = crate::Reg<rfifo0::RFIFO0_SPEC>;
    ///CAN receive FIFO 0 register
    pub mod rfifo0 {
        ///Register `RFIFO0` reader
        pub type R = crate::R<RFIFO0_SPEC>;
        ///Register `RFIFO0` writer
        pub type W = crate::W<RFIFO0_SPEC>;
        ///Field `FMP0` reader - FIFO 0 message pending
        pub type FMP0_R = crate::FieldReader;
        ///Field `FULL0` reader - FIFO 0 full
        pub type FULL0_R = crate::BitReader;
        ///Field `FULL0` writer - FIFO 0 full
        pub type FULL0_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FOVR0` reader - FIFO 0 overrun
        pub type FOVR0_R = crate::BitReader;
        ///Field `FOVR0` writer - FIFO 0 overrun
        pub type FOVR0_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `RFOM0` reader - Release FIFO 0 output mailbox
        pub type RFOM0_R = crate::BitReader;
        ///Field `RFOM0` writer - Release FIFO 0 output mailbox
        pub type RFOM0_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bits 0:1 - FIFO 0 message pending
            #[inline(always)]
            pub fn fmp0(&self) -> FMP0_R {
                FMP0_R::new((self.bits & 3) as u8)
            }
            ///Bit 3 - FIFO 0 full
            #[inline(always)]
            pub fn full0(&self) -> FULL0_R {
                FULL0_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - FIFO 0 overrun
            #[inline(always)]
            pub fn fovr0(&self) -> FOVR0_R {
                FOVR0_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - Release FIFO 0 output mailbox
            #[inline(always)]
            pub fn rfom0(&self) -> RFOM0_R {
                RFOM0_R::new(((self.bits >> 5) & 1) != 0)
            }
        }
        impl W {
            ///Bit 3 - FIFO 0 full
            #[inline(always)]
            #[must_use]
            pub fn full0(&mut self) -> FULL0_W<RFIFO0_SPEC> {
                FULL0_W::new(self, 3)
            }
            ///Bit 4 - FIFO 0 overrun
            #[inline(always)]
            #[must_use]
            pub fn fovr0(&mut self) -> FOVR0_W<RFIFO0_SPEC> {
                FOVR0_W::new(self, 4)
            }
            ///Bit 5 - Release FIFO 0 output mailbox
            #[inline(always)]
            #[must_use]
            pub fn rfom0(&mut self) -> RFOM0_W<RFIFO0_SPEC> {
                RFOM0_W::new(self, 5)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///CAN receive FIFO 0 register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`rfifo0::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`rfifo0::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct RFIFO0_SPEC;
        impl crate::RegisterSpec for RFIFO0_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`rfifo0::R`](R) reader structure
        impl crate::Readable for RFIFO0_SPEC {}
        ///`write(|w| ..)` method takes [`rfifo0::W`](W) writer structure
        impl crate::Writable for RFIFO0_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets RFIFO0 to value 0
        impl crate::Resettable for RFIFO0_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///RFIFO1 (rw) register accessor: CAN receive FIFO 1 register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`rfifo1::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`rfifo1::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@rfifo1`]
    ///module
    pub type RFIFO1 = crate::Reg<rfifo1::RFIFO1_SPEC>;
    ///CAN receive FIFO 1 register
    pub mod rfifo1 {
        ///Register `RFIFO1` reader
        pub type R = crate::R<RFIFO1_SPEC>;
        ///Register `RFIFO1` writer
        pub type W = crate::W<RFIFO1_SPEC>;
        ///Field `FMP1` reader - FIFO 1 message pending
        pub type FMP1_R = crate::FieldReader;
        ///Field `FULL1` reader - FIFO 1 full
        pub type FULL1_R = crate::BitReader;
        ///Field `FULL1` writer - FIFO 1 full
        pub type FULL1_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FOVR1` reader - FIFO 1 overrun
        pub type FOVR1_R = crate::BitReader;
        ///Field `FOVR1` writer - FIFO 1 overrun
        pub type FOVR1_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `RFOM1` reader - Release FIFO 1 output mailbox
        pub type RFOM1_R = crate::BitReader;
        ///Field `RFOM1` writer - Release FIFO 1 output mailbox
        pub type RFOM1_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bits 0:1 - FIFO 1 message pending
            #[inline(always)]
            pub fn fmp1(&self) -> FMP1_R {
                FMP1_R::new((self.bits & 3) as u8)
            }
            ///Bit 3 - FIFO 1 full
            #[inline(always)]
            pub fn full1(&self) -> FULL1_R {
                FULL1_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - FIFO 1 overrun
            #[inline(always)]
            pub fn fovr1(&self) -> FOVR1_R {
                FOVR1_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - Release FIFO 1 output mailbox
            #[inline(always)]
            pub fn rfom1(&self) -> RFOM1_R {
                RFOM1_R::new(((self.bits >> 5) & 1) != 0)
            }
        }
        impl W {
            ///Bit 3 - FIFO 1 full
            #[inline(always)]
            #[must_use]
            pub fn full1(&mut self) -> FULL1_W<RFIFO1_SPEC> {
                FULL1_W::new(self, 3)
            }
            ///Bit 4 - FIFO 1 overrun
            #[inline(always)]
            #[must_use]
            pub fn fovr1(&mut self) -> FOVR1_W<RFIFO1_SPEC> {
                FOVR1_W::new(self, 4)
            }
            ///Bit 5 - Release FIFO 1 output mailbox
            #[inline(always)]
            #[must_use]
            pub fn rfom1(&mut self) -> RFOM1_W<RFIFO1_SPEC> {
                RFOM1_W::new(self, 5)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///CAN receive FIFO 1 register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`rfifo1::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`rfifo1::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct RFIFO1_SPEC;
        impl crate::RegisterSpec for RFIFO1_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`rfifo1::R`](R) reader structure
        impl crate::Readable for RFIFO1_SPEC {}
        ///`write(|w| ..)` method takes [`rfifo1::W`](W) writer structure
        impl crate::Writable for RFIFO1_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets RFIFO1 to value 0
        impl crate::Resettable for RFIFO1_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///INTENR (rw) register accessor: CAN interrupt enable register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`intenr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`intenr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@intenr`]
    ///module
    pub type INTENR = crate::Reg<intenr::INTENR_SPEC>;
    ///CAN interrupt enable register
    pub mod intenr {
        ///Register `INTENR` reader
        pub type R = crate::R<INTENR_SPEC>;
        ///Register `INTENR` writer
        pub type W = crate::W<INTENR_SPEC>;
        ///Field `TMEIE` reader - Transmit mailbox empty interrupt enable
        pub type TMEIE_R = crate::BitReader;
        ///Field `TMEIE` writer - Transmit mailbox empty interrupt enable
        pub type TMEIE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FMPIE0` reader - FIFO message pending interrupt enable
        pub type FMPIE0_R = crate::BitReader;
        ///Field `FMPIE0` writer - FIFO message pending interrupt enable
        pub type FMPIE0_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FFIE0` reader - FIFO full interrupt enable
        pub type FFIE0_R = crate::BitReader;
        ///Field `FFIE0` writer - FIFO full interrupt enable
        pub type FFIE0_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FOVIE0` reader - FIFO overrun interrupt enable
        pub type FOVIE0_R = crate::BitReader;
        ///Field `FOVIE0` writer - FIFO overrun interrupt enable
        pub type FOVIE0_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FMPIE1` reader - FIFO message pending interrupt enable
        pub type FMPIE1_R = crate::BitReader;
        ///Field `FMPIE1` writer - FIFO message pending interrupt enable
        pub type FMPIE1_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FFIE1` reader - FIFO full interrupt enable
        pub type FFIE1_R = crate::BitReader;
        ///Field `FFIE1` writer - FIFO full interrupt enable
        pub type FFIE1_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FOVIE1` reader - FIFO overrun interrupt enable
        pub type FOVIE1_R = crate::BitReader;
        ///Field `FOVIE1` writer - FIFO overrun interrupt enable
        pub type FOVIE1_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `EWGIE` reader - Error warning interrupt enable
        pub type EWGIE_R = crate::BitReader;
        ///Field `EWGIE` writer - Error warning interrupt enable
        pub type EWGIE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `EPVIE` reader - Error passive interrupt enable
        pub type EPVIE_R = crate::BitReader;
        ///Field `EPVIE` writer - Error passive interrupt enable
        pub type EPVIE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `BOFIE` reader - Bus-off interrupt enable
        pub type BOFIE_R = crate::BitReader;
        ///Field `BOFIE` writer - Bus-off interrupt enable
        pub type BOFIE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `LECIE` reader - Last error code interrupt enable
        pub type LECIE_R = crate::BitReader;
        ///Field `LECIE` writer - Last error code interrupt enable
        pub type LECIE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `ERRIE` reader - Error interrupt enable
        pub type ERRIE_R = crate::BitReader;
        ///Field `ERRIE` writer - Error interrupt enable
        pub type ERRIE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `WKUIE` reader - Wakeup interrupt enable
        pub type WKUIE_R = crate::BitReader;
        ///Field `WKUIE` writer - Wakeup interrupt enable
        pub type WKUIE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `SLKIE` reader - Sleep interrupt enable
        pub type SLKIE_R = crate::BitReader;
        ///Field `SLKIE` writer - Sleep interrupt enable
        pub type SLKIE_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - Transmit mailbox empty interrupt enable
            #[inline(always)]
            pub fn tmeie(&self) -> TMEIE_R {
                TMEIE_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - FIFO message pending interrupt enable
            #[inline(always)]
            pub fn fmpie0(&self) -> FMPIE0_R {
                FMPIE0_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - FIFO full interrupt enable
            #[inline(always)]
            pub fn ffie0(&self) -> FFIE0_R {
                FFIE0_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - FIFO overrun interrupt enable
            #[inline(always)]
            pub fn fovie0(&self) -> FOVIE0_R {
                FOVIE0_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - FIFO message pending interrupt enable
            #[inline(always)]
            pub fn fmpie1(&self) -> FMPIE1_R {
                FMPIE1_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - FIFO full interrupt enable
            #[inline(always)]
            pub fn ffie1(&self) -> FFIE1_R {
                FFIE1_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - FIFO overrun interrupt enable
            #[inline(always)]
            pub fn fovie1(&self) -> FOVIE1_R {
                FOVIE1_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 8 - Error warning interrupt enable
            #[inline(always)]
            pub fn ewgie(&self) -> EWGIE_R {
                EWGIE_R::new(((self.bits >> 8) & 1) != 0)
            }
            ///Bit 9 - Error passive interrupt enable
            #[inline(always)]
            pub fn epvie(&self) -> EPVIE_R {
                EPVIE_R::new(((self.bits >> 9) & 1) != 0)
            }
            ///Bit 10 - Bus-off interrupt enable
            #[inline(always)]
            pub fn bofie(&self) -> BOFIE_R {
                BOFIE_R::new(((self.bits >> 10) & 1) != 0)
            }
            ///Bit 11 - Last error code interrupt enable
            #[inline(always)]
            pub fn lecie(&self) -> LECIE_R {
                LECIE_R::new(((self.bits >> 11) & 1) != 0)
            }
            ///Bit 15 - Error interrupt enable
            #[inline(always)]
            pub fn errie(&self) -> ERRIE_R {
                ERRIE_R::new(((self.bits >> 15) & 1) != 0)
            }
            ///Bit 16 - Wakeup interrupt enable
            #[inline(always)]
            pub fn wkuie(&self) -> WKUIE_R {
                WKUIE_R::new(((self.bits >> 16) & 1) != 0)
            }
            ///Bit 17 - Sleep interrupt enable
            #[inline(always)]
            pub fn slkie(&self) -> SLKIE_R {
                SLKIE_R::new(((self.bits >> 17) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - Transmit mailbox empty interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn tmeie(&mut self) -> TMEIE_W<INTENR_SPEC> {
                TMEIE_W::new(self, 0)
            }
            ///Bit 1 - FIFO message pending interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn fmpie0(&mut self) -> FMPIE0_W<INTENR_SPEC> {
                FMPIE0_W::new(self, 1)
            }
            ///Bit 2 - FIFO full interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn ffie0(&mut self) -> FFIE0_W<INTENR_SPEC> {
                FFIE0_W::new(self, 2)
            }
            ///Bit 3 - FIFO overrun interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn fovie0(&mut self) -> FOVIE0_W<INTENR_SPEC> {
                FOVIE0_W::new(self, 3)
            }
            ///Bit 4 - FIFO message pending interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn fmpie1(&mut self) -> FMPIE1_W<INTENR_SPEC> {
                FMPIE1_W::new(self, 4)
            }
            ///Bit 5 - FIFO full interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn ffie1(&mut self) -> FFIE1_W<INTENR_SPEC> {
                FFIE1_W::new(self, 5)
            }
            ///Bit 6 - FIFO overrun interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn fovie1(&mut self) -> FOVIE1_W<INTENR_SPEC> {
                FOVIE1_W::new(self, 6)
            }
            ///Bit 8 - Error warning interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn ewgie(&mut self) -> EWGIE_W<INTENR_SPEC> {
                EWGIE_W::new(self, 8)
            }
            ///Bit 9 - Error passive interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn epvie(&mut self) -> EPVIE_W<INTENR_SPEC> {
                EPVIE_W::new(self, 9)
            }
            ///Bit 10 - Bus-off interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn bofie(&mut self) -> BOFIE_W<INTENR_SPEC> {
                BOFIE_W::new(self, 10)
            }
            ///Bit 11 - Last error code interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn lecie(&mut self) -> LECIE_W<INTENR_SPEC> {
                LECIE_W::new(self, 11)
            }
            ///Bit 15 - Error interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn errie(&mut self) -> ERRIE_W<INTENR_SPEC> {
                ERRIE_W::new(self, 15)
            }
            ///Bit 16 - Wakeup interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn wkuie(&mut self) -> WKUIE_W<INTENR_SPEC> {
                WKUIE_W::new(self, 16)
            }
            ///Bit 17 - Sleep interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn slkie(&mut self) -> SLKIE_W<INTENR_SPEC> {
                SLKIE_W::new(self, 17)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///CAN interrupt enable register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`intenr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`intenr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct INTENR_SPEC;
        impl crate::RegisterSpec for INTENR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`intenr::R`](R) reader structure
        impl crate::Readable for INTENR_SPEC {}
        ///`write(|w| ..)` method takes [`intenr::W`](W) writer structure
        impl crate::Writable for INTENR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets INTENR to value 0
        impl crate::Resettable for INTENR_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///ERRSR (rw) register accessor: CAN error status register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`errsr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`errsr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@errsr`]
    ///module
    pub type ERRSR = crate::Reg<errsr::ERRSR_SPEC>;
    ///CAN error status register
    pub mod errsr {
        ///Register `ERRSR` reader
        pub type R = crate::R<ERRSR_SPEC>;
        ///Register `ERRSR` writer
        pub type W = crate::W<ERRSR_SPEC>;
        ///Field `EWGF` reader - Error warning flag
        pub type EWGF_R = crate::BitReader;
        ///Field `EPVF` reader - Error passive flag
        pub type EPVF_R = crate::BitReader;
        ///Field `BOFF` reader - Bus-off flag
        pub type BOFF_R = crate::BitReader;
        ///Field `LEC` reader - Last error code
        pub type LEC_R = crate::FieldReader;
        ///Field `LEC` writer - Last error code
        pub type LEC_W<'a, REG> = crate::FieldWriter<'a, REG, 3>;
        ///Field `TEC` reader - Least significant byte of the 9-bit transmit error counter
        pub type TEC_R = crate::FieldReader;
        ///Field `REC` reader - Receive error counter
        pub type REC_R = crate::FieldReader;
        impl R {
            ///Bit 0 - Error warning flag
            #[inline(always)]
            pub fn ewgf(&self) -> EWGF_R {
                EWGF_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Error passive flag
            #[inline(always)]
            pub fn epvf(&self) -> EPVF_R {
                EPVF_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - Bus-off flag
            #[inline(always)]
            pub fn boff(&self) -> BOFF_R {
                BOFF_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bits 4:6 - Last error code
            #[inline(always)]
            pub fn lec(&self) -> LEC_R {
                LEC_R::new(((self.bits >> 4) & 7) as u8)
            }
            ///Bits 16:23 - Least significant byte of the 9-bit transmit error counter
            #[inline(always)]
            pub fn tec(&self) -> TEC_R {
                TEC_R::new(((self.bits >> 16) & 0xff) as u8)
            }
            ///Bits 24:31 - Receive error counter
            #[inline(always)]
            pub fn rec(&self) -> REC_R {
                REC_R::new(((self.bits >> 24) & 0xff) as u8)
            }
        }
        impl W {
            ///Bits 4:6 - Last error code
            #[inline(always)]
            #[must_use]
            pub fn lec(&mut self) -> LEC_W<ERRSR_SPEC> {
                LEC_W::new(self, 4)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///CAN error status register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`errsr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`errsr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct ERRSR_SPEC;
        impl crate::RegisterSpec for ERRSR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`errsr::R`](R) reader structure
        impl crate::Readable for ERRSR_SPEC {}
        ///`write(|w| ..)` method takes [`errsr::W`](W) writer structure
        impl crate::Writable for ERRSR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets ERRSR to value 0
        impl crate::Resettable for ERRSR_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///BTIMR (rw) register accessor: CAN bit timing register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`btimr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`btimr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@btimr`]
    ///module
    pub type BTIMR = crate::Reg<btimr::BTIMR_SPEC>;
    ///CAN bit timing register
    pub mod btimr {
        ///Register `BTIMR` reader
        pub type R = crate::R<BTIMR_SPEC>;
        ///Register `BTIMR` writer
        pub type W = crate::W<BTIMR_SPEC>;
        ///Field `BRP` reader - minimum time unit length setting value
        pub type BRP_R = crate::FieldReader<u16>;
        ///Field `BRP` writer - minimum time unit length setting value
        pub type BRP_W<'a, REG> = crate::FieldWriter<'a, REG, 10, u16>;
        ///Field `BTR_TS1_T` reader - CLAS_LONG_TS1=0;TS1 is TS\[3:0\](4bit);CLAS_LONG_TS1=1,TS1 is TS\[1:0\]+BTR_TS1_T\[15:12\](6bit)
        pub type BTR_TS1_T_R = crate::FieldReader;
        ///Field `BTR_TS1_T` writer - CLAS_LONG_TS1=0;TS1 is TS\[3:0\](4bit);CLAS_LONG_TS1=1,TS1 is TS\[1:0\]+BTR_TS1_T\[15:12\](6bit)
        pub type BTR_TS1_T_W<'a, REG> = crate::FieldWriter<'a, REG, 4>;
        ///Field `TS1` reader - Time segment 1
        pub type TS1_R = crate::FieldReader;
        ///Field `TS1` writer - Time segment 1
        pub type TS1_W<'a, REG> = crate::FieldWriter<'a, REG, 4>;
        ///Field `TS2` reader - Time segment 2
        pub type TS2_R = crate::FieldReader;
        ///Field `TS2` writer - Time segment 2
        pub type TS2_W<'a, REG> = crate::FieldWriter<'a, REG, 4>;
        ///Field `SJW` reader - Resynchronization jump width
        pub type SJW_R = crate::FieldReader;
        ///Field `SJW` writer - Resynchronization jump width
        pub type SJW_W<'a, REG> = crate::FieldWriter<'a, REG, 4>;
        ///Field `LBKM` reader - Loop back mode (debug)
        pub type LBKM_R = crate::BitReader;
        ///Field `LBKM` writer - Loop back mode (debug)
        pub type LBKM_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `SILM` reader - Silent mode (debug)
        pub type SILM_R = crate::BitReader;
        ///Field `SILM` writer - Silent mode (debug)
        pub type SILM_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bits 0:9 - minimum time unit length setting value
            #[inline(always)]
            pub fn brp(&self) -> BRP_R {
                BRP_R::new((self.bits & 0x03ff) as u16)
            }
            ///Bits 12:15 - CLAS_LONG_TS1=0;TS1 is TS\[3:0\](4bit);CLAS_LONG_TS1=1,TS1 is TS\[1:0\]+BTR_TS1_T\[15:12\](6bit)
            #[inline(always)]
            pub fn btr_ts1_t(&self) -> BTR_TS1_T_R {
                BTR_TS1_T_R::new(((self.bits >> 12) & 0x0f) as u8)
            }
            ///Bits 16:19 - Time segment 1
            #[inline(always)]
            pub fn ts1(&self) -> TS1_R {
                TS1_R::new(((self.bits >> 16) & 0x0f) as u8)
            }
            ///Bits 20:23 - Time segment 2
            #[inline(always)]
            pub fn ts2(&self) -> TS2_R {
                TS2_R::new(((self.bits >> 20) & 0x0f) as u8)
            }
            ///Bits 24:27 - Resynchronization jump width
            #[inline(always)]
            pub fn sjw(&self) -> SJW_R {
                SJW_R::new(((self.bits >> 24) & 0x0f) as u8)
            }
            ///Bit 30 - Loop back mode (debug)
            #[inline(always)]
            pub fn lbkm(&self) -> LBKM_R {
                LBKM_R::new(((self.bits >> 30) & 1) != 0)
            }
            ///Bit 31 - Silent mode (debug)
            #[inline(always)]
            pub fn silm(&self) -> SILM_R {
                SILM_R::new(((self.bits >> 31) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:9 - minimum time unit length setting value
            #[inline(always)]
            #[must_use]
            pub fn brp(&mut self) -> BRP_W<BTIMR_SPEC> {
                BRP_W::new(self, 0)
            }
            ///Bits 12:15 - CLAS_LONG_TS1=0;TS1 is TS\[3:0\](4bit);CLAS_LONG_TS1=1,TS1 is TS\[1:0\]+BTR_TS1_T\[15:12\](6bit)
            #[inline(always)]
            #[must_use]
            pub fn btr_ts1_t(&mut self) -> BTR_TS1_T_W<BTIMR_SPEC> {
                BTR_TS1_T_W::new(self, 12)
            }
            ///Bits 16:19 - Time segment 1
            #[inline(always)]
            #[must_use]
            pub fn ts1(&mut self) -> TS1_W<BTIMR_SPEC> {
                TS1_W::new(self, 16)
            }
            ///Bits 20:23 - Time segment 2
            #[inline(always)]
            #[must_use]
            pub fn ts2(&mut self) -> TS2_W<BTIMR_SPEC> {
                TS2_W::new(self, 20)
            }
            ///Bits 24:27 - Resynchronization jump width
            #[inline(always)]
            #[must_use]
            pub fn sjw(&mut self) -> SJW_W<BTIMR_SPEC> {
                SJW_W::new(self, 24)
            }
            ///Bit 30 - Loop back mode (debug)
            #[inline(always)]
            #[must_use]
            pub fn lbkm(&mut self) -> LBKM_W<BTIMR_SPEC> {
                LBKM_W::new(self, 30)
            }
            ///Bit 31 - Silent mode (debug)
            #[inline(always)]
            #[must_use]
            pub fn silm(&mut self) -> SILM_W<BTIMR_SPEC> {
                SILM_W::new(self, 31)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///CAN bit timing register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`btimr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`btimr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct BTIMR_SPEC;
        impl crate::RegisterSpec for BTIMR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`btimr::R`](R) reader structure
        impl crate::Readable for BTIMR_SPEC {}
        ///`write(|w| ..)` method takes [`btimr::W`](W) writer structure
        impl crate::Writable for BTIMR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets BTIMR to value 0x0123_0000
        impl crate::Resettable for BTIMR_SPEC {
            const RESET_VALUE: u32 = 0x0123_0000;
        }
    }
    ///TTCTLR (rw) register accessor: CAN time trigger control register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`ttctlr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ttctlr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@ttctlr`]
    ///module
    pub type TTCTLR = crate::Reg<ttctlr::TTCTLR_SPEC>;
    ///CAN time trigger control register
    pub mod ttctlr {
        ///Register `TTCTLR` reader
        pub type R = crate::R<TTCTLR_SPEC>;
        ///Register `TTCTLR` writer
        pub type W = crate::W<TTCTLR_SPEC>;
        ///Field `TIMCMV` reader - Internal counter count end value
        pub type TIMCMV_R = crate::FieldReader<u16>;
        ///Field `TIMCMV` writer - Internal counter count end value
        pub type TIMCMV_W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        ///Field `TIMRST` writer - Internal counter reset control
        pub type TIMRST_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `MODE` reader - Time-triggered mode selection
        pub type MODE_R = crate::BitReader;
        ///Field `MODE` writer - Time-triggered mode selection
        pub type MODE_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bits 0:15 - Internal counter count end value
            #[inline(always)]
            pub fn timcmv(&self) -> TIMCMV_R {
                TIMCMV_R::new((self.bits & 0xffff) as u16)
            }
            ///Bit 17 - Time-triggered mode selection
            #[inline(always)]
            pub fn mode(&self) -> MODE_R {
                MODE_R::new(((self.bits >> 17) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:15 - Internal counter count end value
            #[inline(always)]
            #[must_use]
            pub fn timcmv(&mut self) -> TIMCMV_W<TTCTLR_SPEC> {
                TIMCMV_W::new(self, 0)
            }
            ///Bit 16 - Internal counter reset control
            #[inline(always)]
            #[must_use]
            pub fn timrst(&mut self) -> TIMRST_W<TTCTLR_SPEC> {
                TIMRST_W::new(self, 16)
            }
            ///Bit 17 - Time-triggered mode selection
            #[inline(always)]
            #[must_use]
            pub fn mode(&mut self) -> MODE_W<TTCTLR_SPEC> {
                MODE_W::new(self, 17)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///CAN time trigger control register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`ttctlr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ttctlr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct TTCTLR_SPEC;
        impl crate::RegisterSpec for TTCTLR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`ttctlr::R`](R) reader structure
        impl crate::Readable for TTCTLR_SPEC {}
        ///`write(|w| ..)` method takes [`ttctlr::W`](W) writer structure
        impl crate::Writable for TTCTLR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets TTCTLR to value 0xffff
        impl crate::Resettable for TTCTLR_SPEC {
            const RESET_VALUE: u32 = 0xffff;
        }
    }
    ///TTCNT (rw) register accessor: CAN Time Trigger Count Value Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`ttcnt::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ttcnt::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@ttcnt`]
    ///module
    pub type TTCNT = crate::Reg<ttcnt::TTCNT_SPEC>;
    ///CAN Time Trigger Count Value Register
    pub mod ttcnt {
        ///Register `TTCNT` reader
        pub type R = crate::R<TTCNT_SPEC>;
        ///Register `TTCNT` writer
        pub type W = crate::W<TTCNT_SPEC>;
        ///Field `TIMCNT` reader - time-triggered count value
        pub type TIMCNT_R = crate::FieldReader<u16>;
        ///Field `TIMCNT` writer - time-triggered count value
        pub type TIMCNT_W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            ///Bits 0:15 - time-triggered count value
            #[inline(always)]
            pub fn timcnt(&self) -> TIMCNT_R {
                TIMCNT_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            ///Bits 0:15 - time-triggered count value
            #[inline(always)]
            #[must_use]
            pub fn timcnt(&mut self) -> TIMCNT_W<TTCNT_SPEC> {
                TIMCNT_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///CAN Time Trigger Count Value Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`ttcnt::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ttcnt::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct TTCNT_SPEC;
        impl crate::RegisterSpec for TTCNT_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`ttcnt::R`](R) reader structure
        impl crate::Readable for TTCNT_SPEC {}
        ///`write(|w| ..)` method takes [`ttcnt::W`](W) writer structure
        impl crate::Writable for TTCNT_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets TTCNT to value 0
        impl crate::Resettable for TTCNT_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///TERR_CNT (rw) register accessor: CAN offline recovery error counter
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`terr_cnt::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`terr_cnt::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@terr_cnt`]
    ///module
    pub type TERR_CNT = crate::Reg<terr_cnt::TERR_CNT_SPEC>;
    ///CAN offline recovery error counter
    pub mod terr_cnt {
        ///Register `TERR_CNT` reader
        pub type R = crate::R<TERR_CNT_SPEC>;
        ///Register `TERR_CNT` writer
        pub type W = crate::W<TERR_CNT_SPEC>;
        ///Field `TX_ERR_CNT` reader - Offline recovery error count values
        pub type TX_ERR_CNT_R = crate::FieldReader<u16>;
        ///Field `TX_ERR_CNT` writer - Offline recovery error count values
        pub type TX_ERR_CNT_W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            ///Bits 0:15 - Offline recovery error count values
            #[inline(always)]
            pub fn tx_err_cnt(&self) -> TX_ERR_CNT_R {
                TX_ERR_CNT_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            ///Bits 0:15 - Offline recovery error count values
            #[inline(always)]
            #[must_use]
            pub fn tx_err_cnt(&mut self) -> TX_ERR_CNT_W<TERR_CNT_SPEC> {
                TX_ERR_CNT_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///CAN offline recovery error counter
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`terr_cnt::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`terr_cnt::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct TERR_CNT_SPEC;
        impl crate::RegisterSpec for TERR_CNT_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`terr_cnt::R`](R) reader structure
        impl crate::Readable for TERR_CNT_SPEC {}
        ///`write(|w| ..)` method takes [`terr_cnt::W`](W) writer structure
        impl crate::Writable for TERR_CNT_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets TERR_CNT to value 0
        impl crate::Resettable for TERR_CNT_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///CR (rw) register accessor: CANFD control register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`cr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@cr`]
    ///module
    pub type CR = crate::Reg<cr::CR_SPEC>;
    ///CANFD control register
    pub mod cr {
        ///Register `CR` reader
        pub type R = crate::R<CR_SPEC>;
        ///Register `CR` writer
        pub type W = crate::W<CR_SPEC>;
        ///Field `TX_FD` reader - Send the FD frame enable bit
        pub type TX_FD_R = crate::BitReader;
        ///Field `TX_FD` writer - Send the FD frame enable bit
        pub type TX_FD_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TX_BRS_B` reader - Channel switchover enable
        pub type TX_BRS_B_R = crate::FieldReader;
        ///Field `TX_BRS_B` writer - Channel switchover enable
        pub type TX_BRS_B_W<'a, REG> = crate::FieldWriter<'a, REG, 3>;
        ///Field `USER_ESI_B` reader - ESI status
        pub type USER_ESI_B_R = crate::FieldReader;
        ///Field `USER_ESI_B` writer - ESI status
        pub type USER_ESI_B_W<'a, REG> = crate::FieldWriter<'a, REG, 3>;
        ///Field `RES_EXCEPT` reader - RES Bit exceptional enable
        pub type RES_EXCEPT_R = crate::BitReader;
        ///Field `RES_EXCEPT` writer - RES Bit exceptional enable
        pub type RES_EXCEPT_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CLAS_LONG_TS1` reader - TS1 stage length selection
        pub type CLAS_LONG_TS1_R = crate::BitReader;
        ///Field `CLAS_LONG_TS1` writer - TS1 stage length selection
        pub type CLAS_LONG_TS1_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `RESTRICT_MODE` reader - Mode enable
        pub type RESTRICT_MODE_R = crate::BitReader;
        ///Field `RESTRICT_MODE` writer - Mode enable
        pub type RESTRICT_MODE_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - Send the FD frame enable bit
            #[inline(always)]
            pub fn tx_fd(&self) -> TX_FD_R {
                TX_FD_R::new((self.bits & 1) != 0)
            }
            ///Bits 1:3 - Channel switchover enable
            #[inline(always)]
            pub fn tx_brs_b(&self) -> TX_BRS_B_R {
                TX_BRS_B_R::new(((self.bits >> 1) & 7) as u8)
            }
            ///Bits 4:6 - ESI status
            #[inline(always)]
            pub fn user_esi_b(&self) -> USER_ESI_B_R {
                USER_ESI_B_R::new(((self.bits >> 4) & 7) as u8)
            }
            ///Bit 7 - RES Bit exceptional enable
            #[inline(always)]
            pub fn res_except(&self) -> RES_EXCEPT_R {
                RES_EXCEPT_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bit 8 - TS1 stage length selection
            #[inline(always)]
            pub fn clas_long_ts1(&self) -> CLAS_LONG_TS1_R {
                CLAS_LONG_TS1_R::new(((self.bits >> 8) & 1) != 0)
            }
            ///Bit 9 - Mode enable
            #[inline(always)]
            pub fn restrict_mode(&self) -> RESTRICT_MODE_R {
                RESTRICT_MODE_R::new(((self.bits >> 9) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - Send the FD frame enable bit
            #[inline(always)]
            #[must_use]
            pub fn tx_fd(&mut self) -> TX_FD_W<CR_SPEC> {
                TX_FD_W::new(self, 0)
            }
            ///Bits 1:3 - Channel switchover enable
            #[inline(always)]
            #[must_use]
            pub fn tx_brs_b(&mut self) -> TX_BRS_B_W<CR_SPEC> {
                TX_BRS_B_W::new(self, 1)
            }
            ///Bits 4:6 - ESI status
            #[inline(always)]
            #[must_use]
            pub fn user_esi_b(&mut self) -> USER_ESI_B_W<CR_SPEC> {
                USER_ESI_B_W::new(self, 4)
            }
            ///Bit 7 - RES Bit exceptional enable
            #[inline(always)]
            #[must_use]
            pub fn res_except(&mut self) -> RES_EXCEPT_W<CR_SPEC> {
                RES_EXCEPT_W::new(self, 7)
            }
            ///Bit 8 - TS1 stage length selection
            #[inline(always)]
            #[must_use]
            pub fn clas_long_ts1(&mut self) -> CLAS_LONG_TS1_W<CR_SPEC> {
                CLAS_LONG_TS1_W::new(self, 8)
            }
            ///Bit 9 - Mode enable
            #[inline(always)]
            #[must_use]
            pub fn restrict_mode(&mut self) -> RESTRICT_MODE_W<CR_SPEC> {
                RESTRICT_MODE_W::new(self, 9)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///CANFD control register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`cr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct CR_SPEC;
        impl crate::RegisterSpec for CR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`cr::R`](R) reader structure
        impl crate::Readable for CR_SPEC {}
        ///`write(|w| ..)` method takes [`cr::W`](W) writer structure
        impl crate::Writable for CR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets CR to value 0
        impl crate::Resettable for CR_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///BTR (rw) register accessor: CANFD Sequential register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`btr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`btr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@btr`]
    ///module
    pub type BTR = crate::Reg<btr::BTR_SPEC>;
    ///CANFD Sequential register
    pub mod btr {
        ///Register `BTR` reader
        pub type R = crate::R<BTR_SPEC>;
        ///Register `BTR` writer
        pub type W = crate::W<BTR_SPEC>;
        ///Field `BTR_SJW_FD` reader - Resynchronization width setting
        pub type BTR_SJW_FD_R = crate::FieldReader;
        ///Field `BTR_SJW_FD` writer - Resynchronization width setting
        pub type BTR_SJW_FD_W<'a, REG> = crate::FieldWriter<'a, REG, 4>;
        ///Field `BTR_TS2_FD` reader - Time range 2 set value
        pub type BTR_TS2_FD_R = crate::FieldReader;
        ///Field `BTR_TS2_FD` writer - Time range 2 set value
        pub type BTR_TS2_FD_W<'a, REG> = crate::FieldWriter<'a, REG, 4>;
        ///Field `BTR_TS1_FD` reader - Time range 1 set value
        pub type BTR_TS1_FD_R = crate::FieldReader;
        ///Field `BTR_TS1_FD` writer - Time range 1 set value
        pub type BTR_TS1_FD_W<'a, REG> = crate::FieldWriter<'a, REG, 5>;
        ///Field `BTR_BRP_FD` reader - Minimum time length setting value
        pub type BTR_BRP_FD_R = crate::FieldReader;
        ///Field `BTR_BRP_FD` writer - Minimum time length setting value
        pub type BTR_BRP_FD_W<'a, REG> = crate::FieldWriter<'a, REG, 5>;
        ///Field `TDCE` reader - FD Frame sending delay compensation enable
        pub type TDCE_R = crate::BitReader;
        ///Field `TDCE` writer - FD Frame sending delay compensation enable
        pub type TDCE_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bits 0:3 - Resynchronization width setting
            #[inline(always)]
            pub fn btr_sjw_fd(&self) -> BTR_SJW_FD_R {
                BTR_SJW_FD_R::new((self.bits & 0x0f) as u8)
            }
            ///Bits 4:7 - Time range 2 set value
            #[inline(always)]
            pub fn btr_ts2_fd(&self) -> BTR_TS2_FD_R {
                BTR_TS2_FD_R::new(((self.bits >> 4) & 0x0f) as u8)
            }
            ///Bits 8:12 - Time range 1 set value
            #[inline(always)]
            pub fn btr_ts1_fd(&self) -> BTR_TS1_FD_R {
                BTR_TS1_FD_R::new(((self.bits >> 8) & 0x1f) as u8)
            }
            ///Bits 16:20 - Minimum time length setting value
            #[inline(always)]
            pub fn btr_brp_fd(&self) -> BTR_BRP_FD_R {
                BTR_BRP_FD_R::new(((self.bits >> 16) & 0x1f) as u8)
            }
            ///Bit 23 - FD Frame sending delay compensation enable
            #[inline(always)]
            pub fn tdce(&self) -> TDCE_R {
                TDCE_R::new(((self.bits >> 23) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:3 - Resynchronization width setting
            #[inline(always)]
            #[must_use]
            pub fn btr_sjw_fd(&mut self) -> BTR_SJW_FD_W<BTR_SPEC> {
                BTR_SJW_FD_W::new(self, 0)
            }
            ///Bits 4:7 - Time range 2 set value
            #[inline(always)]
            #[must_use]
            pub fn btr_ts2_fd(&mut self) -> BTR_TS2_FD_W<BTR_SPEC> {
                BTR_TS2_FD_W::new(self, 4)
            }
            ///Bits 8:12 - Time range 1 set value
            #[inline(always)]
            #[must_use]
            pub fn btr_ts1_fd(&mut self) -> BTR_TS1_FD_W<BTR_SPEC> {
                BTR_TS1_FD_W::new(self, 8)
            }
            ///Bits 16:20 - Minimum time length setting value
            #[inline(always)]
            #[must_use]
            pub fn btr_brp_fd(&mut self) -> BTR_BRP_FD_W<BTR_SPEC> {
                BTR_BRP_FD_W::new(self, 16)
            }
            ///Bit 23 - FD Frame sending delay compensation enable
            #[inline(always)]
            #[must_use]
            pub fn tdce(&mut self) -> TDCE_W<BTR_SPEC> {
                TDCE_W::new(self, 23)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///CANFD Sequential register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`btr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`btr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct BTR_SPEC;
        impl crate::RegisterSpec for BTR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`btr::R`](R) reader structure
        impl crate::Readable for BTR_SPEC {}
        ///`write(|w| ..)` method takes [`btr::W`](W) writer structure
        impl crate::Writable for BTR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets BTR to value 0
        impl crate::Resettable for BTR_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///TDCT (rw) register accessor: CANFD Send delay compensation register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`tdct::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`tdct::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@tdct`]
    ///module
    pub type TDCT = crate::Reg<tdct::TDCT_SPEC>;
    ///CANFD Send delay compensation register
    pub mod tdct {
        ///Register `TDCT` reader
        pub type R = crate::R<TDCT_SPEC>;
        ///Register `TDCT` writer
        pub type W = crate::W<TDCT_SPEC>;
        ///Field `TDCO` reader - Transmitter delay compensation offset
        pub type TDCO_R = crate::FieldReader;
        ///Field `TDCO` writer - Transmitter delay compensation offset
        pub type TDCO_W<'a, REG> = crate::FieldWriter<'a, REG, 6>;
        ///Field `TDC_FILTER` reader - Transmitter delay timing filtering
        pub type TDC_FILTER_R = crate::FieldReader;
        ///Field `TDC_FILTER` writer - Transmitter delay timing filtering
        pub type TDC_FILTER_W<'a, REG> = crate::FieldWriter<'a, REG, 6>;
        impl R {
            ///Bits 0:5 - Transmitter delay compensation offset
            #[inline(always)]
            pub fn tdco(&self) -> TDCO_R {
                TDCO_R::new((self.bits & 0x3f) as u8)
            }
            ///Bits 8:13 - Transmitter delay timing filtering
            #[inline(always)]
            pub fn tdc_filter(&self) -> TDC_FILTER_R {
                TDC_FILTER_R::new(((self.bits >> 8) & 0x3f) as u8)
            }
        }
        impl W {
            ///Bits 0:5 - Transmitter delay compensation offset
            #[inline(always)]
            #[must_use]
            pub fn tdco(&mut self) -> TDCO_W<TDCT_SPEC> {
                TDCO_W::new(self, 0)
            }
            ///Bits 8:13 - Transmitter delay timing filtering
            #[inline(always)]
            #[must_use]
            pub fn tdc_filter(&mut self) -> TDC_FILTER_W<TDCT_SPEC> {
                TDC_FILTER_W::new(self, 8)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///CANFD Send delay compensation register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`tdct::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`tdct::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct TDCT_SPEC;
        impl crate::RegisterSpec for TDCT_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`tdct::R`](R) reader structure
        impl crate::Readable for TDCT_SPEC {}
        ///`write(|w| ..)` method takes [`tdct::W`](W) writer structure
        impl crate::Writable for TDCT_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets TDCT to value 0
        impl crate::Resettable for TDCT_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///PSR (r) register accessor: CANFD Send delay compensation value register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`psr::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@psr`]
    ///module
    pub type PSR = crate::Reg<psr::PSR_SPEC>;
    ///CANFD Send delay compensation value register
    pub mod psr {
        ///Register `PSR` reader
        pub type R = crate::R<PSR_SPEC>;
        ///Field `TDCV` reader - FD Send delay compensation value
        pub type TDCV_R = crate::FieldReader;
        impl R {
            ///Bits 16:23 - FD Send delay compensation value
            #[inline(always)]
            pub fn tdcv(&self) -> TDCV_R {
                TDCV_R::new(((self.bits >> 16) & 0xff) as u8)
            }
        }
        ///CANFD Send delay compensation value register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`psr::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct PSR_SPEC;
        impl crate::RegisterSpec for PSR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`psr::R`](R) reader structure
        impl crate::Readable for PSR_SPEC {}
        ///`reset()` method sets PSR to value 0
        impl crate::Resettable for PSR_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///DMA_T0 (rw) register accessor: CANFD DMA send mailbox 0 address register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`dma_t0::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dma_t0::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@dma_t0`]
    ///module
    pub type DMA_T0 = crate::Reg<dma_t0::DMA_T0_SPEC>;
    ///CANFD DMA send mailbox 0 address register
    pub mod dma_t0 {
        ///Register `DMA_T0` reader
        pub type R = crate::R<DMA_T0_SPEC>;
        ///Register `DMA_T0` writer
        pub type W = crate::W<DMA_T0_SPEC>;
        ///Field `DMA_ADDR_T0` reader - Send buffer
        pub type DMA_ADDR_T0_R = crate::FieldReader<u16>;
        ///Field `DMA_ADDR_T0` writer - Send buffer
        pub type DMA_ADDR_T0_W<'a, REG> = crate::FieldWriter<'a, REG, 15, u16>;
        impl R {
            ///Bits 0:14 - Send buffer
            #[inline(always)]
            pub fn dma_addr_t0(&self) -> DMA_ADDR_T0_R {
                DMA_ADDR_T0_R::new((self.bits & 0x7fff) as u16)
            }
        }
        impl W {
            ///Bits 0:14 - Send buffer
            #[inline(always)]
            #[must_use]
            pub fn dma_addr_t0(&mut self) -> DMA_ADDR_T0_W<DMA_T0_SPEC> {
                DMA_ADDR_T0_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///CANFD DMA send mailbox 0 address register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`dma_t0::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dma_t0::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct DMA_T0_SPEC;
        impl crate::RegisterSpec for DMA_T0_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`dma_t0::R`](R) reader structure
        impl crate::Readable for DMA_T0_SPEC {}
        ///`write(|w| ..)` method takes [`dma_t0::W`](W) writer structure
        impl crate::Writable for DMA_T0_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets DMA_T0 to value 0
        impl crate::Resettable for DMA_T0_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///DMA_T1 (rw) register accessor: CANFD DMA send mailbox 1 address register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`dma_t1::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dma_t1::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@dma_t1`]
    ///module
    pub type DMA_T1 = crate::Reg<dma_t1::DMA_T1_SPEC>;
    ///CANFD DMA send mailbox 1 address register
    pub mod dma_t1 {
        ///Register `DMA_T1` reader
        pub type R = crate::R<DMA_T1_SPEC>;
        ///Register `DMA_T1` writer
        pub type W = crate::W<DMA_T1_SPEC>;
        ///Field `DMA_ADDR_T1` reader - Send buffer
        pub type DMA_ADDR_T1_R = crate::FieldReader<u16>;
        ///Field `DMA_ADDR_T1` writer - Send buffer
        pub type DMA_ADDR_T1_W<'a, REG> = crate::FieldWriter<'a, REG, 15, u16>;
        impl R {
            ///Bits 0:14 - Send buffer
            #[inline(always)]
            pub fn dma_addr_t1(&self) -> DMA_ADDR_T1_R {
                DMA_ADDR_T1_R::new((self.bits & 0x7fff) as u16)
            }
        }
        impl W {
            ///Bits 0:14 - Send buffer
            #[inline(always)]
            #[must_use]
            pub fn dma_addr_t1(&mut self) -> DMA_ADDR_T1_W<DMA_T1_SPEC> {
                DMA_ADDR_T1_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///CANFD DMA send mailbox 1 address register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`dma_t1::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dma_t1::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct DMA_T1_SPEC;
        impl crate::RegisterSpec for DMA_T1_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`dma_t1::R`](R) reader structure
        impl crate::Readable for DMA_T1_SPEC {}
        ///`write(|w| ..)` method takes [`dma_t1::W`](W) writer structure
        impl crate::Writable for DMA_T1_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets DMA_T1 to value 0
        impl crate::Resettable for DMA_T1_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///DMA_T2 (rw) register accessor: CANFD DMA send mailbox 2 address register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`dma_t2::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dma_t2::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@dma_t2`]
    ///module
    pub type DMA_T2 = crate::Reg<dma_t2::DMA_T2_SPEC>;
    ///CANFD DMA send mailbox 2 address register
    pub mod dma_t2 {
        ///Register `DMA_T2` reader
        pub type R = crate::R<DMA_T2_SPEC>;
        ///Register `DMA_T2` writer
        pub type W = crate::W<DMA_T2_SPEC>;
        ///Field `DMA_ADDR_T2` reader - Send buffer
        pub type DMA_ADDR_T2_R = crate::FieldReader<u16>;
        ///Field `DMA_ADDR_T2` writer - Send buffer
        pub type DMA_ADDR_T2_W<'a, REG> = crate::FieldWriter<'a, REG, 15, u16>;
        impl R {
            ///Bits 0:14 - Send buffer
            #[inline(always)]
            pub fn dma_addr_t2(&self) -> DMA_ADDR_T2_R {
                DMA_ADDR_T2_R::new((self.bits & 0x7fff) as u16)
            }
        }
        impl W {
            ///Bits 0:14 - Send buffer
            #[inline(always)]
            #[must_use]
            pub fn dma_addr_t2(&mut self) -> DMA_ADDR_T2_W<DMA_T2_SPEC> {
                DMA_ADDR_T2_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///CANFD DMA send mailbox 2 address register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`dma_t2::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dma_t2::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct DMA_T2_SPEC;
        impl crate::RegisterSpec for DMA_T2_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`dma_t2::R`](R) reader structure
        impl crate::Readable for DMA_T2_SPEC {}
        ///`write(|w| ..)` method takes [`dma_t2::W`](W) writer structure
        impl crate::Writable for DMA_T2_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets DMA_T2 to value 0
        impl crate::Resettable for DMA_T2_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///DMA_R0 (rw) register accessor: CANFD DMA receives mailbox 0 address register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`dma_r0::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dma_r0::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@dma_r0`]
    ///module
    pub type DMA_R0 = crate::Reg<dma_r0::DMA_R0_SPEC>;
    ///CANFD DMA receives mailbox 0 address register
    pub mod dma_r0 {
        ///Register `DMA_R0` reader
        pub type R = crate::R<DMA_R0_SPEC>;
        ///Register `DMA_R0` writer
        pub type W = crate::W<DMA_R0_SPEC>;
        ///Field `DMA_ADDR_R0` reader - Receive buffer
        pub type DMA_ADDR_R0_R = crate::FieldReader<u16>;
        ///Field `DMA_ADDR_R0` writer - Receive buffer
        pub type DMA_ADDR_R0_W<'a, REG> = crate::FieldWriter<'a, REG, 15, u16>;
        impl R {
            ///Bits 0:14 - Receive buffer
            #[inline(always)]
            pub fn dma_addr_r0(&self) -> DMA_ADDR_R0_R {
                DMA_ADDR_R0_R::new((self.bits & 0x7fff) as u16)
            }
        }
        impl W {
            ///Bits 0:14 - Receive buffer
            #[inline(always)]
            #[must_use]
            pub fn dma_addr_r0(&mut self) -> DMA_ADDR_R0_W<DMA_R0_SPEC> {
                DMA_ADDR_R0_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///CANFD DMA receives mailbox 0 address register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`dma_r0::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dma_r0::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct DMA_R0_SPEC;
        impl crate::RegisterSpec for DMA_R0_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`dma_r0::R`](R) reader structure
        impl crate::Readable for DMA_R0_SPEC {}
        ///`write(|w| ..)` method takes [`dma_r0::W`](W) writer structure
        impl crate::Writable for DMA_R0_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets DMA_R0 to value 0
        impl crate::Resettable for DMA_R0_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///DMA_R1 (rw) register accessor: CANFD DMA receives mailbox 1 address register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`dma_r1::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dma_r1::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@dma_r1`]
    ///module
    pub type DMA_R1 = crate::Reg<dma_r1::DMA_R1_SPEC>;
    ///CANFD DMA receives mailbox 1 address register
    pub mod dma_r1 {
        ///Register `DMA_R1` reader
        pub type R = crate::R<DMA_R1_SPEC>;
        ///Register `DMA_R1` writer
        pub type W = crate::W<DMA_R1_SPEC>;
        ///Field `DMA_ADDR_R1` reader - Receive buffer
        pub type DMA_ADDR_R1_R = crate::FieldReader<u16>;
        ///Field `DMA_ADDR_R1` writer - Receive buffer
        pub type DMA_ADDR_R1_W<'a, REG> = crate::FieldWriter<'a, REG, 15, u16>;
        impl R {
            ///Bits 0:14 - Receive buffer
            #[inline(always)]
            pub fn dma_addr_r1(&self) -> DMA_ADDR_R1_R {
                DMA_ADDR_R1_R::new((self.bits & 0x7fff) as u16)
            }
        }
        impl W {
            ///Bits 0:14 - Receive buffer
            #[inline(always)]
            #[must_use]
            pub fn dma_addr_r1(&mut self) -> DMA_ADDR_R1_W<DMA_R1_SPEC> {
                DMA_ADDR_R1_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///CANFD DMA receives mailbox 1 address register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`dma_r1::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dma_r1::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct DMA_R1_SPEC;
        impl crate::RegisterSpec for DMA_R1_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`dma_r1::R`](R) reader structure
        impl crate::Readable for DMA_R1_SPEC {}
        ///`write(|w| ..)` method takes [`dma_r1::W`](W) writer structure
        impl crate::Writable for DMA_R1_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets DMA_R1 to value 0
        impl crate::Resettable for DMA_R1_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///TXMIR0 (rw) register accessor: CAN TX mailbox identifier register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`txmir0::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`txmir0::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@txmir0`]
    ///module
    pub type TXMIR0 = crate::Reg<txmir0::TXMIR0_SPEC>;
    ///CAN TX mailbox identifier register
    pub mod txmir0 {
        ///Register `TXMIR0` reader
        pub type R = crate::R<TXMIR0_SPEC>;
        ///Register `TXMIR0` writer
        pub type W = crate::W<TXMIR0_SPEC>;
        ///Field `TXRQ` reader - Transmit mailbox request
        pub type TXRQ_R = crate::BitReader;
        ///Field `TXRQ` writer - Transmit mailbox request
        pub type TXRQ_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `RTR` reader - Remote transmission request
        pub type RTR_R = crate::BitReader;
        ///Field `RTR` writer - Remote transmission request
        pub type RTR_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `IDE` reader - Identifier extension
        pub type IDE_R = crate::BitReader;
        ///Field `IDE` writer - Identifier extension
        pub type IDE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `EXID` reader - extended identifier
        pub type EXID_R = crate::FieldReader<u32>;
        ///Field `EXID` writer - extended identifier
        pub type EXID_W<'a, REG> = crate::FieldWriter<'a, REG, 18, u32>;
        ///Field `STID` reader - Standard identifier
        pub type STID_R = crate::FieldReader<u16>;
        ///Field `STID` writer - Standard identifier
        pub type STID_W<'a, REG> = crate::FieldWriter<'a, REG, 11, u16>;
        impl R {
            ///Bit 0 - Transmit mailbox request
            #[inline(always)]
            pub fn txrq(&self) -> TXRQ_R {
                TXRQ_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Remote transmission request
            #[inline(always)]
            pub fn rtr(&self) -> RTR_R {
                RTR_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - Identifier extension
            #[inline(always)]
            pub fn ide(&self) -> IDE_R {
                IDE_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bits 3:20 - extended identifier
            #[inline(always)]
            pub fn exid(&self) -> EXID_R {
                EXID_R::new((self.bits >> 3) & 0x0003_ffff)
            }
            ///Bits 21:31 - Standard identifier
            #[inline(always)]
            pub fn stid(&self) -> STID_R {
                STID_R::new(((self.bits >> 21) & 0x07ff) as u16)
            }
        }
        impl W {
            ///Bit 0 - Transmit mailbox request
            #[inline(always)]
            #[must_use]
            pub fn txrq(&mut self) -> TXRQ_W<TXMIR0_SPEC> {
                TXRQ_W::new(self, 0)
            }
            ///Bit 1 - Remote transmission request
            #[inline(always)]
            #[must_use]
            pub fn rtr(&mut self) -> RTR_W<TXMIR0_SPEC> {
                RTR_W::new(self, 1)
            }
            ///Bit 2 - Identifier extension
            #[inline(always)]
            #[must_use]
            pub fn ide(&mut self) -> IDE_W<TXMIR0_SPEC> {
                IDE_W::new(self, 2)
            }
            ///Bits 3:20 - extended identifier
            #[inline(always)]
            #[must_use]
            pub fn exid(&mut self) -> EXID_W<TXMIR0_SPEC> {
                EXID_W::new(self, 3)
            }
            ///Bits 21:31 - Standard identifier
            #[inline(always)]
            #[must_use]
            pub fn stid(&mut self) -> STID_W<TXMIR0_SPEC> {
                STID_W::new(self, 21)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///CAN TX mailbox identifier register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`txmir0::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`txmir0::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct TXMIR0_SPEC;
        impl crate::RegisterSpec for TXMIR0_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`txmir0::R`](R) reader structure
        impl crate::Readable for TXMIR0_SPEC {}
        ///`write(|w| ..)` method takes [`txmir0::W`](W) writer structure
        impl crate::Writable for TXMIR0_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets TXMIR0 to value 0
        impl crate::Resettable for TXMIR0_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///TXMDTR0 (rw) register accessor: CAN mailbox data length control and time stamp register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`txmdtr0::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`txmdtr0::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@txmdtr0`]
    ///module
    pub type TXMDTR0 = crate::Reg<txmdtr0::TXMDTR0_SPEC>;
    ///CAN mailbox data length control and time stamp register
    pub mod txmdtr0 {
        ///Register `TXMDTR0` reader
        pub type R = crate::R<TXMDTR0_SPEC>;
        ///Register `TXMDTR0` writer
        pub type W = crate::W<TXMDTR0_SPEC>;
        ///Field `DLC` reader - Data length code
        pub type DLC_R = crate::FieldReader;
        ///Field `DLC` writer - Data length code
        pub type DLC_W<'a, REG> = crate::FieldWriter<'a, REG, 4>;
        ///Field `TGT` reader - Transmit global time
        pub type TGT_R = crate::BitReader;
        ///Field `TGT` writer - Transmit global time
        pub type TGT_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TIME` reader - Message time stamp
        pub type TIME_R = crate::FieldReader<u16>;
        ///Field `TIME` writer - Message time stamp
        pub type TIME_W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            ///Bits 0:3 - Data length code
            #[inline(always)]
            pub fn dlc(&self) -> DLC_R {
                DLC_R::new((self.bits & 0x0f) as u8)
            }
            ///Bit 8 - Transmit global time
            #[inline(always)]
            pub fn tgt(&self) -> TGT_R {
                TGT_R::new(((self.bits >> 8) & 1) != 0)
            }
            ///Bits 16:31 - Message time stamp
            #[inline(always)]
            pub fn time(&self) -> TIME_R {
                TIME_R::new(((self.bits >> 16) & 0xffff) as u16)
            }
        }
        impl W {
            ///Bits 0:3 - Data length code
            #[inline(always)]
            #[must_use]
            pub fn dlc(&mut self) -> DLC_W<TXMDTR0_SPEC> {
                DLC_W::new(self, 0)
            }
            ///Bit 8 - Transmit global time
            #[inline(always)]
            #[must_use]
            pub fn tgt(&mut self) -> TGT_W<TXMDTR0_SPEC> {
                TGT_W::new(self, 8)
            }
            ///Bits 16:31 - Message time stamp
            #[inline(always)]
            #[must_use]
            pub fn time(&mut self) -> TIME_W<TXMDTR0_SPEC> {
                TIME_W::new(self, 16)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///CAN mailbox data length control and time stamp register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`txmdtr0::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`txmdtr0::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct TXMDTR0_SPEC;
        impl crate::RegisterSpec for TXMDTR0_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`txmdtr0::R`](R) reader structure
        impl crate::Readable for TXMDTR0_SPEC {}
        ///`write(|w| ..)` method takes [`txmdtr0::W`](W) writer structure
        impl crate::Writable for TXMDTR0_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets TXMDTR0 to value 0
        impl crate::Resettable for TXMDTR0_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///TXMDLR0 (rw) register accessor: CAN mailbox data low register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`txmdlr0::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`txmdlr0::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@txmdlr0`]
    ///module
    pub type TXMDLR0 = crate::Reg<txmdlr0::TXMDLR0_SPEC>;
    ///CAN mailbox data low register
    pub mod txmdlr0 {
        ///Register `TXMDLR0` reader
        pub type R = crate::R<TXMDLR0_SPEC>;
        ///Register `TXMDLR0` writer
        pub type W = crate::W<TXMDLR0_SPEC>;
        ///Field `DATA0` reader - Data byte 0
        pub type DATA0_R = crate::FieldReader;
        ///Field `DATA0` writer - Data byte 0
        pub type DATA0_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        ///Field `DATA1` reader - Data byte 1
        pub type DATA1_R = crate::FieldReader;
        ///Field `DATA1` writer - Data byte 1
        pub type DATA1_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        ///Field `DATA2` reader - Data byte 2
        pub type DATA2_R = crate::FieldReader;
        ///Field `DATA2` writer - Data byte 2
        pub type DATA2_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        ///Field `DATA3` reader - Data byte 3
        pub type DATA3_R = crate::FieldReader;
        ///Field `DATA3` writer - Data byte 3
        pub type DATA3_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            ///Bits 0:7 - Data byte 0
            #[inline(always)]
            pub fn data0(&self) -> DATA0_R {
                DATA0_R::new((self.bits & 0xff) as u8)
            }
            ///Bits 8:15 - Data byte 1
            #[inline(always)]
            pub fn data1(&self) -> DATA1_R {
                DATA1_R::new(((self.bits >> 8) & 0xff) as u8)
            }
            ///Bits 16:23 - Data byte 2
            #[inline(always)]
            pub fn data2(&self) -> DATA2_R {
                DATA2_R::new(((self.bits >> 16) & 0xff) as u8)
            }
            ///Bits 24:31 - Data byte 3
            #[inline(always)]
            pub fn data3(&self) -> DATA3_R {
                DATA3_R::new(((self.bits >> 24) & 0xff) as u8)
            }
        }
        impl W {
            ///Bits 0:7 - Data byte 0
            #[inline(always)]
            #[must_use]
            pub fn data0(&mut self) -> DATA0_W<TXMDLR0_SPEC> {
                DATA0_W::new(self, 0)
            }
            ///Bits 8:15 - Data byte 1
            #[inline(always)]
            #[must_use]
            pub fn data1(&mut self) -> DATA1_W<TXMDLR0_SPEC> {
                DATA1_W::new(self, 8)
            }
            ///Bits 16:23 - Data byte 2
            #[inline(always)]
            #[must_use]
            pub fn data2(&mut self) -> DATA2_W<TXMDLR0_SPEC> {
                DATA2_W::new(self, 16)
            }
            ///Bits 24:31 - Data byte 3
            #[inline(always)]
            #[must_use]
            pub fn data3(&mut self) -> DATA3_W<TXMDLR0_SPEC> {
                DATA3_W::new(self, 24)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///CAN mailbox data low register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`txmdlr0::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`txmdlr0::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct TXMDLR0_SPEC;
        impl crate::RegisterSpec for TXMDLR0_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`txmdlr0::R`](R) reader structure
        impl crate::Readable for TXMDLR0_SPEC {}
        ///`write(|w| ..)` method takes [`txmdlr0::W`](W) writer structure
        impl crate::Writable for TXMDLR0_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets TXMDLR0 to value 0
        impl crate::Resettable for TXMDLR0_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///TXMDHR0 (rw) register accessor: CAN mailbox data high register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`txmdhr0::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`txmdhr0::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@txmdhr0`]
    ///module
    pub type TXMDHR0 = crate::Reg<txmdhr0::TXMDHR0_SPEC>;
    ///CAN mailbox data high register
    pub mod txmdhr0 {
        ///Register `TXMDHR0` reader
        pub type R = crate::R<TXMDHR0_SPEC>;
        ///Register `TXMDHR0` writer
        pub type W = crate::W<TXMDHR0_SPEC>;
        ///Field `DATA4` reader - Data byte 4
        pub type DATA4_R = crate::FieldReader;
        ///Field `DATA4` writer - Data byte 4
        pub type DATA4_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        ///Field `DATA5` reader - Data byte 5
        pub type DATA5_R = crate::FieldReader;
        ///Field `DATA5` writer - Data byte 5
        pub type DATA5_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        ///Field `DATA6` reader - Data byte 6
        pub type DATA6_R = crate::FieldReader;
        ///Field `DATA6` writer - Data byte 6
        pub type DATA6_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        ///Field `DATA7` reader - Data byte 7
        pub type DATA7_R = crate::FieldReader;
        ///Field `DATA7` writer - Data byte 7
        pub type DATA7_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            ///Bits 0:7 - Data byte 4
            #[inline(always)]
            pub fn data4(&self) -> DATA4_R {
                DATA4_R::new((self.bits & 0xff) as u8)
            }
            ///Bits 8:15 - Data byte 5
            #[inline(always)]
            pub fn data5(&self) -> DATA5_R {
                DATA5_R::new(((self.bits >> 8) & 0xff) as u8)
            }
            ///Bits 16:23 - Data byte 6
            #[inline(always)]
            pub fn data6(&self) -> DATA6_R {
                DATA6_R::new(((self.bits >> 16) & 0xff) as u8)
            }
            ///Bits 24:31 - Data byte 7
            #[inline(always)]
            pub fn data7(&self) -> DATA7_R {
                DATA7_R::new(((self.bits >> 24) & 0xff) as u8)
            }
        }
        impl W {
            ///Bits 0:7 - Data byte 4
            #[inline(always)]
            #[must_use]
            pub fn data4(&mut self) -> DATA4_W<TXMDHR0_SPEC> {
                DATA4_W::new(self, 0)
            }
            ///Bits 8:15 - Data byte 5
            #[inline(always)]
            #[must_use]
            pub fn data5(&mut self) -> DATA5_W<TXMDHR0_SPEC> {
                DATA5_W::new(self, 8)
            }
            ///Bits 16:23 - Data byte 6
            #[inline(always)]
            #[must_use]
            pub fn data6(&mut self) -> DATA6_W<TXMDHR0_SPEC> {
                DATA6_W::new(self, 16)
            }
            ///Bits 24:31 - Data byte 7
            #[inline(always)]
            #[must_use]
            pub fn data7(&mut self) -> DATA7_W<TXMDHR0_SPEC> {
                DATA7_W::new(self, 24)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///CAN mailbox data high register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`txmdhr0::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`txmdhr0::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct TXMDHR0_SPEC;
        impl crate::RegisterSpec for TXMDHR0_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`txmdhr0::R`](R) reader structure
        impl crate::Readable for TXMDHR0_SPEC {}
        ///`write(|w| ..)` method takes [`txmdhr0::W`](W) writer structure
        impl crate::Writable for TXMDHR0_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets TXMDHR0 to value 0
        impl crate::Resettable for TXMDHR0_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///TXMIR1 (rw) register accessor: CAN TX mailbox identifier register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`txmir1::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`txmir1::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@txmir1`]
    ///module
    pub type TXMIR1 = crate::Reg<txmir1::TXMIR1_SPEC>;
    ///CAN TX mailbox identifier register
    pub mod txmir1 {
        ///Register `TXMIR1` reader
        pub type R = crate::R<TXMIR1_SPEC>;
        ///Register `TXMIR1` writer
        pub type W = crate::W<TXMIR1_SPEC>;
        ///Field `TXRQ` reader - Transmit mailbox request
        pub type TXRQ_R = crate::BitReader;
        ///Field `TXRQ` writer - Transmit mailbox request
        pub type TXRQ_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `RTR` reader - Remote transmission request
        pub type RTR_R = crate::BitReader;
        ///Field `RTR` writer - Remote transmission request
        pub type RTR_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `IDE` reader - Identifier extension
        pub type IDE_R = crate::BitReader;
        ///Field `IDE` writer - Identifier extension
        pub type IDE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `EXID` reader - extended identifier
        pub type EXID_R = crate::FieldReader<u32>;
        ///Field `EXID` writer - extended identifier
        pub type EXID_W<'a, REG> = crate::FieldWriter<'a, REG, 18, u32>;
        ///Field `STID` reader - Standard identifier
        pub type STID_R = crate::FieldReader<u16>;
        ///Field `STID` writer - Standard identifier
        pub type STID_W<'a, REG> = crate::FieldWriter<'a, REG, 11, u16>;
        impl R {
            ///Bit 0 - Transmit mailbox request
            #[inline(always)]
            pub fn txrq(&self) -> TXRQ_R {
                TXRQ_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Remote transmission request
            #[inline(always)]
            pub fn rtr(&self) -> RTR_R {
                RTR_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - Identifier extension
            #[inline(always)]
            pub fn ide(&self) -> IDE_R {
                IDE_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bits 3:20 - extended identifier
            #[inline(always)]
            pub fn exid(&self) -> EXID_R {
                EXID_R::new((self.bits >> 3) & 0x0003_ffff)
            }
            ///Bits 21:31 - Standard identifier
            #[inline(always)]
            pub fn stid(&self) -> STID_R {
                STID_R::new(((self.bits >> 21) & 0x07ff) as u16)
            }
        }
        impl W {
            ///Bit 0 - Transmit mailbox request
            #[inline(always)]
            #[must_use]
            pub fn txrq(&mut self) -> TXRQ_W<TXMIR1_SPEC> {
                TXRQ_W::new(self, 0)
            }
            ///Bit 1 - Remote transmission request
            #[inline(always)]
            #[must_use]
            pub fn rtr(&mut self) -> RTR_W<TXMIR1_SPEC> {
                RTR_W::new(self, 1)
            }
            ///Bit 2 - Identifier extension
            #[inline(always)]
            #[must_use]
            pub fn ide(&mut self) -> IDE_W<TXMIR1_SPEC> {
                IDE_W::new(self, 2)
            }
            ///Bits 3:20 - extended identifier
            #[inline(always)]
            #[must_use]
            pub fn exid(&mut self) -> EXID_W<TXMIR1_SPEC> {
                EXID_W::new(self, 3)
            }
            ///Bits 21:31 - Standard identifier
            #[inline(always)]
            #[must_use]
            pub fn stid(&mut self) -> STID_W<TXMIR1_SPEC> {
                STID_W::new(self, 21)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///CAN TX mailbox identifier register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`txmir1::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`txmir1::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct TXMIR1_SPEC;
        impl crate::RegisterSpec for TXMIR1_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`txmir1::R`](R) reader structure
        impl crate::Readable for TXMIR1_SPEC {}
        ///`write(|w| ..)` method takes [`txmir1::W`](W) writer structure
        impl crate::Writable for TXMIR1_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets TXMIR1 to value 0
        impl crate::Resettable for TXMIR1_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///TXMDTR1 (rw) register accessor: CAN mailbox data length control and time stamp register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`txmdtr1::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`txmdtr1::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@txmdtr1`]
    ///module
    pub type TXMDTR1 = crate::Reg<txmdtr1::TXMDTR1_SPEC>;
    ///CAN mailbox data length control and time stamp register
    pub mod txmdtr1 {
        ///Register `TXMDTR1` reader
        pub type R = crate::R<TXMDTR1_SPEC>;
        ///Register `TXMDTR1` writer
        pub type W = crate::W<TXMDTR1_SPEC>;
        ///Field `DLC` reader - Data length code
        pub type DLC_R = crate::FieldReader;
        ///Field `DLC` writer - Data length code
        pub type DLC_W<'a, REG> = crate::FieldWriter<'a, REG, 4>;
        ///Field `TGT` reader - Transmit global time
        pub type TGT_R = crate::BitReader;
        ///Field `TGT` writer - Transmit global time
        pub type TGT_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TIME` reader - Message time stamp
        pub type TIME_R = crate::FieldReader<u16>;
        ///Field `TIME` writer - Message time stamp
        pub type TIME_W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            ///Bits 0:3 - Data length code
            #[inline(always)]
            pub fn dlc(&self) -> DLC_R {
                DLC_R::new((self.bits & 0x0f) as u8)
            }
            ///Bit 8 - Transmit global time
            #[inline(always)]
            pub fn tgt(&self) -> TGT_R {
                TGT_R::new(((self.bits >> 8) & 1) != 0)
            }
            ///Bits 16:31 - Message time stamp
            #[inline(always)]
            pub fn time(&self) -> TIME_R {
                TIME_R::new(((self.bits >> 16) & 0xffff) as u16)
            }
        }
        impl W {
            ///Bits 0:3 - Data length code
            #[inline(always)]
            #[must_use]
            pub fn dlc(&mut self) -> DLC_W<TXMDTR1_SPEC> {
                DLC_W::new(self, 0)
            }
            ///Bit 8 - Transmit global time
            #[inline(always)]
            #[must_use]
            pub fn tgt(&mut self) -> TGT_W<TXMDTR1_SPEC> {
                TGT_W::new(self, 8)
            }
            ///Bits 16:31 - Message time stamp
            #[inline(always)]
            #[must_use]
            pub fn time(&mut self) -> TIME_W<TXMDTR1_SPEC> {
                TIME_W::new(self, 16)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///CAN mailbox data length control and time stamp register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`txmdtr1::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`txmdtr1::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct TXMDTR1_SPEC;
        impl crate::RegisterSpec for TXMDTR1_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`txmdtr1::R`](R) reader structure
        impl crate::Readable for TXMDTR1_SPEC {}
        ///`write(|w| ..)` method takes [`txmdtr1::W`](W) writer structure
        impl crate::Writable for TXMDTR1_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets TXMDTR1 to value 0
        impl crate::Resettable for TXMDTR1_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///TXMDLR1 (rw) register accessor: CAN mailbox data low register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`txmdlr1::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`txmdlr1::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@txmdlr1`]
    ///module
    pub type TXMDLR1 = crate::Reg<txmdlr1::TXMDLR1_SPEC>;
    ///CAN mailbox data low register
    pub mod txmdlr1 {
        ///Register `TXMDLR1` reader
        pub type R = crate::R<TXMDLR1_SPEC>;
        ///Register `TXMDLR1` writer
        pub type W = crate::W<TXMDLR1_SPEC>;
        ///Field `DATA0` reader - Data byte 0
        pub type DATA0_R = crate::FieldReader;
        ///Field `DATA0` writer - Data byte 0
        pub type DATA0_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        ///Field `DATA1` reader - Data byte 1
        pub type DATA1_R = crate::FieldReader;
        ///Field `DATA1` writer - Data byte 1
        pub type DATA1_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        ///Field `DATA2` reader - Data byte 2
        pub type DATA2_R = crate::FieldReader;
        ///Field `DATA2` writer - Data byte 2
        pub type DATA2_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        ///Field `DATA3` reader - Data byte 3
        pub type DATA3_R = crate::FieldReader;
        ///Field `DATA3` writer - Data byte 3
        pub type DATA3_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            ///Bits 0:7 - Data byte 0
            #[inline(always)]
            pub fn data0(&self) -> DATA0_R {
                DATA0_R::new((self.bits & 0xff) as u8)
            }
            ///Bits 8:15 - Data byte 1
            #[inline(always)]
            pub fn data1(&self) -> DATA1_R {
                DATA1_R::new(((self.bits >> 8) & 0xff) as u8)
            }
            ///Bits 16:23 - Data byte 2
            #[inline(always)]
            pub fn data2(&self) -> DATA2_R {
                DATA2_R::new(((self.bits >> 16) & 0xff) as u8)
            }
            ///Bits 24:31 - Data byte 3
            #[inline(always)]
            pub fn data3(&self) -> DATA3_R {
                DATA3_R::new(((self.bits >> 24) & 0xff) as u8)
            }
        }
        impl W {
            ///Bits 0:7 - Data byte 0
            #[inline(always)]
            #[must_use]
            pub fn data0(&mut self) -> DATA0_W<TXMDLR1_SPEC> {
                DATA0_W::new(self, 0)
            }
            ///Bits 8:15 - Data byte 1
            #[inline(always)]
            #[must_use]
            pub fn data1(&mut self) -> DATA1_W<TXMDLR1_SPEC> {
                DATA1_W::new(self, 8)
            }
            ///Bits 16:23 - Data byte 2
            #[inline(always)]
            #[must_use]
            pub fn data2(&mut self) -> DATA2_W<TXMDLR1_SPEC> {
                DATA2_W::new(self, 16)
            }
            ///Bits 24:31 - Data byte 3
            #[inline(always)]
            #[must_use]
            pub fn data3(&mut self) -> DATA3_W<TXMDLR1_SPEC> {
                DATA3_W::new(self, 24)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///CAN mailbox data low register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`txmdlr1::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`txmdlr1::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct TXMDLR1_SPEC;
        impl crate::RegisterSpec for TXMDLR1_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`txmdlr1::R`](R) reader structure
        impl crate::Readable for TXMDLR1_SPEC {}
        ///`write(|w| ..)` method takes [`txmdlr1::W`](W) writer structure
        impl crate::Writable for TXMDLR1_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets TXMDLR1 to value 0
        impl crate::Resettable for TXMDLR1_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///TXMDHR1 (rw) register accessor: CAN mailbox data high register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`txmdhr1::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`txmdhr1::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@txmdhr1`]
    ///module
    pub type TXMDHR1 = crate::Reg<txmdhr1::TXMDHR1_SPEC>;
    ///CAN mailbox data high register
    pub mod txmdhr1 {
        ///Register `TXMDHR1` reader
        pub type R = crate::R<TXMDHR1_SPEC>;
        ///Register `TXMDHR1` writer
        pub type W = crate::W<TXMDHR1_SPEC>;
        ///Field `DATA4` reader - Data byte 4
        pub type DATA4_R = crate::FieldReader;
        ///Field `DATA4` writer - Data byte 4
        pub type DATA4_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        ///Field `DATA5` reader - Data byte 5
        pub type DATA5_R = crate::FieldReader;
        ///Field `DATA5` writer - Data byte 5
        pub type DATA5_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        ///Field `DATA6` reader - Data byte 6
        pub type DATA6_R = crate::FieldReader;
        ///Field `DATA6` writer - Data byte 6
        pub type DATA6_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        ///Field `DATA7` reader - Data byte 7
        pub type DATA7_R = crate::FieldReader;
        ///Field `DATA7` writer - Data byte 7
        pub type DATA7_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            ///Bits 0:7 - Data byte 4
            #[inline(always)]
            pub fn data4(&self) -> DATA4_R {
                DATA4_R::new((self.bits & 0xff) as u8)
            }
            ///Bits 8:15 - Data byte 5
            #[inline(always)]
            pub fn data5(&self) -> DATA5_R {
                DATA5_R::new(((self.bits >> 8) & 0xff) as u8)
            }
            ///Bits 16:23 - Data byte 6
            #[inline(always)]
            pub fn data6(&self) -> DATA6_R {
                DATA6_R::new(((self.bits >> 16) & 0xff) as u8)
            }
            ///Bits 24:31 - Data byte 7
            #[inline(always)]
            pub fn data7(&self) -> DATA7_R {
                DATA7_R::new(((self.bits >> 24) & 0xff) as u8)
            }
        }
        impl W {
            ///Bits 0:7 - Data byte 4
            #[inline(always)]
            #[must_use]
            pub fn data4(&mut self) -> DATA4_W<TXMDHR1_SPEC> {
                DATA4_W::new(self, 0)
            }
            ///Bits 8:15 - Data byte 5
            #[inline(always)]
            #[must_use]
            pub fn data5(&mut self) -> DATA5_W<TXMDHR1_SPEC> {
                DATA5_W::new(self, 8)
            }
            ///Bits 16:23 - Data byte 6
            #[inline(always)]
            #[must_use]
            pub fn data6(&mut self) -> DATA6_W<TXMDHR1_SPEC> {
                DATA6_W::new(self, 16)
            }
            ///Bits 24:31 - Data byte 7
            #[inline(always)]
            #[must_use]
            pub fn data7(&mut self) -> DATA7_W<TXMDHR1_SPEC> {
                DATA7_W::new(self, 24)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///CAN mailbox data high register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`txmdhr1::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`txmdhr1::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct TXMDHR1_SPEC;
        impl crate::RegisterSpec for TXMDHR1_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`txmdhr1::R`](R) reader structure
        impl crate::Readable for TXMDHR1_SPEC {}
        ///`write(|w| ..)` method takes [`txmdhr1::W`](W) writer structure
        impl crate::Writable for TXMDHR1_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets TXMDHR1 to value 0
        impl crate::Resettable for TXMDHR1_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///TXMIR2 (rw) register accessor: CAN TX mailbox identifier register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`txmir2::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`txmir2::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@txmir2`]
    ///module
    pub type TXMIR2 = crate::Reg<txmir2::TXMIR2_SPEC>;
    ///CAN TX mailbox identifier register
    pub mod txmir2 {
        ///Register `TXMIR2` reader
        pub type R = crate::R<TXMIR2_SPEC>;
        ///Register `TXMIR2` writer
        pub type W = crate::W<TXMIR2_SPEC>;
        ///Field `TXRQ` reader - Transmit mailbox request
        pub type TXRQ_R = crate::BitReader;
        ///Field `TXRQ` writer - Transmit mailbox request
        pub type TXRQ_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `RTR` reader - Remote transmission request
        pub type RTR_R = crate::BitReader;
        ///Field `RTR` writer - Remote transmission request
        pub type RTR_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `IDE` reader - Identifier extension
        pub type IDE_R = crate::BitReader;
        ///Field `IDE` writer - Identifier extension
        pub type IDE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `EXID` reader - extended identifier
        pub type EXID_R = crate::FieldReader<u32>;
        ///Field `EXID` writer - extended identifier
        pub type EXID_W<'a, REG> = crate::FieldWriter<'a, REG, 18, u32>;
        ///Field `STID` reader - Standard identifier
        pub type STID_R = crate::FieldReader<u16>;
        ///Field `STID` writer - Standard identifier
        pub type STID_W<'a, REG> = crate::FieldWriter<'a, REG, 11, u16>;
        impl R {
            ///Bit 0 - Transmit mailbox request
            #[inline(always)]
            pub fn txrq(&self) -> TXRQ_R {
                TXRQ_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Remote transmission request
            #[inline(always)]
            pub fn rtr(&self) -> RTR_R {
                RTR_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - Identifier extension
            #[inline(always)]
            pub fn ide(&self) -> IDE_R {
                IDE_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bits 3:20 - extended identifier
            #[inline(always)]
            pub fn exid(&self) -> EXID_R {
                EXID_R::new((self.bits >> 3) & 0x0003_ffff)
            }
            ///Bits 21:31 - Standard identifier
            #[inline(always)]
            pub fn stid(&self) -> STID_R {
                STID_R::new(((self.bits >> 21) & 0x07ff) as u16)
            }
        }
        impl W {
            ///Bit 0 - Transmit mailbox request
            #[inline(always)]
            #[must_use]
            pub fn txrq(&mut self) -> TXRQ_W<TXMIR2_SPEC> {
                TXRQ_W::new(self, 0)
            }
            ///Bit 1 - Remote transmission request
            #[inline(always)]
            #[must_use]
            pub fn rtr(&mut self) -> RTR_W<TXMIR2_SPEC> {
                RTR_W::new(self, 1)
            }
            ///Bit 2 - Identifier extension
            #[inline(always)]
            #[must_use]
            pub fn ide(&mut self) -> IDE_W<TXMIR2_SPEC> {
                IDE_W::new(self, 2)
            }
            ///Bits 3:20 - extended identifier
            #[inline(always)]
            #[must_use]
            pub fn exid(&mut self) -> EXID_W<TXMIR2_SPEC> {
                EXID_W::new(self, 3)
            }
            ///Bits 21:31 - Standard identifier
            #[inline(always)]
            #[must_use]
            pub fn stid(&mut self) -> STID_W<TXMIR2_SPEC> {
                STID_W::new(self, 21)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///CAN TX mailbox identifier register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`txmir2::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`txmir2::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct TXMIR2_SPEC;
        impl crate::RegisterSpec for TXMIR2_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`txmir2::R`](R) reader structure
        impl crate::Readable for TXMIR2_SPEC {}
        ///`write(|w| ..)` method takes [`txmir2::W`](W) writer structure
        impl crate::Writable for TXMIR2_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets TXMIR2 to value 0
        impl crate::Resettable for TXMIR2_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///TXMDTR2 (rw) register accessor: CAN mailbox data length control and time stamp register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`txmdtr2::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`txmdtr2::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@txmdtr2`]
    ///module
    pub type TXMDTR2 = crate::Reg<txmdtr2::TXMDTR2_SPEC>;
    ///CAN mailbox data length control and time stamp register
    pub mod txmdtr2 {
        ///Register `TXMDTR2` reader
        pub type R = crate::R<TXMDTR2_SPEC>;
        ///Register `TXMDTR2` writer
        pub type W = crate::W<TXMDTR2_SPEC>;
        ///Field `DLC` reader - Data length code
        pub type DLC_R = crate::FieldReader;
        ///Field `DLC` writer - Data length code
        pub type DLC_W<'a, REG> = crate::FieldWriter<'a, REG, 4>;
        ///Field `TGT` reader - Transmit global time
        pub type TGT_R = crate::BitReader;
        ///Field `TGT` writer - Transmit global time
        pub type TGT_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TIME` reader - Message time stamp
        pub type TIME_R = crate::FieldReader<u16>;
        ///Field `TIME` writer - Message time stamp
        pub type TIME_W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            ///Bits 0:3 - Data length code
            #[inline(always)]
            pub fn dlc(&self) -> DLC_R {
                DLC_R::new((self.bits & 0x0f) as u8)
            }
            ///Bit 8 - Transmit global time
            #[inline(always)]
            pub fn tgt(&self) -> TGT_R {
                TGT_R::new(((self.bits >> 8) & 1) != 0)
            }
            ///Bits 16:31 - Message time stamp
            #[inline(always)]
            pub fn time(&self) -> TIME_R {
                TIME_R::new(((self.bits >> 16) & 0xffff) as u16)
            }
        }
        impl W {
            ///Bits 0:3 - Data length code
            #[inline(always)]
            #[must_use]
            pub fn dlc(&mut self) -> DLC_W<TXMDTR2_SPEC> {
                DLC_W::new(self, 0)
            }
            ///Bit 8 - Transmit global time
            #[inline(always)]
            #[must_use]
            pub fn tgt(&mut self) -> TGT_W<TXMDTR2_SPEC> {
                TGT_W::new(self, 8)
            }
            ///Bits 16:31 - Message time stamp
            #[inline(always)]
            #[must_use]
            pub fn time(&mut self) -> TIME_W<TXMDTR2_SPEC> {
                TIME_W::new(self, 16)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///CAN mailbox data length control and time stamp register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`txmdtr2::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`txmdtr2::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct TXMDTR2_SPEC;
        impl crate::RegisterSpec for TXMDTR2_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`txmdtr2::R`](R) reader structure
        impl crate::Readable for TXMDTR2_SPEC {}
        ///`write(|w| ..)` method takes [`txmdtr2::W`](W) writer structure
        impl crate::Writable for TXMDTR2_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets TXMDTR2 to value 0
        impl crate::Resettable for TXMDTR2_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///TXMDLR2 (rw) register accessor: CAN mailbox data low register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`txmdlr2::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`txmdlr2::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@txmdlr2`]
    ///module
    pub type TXMDLR2 = crate::Reg<txmdlr2::TXMDLR2_SPEC>;
    ///CAN mailbox data low register
    pub mod txmdlr2 {
        ///Register `TXMDLR2` reader
        pub type R = crate::R<TXMDLR2_SPEC>;
        ///Register `TXMDLR2` writer
        pub type W = crate::W<TXMDLR2_SPEC>;
        ///Field `DATA0` reader - Data byte 0
        pub type DATA0_R = crate::FieldReader;
        ///Field `DATA0` writer - Data byte 0
        pub type DATA0_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        ///Field `DATA1` reader - Data byte 1
        pub type DATA1_R = crate::FieldReader;
        ///Field `DATA1` writer - Data byte 1
        pub type DATA1_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        ///Field `DATA2` reader - Data byte 2
        pub type DATA2_R = crate::FieldReader;
        ///Field `DATA2` writer - Data byte 2
        pub type DATA2_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        ///Field `DATA3` reader - Data byte 3
        pub type DATA3_R = crate::FieldReader;
        ///Field `DATA3` writer - Data byte 3
        pub type DATA3_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            ///Bits 0:7 - Data byte 0
            #[inline(always)]
            pub fn data0(&self) -> DATA0_R {
                DATA0_R::new((self.bits & 0xff) as u8)
            }
            ///Bits 8:15 - Data byte 1
            #[inline(always)]
            pub fn data1(&self) -> DATA1_R {
                DATA1_R::new(((self.bits >> 8) & 0xff) as u8)
            }
            ///Bits 16:23 - Data byte 2
            #[inline(always)]
            pub fn data2(&self) -> DATA2_R {
                DATA2_R::new(((self.bits >> 16) & 0xff) as u8)
            }
            ///Bits 24:31 - Data byte 3
            #[inline(always)]
            pub fn data3(&self) -> DATA3_R {
                DATA3_R::new(((self.bits >> 24) & 0xff) as u8)
            }
        }
        impl W {
            ///Bits 0:7 - Data byte 0
            #[inline(always)]
            #[must_use]
            pub fn data0(&mut self) -> DATA0_W<TXMDLR2_SPEC> {
                DATA0_W::new(self, 0)
            }
            ///Bits 8:15 - Data byte 1
            #[inline(always)]
            #[must_use]
            pub fn data1(&mut self) -> DATA1_W<TXMDLR2_SPEC> {
                DATA1_W::new(self, 8)
            }
            ///Bits 16:23 - Data byte 2
            #[inline(always)]
            #[must_use]
            pub fn data2(&mut self) -> DATA2_W<TXMDLR2_SPEC> {
                DATA2_W::new(self, 16)
            }
            ///Bits 24:31 - Data byte 3
            #[inline(always)]
            #[must_use]
            pub fn data3(&mut self) -> DATA3_W<TXMDLR2_SPEC> {
                DATA3_W::new(self, 24)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///CAN mailbox data low register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`txmdlr2::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`txmdlr2::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct TXMDLR2_SPEC;
        impl crate::RegisterSpec for TXMDLR2_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`txmdlr2::R`](R) reader structure
        impl crate::Readable for TXMDLR2_SPEC {}
        ///`write(|w| ..)` method takes [`txmdlr2::W`](W) writer structure
        impl crate::Writable for TXMDLR2_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets TXMDLR2 to value 0
        impl crate::Resettable for TXMDLR2_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///TXMDHR2 (rw) register accessor: CAN mailbox data high register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`txmdhr2::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`txmdhr2::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@txmdhr2`]
    ///module
    pub type TXMDHR2 = crate::Reg<txmdhr2::TXMDHR2_SPEC>;
    ///CAN mailbox data high register
    pub mod txmdhr2 {
        ///Register `TXMDHR2` reader
        pub type R = crate::R<TXMDHR2_SPEC>;
        ///Register `TXMDHR2` writer
        pub type W = crate::W<TXMDHR2_SPEC>;
        ///Field `DATA4` reader - Data byte 4
        pub type DATA4_R = crate::FieldReader;
        ///Field `DATA4` writer - Data byte 4
        pub type DATA4_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        ///Field `DATA5` reader - Data byte 5
        pub type DATA5_R = crate::FieldReader;
        ///Field `DATA5` writer - Data byte 5
        pub type DATA5_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        ///Field `DATA6` reader - Data byte 6
        pub type DATA6_R = crate::FieldReader;
        ///Field `DATA6` writer - Data byte 6
        pub type DATA6_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        ///Field `DATA7` reader - Data byte 7
        pub type DATA7_R = crate::FieldReader;
        ///Field `DATA7` writer - Data byte 7
        pub type DATA7_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            ///Bits 0:7 - Data byte 4
            #[inline(always)]
            pub fn data4(&self) -> DATA4_R {
                DATA4_R::new((self.bits & 0xff) as u8)
            }
            ///Bits 8:15 - Data byte 5
            #[inline(always)]
            pub fn data5(&self) -> DATA5_R {
                DATA5_R::new(((self.bits >> 8) & 0xff) as u8)
            }
            ///Bits 16:23 - Data byte 6
            #[inline(always)]
            pub fn data6(&self) -> DATA6_R {
                DATA6_R::new(((self.bits >> 16) & 0xff) as u8)
            }
            ///Bits 24:31 - Data byte 7
            #[inline(always)]
            pub fn data7(&self) -> DATA7_R {
                DATA7_R::new(((self.bits >> 24) & 0xff) as u8)
            }
        }
        impl W {
            ///Bits 0:7 - Data byte 4
            #[inline(always)]
            #[must_use]
            pub fn data4(&mut self) -> DATA4_W<TXMDHR2_SPEC> {
                DATA4_W::new(self, 0)
            }
            ///Bits 8:15 - Data byte 5
            #[inline(always)]
            #[must_use]
            pub fn data5(&mut self) -> DATA5_W<TXMDHR2_SPEC> {
                DATA5_W::new(self, 8)
            }
            ///Bits 16:23 - Data byte 6
            #[inline(always)]
            #[must_use]
            pub fn data6(&mut self) -> DATA6_W<TXMDHR2_SPEC> {
                DATA6_W::new(self, 16)
            }
            ///Bits 24:31 - Data byte 7
            #[inline(always)]
            #[must_use]
            pub fn data7(&mut self) -> DATA7_W<TXMDHR2_SPEC> {
                DATA7_W::new(self, 24)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///CAN mailbox data high register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`txmdhr2::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`txmdhr2::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct TXMDHR2_SPEC;
        impl crate::RegisterSpec for TXMDHR2_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`txmdhr2::R`](R) reader structure
        impl crate::Readable for TXMDHR2_SPEC {}
        ///`write(|w| ..)` method takes [`txmdhr2::W`](W) writer structure
        impl crate::Writable for TXMDHR2_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets TXMDHR2 to value 0
        impl crate::Resettable for TXMDHR2_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///RXMIR0 (r) register accessor: CAN receive FIFO mailbox identifier register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`rxmir0::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@rxmir0`]
    ///module
    pub type RXMIR0 = crate::Reg<rxmir0::RXMIR0_SPEC>;
    ///CAN receive FIFO mailbox identifier register
    pub mod rxmir0 {
        ///Register `RXMIR0` reader
        pub type R = crate::R<RXMIR0_SPEC>;
        ///Field `FDF` reader - Receive FD frame indication flag
        pub type FDF_R = crate::BitReader;
        ///Field `RTR` reader - Remote transmission request
        pub type RTR_R = crate::BitReader;
        ///Field `IDE` reader - Identifier extension
        pub type IDE_R = crate::BitReader;
        ///Field `EXID` reader - extended identifier
        pub type EXID_R = crate::FieldReader<u32>;
        ///Field `STID` reader - Standard identifier
        pub type STID_R = crate::FieldReader<u16>;
        impl R {
            ///Bit 0 - Receive FD frame indication flag
            #[inline(always)]
            pub fn fdf(&self) -> FDF_R {
                FDF_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Remote transmission request
            #[inline(always)]
            pub fn rtr(&self) -> RTR_R {
                RTR_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - Identifier extension
            #[inline(always)]
            pub fn ide(&self) -> IDE_R {
                IDE_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bits 3:20 - extended identifier
            #[inline(always)]
            pub fn exid(&self) -> EXID_R {
                EXID_R::new((self.bits >> 3) & 0x0003_ffff)
            }
            ///Bits 21:31 - Standard identifier
            #[inline(always)]
            pub fn stid(&self) -> STID_R {
                STID_R::new(((self.bits >> 21) & 0x07ff) as u16)
            }
        }
        ///CAN receive FIFO mailbox identifier register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`rxmir0::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct RXMIR0_SPEC;
        impl crate::RegisterSpec for RXMIR0_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`rxmir0::R`](R) reader structure
        impl crate::Readable for RXMIR0_SPEC {}
        ///`reset()` method sets RXMIR0 to value 0
        impl crate::Resettable for RXMIR0_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///RXMDTR0 (r) register accessor: CAN receive FIFO mailbox data length control and time stamp register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`rxmdtr0::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@rxmdtr0`]
    ///module
    pub type RXMDTR0 = crate::Reg<rxmdtr0::RXMDTR0_SPEC>;
    ///CAN receive FIFO mailbox data length control and time stamp register
    pub mod rxmdtr0 {
        ///Register `RXMDTR0` reader
        pub type R = crate::R<RXMDTR0_SPEC>;
        ///Field `DLC` reader - Data length code
        pub type DLC_R = crate::FieldReader;
        ///Field `BRS` reader - BRS bit of the received frame
        pub type BRS_R = crate::BitReader;
        ///Field `ESI` reader - ESI bit of the received frame
        pub type ESI_R = crate::BitReader;
        ///Field `RES` reader - RES bit of the received frame
        pub type RES_R = crate::BitReader;
        ///Field `FMI` reader - Filter match index
        pub type FMI_R = crate::FieldReader;
        ///Field `TIME` reader - Message time stamp
        pub type TIME_R = crate::FieldReader<u16>;
        impl R {
            ///Bits 0:3 - Data length code
            #[inline(always)]
            pub fn dlc(&self) -> DLC_R {
                DLC_R::new((self.bits & 0x0f) as u8)
            }
            ///Bit 4 - BRS bit of the received frame
            #[inline(always)]
            pub fn brs(&self) -> BRS_R {
                BRS_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - ESI bit of the received frame
            #[inline(always)]
            pub fn esi(&self) -> ESI_R {
                ESI_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - RES bit of the received frame
            #[inline(always)]
            pub fn res(&self) -> RES_R {
                RES_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bits 8:15 - Filter match index
            #[inline(always)]
            pub fn fmi(&self) -> FMI_R {
                FMI_R::new(((self.bits >> 8) & 0xff) as u8)
            }
            ///Bits 16:31 - Message time stamp
            #[inline(always)]
            pub fn time(&self) -> TIME_R {
                TIME_R::new(((self.bits >> 16) & 0xffff) as u16)
            }
        }
        ///CAN receive FIFO mailbox data length control and time stamp register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`rxmdtr0::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct RXMDTR0_SPEC;
        impl crate::RegisterSpec for RXMDTR0_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`rxmdtr0::R`](R) reader structure
        impl crate::Readable for RXMDTR0_SPEC {}
        ///`reset()` method sets RXMDTR0 to value 0
        impl crate::Resettable for RXMDTR0_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///RXMDLR0 (r) register accessor: CAN receive FIFO mailbox data low register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`rxmdlr0::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@rxmdlr0`]
    ///module
    pub type RXMDLR0 = crate::Reg<rxmdlr0::RXMDLR0_SPEC>;
    ///CAN receive FIFO mailbox data low register
    pub mod rxmdlr0 {
        ///Register `RXMDLR0` reader
        pub type R = crate::R<RXMDLR0_SPEC>;
        ///Field `DATA0` reader - Data Byte 0
        pub type DATA0_R = crate::FieldReader;
        ///Field `DATA1` reader - Data Byte 1
        pub type DATA1_R = crate::FieldReader;
        ///Field `DATA2` reader - Data Byte 2
        pub type DATA2_R = crate::FieldReader;
        ///Field `DATA3` reader - Data Byte 3
        pub type DATA3_R = crate::FieldReader;
        impl R {
            ///Bits 0:7 - Data Byte 0
            #[inline(always)]
            pub fn data0(&self) -> DATA0_R {
                DATA0_R::new((self.bits & 0xff) as u8)
            }
            ///Bits 8:15 - Data Byte 1
            #[inline(always)]
            pub fn data1(&self) -> DATA1_R {
                DATA1_R::new(((self.bits >> 8) & 0xff) as u8)
            }
            ///Bits 16:23 - Data Byte 2
            #[inline(always)]
            pub fn data2(&self) -> DATA2_R {
                DATA2_R::new(((self.bits >> 16) & 0xff) as u8)
            }
            ///Bits 24:31 - Data Byte 3
            #[inline(always)]
            pub fn data3(&self) -> DATA3_R {
                DATA3_R::new(((self.bits >> 24) & 0xff) as u8)
            }
        }
        ///CAN receive FIFO mailbox data low register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`rxmdlr0::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct RXMDLR0_SPEC;
        impl crate::RegisterSpec for RXMDLR0_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`rxmdlr0::R`](R) reader structure
        impl crate::Readable for RXMDLR0_SPEC {}
        ///`reset()` method sets RXMDLR0 to value 0
        impl crate::Resettable for RXMDLR0_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///RXMDHR0 (r) register accessor: CAN receive FIFO mailbox data high register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`rxmdhr0::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@rxmdhr0`]
    ///module
    pub type RXMDHR0 = crate::Reg<rxmdhr0::RXMDHR0_SPEC>;
    ///CAN receive FIFO mailbox data high register
    pub mod rxmdhr0 {
        ///Register `RXMDHR0` reader
        pub type R = crate::R<RXMDHR0_SPEC>;
        ///Field `DATA4` reader - DATA4
        pub type DATA4_R = crate::FieldReader;
        ///Field `DATA5` reader - DATA5
        pub type DATA5_R = crate::FieldReader;
        ///Field `DATA6` reader - DATA6
        pub type DATA6_R = crate::FieldReader;
        ///Field `DATA7` reader - DATA7
        pub type DATA7_R = crate::FieldReader;
        impl R {
            ///Bits 0:7 - DATA4
            #[inline(always)]
            pub fn data4(&self) -> DATA4_R {
                DATA4_R::new((self.bits & 0xff) as u8)
            }
            ///Bits 8:15 - DATA5
            #[inline(always)]
            pub fn data5(&self) -> DATA5_R {
                DATA5_R::new(((self.bits >> 8) & 0xff) as u8)
            }
            ///Bits 16:23 - DATA6
            #[inline(always)]
            pub fn data6(&self) -> DATA6_R {
                DATA6_R::new(((self.bits >> 16) & 0xff) as u8)
            }
            ///Bits 24:31 - DATA7
            #[inline(always)]
            pub fn data7(&self) -> DATA7_R {
                DATA7_R::new(((self.bits >> 24) & 0xff) as u8)
            }
        }
        ///CAN receive FIFO mailbox data high register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`rxmdhr0::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct RXMDHR0_SPEC;
        impl crate::RegisterSpec for RXMDHR0_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`rxmdhr0::R`](R) reader structure
        impl crate::Readable for RXMDHR0_SPEC {}
        ///`reset()` method sets RXMDHR0 to value 0
        impl crate::Resettable for RXMDHR0_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///RXMIR1 (r) register accessor: CAN receive FIFO mailbox identifier register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`rxmir1::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@rxmir1`]
    ///module
    pub type RXMIR1 = crate::Reg<rxmir1::RXMIR1_SPEC>;
    ///CAN receive FIFO mailbox identifier register
    pub mod rxmir1 {
        ///Register `RXMIR1` reader
        pub type R = crate::R<RXMIR1_SPEC>;
        ///Field `FDF` reader - Receive FD frame indication flag
        pub type FDF_R = crate::BitReader;
        ///Field `RTR` reader - Remote transmission request
        pub type RTR_R = crate::BitReader;
        ///Field `IDE` reader - Identifier extension
        pub type IDE_R = crate::BitReader;
        ///Field `EXID` reader - extended identifier
        pub type EXID_R = crate::FieldReader<u32>;
        ///Field `STID` reader - Standard identifier
        pub type STID_R = crate::FieldReader<u16>;
        impl R {
            ///Bit 0 - Receive FD frame indication flag
            #[inline(always)]
            pub fn fdf(&self) -> FDF_R {
                FDF_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Remote transmission request
            #[inline(always)]
            pub fn rtr(&self) -> RTR_R {
                RTR_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - Identifier extension
            #[inline(always)]
            pub fn ide(&self) -> IDE_R {
                IDE_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bits 3:20 - extended identifier
            #[inline(always)]
            pub fn exid(&self) -> EXID_R {
                EXID_R::new((self.bits >> 3) & 0x0003_ffff)
            }
            ///Bits 21:31 - Standard identifier
            #[inline(always)]
            pub fn stid(&self) -> STID_R {
                STID_R::new(((self.bits >> 21) & 0x07ff) as u16)
            }
        }
        ///CAN receive FIFO mailbox identifier register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`rxmir1::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct RXMIR1_SPEC;
        impl crate::RegisterSpec for RXMIR1_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`rxmir1::R`](R) reader structure
        impl crate::Readable for RXMIR1_SPEC {}
        ///`reset()` method sets RXMIR1 to value 0
        impl crate::Resettable for RXMIR1_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///RXMDTR1 (r) register accessor: CAN receive FIFO mailbox data length control and time stamp register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`rxmdtr1::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@rxmdtr1`]
    ///module
    pub type RXMDTR1 = crate::Reg<rxmdtr1::RXMDTR1_SPEC>;
    ///CAN receive FIFO mailbox data length control and time stamp register
    pub mod rxmdtr1 {
        ///Register `RXMDTR1` reader
        pub type R = crate::R<RXMDTR1_SPEC>;
        ///Field `DLC` reader - Data length code
        pub type DLC_R = crate::FieldReader;
        ///Field `BRS` reader - BRS bit of the received frame
        pub type BRS_R = crate::BitReader;
        ///Field `ESI` reader - ESI bit of the received frame
        pub type ESI_R = crate::BitReader;
        ///Field `RES` reader - RES bit of the received frame
        pub type RES_R = crate::BitReader;
        ///Field `FMI` reader - Filter match index
        pub type FMI_R = crate::FieldReader;
        ///Field `TIME` reader - Message time stamp
        pub type TIME_R = crate::FieldReader<u16>;
        impl R {
            ///Bits 0:3 - Data length code
            #[inline(always)]
            pub fn dlc(&self) -> DLC_R {
                DLC_R::new((self.bits & 0x0f) as u8)
            }
            ///Bit 4 - BRS bit of the received frame
            #[inline(always)]
            pub fn brs(&self) -> BRS_R {
                BRS_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - ESI bit of the received frame
            #[inline(always)]
            pub fn esi(&self) -> ESI_R {
                ESI_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - RES bit of the received frame
            #[inline(always)]
            pub fn res(&self) -> RES_R {
                RES_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bits 8:15 - Filter match index
            #[inline(always)]
            pub fn fmi(&self) -> FMI_R {
                FMI_R::new(((self.bits >> 8) & 0xff) as u8)
            }
            ///Bits 16:31 - Message time stamp
            #[inline(always)]
            pub fn time(&self) -> TIME_R {
                TIME_R::new(((self.bits >> 16) & 0xffff) as u16)
            }
        }
        ///CAN receive FIFO mailbox data length control and time stamp register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`rxmdtr1::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct RXMDTR1_SPEC;
        impl crate::RegisterSpec for RXMDTR1_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`rxmdtr1::R`](R) reader structure
        impl crate::Readable for RXMDTR1_SPEC {}
        ///`reset()` method sets RXMDTR1 to value 0
        impl crate::Resettable for RXMDTR1_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///RXMDLR1 (r) register accessor: CAN receive FIFO mailbox data low register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`rxmdlr1::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@rxmdlr1`]
    ///module
    pub type RXMDLR1 = crate::Reg<rxmdlr1::RXMDLR1_SPEC>;
    ///CAN receive FIFO mailbox data low register
    pub mod rxmdlr1 {
        ///Register `RXMDLR1` reader
        pub type R = crate::R<RXMDLR1_SPEC>;
        ///Field `DATA0` reader - Data Byte 0
        pub type DATA0_R = crate::FieldReader;
        ///Field `DATA1` reader - Data Byte 1
        pub type DATA1_R = crate::FieldReader;
        ///Field `DATA2` reader - Data Byte 2
        pub type DATA2_R = crate::FieldReader;
        ///Field `DATA3` reader - Data Byte 3
        pub type DATA3_R = crate::FieldReader;
        impl R {
            ///Bits 0:7 - Data Byte 0
            #[inline(always)]
            pub fn data0(&self) -> DATA0_R {
                DATA0_R::new((self.bits & 0xff) as u8)
            }
            ///Bits 8:15 - Data Byte 1
            #[inline(always)]
            pub fn data1(&self) -> DATA1_R {
                DATA1_R::new(((self.bits >> 8) & 0xff) as u8)
            }
            ///Bits 16:23 - Data Byte 2
            #[inline(always)]
            pub fn data2(&self) -> DATA2_R {
                DATA2_R::new(((self.bits >> 16) & 0xff) as u8)
            }
            ///Bits 24:31 - Data Byte 3
            #[inline(always)]
            pub fn data3(&self) -> DATA3_R {
                DATA3_R::new(((self.bits >> 24) & 0xff) as u8)
            }
        }
        ///CAN receive FIFO mailbox data low register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`rxmdlr1::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct RXMDLR1_SPEC;
        impl crate::RegisterSpec for RXMDLR1_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`rxmdlr1::R`](R) reader structure
        impl crate::Readable for RXMDLR1_SPEC {}
        ///`reset()` method sets RXMDLR1 to value 0
        impl crate::Resettable for RXMDLR1_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///RXMDHR1 (r) register accessor: CAN receive FIFO mailbox data high register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`rxmdhr1::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@rxmdhr1`]
    ///module
    pub type RXMDHR1 = crate::Reg<rxmdhr1::RXMDHR1_SPEC>;
    ///CAN receive FIFO mailbox data high register
    pub mod rxmdhr1 {
        ///Register `RXMDHR1` reader
        pub type R = crate::R<RXMDHR1_SPEC>;
        ///Field `DATA4` reader - DATA4
        pub type DATA4_R = crate::FieldReader;
        ///Field `DATA5` reader - DATA5
        pub type DATA5_R = crate::FieldReader;
        ///Field `DATA6` reader - DATA6
        pub type DATA6_R = crate::FieldReader;
        ///Field `DATA7` reader - DATA7
        pub type DATA7_R = crate::FieldReader;
        impl R {
            ///Bits 0:7 - DATA4
            #[inline(always)]
            pub fn data4(&self) -> DATA4_R {
                DATA4_R::new((self.bits & 0xff) as u8)
            }
            ///Bits 8:15 - DATA5
            #[inline(always)]
            pub fn data5(&self) -> DATA5_R {
                DATA5_R::new(((self.bits >> 8) & 0xff) as u8)
            }
            ///Bits 16:23 - DATA6
            #[inline(always)]
            pub fn data6(&self) -> DATA6_R {
                DATA6_R::new(((self.bits >> 16) & 0xff) as u8)
            }
            ///Bits 24:31 - DATA7
            #[inline(always)]
            pub fn data7(&self) -> DATA7_R {
                DATA7_R::new(((self.bits >> 24) & 0xff) as u8)
            }
        }
        ///CAN receive FIFO mailbox data high register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`rxmdhr1::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct RXMDHR1_SPEC;
        impl crate::RegisterSpec for RXMDHR1_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`rxmdhr1::R`](R) reader structure
        impl crate::Readable for RXMDHR1_SPEC {}
        ///`reset()` method sets RXMDHR1 to value 0
        impl crate::Resettable for RXMDHR1_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///FCTLR (rw) register accessor: CAN filter master register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`fctlr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`fctlr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@fctlr`]
    ///module
    pub type FCTLR = crate::Reg<fctlr::FCTLR_SPEC>;
    ///CAN filter master register
    pub mod fctlr {
        ///Register `FCTLR` reader
        pub type R = crate::R<FCTLR_SPEC>;
        ///Register `FCTLR` writer
        pub type W = crate::W<FCTLR_SPEC>;
        ///Field `FINIT` reader - Filter init mode
        pub type FINIT_R = crate::BitReader;
        ///Field `FINIT` writer - Filter init mode
        pub type FINIT_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - Filter init mode
            #[inline(always)]
            pub fn finit(&self) -> FINIT_R {
                FINIT_R::new((self.bits & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - Filter init mode
            #[inline(always)]
            #[must_use]
            pub fn finit(&mut self) -> FINIT_W<FCTLR_SPEC> {
                FINIT_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///CAN filter master register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`fctlr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`fctlr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct FCTLR_SPEC;
        impl crate::RegisterSpec for FCTLR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`fctlr::R`](R) reader structure
        impl crate::Readable for FCTLR_SPEC {}
        ///`write(|w| ..)` method takes [`fctlr::W`](W) writer structure
        impl crate::Writable for FCTLR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets FCTLR to value 0x2a1c_0e01
        impl crate::Resettable for FCTLR_SPEC {
            const RESET_VALUE: u32 = 0x2a1c_0e01;
        }
    }
    ///FMCFGR (rw) register accessor: CAN filter mode register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`fmcfgr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`fmcfgr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@fmcfgr`]
    ///module
    pub type FMCFGR = crate::Reg<fmcfgr::FMCFGR_SPEC>;
    ///CAN filter mode register
    pub mod fmcfgr {
        ///Register `FMCFGR` reader
        pub type R = crate::R<FMCFGR_SPEC>;
        ///Register `FMCFGR` writer
        pub type W = crate::W<FMCFGR_SPEC>;
        ///Field `FBM0` reader - Filter mode
        pub type FBM0_R = crate::BitReader;
        ///Field `FBM0` writer - Filter mode
        pub type FBM0_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FBM1` reader - Filter mode
        pub type FBM1_R = crate::BitReader;
        ///Field `FBM1` writer - Filter mode
        pub type FBM1_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FBM2` reader - Filter mode
        pub type FBM2_R = crate::BitReader;
        ///Field `FBM2` writer - Filter mode
        pub type FBM2_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FBM3` reader - Filter mode
        pub type FBM3_R = crate::BitReader;
        ///Field `FBM3` writer - Filter mode
        pub type FBM3_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FBM4` reader - Filter mode
        pub type FBM4_R = crate::BitReader;
        ///Field `FBM4` writer - Filter mode
        pub type FBM4_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FBM5` reader - Filter mode
        pub type FBM5_R = crate::BitReader;
        ///Field `FBM5` writer - Filter mode
        pub type FBM5_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FBM6` reader - Filter mode
        pub type FBM6_R = crate::BitReader;
        ///Field `FBM6` writer - Filter mode
        pub type FBM6_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FBM7` reader - Filter mode
        pub type FBM7_R = crate::BitReader;
        ///Field `FBM7` writer - Filter mode
        pub type FBM7_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FBM8` reader - Filter mode
        pub type FBM8_R = crate::BitReader;
        ///Field `FBM8` writer - Filter mode
        pub type FBM8_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FBM9` reader - Filter mode
        pub type FBM9_R = crate::BitReader;
        ///Field `FBM9` writer - Filter mode
        pub type FBM9_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FBM10` reader - Filter mode
        pub type FBM10_R = crate::BitReader;
        ///Field `FBM10` writer - Filter mode
        pub type FBM10_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FBM11` reader - Filter mode
        pub type FBM11_R = crate::BitReader;
        ///Field `FBM11` writer - Filter mode
        pub type FBM11_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FBM12` reader - Filter mode
        pub type FBM12_R = crate::BitReader;
        ///Field `FBM12` writer - Filter mode
        pub type FBM12_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FBM13` reader - Filter mode
        pub type FBM13_R = crate::BitReader;
        ///Field `FBM13` writer - Filter mode
        pub type FBM13_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FBM14` reader - Filter mode
        pub type FBM14_R = crate::BitReader;
        ///Field `FBM14` writer - Filter mode
        pub type FBM14_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FBM15` reader - Filter mode
        pub type FBM15_R = crate::BitReader;
        ///Field `FBM15` writer - Filter mode
        pub type FBM15_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FBM16` reader - Filter mode
        pub type FBM16_R = crate::BitReader;
        ///Field `FBM16` writer - Filter mode
        pub type FBM16_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FBM17` reader - Filter mode
        pub type FBM17_R = crate::BitReader;
        ///Field `FBM17` writer - Filter mode
        pub type FBM17_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FBM18` reader - Filter mode
        pub type FBM18_R = crate::BitReader;
        ///Field `FBM18` writer - Filter mode
        pub type FBM18_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FBM19` reader - Filter mode
        pub type FBM19_R = crate::BitReader;
        ///Field `FBM19` writer - Filter mode
        pub type FBM19_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FBM20` reader - Filter mode
        pub type FBM20_R = crate::BitReader;
        ///Field `FBM20` writer - Filter mode
        pub type FBM20_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FBM21` reader - Filter mode
        pub type FBM21_R = crate::BitReader;
        ///Field `FBM21` writer - Filter mode
        pub type FBM21_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FBM22` reader - Filter mode
        pub type FBM22_R = crate::BitReader;
        ///Field `FBM22` writer - Filter mode
        pub type FBM22_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FBM23` reader - Filter mode
        pub type FBM23_R = crate::BitReader;
        ///Field `FBM23` writer - Filter mode
        pub type FBM23_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FBM24` reader - Filter mode
        pub type FBM24_R = crate::BitReader;
        ///Field `FBM24` writer - Filter mode
        pub type FBM24_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FBM25` reader - Filter mode
        pub type FBM25_R = crate::BitReader;
        ///Field `FBM25` writer - Filter mode
        pub type FBM25_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FBM26` reader - Filter mode
        pub type FBM26_R = crate::BitReader;
        ///Field `FBM26` writer - Filter mode
        pub type FBM26_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FBM27` reader - Filter mode
        pub type FBM27_R = crate::BitReader;
        ///Field `FBM27` writer - Filter mode
        pub type FBM27_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - Filter mode
            #[inline(always)]
            pub fn fbm0(&self) -> FBM0_R {
                FBM0_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Filter mode
            #[inline(always)]
            pub fn fbm1(&self) -> FBM1_R {
                FBM1_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - Filter mode
            #[inline(always)]
            pub fn fbm2(&self) -> FBM2_R {
                FBM2_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - Filter mode
            #[inline(always)]
            pub fn fbm3(&self) -> FBM3_R {
                FBM3_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - Filter mode
            #[inline(always)]
            pub fn fbm4(&self) -> FBM4_R {
                FBM4_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - Filter mode
            #[inline(always)]
            pub fn fbm5(&self) -> FBM5_R {
                FBM5_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - Filter mode
            #[inline(always)]
            pub fn fbm6(&self) -> FBM6_R {
                FBM6_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - Filter mode
            #[inline(always)]
            pub fn fbm7(&self) -> FBM7_R {
                FBM7_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bit 8 - Filter mode
            #[inline(always)]
            pub fn fbm8(&self) -> FBM8_R {
                FBM8_R::new(((self.bits >> 8) & 1) != 0)
            }
            ///Bit 9 - Filter mode
            #[inline(always)]
            pub fn fbm9(&self) -> FBM9_R {
                FBM9_R::new(((self.bits >> 9) & 1) != 0)
            }
            ///Bit 10 - Filter mode
            #[inline(always)]
            pub fn fbm10(&self) -> FBM10_R {
                FBM10_R::new(((self.bits >> 10) & 1) != 0)
            }
            ///Bit 11 - Filter mode
            #[inline(always)]
            pub fn fbm11(&self) -> FBM11_R {
                FBM11_R::new(((self.bits >> 11) & 1) != 0)
            }
            ///Bit 12 - Filter mode
            #[inline(always)]
            pub fn fbm12(&self) -> FBM12_R {
                FBM12_R::new(((self.bits >> 12) & 1) != 0)
            }
            ///Bit 13 - Filter mode
            #[inline(always)]
            pub fn fbm13(&self) -> FBM13_R {
                FBM13_R::new(((self.bits >> 13) & 1) != 0)
            }
            ///Bit 14 - Filter mode
            #[inline(always)]
            pub fn fbm14(&self) -> FBM14_R {
                FBM14_R::new(((self.bits >> 14) & 1) != 0)
            }
            ///Bit 15 - Filter mode
            #[inline(always)]
            pub fn fbm15(&self) -> FBM15_R {
                FBM15_R::new(((self.bits >> 15) & 1) != 0)
            }
            ///Bit 16 - Filter mode
            #[inline(always)]
            pub fn fbm16(&self) -> FBM16_R {
                FBM16_R::new(((self.bits >> 16) & 1) != 0)
            }
            ///Bit 17 - Filter mode
            #[inline(always)]
            pub fn fbm17(&self) -> FBM17_R {
                FBM17_R::new(((self.bits >> 17) & 1) != 0)
            }
            ///Bit 18 - Filter mode
            #[inline(always)]
            pub fn fbm18(&self) -> FBM18_R {
                FBM18_R::new(((self.bits >> 18) & 1) != 0)
            }
            ///Bit 19 - Filter mode
            #[inline(always)]
            pub fn fbm19(&self) -> FBM19_R {
                FBM19_R::new(((self.bits >> 19) & 1) != 0)
            }
            ///Bit 20 - Filter mode
            #[inline(always)]
            pub fn fbm20(&self) -> FBM20_R {
                FBM20_R::new(((self.bits >> 20) & 1) != 0)
            }
            ///Bit 21 - Filter mode
            #[inline(always)]
            pub fn fbm21(&self) -> FBM21_R {
                FBM21_R::new(((self.bits >> 21) & 1) != 0)
            }
            ///Bit 22 - Filter mode
            #[inline(always)]
            pub fn fbm22(&self) -> FBM22_R {
                FBM22_R::new(((self.bits >> 22) & 1) != 0)
            }
            ///Bit 23 - Filter mode
            #[inline(always)]
            pub fn fbm23(&self) -> FBM23_R {
                FBM23_R::new(((self.bits >> 23) & 1) != 0)
            }
            ///Bit 24 - Filter mode
            #[inline(always)]
            pub fn fbm24(&self) -> FBM24_R {
                FBM24_R::new(((self.bits >> 24) & 1) != 0)
            }
            ///Bit 25 - Filter mode
            #[inline(always)]
            pub fn fbm25(&self) -> FBM25_R {
                FBM25_R::new(((self.bits >> 25) & 1) != 0)
            }
            ///Bit 26 - Filter mode
            #[inline(always)]
            pub fn fbm26(&self) -> FBM26_R {
                FBM26_R::new(((self.bits >> 26) & 1) != 0)
            }
            ///Bit 27 - Filter mode
            #[inline(always)]
            pub fn fbm27(&self) -> FBM27_R {
                FBM27_R::new(((self.bits >> 27) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - Filter mode
            #[inline(always)]
            #[must_use]
            pub fn fbm0(&mut self) -> FBM0_W<FMCFGR_SPEC> {
                FBM0_W::new(self, 0)
            }
            ///Bit 1 - Filter mode
            #[inline(always)]
            #[must_use]
            pub fn fbm1(&mut self) -> FBM1_W<FMCFGR_SPEC> {
                FBM1_W::new(self, 1)
            }
            ///Bit 2 - Filter mode
            #[inline(always)]
            #[must_use]
            pub fn fbm2(&mut self) -> FBM2_W<FMCFGR_SPEC> {
                FBM2_W::new(self, 2)
            }
            ///Bit 3 - Filter mode
            #[inline(always)]
            #[must_use]
            pub fn fbm3(&mut self) -> FBM3_W<FMCFGR_SPEC> {
                FBM3_W::new(self, 3)
            }
            ///Bit 4 - Filter mode
            #[inline(always)]
            #[must_use]
            pub fn fbm4(&mut self) -> FBM4_W<FMCFGR_SPEC> {
                FBM4_W::new(self, 4)
            }
            ///Bit 5 - Filter mode
            #[inline(always)]
            #[must_use]
            pub fn fbm5(&mut self) -> FBM5_W<FMCFGR_SPEC> {
                FBM5_W::new(self, 5)
            }
            ///Bit 6 - Filter mode
            #[inline(always)]
            #[must_use]
            pub fn fbm6(&mut self) -> FBM6_W<FMCFGR_SPEC> {
                FBM6_W::new(self, 6)
            }
            ///Bit 7 - Filter mode
            #[inline(always)]
            #[must_use]
            pub fn fbm7(&mut self) -> FBM7_W<FMCFGR_SPEC> {
                FBM7_W::new(self, 7)
            }
            ///Bit 8 - Filter mode
            #[inline(always)]
            #[must_use]
            pub fn fbm8(&mut self) -> FBM8_W<FMCFGR_SPEC> {
                FBM8_W::new(self, 8)
            }
            ///Bit 9 - Filter mode
            #[inline(always)]
            #[must_use]
            pub fn fbm9(&mut self) -> FBM9_W<FMCFGR_SPEC> {
                FBM9_W::new(self, 9)
            }
            ///Bit 10 - Filter mode
            #[inline(always)]
            #[must_use]
            pub fn fbm10(&mut self) -> FBM10_W<FMCFGR_SPEC> {
                FBM10_W::new(self, 10)
            }
            ///Bit 11 - Filter mode
            #[inline(always)]
            #[must_use]
            pub fn fbm11(&mut self) -> FBM11_W<FMCFGR_SPEC> {
                FBM11_W::new(self, 11)
            }
            ///Bit 12 - Filter mode
            #[inline(always)]
            #[must_use]
            pub fn fbm12(&mut self) -> FBM12_W<FMCFGR_SPEC> {
                FBM12_W::new(self, 12)
            }
            ///Bit 13 - Filter mode
            #[inline(always)]
            #[must_use]
            pub fn fbm13(&mut self) -> FBM13_W<FMCFGR_SPEC> {
                FBM13_W::new(self, 13)
            }
            ///Bit 14 - Filter mode
            #[inline(always)]
            #[must_use]
            pub fn fbm14(&mut self) -> FBM14_W<FMCFGR_SPEC> {
                FBM14_W::new(self, 14)
            }
            ///Bit 15 - Filter mode
            #[inline(always)]
            #[must_use]
            pub fn fbm15(&mut self) -> FBM15_W<FMCFGR_SPEC> {
                FBM15_W::new(self, 15)
            }
            ///Bit 16 - Filter mode
            #[inline(always)]
            #[must_use]
            pub fn fbm16(&mut self) -> FBM16_W<FMCFGR_SPEC> {
                FBM16_W::new(self, 16)
            }
            ///Bit 17 - Filter mode
            #[inline(always)]
            #[must_use]
            pub fn fbm17(&mut self) -> FBM17_W<FMCFGR_SPEC> {
                FBM17_W::new(self, 17)
            }
            ///Bit 18 - Filter mode
            #[inline(always)]
            #[must_use]
            pub fn fbm18(&mut self) -> FBM18_W<FMCFGR_SPEC> {
                FBM18_W::new(self, 18)
            }
            ///Bit 19 - Filter mode
            #[inline(always)]
            #[must_use]
            pub fn fbm19(&mut self) -> FBM19_W<FMCFGR_SPEC> {
                FBM19_W::new(self, 19)
            }
            ///Bit 20 - Filter mode
            #[inline(always)]
            #[must_use]
            pub fn fbm20(&mut self) -> FBM20_W<FMCFGR_SPEC> {
                FBM20_W::new(self, 20)
            }
            ///Bit 21 - Filter mode
            #[inline(always)]
            #[must_use]
            pub fn fbm21(&mut self) -> FBM21_W<FMCFGR_SPEC> {
                FBM21_W::new(self, 21)
            }
            ///Bit 22 - Filter mode
            #[inline(always)]
            #[must_use]
            pub fn fbm22(&mut self) -> FBM22_W<FMCFGR_SPEC> {
                FBM22_W::new(self, 22)
            }
            ///Bit 23 - Filter mode
            #[inline(always)]
            #[must_use]
            pub fn fbm23(&mut self) -> FBM23_W<FMCFGR_SPEC> {
                FBM23_W::new(self, 23)
            }
            ///Bit 24 - Filter mode
            #[inline(always)]
            #[must_use]
            pub fn fbm24(&mut self) -> FBM24_W<FMCFGR_SPEC> {
                FBM24_W::new(self, 24)
            }
            ///Bit 25 - Filter mode
            #[inline(always)]
            #[must_use]
            pub fn fbm25(&mut self) -> FBM25_W<FMCFGR_SPEC> {
                FBM25_W::new(self, 25)
            }
            ///Bit 26 - Filter mode
            #[inline(always)]
            #[must_use]
            pub fn fbm26(&mut self) -> FBM26_W<FMCFGR_SPEC> {
                FBM26_W::new(self, 26)
            }
            ///Bit 27 - Filter mode
            #[inline(always)]
            #[must_use]
            pub fn fbm27(&mut self) -> FBM27_W<FMCFGR_SPEC> {
                FBM27_W::new(self, 27)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///CAN filter mode register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`fmcfgr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`fmcfgr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct FMCFGR_SPEC;
        impl crate::RegisterSpec for FMCFGR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`fmcfgr::R`](R) reader structure
        impl crate::Readable for FMCFGR_SPEC {}
        ///`write(|w| ..)` method takes [`fmcfgr::W`](W) writer structure
        impl crate::Writable for FMCFGR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets FMCFGR to value 0
        impl crate::Resettable for FMCFGR_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///FSCFGR (rw) register accessor: CAN filter scale register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`fscfgr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`fscfgr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@fscfgr`]
    ///module
    pub type FSCFGR = crate::Reg<fscfgr::FSCFGR_SPEC>;
    ///CAN filter scale register
    pub mod fscfgr {
        ///Register `FSCFGR` reader
        pub type R = crate::R<FSCFGR_SPEC>;
        ///Register `FSCFGR` writer
        pub type W = crate::W<FSCFGR_SPEC>;
        ///Field `FSC0` reader - Filter scale configuration
        pub type FSC0_R = crate::BitReader;
        ///Field `FSC0` writer - Filter scale configuration
        pub type FSC0_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FSC1` reader - Filter scale configuration
        pub type FSC1_R = crate::BitReader;
        ///Field `FSC1` writer - Filter scale configuration
        pub type FSC1_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FSC2` reader - Filter scale configuration
        pub type FSC2_R = crate::BitReader;
        ///Field `FSC2` writer - Filter scale configuration
        pub type FSC2_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FSC3` reader - Filter scale configuration
        pub type FSC3_R = crate::BitReader;
        ///Field `FSC3` writer - Filter scale configuration
        pub type FSC3_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FSC4` reader - Filter scale configuration
        pub type FSC4_R = crate::BitReader;
        ///Field `FSC4` writer - Filter scale configuration
        pub type FSC4_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FSC5` reader - Filter scale configuration
        pub type FSC5_R = crate::BitReader;
        ///Field `FSC5` writer - Filter scale configuration
        pub type FSC5_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FSC6` reader - Filter scale configuration
        pub type FSC6_R = crate::BitReader;
        ///Field `FSC6` writer - Filter scale configuration
        pub type FSC6_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FSC7` reader - Filter scale configuration
        pub type FSC7_R = crate::BitReader;
        ///Field `FSC7` writer - Filter scale configuration
        pub type FSC7_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FSC8` reader - Filter scale configuration
        pub type FSC8_R = crate::BitReader;
        ///Field `FSC8` writer - Filter scale configuration
        pub type FSC8_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FSC9` reader - Filter scale configuration
        pub type FSC9_R = crate::BitReader;
        ///Field `FSC9` writer - Filter scale configuration
        pub type FSC9_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FSC10` reader - Filter scale configuration
        pub type FSC10_R = crate::BitReader;
        ///Field `FSC10` writer - Filter scale configuration
        pub type FSC10_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FSC11` reader - Filter scale configuration
        pub type FSC11_R = crate::BitReader;
        ///Field `FSC11` writer - Filter scale configuration
        pub type FSC11_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FSC12` reader - Filter scale configuration
        pub type FSC12_R = crate::BitReader;
        ///Field `FSC12` writer - Filter scale configuration
        pub type FSC12_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FSC13` reader - Filter scale configuration
        pub type FSC13_R = crate::BitReader;
        ///Field `FSC13` writer - Filter scale configuration
        pub type FSC13_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FSC14` reader - Filter scale configuration
        pub type FSC14_R = crate::BitReader;
        ///Field `FSC14` writer - Filter scale configuration
        pub type FSC14_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FSC15` reader - Filter scale configuration
        pub type FSC15_R = crate::BitReader;
        ///Field `FSC15` writer - Filter scale configuration
        pub type FSC15_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FSC16` reader - Filter scale configuration
        pub type FSC16_R = crate::BitReader;
        ///Field `FSC16` writer - Filter scale configuration
        pub type FSC16_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FSC17` reader - Filter scale configuration
        pub type FSC17_R = crate::BitReader;
        ///Field `FSC17` writer - Filter scale configuration
        pub type FSC17_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FSC18` reader - Filter scale configuration
        pub type FSC18_R = crate::BitReader;
        ///Field `FSC18` writer - Filter scale configuration
        pub type FSC18_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FSC19` reader - Filter scale configuration
        pub type FSC19_R = crate::BitReader;
        ///Field `FSC19` writer - Filter scale configuration
        pub type FSC19_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FSC20` reader - Filter scale configuration
        pub type FSC20_R = crate::BitReader;
        ///Field `FSC20` writer - Filter scale configuration
        pub type FSC20_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FSC21` reader - Filter scale configuration
        pub type FSC21_R = crate::BitReader;
        ///Field `FSC21` writer - Filter scale configuration
        pub type FSC21_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FSC22` reader - Filter scale configuration
        pub type FSC22_R = crate::BitReader;
        ///Field `FSC22` writer - Filter scale configuration
        pub type FSC22_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FSC23` reader - Filter scale configuration
        pub type FSC23_R = crate::BitReader;
        ///Field `FSC23` writer - Filter scale configuration
        pub type FSC23_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FSC24` reader - Filter scale configuration
        pub type FSC24_R = crate::BitReader;
        ///Field `FSC24` writer - Filter scale configuration
        pub type FSC24_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FSC25` reader - Filter scale configuration
        pub type FSC25_R = crate::BitReader;
        ///Field `FSC25` writer - Filter scale configuration
        pub type FSC25_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FSC26` reader - Filter scale configuration
        pub type FSC26_R = crate::BitReader;
        ///Field `FSC26` writer - Filter scale configuration
        pub type FSC26_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FSC27` reader - Filter scale configuration
        pub type FSC27_R = crate::BitReader;
        ///Field `FSC27` writer - Filter scale configuration
        pub type FSC27_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - Filter scale configuration
            #[inline(always)]
            pub fn fsc0(&self) -> FSC0_R {
                FSC0_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Filter scale configuration
            #[inline(always)]
            pub fn fsc1(&self) -> FSC1_R {
                FSC1_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - Filter scale configuration
            #[inline(always)]
            pub fn fsc2(&self) -> FSC2_R {
                FSC2_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - Filter scale configuration
            #[inline(always)]
            pub fn fsc3(&self) -> FSC3_R {
                FSC3_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - Filter scale configuration
            #[inline(always)]
            pub fn fsc4(&self) -> FSC4_R {
                FSC4_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - Filter scale configuration
            #[inline(always)]
            pub fn fsc5(&self) -> FSC5_R {
                FSC5_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - Filter scale configuration
            #[inline(always)]
            pub fn fsc6(&self) -> FSC6_R {
                FSC6_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - Filter scale configuration
            #[inline(always)]
            pub fn fsc7(&self) -> FSC7_R {
                FSC7_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bit 8 - Filter scale configuration
            #[inline(always)]
            pub fn fsc8(&self) -> FSC8_R {
                FSC8_R::new(((self.bits >> 8) & 1) != 0)
            }
            ///Bit 9 - Filter scale configuration
            #[inline(always)]
            pub fn fsc9(&self) -> FSC9_R {
                FSC9_R::new(((self.bits >> 9) & 1) != 0)
            }
            ///Bit 10 - Filter scale configuration
            #[inline(always)]
            pub fn fsc10(&self) -> FSC10_R {
                FSC10_R::new(((self.bits >> 10) & 1) != 0)
            }
            ///Bit 11 - Filter scale configuration
            #[inline(always)]
            pub fn fsc11(&self) -> FSC11_R {
                FSC11_R::new(((self.bits >> 11) & 1) != 0)
            }
            ///Bit 12 - Filter scale configuration
            #[inline(always)]
            pub fn fsc12(&self) -> FSC12_R {
                FSC12_R::new(((self.bits >> 12) & 1) != 0)
            }
            ///Bit 13 - Filter scale configuration
            #[inline(always)]
            pub fn fsc13(&self) -> FSC13_R {
                FSC13_R::new(((self.bits >> 13) & 1) != 0)
            }
            ///Bit 14 - Filter scale configuration
            #[inline(always)]
            pub fn fsc14(&self) -> FSC14_R {
                FSC14_R::new(((self.bits >> 14) & 1) != 0)
            }
            ///Bit 15 - Filter scale configuration
            #[inline(always)]
            pub fn fsc15(&self) -> FSC15_R {
                FSC15_R::new(((self.bits >> 15) & 1) != 0)
            }
            ///Bit 16 - Filter scale configuration
            #[inline(always)]
            pub fn fsc16(&self) -> FSC16_R {
                FSC16_R::new(((self.bits >> 16) & 1) != 0)
            }
            ///Bit 17 - Filter scale configuration
            #[inline(always)]
            pub fn fsc17(&self) -> FSC17_R {
                FSC17_R::new(((self.bits >> 17) & 1) != 0)
            }
            ///Bit 18 - Filter scale configuration
            #[inline(always)]
            pub fn fsc18(&self) -> FSC18_R {
                FSC18_R::new(((self.bits >> 18) & 1) != 0)
            }
            ///Bit 19 - Filter scale configuration
            #[inline(always)]
            pub fn fsc19(&self) -> FSC19_R {
                FSC19_R::new(((self.bits >> 19) & 1) != 0)
            }
            ///Bit 20 - Filter scale configuration
            #[inline(always)]
            pub fn fsc20(&self) -> FSC20_R {
                FSC20_R::new(((self.bits >> 20) & 1) != 0)
            }
            ///Bit 21 - Filter scale configuration
            #[inline(always)]
            pub fn fsc21(&self) -> FSC21_R {
                FSC21_R::new(((self.bits >> 21) & 1) != 0)
            }
            ///Bit 22 - Filter scale configuration
            #[inline(always)]
            pub fn fsc22(&self) -> FSC22_R {
                FSC22_R::new(((self.bits >> 22) & 1) != 0)
            }
            ///Bit 23 - Filter scale configuration
            #[inline(always)]
            pub fn fsc23(&self) -> FSC23_R {
                FSC23_R::new(((self.bits >> 23) & 1) != 0)
            }
            ///Bit 24 - Filter scale configuration
            #[inline(always)]
            pub fn fsc24(&self) -> FSC24_R {
                FSC24_R::new(((self.bits >> 24) & 1) != 0)
            }
            ///Bit 25 - Filter scale configuration
            #[inline(always)]
            pub fn fsc25(&self) -> FSC25_R {
                FSC25_R::new(((self.bits >> 25) & 1) != 0)
            }
            ///Bit 26 - Filter scale configuration
            #[inline(always)]
            pub fn fsc26(&self) -> FSC26_R {
                FSC26_R::new(((self.bits >> 26) & 1) != 0)
            }
            ///Bit 27 - Filter scale configuration
            #[inline(always)]
            pub fn fsc27(&self) -> FSC27_R {
                FSC27_R::new(((self.bits >> 27) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - Filter scale configuration
            #[inline(always)]
            #[must_use]
            pub fn fsc0(&mut self) -> FSC0_W<FSCFGR_SPEC> {
                FSC0_W::new(self, 0)
            }
            ///Bit 1 - Filter scale configuration
            #[inline(always)]
            #[must_use]
            pub fn fsc1(&mut self) -> FSC1_W<FSCFGR_SPEC> {
                FSC1_W::new(self, 1)
            }
            ///Bit 2 - Filter scale configuration
            #[inline(always)]
            #[must_use]
            pub fn fsc2(&mut self) -> FSC2_W<FSCFGR_SPEC> {
                FSC2_W::new(self, 2)
            }
            ///Bit 3 - Filter scale configuration
            #[inline(always)]
            #[must_use]
            pub fn fsc3(&mut self) -> FSC3_W<FSCFGR_SPEC> {
                FSC3_W::new(self, 3)
            }
            ///Bit 4 - Filter scale configuration
            #[inline(always)]
            #[must_use]
            pub fn fsc4(&mut self) -> FSC4_W<FSCFGR_SPEC> {
                FSC4_W::new(self, 4)
            }
            ///Bit 5 - Filter scale configuration
            #[inline(always)]
            #[must_use]
            pub fn fsc5(&mut self) -> FSC5_W<FSCFGR_SPEC> {
                FSC5_W::new(self, 5)
            }
            ///Bit 6 - Filter scale configuration
            #[inline(always)]
            #[must_use]
            pub fn fsc6(&mut self) -> FSC6_W<FSCFGR_SPEC> {
                FSC6_W::new(self, 6)
            }
            ///Bit 7 - Filter scale configuration
            #[inline(always)]
            #[must_use]
            pub fn fsc7(&mut self) -> FSC7_W<FSCFGR_SPEC> {
                FSC7_W::new(self, 7)
            }
            ///Bit 8 - Filter scale configuration
            #[inline(always)]
            #[must_use]
            pub fn fsc8(&mut self) -> FSC8_W<FSCFGR_SPEC> {
                FSC8_W::new(self, 8)
            }
            ///Bit 9 - Filter scale configuration
            #[inline(always)]
            #[must_use]
            pub fn fsc9(&mut self) -> FSC9_W<FSCFGR_SPEC> {
                FSC9_W::new(self, 9)
            }
            ///Bit 10 - Filter scale configuration
            #[inline(always)]
            #[must_use]
            pub fn fsc10(&mut self) -> FSC10_W<FSCFGR_SPEC> {
                FSC10_W::new(self, 10)
            }
            ///Bit 11 - Filter scale configuration
            #[inline(always)]
            #[must_use]
            pub fn fsc11(&mut self) -> FSC11_W<FSCFGR_SPEC> {
                FSC11_W::new(self, 11)
            }
            ///Bit 12 - Filter scale configuration
            #[inline(always)]
            #[must_use]
            pub fn fsc12(&mut self) -> FSC12_W<FSCFGR_SPEC> {
                FSC12_W::new(self, 12)
            }
            ///Bit 13 - Filter scale configuration
            #[inline(always)]
            #[must_use]
            pub fn fsc13(&mut self) -> FSC13_W<FSCFGR_SPEC> {
                FSC13_W::new(self, 13)
            }
            ///Bit 14 - Filter scale configuration
            #[inline(always)]
            #[must_use]
            pub fn fsc14(&mut self) -> FSC14_W<FSCFGR_SPEC> {
                FSC14_W::new(self, 14)
            }
            ///Bit 15 - Filter scale configuration
            #[inline(always)]
            #[must_use]
            pub fn fsc15(&mut self) -> FSC15_W<FSCFGR_SPEC> {
                FSC15_W::new(self, 15)
            }
            ///Bit 16 - Filter scale configuration
            #[inline(always)]
            #[must_use]
            pub fn fsc16(&mut self) -> FSC16_W<FSCFGR_SPEC> {
                FSC16_W::new(self, 16)
            }
            ///Bit 17 - Filter scale configuration
            #[inline(always)]
            #[must_use]
            pub fn fsc17(&mut self) -> FSC17_W<FSCFGR_SPEC> {
                FSC17_W::new(self, 17)
            }
            ///Bit 18 - Filter scale configuration
            #[inline(always)]
            #[must_use]
            pub fn fsc18(&mut self) -> FSC18_W<FSCFGR_SPEC> {
                FSC18_W::new(self, 18)
            }
            ///Bit 19 - Filter scale configuration
            #[inline(always)]
            #[must_use]
            pub fn fsc19(&mut self) -> FSC19_W<FSCFGR_SPEC> {
                FSC19_W::new(self, 19)
            }
            ///Bit 20 - Filter scale configuration
            #[inline(always)]
            #[must_use]
            pub fn fsc20(&mut self) -> FSC20_W<FSCFGR_SPEC> {
                FSC20_W::new(self, 20)
            }
            ///Bit 21 - Filter scale configuration
            #[inline(always)]
            #[must_use]
            pub fn fsc21(&mut self) -> FSC21_W<FSCFGR_SPEC> {
                FSC21_W::new(self, 21)
            }
            ///Bit 22 - Filter scale configuration
            #[inline(always)]
            #[must_use]
            pub fn fsc22(&mut self) -> FSC22_W<FSCFGR_SPEC> {
                FSC22_W::new(self, 22)
            }
            ///Bit 23 - Filter scale configuration
            #[inline(always)]
            #[must_use]
            pub fn fsc23(&mut self) -> FSC23_W<FSCFGR_SPEC> {
                FSC23_W::new(self, 23)
            }
            ///Bit 24 - Filter scale configuration
            #[inline(always)]
            #[must_use]
            pub fn fsc24(&mut self) -> FSC24_W<FSCFGR_SPEC> {
                FSC24_W::new(self, 24)
            }
            ///Bit 25 - Filter scale configuration
            #[inline(always)]
            #[must_use]
            pub fn fsc25(&mut self) -> FSC25_W<FSCFGR_SPEC> {
                FSC25_W::new(self, 25)
            }
            ///Bit 26 - Filter scale configuration
            #[inline(always)]
            #[must_use]
            pub fn fsc26(&mut self) -> FSC26_W<FSCFGR_SPEC> {
                FSC26_W::new(self, 26)
            }
            ///Bit 27 - Filter scale configuration
            #[inline(always)]
            #[must_use]
            pub fn fsc27(&mut self) -> FSC27_W<FSCFGR_SPEC> {
                FSC27_W::new(self, 27)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///CAN filter scale register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`fscfgr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`fscfgr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct FSCFGR_SPEC;
        impl crate::RegisterSpec for FSCFGR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`fscfgr::R`](R) reader structure
        impl crate::Readable for FSCFGR_SPEC {}
        ///`write(|w| ..)` method takes [`fscfgr::W`](W) writer structure
        impl crate::Writable for FSCFGR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets FSCFGR to value 0
        impl crate::Resettable for FSCFGR_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///FAFIFOR (rw) register accessor: CAN filter FIFO assignment register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`fafifor::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`fafifor::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@fafifor`]
    ///module
    pub type FAFIFOR = crate::Reg<fafifor::FAFIFOR_SPEC>;
    ///CAN filter FIFO assignment register
    pub mod fafifor {
        ///Register `FAFIFOR` reader
        pub type R = crate::R<FAFIFOR_SPEC>;
        ///Register `FAFIFOR` writer
        pub type W = crate::W<FAFIFOR_SPEC>;
        ///Field `FFA0` reader - Filter FIFO assignment for filter 0
        pub type FFA0_R = crate::BitReader;
        ///Field `FFA0` writer - Filter FIFO assignment for filter 0
        pub type FFA0_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FFA1` reader - Filter FIFO assignment for filter 1
        pub type FFA1_R = crate::BitReader;
        ///Field `FFA1` writer - Filter FIFO assignment for filter 1
        pub type FFA1_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FFA2` reader - Filter FIFO assignment for filter 2
        pub type FFA2_R = crate::BitReader;
        ///Field `FFA2` writer - Filter FIFO assignment for filter 2
        pub type FFA2_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FFA3` reader - Filter FIFO assignment for filter 3
        pub type FFA3_R = crate::BitReader;
        ///Field `FFA3` writer - Filter FIFO assignment for filter 3
        pub type FFA3_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FFA4` reader - Filter FIFO assignment for filter 4
        pub type FFA4_R = crate::BitReader;
        ///Field `FFA4` writer - Filter FIFO assignment for filter 4
        pub type FFA4_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FFA5` reader - Filter FIFO assignment for filter 5
        pub type FFA5_R = crate::BitReader;
        ///Field `FFA5` writer - Filter FIFO assignment for filter 5
        pub type FFA5_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FFA6` reader - Filter FIFO assignment for filter 6
        pub type FFA6_R = crate::BitReader;
        ///Field `FFA6` writer - Filter FIFO assignment for filter 6
        pub type FFA6_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FFA7` reader - Filter FIFO assignment for filter 7
        pub type FFA7_R = crate::BitReader;
        ///Field `FFA7` writer - Filter FIFO assignment for filter 7
        pub type FFA7_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FFA8` reader - Filter FIFO assignment for filter 8
        pub type FFA8_R = crate::BitReader;
        ///Field `FFA8` writer - Filter FIFO assignment for filter 8
        pub type FFA8_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FFA9` reader - Filter FIFO assignment for filter 9
        pub type FFA9_R = crate::BitReader;
        ///Field `FFA9` writer - Filter FIFO assignment for filter 9
        pub type FFA9_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FFA10` reader - Filter FIFO assignment for filter 10
        pub type FFA10_R = crate::BitReader;
        ///Field `FFA10` writer - Filter FIFO assignment for filter 10
        pub type FFA10_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FFA11` reader - Filter FIFO assignment for filter 11
        pub type FFA11_R = crate::BitReader;
        ///Field `FFA11` writer - Filter FIFO assignment for filter 11
        pub type FFA11_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FFA12` reader - Filter FIFO assignment for filter 12
        pub type FFA12_R = crate::BitReader;
        ///Field `FFA12` writer - Filter FIFO assignment for filter 12
        pub type FFA12_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FFA13` reader - Filter FIFO assignment for filter 13
        pub type FFA13_R = crate::BitReader;
        ///Field `FFA13` writer - Filter FIFO assignment for filter 13
        pub type FFA13_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FFA14` reader - Filter FIFO assignment for filter 14
        pub type FFA14_R = crate::BitReader;
        ///Field `FFA14` writer - Filter FIFO assignment for filter 14
        pub type FFA14_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FFA15` reader - Filter FIFO assignment for filter 15
        pub type FFA15_R = crate::BitReader;
        ///Field `FFA15` writer - Filter FIFO assignment for filter 15
        pub type FFA15_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FFA16` reader - Filter FIFO assignment for filter 16
        pub type FFA16_R = crate::BitReader;
        ///Field `FFA16` writer - Filter FIFO assignment for filter 16
        pub type FFA16_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FFA17` reader - Filter FIFO assignment for filter 17
        pub type FFA17_R = crate::BitReader;
        ///Field `FFA17` writer - Filter FIFO assignment for filter 17
        pub type FFA17_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FFA18` reader - Filter FIFO assignment for filter 18
        pub type FFA18_R = crate::BitReader;
        ///Field `FFA18` writer - Filter FIFO assignment for filter 18
        pub type FFA18_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FFA19` reader - Filter FIFO assignment for filter 19
        pub type FFA19_R = crate::BitReader;
        ///Field `FFA19` writer - Filter FIFO assignment for filter 19
        pub type FFA19_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FFA20` reader - Filter FIFO assignment for filter 20
        pub type FFA20_R = crate::BitReader;
        ///Field `FFA20` writer - Filter FIFO assignment for filter 20
        pub type FFA20_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FFA21` reader - Filter FIFO assignment for filter 21
        pub type FFA21_R = crate::BitReader;
        ///Field `FFA21` writer - Filter FIFO assignment for filter 21
        pub type FFA21_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FFA22` reader - Filter FIFO assignment for filter 22
        pub type FFA22_R = crate::BitReader;
        ///Field `FFA22` writer - Filter FIFO assignment for filter 22
        pub type FFA22_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FFA23` reader - Filter FIFO assignment for filter 23
        pub type FFA23_R = crate::BitReader;
        ///Field `FFA23` writer - Filter FIFO assignment for filter 23
        pub type FFA23_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FFA24` reader - Filter FIFO assignment for filter 24
        pub type FFA24_R = crate::BitReader;
        ///Field `FFA24` writer - Filter FIFO assignment for filter 24
        pub type FFA24_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FFA25` reader - Filter FIFO assignment for filter 25
        pub type FFA25_R = crate::BitReader;
        ///Field `FFA25` writer - Filter FIFO assignment for filter 25
        pub type FFA25_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FFA26` reader - Filter FIFO assignment for filter 26
        pub type FFA26_R = crate::BitReader;
        ///Field `FFA26` writer - Filter FIFO assignment for filter 26
        pub type FFA26_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FFA27` reader - Filter FIFO assignment for filter 27
        pub type FFA27_R = crate::BitReader;
        ///Field `FFA27` writer - Filter FIFO assignment for filter 27
        pub type FFA27_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - Filter FIFO assignment for filter 0
            #[inline(always)]
            pub fn ffa0(&self) -> FFA0_R {
                FFA0_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Filter FIFO assignment for filter 1
            #[inline(always)]
            pub fn ffa1(&self) -> FFA1_R {
                FFA1_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - Filter FIFO assignment for filter 2
            #[inline(always)]
            pub fn ffa2(&self) -> FFA2_R {
                FFA2_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - Filter FIFO assignment for filter 3
            #[inline(always)]
            pub fn ffa3(&self) -> FFA3_R {
                FFA3_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - Filter FIFO assignment for filter 4
            #[inline(always)]
            pub fn ffa4(&self) -> FFA4_R {
                FFA4_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - Filter FIFO assignment for filter 5
            #[inline(always)]
            pub fn ffa5(&self) -> FFA5_R {
                FFA5_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - Filter FIFO assignment for filter 6
            #[inline(always)]
            pub fn ffa6(&self) -> FFA6_R {
                FFA6_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - Filter FIFO assignment for filter 7
            #[inline(always)]
            pub fn ffa7(&self) -> FFA7_R {
                FFA7_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bit 8 - Filter FIFO assignment for filter 8
            #[inline(always)]
            pub fn ffa8(&self) -> FFA8_R {
                FFA8_R::new(((self.bits >> 8) & 1) != 0)
            }
            ///Bit 9 - Filter FIFO assignment for filter 9
            #[inline(always)]
            pub fn ffa9(&self) -> FFA9_R {
                FFA9_R::new(((self.bits >> 9) & 1) != 0)
            }
            ///Bit 10 - Filter FIFO assignment for filter 10
            #[inline(always)]
            pub fn ffa10(&self) -> FFA10_R {
                FFA10_R::new(((self.bits >> 10) & 1) != 0)
            }
            ///Bit 11 - Filter FIFO assignment for filter 11
            #[inline(always)]
            pub fn ffa11(&self) -> FFA11_R {
                FFA11_R::new(((self.bits >> 11) & 1) != 0)
            }
            ///Bit 12 - Filter FIFO assignment for filter 12
            #[inline(always)]
            pub fn ffa12(&self) -> FFA12_R {
                FFA12_R::new(((self.bits >> 12) & 1) != 0)
            }
            ///Bit 13 - Filter FIFO assignment for filter 13
            #[inline(always)]
            pub fn ffa13(&self) -> FFA13_R {
                FFA13_R::new(((self.bits >> 13) & 1) != 0)
            }
            ///Bit 14 - Filter FIFO assignment for filter 14
            #[inline(always)]
            pub fn ffa14(&self) -> FFA14_R {
                FFA14_R::new(((self.bits >> 14) & 1) != 0)
            }
            ///Bit 15 - Filter FIFO assignment for filter 15
            #[inline(always)]
            pub fn ffa15(&self) -> FFA15_R {
                FFA15_R::new(((self.bits >> 15) & 1) != 0)
            }
            ///Bit 16 - Filter FIFO assignment for filter 16
            #[inline(always)]
            pub fn ffa16(&self) -> FFA16_R {
                FFA16_R::new(((self.bits >> 16) & 1) != 0)
            }
            ///Bit 17 - Filter FIFO assignment for filter 17
            #[inline(always)]
            pub fn ffa17(&self) -> FFA17_R {
                FFA17_R::new(((self.bits >> 17) & 1) != 0)
            }
            ///Bit 18 - Filter FIFO assignment for filter 18
            #[inline(always)]
            pub fn ffa18(&self) -> FFA18_R {
                FFA18_R::new(((self.bits >> 18) & 1) != 0)
            }
            ///Bit 19 - Filter FIFO assignment for filter 19
            #[inline(always)]
            pub fn ffa19(&self) -> FFA19_R {
                FFA19_R::new(((self.bits >> 19) & 1) != 0)
            }
            ///Bit 20 - Filter FIFO assignment for filter 20
            #[inline(always)]
            pub fn ffa20(&self) -> FFA20_R {
                FFA20_R::new(((self.bits >> 20) & 1) != 0)
            }
            ///Bit 21 - Filter FIFO assignment for filter 21
            #[inline(always)]
            pub fn ffa21(&self) -> FFA21_R {
                FFA21_R::new(((self.bits >> 21) & 1) != 0)
            }
            ///Bit 22 - Filter FIFO assignment for filter 22
            #[inline(always)]
            pub fn ffa22(&self) -> FFA22_R {
                FFA22_R::new(((self.bits >> 22) & 1) != 0)
            }
            ///Bit 23 - Filter FIFO assignment for filter 23
            #[inline(always)]
            pub fn ffa23(&self) -> FFA23_R {
                FFA23_R::new(((self.bits >> 23) & 1) != 0)
            }
            ///Bit 24 - Filter FIFO assignment for filter 24
            #[inline(always)]
            pub fn ffa24(&self) -> FFA24_R {
                FFA24_R::new(((self.bits >> 24) & 1) != 0)
            }
            ///Bit 25 - Filter FIFO assignment for filter 25
            #[inline(always)]
            pub fn ffa25(&self) -> FFA25_R {
                FFA25_R::new(((self.bits >> 25) & 1) != 0)
            }
            ///Bit 26 - Filter FIFO assignment for filter 26
            #[inline(always)]
            pub fn ffa26(&self) -> FFA26_R {
                FFA26_R::new(((self.bits >> 26) & 1) != 0)
            }
            ///Bit 27 - Filter FIFO assignment for filter 27
            #[inline(always)]
            pub fn ffa27(&self) -> FFA27_R {
                FFA27_R::new(((self.bits >> 27) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - Filter FIFO assignment for filter 0
            #[inline(always)]
            #[must_use]
            pub fn ffa0(&mut self) -> FFA0_W<FAFIFOR_SPEC> {
                FFA0_W::new(self, 0)
            }
            ///Bit 1 - Filter FIFO assignment for filter 1
            #[inline(always)]
            #[must_use]
            pub fn ffa1(&mut self) -> FFA1_W<FAFIFOR_SPEC> {
                FFA1_W::new(self, 1)
            }
            ///Bit 2 - Filter FIFO assignment for filter 2
            #[inline(always)]
            #[must_use]
            pub fn ffa2(&mut self) -> FFA2_W<FAFIFOR_SPEC> {
                FFA2_W::new(self, 2)
            }
            ///Bit 3 - Filter FIFO assignment for filter 3
            #[inline(always)]
            #[must_use]
            pub fn ffa3(&mut self) -> FFA3_W<FAFIFOR_SPEC> {
                FFA3_W::new(self, 3)
            }
            ///Bit 4 - Filter FIFO assignment for filter 4
            #[inline(always)]
            #[must_use]
            pub fn ffa4(&mut self) -> FFA4_W<FAFIFOR_SPEC> {
                FFA4_W::new(self, 4)
            }
            ///Bit 5 - Filter FIFO assignment for filter 5
            #[inline(always)]
            #[must_use]
            pub fn ffa5(&mut self) -> FFA5_W<FAFIFOR_SPEC> {
                FFA5_W::new(self, 5)
            }
            ///Bit 6 - Filter FIFO assignment for filter 6
            #[inline(always)]
            #[must_use]
            pub fn ffa6(&mut self) -> FFA6_W<FAFIFOR_SPEC> {
                FFA6_W::new(self, 6)
            }
            ///Bit 7 - Filter FIFO assignment for filter 7
            #[inline(always)]
            #[must_use]
            pub fn ffa7(&mut self) -> FFA7_W<FAFIFOR_SPEC> {
                FFA7_W::new(self, 7)
            }
            ///Bit 8 - Filter FIFO assignment for filter 8
            #[inline(always)]
            #[must_use]
            pub fn ffa8(&mut self) -> FFA8_W<FAFIFOR_SPEC> {
                FFA8_W::new(self, 8)
            }
            ///Bit 9 - Filter FIFO assignment for filter 9
            #[inline(always)]
            #[must_use]
            pub fn ffa9(&mut self) -> FFA9_W<FAFIFOR_SPEC> {
                FFA9_W::new(self, 9)
            }
            ///Bit 10 - Filter FIFO assignment for filter 10
            #[inline(always)]
            #[must_use]
            pub fn ffa10(&mut self) -> FFA10_W<FAFIFOR_SPEC> {
                FFA10_W::new(self, 10)
            }
            ///Bit 11 - Filter FIFO assignment for filter 11
            #[inline(always)]
            #[must_use]
            pub fn ffa11(&mut self) -> FFA11_W<FAFIFOR_SPEC> {
                FFA11_W::new(self, 11)
            }
            ///Bit 12 - Filter FIFO assignment for filter 12
            #[inline(always)]
            #[must_use]
            pub fn ffa12(&mut self) -> FFA12_W<FAFIFOR_SPEC> {
                FFA12_W::new(self, 12)
            }
            ///Bit 13 - Filter FIFO assignment for filter 13
            #[inline(always)]
            #[must_use]
            pub fn ffa13(&mut self) -> FFA13_W<FAFIFOR_SPEC> {
                FFA13_W::new(self, 13)
            }
            ///Bit 14 - Filter FIFO assignment for filter 14
            #[inline(always)]
            #[must_use]
            pub fn ffa14(&mut self) -> FFA14_W<FAFIFOR_SPEC> {
                FFA14_W::new(self, 14)
            }
            ///Bit 15 - Filter FIFO assignment for filter 15
            #[inline(always)]
            #[must_use]
            pub fn ffa15(&mut self) -> FFA15_W<FAFIFOR_SPEC> {
                FFA15_W::new(self, 15)
            }
            ///Bit 16 - Filter FIFO assignment for filter 16
            #[inline(always)]
            #[must_use]
            pub fn ffa16(&mut self) -> FFA16_W<FAFIFOR_SPEC> {
                FFA16_W::new(self, 16)
            }
            ///Bit 17 - Filter FIFO assignment for filter 17
            #[inline(always)]
            #[must_use]
            pub fn ffa17(&mut self) -> FFA17_W<FAFIFOR_SPEC> {
                FFA17_W::new(self, 17)
            }
            ///Bit 18 - Filter FIFO assignment for filter 18
            #[inline(always)]
            #[must_use]
            pub fn ffa18(&mut self) -> FFA18_W<FAFIFOR_SPEC> {
                FFA18_W::new(self, 18)
            }
            ///Bit 19 - Filter FIFO assignment for filter 19
            #[inline(always)]
            #[must_use]
            pub fn ffa19(&mut self) -> FFA19_W<FAFIFOR_SPEC> {
                FFA19_W::new(self, 19)
            }
            ///Bit 20 - Filter FIFO assignment for filter 20
            #[inline(always)]
            #[must_use]
            pub fn ffa20(&mut self) -> FFA20_W<FAFIFOR_SPEC> {
                FFA20_W::new(self, 20)
            }
            ///Bit 21 - Filter FIFO assignment for filter 21
            #[inline(always)]
            #[must_use]
            pub fn ffa21(&mut self) -> FFA21_W<FAFIFOR_SPEC> {
                FFA21_W::new(self, 21)
            }
            ///Bit 22 - Filter FIFO assignment for filter 22
            #[inline(always)]
            #[must_use]
            pub fn ffa22(&mut self) -> FFA22_W<FAFIFOR_SPEC> {
                FFA22_W::new(self, 22)
            }
            ///Bit 23 - Filter FIFO assignment for filter 23
            #[inline(always)]
            #[must_use]
            pub fn ffa23(&mut self) -> FFA23_W<FAFIFOR_SPEC> {
                FFA23_W::new(self, 23)
            }
            ///Bit 24 - Filter FIFO assignment for filter 24
            #[inline(always)]
            #[must_use]
            pub fn ffa24(&mut self) -> FFA24_W<FAFIFOR_SPEC> {
                FFA24_W::new(self, 24)
            }
            ///Bit 25 - Filter FIFO assignment for filter 25
            #[inline(always)]
            #[must_use]
            pub fn ffa25(&mut self) -> FFA25_W<FAFIFOR_SPEC> {
                FFA25_W::new(self, 25)
            }
            ///Bit 26 - Filter FIFO assignment for filter 26
            #[inline(always)]
            #[must_use]
            pub fn ffa26(&mut self) -> FFA26_W<FAFIFOR_SPEC> {
                FFA26_W::new(self, 26)
            }
            ///Bit 27 - Filter FIFO assignment for filter 27
            #[inline(always)]
            #[must_use]
            pub fn ffa27(&mut self) -> FFA27_W<FAFIFOR_SPEC> {
                FFA27_W::new(self, 27)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///CAN filter FIFO assignment register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`fafifor::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`fafifor::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct FAFIFOR_SPEC;
        impl crate::RegisterSpec for FAFIFOR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`fafifor::R`](R) reader structure
        impl crate::Readable for FAFIFOR_SPEC {}
        ///`write(|w| ..)` method takes [`fafifor::W`](W) writer structure
        impl crate::Writable for FAFIFOR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets FAFIFOR to value 0
        impl crate::Resettable for FAFIFOR_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///FWR (rw) register accessor: CAN filter activation register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`fwr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`fwr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@fwr`]
    ///module
    pub type FWR = crate::Reg<fwr::FWR_SPEC>;
    ///CAN filter activation register
    pub mod fwr {
        ///Register `FWR` reader
        pub type R = crate::R<FWR_SPEC>;
        ///Register `FWR` writer
        pub type W = crate::W<FWR_SPEC>;
        ///Field `FACT0` reader - Filter active
        pub type FACT0_R = crate::BitReader;
        ///Field `FACT0` writer - Filter active
        pub type FACT0_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FACT1` reader - Filter active
        pub type FACT1_R = crate::BitReader;
        ///Field `FACT1` writer - Filter active
        pub type FACT1_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FACT2` reader - Filter active
        pub type FACT2_R = crate::BitReader;
        ///Field `FACT2` writer - Filter active
        pub type FACT2_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FACT3` reader - Filter active
        pub type FACT3_R = crate::BitReader;
        ///Field `FACT3` writer - Filter active
        pub type FACT3_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FACT4` reader - Filter active
        pub type FACT4_R = crate::BitReader;
        ///Field `FACT4` writer - Filter active
        pub type FACT4_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FACT5` reader - Filter active
        pub type FACT5_R = crate::BitReader;
        ///Field `FACT5` writer - Filter active
        pub type FACT5_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FACT6` reader - Filter active
        pub type FACT6_R = crate::BitReader;
        ///Field `FACT6` writer - Filter active
        pub type FACT6_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FACT7` reader - Filter active
        pub type FACT7_R = crate::BitReader;
        ///Field `FACT7` writer - Filter active
        pub type FACT7_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FACT8` reader - Filter active
        pub type FACT8_R = crate::BitReader;
        ///Field `FACT8` writer - Filter active
        pub type FACT8_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FACT9` reader - Filter active
        pub type FACT9_R = crate::BitReader;
        ///Field `FACT9` writer - Filter active
        pub type FACT9_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FACT10` reader - Filter active
        pub type FACT10_R = crate::BitReader;
        ///Field `FACT10` writer - Filter active
        pub type FACT10_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FACT11` reader - Filter active
        pub type FACT11_R = crate::BitReader;
        ///Field `FACT11` writer - Filter active
        pub type FACT11_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FACT12` reader - Filter active
        pub type FACT12_R = crate::BitReader;
        ///Field `FACT12` writer - Filter active
        pub type FACT12_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FACT13` reader - Filter active
        pub type FACT13_R = crate::BitReader;
        ///Field `FACT13` writer - Filter active
        pub type FACT13_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FACT14` reader - Filter active
        pub type FACT14_R = crate::BitReader;
        ///Field `FACT14` writer - Filter active
        pub type FACT14_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FACT15` reader - Filter active
        pub type FACT15_R = crate::BitReader;
        ///Field `FACT15` writer - Filter active
        pub type FACT15_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FACT16` reader - Filter active
        pub type FACT16_R = crate::BitReader;
        ///Field `FACT16` writer - Filter active
        pub type FACT16_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FACT17` reader - Filter active
        pub type FACT17_R = crate::BitReader;
        ///Field `FACT17` writer - Filter active
        pub type FACT17_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FACT18` reader - Filter active
        pub type FACT18_R = crate::BitReader;
        ///Field `FACT18` writer - Filter active
        pub type FACT18_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FACT19` reader - Filter active
        pub type FACT19_R = crate::BitReader;
        ///Field `FACT19` writer - Filter active
        pub type FACT19_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FACT20` reader - Filter active
        pub type FACT20_R = crate::BitReader;
        ///Field `FACT20` writer - Filter active
        pub type FACT20_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FACT21` reader - Filter active
        pub type FACT21_R = crate::BitReader;
        ///Field `FACT21` writer - Filter active
        pub type FACT21_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FACT22` reader - Filter active
        pub type FACT22_R = crate::BitReader;
        ///Field `FACT22` writer - Filter active
        pub type FACT22_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FACT23` reader - Filter active
        pub type FACT23_R = crate::BitReader;
        ///Field `FACT23` writer - Filter active
        pub type FACT23_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FACT24` reader - Filter active
        pub type FACT24_R = crate::BitReader;
        ///Field `FACT24` writer - Filter active
        pub type FACT24_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FACT25` reader - Filter active
        pub type FACT25_R = crate::BitReader;
        ///Field `FACT25` writer - Filter active
        pub type FACT25_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FACT26` reader - Filter active
        pub type FACT26_R = crate::BitReader;
        ///Field `FACT26` writer - Filter active
        pub type FACT26_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FACT27` reader - Filter active
        pub type FACT27_R = crate::BitReader;
        ///Field `FACT27` writer - Filter active
        pub type FACT27_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - Filter active
            #[inline(always)]
            pub fn fact0(&self) -> FACT0_R {
                FACT0_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Filter active
            #[inline(always)]
            pub fn fact1(&self) -> FACT1_R {
                FACT1_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - Filter active
            #[inline(always)]
            pub fn fact2(&self) -> FACT2_R {
                FACT2_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - Filter active
            #[inline(always)]
            pub fn fact3(&self) -> FACT3_R {
                FACT3_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - Filter active
            #[inline(always)]
            pub fn fact4(&self) -> FACT4_R {
                FACT4_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - Filter active
            #[inline(always)]
            pub fn fact5(&self) -> FACT5_R {
                FACT5_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - Filter active
            #[inline(always)]
            pub fn fact6(&self) -> FACT6_R {
                FACT6_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - Filter active
            #[inline(always)]
            pub fn fact7(&self) -> FACT7_R {
                FACT7_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bit 8 - Filter active
            #[inline(always)]
            pub fn fact8(&self) -> FACT8_R {
                FACT8_R::new(((self.bits >> 8) & 1) != 0)
            }
            ///Bit 9 - Filter active
            #[inline(always)]
            pub fn fact9(&self) -> FACT9_R {
                FACT9_R::new(((self.bits >> 9) & 1) != 0)
            }
            ///Bit 10 - Filter active
            #[inline(always)]
            pub fn fact10(&self) -> FACT10_R {
                FACT10_R::new(((self.bits >> 10) & 1) != 0)
            }
            ///Bit 11 - Filter active
            #[inline(always)]
            pub fn fact11(&self) -> FACT11_R {
                FACT11_R::new(((self.bits >> 11) & 1) != 0)
            }
            ///Bit 12 - Filter active
            #[inline(always)]
            pub fn fact12(&self) -> FACT12_R {
                FACT12_R::new(((self.bits >> 12) & 1) != 0)
            }
            ///Bit 13 - Filter active
            #[inline(always)]
            pub fn fact13(&self) -> FACT13_R {
                FACT13_R::new(((self.bits >> 13) & 1) != 0)
            }
            ///Bit 14 - Filter active
            #[inline(always)]
            pub fn fact14(&self) -> FACT14_R {
                FACT14_R::new(((self.bits >> 14) & 1) != 0)
            }
            ///Bit 15 - Filter active
            #[inline(always)]
            pub fn fact15(&self) -> FACT15_R {
                FACT15_R::new(((self.bits >> 15) & 1) != 0)
            }
            ///Bit 16 - Filter active
            #[inline(always)]
            pub fn fact16(&self) -> FACT16_R {
                FACT16_R::new(((self.bits >> 16) & 1) != 0)
            }
            ///Bit 17 - Filter active
            #[inline(always)]
            pub fn fact17(&self) -> FACT17_R {
                FACT17_R::new(((self.bits >> 17) & 1) != 0)
            }
            ///Bit 18 - Filter active
            #[inline(always)]
            pub fn fact18(&self) -> FACT18_R {
                FACT18_R::new(((self.bits >> 18) & 1) != 0)
            }
            ///Bit 19 - Filter active
            #[inline(always)]
            pub fn fact19(&self) -> FACT19_R {
                FACT19_R::new(((self.bits >> 19) & 1) != 0)
            }
            ///Bit 20 - Filter active
            #[inline(always)]
            pub fn fact20(&self) -> FACT20_R {
                FACT20_R::new(((self.bits >> 20) & 1) != 0)
            }
            ///Bit 21 - Filter active
            #[inline(always)]
            pub fn fact21(&self) -> FACT21_R {
                FACT21_R::new(((self.bits >> 21) & 1) != 0)
            }
            ///Bit 22 - Filter active
            #[inline(always)]
            pub fn fact22(&self) -> FACT22_R {
                FACT22_R::new(((self.bits >> 22) & 1) != 0)
            }
            ///Bit 23 - Filter active
            #[inline(always)]
            pub fn fact23(&self) -> FACT23_R {
                FACT23_R::new(((self.bits >> 23) & 1) != 0)
            }
            ///Bit 24 - Filter active
            #[inline(always)]
            pub fn fact24(&self) -> FACT24_R {
                FACT24_R::new(((self.bits >> 24) & 1) != 0)
            }
            ///Bit 25 - Filter active
            #[inline(always)]
            pub fn fact25(&self) -> FACT25_R {
                FACT25_R::new(((self.bits >> 25) & 1) != 0)
            }
            ///Bit 26 - Filter active
            #[inline(always)]
            pub fn fact26(&self) -> FACT26_R {
                FACT26_R::new(((self.bits >> 26) & 1) != 0)
            }
            ///Bit 27 - Filter active
            #[inline(always)]
            pub fn fact27(&self) -> FACT27_R {
                FACT27_R::new(((self.bits >> 27) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - Filter active
            #[inline(always)]
            #[must_use]
            pub fn fact0(&mut self) -> FACT0_W<FWR_SPEC> {
                FACT0_W::new(self, 0)
            }
            ///Bit 1 - Filter active
            #[inline(always)]
            #[must_use]
            pub fn fact1(&mut self) -> FACT1_W<FWR_SPEC> {
                FACT1_W::new(self, 1)
            }
            ///Bit 2 - Filter active
            #[inline(always)]
            #[must_use]
            pub fn fact2(&mut self) -> FACT2_W<FWR_SPEC> {
                FACT2_W::new(self, 2)
            }
            ///Bit 3 - Filter active
            #[inline(always)]
            #[must_use]
            pub fn fact3(&mut self) -> FACT3_W<FWR_SPEC> {
                FACT3_W::new(self, 3)
            }
            ///Bit 4 - Filter active
            #[inline(always)]
            #[must_use]
            pub fn fact4(&mut self) -> FACT4_W<FWR_SPEC> {
                FACT4_W::new(self, 4)
            }
            ///Bit 5 - Filter active
            #[inline(always)]
            #[must_use]
            pub fn fact5(&mut self) -> FACT5_W<FWR_SPEC> {
                FACT5_W::new(self, 5)
            }
            ///Bit 6 - Filter active
            #[inline(always)]
            #[must_use]
            pub fn fact6(&mut self) -> FACT6_W<FWR_SPEC> {
                FACT6_W::new(self, 6)
            }
            ///Bit 7 - Filter active
            #[inline(always)]
            #[must_use]
            pub fn fact7(&mut self) -> FACT7_W<FWR_SPEC> {
                FACT7_W::new(self, 7)
            }
            ///Bit 8 - Filter active
            #[inline(always)]
            #[must_use]
            pub fn fact8(&mut self) -> FACT8_W<FWR_SPEC> {
                FACT8_W::new(self, 8)
            }
            ///Bit 9 - Filter active
            #[inline(always)]
            #[must_use]
            pub fn fact9(&mut self) -> FACT9_W<FWR_SPEC> {
                FACT9_W::new(self, 9)
            }
            ///Bit 10 - Filter active
            #[inline(always)]
            #[must_use]
            pub fn fact10(&mut self) -> FACT10_W<FWR_SPEC> {
                FACT10_W::new(self, 10)
            }
            ///Bit 11 - Filter active
            #[inline(always)]
            #[must_use]
            pub fn fact11(&mut self) -> FACT11_W<FWR_SPEC> {
                FACT11_W::new(self, 11)
            }
            ///Bit 12 - Filter active
            #[inline(always)]
            #[must_use]
            pub fn fact12(&mut self) -> FACT12_W<FWR_SPEC> {
                FACT12_W::new(self, 12)
            }
            ///Bit 13 - Filter active
            #[inline(always)]
            #[must_use]
            pub fn fact13(&mut self) -> FACT13_W<FWR_SPEC> {
                FACT13_W::new(self, 13)
            }
            ///Bit 14 - Filter active
            #[inline(always)]
            #[must_use]
            pub fn fact14(&mut self) -> FACT14_W<FWR_SPEC> {
                FACT14_W::new(self, 14)
            }
            ///Bit 15 - Filter active
            #[inline(always)]
            #[must_use]
            pub fn fact15(&mut self) -> FACT15_W<FWR_SPEC> {
                FACT15_W::new(self, 15)
            }
            ///Bit 16 - Filter active
            #[inline(always)]
            #[must_use]
            pub fn fact16(&mut self) -> FACT16_W<FWR_SPEC> {
                FACT16_W::new(self, 16)
            }
            ///Bit 17 - Filter active
            #[inline(always)]
            #[must_use]
            pub fn fact17(&mut self) -> FACT17_W<FWR_SPEC> {
                FACT17_W::new(self, 17)
            }
            ///Bit 18 - Filter active
            #[inline(always)]
            #[must_use]
            pub fn fact18(&mut self) -> FACT18_W<FWR_SPEC> {
                FACT18_W::new(self, 18)
            }
            ///Bit 19 - Filter active
            #[inline(always)]
            #[must_use]
            pub fn fact19(&mut self) -> FACT19_W<FWR_SPEC> {
                FACT19_W::new(self, 19)
            }
            ///Bit 20 - Filter active
            #[inline(always)]
            #[must_use]
            pub fn fact20(&mut self) -> FACT20_W<FWR_SPEC> {
                FACT20_W::new(self, 20)
            }
            ///Bit 21 - Filter active
            #[inline(always)]
            #[must_use]
            pub fn fact21(&mut self) -> FACT21_W<FWR_SPEC> {
                FACT21_W::new(self, 21)
            }
            ///Bit 22 - Filter active
            #[inline(always)]
            #[must_use]
            pub fn fact22(&mut self) -> FACT22_W<FWR_SPEC> {
                FACT22_W::new(self, 22)
            }
            ///Bit 23 - Filter active
            #[inline(always)]
            #[must_use]
            pub fn fact23(&mut self) -> FACT23_W<FWR_SPEC> {
                FACT23_W::new(self, 23)
            }
            ///Bit 24 - Filter active
            #[inline(always)]
            #[must_use]
            pub fn fact24(&mut self) -> FACT24_W<FWR_SPEC> {
                FACT24_W::new(self, 24)
            }
            ///Bit 25 - Filter active
            #[inline(always)]
            #[must_use]
            pub fn fact25(&mut self) -> FACT25_W<FWR_SPEC> {
                FACT25_W::new(self, 25)
            }
            ///Bit 26 - Filter active
            #[inline(always)]
            #[must_use]
            pub fn fact26(&mut self) -> FACT26_W<FWR_SPEC> {
                FACT26_W::new(self, 26)
            }
            ///Bit 27 - Filter active
            #[inline(always)]
            #[must_use]
            pub fn fact27(&mut self) -> FACT27_W<FWR_SPEC> {
                FACT27_W::new(self, 27)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///CAN filter activation register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`fwr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`fwr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct FWR_SPEC;
        impl crate::RegisterSpec for FWR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`fwr::R`](R) reader structure
        impl crate::Readable for FWR_SPEC {}
        ///`write(|w| ..)` method takes [`fwr::W`](W) writer structure
        impl crate::Writable for FWR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets FWR to value 0
        impl crate::Resettable for FWR_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///F0R1 (rw) register accessor: Filter bank 0 register 1
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`f0r1::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`f0r1::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@f0r1`]
    ///module
    pub type F0R1 = crate::Reg<f0r1::F0R1_SPEC>;
    ///Filter bank 0 register 1
    pub mod f0r1 {
        ///Register `F0R1` reader
        pub type R = crate::R<F0R1_SPEC>;
        ///Register `F0R1` writer
        pub type W = crate::W<F0R1_SPEC>;
        ///Field `FB0` reader - Filter bits
        pub type FB0_R = crate::BitReader;
        ///Field `FB0` writer - Filter bits
        pub type FB0_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB1` reader - Filter bits
        pub type FB1_R = crate::BitReader;
        ///Field `FB1` writer - Filter bits
        pub type FB1_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB2` reader - Filter bits
        pub type FB2_R = crate::BitReader;
        ///Field `FB2` writer - Filter bits
        pub type FB2_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB3` reader - Filter bits
        pub type FB3_R = crate::BitReader;
        ///Field `FB3` writer - Filter bits
        pub type FB3_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB4` reader - Filter bits
        pub type FB4_R = crate::BitReader;
        ///Field `FB4` writer - Filter bits
        pub type FB4_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB5` reader - Filter bits
        pub type FB5_R = crate::BitReader;
        ///Field `FB5` writer - Filter bits
        pub type FB5_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB6` reader - Filter bits
        pub type FB6_R = crate::BitReader;
        ///Field `FB6` writer - Filter bits
        pub type FB6_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB7` reader - Filter bits
        pub type FB7_R = crate::BitReader;
        ///Field `FB7` writer - Filter bits
        pub type FB7_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB8` reader - Filter bits
        pub type FB8_R = crate::BitReader;
        ///Field `FB8` writer - Filter bits
        pub type FB8_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB9` reader - Filter bits
        pub type FB9_R = crate::BitReader;
        ///Field `FB9` writer - Filter bits
        pub type FB9_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB10` reader - Filter bits
        pub type FB10_R = crate::BitReader;
        ///Field `FB10` writer - Filter bits
        pub type FB10_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB11` reader - Filter bits
        pub type FB11_R = crate::BitReader;
        ///Field `FB11` writer - Filter bits
        pub type FB11_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB12` reader - Filter bits
        pub type FB12_R = crate::BitReader;
        ///Field `FB12` writer - Filter bits
        pub type FB12_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB13` reader - Filter bits
        pub type FB13_R = crate::BitReader;
        ///Field `FB13` writer - Filter bits
        pub type FB13_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB14` reader - Filter bits
        pub type FB14_R = crate::BitReader;
        ///Field `FB14` writer - Filter bits
        pub type FB14_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB15` reader - Filter bits
        pub type FB15_R = crate::BitReader;
        ///Field `FB15` writer - Filter bits
        pub type FB15_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB16` reader - Filter bits
        pub type FB16_R = crate::BitReader;
        ///Field `FB16` writer - Filter bits
        pub type FB16_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB17` reader - Filter bits
        pub type FB17_R = crate::BitReader;
        ///Field `FB17` writer - Filter bits
        pub type FB17_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB18` reader - Filter bits
        pub type FB18_R = crate::BitReader;
        ///Field `FB18` writer - Filter bits
        pub type FB18_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB19` reader - Filter bits
        pub type FB19_R = crate::BitReader;
        ///Field `FB19` writer - Filter bits
        pub type FB19_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB20` reader - Filter bits
        pub type FB20_R = crate::BitReader;
        ///Field `FB20` writer - Filter bits
        pub type FB20_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB21` reader - Filter bits
        pub type FB21_R = crate::BitReader;
        ///Field `FB21` writer - Filter bits
        pub type FB21_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB22` reader - Filter bits
        pub type FB22_R = crate::BitReader;
        ///Field `FB22` writer - Filter bits
        pub type FB22_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB23` reader - Filter bits
        pub type FB23_R = crate::BitReader;
        ///Field `FB23` writer - Filter bits
        pub type FB23_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB24` reader - Filter bits
        pub type FB24_R = crate::BitReader;
        ///Field `FB24` writer - Filter bits
        pub type FB24_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB25` reader - Filter bits
        pub type FB25_R = crate::BitReader;
        ///Field `FB25` writer - Filter bits
        pub type FB25_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB26` reader - Filter bits
        pub type FB26_R = crate::BitReader;
        ///Field `FB26` writer - Filter bits
        pub type FB26_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB27` reader - Filter bits
        pub type FB27_R = crate::BitReader;
        ///Field `FB27` writer - Filter bits
        pub type FB27_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB28` reader - Filter bits
        pub type FB28_R = crate::BitReader;
        ///Field `FB28` writer - Filter bits
        pub type FB28_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB29` reader - Filter bits
        pub type FB29_R = crate::BitReader;
        ///Field `FB29` writer - Filter bits
        pub type FB29_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB30` reader - Filter bits
        pub type FB30_R = crate::BitReader;
        ///Field `FB30` writer - Filter bits
        pub type FB30_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB31` reader - Filter bits
        pub type FB31_R = crate::BitReader;
        ///Field `FB31` writer - Filter bits
        pub type FB31_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - Filter bits
            #[inline(always)]
            pub fn fb0(&self) -> FB0_R {
                FB0_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Filter bits
            #[inline(always)]
            pub fn fb1(&self) -> FB1_R {
                FB1_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - Filter bits
            #[inline(always)]
            pub fn fb2(&self) -> FB2_R {
                FB2_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - Filter bits
            #[inline(always)]
            pub fn fb3(&self) -> FB3_R {
                FB3_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - Filter bits
            #[inline(always)]
            pub fn fb4(&self) -> FB4_R {
                FB4_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - Filter bits
            #[inline(always)]
            pub fn fb5(&self) -> FB5_R {
                FB5_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - Filter bits
            #[inline(always)]
            pub fn fb6(&self) -> FB6_R {
                FB6_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - Filter bits
            #[inline(always)]
            pub fn fb7(&self) -> FB7_R {
                FB7_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bit 8 - Filter bits
            #[inline(always)]
            pub fn fb8(&self) -> FB8_R {
                FB8_R::new(((self.bits >> 8) & 1) != 0)
            }
            ///Bit 9 - Filter bits
            #[inline(always)]
            pub fn fb9(&self) -> FB9_R {
                FB9_R::new(((self.bits >> 9) & 1) != 0)
            }
            ///Bit 10 - Filter bits
            #[inline(always)]
            pub fn fb10(&self) -> FB10_R {
                FB10_R::new(((self.bits >> 10) & 1) != 0)
            }
            ///Bit 11 - Filter bits
            #[inline(always)]
            pub fn fb11(&self) -> FB11_R {
                FB11_R::new(((self.bits >> 11) & 1) != 0)
            }
            ///Bit 12 - Filter bits
            #[inline(always)]
            pub fn fb12(&self) -> FB12_R {
                FB12_R::new(((self.bits >> 12) & 1) != 0)
            }
            ///Bit 13 - Filter bits
            #[inline(always)]
            pub fn fb13(&self) -> FB13_R {
                FB13_R::new(((self.bits >> 13) & 1) != 0)
            }
            ///Bit 14 - Filter bits
            #[inline(always)]
            pub fn fb14(&self) -> FB14_R {
                FB14_R::new(((self.bits >> 14) & 1) != 0)
            }
            ///Bit 15 - Filter bits
            #[inline(always)]
            pub fn fb15(&self) -> FB15_R {
                FB15_R::new(((self.bits >> 15) & 1) != 0)
            }
            ///Bit 16 - Filter bits
            #[inline(always)]
            pub fn fb16(&self) -> FB16_R {
                FB16_R::new(((self.bits >> 16) & 1) != 0)
            }
            ///Bit 17 - Filter bits
            #[inline(always)]
            pub fn fb17(&self) -> FB17_R {
                FB17_R::new(((self.bits >> 17) & 1) != 0)
            }
            ///Bit 18 - Filter bits
            #[inline(always)]
            pub fn fb18(&self) -> FB18_R {
                FB18_R::new(((self.bits >> 18) & 1) != 0)
            }
            ///Bit 19 - Filter bits
            #[inline(always)]
            pub fn fb19(&self) -> FB19_R {
                FB19_R::new(((self.bits >> 19) & 1) != 0)
            }
            ///Bit 20 - Filter bits
            #[inline(always)]
            pub fn fb20(&self) -> FB20_R {
                FB20_R::new(((self.bits >> 20) & 1) != 0)
            }
            ///Bit 21 - Filter bits
            #[inline(always)]
            pub fn fb21(&self) -> FB21_R {
                FB21_R::new(((self.bits >> 21) & 1) != 0)
            }
            ///Bit 22 - Filter bits
            #[inline(always)]
            pub fn fb22(&self) -> FB22_R {
                FB22_R::new(((self.bits >> 22) & 1) != 0)
            }
            ///Bit 23 - Filter bits
            #[inline(always)]
            pub fn fb23(&self) -> FB23_R {
                FB23_R::new(((self.bits >> 23) & 1) != 0)
            }
            ///Bit 24 - Filter bits
            #[inline(always)]
            pub fn fb24(&self) -> FB24_R {
                FB24_R::new(((self.bits >> 24) & 1) != 0)
            }
            ///Bit 25 - Filter bits
            #[inline(always)]
            pub fn fb25(&self) -> FB25_R {
                FB25_R::new(((self.bits >> 25) & 1) != 0)
            }
            ///Bit 26 - Filter bits
            #[inline(always)]
            pub fn fb26(&self) -> FB26_R {
                FB26_R::new(((self.bits >> 26) & 1) != 0)
            }
            ///Bit 27 - Filter bits
            #[inline(always)]
            pub fn fb27(&self) -> FB27_R {
                FB27_R::new(((self.bits >> 27) & 1) != 0)
            }
            ///Bit 28 - Filter bits
            #[inline(always)]
            pub fn fb28(&self) -> FB28_R {
                FB28_R::new(((self.bits >> 28) & 1) != 0)
            }
            ///Bit 29 - Filter bits
            #[inline(always)]
            pub fn fb29(&self) -> FB29_R {
                FB29_R::new(((self.bits >> 29) & 1) != 0)
            }
            ///Bit 30 - Filter bits
            #[inline(always)]
            pub fn fb30(&self) -> FB30_R {
                FB30_R::new(((self.bits >> 30) & 1) != 0)
            }
            ///Bit 31 - Filter bits
            #[inline(always)]
            pub fn fb31(&self) -> FB31_R {
                FB31_R::new(((self.bits >> 31) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb0(&mut self) -> FB0_W<F0R1_SPEC> {
                FB0_W::new(self, 0)
            }
            ///Bit 1 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb1(&mut self) -> FB1_W<F0R1_SPEC> {
                FB1_W::new(self, 1)
            }
            ///Bit 2 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb2(&mut self) -> FB2_W<F0R1_SPEC> {
                FB2_W::new(self, 2)
            }
            ///Bit 3 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb3(&mut self) -> FB3_W<F0R1_SPEC> {
                FB3_W::new(self, 3)
            }
            ///Bit 4 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb4(&mut self) -> FB4_W<F0R1_SPEC> {
                FB4_W::new(self, 4)
            }
            ///Bit 5 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb5(&mut self) -> FB5_W<F0R1_SPEC> {
                FB5_W::new(self, 5)
            }
            ///Bit 6 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb6(&mut self) -> FB6_W<F0R1_SPEC> {
                FB6_W::new(self, 6)
            }
            ///Bit 7 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb7(&mut self) -> FB7_W<F0R1_SPEC> {
                FB7_W::new(self, 7)
            }
            ///Bit 8 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb8(&mut self) -> FB8_W<F0R1_SPEC> {
                FB8_W::new(self, 8)
            }
            ///Bit 9 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb9(&mut self) -> FB9_W<F0R1_SPEC> {
                FB9_W::new(self, 9)
            }
            ///Bit 10 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb10(&mut self) -> FB10_W<F0R1_SPEC> {
                FB10_W::new(self, 10)
            }
            ///Bit 11 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb11(&mut self) -> FB11_W<F0R1_SPEC> {
                FB11_W::new(self, 11)
            }
            ///Bit 12 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb12(&mut self) -> FB12_W<F0R1_SPEC> {
                FB12_W::new(self, 12)
            }
            ///Bit 13 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb13(&mut self) -> FB13_W<F0R1_SPEC> {
                FB13_W::new(self, 13)
            }
            ///Bit 14 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb14(&mut self) -> FB14_W<F0R1_SPEC> {
                FB14_W::new(self, 14)
            }
            ///Bit 15 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb15(&mut self) -> FB15_W<F0R1_SPEC> {
                FB15_W::new(self, 15)
            }
            ///Bit 16 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb16(&mut self) -> FB16_W<F0R1_SPEC> {
                FB16_W::new(self, 16)
            }
            ///Bit 17 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb17(&mut self) -> FB17_W<F0R1_SPEC> {
                FB17_W::new(self, 17)
            }
            ///Bit 18 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb18(&mut self) -> FB18_W<F0R1_SPEC> {
                FB18_W::new(self, 18)
            }
            ///Bit 19 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb19(&mut self) -> FB19_W<F0R1_SPEC> {
                FB19_W::new(self, 19)
            }
            ///Bit 20 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb20(&mut self) -> FB20_W<F0R1_SPEC> {
                FB20_W::new(self, 20)
            }
            ///Bit 21 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb21(&mut self) -> FB21_W<F0R1_SPEC> {
                FB21_W::new(self, 21)
            }
            ///Bit 22 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb22(&mut self) -> FB22_W<F0R1_SPEC> {
                FB22_W::new(self, 22)
            }
            ///Bit 23 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb23(&mut self) -> FB23_W<F0R1_SPEC> {
                FB23_W::new(self, 23)
            }
            ///Bit 24 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb24(&mut self) -> FB24_W<F0R1_SPEC> {
                FB24_W::new(self, 24)
            }
            ///Bit 25 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb25(&mut self) -> FB25_W<F0R1_SPEC> {
                FB25_W::new(self, 25)
            }
            ///Bit 26 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb26(&mut self) -> FB26_W<F0R1_SPEC> {
                FB26_W::new(self, 26)
            }
            ///Bit 27 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb27(&mut self) -> FB27_W<F0R1_SPEC> {
                FB27_W::new(self, 27)
            }
            ///Bit 28 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb28(&mut self) -> FB28_W<F0R1_SPEC> {
                FB28_W::new(self, 28)
            }
            ///Bit 29 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb29(&mut self) -> FB29_W<F0R1_SPEC> {
                FB29_W::new(self, 29)
            }
            ///Bit 30 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb30(&mut self) -> FB30_W<F0R1_SPEC> {
                FB30_W::new(self, 30)
            }
            ///Bit 31 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb31(&mut self) -> FB31_W<F0R1_SPEC> {
                FB31_W::new(self, 31)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Filter bank 0 register 1
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`f0r1::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`f0r1::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct F0R1_SPEC;
        impl crate::RegisterSpec for F0R1_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`f0r1::R`](R) reader structure
        impl crate::Readable for F0R1_SPEC {}
        ///`write(|w| ..)` method takes [`f0r1::W`](W) writer structure
        impl crate::Writable for F0R1_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets F0R1 to value 0
        impl crate::Resettable for F0R1_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///F0R2 (rw) register accessor: Filter bank 0 register 2
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`f0r2::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`f0r2::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@f0r2`]
    ///module
    pub type F0R2 = crate::Reg<f0r2::F0R2_SPEC>;
    ///Filter bank 0 register 2
    pub mod f0r2 {
        ///Register `F0R2` reader
        pub type R = crate::R<F0R2_SPEC>;
        ///Register `F0R2` writer
        pub type W = crate::W<F0R2_SPEC>;
        ///Field `FB0` reader - Filter bits
        pub type FB0_R = crate::BitReader;
        ///Field `FB0` writer - Filter bits
        pub type FB0_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB1` reader - Filter bits
        pub type FB1_R = crate::BitReader;
        ///Field `FB1` writer - Filter bits
        pub type FB1_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB2` reader - Filter bits
        pub type FB2_R = crate::BitReader;
        ///Field `FB2` writer - Filter bits
        pub type FB2_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB3` reader - Filter bits
        pub type FB3_R = crate::BitReader;
        ///Field `FB3` writer - Filter bits
        pub type FB3_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB4` reader - Filter bits
        pub type FB4_R = crate::BitReader;
        ///Field `FB4` writer - Filter bits
        pub type FB4_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB5` reader - Filter bits
        pub type FB5_R = crate::BitReader;
        ///Field `FB5` writer - Filter bits
        pub type FB5_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB6` reader - Filter bits
        pub type FB6_R = crate::BitReader;
        ///Field `FB6` writer - Filter bits
        pub type FB6_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB7` reader - Filter bits
        pub type FB7_R = crate::BitReader;
        ///Field `FB7` writer - Filter bits
        pub type FB7_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB8` reader - Filter bits
        pub type FB8_R = crate::BitReader;
        ///Field `FB8` writer - Filter bits
        pub type FB8_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB9` reader - Filter bits
        pub type FB9_R = crate::BitReader;
        ///Field `FB9` writer - Filter bits
        pub type FB9_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB10` reader - Filter bits
        pub type FB10_R = crate::BitReader;
        ///Field `FB10` writer - Filter bits
        pub type FB10_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB11` reader - Filter bits
        pub type FB11_R = crate::BitReader;
        ///Field `FB11` writer - Filter bits
        pub type FB11_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB12` reader - Filter bits
        pub type FB12_R = crate::BitReader;
        ///Field `FB12` writer - Filter bits
        pub type FB12_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB13` reader - Filter bits
        pub type FB13_R = crate::BitReader;
        ///Field `FB13` writer - Filter bits
        pub type FB13_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB14` reader - Filter bits
        pub type FB14_R = crate::BitReader;
        ///Field `FB14` writer - Filter bits
        pub type FB14_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB15` reader - Filter bits
        pub type FB15_R = crate::BitReader;
        ///Field `FB15` writer - Filter bits
        pub type FB15_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB16` reader - Filter bits
        pub type FB16_R = crate::BitReader;
        ///Field `FB16` writer - Filter bits
        pub type FB16_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB17` reader - Filter bits
        pub type FB17_R = crate::BitReader;
        ///Field `FB17` writer - Filter bits
        pub type FB17_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB18` reader - Filter bits
        pub type FB18_R = crate::BitReader;
        ///Field `FB18` writer - Filter bits
        pub type FB18_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB19` reader - Filter bits
        pub type FB19_R = crate::BitReader;
        ///Field `FB19` writer - Filter bits
        pub type FB19_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB20` reader - Filter bits
        pub type FB20_R = crate::BitReader;
        ///Field `FB20` writer - Filter bits
        pub type FB20_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB21` reader - Filter bits
        pub type FB21_R = crate::BitReader;
        ///Field `FB21` writer - Filter bits
        pub type FB21_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB22` reader - Filter bits
        pub type FB22_R = crate::BitReader;
        ///Field `FB22` writer - Filter bits
        pub type FB22_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB23` reader - Filter bits
        pub type FB23_R = crate::BitReader;
        ///Field `FB23` writer - Filter bits
        pub type FB23_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB24` reader - Filter bits
        pub type FB24_R = crate::BitReader;
        ///Field `FB24` writer - Filter bits
        pub type FB24_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB25` reader - Filter bits
        pub type FB25_R = crate::BitReader;
        ///Field `FB25` writer - Filter bits
        pub type FB25_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB26` reader - Filter bits
        pub type FB26_R = crate::BitReader;
        ///Field `FB26` writer - Filter bits
        pub type FB26_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB27` reader - Filter bits
        pub type FB27_R = crate::BitReader;
        ///Field `FB27` writer - Filter bits
        pub type FB27_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB28` reader - Filter bits
        pub type FB28_R = crate::BitReader;
        ///Field `FB28` writer - Filter bits
        pub type FB28_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB29` reader - Filter bits
        pub type FB29_R = crate::BitReader;
        ///Field `FB29` writer - Filter bits
        pub type FB29_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB30` reader - Filter bits
        pub type FB30_R = crate::BitReader;
        ///Field `FB30` writer - Filter bits
        pub type FB30_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB31` reader - Filter bits
        pub type FB31_R = crate::BitReader;
        ///Field `FB31` writer - Filter bits
        pub type FB31_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - Filter bits
            #[inline(always)]
            pub fn fb0(&self) -> FB0_R {
                FB0_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Filter bits
            #[inline(always)]
            pub fn fb1(&self) -> FB1_R {
                FB1_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - Filter bits
            #[inline(always)]
            pub fn fb2(&self) -> FB2_R {
                FB2_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - Filter bits
            #[inline(always)]
            pub fn fb3(&self) -> FB3_R {
                FB3_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - Filter bits
            #[inline(always)]
            pub fn fb4(&self) -> FB4_R {
                FB4_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - Filter bits
            #[inline(always)]
            pub fn fb5(&self) -> FB5_R {
                FB5_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - Filter bits
            #[inline(always)]
            pub fn fb6(&self) -> FB6_R {
                FB6_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - Filter bits
            #[inline(always)]
            pub fn fb7(&self) -> FB7_R {
                FB7_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bit 8 - Filter bits
            #[inline(always)]
            pub fn fb8(&self) -> FB8_R {
                FB8_R::new(((self.bits >> 8) & 1) != 0)
            }
            ///Bit 9 - Filter bits
            #[inline(always)]
            pub fn fb9(&self) -> FB9_R {
                FB9_R::new(((self.bits >> 9) & 1) != 0)
            }
            ///Bit 10 - Filter bits
            #[inline(always)]
            pub fn fb10(&self) -> FB10_R {
                FB10_R::new(((self.bits >> 10) & 1) != 0)
            }
            ///Bit 11 - Filter bits
            #[inline(always)]
            pub fn fb11(&self) -> FB11_R {
                FB11_R::new(((self.bits >> 11) & 1) != 0)
            }
            ///Bit 12 - Filter bits
            #[inline(always)]
            pub fn fb12(&self) -> FB12_R {
                FB12_R::new(((self.bits >> 12) & 1) != 0)
            }
            ///Bit 13 - Filter bits
            #[inline(always)]
            pub fn fb13(&self) -> FB13_R {
                FB13_R::new(((self.bits >> 13) & 1) != 0)
            }
            ///Bit 14 - Filter bits
            #[inline(always)]
            pub fn fb14(&self) -> FB14_R {
                FB14_R::new(((self.bits >> 14) & 1) != 0)
            }
            ///Bit 15 - Filter bits
            #[inline(always)]
            pub fn fb15(&self) -> FB15_R {
                FB15_R::new(((self.bits >> 15) & 1) != 0)
            }
            ///Bit 16 - Filter bits
            #[inline(always)]
            pub fn fb16(&self) -> FB16_R {
                FB16_R::new(((self.bits >> 16) & 1) != 0)
            }
            ///Bit 17 - Filter bits
            #[inline(always)]
            pub fn fb17(&self) -> FB17_R {
                FB17_R::new(((self.bits >> 17) & 1) != 0)
            }
            ///Bit 18 - Filter bits
            #[inline(always)]
            pub fn fb18(&self) -> FB18_R {
                FB18_R::new(((self.bits >> 18) & 1) != 0)
            }
            ///Bit 19 - Filter bits
            #[inline(always)]
            pub fn fb19(&self) -> FB19_R {
                FB19_R::new(((self.bits >> 19) & 1) != 0)
            }
            ///Bit 20 - Filter bits
            #[inline(always)]
            pub fn fb20(&self) -> FB20_R {
                FB20_R::new(((self.bits >> 20) & 1) != 0)
            }
            ///Bit 21 - Filter bits
            #[inline(always)]
            pub fn fb21(&self) -> FB21_R {
                FB21_R::new(((self.bits >> 21) & 1) != 0)
            }
            ///Bit 22 - Filter bits
            #[inline(always)]
            pub fn fb22(&self) -> FB22_R {
                FB22_R::new(((self.bits >> 22) & 1) != 0)
            }
            ///Bit 23 - Filter bits
            #[inline(always)]
            pub fn fb23(&self) -> FB23_R {
                FB23_R::new(((self.bits >> 23) & 1) != 0)
            }
            ///Bit 24 - Filter bits
            #[inline(always)]
            pub fn fb24(&self) -> FB24_R {
                FB24_R::new(((self.bits >> 24) & 1) != 0)
            }
            ///Bit 25 - Filter bits
            #[inline(always)]
            pub fn fb25(&self) -> FB25_R {
                FB25_R::new(((self.bits >> 25) & 1) != 0)
            }
            ///Bit 26 - Filter bits
            #[inline(always)]
            pub fn fb26(&self) -> FB26_R {
                FB26_R::new(((self.bits >> 26) & 1) != 0)
            }
            ///Bit 27 - Filter bits
            #[inline(always)]
            pub fn fb27(&self) -> FB27_R {
                FB27_R::new(((self.bits >> 27) & 1) != 0)
            }
            ///Bit 28 - Filter bits
            #[inline(always)]
            pub fn fb28(&self) -> FB28_R {
                FB28_R::new(((self.bits >> 28) & 1) != 0)
            }
            ///Bit 29 - Filter bits
            #[inline(always)]
            pub fn fb29(&self) -> FB29_R {
                FB29_R::new(((self.bits >> 29) & 1) != 0)
            }
            ///Bit 30 - Filter bits
            #[inline(always)]
            pub fn fb30(&self) -> FB30_R {
                FB30_R::new(((self.bits >> 30) & 1) != 0)
            }
            ///Bit 31 - Filter bits
            #[inline(always)]
            pub fn fb31(&self) -> FB31_R {
                FB31_R::new(((self.bits >> 31) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb0(&mut self) -> FB0_W<F0R2_SPEC> {
                FB0_W::new(self, 0)
            }
            ///Bit 1 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb1(&mut self) -> FB1_W<F0R2_SPEC> {
                FB1_W::new(self, 1)
            }
            ///Bit 2 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb2(&mut self) -> FB2_W<F0R2_SPEC> {
                FB2_W::new(self, 2)
            }
            ///Bit 3 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb3(&mut self) -> FB3_W<F0R2_SPEC> {
                FB3_W::new(self, 3)
            }
            ///Bit 4 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb4(&mut self) -> FB4_W<F0R2_SPEC> {
                FB4_W::new(self, 4)
            }
            ///Bit 5 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb5(&mut self) -> FB5_W<F0R2_SPEC> {
                FB5_W::new(self, 5)
            }
            ///Bit 6 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb6(&mut self) -> FB6_W<F0R2_SPEC> {
                FB6_W::new(self, 6)
            }
            ///Bit 7 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb7(&mut self) -> FB7_W<F0R2_SPEC> {
                FB7_W::new(self, 7)
            }
            ///Bit 8 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb8(&mut self) -> FB8_W<F0R2_SPEC> {
                FB8_W::new(self, 8)
            }
            ///Bit 9 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb9(&mut self) -> FB9_W<F0R2_SPEC> {
                FB9_W::new(self, 9)
            }
            ///Bit 10 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb10(&mut self) -> FB10_W<F0R2_SPEC> {
                FB10_W::new(self, 10)
            }
            ///Bit 11 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb11(&mut self) -> FB11_W<F0R2_SPEC> {
                FB11_W::new(self, 11)
            }
            ///Bit 12 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb12(&mut self) -> FB12_W<F0R2_SPEC> {
                FB12_W::new(self, 12)
            }
            ///Bit 13 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb13(&mut self) -> FB13_W<F0R2_SPEC> {
                FB13_W::new(self, 13)
            }
            ///Bit 14 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb14(&mut self) -> FB14_W<F0R2_SPEC> {
                FB14_W::new(self, 14)
            }
            ///Bit 15 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb15(&mut self) -> FB15_W<F0R2_SPEC> {
                FB15_W::new(self, 15)
            }
            ///Bit 16 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb16(&mut self) -> FB16_W<F0R2_SPEC> {
                FB16_W::new(self, 16)
            }
            ///Bit 17 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb17(&mut self) -> FB17_W<F0R2_SPEC> {
                FB17_W::new(self, 17)
            }
            ///Bit 18 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb18(&mut self) -> FB18_W<F0R2_SPEC> {
                FB18_W::new(self, 18)
            }
            ///Bit 19 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb19(&mut self) -> FB19_W<F0R2_SPEC> {
                FB19_W::new(self, 19)
            }
            ///Bit 20 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb20(&mut self) -> FB20_W<F0R2_SPEC> {
                FB20_W::new(self, 20)
            }
            ///Bit 21 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb21(&mut self) -> FB21_W<F0R2_SPEC> {
                FB21_W::new(self, 21)
            }
            ///Bit 22 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb22(&mut self) -> FB22_W<F0R2_SPEC> {
                FB22_W::new(self, 22)
            }
            ///Bit 23 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb23(&mut self) -> FB23_W<F0R2_SPEC> {
                FB23_W::new(self, 23)
            }
            ///Bit 24 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb24(&mut self) -> FB24_W<F0R2_SPEC> {
                FB24_W::new(self, 24)
            }
            ///Bit 25 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb25(&mut self) -> FB25_W<F0R2_SPEC> {
                FB25_W::new(self, 25)
            }
            ///Bit 26 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb26(&mut self) -> FB26_W<F0R2_SPEC> {
                FB26_W::new(self, 26)
            }
            ///Bit 27 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb27(&mut self) -> FB27_W<F0R2_SPEC> {
                FB27_W::new(self, 27)
            }
            ///Bit 28 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb28(&mut self) -> FB28_W<F0R2_SPEC> {
                FB28_W::new(self, 28)
            }
            ///Bit 29 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb29(&mut self) -> FB29_W<F0R2_SPEC> {
                FB29_W::new(self, 29)
            }
            ///Bit 30 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb30(&mut self) -> FB30_W<F0R2_SPEC> {
                FB30_W::new(self, 30)
            }
            ///Bit 31 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb31(&mut self) -> FB31_W<F0R2_SPEC> {
                FB31_W::new(self, 31)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Filter bank 0 register 2
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`f0r2::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`f0r2::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct F0R2_SPEC;
        impl crate::RegisterSpec for F0R2_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`f0r2::R`](R) reader structure
        impl crate::Readable for F0R2_SPEC {}
        ///`write(|w| ..)` method takes [`f0r2::W`](W) writer structure
        impl crate::Writable for F0R2_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets F0R2 to value 0
        impl crate::Resettable for F0R2_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///F1R1 (rw) register accessor: Filter bank 1 register 1
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`f1r1::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`f1r1::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@f1r1`]
    ///module
    pub type F1R1 = crate::Reg<f1r1::F1R1_SPEC>;
    ///Filter bank 1 register 1
    pub mod f1r1 {
        ///Register `F1R1` reader
        pub type R = crate::R<F1R1_SPEC>;
        ///Register `F1R1` writer
        pub type W = crate::W<F1R1_SPEC>;
        ///Field `FB0` reader - Filter bits
        pub type FB0_R = crate::BitReader;
        ///Field `FB0` writer - Filter bits
        pub type FB0_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB1` reader - Filter bits
        pub type FB1_R = crate::BitReader;
        ///Field `FB1` writer - Filter bits
        pub type FB1_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB2` reader - Filter bits
        pub type FB2_R = crate::BitReader;
        ///Field `FB2` writer - Filter bits
        pub type FB2_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB3` reader - Filter bits
        pub type FB3_R = crate::BitReader;
        ///Field `FB3` writer - Filter bits
        pub type FB3_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB4` reader - Filter bits
        pub type FB4_R = crate::BitReader;
        ///Field `FB4` writer - Filter bits
        pub type FB4_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB5` reader - Filter bits
        pub type FB5_R = crate::BitReader;
        ///Field `FB5` writer - Filter bits
        pub type FB5_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB6` reader - Filter bits
        pub type FB6_R = crate::BitReader;
        ///Field `FB6` writer - Filter bits
        pub type FB6_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB7` reader - Filter bits
        pub type FB7_R = crate::BitReader;
        ///Field `FB7` writer - Filter bits
        pub type FB7_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB8` reader - Filter bits
        pub type FB8_R = crate::BitReader;
        ///Field `FB8` writer - Filter bits
        pub type FB8_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB9` reader - Filter bits
        pub type FB9_R = crate::BitReader;
        ///Field `FB9` writer - Filter bits
        pub type FB9_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB10` reader - Filter bits
        pub type FB10_R = crate::BitReader;
        ///Field `FB10` writer - Filter bits
        pub type FB10_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB11` reader - Filter bits
        pub type FB11_R = crate::BitReader;
        ///Field `FB11` writer - Filter bits
        pub type FB11_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB12` reader - Filter bits
        pub type FB12_R = crate::BitReader;
        ///Field `FB12` writer - Filter bits
        pub type FB12_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB13` reader - Filter bits
        pub type FB13_R = crate::BitReader;
        ///Field `FB13` writer - Filter bits
        pub type FB13_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB14` reader - Filter bits
        pub type FB14_R = crate::BitReader;
        ///Field `FB14` writer - Filter bits
        pub type FB14_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB15` reader - Filter bits
        pub type FB15_R = crate::BitReader;
        ///Field `FB15` writer - Filter bits
        pub type FB15_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB16` reader - Filter bits
        pub type FB16_R = crate::BitReader;
        ///Field `FB16` writer - Filter bits
        pub type FB16_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB17` reader - Filter bits
        pub type FB17_R = crate::BitReader;
        ///Field `FB17` writer - Filter bits
        pub type FB17_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB18` reader - Filter bits
        pub type FB18_R = crate::BitReader;
        ///Field `FB18` writer - Filter bits
        pub type FB18_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB19` reader - Filter bits
        pub type FB19_R = crate::BitReader;
        ///Field `FB19` writer - Filter bits
        pub type FB19_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB20` reader - Filter bits
        pub type FB20_R = crate::BitReader;
        ///Field `FB20` writer - Filter bits
        pub type FB20_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB21` reader - Filter bits
        pub type FB21_R = crate::BitReader;
        ///Field `FB21` writer - Filter bits
        pub type FB21_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB22` reader - Filter bits
        pub type FB22_R = crate::BitReader;
        ///Field `FB22` writer - Filter bits
        pub type FB22_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB23` reader - Filter bits
        pub type FB23_R = crate::BitReader;
        ///Field `FB23` writer - Filter bits
        pub type FB23_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB24` reader - Filter bits
        pub type FB24_R = crate::BitReader;
        ///Field `FB24` writer - Filter bits
        pub type FB24_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB25` reader - Filter bits
        pub type FB25_R = crate::BitReader;
        ///Field `FB25` writer - Filter bits
        pub type FB25_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB26` reader - Filter bits
        pub type FB26_R = crate::BitReader;
        ///Field `FB26` writer - Filter bits
        pub type FB26_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB27` reader - Filter bits
        pub type FB27_R = crate::BitReader;
        ///Field `FB27` writer - Filter bits
        pub type FB27_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB28` reader - Filter bits
        pub type FB28_R = crate::BitReader;
        ///Field `FB28` writer - Filter bits
        pub type FB28_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB29` reader - Filter bits
        pub type FB29_R = crate::BitReader;
        ///Field `FB29` writer - Filter bits
        pub type FB29_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB30` reader - Filter bits
        pub type FB30_R = crate::BitReader;
        ///Field `FB30` writer - Filter bits
        pub type FB30_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB31` reader - Filter bits
        pub type FB31_R = crate::BitReader;
        ///Field `FB31` writer - Filter bits
        pub type FB31_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - Filter bits
            #[inline(always)]
            pub fn fb0(&self) -> FB0_R {
                FB0_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Filter bits
            #[inline(always)]
            pub fn fb1(&self) -> FB1_R {
                FB1_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - Filter bits
            #[inline(always)]
            pub fn fb2(&self) -> FB2_R {
                FB2_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - Filter bits
            #[inline(always)]
            pub fn fb3(&self) -> FB3_R {
                FB3_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - Filter bits
            #[inline(always)]
            pub fn fb4(&self) -> FB4_R {
                FB4_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - Filter bits
            #[inline(always)]
            pub fn fb5(&self) -> FB5_R {
                FB5_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - Filter bits
            #[inline(always)]
            pub fn fb6(&self) -> FB6_R {
                FB6_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - Filter bits
            #[inline(always)]
            pub fn fb7(&self) -> FB7_R {
                FB7_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bit 8 - Filter bits
            #[inline(always)]
            pub fn fb8(&self) -> FB8_R {
                FB8_R::new(((self.bits >> 8) & 1) != 0)
            }
            ///Bit 9 - Filter bits
            #[inline(always)]
            pub fn fb9(&self) -> FB9_R {
                FB9_R::new(((self.bits >> 9) & 1) != 0)
            }
            ///Bit 10 - Filter bits
            #[inline(always)]
            pub fn fb10(&self) -> FB10_R {
                FB10_R::new(((self.bits >> 10) & 1) != 0)
            }
            ///Bit 11 - Filter bits
            #[inline(always)]
            pub fn fb11(&self) -> FB11_R {
                FB11_R::new(((self.bits >> 11) & 1) != 0)
            }
            ///Bit 12 - Filter bits
            #[inline(always)]
            pub fn fb12(&self) -> FB12_R {
                FB12_R::new(((self.bits >> 12) & 1) != 0)
            }
            ///Bit 13 - Filter bits
            #[inline(always)]
            pub fn fb13(&self) -> FB13_R {
                FB13_R::new(((self.bits >> 13) & 1) != 0)
            }
            ///Bit 14 - Filter bits
            #[inline(always)]
            pub fn fb14(&self) -> FB14_R {
                FB14_R::new(((self.bits >> 14) & 1) != 0)
            }
            ///Bit 15 - Filter bits
            #[inline(always)]
            pub fn fb15(&self) -> FB15_R {
                FB15_R::new(((self.bits >> 15) & 1) != 0)
            }
            ///Bit 16 - Filter bits
            #[inline(always)]
            pub fn fb16(&self) -> FB16_R {
                FB16_R::new(((self.bits >> 16) & 1) != 0)
            }
            ///Bit 17 - Filter bits
            #[inline(always)]
            pub fn fb17(&self) -> FB17_R {
                FB17_R::new(((self.bits >> 17) & 1) != 0)
            }
            ///Bit 18 - Filter bits
            #[inline(always)]
            pub fn fb18(&self) -> FB18_R {
                FB18_R::new(((self.bits >> 18) & 1) != 0)
            }
            ///Bit 19 - Filter bits
            #[inline(always)]
            pub fn fb19(&self) -> FB19_R {
                FB19_R::new(((self.bits >> 19) & 1) != 0)
            }
            ///Bit 20 - Filter bits
            #[inline(always)]
            pub fn fb20(&self) -> FB20_R {
                FB20_R::new(((self.bits >> 20) & 1) != 0)
            }
            ///Bit 21 - Filter bits
            #[inline(always)]
            pub fn fb21(&self) -> FB21_R {
                FB21_R::new(((self.bits >> 21) & 1) != 0)
            }
            ///Bit 22 - Filter bits
            #[inline(always)]
            pub fn fb22(&self) -> FB22_R {
                FB22_R::new(((self.bits >> 22) & 1) != 0)
            }
            ///Bit 23 - Filter bits
            #[inline(always)]
            pub fn fb23(&self) -> FB23_R {
                FB23_R::new(((self.bits >> 23) & 1) != 0)
            }
            ///Bit 24 - Filter bits
            #[inline(always)]
            pub fn fb24(&self) -> FB24_R {
                FB24_R::new(((self.bits >> 24) & 1) != 0)
            }
            ///Bit 25 - Filter bits
            #[inline(always)]
            pub fn fb25(&self) -> FB25_R {
                FB25_R::new(((self.bits >> 25) & 1) != 0)
            }
            ///Bit 26 - Filter bits
            #[inline(always)]
            pub fn fb26(&self) -> FB26_R {
                FB26_R::new(((self.bits >> 26) & 1) != 0)
            }
            ///Bit 27 - Filter bits
            #[inline(always)]
            pub fn fb27(&self) -> FB27_R {
                FB27_R::new(((self.bits >> 27) & 1) != 0)
            }
            ///Bit 28 - Filter bits
            #[inline(always)]
            pub fn fb28(&self) -> FB28_R {
                FB28_R::new(((self.bits >> 28) & 1) != 0)
            }
            ///Bit 29 - Filter bits
            #[inline(always)]
            pub fn fb29(&self) -> FB29_R {
                FB29_R::new(((self.bits >> 29) & 1) != 0)
            }
            ///Bit 30 - Filter bits
            #[inline(always)]
            pub fn fb30(&self) -> FB30_R {
                FB30_R::new(((self.bits >> 30) & 1) != 0)
            }
            ///Bit 31 - Filter bits
            #[inline(always)]
            pub fn fb31(&self) -> FB31_R {
                FB31_R::new(((self.bits >> 31) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb0(&mut self) -> FB0_W<F1R1_SPEC> {
                FB0_W::new(self, 0)
            }
            ///Bit 1 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb1(&mut self) -> FB1_W<F1R1_SPEC> {
                FB1_W::new(self, 1)
            }
            ///Bit 2 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb2(&mut self) -> FB2_W<F1R1_SPEC> {
                FB2_W::new(self, 2)
            }
            ///Bit 3 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb3(&mut self) -> FB3_W<F1R1_SPEC> {
                FB3_W::new(self, 3)
            }
            ///Bit 4 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb4(&mut self) -> FB4_W<F1R1_SPEC> {
                FB4_W::new(self, 4)
            }
            ///Bit 5 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb5(&mut self) -> FB5_W<F1R1_SPEC> {
                FB5_W::new(self, 5)
            }
            ///Bit 6 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb6(&mut self) -> FB6_W<F1R1_SPEC> {
                FB6_W::new(self, 6)
            }
            ///Bit 7 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb7(&mut self) -> FB7_W<F1R1_SPEC> {
                FB7_W::new(self, 7)
            }
            ///Bit 8 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb8(&mut self) -> FB8_W<F1R1_SPEC> {
                FB8_W::new(self, 8)
            }
            ///Bit 9 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb9(&mut self) -> FB9_W<F1R1_SPEC> {
                FB9_W::new(self, 9)
            }
            ///Bit 10 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb10(&mut self) -> FB10_W<F1R1_SPEC> {
                FB10_W::new(self, 10)
            }
            ///Bit 11 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb11(&mut self) -> FB11_W<F1R1_SPEC> {
                FB11_W::new(self, 11)
            }
            ///Bit 12 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb12(&mut self) -> FB12_W<F1R1_SPEC> {
                FB12_W::new(self, 12)
            }
            ///Bit 13 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb13(&mut self) -> FB13_W<F1R1_SPEC> {
                FB13_W::new(self, 13)
            }
            ///Bit 14 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb14(&mut self) -> FB14_W<F1R1_SPEC> {
                FB14_W::new(self, 14)
            }
            ///Bit 15 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb15(&mut self) -> FB15_W<F1R1_SPEC> {
                FB15_W::new(self, 15)
            }
            ///Bit 16 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb16(&mut self) -> FB16_W<F1R1_SPEC> {
                FB16_W::new(self, 16)
            }
            ///Bit 17 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb17(&mut self) -> FB17_W<F1R1_SPEC> {
                FB17_W::new(self, 17)
            }
            ///Bit 18 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb18(&mut self) -> FB18_W<F1R1_SPEC> {
                FB18_W::new(self, 18)
            }
            ///Bit 19 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb19(&mut self) -> FB19_W<F1R1_SPEC> {
                FB19_W::new(self, 19)
            }
            ///Bit 20 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb20(&mut self) -> FB20_W<F1R1_SPEC> {
                FB20_W::new(self, 20)
            }
            ///Bit 21 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb21(&mut self) -> FB21_W<F1R1_SPEC> {
                FB21_W::new(self, 21)
            }
            ///Bit 22 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb22(&mut self) -> FB22_W<F1R1_SPEC> {
                FB22_W::new(self, 22)
            }
            ///Bit 23 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb23(&mut self) -> FB23_W<F1R1_SPEC> {
                FB23_W::new(self, 23)
            }
            ///Bit 24 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb24(&mut self) -> FB24_W<F1R1_SPEC> {
                FB24_W::new(self, 24)
            }
            ///Bit 25 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb25(&mut self) -> FB25_W<F1R1_SPEC> {
                FB25_W::new(self, 25)
            }
            ///Bit 26 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb26(&mut self) -> FB26_W<F1R1_SPEC> {
                FB26_W::new(self, 26)
            }
            ///Bit 27 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb27(&mut self) -> FB27_W<F1R1_SPEC> {
                FB27_W::new(self, 27)
            }
            ///Bit 28 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb28(&mut self) -> FB28_W<F1R1_SPEC> {
                FB28_W::new(self, 28)
            }
            ///Bit 29 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb29(&mut self) -> FB29_W<F1R1_SPEC> {
                FB29_W::new(self, 29)
            }
            ///Bit 30 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb30(&mut self) -> FB30_W<F1R1_SPEC> {
                FB30_W::new(self, 30)
            }
            ///Bit 31 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb31(&mut self) -> FB31_W<F1R1_SPEC> {
                FB31_W::new(self, 31)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Filter bank 1 register 1
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`f1r1::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`f1r1::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct F1R1_SPEC;
        impl crate::RegisterSpec for F1R1_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`f1r1::R`](R) reader structure
        impl crate::Readable for F1R1_SPEC {}
        ///`write(|w| ..)` method takes [`f1r1::W`](W) writer structure
        impl crate::Writable for F1R1_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets F1R1 to value 0
        impl crate::Resettable for F1R1_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///F1R2 (rw) register accessor: Filter bank 1 register 2
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`f1r2::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`f1r2::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@f1r2`]
    ///module
    pub type F1R2 = crate::Reg<f1r2::F1R2_SPEC>;
    ///Filter bank 1 register 2
    pub mod f1r2 {
        ///Register `F1R2` reader
        pub type R = crate::R<F1R2_SPEC>;
        ///Register `F1R2` writer
        pub type W = crate::W<F1R2_SPEC>;
        ///Field `FB0` reader - Filter bits
        pub type FB0_R = crate::BitReader;
        ///Field `FB0` writer - Filter bits
        pub type FB0_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB1` reader - Filter bits
        pub type FB1_R = crate::BitReader;
        ///Field `FB1` writer - Filter bits
        pub type FB1_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB2` reader - Filter bits
        pub type FB2_R = crate::BitReader;
        ///Field `FB2` writer - Filter bits
        pub type FB2_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB3` reader - Filter bits
        pub type FB3_R = crate::BitReader;
        ///Field `FB3` writer - Filter bits
        pub type FB3_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB4` reader - Filter bits
        pub type FB4_R = crate::BitReader;
        ///Field `FB4` writer - Filter bits
        pub type FB4_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB5` reader - Filter bits
        pub type FB5_R = crate::BitReader;
        ///Field `FB5` writer - Filter bits
        pub type FB5_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB6` reader - Filter bits
        pub type FB6_R = crate::BitReader;
        ///Field `FB6` writer - Filter bits
        pub type FB6_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB7` reader - Filter bits
        pub type FB7_R = crate::BitReader;
        ///Field `FB7` writer - Filter bits
        pub type FB7_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB8` reader - Filter bits
        pub type FB8_R = crate::BitReader;
        ///Field `FB8` writer - Filter bits
        pub type FB8_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB9` reader - Filter bits
        pub type FB9_R = crate::BitReader;
        ///Field `FB9` writer - Filter bits
        pub type FB9_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB10` reader - Filter bits
        pub type FB10_R = crate::BitReader;
        ///Field `FB10` writer - Filter bits
        pub type FB10_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB11` reader - Filter bits
        pub type FB11_R = crate::BitReader;
        ///Field `FB11` writer - Filter bits
        pub type FB11_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB12` reader - Filter bits
        pub type FB12_R = crate::BitReader;
        ///Field `FB12` writer - Filter bits
        pub type FB12_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB13` reader - Filter bits
        pub type FB13_R = crate::BitReader;
        ///Field `FB13` writer - Filter bits
        pub type FB13_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB14` reader - Filter bits
        pub type FB14_R = crate::BitReader;
        ///Field `FB14` writer - Filter bits
        pub type FB14_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB15` reader - Filter bits
        pub type FB15_R = crate::BitReader;
        ///Field `FB15` writer - Filter bits
        pub type FB15_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB16` reader - Filter bits
        pub type FB16_R = crate::BitReader;
        ///Field `FB16` writer - Filter bits
        pub type FB16_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB17` reader - Filter bits
        pub type FB17_R = crate::BitReader;
        ///Field `FB17` writer - Filter bits
        pub type FB17_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB18` reader - Filter bits
        pub type FB18_R = crate::BitReader;
        ///Field `FB18` writer - Filter bits
        pub type FB18_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB19` reader - Filter bits
        pub type FB19_R = crate::BitReader;
        ///Field `FB19` writer - Filter bits
        pub type FB19_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB20` reader - Filter bits
        pub type FB20_R = crate::BitReader;
        ///Field `FB20` writer - Filter bits
        pub type FB20_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB21` reader - Filter bits
        pub type FB21_R = crate::BitReader;
        ///Field `FB21` writer - Filter bits
        pub type FB21_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB22` reader - Filter bits
        pub type FB22_R = crate::BitReader;
        ///Field `FB22` writer - Filter bits
        pub type FB22_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB23` reader - Filter bits
        pub type FB23_R = crate::BitReader;
        ///Field `FB23` writer - Filter bits
        pub type FB23_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB24` reader - Filter bits
        pub type FB24_R = crate::BitReader;
        ///Field `FB24` writer - Filter bits
        pub type FB24_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB25` reader - Filter bits
        pub type FB25_R = crate::BitReader;
        ///Field `FB25` writer - Filter bits
        pub type FB25_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB26` reader - Filter bits
        pub type FB26_R = crate::BitReader;
        ///Field `FB26` writer - Filter bits
        pub type FB26_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB27` reader - Filter bits
        pub type FB27_R = crate::BitReader;
        ///Field `FB27` writer - Filter bits
        pub type FB27_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB28` reader - Filter bits
        pub type FB28_R = crate::BitReader;
        ///Field `FB28` writer - Filter bits
        pub type FB28_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB29` reader - Filter bits
        pub type FB29_R = crate::BitReader;
        ///Field `FB29` writer - Filter bits
        pub type FB29_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB30` reader - Filter bits
        pub type FB30_R = crate::BitReader;
        ///Field `FB30` writer - Filter bits
        pub type FB30_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB31` reader - Filter bits
        pub type FB31_R = crate::BitReader;
        ///Field `FB31` writer - Filter bits
        pub type FB31_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - Filter bits
            #[inline(always)]
            pub fn fb0(&self) -> FB0_R {
                FB0_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Filter bits
            #[inline(always)]
            pub fn fb1(&self) -> FB1_R {
                FB1_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - Filter bits
            #[inline(always)]
            pub fn fb2(&self) -> FB2_R {
                FB2_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - Filter bits
            #[inline(always)]
            pub fn fb3(&self) -> FB3_R {
                FB3_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - Filter bits
            #[inline(always)]
            pub fn fb4(&self) -> FB4_R {
                FB4_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - Filter bits
            #[inline(always)]
            pub fn fb5(&self) -> FB5_R {
                FB5_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - Filter bits
            #[inline(always)]
            pub fn fb6(&self) -> FB6_R {
                FB6_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - Filter bits
            #[inline(always)]
            pub fn fb7(&self) -> FB7_R {
                FB7_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bit 8 - Filter bits
            #[inline(always)]
            pub fn fb8(&self) -> FB8_R {
                FB8_R::new(((self.bits >> 8) & 1) != 0)
            }
            ///Bit 9 - Filter bits
            #[inline(always)]
            pub fn fb9(&self) -> FB9_R {
                FB9_R::new(((self.bits >> 9) & 1) != 0)
            }
            ///Bit 10 - Filter bits
            #[inline(always)]
            pub fn fb10(&self) -> FB10_R {
                FB10_R::new(((self.bits >> 10) & 1) != 0)
            }
            ///Bit 11 - Filter bits
            #[inline(always)]
            pub fn fb11(&self) -> FB11_R {
                FB11_R::new(((self.bits >> 11) & 1) != 0)
            }
            ///Bit 12 - Filter bits
            #[inline(always)]
            pub fn fb12(&self) -> FB12_R {
                FB12_R::new(((self.bits >> 12) & 1) != 0)
            }
            ///Bit 13 - Filter bits
            #[inline(always)]
            pub fn fb13(&self) -> FB13_R {
                FB13_R::new(((self.bits >> 13) & 1) != 0)
            }
            ///Bit 14 - Filter bits
            #[inline(always)]
            pub fn fb14(&self) -> FB14_R {
                FB14_R::new(((self.bits >> 14) & 1) != 0)
            }
            ///Bit 15 - Filter bits
            #[inline(always)]
            pub fn fb15(&self) -> FB15_R {
                FB15_R::new(((self.bits >> 15) & 1) != 0)
            }
            ///Bit 16 - Filter bits
            #[inline(always)]
            pub fn fb16(&self) -> FB16_R {
                FB16_R::new(((self.bits >> 16) & 1) != 0)
            }
            ///Bit 17 - Filter bits
            #[inline(always)]
            pub fn fb17(&self) -> FB17_R {
                FB17_R::new(((self.bits >> 17) & 1) != 0)
            }
            ///Bit 18 - Filter bits
            #[inline(always)]
            pub fn fb18(&self) -> FB18_R {
                FB18_R::new(((self.bits >> 18) & 1) != 0)
            }
            ///Bit 19 - Filter bits
            #[inline(always)]
            pub fn fb19(&self) -> FB19_R {
                FB19_R::new(((self.bits >> 19) & 1) != 0)
            }
            ///Bit 20 - Filter bits
            #[inline(always)]
            pub fn fb20(&self) -> FB20_R {
                FB20_R::new(((self.bits >> 20) & 1) != 0)
            }
            ///Bit 21 - Filter bits
            #[inline(always)]
            pub fn fb21(&self) -> FB21_R {
                FB21_R::new(((self.bits >> 21) & 1) != 0)
            }
            ///Bit 22 - Filter bits
            #[inline(always)]
            pub fn fb22(&self) -> FB22_R {
                FB22_R::new(((self.bits >> 22) & 1) != 0)
            }
            ///Bit 23 - Filter bits
            #[inline(always)]
            pub fn fb23(&self) -> FB23_R {
                FB23_R::new(((self.bits >> 23) & 1) != 0)
            }
            ///Bit 24 - Filter bits
            #[inline(always)]
            pub fn fb24(&self) -> FB24_R {
                FB24_R::new(((self.bits >> 24) & 1) != 0)
            }
            ///Bit 25 - Filter bits
            #[inline(always)]
            pub fn fb25(&self) -> FB25_R {
                FB25_R::new(((self.bits >> 25) & 1) != 0)
            }
            ///Bit 26 - Filter bits
            #[inline(always)]
            pub fn fb26(&self) -> FB26_R {
                FB26_R::new(((self.bits >> 26) & 1) != 0)
            }
            ///Bit 27 - Filter bits
            #[inline(always)]
            pub fn fb27(&self) -> FB27_R {
                FB27_R::new(((self.bits >> 27) & 1) != 0)
            }
            ///Bit 28 - Filter bits
            #[inline(always)]
            pub fn fb28(&self) -> FB28_R {
                FB28_R::new(((self.bits >> 28) & 1) != 0)
            }
            ///Bit 29 - Filter bits
            #[inline(always)]
            pub fn fb29(&self) -> FB29_R {
                FB29_R::new(((self.bits >> 29) & 1) != 0)
            }
            ///Bit 30 - Filter bits
            #[inline(always)]
            pub fn fb30(&self) -> FB30_R {
                FB30_R::new(((self.bits >> 30) & 1) != 0)
            }
            ///Bit 31 - Filter bits
            #[inline(always)]
            pub fn fb31(&self) -> FB31_R {
                FB31_R::new(((self.bits >> 31) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb0(&mut self) -> FB0_W<F1R2_SPEC> {
                FB0_W::new(self, 0)
            }
            ///Bit 1 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb1(&mut self) -> FB1_W<F1R2_SPEC> {
                FB1_W::new(self, 1)
            }
            ///Bit 2 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb2(&mut self) -> FB2_W<F1R2_SPEC> {
                FB2_W::new(self, 2)
            }
            ///Bit 3 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb3(&mut self) -> FB3_W<F1R2_SPEC> {
                FB3_W::new(self, 3)
            }
            ///Bit 4 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb4(&mut self) -> FB4_W<F1R2_SPEC> {
                FB4_W::new(self, 4)
            }
            ///Bit 5 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb5(&mut self) -> FB5_W<F1R2_SPEC> {
                FB5_W::new(self, 5)
            }
            ///Bit 6 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb6(&mut self) -> FB6_W<F1R2_SPEC> {
                FB6_W::new(self, 6)
            }
            ///Bit 7 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb7(&mut self) -> FB7_W<F1R2_SPEC> {
                FB7_W::new(self, 7)
            }
            ///Bit 8 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb8(&mut self) -> FB8_W<F1R2_SPEC> {
                FB8_W::new(self, 8)
            }
            ///Bit 9 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb9(&mut self) -> FB9_W<F1R2_SPEC> {
                FB9_W::new(self, 9)
            }
            ///Bit 10 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb10(&mut self) -> FB10_W<F1R2_SPEC> {
                FB10_W::new(self, 10)
            }
            ///Bit 11 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb11(&mut self) -> FB11_W<F1R2_SPEC> {
                FB11_W::new(self, 11)
            }
            ///Bit 12 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb12(&mut self) -> FB12_W<F1R2_SPEC> {
                FB12_W::new(self, 12)
            }
            ///Bit 13 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb13(&mut self) -> FB13_W<F1R2_SPEC> {
                FB13_W::new(self, 13)
            }
            ///Bit 14 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb14(&mut self) -> FB14_W<F1R2_SPEC> {
                FB14_W::new(self, 14)
            }
            ///Bit 15 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb15(&mut self) -> FB15_W<F1R2_SPEC> {
                FB15_W::new(self, 15)
            }
            ///Bit 16 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb16(&mut self) -> FB16_W<F1R2_SPEC> {
                FB16_W::new(self, 16)
            }
            ///Bit 17 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb17(&mut self) -> FB17_W<F1R2_SPEC> {
                FB17_W::new(self, 17)
            }
            ///Bit 18 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb18(&mut self) -> FB18_W<F1R2_SPEC> {
                FB18_W::new(self, 18)
            }
            ///Bit 19 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb19(&mut self) -> FB19_W<F1R2_SPEC> {
                FB19_W::new(self, 19)
            }
            ///Bit 20 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb20(&mut self) -> FB20_W<F1R2_SPEC> {
                FB20_W::new(self, 20)
            }
            ///Bit 21 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb21(&mut self) -> FB21_W<F1R2_SPEC> {
                FB21_W::new(self, 21)
            }
            ///Bit 22 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb22(&mut self) -> FB22_W<F1R2_SPEC> {
                FB22_W::new(self, 22)
            }
            ///Bit 23 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb23(&mut self) -> FB23_W<F1R2_SPEC> {
                FB23_W::new(self, 23)
            }
            ///Bit 24 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb24(&mut self) -> FB24_W<F1R2_SPEC> {
                FB24_W::new(self, 24)
            }
            ///Bit 25 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb25(&mut self) -> FB25_W<F1R2_SPEC> {
                FB25_W::new(self, 25)
            }
            ///Bit 26 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb26(&mut self) -> FB26_W<F1R2_SPEC> {
                FB26_W::new(self, 26)
            }
            ///Bit 27 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb27(&mut self) -> FB27_W<F1R2_SPEC> {
                FB27_W::new(self, 27)
            }
            ///Bit 28 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb28(&mut self) -> FB28_W<F1R2_SPEC> {
                FB28_W::new(self, 28)
            }
            ///Bit 29 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb29(&mut self) -> FB29_W<F1R2_SPEC> {
                FB29_W::new(self, 29)
            }
            ///Bit 30 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb30(&mut self) -> FB30_W<F1R2_SPEC> {
                FB30_W::new(self, 30)
            }
            ///Bit 31 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb31(&mut self) -> FB31_W<F1R2_SPEC> {
                FB31_W::new(self, 31)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Filter bank 1 register 2
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`f1r2::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`f1r2::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct F1R2_SPEC;
        impl crate::RegisterSpec for F1R2_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`f1r2::R`](R) reader structure
        impl crate::Readable for F1R2_SPEC {}
        ///`write(|w| ..)` method takes [`f1r2::W`](W) writer structure
        impl crate::Writable for F1R2_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets F1R2 to value 0
        impl crate::Resettable for F1R2_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///F2R1 (rw) register accessor: Filter bank 2 register 1
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`f2r1::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`f2r1::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@f2r1`]
    ///module
    pub type F2R1 = crate::Reg<f2r1::F2R1_SPEC>;
    ///Filter bank 2 register 1
    pub mod f2r1 {
        ///Register `F2R1` reader
        pub type R = crate::R<F2R1_SPEC>;
        ///Register `F2R1` writer
        pub type W = crate::W<F2R1_SPEC>;
        ///Field `FB0` reader - Filter bits
        pub type FB0_R = crate::BitReader;
        ///Field `FB0` writer - Filter bits
        pub type FB0_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB1` reader - Filter bits
        pub type FB1_R = crate::BitReader;
        ///Field `FB1` writer - Filter bits
        pub type FB1_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB2` reader - Filter bits
        pub type FB2_R = crate::BitReader;
        ///Field `FB2` writer - Filter bits
        pub type FB2_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB3` reader - Filter bits
        pub type FB3_R = crate::BitReader;
        ///Field `FB3` writer - Filter bits
        pub type FB3_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB4` reader - Filter bits
        pub type FB4_R = crate::BitReader;
        ///Field `FB4` writer - Filter bits
        pub type FB4_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB5` reader - Filter bits
        pub type FB5_R = crate::BitReader;
        ///Field `FB5` writer - Filter bits
        pub type FB5_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB6` reader - Filter bits
        pub type FB6_R = crate::BitReader;
        ///Field `FB6` writer - Filter bits
        pub type FB6_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB7` reader - Filter bits
        pub type FB7_R = crate::BitReader;
        ///Field `FB7` writer - Filter bits
        pub type FB7_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB8` reader - Filter bits
        pub type FB8_R = crate::BitReader;
        ///Field `FB8` writer - Filter bits
        pub type FB8_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB9` reader - Filter bits
        pub type FB9_R = crate::BitReader;
        ///Field `FB9` writer - Filter bits
        pub type FB9_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB10` reader - Filter bits
        pub type FB10_R = crate::BitReader;
        ///Field `FB10` writer - Filter bits
        pub type FB10_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB11` reader - Filter bits
        pub type FB11_R = crate::BitReader;
        ///Field `FB11` writer - Filter bits
        pub type FB11_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB12` reader - Filter bits
        pub type FB12_R = crate::BitReader;
        ///Field `FB12` writer - Filter bits
        pub type FB12_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB13` reader - Filter bits
        pub type FB13_R = crate::BitReader;
        ///Field `FB13` writer - Filter bits
        pub type FB13_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB14` reader - Filter bits
        pub type FB14_R = crate::BitReader;
        ///Field `FB14` writer - Filter bits
        pub type FB14_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB15` reader - Filter bits
        pub type FB15_R = crate::BitReader;
        ///Field `FB15` writer - Filter bits
        pub type FB15_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB16` reader - Filter bits
        pub type FB16_R = crate::BitReader;
        ///Field `FB16` writer - Filter bits
        pub type FB16_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB17` reader - Filter bits
        pub type FB17_R = crate::BitReader;
        ///Field `FB17` writer - Filter bits
        pub type FB17_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB18` reader - Filter bits
        pub type FB18_R = crate::BitReader;
        ///Field `FB18` writer - Filter bits
        pub type FB18_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB19` reader - Filter bits
        pub type FB19_R = crate::BitReader;
        ///Field `FB19` writer - Filter bits
        pub type FB19_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB20` reader - Filter bits
        pub type FB20_R = crate::BitReader;
        ///Field `FB20` writer - Filter bits
        pub type FB20_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB21` reader - Filter bits
        pub type FB21_R = crate::BitReader;
        ///Field `FB21` writer - Filter bits
        pub type FB21_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB22` reader - Filter bits
        pub type FB22_R = crate::BitReader;
        ///Field `FB22` writer - Filter bits
        pub type FB22_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB23` reader - Filter bits
        pub type FB23_R = crate::BitReader;
        ///Field `FB23` writer - Filter bits
        pub type FB23_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB24` reader - Filter bits
        pub type FB24_R = crate::BitReader;
        ///Field `FB24` writer - Filter bits
        pub type FB24_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB25` reader - Filter bits
        pub type FB25_R = crate::BitReader;
        ///Field `FB25` writer - Filter bits
        pub type FB25_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB26` reader - Filter bits
        pub type FB26_R = crate::BitReader;
        ///Field `FB26` writer - Filter bits
        pub type FB26_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB27` reader - Filter bits
        pub type FB27_R = crate::BitReader;
        ///Field `FB27` writer - Filter bits
        pub type FB27_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB28` reader - Filter bits
        pub type FB28_R = crate::BitReader;
        ///Field `FB28` writer - Filter bits
        pub type FB28_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB29` reader - Filter bits
        pub type FB29_R = crate::BitReader;
        ///Field `FB29` writer - Filter bits
        pub type FB29_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB30` reader - Filter bits
        pub type FB30_R = crate::BitReader;
        ///Field `FB30` writer - Filter bits
        pub type FB30_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB31` reader - Filter bits
        pub type FB31_R = crate::BitReader;
        ///Field `FB31` writer - Filter bits
        pub type FB31_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - Filter bits
            #[inline(always)]
            pub fn fb0(&self) -> FB0_R {
                FB0_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Filter bits
            #[inline(always)]
            pub fn fb1(&self) -> FB1_R {
                FB1_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - Filter bits
            #[inline(always)]
            pub fn fb2(&self) -> FB2_R {
                FB2_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - Filter bits
            #[inline(always)]
            pub fn fb3(&self) -> FB3_R {
                FB3_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - Filter bits
            #[inline(always)]
            pub fn fb4(&self) -> FB4_R {
                FB4_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - Filter bits
            #[inline(always)]
            pub fn fb5(&self) -> FB5_R {
                FB5_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - Filter bits
            #[inline(always)]
            pub fn fb6(&self) -> FB6_R {
                FB6_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - Filter bits
            #[inline(always)]
            pub fn fb7(&self) -> FB7_R {
                FB7_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bit 8 - Filter bits
            #[inline(always)]
            pub fn fb8(&self) -> FB8_R {
                FB8_R::new(((self.bits >> 8) & 1) != 0)
            }
            ///Bit 9 - Filter bits
            #[inline(always)]
            pub fn fb9(&self) -> FB9_R {
                FB9_R::new(((self.bits >> 9) & 1) != 0)
            }
            ///Bit 10 - Filter bits
            #[inline(always)]
            pub fn fb10(&self) -> FB10_R {
                FB10_R::new(((self.bits >> 10) & 1) != 0)
            }
            ///Bit 11 - Filter bits
            #[inline(always)]
            pub fn fb11(&self) -> FB11_R {
                FB11_R::new(((self.bits >> 11) & 1) != 0)
            }
            ///Bit 12 - Filter bits
            #[inline(always)]
            pub fn fb12(&self) -> FB12_R {
                FB12_R::new(((self.bits >> 12) & 1) != 0)
            }
            ///Bit 13 - Filter bits
            #[inline(always)]
            pub fn fb13(&self) -> FB13_R {
                FB13_R::new(((self.bits >> 13) & 1) != 0)
            }
            ///Bit 14 - Filter bits
            #[inline(always)]
            pub fn fb14(&self) -> FB14_R {
                FB14_R::new(((self.bits >> 14) & 1) != 0)
            }
            ///Bit 15 - Filter bits
            #[inline(always)]
            pub fn fb15(&self) -> FB15_R {
                FB15_R::new(((self.bits >> 15) & 1) != 0)
            }
            ///Bit 16 - Filter bits
            #[inline(always)]
            pub fn fb16(&self) -> FB16_R {
                FB16_R::new(((self.bits >> 16) & 1) != 0)
            }
            ///Bit 17 - Filter bits
            #[inline(always)]
            pub fn fb17(&self) -> FB17_R {
                FB17_R::new(((self.bits >> 17) & 1) != 0)
            }
            ///Bit 18 - Filter bits
            #[inline(always)]
            pub fn fb18(&self) -> FB18_R {
                FB18_R::new(((self.bits >> 18) & 1) != 0)
            }
            ///Bit 19 - Filter bits
            #[inline(always)]
            pub fn fb19(&self) -> FB19_R {
                FB19_R::new(((self.bits >> 19) & 1) != 0)
            }
            ///Bit 20 - Filter bits
            #[inline(always)]
            pub fn fb20(&self) -> FB20_R {
                FB20_R::new(((self.bits >> 20) & 1) != 0)
            }
            ///Bit 21 - Filter bits
            #[inline(always)]
            pub fn fb21(&self) -> FB21_R {
                FB21_R::new(((self.bits >> 21) & 1) != 0)
            }
            ///Bit 22 - Filter bits
            #[inline(always)]
            pub fn fb22(&self) -> FB22_R {
                FB22_R::new(((self.bits >> 22) & 1) != 0)
            }
            ///Bit 23 - Filter bits
            #[inline(always)]
            pub fn fb23(&self) -> FB23_R {
                FB23_R::new(((self.bits >> 23) & 1) != 0)
            }
            ///Bit 24 - Filter bits
            #[inline(always)]
            pub fn fb24(&self) -> FB24_R {
                FB24_R::new(((self.bits >> 24) & 1) != 0)
            }
            ///Bit 25 - Filter bits
            #[inline(always)]
            pub fn fb25(&self) -> FB25_R {
                FB25_R::new(((self.bits >> 25) & 1) != 0)
            }
            ///Bit 26 - Filter bits
            #[inline(always)]
            pub fn fb26(&self) -> FB26_R {
                FB26_R::new(((self.bits >> 26) & 1) != 0)
            }
            ///Bit 27 - Filter bits
            #[inline(always)]
            pub fn fb27(&self) -> FB27_R {
                FB27_R::new(((self.bits >> 27) & 1) != 0)
            }
            ///Bit 28 - Filter bits
            #[inline(always)]
            pub fn fb28(&self) -> FB28_R {
                FB28_R::new(((self.bits >> 28) & 1) != 0)
            }
            ///Bit 29 - Filter bits
            #[inline(always)]
            pub fn fb29(&self) -> FB29_R {
                FB29_R::new(((self.bits >> 29) & 1) != 0)
            }
            ///Bit 30 - Filter bits
            #[inline(always)]
            pub fn fb30(&self) -> FB30_R {
                FB30_R::new(((self.bits >> 30) & 1) != 0)
            }
            ///Bit 31 - Filter bits
            #[inline(always)]
            pub fn fb31(&self) -> FB31_R {
                FB31_R::new(((self.bits >> 31) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb0(&mut self) -> FB0_W<F2R1_SPEC> {
                FB0_W::new(self, 0)
            }
            ///Bit 1 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb1(&mut self) -> FB1_W<F2R1_SPEC> {
                FB1_W::new(self, 1)
            }
            ///Bit 2 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb2(&mut self) -> FB2_W<F2R1_SPEC> {
                FB2_W::new(self, 2)
            }
            ///Bit 3 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb3(&mut self) -> FB3_W<F2R1_SPEC> {
                FB3_W::new(self, 3)
            }
            ///Bit 4 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb4(&mut self) -> FB4_W<F2R1_SPEC> {
                FB4_W::new(self, 4)
            }
            ///Bit 5 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb5(&mut self) -> FB5_W<F2R1_SPEC> {
                FB5_W::new(self, 5)
            }
            ///Bit 6 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb6(&mut self) -> FB6_W<F2R1_SPEC> {
                FB6_W::new(self, 6)
            }
            ///Bit 7 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb7(&mut self) -> FB7_W<F2R1_SPEC> {
                FB7_W::new(self, 7)
            }
            ///Bit 8 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb8(&mut self) -> FB8_W<F2R1_SPEC> {
                FB8_W::new(self, 8)
            }
            ///Bit 9 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb9(&mut self) -> FB9_W<F2R1_SPEC> {
                FB9_W::new(self, 9)
            }
            ///Bit 10 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb10(&mut self) -> FB10_W<F2R1_SPEC> {
                FB10_W::new(self, 10)
            }
            ///Bit 11 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb11(&mut self) -> FB11_W<F2R1_SPEC> {
                FB11_W::new(self, 11)
            }
            ///Bit 12 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb12(&mut self) -> FB12_W<F2R1_SPEC> {
                FB12_W::new(self, 12)
            }
            ///Bit 13 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb13(&mut self) -> FB13_W<F2R1_SPEC> {
                FB13_W::new(self, 13)
            }
            ///Bit 14 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb14(&mut self) -> FB14_W<F2R1_SPEC> {
                FB14_W::new(self, 14)
            }
            ///Bit 15 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb15(&mut self) -> FB15_W<F2R1_SPEC> {
                FB15_W::new(self, 15)
            }
            ///Bit 16 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb16(&mut self) -> FB16_W<F2R1_SPEC> {
                FB16_W::new(self, 16)
            }
            ///Bit 17 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb17(&mut self) -> FB17_W<F2R1_SPEC> {
                FB17_W::new(self, 17)
            }
            ///Bit 18 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb18(&mut self) -> FB18_W<F2R1_SPEC> {
                FB18_W::new(self, 18)
            }
            ///Bit 19 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb19(&mut self) -> FB19_W<F2R1_SPEC> {
                FB19_W::new(self, 19)
            }
            ///Bit 20 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb20(&mut self) -> FB20_W<F2R1_SPEC> {
                FB20_W::new(self, 20)
            }
            ///Bit 21 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb21(&mut self) -> FB21_W<F2R1_SPEC> {
                FB21_W::new(self, 21)
            }
            ///Bit 22 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb22(&mut self) -> FB22_W<F2R1_SPEC> {
                FB22_W::new(self, 22)
            }
            ///Bit 23 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb23(&mut self) -> FB23_W<F2R1_SPEC> {
                FB23_W::new(self, 23)
            }
            ///Bit 24 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb24(&mut self) -> FB24_W<F2R1_SPEC> {
                FB24_W::new(self, 24)
            }
            ///Bit 25 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb25(&mut self) -> FB25_W<F2R1_SPEC> {
                FB25_W::new(self, 25)
            }
            ///Bit 26 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb26(&mut self) -> FB26_W<F2R1_SPEC> {
                FB26_W::new(self, 26)
            }
            ///Bit 27 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb27(&mut self) -> FB27_W<F2R1_SPEC> {
                FB27_W::new(self, 27)
            }
            ///Bit 28 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb28(&mut self) -> FB28_W<F2R1_SPEC> {
                FB28_W::new(self, 28)
            }
            ///Bit 29 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb29(&mut self) -> FB29_W<F2R1_SPEC> {
                FB29_W::new(self, 29)
            }
            ///Bit 30 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb30(&mut self) -> FB30_W<F2R1_SPEC> {
                FB30_W::new(self, 30)
            }
            ///Bit 31 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb31(&mut self) -> FB31_W<F2R1_SPEC> {
                FB31_W::new(self, 31)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Filter bank 2 register 1
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`f2r1::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`f2r1::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct F2R1_SPEC;
        impl crate::RegisterSpec for F2R1_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`f2r1::R`](R) reader structure
        impl crate::Readable for F2R1_SPEC {}
        ///`write(|w| ..)` method takes [`f2r1::W`](W) writer structure
        impl crate::Writable for F2R1_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets F2R1 to value 0
        impl crate::Resettable for F2R1_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///F2R2 (rw) register accessor: Filter bank 2 register 2
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`f2r2::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`f2r2::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@f2r2`]
    ///module
    pub type F2R2 = crate::Reg<f2r2::F2R2_SPEC>;
    ///Filter bank 2 register 2
    pub mod f2r2 {
        ///Register `F2R2` reader
        pub type R = crate::R<F2R2_SPEC>;
        ///Register `F2R2` writer
        pub type W = crate::W<F2R2_SPEC>;
        ///Field `FB0` reader - Filter bits
        pub type FB0_R = crate::BitReader;
        ///Field `FB0` writer - Filter bits
        pub type FB0_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB1` reader - Filter bits
        pub type FB1_R = crate::BitReader;
        ///Field `FB1` writer - Filter bits
        pub type FB1_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB2` reader - Filter bits
        pub type FB2_R = crate::BitReader;
        ///Field `FB2` writer - Filter bits
        pub type FB2_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB3` reader - Filter bits
        pub type FB3_R = crate::BitReader;
        ///Field `FB3` writer - Filter bits
        pub type FB3_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB4` reader - Filter bits
        pub type FB4_R = crate::BitReader;
        ///Field `FB4` writer - Filter bits
        pub type FB4_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB5` reader - Filter bits
        pub type FB5_R = crate::BitReader;
        ///Field `FB5` writer - Filter bits
        pub type FB5_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB6` reader - Filter bits
        pub type FB6_R = crate::BitReader;
        ///Field `FB6` writer - Filter bits
        pub type FB6_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB7` reader - Filter bits
        pub type FB7_R = crate::BitReader;
        ///Field `FB7` writer - Filter bits
        pub type FB7_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB8` reader - Filter bits
        pub type FB8_R = crate::BitReader;
        ///Field `FB8` writer - Filter bits
        pub type FB8_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB9` reader - Filter bits
        pub type FB9_R = crate::BitReader;
        ///Field `FB9` writer - Filter bits
        pub type FB9_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB10` reader - Filter bits
        pub type FB10_R = crate::BitReader;
        ///Field `FB10` writer - Filter bits
        pub type FB10_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB11` reader - Filter bits
        pub type FB11_R = crate::BitReader;
        ///Field `FB11` writer - Filter bits
        pub type FB11_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB12` reader - Filter bits
        pub type FB12_R = crate::BitReader;
        ///Field `FB12` writer - Filter bits
        pub type FB12_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB13` reader - Filter bits
        pub type FB13_R = crate::BitReader;
        ///Field `FB13` writer - Filter bits
        pub type FB13_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB14` reader - Filter bits
        pub type FB14_R = crate::BitReader;
        ///Field `FB14` writer - Filter bits
        pub type FB14_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB15` reader - Filter bits
        pub type FB15_R = crate::BitReader;
        ///Field `FB15` writer - Filter bits
        pub type FB15_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB16` reader - Filter bits
        pub type FB16_R = crate::BitReader;
        ///Field `FB16` writer - Filter bits
        pub type FB16_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB17` reader - Filter bits
        pub type FB17_R = crate::BitReader;
        ///Field `FB17` writer - Filter bits
        pub type FB17_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB18` reader - Filter bits
        pub type FB18_R = crate::BitReader;
        ///Field `FB18` writer - Filter bits
        pub type FB18_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB19` reader - Filter bits
        pub type FB19_R = crate::BitReader;
        ///Field `FB19` writer - Filter bits
        pub type FB19_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB20` reader - Filter bits
        pub type FB20_R = crate::BitReader;
        ///Field `FB20` writer - Filter bits
        pub type FB20_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB21` reader - Filter bits
        pub type FB21_R = crate::BitReader;
        ///Field `FB21` writer - Filter bits
        pub type FB21_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB22` reader - Filter bits
        pub type FB22_R = crate::BitReader;
        ///Field `FB22` writer - Filter bits
        pub type FB22_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB23` reader - Filter bits
        pub type FB23_R = crate::BitReader;
        ///Field `FB23` writer - Filter bits
        pub type FB23_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB24` reader - Filter bits
        pub type FB24_R = crate::BitReader;
        ///Field `FB24` writer - Filter bits
        pub type FB24_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB25` reader - Filter bits
        pub type FB25_R = crate::BitReader;
        ///Field `FB25` writer - Filter bits
        pub type FB25_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB26` reader - Filter bits
        pub type FB26_R = crate::BitReader;
        ///Field `FB26` writer - Filter bits
        pub type FB26_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB27` reader - Filter bits
        pub type FB27_R = crate::BitReader;
        ///Field `FB27` writer - Filter bits
        pub type FB27_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB28` reader - Filter bits
        pub type FB28_R = crate::BitReader;
        ///Field `FB28` writer - Filter bits
        pub type FB28_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB29` reader - Filter bits
        pub type FB29_R = crate::BitReader;
        ///Field `FB29` writer - Filter bits
        pub type FB29_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB30` reader - Filter bits
        pub type FB30_R = crate::BitReader;
        ///Field `FB30` writer - Filter bits
        pub type FB30_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB31` reader - Filter bits
        pub type FB31_R = crate::BitReader;
        ///Field `FB31` writer - Filter bits
        pub type FB31_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - Filter bits
            #[inline(always)]
            pub fn fb0(&self) -> FB0_R {
                FB0_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Filter bits
            #[inline(always)]
            pub fn fb1(&self) -> FB1_R {
                FB1_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - Filter bits
            #[inline(always)]
            pub fn fb2(&self) -> FB2_R {
                FB2_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - Filter bits
            #[inline(always)]
            pub fn fb3(&self) -> FB3_R {
                FB3_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - Filter bits
            #[inline(always)]
            pub fn fb4(&self) -> FB4_R {
                FB4_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - Filter bits
            #[inline(always)]
            pub fn fb5(&self) -> FB5_R {
                FB5_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - Filter bits
            #[inline(always)]
            pub fn fb6(&self) -> FB6_R {
                FB6_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - Filter bits
            #[inline(always)]
            pub fn fb7(&self) -> FB7_R {
                FB7_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bit 8 - Filter bits
            #[inline(always)]
            pub fn fb8(&self) -> FB8_R {
                FB8_R::new(((self.bits >> 8) & 1) != 0)
            }
            ///Bit 9 - Filter bits
            #[inline(always)]
            pub fn fb9(&self) -> FB9_R {
                FB9_R::new(((self.bits >> 9) & 1) != 0)
            }
            ///Bit 10 - Filter bits
            #[inline(always)]
            pub fn fb10(&self) -> FB10_R {
                FB10_R::new(((self.bits >> 10) & 1) != 0)
            }
            ///Bit 11 - Filter bits
            #[inline(always)]
            pub fn fb11(&self) -> FB11_R {
                FB11_R::new(((self.bits >> 11) & 1) != 0)
            }
            ///Bit 12 - Filter bits
            #[inline(always)]
            pub fn fb12(&self) -> FB12_R {
                FB12_R::new(((self.bits >> 12) & 1) != 0)
            }
            ///Bit 13 - Filter bits
            #[inline(always)]
            pub fn fb13(&self) -> FB13_R {
                FB13_R::new(((self.bits >> 13) & 1) != 0)
            }
            ///Bit 14 - Filter bits
            #[inline(always)]
            pub fn fb14(&self) -> FB14_R {
                FB14_R::new(((self.bits >> 14) & 1) != 0)
            }
            ///Bit 15 - Filter bits
            #[inline(always)]
            pub fn fb15(&self) -> FB15_R {
                FB15_R::new(((self.bits >> 15) & 1) != 0)
            }
            ///Bit 16 - Filter bits
            #[inline(always)]
            pub fn fb16(&self) -> FB16_R {
                FB16_R::new(((self.bits >> 16) & 1) != 0)
            }
            ///Bit 17 - Filter bits
            #[inline(always)]
            pub fn fb17(&self) -> FB17_R {
                FB17_R::new(((self.bits >> 17) & 1) != 0)
            }
            ///Bit 18 - Filter bits
            #[inline(always)]
            pub fn fb18(&self) -> FB18_R {
                FB18_R::new(((self.bits >> 18) & 1) != 0)
            }
            ///Bit 19 - Filter bits
            #[inline(always)]
            pub fn fb19(&self) -> FB19_R {
                FB19_R::new(((self.bits >> 19) & 1) != 0)
            }
            ///Bit 20 - Filter bits
            #[inline(always)]
            pub fn fb20(&self) -> FB20_R {
                FB20_R::new(((self.bits >> 20) & 1) != 0)
            }
            ///Bit 21 - Filter bits
            #[inline(always)]
            pub fn fb21(&self) -> FB21_R {
                FB21_R::new(((self.bits >> 21) & 1) != 0)
            }
            ///Bit 22 - Filter bits
            #[inline(always)]
            pub fn fb22(&self) -> FB22_R {
                FB22_R::new(((self.bits >> 22) & 1) != 0)
            }
            ///Bit 23 - Filter bits
            #[inline(always)]
            pub fn fb23(&self) -> FB23_R {
                FB23_R::new(((self.bits >> 23) & 1) != 0)
            }
            ///Bit 24 - Filter bits
            #[inline(always)]
            pub fn fb24(&self) -> FB24_R {
                FB24_R::new(((self.bits >> 24) & 1) != 0)
            }
            ///Bit 25 - Filter bits
            #[inline(always)]
            pub fn fb25(&self) -> FB25_R {
                FB25_R::new(((self.bits >> 25) & 1) != 0)
            }
            ///Bit 26 - Filter bits
            #[inline(always)]
            pub fn fb26(&self) -> FB26_R {
                FB26_R::new(((self.bits >> 26) & 1) != 0)
            }
            ///Bit 27 - Filter bits
            #[inline(always)]
            pub fn fb27(&self) -> FB27_R {
                FB27_R::new(((self.bits >> 27) & 1) != 0)
            }
            ///Bit 28 - Filter bits
            #[inline(always)]
            pub fn fb28(&self) -> FB28_R {
                FB28_R::new(((self.bits >> 28) & 1) != 0)
            }
            ///Bit 29 - Filter bits
            #[inline(always)]
            pub fn fb29(&self) -> FB29_R {
                FB29_R::new(((self.bits >> 29) & 1) != 0)
            }
            ///Bit 30 - Filter bits
            #[inline(always)]
            pub fn fb30(&self) -> FB30_R {
                FB30_R::new(((self.bits >> 30) & 1) != 0)
            }
            ///Bit 31 - Filter bits
            #[inline(always)]
            pub fn fb31(&self) -> FB31_R {
                FB31_R::new(((self.bits >> 31) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb0(&mut self) -> FB0_W<F2R2_SPEC> {
                FB0_W::new(self, 0)
            }
            ///Bit 1 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb1(&mut self) -> FB1_W<F2R2_SPEC> {
                FB1_W::new(self, 1)
            }
            ///Bit 2 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb2(&mut self) -> FB2_W<F2R2_SPEC> {
                FB2_W::new(self, 2)
            }
            ///Bit 3 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb3(&mut self) -> FB3_W<F2R2_SPEC> {
                FB3_W::new(self, 3)
            }
            ///Bit 4 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb4(&mut self) -> FB4_W<F2R2_SPEC> {
                FB4_W::new(self, 4)
            }
            ///Bit 5 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb5(&mut self) -> FB5_W<F2R2_SPEC> {
                FB5_W::new(self, 5)
            }
            ///Bit 6 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb6(&mut self) -> FB6_W<F2R2_SPEC> {
                FB6_W::new(self, 6)
            }
            ///Bit 7 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb7(&mut self) -> FB7_W<F2R2_SPEC> {
                FB7_W::new(self, 7)
            }
            ///Bit 8 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb8(&mut self) -> FB8_W<F2R2_SPEC> {
                FB8_W::new(self, 8)
            }
            ///Bit 9 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb9(&mut self) -> FB9_W<F2R2_SPEC> {
                FB9_W::new(self, 9)
            }
            ///Bit 10 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb10(&mut self) -> FB10_W<F2R2_SPEC> {
                FB10_W::new(self, 10)
            }
            ///Bit 11 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb11(&mut self) -> FB11_W<F2R2_SPEC> {
                FB11_W::new(self, 11)
            }
            ///Bit 12 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb12(&mut self) -> FB12_W<F2R2_SPEC> {
                FB12_W::new(self, 12)
            }
            ///Bit 13 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb13(&mut self) -> FB13_W<F2R2_SPEC> {
                FB13_W::new(self, 13)
            }
            ///Bit 14 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb14(&mut self) -> FB14_W<F2R2_SPEC> {
                FB14_W::new(self, 14)
            }
            ///Bit 15 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb15(&mut self) -> FB15_W<F2R2_SPEC> {
                FB15_W::new(self, 15)
            }
            ///Bit 16 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb16(&mut self) -> FB16_W<F2R2_SPEC> {
                FB16_W::new(self, 16)
            }
            ///Bit 17 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb17(&mut self) -> FB17_W<F2R2_SPEC> {
                FB17_W::new(self, 17)
            }
            ///Bit 18 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb18(&mut self) -> FB18_W<F2R2_SPEC> {
                FB18_W::new(self, 18)
            }
            ///Bit 19 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb19(&mut self) -> FB19_W<F2R2_SPEC> {
                FB19_W::new(self, 19)
            }
            ///Bit 20 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb20(&mut self) -> FB20_W<F2R2_SPEC> {
                FB20_W::new(self, 20)
            }
            ///Bit 21 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb21(&mut self) -> FB21_W<F2R2_SPEC> {
                FB21_W::new(self, 21)
            }
            ///Bit 22 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb22(&mut self) -> FB22_W<F2R2_SPEC> {
                FB22_W::new(self, 22)
            }
            ///Bit 23 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb23(&mut self) -> FB23_W<F2R2_SPEC> {
                FB23_W::new(self, 23)
            }
            ///Bit 24 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb24(&mut self) -> FB24_W<F2R2_SPEC> {
                FB24_W::new(self, 24)
            }
            ///Bit 25 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb25(&mut self) -> FB25_W<F2R2_SPEC> {
                FB25_W::new(self, 25)
            }
            ///Bit 26 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb26(&mut self) -> FB26_W<F2R2_SPEC> {
                FB26_W::new(self, 26)
            }
            ///Bit 27 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb27(&mut self) -> FB27_W<F2R2_SPEC> {
                FB27_W::new(self, 27)
            }
            ///Bit 28 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb28(&mut self) -> FB28_W<F2R2_SPEC> {
                FB28_W::new(self, 28)
            }
            ///Bit 29 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb29(&mut self) -> FB29_W<F2R2_SPEC> {
                FB29_W::new(self, 29)
            }
            ///Bit 30 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb30(&mut self) -> FB30_W<F2R2_SPEC> {
                FB30_W::new(self, 30)
            }
            ///Bit 31 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb31(&mut self) -> FB31_W<F2R2_SPEC> {
                FB31_W::new(self, 31)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Filter bank 2 register 2
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`f2r2::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`f2r2::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct F2R2_SPEC;
        impl crate::RegisterSpec for F2R2_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`f2r2::R`](R) reader structure
        impl crate::Readable for F2R2_SPEC {}
        ///`write(|w| ..)` method takes [`f2r2::W`](W) writer structure
        impl crate::Writable for F2R2_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets F2R2 to value 0
        impl crate::Resettable for F2R2_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///F3R1 (rw) register accessor: Filter bank 3 register 1
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`f3r1::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`f3r1::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@f3r1`]
    ///module
    pub type F3R1 = crate::Reg<f3r1::F3R1_SPEC>;
    ///Filter bank 3 register 1
    pub mod f3r1 {
        ///Register `F3R1` reader
        pub type R = crate::R<F3R1_SPEC>;
        ///Register `F3R1` writer
        pub type W = crate::W<F3R1_SPEC>;
        ///Field `FB0` reader - Filter bits
        pub type FB0_R = crate::BitReader;
        ///Field `FB0` writer - Filter bits
        pub type FB0_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB1` reader - Filter bits
        pub type FB1_R = crate::BitReader;
        ///Field `FB1` writer - Filter bits
        pub type FB1_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB2` reader - Filter bits
        pub type FB2_R = crate::BitReader;
        ///Field `FB2` writer - Filter bits
        pub type FB2_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB3` reader - Filter bits
        pub type FB3_R = crate::BitReader;
        ///Field `FB3` writer - Filter bits
        pub type FB3_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB4` reader - Filter bits
        pub type FB4_R = crate::BitReader;
        ///Field `FB4` writer - Filter bits
        pub type FB4_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB5` reader - Filter bits
        pub type FB5_R = crate::BitReader;
        ///Field `FB5` writer - Filter bits
        pub type FB5_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB6` reader - Filter bits
        pub type FB6_R = crate::BitReader;
        ///Field `FB6` writer - Filter bits
        pub type FB6_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB7` reader - Filter bits
        pub type FB7_R = crate::BitReader;
        ///Field `FB7` writer - Filter bits
        pub type FB7_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB8` reader - Filter bits
        pub type FB8_R = crate::BitReader;
        ///Field `FB8` writer - Filter bits
        pub type FB8_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB9` reader - Filter bits
        pub type FB9_R = crate::BitReader;
        ///Field `FB9` writer - Filter bits
        pub type FB9_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB10` reader - Filter bits
        pub type FB10_R = crate::BitReader;
        ///Field `FB10` writer - Filter bits
        pub type FB10_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB11` reader - Filter bits
        pub type FB11_R = crate::BitReader;
        ///Field `FB11` writer - Filter bits
        pub type FB11_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB12` reader - Filter bits
        pub type FB12_R = crate::BitReader;
        ///Field `FB12` writer - Filter bits
        pub type FB12_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB13` reader - Filter bits
        pub type FB13_R = crate::BitReader;
        ///Field `FB13` writer - Filter bits
        pub type FB13_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB14` reader - Filter bits
        pub type FB14_R = crate::BitReader;
        ///Field `FB14` writer - Filter bits
        pub type FB14_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB15` reader - Filter bits
        pub type FB15_R = crate::BitReader;
        ///Field `FB15` writer - Filter bits
        pub type FB15_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB16` reader - Filter bits
        pub type FB16_R = crate::BitReader;
        ///Field `FB16` writer - Filter bits
        pub type FB16_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB17` reader - Filter bits
        pub type FB17_R = crate::BitReader;
        ///Field `FB17` writer - Filter bits
        pub type FB17_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB18` reader - Filter bits
        pub type FB18_R = crate::BitReader;
        ///Field `FB18` writer - Filter bits
        pub type FB18_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB19` reader - Filter bits
        pub type FB19_R = crate::BitReader;
        ///Field `FB19` writer - Filter bits
        pub type FB19_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB20` reader - Filter bits
        pub type FB20_R = crate::BitReader;
        ///Field `FB20` writer - Filter bits
        pub type FB20_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB21` reader - Filter bits
        pub type FB21_R = crate::BitReader;
        ///Field `FB21` writer - Filter bits
        pub type FB21_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB22` reader - Filter bits
        pub type FB22_R = crate::BitReader;
        ///Field `FB22` writer - Filter bits
        pub type FB22_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB23` reader - Filter bits
        pub type FB23_R = crate::BitReader;
        ///Field `FB23` writer - Filter bits
        pub type FB23_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB24` reader - Filter bits
        pub type FB24_R = crate::BitReader;
        ///Field `FB24` writer - Filter bits
        pub type FB24_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB25` reader - Filter bits
        pub type FB25_R = crate::BitReader;
        ///Field `FB25` writer - Filter bits
        pub type FB25_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB26` reader - Filter bits
        pub type FB26_R = crate::BitReader;
        ///Field `FB26` writer - Filter bits
        pub type FB26_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB27` reader - Filter bits
        pub type FB27_R = crate::BitReader;
        ///Field `FB27` writer - Filter bits
        pub type FB27_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB28` reader - Filter bits
        pub type FB28_R = crate::BitReader;
        ///Field `FB28` writer - Filter bits
        pub type FB28_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB29` reader - Filter bits
        pub type FB29_R = crate::BitReader;
        ///Field `FB29` writer - Filter bits
        pub type FB29_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB30` reader - Filter bits
        pub type FB30_R = crate::BitReader;
        ///Field `FB30` writer - Filter bits
        pub type FB30_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB31` reader - Filter bits
        pub type FB31_R = crate::BitReader;
        ///Field `FB31` writer - Filter bits
        pub type FB31_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - Filter bits
            #[inline(always)]
            pub fn fb0(&self) -> FB0_R {
                FB0_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Filter bits
            #[inline(always)]
            pub fn fb1(&self) -> FB1_R {
                FB1_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - Filter bits
            #[inline(always)]
            pub fn fb2(&self) -> FB2_R {
                FB2_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - Filter bits
            #[inline(always)]
            pub fn fb3(&self) -> FB3_R {
                FB3_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - Filter bits
            #[inline(always)]
            pub fn fb4(&self) -> FB4_R {
                FB4_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - Filter bits
            #[inline(always)]
            pub fn fb5(&self) -> FB5_R {
                FB5_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - Filter bits
            #[inline(always)]
            pub fn fb6(&self) -> FB6_R {
                FB6_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - Filter bits
            #[inline(always)]
            pub fn fb7(&self) -> FB7_R {
                FB7_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bit 8 - Filter bits
            #[inline(always)]
            pub fn fb8(&self) -> FB8_R {
                FB8_R::new(((self.bits >> 8) & 1) != 0)
            }
            ///Bit 9 - Filter bits
            #[inline(always)]
            pub fn fb9(&self) -> FB9_R {
                FB9_R::new(((self.bits >> 9) & 1) != 0)
            }
            ///Bit 10 - Filter bits
            #[inline(always)]
            pub fn fb10(&self) -> FB10_R {
                FB10_R::new(((self.bits >> 10) & 1) != 0)
            }
            ///Bit 11 - Filter bits
            #[inline(always)]
            pub fn fb11(&self) -> FB11_R {
                FB11_R::new(((self.bits >> 11) & 1) != 0)
            }
            ///Bit 12 - Filter bits
            #[inline(always)]
            pub fn fb12(&self) -> FB12_R {
                FB12_R::new(((self.bits >> 12) & 1) != 0)
            }
            ///Bit 13 - Filter bits
            #[inline(always)]
            pub fn fb13(&self) -> FB13_R {
                FB13_R::new(((self.bits >> 13) & 1) != 0)
            }
            ///Bit 14 - Filter bits
            #[inline(always)]
            pub fn fb14(&self) -> FB14_R {
                FB14_R::new(((self.bits >> 14) & 1) != 0)
            }
            ///Bit 15 - Filter bits
            #[inline(always)]
            pub fn fb15(&self) -> FB15_R {
                FB15_R::new(((self.bits >> 15) & 1) != 0)
            }
            ///Bit 16 - Filter bits
            #[inline(always)]
            pub fn fb16(&self) -> FB16_R {
                FB16_R::new(((self.bits >> 16) & 1) != 0)
            }
            ///Bit 17 - Filter bits
            #[inline(always)]
            pub fn fb17(&self) -> FB17_R {
                FB17_R::new(((self.bits >> 17) & 1) != 0)
            }
            ///Bit 18 - Filter bits
            #[inline(always)]
            pub fn fb18(&self) -> FB18_R {
                FB18_R::new(((self.bits >> 18) & 1) != 0)
            }
            ///Bit 19 - Filter bits
            #[inline(always)]
            pub fn fb19(&self) -> FB19_R {
                FB19_R::new(((self.bits >> 19) & 1) != 0)
            }
            ///Bit 20 - Filter bits
            #[inline(always)]
            pub fn fb20(&self) -> FB20_R {
                FB20_R::new(((self.bits >> 20) & 1) != 0)
            }
            ///Bit 21 - Filter bits
            #[inline(always)]
            pub fn fb21(&self) -> FB21_R {
                FB21_R::new(((self.bits >> 21) & 1) != 0)
            }
            ///Bit 22 - Filter bits
            #[inline(always)]
            pub fn fb22(&self) -> FB22_R {
                FB22_R::new(((self.bits >> 22) & 1) != 0)
            }
            ///Bit 23 - Filter bits
            #[inline(always)]
            pub fn fb23(&self) -> FB23_R {
                FB23_R::new(((self.bits >> 23) & 1) != 0)
            }
            ///Bit 24 - Filter bits
            #[inline(always)]
            pub fn fb24(&self) -> FB24_R {
                FB24_R::new(((self.bits >> 24) & 1) != 0)
            }
            ///Bit 25 - Filter bits
            #[inline(always)]
            pub fn fb25(&self) -> FB25_R {
                FB25_R::new(((self.bits >> 25) & 1) != 0)
            }
            ///Bit 26 - Filter bits
            #[inline(always)]
            pub fn fb26(&self) -> FB26_R {
                FB26_R::new(((self.bits >> 26) & 1) != 0)
            }
            ///Bit 27 - Filter bits
            #[inline(always)]
            pub fn fb27(&self) -> FB27_R {
                FB27_R::new(((self.bits >> 27) & 1) != 0)
            }
            ///Bit 28 - Filter bits
            #[inline(always)]
            pub fn fb28(&self) -> FB28_R {
                FB28_R::new(((self.bits >> 28) & 1) != 0)
            }
            ///Bit 29 - Filter bits
            #[inline(always)]
            pub fn fb29(&self) -> FB29_R {
                FB29_R::new(((self.bits >> 29) & 1) != 0)
            }
            ///Bit 30 - Filter bits
            #[inline(always)]
            pub fn fb30(&self) -> FB30_R {
                FB30_R::new(((self.bits >> 30) & 1) != 0)
            }
            ///Bit 31 - Filter bits
            #[inline(always)]
            pub fn fb31(&self) -> FB31_R {
                FB31_R::new(((self.bits >> 31) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb0(&mut self) -> FB0_W<F3R1_SPEC> {
                FB0_W::new(self, 0)
            }
            ///Bit 1 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb1(&mut self) -> FB1_W<F3R1_SPEC> {
                FB1_W::new(self, 1)
            }
            ///Bit 2 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb2(&mut self) -> FB2_W<F3R1_SPEC> {
                FB2_W::new(self, 2)
            }
            ///Bit 3 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb3(&mut self) -> FB3_W<F3R1_SPEC> {
                FB3_W::new(self, 3)
            }
            ///Bit 4 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb4(&mut self) -> FB4_W<F3R1_SPEC> {
                FB4_W::new(self, 4)
            }
            ///Bit 5 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb5(&mut self) -> FB5_W<F3R1_SPEC> {
                FB5_W::new(self, 5)
            }
            ///Bit 6 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb6(&mut self) -> FB6_W<F3R1_SPEC> {
                FB6_W::new(self, 6)
            }
            ///Bit 7 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb7(&mut self) -> FB7_W<F3R1_SPEC> {
                FB7_W::new(self, 7)
            }
            ///Bit 8 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb8(&mut self) -> FB8_W<F3R1_SPEC> {
                FB8_W::new(self, 8)
            }
            ///Bit 9 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb9(&mut self) -> FB9_W<F3R1_SPEC> {
                FB9_W::new(self, 9)
            }
            ///Bit 10 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb10(&mut self) -> FB10_W<F3R1_SPEC> {
                FB10_W::new(self, 10)
            }
            ///Bit 11 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb11(&mut self) -> FB11_W<F3R1_SPEC> {
                FB11_W::new(self, 11)
            }
            ///Bit 12 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb12(&mut self) -> FB12_W<F3R1_SPEC> {
                FB12_W::new(self, 12)
            }
            ///Bit 13 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb13(&mut self) -> FB13_W<F3R1_SPEC> {
                FB13_W::new(self, 13)
            }
            ///Bit 14 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb14(&mut self) -> FB14_W<F3R1_SPEC> {
                FB14_W::new(self, 14)
            }
            ///Bit 15 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb15(&mut self) -> FB15_W<F3R1_SPEC> {
                FB15_W::new(self, 15)
            }
            ///Bit 16 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb16(&mut self) -> FB16_W<F3R1_SPEC> {
                FB16_W::new(self, 16)
            }
            ///Bit 17 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb17(&mut self) -> FB17_W<F3R1_SPEC> {
                FB17_W::new(self, 17)
            }
            ///Bit 18 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb18(&mut self) -> FB18_W<F3R1_SPEC> {
                FB18_W::new(self, 18)
            }
            ///Bit 19 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb19(&mut self) -> FB19_W<F3R1_SPEC> {
                FB19_W::new(self, 19)
            }
            ///Bit 20 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb20(&mut self) -> FB20_W<F3R1_SPEC> {
                FB20_W::new(self, 20)
            }
            ///Bit 21 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb21(&mut self) -> FB21_W<F3R1_SPEC> {
                FB21_W::new(self, 21)
            }
            ///Bit 22 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb22(&mut self) -> FB22_W<F3R1_SPEC> {
                FB22_W::new(self, 22)
            }
            ///Bit 23 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb23(&mut self) -> FB23_W<F3R1_SPEC> {
                FB23_W::new(self, 23)
            }
            ///Bit 24 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb24(&mut self) -> FB24_W<F3R1_SPEC> {
                FB24_W::new(self, 24)
            }
            ///Bit 25 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb25(&mut self) -> FB25_W<F3R1_SPEC> {
                FB25_W::new(self, 25)
            }
            ///Bit 26 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb26(&mut self) -> FB26_W<F3R1_SPEC> {
                FB26_W::new(self, 26)
            }
            ///Bit 27 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb27(&mut self) -> FB27_W<F3R1_SPEC> {
                FB27_W::new(self, 27)
            }
            ///Bit 28 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb28(&mut self) -> FB28_W<F3R1_SPEC> {
                FB28_W::new(self, 28)
            }
            ///Bit 29 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb29(&mut self) -> FB29_W<F3R1_SPEC> {
                FB29_W::new(self, 29)
            }
            ///Bit 30 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb30(&mut self) -> FB30_W<F3R1_SPEC> {
                FB30_W::new(self, 30)
            }
            ///Bit 31 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb31(&mut self) -> FB31_W<F3R1_SPEC> {
                FB31_W::new(self, 31)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Filter bank 3 register 1
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`f3r1::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`f3r1::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct F3R1_SPEC;
        impl crate::RegisterSpec for F3R1_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`f3r1::R`](R) reader structure
        impl crate::Readable for F3R1_SPEC {}
        ///`write(|w| ..)` method takes [`f3r1::W`](W) writer structure
        impl crate::Writable for F3R1_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets F3R1 to value 0
        impl crate::Resettable for F3R1_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///F3R2 (rw) register accessor: Filter bank 3 register 2
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`f3r2::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`f3r2::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@f3r2`]
    ///module
    pub type F3R2 = crate::Reg<f3r2::F3R2_SPEC>;
    ///Filter bank 3 register 2
    pub mod f3r2 {
        ///Register `F3R2` reader
        pub type R = crate::R<F3R2_SPEC>;
        ///Register `F3R2` writer
        pub type W = crate::W<F3R2_SPEC>;
        ///Field `FB0` reader - Filter bits
        pub type FB0_R = crate::BitReader;
        ///Field `FB0` writer - Filter bits
        pub type FB0_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB1` reader - Filter bits
        pub type FB1_R = crate::BitReader;
        ///Field `FB1` writer - Filter bits
        pub type FB1_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB2` reader - Filter bits
        pub type FB2_R = crate::BitReader;
        ///Field `FB2` writer - Filter bits
        pub type FB2_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB3` reader - Filter bits
        pub type FB3_R = crate::BitReader;
        ///Field `FB3` writer - Filter bits
        pub type FB3_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB4` reader - Filter bits
        pub type FB4_R = crate::BitReader;
        ///Field `FB4` writer - Filter bits
        pub type FB4_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB5` reader - Filter bits
        pub type FB5_R = crate::BitReader;
        ///Field `FB5` writer - Filter bits
        pub type FB5_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB6` reader - Filter bits
        pub type FB6_R = crate::BitReader;
        ///Field `FB6` writer - Filter bits
        pub type FB6_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB7` reader - Filter bits
        pub type FB7_R = crate::BitReader;
        ///Field `FB7` writer - Filter bits
        pub type FB7_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB8` reader - Filter bits
        pub type FB8_R = crate::BitReader;
        ///Field `FB8` writer - Filter bits
        pub type FB8_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB9` reader - Filter bits
        pub type FB9_R = crate::BitReader;
        ///Field `FB9` writer - Filter bits
        pub type FB9_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB10` reader - Filter bits
        pub type FB10_R = crate::BitReader;
        ///Field `FB10` writer - Filter bits
        pub type FB10_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB11` reader - Filter bits
        pub type FB11_R = crate::BitReader;
        ///Field `FB11` writer - Filter bits
        pub type FB11_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB12` reader - Filter bits
        pub type FB12_R = crate::BitReader;
        ///Field `FB12` writer - Filter bits
        pub type FB12_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB13` reader - Filter bits
        pub type FB13_R = crate::BitReader;
        ///Field `FB13` writer - Filter bits
        pub type FB13_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB14` reader - Filter bits
        pub type FB14_R = crate::BitReader;
        ///Field `FB14` writer - Filter bits
        pub type FB14_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB15` reader - Filter bits
        pub type FB15_R = crate::BitReader;
        ///Field `FB15` writer - Filter bits
        pub type FB15_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB16` reader - Filter bits
        pub type FB16_R = crate::BitReader;
        ///Field `FB16` writer - Filter bits
        pub type FB16_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB17` reader - Filter bits
        pub type FB17_R = crate::BitReader;
        ///Field `FB17` writer - Filter bits
        pub type FB17_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB18` reader - Filter bits
        pub type FB18_R = crate::BitReader;
        ///Field `FB18` writer - Filter bits
        pub type FB18_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB19` reader - Filter bits
        pub type FB19_R = crate::BitReader;
        ///Field `FB19` writer - Filter bits
        pub type FB19_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB20` reader - Filter bits
        pub type FB20_R = crate::BitReader;
        ///Field `FB20` writer - Filter bits
        pub type FB20_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB21` reader - Filter bits
        pub type FB21_R = crate::BitReader;
        ///Field `FB21` writer - Filter bits
        pub type FB21_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB22` reader - Filter bits
        pub type FB22_R = crate::BitReader;
        ///Field `FB22` writer - Filter bits
        pub type FB22_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB23` reader - Filter bits
        pub type FB23_R = crate::BitReader;
        ///Field `FB23` writer - Filter bits
        pub type FB23_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB24` reader - Filter bits
        pub type FB24_R = crate::BitReader;
        ///Field `FB24` writer - Filter bits
        pub type FB24_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB25` reader - Filter bits
        pub type FB25_R = crate::BitReader;
        ///Field `FB25` writer - Filter bits
        pub type FB25_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB26` reader - Filter bits
        pub type FB26_R = crate::BitReader;
        ///Field `FB26` writer - Filter bits
        pub type FB26_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB27` reader - Filter bits
        pub type FB27_R = crate::BitReader;
        ///Field `FB27` writer - Filter bits
        pub type FB27_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB28` reader - Filter bits
        pub type FB28_R = crate::BitReader;
        ///Field `FB28` writer - Filter bits
        pub type FB28_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB29` reader - Filter bits
        pub type FB29_R = crate::BitReader;
        ///Field `FB29` writer - Filter bits
        pub type FB29_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB30` reader - Filter bits
        pub type FB30_R = crate::BitReader;
        ///Field `FB30` writer - Filter bits
        pub type FB30_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB31` reader - Filter bits
        pub type FB31_R = crate::BitReader;
        ///Field `FB31` writer - Filter bits
        pub type FB31_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - Filter bits
            #[inline(always)]
            pub fn fb0(&self) -> FB0_R {
                FB0_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Filter bits
            #[inline(always)]
            pub fn fb1(&self) -> FB1_R {
                FB1_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - Filter bits
            #[inline(always)]
            pub fn fb2(&self) -> FB2_R {
                FB2_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - Filter bits
            #[inline(always)]
            pub fn fb3(&self) -> FB3_R {
                FB3_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - Filter bits
            #[inline(always)]
            pub fn fb4(&self) -> FB4_R {
                FB4_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - Filter bits
            #[inline(always)]
            pub fn fb5(&self) -> FB5_R {
                FB5_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - Filter bits
            #[inline(always)]
            pub fn fb6(&self) -> FB6_R {
                FB6_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - Filter bits
            #[inline(always)]
            pub fn fb7(&self) -> FB7_R {
                FB7_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bit 8 - Filter bits
            #[inline(always)]
            pub fn fb8(&self) -> FB8_R {
                FB8_R::new(((self.bits >> 8) & 1) != 0)
            }
            ///Bit 9 - Filter bits
            #[inline(always)]
            pub fn fb9(&self) -> FB9_R {
                FB9_R::new(((self.bits >> 9) & 1) != 0)
            }
            ///Bit 10 - Filter bits
            #[inline(always)]
            pub fn fb10(&self) -> FB10_R {
                FB10_R::new(((self.bits >> 10) & 1) != 0)
            }
            ///Bit 11 - Filter bits
            #[inline(always)]
            pub fn fb11(&self) -> FB11_R {
                FB11_R::new(((self.bits >> 11) & 1) != 0)
            }
            ///Bit 12 - Filter bits
            #[inline(always)]
            pub fn fb12(&self) -> FB12_R {
                FB12_R::new(((self.bits >> 12) & 1) != 0)
            }
            ///Bit 13 - Filter bits
            #[inline(always)]
            pub fn fb13(&self) -> FB13_R {
                FB13_R::new(((self.bits >> 13) & 1) != 0)
            }
            ///Bit 14 - Filter bits
            #[inline(always)]
            pub fn fb14(&self) -> FB14_R {
                FB14_R::new(((self.bits >> 14) & 1) != 0)
            }
            ///Bit 15 - Filter bits
            #[inline(always)]
            pub fn fb15(&self) -> FB15_R {
                FB15_R::new(((self.bits >> 15) & 1) != 0)
            }
            ///Bit 16 - Filter bits
            #[inline(always)]
            pub fn fb16(&self) -> FB16_R {
                FB16_R::new(((self.bits >> 16) & 1) != 0)
            }
            ///Bit 17 - Filter bits
            #[inline(always)]
            pub fn fb17(&self) -> FB17_R {
                FB17_R::new(((self.bits >> 17) & 1) != 0)
            }
            ///Bit 18 - Filter bits
            #[inline(always)]
            pub fn fb18(&self) -> FB18_R {
                FB18_R::new(((self.bits >> 18) & 1) != 0)
            }
            ///Bit 19 - Filter bits
            #[inline(always)]
            pub fn fb19(&self) -> FB19_R {
                FB19_R::new(((self.bits >> 19) & 1) != 0)
            }
            ///Bit 20 - Filter bits
            #[inline(always)]
            pub fn fb20(&self) -> FB20_R {
                FB20_R::new(((self.bits >> 20) & 1) != 0)
            }
            ///Bit 21 - Filter bits
            #[inline(always)]
            pub fn fb21(&self) -> FB21_R {
                FB21_R::new(((self.bits >> 21) & 1) != 0)
            }
            ///Bit 22 - Filter bits
            #[inline(always)]
            pub fn fb22(&self) -> FB22_R {
                FB22_R::new(((self.bits >> 22) & 1) != 0)
            }
            ///Bit 23 - Filter bits
            #[inline(always)]
            pub fn fb23(&self) -> FB23_R {
                FB23_R::new(((self.bits >> 23) & 1) != 0)
            }
            ///Bit 24 - Filter bits
            #[inline(always)]
            pub fn fb24(&self) -> FB24_R {
                FB24_R::new(((self.bits >> 24) & 1) != 0)
            }
            ///Bit 25 - Filter bits
            #[inline(always)]
            pub fn fb25(&self) -> FB25_R {
                FB25_R::new(((self.bits >> 25) & 1) != 0)
            }
            ///Bit 26 - Filter bits
            #[inline(always)]
            pub fn fb26(&self) -> FB26_R {
                FB26_R::new(((self.bits >> 26) & 1) != 0)
            }
            ///Bit 27 - Filter bits
            #[inline(always)]
            pub fn fb27(&self) -> FB27_R {
                FB27_R::new(((self.bits >> 27) & 1) != 0)
            }
            ///Bit 28 - Filter bits
            #[inline(always)]
            pub fn fb28(&self) -> FB28_R {
                FB28_R::new(((self.bits >> 28) & 1) != 0)
            }
            ///Bit 29 - Filter bits
            #[inline(always)]
            pub fn fb29(&self) -> FB29_R {
                FB29_R::new(((self.bits >> 29) & 1) != 0)
            }
            ///Bit 30 - Filter bits
            #[inline(always)]
            pub fn fb30(&self) -> FB30_R {
                FB30_R::new(((self.bits >> 30) & 1) != 0)
            }
            ///Bit 31 - Filter bits
            #[inline(always)]
            pub fn fb31(&self) -> FB31_R {
                FB31_R::new(((self.bits >> 31) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb0(&mut self) -> FB0_W<F3R2_SPEC> {
                FB0_W::new(self, 0)
            }
            ///Bit 1 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb1(&mut self) -> FB1_W<F3R2_SPEC> {
                FB1_W::new(self, 1)
            }
            ///Bit 2 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb2(&mut self) -> FB2_W<F3R2_SPEC> {
                FB2_W::new(self, 2)
            }
            ///Bit 3 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb3(&mut self) -> FB3_W<F3R2_SPEC> {
                FB3_W::new(self, 3)
            }
            ///Bit 4 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb4(&mut self) -> FB4_W<F3R2_SPEC> {
                FB4_W::new(self, 4)
            }
            ///Bit 5 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb5(&mut self) -> FB5_W<F3R2_SPEC> {
                FB5_W::new(self, 5)
            }
            ///Bit 6 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb6(&mut self) -> FB6_W<F3R2_SPEC> {
                FB6_W::new(self, 6)
            }
            ///Bit 7 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb7(&mut self) -> FB7_W<F3R2_SPEC> {
                FB7_W::new(self, 7)
            }
            ///Bit 8 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb8(&mut self) -> FB8_W<F3R2_SPEC> {
                FB8_W::new(self, 8)
            }
            ///Bit 9 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb9(&mut self) -> FB9_W<F3R2_SPEC> {
                FB9_W::new(self, 9)
            }
            ///Bit 10 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb10(&mut self) -> FB10_W<F3R2_SPEC> {
                FB10_W::new(self, 10)
            }
            ///Bit 11 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb11(&mut self) -> FB11_W<F3R2_SPEC> {
                FB11_W::new(self, 11)
            }
            ///Bit 12 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb12(&mut self) -> FB12_W<F3R2_SPEC> {
                FB12_W::new(self, 12)
            }
            ///Bit 13 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb13(&mut self) -> FB13_W<F3R2_SPEC> {
                FB13_W::new(self, 13)
            }
            ///Bit 14 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb14(&mut self) -> FB14_W<F3R2_SPEC> {
                FB14_W::new(self, 14)
            }
            ///Bit 15 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb15(&mut self) -> FB15_W<F3R2_SPEC> {
                FB15_W::new(self, 15)
            }
            ///Bit 16 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb16(&mut self) -> FB16_W<F3R2_SPEC> {
                FB16_W::new(self, 16)
            }
            ///Bit 17 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb17(&mut self) -> FB17_W<F3R2_SPEC> {
                FB17_W::new(self, 17)
            }
            ///Bit 18 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb18(&mut self) -> FB18_W<F3R2_SPEC> {
                FB18_W::new(self, 18)
            }
            ///Bit 19 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb19(&mut self) -> FB19_W<F3R2_SPEC> {
                FB19_W::new(self, 19)
            }
            ///Bit 20 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb20(&mut self) -> FB20_W<F3R2_SPEC> {
                FB20_W::new(self, 20)
            }
            ///Bit 21 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb21(&mut self) -> FB21_W<F3R2_SPEC> {
                FB21_W::new(self, 21)
            }
            ///Bit 22 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb22(&mut self) -> FB22_W<F3R2_SPEC> {
                FB22_W::new(self, 22)
            }
            ///Bit 23 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb23(&mut self) -> FB23_W<F3R2_SPEC> {
                FB23_W::new(self, 23)
            }
            ///Bit 24 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb24(&mut self) -> FB24_W<F3R2_SPEC> {
                FB24_W::new(self, 24)
            }
            ///Bit 25 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb25(&mut self) -> FB25_W<F3R2_SPEC> {
                FB25_W::new(self, 25)
            }
            ///Bit 26 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb26(&mut self) -> FB26_W<F3R2_SPEC> {
                FB26_W::new(self, 26)
            }
            ///Bit 27 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb27(&mut self) -> FB27_W<F3R2_SPEC> {
                FB27_W::new(self, 27)
            }
            ///Bit 28 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb28(&mut self) -> FB28_W<F3R2_SPEC> {
                FB28_W::new(self, 28)
            }
            ///Bit 29 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb29(&mut self) -> FB29_W<F3R2_SPEC> {
                FB29_W::new(self, 29)
            }
            ///Bit 30 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb30(&mut self) -> FB30_W<F3R2_SPEC> {
                FB30_W::new(self, 30)
            }
            ///Bit 31 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb31(&mut self) -> FB31_W<F3R2_SPEC> {
                FB31_W::new(self, 31)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Filter bank 3 register 2
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`f3r2::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`f3r2::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct F3R2_SPEC;
        impl crate::RegisterSpec for F3R2_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`f3r2::R`](R) reader structure
        impl crate::Readable for F3R2_SPEC {}
        ///`write(|w| ..)` method takes [`f3r2::W`](W) writer structure
        impl crate::Writable for F3R2_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets F3R2 to value 0
        impl crate::Resettable for F3R2_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///F4R1 (rw) register accessor: Filter bank 4 register 1
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`f4r1::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`f4r1::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@f4r1`]
    ///module
    pub type F4R1 = crate::Reg<f4r1::F4R1_SPEC>;
    ///Filter bank 4 register 1
    pub mod f4r1 {
        ///Register `F4R1` reader
        pub type R = crate::R<F4R1_SPEC>;
        ///Register `F4R1` writer
        pub type W = crate::W<F4R1_SPEC>;
        ///Field `FB0` reader - Filter bits
        pub type FB0_R = crate::BitReader;
        ///Field `FB0` writer - Filter bits
        pub type FB0_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB1` reader - Filter bits
        pub type FB1_R = crate::BitReader;
        ///Field `FB1` writer - Filter bits
        pub type FB1_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB2` reader - Filter bits
        pub type FB2_R = crate::BitReader;
        ///Field `FB2` writer - Filter bits
        pub type FB2_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB3` reader - Filter bits
        pub type FB3_R = crate::BitReader;
        ///Field `FB3` writer - Filter bits
        pub type FB3_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB4` reader - Filter bits
        pub type FB4_R = crate::BitReader;
        ///Field `FB4` writer - Filter bits
        pub type FB4_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB5` reader - Filter bits
        pub type FB5_R = crate::BitReader;
        ///Field `FB5` writer - Filter bits
        pub type FB5_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB6` reader - Filter bits
        pub type FB6_R = crate::BitReader;
        ///Field `FB6` writer - Filter bits
        pub type FB6_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB7` reader - Filter bits
        pub type FB7_R = crate::BitReader;
        ///Field `FB7` writer - Filter bits
        pub type FB7_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB8` reader - Filter bits
        pub type FB8_R = crate::BitReader;
        ///Field `FB8` writer - Filter bits
        pub type FB8_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB9` reader - Filter bits
        pub type FB9_R = crate::BitReader;
        ///Field `FB9` writer - Filter bits
        pub type FB9_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB10` reader - Filter bits
        pub type FB10_R = crate::BitReader;
        ///Field `FB10` writer - Filter bits
        pub type FB10_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB11` reader - Filter bits
        pub type FB11_R = crate::BitReader;
        ///Field `FB11` writer - Filter bits
        pub type FB11_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB12` reader - Filter bits
        pub type FB12_R = crate::BitReader;
        ///Field `FB12` writer - Filter bits
        pub type FB12_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB13` reader - Filter bits
        pub type FB13_R = crate::BitReader;
        ///Field `FB13` writer - Filter bits
        pub type FB13_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB14` reader - Filter bits
        pub type FB14_R = crate::BitReader;
        ///Field `FB14` writer - Filter bits
        pub type FB14_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB15` reader - Filter bits
        pub type FB15_R = crate::BitReader;
        ///Field `FB15` writer - Filter bits
        pub type FB15_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB16` reader - Filter bits
        pub type FB16_R = crate::BitReader;
        ///Field `FB16` writer - Filter bits
        pub type FB16_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB17` reader - Filter bits
        pub type FB17_R = crate::BitReader;
        ///Field `FB17` writer - Filter bits
        pub type FB17_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB18` reader - Filter bits
        pub type FB18_R = crate::BitReader;
        ///Field `FB18` writer - Filter bits
        pub type FB18_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB19` reader - Filter bits
        pub type FB19_R = crate::BitReader;
        ///Field `FB19` writer - Filter bits
        pub type FB19_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB20` reader - Filter bits
        pub type FB20_R = crate::BitReader;
        ///Field `FB20` writer - Filter bits
        pub type FB20_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB21` reader - Filter bits
        pub type FB21_R = crate::BitReader;
        ///Field `FB21` writer - Filter bits
        pub type FB21_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB22` reader - Filter bits
        pub type FB22_R = crate::BitReader;
        ///Field `FB22` writer - Filter bits
        pub type FB22_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB23` reader - Filter bits
        pub type FB23_R = crate::BitReader;
        ///Field `FB23` writer - Filter bits
        pub type FB23_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB24` reader - Filter bits
        pub type FB24_R = crate::BitReader;
        ///Field `FB24` writer - Filter bits
        pub type FB24_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB25` reader - Filter bits
        pub type FB25_R = crate::BitReader;
        ///Field `FB25` writer - Filter bits
        pub type FB25_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB26` reader - Filter bits
        pub type FB26_R = crate::BitReader;
        ///Field `FB26` writer - Filter bits
        pub type FB26_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB27` reader - Filter bits
        pub type FB27_R = crate::BitReader;
        ///Field `FB27` writer - Filter bits
        pub type FB27_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB28` reader - Filter bits
        pub type FB28_R = crate::BitReader;
        ///Field `FB28` writer - Filter bits
        pub type FB28_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB29` reader - Filter bits
        pub type FB29_R = crate::BitReader;
        ///Field `FB29` writer - Filter bits
        pub type FB29_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB30` reader - Filter bits
        pub type FB30_R = crate::BitReader;
        ///Field `FB30` writer - Filter bits
        pub type FB30_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB31` reader - Filter bits
        pub type FB31_R = crate::BitReader;
        ///Field `FB31` writer - Filter bits
        pub type FB31_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - Filter bits
            #[inline(always)]
            pub fn fb0(&self) -> FB0_R {
                FB0_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Filter bits
            #[inline(always)]
            pub fn fb1(&self) -> FB1_R {
                FB1_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - Filter bits
            #[inline(always)]
            pub fn fb2(&self) -> FB2_R {
                FB2_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - Filter bits
            #[inline(always)]
            pub fn fb3(&self) -> FB3_R {
                FB3_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - Filter bits
            #[inline(always)]
            pub fn fb4(&self) -> FB4_R {
                FB4_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - Filter bits
            #[inline(always)]
            pub fn fb5(&self) -> FB5_R {
                FB5_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - Filter bits
            #[inline(always)]
            pub fn fb6(&self) -> FB6_R {
                FB6_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - Filter bits
            #[inline(always)]
            pub fn fb7(&self) -> FB7_R {
                FB7_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bit 8 - Filter bits
            #[inline(always)]
            pub fn fb8(&self) -> FB8_R {
                FB8_R::new(((self.bits >> 8) & 1) != 0)
            }
            ///Bit 9 - Filter bits
            #[inline(always)]
            pub fn fb9(&self) -> FB9_R {
                FB9_R::new(((self.bits >> 9) & 1) != 0)
            }
            ///Bit 10 - Filter bits
            #[inline(always)]
            pub fn fb10(&self) -> FB10_R {
                FB10_R::new(((self.bits >> 10) & 1) != 0)
            }
            ///Bit 11 - Filter bits
            #[inline(always)]
            pub fn fb11(&self) -> FB11_R {
                FB11_R::new(((self.bits >> 11) & 1) != 0)
            }
            ///Bit 12 - Filter bits
            #[inline(always)]
            pub fn fb12(&self) -> FB12_R {
                FB12_R::new(((self.bits >> 12) & 1) != 0)
            }
            ///Bit 13 - Filter bits
            #[inline(always)]
            pub fn fb13(&self) -> FB13_R {
                FB13_R::new(((self.bits >> 13) & 1) != 0)
            }
            ///Bit 14 - Filter bits
            #[inline(always)]
            pub fn fb14(&self) -> FB14_R {
                FB14_R::new(((self.bits >> 14) & 1) != 0)
            }
            ///Bit 15 - Filter bits
            #[inline(always)]
            pub fn fb15(&self) -> FB15_R {
                FB15_R::new(((self.bits >> 15) & 1) != 0)
            }
            ///Bit 16 - Filter bits
            #[inline(always)]
            pub fn fb16(&self) -> FB16_R {
                FB16_R::new(((self.bits >> 16) & 1) != 0)
            }
            ///Bit 17 - Filter bits
            #[inline(always)]
            pub fn fb17(&self) -> FB17_R {
                FB17_R::new(((self.bits >> 17) & 1) != 0)
            }
            ///Bit 18 - Filter bits
            #[inline(always)]
            pub fn fb18(&self) -> FB18_R {
                FB18_R::new(((self.bits >> 18) & 1) != 0)
            }
            ///Bit 19 - Filter bits
            #[inline(always)]
            pub fn fb19(&self) -> FB19_R {
                FB19_R::new(((self.bits >> 19) & 1) != 0)
            }
            ///Bit 20 - Filter bits
            #[inline(always)]
            pub fn fb20(&self) -> FB20_R {
                FB20_R::new(((self.bits >> 20) & 1) != 0)
            }
            ///Bit 21 - Filter bits
            #[inline(always)]
            pub fn fb21(&self) -> FB21_R {
                FB21_R::new(((self.bits >> 21) & 1) != 0)
            }
            ///Bit 22 - Filter bits
            #[inline(always)]
            pub fn fb22(&self) -> FB22_R {
                FB22_R::new(((self.bits >> 22) & 1) != 0)
            }
            ///Bit 23 - Filter bits
            #[inline(always)]
            pub fn fb23(&self) -> FB23_R {
                FB23_R::new(((self.bits >> 23) & 1) != 0)
            }
            ///Bit 24 - Filter bits
            #[inline(always)]
            pub fn fb24(&self) -> FB24_R {
                FB24_R::new(((self.bits >> 24) & 1) != 0)
            }
            ///Bit 25 - Filter bits
            #[inline(always)]
            pub fn fb25(&self) -> FB25_R {
                FB25_R::new(((self.bits >> 25) & 1) != 0)
            }
            ///Bit 26 - Filter bits
            #[inline(always)]
            pub fn fb26(&self) -> FB26_R {
                FB26_R::new(((self.bits >> 26) & 1) != 0)
            }
            ///Bit 27 - Filter bits
            #[inline(always)]
            pub fn fb27(&self) -> FB27_R {
                FB27_R::new(((self.bits >> 27) & 1) != 0)
            }
            ///Bit 28 - Filter bits
            #[inline(always)]
            pub fn fb28(&self) -> FB28_R {
                FB28_R::new(((self.bits >> 28) & 1) != 0)
            }
            ///Bit 29 - Filter bits
            #[inline(always)]
            pub fn fb29(&self) -> FB29_R {
                FB29_R::new(((self.bits >> 29) & 1) != 0)
            }
            ///Bit 30 - Filter bits
            #[inline(always)]
            pub fn fb30(&self) -> FB30_R {
                FB30_R::new(((self.bits >> 30) & 1) != 0)
            }
            ///Bit 31 - Filter bits
            #[inline(always)]
            pub fn fb31(&self) -> FB31_R {
                FB31_R::new(((self.bits >> 31) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb0(&mut self) -> FB0_W<F4R1_SPEC> {
                FB0_W::new(self, 0)
            }
            ///Bit 1 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb1(&mut self) -> FB1_W<F4R1_SPEC> {
                FB1_W::new(self, 1)
            }
            ///Bit 2 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb2(&mut self) -> FB2_W<F4R1_SPEC> {
                FB2_W::new(self, 2)
            }
            ///Bit 3 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb3(&mut self) -> FB3_W<F4R1_SPEC> {
                FB3_W::new(self, 3)
            }
            ///Bit 4 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb4(&mut self) -> FB4_W<F4R1_SPEC> {
                FB4_W::new(self, 4)
            }
            ///Bit 5 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb5(&mut self) -> FB5_W<F4R1_SPEC> {
                FB5_W::new(self, 5)
            }
            ///Bit 6 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb6(&mut self) -> FB6_W<F4R1_SPEC> {
                FB6_W::new(self, 6)
            }
            ///Bit 7 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb7(&mut self) -> FB7_W<F4R1_SPEC> {
                FB7_W::new(self, 7)
            }
            ///Bit 8 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb8(&mut self) -> FB8_W<F4R1_SPEC> {
                FB8_W::new(self, 8)
            }
            ///Bit 9 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb9(&mut self) -> FB9_W<F4R1_SPEC> {
                FB9_W::new(self, 9)
            }
            ///Bit 10 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb10(&mut self) -> FB10_W<F4R1_SPEC> {
                FB10_W::new(self, 10)
            }
            ///Bit 11 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb11(&mut self) -> FB11_W<F4R1_SPEC> {
                FB11_W::new(self, 11)
            }
            ///Bit 12 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb12(&mut self) -> FB12_W<F4R1_SPEC> {
                FB12_W::new(self, 12)
            }
            ///Bit 13 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb13(&mut self) -> FB13_W<F4R1_SPEC> {
                FB13_W::new(self, 13)
            }
            ///Bit 14 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb14(&mut self) -> FB14_W<F4R1_SPEC> {
                FB14_W::new(self, 14)
            }
            ///Bit 15 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb15(&mut self) -> FB15_W<F4R1_SPEC> {
                FB15_W::new(self, 15)
            }
            ///Bit 16 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb16(&mut self) -> FB16_W<F4R1_SPEC> {
                FB16_W::new(self, 16)
            }
            ///Bit 17 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb17(&mut self) -> FB17_W<F4R1_SPEC> {
                FB17_W::new(self, 17)
            }
            ///Bit 18 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb18(&mut self) -> FB18_W<F4R1_SPEC> {
                FB18_W::new(self, 18)
            }
            ///Bit 19 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb19(&mut self) -> FB19_W<F4R1_SPEC> {
                FB19_W::new(self, 19)
            }
            ///Bit 20 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb20(&mut self) -> FB20_W<F4R1_SPEC> {
                FB20_W::new(self, 20)
            }
            ///Bit 21 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb21(&mut self) -> FB21_W<F4R1_SPEC> {
                FB21_W::new(self, 21)
            }
            ///Bit 22 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb22(&mut self) -> FB22_W<F4R1_SPEC> {
                FB22_W::new(self, 22)
            }
            ///Bit 23 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb23(&mut self) -> FB23_W<F4R1_SPEC> {
                FB23_W::new(self, 23)
            }
            ///Bit 24 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb24(&mut self) -> FB24_W<F4R1_SPEC> {
                FB24_W::new(self, 24)
            }
            ///Bit 25 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb25(&mut self) -> FB25_W<F4R1_SPEC> {
                FB25_W::new(self, 25)
            }
            ///Bit 26 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb26(&mut self) -> FB26_W<F4R1_SPEC> {
                FB26_W::new(self, 26)
            }
            ///Bit 27 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb27(&mut self) -> FB27_W<F4R1_SPEC> {
                FB27_W::new(self, 27)
            }
            ///Bit 28 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb28(&mut self) -> FB28_W<F4R1_SPEC> {
                FB28_W::new(self, 28)
            }
            ///Bit 29 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb29(&mut self) -> FB29_W<F4R1_SPEC> {
                FB29_W::new(self, 29)
            }
            ///Bit 30 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb30(&mut self) -> FB30_W<F4R1_SPEC> {
                FB30_W::new(self, 30)
            }
            ///Bit 31 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb31(&mut self) -> FB31_W<F4R1_SPEC> {
                FB31_W::new(self, 31)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Filter bank 4 register 1
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`f4r1::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`f4r1::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct F4R1_SPEC;
        impl crate::RegisterSpec for F4R1_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`f4r1::R`](R) reader structure
        impl crate::Readable for F4R1_SPEC {}
        ///`write(|w| ..)` method takes [`f4r1::W`](W) writer structure
        impl crate::Writable for F4R1_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets F4R1 to value 0
        impl crate::Resettable for F4R1_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///F4R2 (rw) register accessor: Filter bank 4 register 2
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`f4r2::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`f4r2::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@f4r2`]
    ///module
    pub type F4R2 = crate::Reg<f4r2::F4R2_SPEC>;
    ///Filter bank 4 register 2
    pub mod f4r2 {
        ///Register `F4R2` reader
        pub type R = crate::R<F4R2_SPEC>;
        ///Register `F4R2` writer
        pub type W = crate::W<F4R2_SPEC>;
        ///Field `FB0` reader - Filter bits
        pub type FB0_R = crate::BitReader;
        ///Field `FB0` writer - Filter bits
        pub type FB0_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB1` reader - Filter bits
        pub type FB1_R = crate::BitReader;
        ///Field `FB1` writer - Filter bits
        pub type FB1_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB2` reader - Filter bits
        pub type FB2_R = crate::BitReader;
        ///Field `FB2` writer - Filter bits
        pub type FB2_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB3` reader - Filter bits
        pub type FB3_R = crate::BitReader;
        ///Field `FB3` writer - Filter bits
        pub type FB3_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB4` reader - Filter bits
        pub type FB4_R = crate::BitReader;
        ///Field `FB4` writer - Filter bits
        pub type FB4_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB5` reader - Filter bits
        pub type FB5_R = crate::BitReader;
        ///Field `FB5` writer - Filter bits
        pub type FB5_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB6` reader - Filter bits
        pub type FB6_R = crate::BitReader;
        ///Field `FB6` writer - Filter bits
        pub type FB6_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB7` reader - Filter bits
        pub type FB7_R = crate::BitReader;
        ///Field `FB7` writer - Filter bits
        pub type FB7_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB8` reader - Filter bits
        pub type FB8_R = crate::BitReader;
        ///Field `FB8` writer - Filter bits
        pub type FB8_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB9` reader - Filter bits
        pub type FB9_R = crate::BitReader;
        ///Field `FB9` writer - Filter bits
        pub type FB9_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB10` reader - Filter bits
        pub type FB10_R = crate::BitReader;
        ///Field `FB10` writer - Filter bits
        pub type FB10_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB11` reader - Filter bits
        pub type FB11_R = crate::BitReader;
        ///Field `FB11` writer - Filter bits
        pub type FB11_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB12` reader - Filter bits
        pub type FB12_R = crate::BitReader;
        ///Field `FB12` writer - Filter bits
        pub type FB12_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB13` reader - Filter bits
        pub type FB13_R = crate::BitReader;
        ///Field `FB13` writer - Filter bits
        pub type FB13_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB14` reader - Filter bits
        pub type FB14_R = crate::BitReader;
        ///Field `FB14` writer - Filter bits
        pub type FB14_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB15` reader - Filter bits
        pub type FB15_R = crate::BitReader;
        ///Field `FB15` writer - Filter bits
        pub type FB15_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB16` reader - Filter bits
        pub type FB16_R = crate::BitReader;
        ///Field `FB16` writer - Filter bits
        pub type FB16_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB17` reader - Filter bits
        pub type FB17_R = crate::BitReader;
        ///Field `FB17` writer - Filter bits
        pub type FB17_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB18` reader - Filter bits
        pub type FB18_R = crate::BitReader;
        ///Field `FB18` writer - Filter bits
        pub type FB18_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB19` reader - Filter bits
        pub type FB19_R = crate::BitReader;
        ///Field `FB19` writer - Filter bits
        pub type FB19_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB20` reader - Filter bits
        pub type FB20_R = crate::BitReader;
        ///Field `FB20` writer - Filter bits
        pub type FB20_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB21` reader - Filter bits
        pub type FB21_R = crate::BitReader;
        ///Field `FB21` writer - Filter bits
        pub type FB21_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB22` reader - Filter bits
        pub type FB22_R = crate::BitReader;
        ///Field `FB22` writer - Filter bits
        pub type FB22_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB23` reader - Filter bits
        pub type FB23_R = crate::BitReader;
        ///Field `FB23` writer - Filter bits
        pub type FB23_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB24` reader - Filter bits
        pub type FB24_R = crate::BitReader;
        ///Field `FB24` writer - Filter bits
        pub type FB24_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB25` reader - Filter bits
        pub type FB25_R = crate::BitReader;
        ///Field `FB25` writer - Filter bits
        pub type FB25_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB26` reader - Filter bits
        pub type FB26_R = crate::BitReader;
        ///Field `FB26` writer - Filter bits
        pub type FB26_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB27` reader - Filter bits
        pub type FB27_R = crate::BitReader;
        ///Field `FB27` writer - Filter bits
        pub type FB27_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB28` reader - Filter bits
        pub type FB28_R = crate::BitReader;
        ///Field `FB28` writer - Filter bits
        pub type FB28_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB29` reader - Filter bits
        pub type FB29_R = crate::BitReader;
        ///Field `FB29` writer - Filter bits
        pub type FB29_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB30` reader - Filter bits
        pub type FB30_R = crate::BitReader;
        ///Field `FB30` writer - Filter bits
        pub type FB30_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB31` reader - Filter bits
        pub type FB31_R = crate::BitReader;
        ///Field `FB31` writer - Filter bits
        pub type FB31_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - Filter bits
            #[inline(always)]
            pub fn fb0(&self) -> FB0_R {
                FB0_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Filter bits
            #[inline(always)]
            pub fn fb1(&self) -> FB1_R {
                FB1_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - Filter bits
            #[inline(always)]
            pub fn fb2(&self) -> FB2_R {
                FB2_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - Filter bits
            #[inline(always)]
            pub fn fb3(&self) -> FB3_R {
                FB3_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - Filter bits
            #[inline(always)]
            pub fn fb4(&self) -> FB4_R {
                FB4_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - Filter bits
            #[inline(always)]
            pub fn fb5(&self) -> FB5_R {
                FB5_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - Filter bits
            #[inline(always)]
            pub fn fb6(&self) -> FB6_R {
                FB6_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - Filter bits
            #[inline(always)]
            pub fn fb7(&self) -> FB7_R {
                FB7_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bit 8 - Filter bits
            #[inline(always)]
            pub fn fb8(&self) -> FB8_R {
                FB8_R::new(((self.bits >> 8) & 1) != 0)
            }
            ///Bit 9 - Filter bits
            #[inline(always)]
            pub fn fb9(&self) -> FB9_R {
                FB9_R::new(((self.bits >> 9) & 1) != 0)
            }
            ///Bit 10 - Filter bits
            #[inline(always)]
            pub fn fb10(&self) -> FB10_R {
                FB10_R::new(((self.bits >> 10) & 1) != 0)
            }
            ///Bit 11 - Filter bits
            #[inline(always)]
            pub fn fb11(&self) -> FB11_R {
                FB11_R::new(((self.bits >> 11) & 1) != 0)
            }
            ///Bit 12 - Filter bits
            #[inline(always)]
            pub fn fb12(&self) -> FB12_R {
                FB12_R::new(((self.bits >> 12) & 1) != 0)
            }
            ///Bit 13 - Filter bits
            #[inline(always)]
            pub fn fb13(&self) -> FB13_R {
                FB13_R::new(((self.bits >> 13) & 1) != 0)
            }
            ///Bit 14 - Filter bits
            #[inline(always)]
            pub fn fb14(&self) -> FB14_R {
                FB14_R::new(((self.bits >> 14) & 1) != 0)
            }
            ///Bit 15 - Filter bits
            #[inline(always)]
            pub fn fb15(&self) -> FB15_R {
                FB15_R::new(((self.bits >> 15) & 1) != 0)
            }
            ///Bit 16 - Filter bits
            #[inline(always)]
            pub fn fb16(&self) -> FB16_R {
                FB16_R::new(((self.bits >> 16) & 1) != 0)
            }
            ///Bit 17 - Filter bits
            #[inline(always)]
            pub fn fb17(&self) -> FB17_R {
                FB17_R::new(((self.bits >> 17) & 1) != 0)
            }
            ///Bit 18 - Filter bits
            #[inline(always)]
            pub fn fb18(&self) -> FB18_R {
                FB18_R::new(((self.bits >> 18) & 1) != 0)
            }
            ///Bit 19 - Filter bits
            #[inline(always)]
            pub fn fb19(&self) -> FB19_R {
                FB19_R::new(((self.bits >> 19) & 1) != 0)
            }
            ///Bit 20 - Filter bits
            #[inline(always)]
            pub fn fb20(&self) -> FB20_R {
                FB20_R::new(((self.bits >> 20) & 1) != 0)
            }
            ///Bit 21 - Filter bits
            #[inline(always)]
            pub fn fb21(&self) -> FB21_R {
                FB21_R::new(((self.bits >> 21) & 1) != 0)
            }
            ///Bit 22 - Filter bits
            #[inline(always)]
            pub fn fb22(&self) -> FB22_R {
                FB22_R::new(((self.bits >> 22) & 1) != 0)
            }
            ///Bit 23 - Filter bits
            #[inline(always)]
            pub fn fb23(&self) -> FB23_R {
                FB23_R::new(((self.bits >> 23) & 1) != 0)
            }
            ///Bit 24 - Filter bits
            #[inline(always)]
            pub fn fb24(&self) -> FB24_R {
                FB24_R::new(((self.bits >> 24) & 1) != 0)
            }
            ///Bit 25 - Filter bits
            #[inline(always)]
            pub fn fb25(&self) -> FB25_R {
                FB25_R::new(((self.bits >> 25) & 1) != 0)
            }
            ///Bit 26 - Filter bits
            #[inline(always)]
            pub fn fb26(&self) -> FB26_R {
                FB26_R::new(((self.bits >> 26) & 1) != 0)
            }
            ///Bit 27 - Filter bits
            #[inline(always)]
            pub fn fb27(&self) -> FB27_R {
                FB27_R::new(((self.bits >> 27) & 1) != 0)
            }
            ///Bit 28 - Filter bits
            #[inline(always)]
            pub fn fb28(&self) -> FB28_R {
                FB28_R::new(((self.bits >> 28) & 1) != 0)
            }
            ///Bit 29 - Filter bits
            #[inline(always)]
            pub fn fb29(&self) -> FB29_R {
                FB29_R::new(((self.bits >> 29) & 1) != 0)
            }
            ///Bit 30 - Filter bits
            #[inline(always)]
            pub fn fb30(&self) -> FB30_R {
                FB30_R::new(((self.bits >> 30) & 1) != 0)
            }
            ///Bit 31 - Filter bits
            #[inline(always)]
            pub fn fb31(&self) -> FB31_R {
                FB31_R::new(((self.bits >> 31) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb0(&mut self) -> FB0_W<F4R2_SPEC> {
                FB0_W::new(self, 0)
            }
            ///Bit 1 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb1(&mut self) -> FB1_W<F4R2_SPEC> {
                FB1_W::new(self, 1)
            }
            ///Bit 2 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb2(&mut self) -> FB2_W<F4R2_SPEC> {
                FB2_W::new(self, 2)
            }
            ///Bit 3 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb3(&mut self) -> FB3_W<F4R2_SPEC> {
                FB3_W::new(self, 3)
            }
            ///Bit 4 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb4(&mut self) -> FB4_W<F4R2_SPEC> {
                FB4_W::new(self, 4)
            }
            ///Bit 5 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb5(&mut self) -> FB5_W<F4R2_SPEC> {
                FB5_W::new(self, 5)
            }
            ///Bit 6 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb6(&mut self) -> FB6_W<F4R2_SPEC> {
                FB6_W::new(self, 6)
            }
            ///Bit 7 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb7(&mut self) -> FB7_W<F4R2_SPEC> {
                FB7_W::new(self, 7)
            }
            ///Bit 8 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb8(&mut self) -> FB8_W<F4R2_SPEC> {
                FB8_W::new(self, 8)
            }
            ///Bit 9 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb9(&mut self) -> FB9_W<F4R2_SPEC> {
                FB9_W::new(self, 9)
            }
            ///Bit 10 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb10(&mut self) -> FB10_W<F4R2_SPEC> {
                FB10_W::new(self, 10)
            }
            ///Bit 11 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb11(&mut self) -> FB11_W<F4R2_SPEC> {
                FB11_W::new(self, 11)
            }
            ///Bit 12 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb12(&mut self) -> FB12_W<F4R2_SPEC> {
                FB12_W::new(self, 12)
            }
            ///Bit 13 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb13(&mut self) -> FB13_W<F4R2_SPEC> {
                FB13_W::new(self, 13)
            }
            ///Bit 14 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb14(&mut self) -> FB14_W<F4R2_SPEC> {
                FB14_W::new(self, 14)
            }
            ///Bit 15 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb15(&mut self) -> FB15_W<F4R2_SPEC> {
                FB15_W::new(self, 15)
            }
            ///Bit 16 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb16(&mut self) -> FB16_W<F4R2_SPEC> {
                FB16_W::new(self, 16)
            }
            ///Bit 17 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb17(&mut self) -> FB17_W<F4R2_SPEC> {
                FB17_W::new(self, 17)
            }
            ///Bit 18 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb18(&mut self) -> FB18_W<F4R2_SPEC> {
                FB18_W::new(self, 18)
            }
            ///Bit 19 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb19(&mut self) -> FB19_W<F4R2_SPEC> {
                FB19_W::new(self, 19)
            }
            ///Bit 20 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb20(&mut self) -> FB20_W<F4R2_SPEC> {
                FB20_W::new(self, 20)
            }
            ///Bit 21 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb21(&mut self) -> FB21_W<F4R2_SPEC> {
                FB21_W::new(self, 21)
            }
            ///Bit 22 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb22(&mut self) -> FB22_W<F4R2_SPEC> {
                FB22_W::new(self, 22)
            }
            ///Bit 23 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb23(&mut self) -> FB23_W<F4R2_SPEC> {
                FB23_W::new(self, 23)
            }
            ///Bit 24 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb24(&mut self) -> FB24_W<F4R2_SPEC> {
                FB24_W::new(self, 24)
            }
            ///Bit 25 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb25(&mut self) -> FB25_W<F4R2_SPEC> {
                FB25_W::new(self, 25)
            }
            ///Bit 26 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb26(&mut self) -> FB26_W<F4R2_SPEC> {
                FB26_W::new(self, 26)
            }
            ///Bit 27 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb27(&mut self) -> FB27_W<F4R2_SPEC> {
                FB27_W::new(self, 27)
            }
            ///Bit 28 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb28(&mut self) -> FB28_W<F4R2_SPEC> {
                FB28_W::new(self, 28)
            }
            ///Bit 29 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb29(&mut self) -> FB29_W<F4R2_SPEC> {
                FB29_W::new(self, 29)
            }
            ///Bit 30 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb30(&mut self) -> FB30_W<F4R2_SPEC> {
                FB30_W::new(self, 30)
            }
            ///Bit 31 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb31(&mut self) -> FB31_W<F4R2_SPEC> {
                FB31_W::new(self, 31)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Filter bank 4 register 2
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`f4r2::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`f4r2::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct F4R2_SPEC;
        impl crate::RegisterSpec for F4R2_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`f4r2::R`](R) reader structure
        impl crate::Readable for F4R2_SPEC {}
        ///`write(|w| ..)` method takes [`f4r2::W`](W) writer structure
        impl crate::Writable for F4R2_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets F4R2 to value 0
        impl crate::Resettable for F4R2_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///F5R1 (rw) register accessor: Filter bank 5 register 1
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`f5r1::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`f5r1::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@f5r1`]
    ///module
    pub type F5R1 = crate::Reg<f5r1::F5R1_SPEC>;
    ///Filter bank 5 register 1
    pub mod f5r1 {
        ///Register `F5R1` reader
        pub type R = crate::R<F5R1_SPEC>;
        ///Register `F5R1` writer
        pub type W = crate::W<F5R1_SPEC>;
        ///Field `FB0` reader - Filter bits
        pub type FB0_R = crate::BitReader;
        ///Field `FB0` writer - Filter bits
        pub type FB0_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB1` reader - Filter bits
        pub type FB1_R = crate::BitReader;
        ///Field `FB1` writer - Filter bits
        pub type FB1_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB2` reader - Filter bits
        pub type FB2_R = crate::BitReader;
        ///Field `FB2` writer - Filter bits
        pub type FB2_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB3` reader - Filter bits
        pub type FB3_R = crate::BitReader;
        ///Field `FB3` writer - Filter bits
        pub type FB3_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB4` reader - Filter bits
        pub type FB4_R = crate::BitReader;
        ///Field `FB4` writer - Filter bits
        pub type FB4_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB5` reader - Filter bits
        pub type FB5_R = crate::BitReader;
        ///Field `FB5` writer - Filter bits
        pub type FB5_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB6` reader - Filter bits
        pub type FB6_R = crate::BitReader;
        ///Field `FB6` writer - Filter bits
        pub type FB6_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB7` reader - Filter bits
        pub type FB7_R = crate::BitReader;
        ///Field `FB7` writer - Filter bits
        pub type FB7_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB8` reader - Filter bits
        pub type FB8_R = crate::BitReader;
        ///Field `FB8` writer - Filter bits
        pub type FB8_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB9` reader - Filter bits
        pub type FB9_R = crate::BitReader;
        ///Field `FB9` writer - Filter bits
        pub type FB9_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB10` reader - Filter bits
        pub type FB10_R = crate::BitReader;
        ///Field `FB10` writer - Filter bits
        pub type FB10_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB11` reader - Filter bits
        pub type FB11_R = crate::BitReader;
        ///Field `FB11` writer - Filter bits
        pub type FB11_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB12` reader - Filter bits
        pub type FB12_R = crate::BitReader;
        ///Field `FB12` writer - Filter bits
        pub type FB12_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB13` reader - Filter bits
        pub type FB13_R = crate::BitReader;
        ///Field `FB13` writer - Filter bits
        pub type FB13_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB14` reader - Filter bits
        pub type FB14_R = crate::BitReader;
        ///Field `FB14` writer - Filter bits
        pub type FB14_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB15` reader - Filter bits
        pub type FB15_R = crate::BitReader;
        ///Field `FB15` writer - Filter bits
        pub type FB15_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB16` reader - Filter bits
        pub type FB16_R = crate::BitReader;
        ///Field `FB16` writer - Filter bits
        pub type FB16_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB17` reader - Filter bits
        pub type FB17_R = crate::BitReader;
        ///Field `FB17` writer - Filter bits
        pub type FB17_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB18` reader - Filter bits
        pub type FB18_R = crate::BitReader;
        ///Field `FB18` writer - Filter bits
        pub type FB18_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB19` reader - Filter bits
        pub type FB19_R = crate::BitReader;
        ///Field `FB19` writer - Filter bits
        pub type FB19_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB20` reader - Filter bits
        pub type FB20_R = crate::BitReader;
        ///Field `FB20` writer - Filter bits
        pub type FB20_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB21` reader - Filter bits
        pub type FB21_R = crate::BitReader;
        ///Field `FB21` writer - Filter bits
        pub type FB21_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB22` reader - Filter bits
        pub type FB22_R = crate::BitReader;
        ///Field `FB22` writer - Filter bits
        pub type FB22_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB23` reader - Filter bits
        pub type FB23_R = crate::BitReader;
        ///Field `FB23` writer - Filter bits
        pub type FB23_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB24` reader - Filter bits
        pub type FB24_R = crate::BitReader;
        ///Field `FB24` writer - Filter bits
        pub type FB24_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB25` reader - Filter bits
        pub type FB25_R = crate::BitReader;
        ///Field `FB25` writer - Filter bits
        pub type FB25_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB26` reader - Filter bits
        pub type FB26_R = crate::BitReader;
        ///Field `FB26` writer - Filter bits
        pub type FB26_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB27` reader - Filter bits
        pub type FB27_R = crate::BitReader;
        ///Field `FB27` writer - Filter bits
        pub type FB27_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB28` reader - Filter bits
        pub type FB28_R = crate::BitReader;
        ///Field `FB28` writer - Filter bits
        pub type FB28_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB29` reader - Filter bits
        pub type FB29_R = crate::BitReader;
        ///Field `FB29` writer - Filter bits
        pub type FB29_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB30` reader - Filter bits
        pub type FB30_R = crate::BitReader;
        ///Field `FB30` writer - Filter bits
        pub type FB30_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB31` reader - Filter bits
        pub type FB31_R = crate::BitReader;
        ///Field `FB31` writer - Filter bits
        pub type FB31_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - Filter bits
            #[inline(always)]
            pub fn fb0(&self) -> FB0_R {
                FB0_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Filter bits
            #[inline(always)]
            pub fn fb1(&self) -> FB1_R {
                FB1_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - Filter bits
            #[inline(always)]
            pub fn fb2(&self) -> FB2_R {
                FB2_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - Filter bits
            #[inline(always)]
            pub fn fb3(&self) -> FB3_R {
                FB3_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - Filter bits
            #[inline(always)]
            pub fn fb4(&self) -> FB4_R {
                FB4_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - Filter bits
            #[inline(always)]
            pub fn fb5(&self) -> FB5_R {
                FB5_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - Filter bits
            #[inline(always)]
            pub fn fb6(&self) -> FB6_R {
                FB6_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - Filter bits
            #[inline(always)]
            pub fn fb7(&self) -> FB7_R {
                FB7_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bit 8 - Filter bits
            #[inline(always)]
            pub fn fb8(&self) -> FB8_R {
                FB8_R::new(((self.bits >> 8) & 1) != 0)
            }
            ///Bit 9 - Filter bits
            #[inline(always)]
            pub fn fb9(&self) -> FB9_R {
                FB9_R::new(((self.bits >> 9) & 1) != 0)
            }
            ///Bit 10 - Filter bits
            #[inline(always)]
            pub fn fb10(&self) -> FB10_R {
                FB10_R::new(((self.bits >> 10) & 1) != 0)
            }
            ///Bit 11 - Filter bits
            #[inline(always)]
            pub fn fb11(&self) -> FB11_R {
                FB11_R::new(((self.bits >> 11) & 1) != 0)
            }
            ///Bit 12 - Filter bits
            #[inline(always)]
            pub fn fb12(&self) -> FB12_R {
                FB12_R::new(((self.bits >> 12) & 1) != 0)
            }
            ///Bit 13 - Filter bits
            #[inline(always)]
            pub fn fb13(&self) -> FB13_R {
                FB13_R::new(((self.bits >> 13) & 1) != 0)
            }
            ///Bit 14 - Filter bits
            #[inline(always)]
            pub fn fb14(&self) -> FB14_R {
                FB14_R::new(((self.bits >> 14) & 1) != 0)
            }
            ///Bit 15 - Filter bits
            #[inline(always)]
            pub fn fb15(&self) -> FB15_R {
                FB15_R::new(((self.bits >> 15) & 1) != 0)
            }
            ///Bit 16 - Filter bits
            #[inline(always)]
            pub fn fb16(&self) -> FB16_R {
                FB16_R::new(((self.bits >> 16) & 1) != 0)
            }
            ///Bit 17 - Filter bits
            #[inline(always)]
            pub fn fb17(&self) -> FB17_R {
                FB17_R::new(((self.bits >> 17) & 1) != 0)
            }
            ///Bit 18 - Filter bits
            #[inline(always)]
            pub fn fb18(&self) -> FB18_R {
                FB18_R::new(((self.bits >> 18) & 1) != 0)
            }
            ///Bit 19 - Filter bits
            #[inline(always)]
            pub fn fb19(&self) -> FB19_R {
                FB19_R::new(((self.bits >> 19) & 1) != 0)
            }
            ///Bit 20 - Filter bits
            #[inline(always)]
            pub fn fb20(&self) -> FB20_R {
                FB20_R::new(((self.bits >> 20) & 1) != 0)
            }
            ///Bit 21 - Filter bits
            #[inline(always)]
            pub fn fb21(&self) -> FB21_R {
                FB21_R::new(((self.bits >> 21) & 1) != 0)
            }
            ///Bit 22 - Filter bits
            #[inline(always)]
            pub fn fb22(&self) -> FB22_R {
                FB22_R::new(((self.bits >> 22) & 1) != 0)
            }
            ///Bit 23 - Filter bits
            #[inline(always)]
            pub fn fb23(&self) -> FB23_R {
                FB23_R::new(((self.bits >> 23) & 1) != 0)
            }
            ///Bit 24 - Filter bits
            #[inline(always)]
            pub fn fb24(&self) -> FB24_R {
                FB24_R::new(((self.bits >> 24) & 1) != 0)
            }
            ///Bit 25 - Filter bits
            #[inline(always)]
            pub fn fb25(&self) -> FB25_R {
                FB25_R::new(((self.bits >> 25) & 1) != 0)
            }
            ///Bit 26 - Filter bits
            #[inline(always)]
            pub fn fb26(&self) -> FB26_R {
                FB26_R::new(((self.bits >> 26) & 1) != 0)
            }
            ///Bit 27 - Filter bits
            #[inline(always)]
            pub fn fb27(&self) -> FB27_R {
                FB27_R::new(((self.bits >> 27) & 1) != 0)
            }
            ///Bit 28 - Filter bits
            #[inline(always)]
            pub fn fb28(&self) -> FB28_R {
                FB28_R::new(((self.bits >> 28) & 1) != 0)
            }
            ///Bit 29 - Filter bits
            #[inline(always)]
            pub fn fb29(&self) -> FB29_R {
                FB29_R::new(((self.bits >> 29) & 1) != 0)
            }
            ///Bit 30 - Filter bits
            #[inline(always)]
            pub fn fb30(&self) -> FB30_R {
                FB30_R::new(((self.bits >> 30) & 1) != 0)
            }
            ///Bit 31 - Filter bits
            #[inline(always)]
            pub fn fb31(&self) -> FB31_R {
                FB31_R::new(((self.bits >> 31) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb0(&mut self) -> FB0_W<F5R1_SPEC> {
                FB0_W::new(self, 0)
            }
            ///Bit 1 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb1(&mut self) -> FB1_W<F5R1_SPEC> {
                FB1_W::new(self, 1)
            }
            ///Bit 2 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb2(&mut self) -> FB2_W<F5R1_SPEC> {
                FB2_W::new(self, 2)
            }
            ///Bit 3 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb3(&mut self) -> FB3_W<F5R1_SPEC> {
                FB3_W::new(self, 3)
            }
            ///Bit 4 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb4(&mut self) -> FB4_W<F5R1_SPEC> {
                FB4_W::new(self, 4)
            }
            ///Bit 5 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb5(&mut self) -> FB5_W<F5R1_SPEC> {
                FB5_W::new(self, 5)
            }
            ///Bit 6 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb6(&mut self) -> FB6_W<F5R1_SPEC> {
                FB6_W::new(self, 6)
            }
            ///Bit 7 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb7(&mut self) -> FB7_W<F5R1_SPEC> {
                FB7_W::new(self, 7)
            }
            ///Bit 8 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb8(&mut self) -> FB8_W<F5R1_SPEC> {
                FB8_W::new(self, 8)
            }
            ///Bit 9 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb9(&mut self) -> FB9_W<F5R1_SPEC> {
                FB9_W::new(self, 9)
            }
            ///Bit 10 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb10(&mut self) -> FB10_W<F5R1_SPEC> {
                FB10_W::new(self, 10)
            }
            ///Bit 11 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb11(&mut self) -> FB11_W<F5R1_SPEC> {
                FB11_W::new(self, 11)
            }
            ///Bit 12 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb12(&mut self) -> FB12_W<F5R1_SPEC> {
                FB12_W::new(self, 12)
            }
            ///Bit 13 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb13(&mut self) -> FB13_W<F5R1_SPEC> {
                FB13_W::new(self, 13)
            }
            ///Bit 14 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb14(&mut self) -> FB14_W<F5R1_SPEC> {
                FB14_W::new(self, 14)
            }
            ///Bit 15 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb15(&mut self) -> FB15_W<F5R1_SPEC> {
                FB15_W::new(self, 15)
            }
            ///Bit 16 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb16(&mut self) -> FB16_W<F5R1_SPEC> {
                FB16_W::new(self, 16)
            }
            ///Bit 17 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb17(&mut self) -> FB17_W<F5R1_SPEC> {
                FB17_W::new(self, 17)
            }
            ///Bit 18 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb18(&mut self) -> FB18_W<F5R1_SPEC> {
                FB18_W::new(self, 18)
            }
            ///Bit 19 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb19(&mut self) -> FB19_W<F5R1_SPEC> {
                FB19_W::new(self, 19)
            }
            ///Bit 20 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb20(&mut self) -> FB20_W<F5R1_SPEC> {
                FB20_W::new(self, 20)
            }
            ///Bit 21 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb21(&mut self) -> FB21_W<F5R1_SPEC> {
                FB21_W::new(self, 21)
            }
            ///Bit 22 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb22(&mut self) -> FB22_W<F5R1_SPEC> {
                FB22_W::new(self, 22)
            }
            ///Bit 23 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb23(&mut self) -> FB23_W<F5R1_SPEC> {
                FB23_W::new(self, 23)
            }
            ///Bit 24 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb24(&mut self) -> FB24_W<F5R1_SPEC> {
                FB24_W::new(self, 24)
            }
            ///Bit 25 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb25(&mut self) -> FB25_W<F5R1_SPEC> {
                FB25_W::new(self, 25)
            }
            ///Bit 26 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb26(&mut self) -> FB26_W<F5R1_SPEC> {
                FB26_W::new(self, 26)
            }
            ///Bit 27 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb27(&mut self) -> FB27_W<F5R1_SPEC> {
                FB27_W::new(self, 27)
            }
            ///Bit 28 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb28(&mut self) -> FB28_W<F5R1_SPEC> {
                FB28_W::new(self, 28)
            }
            ///Bit 29 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb29(&mut self) -> FB29_W<F5R1_SPEC> {
                FB29_W::new(self, 29)
            }
            ///Bit 30 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb30(&mut self) -> FB30_W<F5R1_SPEC> {
                FB30_W::new(self, 30)
            }
            ///Bit 31 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb31(&mut self) -> FB31_W<F5R1_SPEC> {
                FB31_W::new(self, 31)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Filter bank 5 register 1
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`f5r1::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`f5r1::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct F5R1_SPEC;
        impl crate::RegisterSpec for F5R1_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`f5r1::R`](R) reader structure
        impl crate::Readable for F5R1_SPEC {}
        ///`write(|w| ..)` method takes [`f5r1::W`](W) writer structure
        impl crate::Writable for F5R1_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets F5R1 to value 0
        impl crate::Resettable for F5R1_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///F5R2 (rw) register accessor: Filter bank 5 register 2
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`f5r2::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`f5r2::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@f5r2`]
    ///module
    pub type F5R2 = crate::Reg<f5r2::F5R2_SPEC>;
    ///Filter bank 5 register 2
    pub mod f5r2 {
        ///Register `F5R2` reader
        pub type R = crate::R<F5R2_SPEC>;
        ///Register `F5R2` writer
        pub type W = crate::W<F5R2_SPEC>;
        ///Field `FB0` reader - Filter bits
        pub type FB0_R = crate::BitReader;
        ///Field `FB0` writer - Filter bits
        pub type FB0_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB1` reader - Filter bits
        pub type FB1_R = crate::BitReader;
        ///Field `FB1` writer - Filter bits
        pub type FB1_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB2` reader - Filter bits
        pub type FB2_R = crate::BitReader;
        ///Field `FB2` writer - Filter bits
        pub type FB2_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB3` reader - Filter bits
        pub type FB3_R = crate::BitReader;
        ///Field `FB3` writer - Filter bits
        pub type FB3_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB4` reader - Filter bits
        pub type FB4_R = crate::BitReader;
        ///Field `FB4` writer - Filter bits
        pub type FB4_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB5` reader - Filter bits
        pub type FB5_R = crate::BitReader;
        ///Field `FB5` writer - Filter bits
        pub type FB5_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB6` reader - Filter bits
        pub type FB6_R = crate::BitReader;
        ///Field `FB6` writer - Filter bits
        pub type FB6_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB7` reader - Filter bits
        pub type FB7_R = crate::BitReader;
        ///Field `FB7` writer - Filter bits
        pub type FB7_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB8` reader - Filter bits
        pub type FB8_R = crate::BitReader;
        ///Field `FB8` writer - Filter bits
        pub type FB8_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB9` reader - Filter bits
        pub type FB9_R = crate::BitReader;
        ///Field `FB9` writer - Filter bits
        pub type FB9_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB10` reader - Filter bits
        pub type FB10_R = crate::BitReader;
        ///Field `FB10` writer - Filter bits
        pub type FB10_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB11` reader - Filter bits
        pub type FB11_R = crate::BitReader;
        ///Field `FB11` writer - Filter bits
        pub type FB11_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB12` reader - Filter bits
        pub type FB12_R = crate::BitReader;
        ///Field `FB12` writer - Filter bits
        pub type FB12_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB13` reader - Filter bits
        pub type FB13_R = crate::BitReader;
        ///Field `FB13` writer - Filter bits
        pub type FB13_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB14` reader - Filter bits
        pub type FB14_R = crate::BitReader;
        ///Field `FB14` writer - Filter bits
        pub type FB14_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB15` reader - Filter bits
        pub type FB15_R = crate::BitReader;
        ///Field `FB15` writer - Filter bits
        pub type FB15_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB16` reader - Filter bits
        pub type FB16_R = crate::BitReader;
        ///Field `FB16` writer - Filter bits
        pub type FB16_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB17` reader - Filter bits
        pub type FB17_R = crate::BitReader;
        ///Field `FB17` writer - Filter bits
        pub type FB17_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB18` reader - Filter bits
        pub type FB18_R = crate::BitReader;
        ///Field `FB18` writer - Filter bits
        pub type FB18_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB19` reader - Filter bits
        pub type FB19_R = crate::BitReader;
        ///Field `FB19` writer - Filter bits
        pub type FB19_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB20` reader - Filter bits
        pub type FB20_R = crate::BitReader;
        ///Field `FB20` writer - Filter bits
        pub type FB20_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB21` reader - Filter bits
        pub type FB21_R = crate::BitReader;
        ///Field `FB21` writer - Filter bits
        pub type FB21_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB22` reader - Filter bits
        pub type FB22_R = crate::BitReader;
        ///Field `FB22` writer - Filter bits
        pub type FB22_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB23` reader - Filter bits
        pub type FB23_R = crate::BitReader;
        ///Field `FB23` writer - Filter bits
        pub type FB23_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB24` reader - Filter bits
        pub type FB24_R = crate::BitReader;
        ///Field `FB24` writer - Filter bits
        pub type FB24_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB25` reader - Filter bits
        pub type FB25_R = crate::BitReader;
        ///Field `FB25` writer - Filter bits
        pub type FB25_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB26` reader - Filter bits
        pub type FB26_R = crate::BitReader;
        ///Field `FB26` writer - Filter bits
        pub type FB26_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB27` reader - Filter bits
        pub type FB27_R = crate::BitReader;
        ///Field `FB27` writer - Filter bits
        pub type FB27_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB28` reader - Filter bits
        pub type FB28_R = crate::BitReader;
        ///Field `FB28` writer - Filter bits
        pub type FB28_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB29` reader - Filter bits
        pub type FB29_R = crate::BitReader;
        ///Field `FB29` writer - Filter bits
        pub type FB29_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB30` reader - Filter bits
        pub type FB30_R = crate::BitReader;
        ///Field `FB30` writer - Filter bits
        pub type FB30_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB31` reader - Filter bits
        pub type FB31_R = crate::BitReader;
        ///Field `FB31` writer - Filter bits
        pub type FB31_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - Filter bits
            #[inline(always)]
            pub fn fb0(&self) -> FB0_R {
                FB0_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Filter bits
            #[inline(always)]
            pub fn fb1(&self) -> FB1_R {
                FB1_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - Filter bits
            #[inline(always)]
            pub fn fb2(&self) -> FB2_R {
                FB2_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - Filter bits
            #[inline(always)]
            pub fn fb3(&self) -> FB3_R {
                FB3_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - Filter bits
            #[inline(always)]
            pub fn fb4(&self) -> FB4_R {
                FB4_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - Filter bits
            #[inline(always)]
            pub fn fb5(&self) -> FB5_R {
                FB5_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - Filter bits
            #[inline(always)]
            pub fn fb6(&self) -> FB6_R {
                FB6_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - Filter bits
            #[inline(always)]
            pub fn fb7(&self) -> FB7_R {
                FB7_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bit 8 - Filter bits
            #[inline(always)]
            pub fn fb8(&self) -> FB8_R {
                FB8_R::new(((self.bits >> 8) & 1) != 0)
            }
            ///Bit 9 - Filter bits
            #[inline(always)]
            pub fn fb9(&self) -> FB9_R {
                FB9_R::new(((self.bits >> 9) & 1) != 0)
            }
            ///Bit 10 - Filter bits
            #[inline(always)]
            pub fn fb10(&self) -> FB10_R {
                FB10_R::new(((self.bits >> 10) & 1) != 0)
            }
            ///Bit 11 - Filter bits
            #[inline(always)]
            pub fn fb11(&self) -> FB11_R {
                FB11_R::new(((self.bits >> 11) & 1) != 0)
            }
            ///Bit 12 - Filter bits
            #[inline(always)]
            pub fn fb12(&self) -> FB12_R {
                FB12_R::new(((self.bits >> 12) & 1) != 0)
            }
            ///Bit 13 - Filter bits
            #[inline(always)]
            pub fn fb13(&self) -> FB13_R {
                FB13_R::new(((self.bits >> 13) & 1) != 0)
            }
            ///Bit 14 - Filter bits
            #[inline(always)]
            pub fn fb14(&self) -> FB14_R {
                FB14_R::new(((self.bits >> 14) & 1) != 0)
            }
            ///Bit 15 - Filter bits
            #[inline(always)]
            pub fn fb15(&self) -> FB15_R {
                FB15_R::new(((self.bits >> 15) & 1) != 0)
            }
            ///Bit 16 - Filter bits
            #[inline(always)]
            pub fn fb16(&self) -> FB16_R {
                FB16_R::new(((self.bits >> 16) & 1) != 0)
            }
            ///Bit 17 - Filter bits
            #[inline(always)]
            pub fn fb17(&self) -> FB17_R {
                FB17_R::new(((self.bits >> 17) & 1) != 0)
            }
            ///Bit 18 - Filter bits
            #[inline(always)]
            pub fn fb18(&self) -> FB18_R {
                FB18_R::new(((self.bits >> 18) & 1) != 0)
            }
            ///Bit 19 - Filter bits
            #[inline(always)]
            pub fn fb19(&self) -> FB19_R {
                FB19_R::new(((self.bits >> 19) & 1) != 0)
            }
            ///Bit 20 - Filter bits
            #[inline(always)]
            pub fn fb20(&self) -> FB20_R {
                FB20_R::new(((self.bits >> 20) & 1) != 0)
            }
            ///Bit 21 - Filter bits
            #[inline(always)]
            pub fn fb21(&self) -> FB21_R {
                FB21_R::new(((self.bits >> 21) & 1) != 0)
            }
            ///Bit 22 - Filter bits
            #[inline(always)]
            pub fn fb22(&self) -> FB22_R {
                FB22_R::new(((self.bits >> 22) & 1) != 0)
            }
            ///Bit 23 - Filter bits
            #[inline(always)]
            pub fn fb23(&self) -> FB23_R {
                FB23_R::new(((self.bits >> 23) & 1) != 0)
            }
            ///Bit 24 - Filter bits
            #[inline(always)]
            pub fn fb24(&self) -> FB24_R {
                FB24_R::new(((self.bits >> 24) & 1) != 0)
            }
            ///Bit 25 - Filter bits
            #[inline(always)]
            pub fn fb25(&self) -> FB25_R {
                FB25_R::new(((self.bits >> 25) & 1) != 0)
            }
            ///Bit 26 - Filter bits
            #[inline(always)]
            pub fn fb26(&self) -> FB26_R {
                FB26_R::new(((self.bits >> 26) & 1) != 0)
            }
            ///Bit 27 - Filter bits
            #[inline(always)]
            pub fn fb27(&self) -> FB27_R {
                FB27_R::new(((self.bits >> 27) & 1) != 0)
            }
            ///Bit 28 - Filter bits
            #[inline(always)]
            pub fn fb28(&self) -> FB28_R {
                FB28_R::new(((self.bits >> 28) & 1) != 0)
            }
            ///Bit 29 - Filter bits
            #[inline(always)]
            pub fn fb29(&self) -> FB29_R {
                FB29_R::new(((self.bits >> 29) & 1) != 0)
            }
            ///Bit 30 - Filter bits
            #[inline(always)]
            pub fn fb30(&self) -> FB30_R {
                FB30_R::new(((self.bits >> 30) & 1) != 0)
            }
            ///Bit 31 - Filter bits
            #[inline(always)]
            pub fn fb31(&self) -> FB31_R {
                FB31_R::new(((self.bits >> 31) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb0(&mut self) -> FB0_W<F5R2_SPEC> {
                FB0_W::new(self, 0)
            }
            ///Bit 1 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb1(&mut self) -> FB1_W<F5R2_SPEC> {
                FB1_W::new(self, 1)
            }
            ///Bit 2 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb2(&mut self) -> FB2_W<F5R2_SPEC> {
                FB2_W::new(self, 2)
            }
            ///Bit 3 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb3(&mut self) -> FB3_W<F5R2_SPEC> {
                FB3_W::new(self, 3)
            }
            ///Bit 4 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb4(&mut self) -> FB4_W<F5R2_SPEC> {
                FB4_W::new(self, 4)
            }
            ///Bit 5 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb5(&mut self) -> FB5_W<F5R2_SPEC> {
                FB5_W::new(self, 5)
            }
            ///Bit 6 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb6(&mut self) -> FB6_W<F5R2_SPEC> {
                FB6_W::new(self, 6)
            }
            ///Bit 7 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb7(&mut self) -> FB7_W<F5R2_SPEC> {
                FB7_W::new(self, 7)
            }
            ///Bit 8 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb8(&mut self) -> FB8_W<F5R2_SPEC> {
                FB8_W::new(self, 8)
            }
            ///Bit 9 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb9(&mut self) -> FB9_W<F5R2_SPEC> {
                FB9_W::new(self, 9)
            }
            ///Bit 10 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb10(&mut self) -> FB10_W<F5R2_SPEC> {
                FB10_W::new(self, 10)
            }
            ///Bit 11 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb11(&mut self) -> FB11_W<F5R2_SPEC> {
                FB11_W::new(self, 11)
            }
            ///Bit 12 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb12(&mut self) -> FB12_W<F5R2_SPEC> {
                FB12_W::new(self, 12)
            }
            ///Bit 13 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb13(&mut self) -> FB13_W<F5R2_SPEC> {
                FB13_W::new(self, 13)
            }
            ///Bit 14 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb14(&mut self) -> FB14_W<F5R2_SPEC> {
                FB14_W::new(self, 14)
            }
            ///Bit 15 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb15(&mut self) -> FB15_W<F5R2_SPEC> {
                FB15_W::new(self, 15)
            }
            ///Bit 16 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb16(&mut self) -> FB16_W<F5R2_SPEC> {
                FB16_W::new(self, 16)
            }
            ///Bit 17 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb17(&mut self) -> FB17_W<F5R2_SPEC> {
                FB17_W::new(self, 17)
            }
            ///Bit 18 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb18(&mut self) -> FB18_W<F5R2_SPEC> {
                FB18_W::new(self, 18)
            }
            ///Bit 19 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb19(&mut self) -> FB19_W<F5R2_SPEC> {
                FB19_W::new(self, 19)
            }
            ///Bit 20 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb20(&mut self) -> FB20_W<F5R2_SPEC> {
                FB20_W::new(self, 20)
            }
            ///Bit 21 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb21(&mut self) -> FB21_W<F5R2_SPEC> {
                FB21_W::new(self, 21)
            }
            ///Bit 22 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb22(&mut self) -> FB22_W<F5R2_SPEC> {
                FB22_W::new(self, 22)
            }
            ///Bit 23 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb23(&mut self) -> FB23_W<F5R2_SPEC> {
                FB23_W::new(self, 23)
            }
            ///Bit 24 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb24(&mut self) -> FB24_W<F5R2_SPEC> {
                FB24_W::new(self, 24)
            }
            ///Bit 25 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb25(&mut self) -> FB25_W<F5R2_SPEC> {
                FB25_W::new(self, 25)
            }
            ///Bit 26 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb26(&mut self) -> FB26_W<F5R2_SPEC> {
                FB26_W::new(self, 26)
            }
            ///Bit 27 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb27(&mut self) -> FB27_W<F5R2_SPEC> {
                FB27_W::new(self, 27)
            }
            ///Bit 28 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb28(&mut self) -> FB28_W<F5R2_SPEC> {
                FB28_W::new(self, 28)
            }
            ///Bit 29 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb29(&mut self) -> FB29_W<F5R2_SPEC> {
                FB29_W::new(self, 29)
            }
            ///Bit 30 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb30(&mut self) -> FB30_W<F5R2_SPEC> {
                FB30_W::new(self, 30)
            }
            ///Bit 31 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb31(&mut self) -> FB31_W<F5R2_SPEC> {
                FB31_W::new(self, 31)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Filter bank 5 register 2
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`f5r2::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`f5r2::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct F5R2_SPEC;
        impl crate::RegisterSpec for F5R2_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`f5r2::R`](R) reader structure
        impl crate::Readable for F5R2_SPEC {}
        ///`write(|w| ..)` method takes [`f5r2::W`](W) writer structure
        impl crate::Writable for F5R2_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets F5R2 to value 0
        impl crate::Resettable for F5R2_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///F6R1 (rw) register accessor: Filter bank 6 register 1
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`f6r1::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`f6r1::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@f6r1`]
    ///module
    pub type F6R1 = crate::Reg<f6r1::F6R1_SPEC>;
    ///Filter bank 6 register 1
    pub mod f6r1 {
        ///Register `F6R1` reader
        pub type R = crate::R<F6R1_SPEC>;
        ///Register `F6R1` writer
        pub type W = crate::W<F6R1_SPEC>;
        ///Field `FB0` reader - Filter bits
        pub type FB0_R = crate::BitReader;
        ///Field `FB0` writer - Filter bits
        pub type FB0_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB1` reader - Filter bits
        pub type FB1_R = crate::BitReader;
        ///Field `FB1` writer - Filter bits
        pub type FB1_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB2` reader - Filter bits
        pub type FB2_R = crate::BitReader;
        ///Field `FB2` writer - Filter bits
        pub type FB2_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB3` reader - Filter bits
        pub type FB3_R = crate::BitReader;
        ///Field `FB3` writer - Filter bits
        pub type FB3_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB4` reader - Filter bits
        pub type FB4_R = crate::BitReader;
        ///Field `FB4` writer - Filter bits
        pub type FB4_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB5` reader - Filter bits
        pub type FB5_R = crate::BitReader;
        ///Field `FB5` writer - Filter bits
        pub type FB5_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB6` reader - Filter bits
        pub type FB6_R = crate::BitReader;
        ///Field `FB6` writer - Filter bits
        pub type FB6_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB7` reader - Filter bits
        pub type FB7_R = crate::BitReader;
        ///Field `FB7` writer - Filter bits
        pub type FB7_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB8` reader - Filter bits
        pub type FB8_R = crate::BitReader;
        ///Field `FB8` writer - Filter bits
        pub type FB8_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB9` reader - Filter bits
        pub type FB9_R = crate::BitReader;
        ///Field `FB9` writer - Filter bits
        pub type FB9_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB10` reader - Filter bits
        pub type FB10_R = crate::BitReader;
        ///Field `FB10` writer - Filter bits
        pub type FB10_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB11` reader - Filter bits
        pub type FB11_R = crate::BitReader;
        ///Field `FB11` writer - Filter bits
        pub type FB11_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB12` reader - Filter bits
        pub type FB12_R = crate::BitReader;
        ///Field `FB12` writer - Filter bits
        pub type FB12_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB13` reader - Filter bits
        pub type FB13_R = crate::BitReader;
        ///Field `FB13` writer - Filter bits
        pub type FB13_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB14` reader - Filter bits
        pub type FB14_R = crate::BitReader;
        ///Field `FB14` writer - Filter bits
        pub type FB14_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB15` reader - Filter bits
        pub type FB15_R = crate::BitReader;
        ///Field `FB15` writer - Filter bits
        pub type FB15_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB16` reader - Filter bits
        pub type FB16_R = crate::BitReader;
        ///Field `FB16` writer - Filter bits
        pub type FB16_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB17` reader - Filter bits
        pub type FB17_R = crate::BitReader;
        ///Field `FB17` writer - Filter bits
        pub type FB17_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB18` reader - Filter bits
        pub type FB18_R = crate::BitReader;
        ///Field `FB18` writer - Filter bits
        pub type FB18_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB19` reader - Filter bits
        pub type FB19_R = crate::BitReader;
        ///Field `FB19` writer - Filter bits
        pub type FB19_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB20` reader - Filter bits
        pub type FB20_R = crate::BitReader;
        ///Field `FB20` writer - Filter bits
        pub type FB20_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB21` reader - Filter bits
        pub type FB21_R = crate::BitReader;
        ///Field `FB21` writer - Filter bits
        pub type FB21_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB22` reader - Filter bits
        pub type FB22_R = crate::BitReader;
        ///Field `FB22` writer - Filter bits
        pub type FB22_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB23` reader - Filter bits
        pub type FB23_R = crate::BitReader;
        ///Field `FB23` writer - Filter bits
        pub type FB23_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB24` reader - Filter bits
        pub type FB24_R = crate::BitReader;
        ///Field `FB24` writer - Filter bits
        pub type FB24_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB25` reader - Filter bits
        pub type FB25_R = crate::BitReader;
        ///Field `FB25` writer - Filter bits
        pub type FB25_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB26` reader - Filter bits
        pub type FB26_R = crate::BitReader;
        ///Field `FB26` writer - Filter bits
        pub type FB26_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB27` reader - Filter bits
        pub type FB27_R = crate::BitReader;
        ///Field `FB27` writer - Filter bits
        pub type FB27_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB28` reader - Filter bits
        pub type FB28_R = crate::BitReader;
        ///Field `FB28` writer - Filter bits
        pub type FB28_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB29` reader - Filter bits
        pub type FB29_R = crate::BitReader;
        ///Field `FB29` writer - Filter bits
        pub type FB29_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB30` reader - Filter bits
        pub type FB30_R = crate::BitReader;
        ///Field `FB30` writer - Filter bits
        pub type FB30_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB31` reader - Filter bits
        pub type FB31_R = crate::BitReader;
        ///Field `FB31` writer - Filter bits
        pub type FB31_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - Filter bits
            #[inline(always)]
            pub fn fb0(&self) -> FB0_R {
                FB0_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Filter bits
            #[inline(always)]
            pub fn fb1(&self) -> FB1_R {
                FB1_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - Filter bits
            #[inline(always)]
            pub fn fb2(&self) -> FB2_R {
                FB2_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - Filter bits
            #[inline(always)]
            pub fn fb3(&self) -> FB3_R {
                FB3_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - Filter bits
            #[inline(always)]
            pub fn fb4(&self) -> FB4_R {
                FB4_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - Filter bits
            #[inline(always)]
            pub fn fb5(&self) -> FB5_R {
                FB5_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - Filter bits
            #[inline(always)]
            pub fn fb6(&self) -> FB6_R {
                FB6_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - Filter bits
            #[inline(always)]
            pub fn fb7(&self) -> FB7_R {
                FB7_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bit 8 - Filter bits
            #[inline(always)]
            pub fn fb8(&self) -> FB8_R {
                FB8_R::new(((self.bits >> 8) & 1) != 0)
            }
            ///Bit 9 - Filter bits
            #[inline(always)]
            pub fn fb9(&self) -> FB9_R {
                FB9_R::new(((self.bits >> 9) & 1) != 0)
            }
            ///Bit 10 - Filter bits
            #[inline(always)]
            pub fn fb10(&self) -> FB10_R {
                FB10_R::new(((self.bits >> 10) & 1) != 0)
            }
            ///Bit 11 - Filter bits
            #[inline(always)]
            pub fn fb11(&self) -> FB11_R {
                FB11_R::new(((self.bits >> 11) & 1) != 0)
            }
            ///Bit 12 - Filter bits
            #[inline(always)]
            pub fn fb12(&self) -> FB12_R {
                FB12_R::new(((self.bits >> 12) & 1) != 0)
            }
            ///Bit 13 - Filter bits
            #[inline(always)]
            pub fn fb13(&self) -> FB13_R {
                FB13_R::new(((self.bits >> 13) & 1) != 0)
            }
            ///Bit 14 - Filter bits
            #[inline(always)]
            pub fn fb14(&self) -> FB14_R {
                FB14_R::new(((self.bits >> 14) & 1) != 0)
            }
            ///Bit 15 - Filter bits
            #[inline(always)]
            pub fn fb15(&self) -> FB15_R {
                FB15_R::new(((self.bits >> 15) & 1) != 0)
            }
            ///Bit 16 - Filter bits
            #[inline(always)]
            pub fn fb16(&self) -> FB16_R {
                FB16_R::new(((self.bits >> 16) & 1) != 0)
            }
            ///Bit 17 - Filter bits
            #[inline(always)]
            pub fn fb17(&self) -> FB17_R {
                FB17_R::new(((self.bits >> 17) & 1) != 0)
            }
            ///Bit 18 - Filter bits
            #[inline(always)]
            pub fn fb18(&self) -> FB18_R {
                FB18_R::new(((self.bits >> 18) & 1) != 0)
            }
            ///Bit 19 - Filter bits
            #[inline(always)]
            pub fn fb19(&self) -> FB19_R {
                FB19_R::new(((self.bits >> 19) & 1) != 0)
            }
            ///Bit 20 - Filter bits
            #[inline(always)]
            pub fn fb20(&self) -> FB20_R {
                FB20_R::new(((self.bits >> 20) & 1) != 0)
            }
            ///Bit 21 - Filter bits
            #[inline(always)]
            pub fn fb21(&self) -> FB21_R {
                FB21_R::new(((self.bits >> 21) & 1) != 0)
            }
            ///Bit 22 - Filter bits
            #[inline(always)]
            pub fn fb22(&self) -> FB22_R {
                FB22_R::new(((self.bits >> 22) & 1) != 0)
            }
            ///Bit 23 - Filter bits
            #[inline(always)]
            pub fn fb23(&self) -> FB23_R {
                FB23_R::new(((self.bits >> 23) & 1) != 0)
            }
            ///Bit 24 - Filter bits
            #[inline(always)]
            pub fn fb24(&self) -> FB24_R {
                FB24_R::new(((self.bits >> 24) & 1) != 0)
            }
            ///Bit 25 - Filter bits
            #[inline(always)]
            pub fn fb25(&self) -> FB25_R {
                FB25_R::new(((self.bits >> 25) & 1) != 0)
            }
            ///Bit 26 - Filter bits
            #[inline(always)]
            pub fn fb26(&self) -> FB26_R {
                FB26_R::new(((self.bits >> 26) & 1) != 0)
            }
            ///Bit 27 - Filter bits
            #[inline(always)]
            pub fn fb27(&self) -> FB27_R {
                FB27_R::new(((self.bits >> 27) & 1) != 0)
            }
            ///Bit 28 - Filter bits
            #[inline(always)]
            pub fn fb28(&self) -> FB28_R {
                FB28_R::new(((self.bits >> 28) & 1) != 0)
            }
            ///Bit 29 - Filter bits
            #[inline(always)]
            pub fn fb29(&self) -> FB29_R {
                FB29_R::new(((self.bits >> 29) & 1) != 0)
            }
            ///Bit 30 - Filter bits
            #[inline(always)]
            pub fn fb30(&self) -> FB30_R {
                FB30_R::new(((self.bits >> 30) & 1) != 0)
            }
            ///Bit 31 - Filter bits
            #[inline(always)]
            pub fn fb31(&self) -> FB31_R {
                FB31_R::new(((self.bits >> 31) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb0(&mut self) -> FB0_W<F6R1_SPEC> {
                FB0_W::new(self, 0)
            }
            ///Bit 1 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb1(&mut self) -> FB1_W<F6R1_SPEC> {
                FB1_W::new(self, 1)
            }
            ///Bit 2 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb2(&mut self) -> FB2_W<F6R1_SPEC> {
                FB2_W::new(self, 2)
            }
            ///Bit 3 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb3(&mut self) -> FB3_W<F6R1_SPEC> {
                FB3_W::new(self, 3)
            }
            ///Bit 4 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb4(&mut self) -> FB4_W<F6R1_SPEC> {
                FB4_W::new(self, 4)
            }
            ///Bit 5 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb5(&mut self) -> FB5_W<F6R1_SPEC> {
                FB5_W::new(self, 5)
            }
            ///Bit 6 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb6(&mut self) -> FB6_W<F6R1_SPEC> {
                FB6_W::new(self, 6)
            }
            ///Bit 7 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb7(&mut self) -> FB7_W<F6R1_SPEC> {
                FB7_W::new(self, 7)
            }
            ///Bit 8 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb8(&mut self) -> FB8_W<F6R1_SPEC> {
                FB8_W::new(self, 8)
            }
            ///Bit 9 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb9(&mut self) -> FB9_W<F6R1_SPEC> {
                FB9_W::new(self, 9)
            }
            ///Bit 10 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb10(&mut self) -> FB10_W<F6R1_SPEC> {
                FB10_W::new(self, 10)
            }
            ///Bit 11 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb11(&mut self) -> FB11_W<F6R1_SPEC> {
                FB11_W::new(self, 11)
            }
            ///Bit 12 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb12(&mut self) -> FB12_W<F6R1_SPEC> {
                FB12_W::new(self, 12)
            }
            ///Bit 13 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb13(&mut self) -> FB13_W<F6R1_SPEC> {
                FB13_W::new(self, 13)
            }
            ///Bit 14 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb14(&mut self) -> FB14_W<F6R1_SPEC> {
                FB14_W::new(self, 14)
            }
            ///Bit 15 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb15(&mut self) -> FB15_W<F6R1_SPEC> {
                FB15_W::new(self, 15)
            }
            ///Bit 16 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb16(&mut self) -> FB16_W<F6R1_SPEC> {
                FB16_W::new(self, 16)
            }
            ///Bit 17 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb17(&mut self) -> FB17_W<F6R1_SPEC> {
                FB17_W::new(self, 17)
            }
            ///Bit 18 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb18(&mut self) -> FB18_W<F6R1_SPEC> {
                FB18_W::new(self, 18)
            }
            ///Bit 19 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb19(&mut self) -> FB19_W<F6R1_SPEC> {
                FB19_W::new(self, 19)
            }
            ///Bit 20 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb20(&mut self) -> FB20_W<F6R1_SPEC> {
                FB20_W::new(self, 20)
            }
            ///Bit 21 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb21(&mut self) -> FB21_W<F6R1_SPEC> {
                FB21_W::new(self, 21)
            }
            ///Bit 22 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb22(&mut self) -> FB22_W<F6R1_SPEC> {
                FB22_W::new(self, 22)
            }
            ///Bit 23 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb23(&mut self) -> FB23_W<F6R1_SPEC> {
                FB23_W::new(self, 23)
            }
            ///Bit 24 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb24(&mut self) -> FB24_W<F6R1_SPEC> {
                FB24_W::new(self, 24)
            }
            ///Bit 25 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb25(&mut self) -> FB25_W<F6R1_SPEC> {
                FB25_W::new(self, 25)
            }
            ///Bit 26 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb26(&mut self) -> FB26_W<F6R1_SPEC> {
                FB26_W::new(self, 26)
            }
            ///Bit 27 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb27(&mut self) -> FB27_W<F6R1_SPEC> {
                FB27_W::new(self, 27)
            }
            ///Bit 28 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb28(&mut self) -> FB28_W<F6R1_SPEC> {
                FB28_W::new(self, 28)
            }
            ///Bit 29 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb29(&mut self) -> FB29_W<F6R1_SPEC> {
                FB29_W::new(self, 29)
            }
            ///Bit 30 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb30(&mut self) -> FB30_W<F6R1_SPEC> {
                FB30_W::new(self, 30)
            }
            ///Bit 31 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb31(&mut self) -> FB31_W<F6R1_SPEC> {
                FB31_W::new(self, 31)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Filter bank 6 register 1
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`f6r1::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`f6r1::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct F6R1_SPEC;
        impl crate::RegisterSpec for F6R1_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`f6r1::R`](R) reader structure
        impl crate::Readable for F6R1_SPEC {}
        ///`write(|w| ..)` method takes [`f6r1::W`](W) writer structure
        impl crate::Writable for F6R1_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets F6R1 to value 0
        impl crate::Resettable for F6R1_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///F6R2 (rw) register accessor: Filter bank 6 register 2
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`f6r2::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`f6r2::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@f6r2`]
    ///module
    pub type F6R2 = crate::Reg<f6r2::F6R2_SPEC>;
    ///Filter bank 6 register 2
    pub mod f6r2 {
        ///Register `F6R2` reader
        pub type R = crate::R<F6R2_SPEC>;
        ///Register `F6R2` writer
        pub type W = crate::W<F6R2_SPEC>;
        ///Field `FB0` reader - Filter bits
        pub type FB0_R = crate::BitReader;
        ///Field `FB0` writer - Filter bits
        pub type FB0_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB1` reader - Filter bits
        pub type FB1_R = crate::BitReader;
        ///Field `FB1` writer - Filter bits
        pub type FB1_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB2` reader - Filter bits
        pub type FB2_R = crate::BitReader;
        ///Field `FB2` writer - Filter bits
        pub type FB2_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB3` reader - Filter bits
        pub type FB3_R = crate::BitReader;
        ///Field `FB3` writer - Filter bits
        pub type FB3_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB4` reader - Filter bits
        pub type FB4_R = crate::BitReader;
        ///Field `FB4` writer - Filter bits
        pub type FB4_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB5` reader - Filter bits
        pub type FB5_R = crate::BitReader;
        ///Field `FB5` writer - Filter bits
        pub type FB5_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB6` reader - Filter bits
        pub type FB6_R = crate::BitReader;
        ///Field `FB6` writer - Filter bits
        pub type FB6_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB7` reader - Filter bits
        pub type FB7_R = crate::BitReader;
        ///Field `FB7` writer - Filter bits
        pub type FB7_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB8` reader - Filter bits
        pub type FB8_R = crate::BitReader;
        ///Field `FB8` writer - Filter bits
        pub type FB8_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB9` reader - Filter bits
        pub type FB9_R = crate::BitReader;
        ///Field `FB9` writer - Filter bits
        pub type FB9_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB10` reader - Filter bits
        pub type FB10_R = crate::BitReader;
        ///Field `FB10` writer - Filter bits
        pub type FB10_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB11` reader - Filter bits
        pub type FB11_R = crate::BitReader;
        ///Field `FB11` writer - Filter bits
        pub type FB11_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB12` reader - Filter bits
        pub type FB12_R = crate::BitReader;
        ///Field `FB12` writer - Filter bits
        pub type FB12_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB13` reader - Filter bits
        pub type FB13_R = crate::BitReader;
        ///Field `FB13` writer - Filter bits
        pub type FB13_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB14` reader - Filter bits
        pub type FB14_R = crate::BitReader;
        ///Field `FB14` writer - Filter bits
        pub type FB14_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB15` reader - Filter bits
        pub type FB15_R = crate::BitReader;
        ///Field `FB15` writer - Filter bits
        pub type FB15_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB16` reader - Filter bits
        pub type FB16_R = crate::BitReader;
        ///Field `FB16` writer - Filter bits
        pub type FB16_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB17` reader - Filter bits
        pub type FB17_R = crate::BitReader;
        ///Field `FB17` writer - Filter bits
        pub type FB17_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB18` reader - Filter bits
        pub type FB18_R = crate::BitReader;
        ///Field `FB18` writer - Filter bits
        pub type FB18_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB19` reader - Filter bits
        pub type FB19_R = crate::BitReader;
        ///Field `FB19` writer - Filter bits
        pub type FB19_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB20` reader - Filter bits
        pub type FB20_R = crate::BitReader;
        ///Field `FB20` writer - Filter bits
        pub type FB20_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB21` reader - Filter bits
        pub type FB21_R = crate::BitReader;
        ///Field `FB21` writer - Filter bits
        pub type FB21_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB22` reader - Filter bits
        pub type FB22_R = crate::BitReader;
        ///Field `FB22` writer - Filter bits
        pub type FB22_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB23` reader - Filter bits
        pub type FB23_R = crate::BitReader;
        ///Field `FB23` writer - Filter bits
        pub type FB23_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB24` reader - Filter bits
        pub type FB24_R = crate::BitReader;
        ///Field `FB24` writer - Filter bits
        pub type FB24_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB25` reader - Filter bits
        pub type FB25_R = crate::BitReader;
        ///Field `FB25` writer - Filter bits
        pub type FB25_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB26` reader - Filter bits
        pub type FB26_R = crate::BitReader;
        ///Field `FB26` writer - Filter bits
        pub type FB26_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB27` reader - Filter bits
        pub type FB27_R = crate::BitReader;
        ///Field `FB27` writer - Filter bits
        pub type FB27_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB28` reader - Filter bits
        pub type FB28_R = crate::BitReader;
        ///Field `FB28` writer - Filter bits
        pub type FB28_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB29` reader - Filter bits
        pub type FB29_R = crate::BitReader;
        ///Field `FB29` writer - Filter bits
        pub type FB29_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB30` reader - Filter bits
        pub type FB30_R = crate::BitReader;
        ///Field `FB30` writer - Filter bits
        pub type FB30_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB31` reader - Filter bits
        pub type FB31_R = crate::BitReader;
        ///Field `FB31` writer - Filter bits
        pub type FB31_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - Filter bits
            #[inline(always)]
            pub fn fb0(&self) -> FB0_R {
                FB0_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Filter bits
            #[inline(always)]
            pub fn fb1(&self) -> FB1_R {
                FB1_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - Filter bits
            #[inline(always)]
            pub fn fb2(&self) -> FB2_R {
                FB2_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - Filter bits
            #[inline(always)]
            pub fn fb3(&self) -> FB3_R {
                FB3_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - Filter bits
            #[inline(always)]
            pub fn fb4(&self) -> FB4_R {
                FB4_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - Filter bits
            #[inline(always)]
            pub fn fb5(&self) -> FB5_R {
                FB5_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - Filter bits
            #[inline(always)]
            pub fn fb6(&self) -> FB6_R {
                FB6_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - Filter bits
            #[inline(always)]
            pub fn fb7(&self) -> FB7_R {
                FB7_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bit 8 - Filter bits
            #[inline(always)]
            pub fn fb8(&self) -> FB8_R {
                FB8_R::new(((self.bits >> 8) & 1) != 0)
            }
            ///Bit 9 - Filter bits
            #[inline(always)]
            pub fn fb9(&self) -> FB9_R {
                FB9_R::new(((self.bits >> 9) & 1) != 0)
            }
            ///Bit 10 - Filter bits
            #[inline(always)]
            pub fn fb10(&self) -> FB10_R {
                FB10_R::new(((self.bits >> 10) & 1) != 0)
            }
            ///Bit 11 - Filter bits
            #[inline(always)]
            pub fn fb11(&self) -> FB11_R {
                FB11_R::new(((self.bits >> 11) & 1) != 0)
            }
            ///Bit 12 - Filter bits
            #[inline(always)]
            pub fn fb12(&self) -> FB12_R {
                FB12_R::new(((self.bits >> 12) & 1) != 0)
            }
            ///Bit 13 - Filter bits
            #[inline(always)]
            pub fn fb13(&self) -> FB13_R {
                FB13_R::new(((self.bits >> 13) & 1) != 0)
            }
            ///Bit 14 - Filter bits
            #[inline(always)]
            pub fn fb14(&self) -> FB14_R {
                FB14_R::new(((self.bits >> 14) & 1) != 0)
            }
            ///Bit 15 - Filter bits
            #[inline(always)]
            pub fn fb15(&self) -> FB15_R {
                FB15_R::new(((self.bits >> 15) & 1) != 0)
            }
            ///Bit 16 - Filter bits
            #[inline(always)]
            pub fn fb16(&self) -> FB16_R {
                FB16_R::new(((self.bits >> 16) & 1) != 0)
            }
            ///Bit 17 - Filter bits
            #[inline(always)]
            pub fn fb17(&self) -> FB17_R {
                FB17_R::new(((self.bits >> 17) & 1) != 0)
            }
            ///Bit 18 - Filter bits
            #[inline(always)]
            pub fn fb18(&self) -> FB18_R {
                FB18_R::new(((self.bits >> 18) & 1) != 0)
            }
            ///Bit 19 - Filter bits
            #[inline(always)]
            pub fn fb19(&self) -> FB19_R {
                FB19_R::new(((self.bits >> 19) & 1) != 0)
            }
            ///Bit 20 - Filter bits
            #[inline(always)]
            pub fn fb20(&self) -> FB20_R {
                FB20_R::new(((self.bits >> 20) & 1) != 0)
            }
            ///Bit 21 - Filter bits
            #[inline(always)]
            pub fn fb21(&self) -> FB21_R {
                FB21_R::new(((self.bits >> 21) & 1) != 0)
            }
            ///Bit 22 - Filter bits
            #[inline(always)]
            pub fn fb22(&self) -> FB22_R {
                FB22_R::new(((self.bits >> 22) & 1) != 0)
            }
            ///Bit 23 - Filter bits
            #[inline(always)]
            pub fn fb23(&self) -> FB23_R {
                FB23_R::new(((self.bits >> 23) & 1) != 0)
            }
            ///Bit 24 - Filter bits
            #[inline(always)]
            pub fn fb24(&self) -> FB24_R {
                FB24_R::new(((self.bits >> 24) & 1) != 0)
            }
            ///Bit 25 - Filter bits
            #[inline(always)]
            pub fn fb25(&self) -> FB25_R {
                FB25_R::new(((self.bits >> 25) & 1) != 0)
            }
            ///Bit 26 - Filter bits
            #[inline(always)]
            pub fn fb26(&self) -> FB26_R {
                FB26_R::new(((self.bits >> 26) & 1) != 0)
            }
            ///Bit 27 - Filter bits
            #[inline(always)]
            pub fn fb27(&self) -> FB27_R {
                FB27_R::new(((self.bits >> 27) & 1) != 0)
            }
            ///Bit 28 - Filter bits
            #[inline(always)]
            pub fn fb28(&self) -> FB28_R {
                FB28_R::new(((self.bits >> 28) & 1) != 0)
            }
            ///Bit 29 - Filter bits
            #[inline(always)]
            pub fn fb29(&self) -> FB29_R {
                FB29_R::new(((self.bits >> 29) & 1) != 0)
            }
            ///Bit 30 - Filter bits
            #[inline(always)]
            pub fn fb30(&self) -> FB30_R {
                FB30_R::new(((self.bits >> 30) & 1) != 0)
            }
            ///Bit 31 - Filter bits
            #[inline(always)]
            pub fn fb31(&self) -> FB31_R {
                FB31_R::new(((self.bits >> 31) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb0(&mut self) -> FB0_W<F6R2_SPEC> {
                FB0_W::new(self, 0)
            }
            ///Bit 1 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb1(&mut self) -> FB1_W<F6R2_SPEC> {
                FB1_W::new(self, 1)
            }
            ///Bit 2 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb2(&mut self) -> FB2_W<F6R2_SPEC> {
                FB2_W::new(self, 2)
            }
            ///Bit 3 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb3(&mut self) -> FB3_W<F6R2_SPEC> {
                FB3_W::new(self, 3)
            }
            ///Bit 4 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb4(&mut self) -> FB4_W<F6R2_SPEC> {
                FB4_W::new(self, 4)
            }
            ///Bit 5 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb5(&mut self) -> FB5_W<F6R2_SPEC> {
                FB5_W::new(self, 5)
            }
            ///Bit 6 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb6(&mut self) -> FB6_W<F6R2_SPEC> {
                FB6_W::new(self, 6)
            }
            ///Bit 7 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb7(&mut self) -> FB7_W<F6R2_SPEC> {
                FB7_W::new(self, 7)
            }
            ///Bit 8 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb8(&mut self) -> FB8_W<F6R2_SPEC> {
                FB8_W::new(self, 8)
            }
            ///Bit 9 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb9(&mut self) -> FB9_W<F6R2_SPEC> {
                FB9_W::new(self, 9)
            }
            ///Bit 10 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb10(&mut self) -> FB10_W<F6R2_SPEC> {
                FB10_W::new(self, 10)
            }
            ///Bit 11 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb11(&mut self) -> FB11_W<F6R2_SPEC> {
                FB11_W::new(self, 11)
            }
            ///Bit 12 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb12(&mut self) -> FB12_W<F6R2_SPEC> {
                FB12_W::new(self, 12)
            }
            ///Bit 13 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb13(&mut self) -> FB13_W<F6R2_SPEC> {
                FB13_W::new(self, 13)
            }
            ///Bit 14 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb14(&mut self) -> FB14_W<F6R2_SPEC> {
                FB14_W::new(self, 14)
            }
            ///Bit 15 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb15(&mut self) -> FB15_W<F6R2_SPEC> {
                FB15_W::new(self, 15)
            }
            ///Bit 16 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb16(&mut self) -> FB16_W<F6R2_SPEC> {
                FB16_W::new(self, 16)
            }
            ///Bit 17 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb17(&mut self) -> FB17_W<F6R2_SPEC> {
                FB17_W::new(self, 17)
            }
            ///Bit 18 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb18(&mut self) -> FB18_W<F6R2_SPEC> {
                FB18_W::new(self, 18)
            }
            ///Bit 19 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb19(&mut self) -> FB19_W<F6R2_SPEC> {
                FB19_W::new(self, 19)
            }
            ///Bit 20 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb20(&mut self) -> FB20_W<F6R2_SPEC> {
                FB20_W::new(self, 20)
            }
            ///Bit 21 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb21(&mut self) -> FB21_W<F6R2_SPEC> {
                FB21_W::new(self, 21)
            }
            ///Bit 22 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb22(&mut self) -> FB22_W<F6R2_SPEC> {
                FB22_W::new(self, 22)
            }
            ///Bit 23 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb23(&mut self) -> FB23_W<F6R2_SPEC> {
                FB23_W::new(self, 23)
            }
            ///Bit 24 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb24(&mut self) -> FB24_W<F6R2_SPEC> {
                FB24_W::new(self, 24)
            }
            ///Bit 25 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb25(&mut self) -> FB25_W<F6R2_SPEC> {
                FB25_W::new(self, 25)
            }
            ///Bit 26 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb26(&mut self) -> FB26_W<F6R2_SPEC> {
                FB26_W::new(self, 26)
            }
            ///Bit 27 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb27(&mut self) -> FB27_W<F6R2_SPEC> {
                FB27_W::new(self, 27)
            }
            ///Bit 28 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb28(&mut self) -> FB28_W<F6R2_SPEC> {
                FB28_W::new(self, 28)
            }
            ///Bit 29 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb29(&mut self) -> FB29_W<F6R2_SPEC> {
                FB29_W::new(self, 29)
            }
            ///Bit 30 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb30(&mut self) -> FB30_W<F6R2_SPEC> {
                FB30_W::new(self, 30)
            }
            ///Bit 31 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb31(&mut self) -> FB31_W<F6R2_SPEC> {
                FB31_W::new(self, 31)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Filter bank 6 register 2
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`f6r2::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`f6r2::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct F6R2_SPEC;
        impl crate::RegisterSpec for F6R2_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`f6r2::R`](R) reader structure
        impl crate::Readable for F6R2_SPEC {}
        ///`write(|w| ..)` method takes [`f6r2::W`](W) writer structure
        impl crate::Writable for F6R2_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets F6R2 to value 0
        impl crate::Resettable for F6R2_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///F7R1 (rw) register accessor: Filter bank 7 register 1
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`f7r1::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`f7r1::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@f7r1`]
    ///module
    pub type F7R1 = crate::Reg<f7r1::F7R1_SPEC>;
    ///Filter bank 7 register 1
    pub mod f7r1 {
        ///Register `F7R1` reader
        pub type R = crate::R<F7R1_SPEC>;
        ///Register `F7R1` writer
        pub type W = crate::W<F7R1_SPEC>;
        ///Field `FB0` reader - Filter bits
        pub type FB0_R = crate::BitReader;
        ///Field `FB0` writer - Filter bits
        pub type FB0_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB1` reader - Filter bits
        pub type FB1_R = crate::BitReader;
        ///Field `FB1` writer - Filter bits
        pub type FB1_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB2` reader - Filter bits
        pub type FB2_R = crate::BitReader;
        ///Field `FB2` writer - Filter bits
        pub type FB2_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB3` reader - Filter bits
        pub type FB3_R = crate::BitReader;
        ///Field `FB3` writer - Filter bits
        pub type FB3_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB4` reader - Filter bits
        pub type FB4_R = crate::BitReader;
        ///Field `FB4` writer - Filter bits
        pub type FB4_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB5` reader - Filter bits
        pub type FB5_R = crate::BitReader;
        ///Field `FB5` writer - Filter bits
        pub type FB5_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB6` reader - Filter bits
        pub type FB6_R = crate::BitReader;
        ///Field `FB6` writer - Filter bits
        pub type FB6_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB7` reader - Filter bits
        pub type FB7_R = crate::BitReader;
        ///Field `FB7` writer - Filter bits
        pub type FB7_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB8` reader - Filter bits
        pub type FB8_R = crate::BitReader;
        ///Field `FB8` writer - Filter bits
        pub type FB8_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB9` reader - Filter bits
        pub type FB9_R = crate::BitReader;
        ///Field `FB9` writer - Filter bits
        pub type FB9_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB10` reader - Filter bits
        pub type FB10_R = crate::BitReader;
        ///Field `FB10` writer - Filter bits
        pub type FB10_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB11` reader - Filter bits
        pub type FB11_R = crate::BitReader;
        ///Field `FB11` writer - Filter bits
        pub type FB11_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB12` reader - Filter bits
        pub type FB12_R = crate::BitReader;
        ///Field `FB12` writer - Filter bits
        pub type FB12_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB13` reader - Filter bits
        pub type FB13_R = crate::BitReader;
        ///Field `FB13` writer - Filter bits
        pub type FB13_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB14` reader - Filter bits
        pub type FB14_R = crate::BitReader;
        ///Field `FB14` writer - Filter bits
        pub type FB14_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB15` reader - Filter bits
        pub type FB15_R = crate::BitReader;
        ///Field `FB15` writer - Filter bits
        pub type FB15_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB16` reader - Filter bits
        pub type FB16_R = crate::BitReader;
        ///Field `FB16` writer - Filter bits
        pub type FB16_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB17` reader - Filter bits
        pub type FB17_R = crate::BitReader;
        ///Field `FB17` writer - Filter bits
        pub type FB17_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB18` reader - Filter bits
        pub type FB18_R = crate::BitReader;
        ///Field `FB18` writer - Filter bits
        pub type FB18_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB19` reader - Filter bits
        pub type FB19_R = crate::BitReader;
        ///Field `FB19` writer - Filter bits
        pub type FB19_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB20` reader - Filter bits
        pub type FB20_R = crate::BitReader;
        ///Field `FB20` writer - Filter bits
        pub type FB20_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB21` reader - Filter bits
        pub type FB21_R = crate::BitReader;
        ///Field `FB21` writer - Filter bits
        pub type FB21_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB22` reader - Filter bits
        pub type FB22_R = crate::BitReader;
        ///Field `FB22` writer - Filter bits
        pub type FB22_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB23` reader - Filter bits
        pub type FB23_R = crate::BitReader;
        ///Field `FB23` writer - Filter bits
        pub type FB23_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB24` reader - Filter bits
        pub type FB24_R = crate::BitReader;
        ///Field `FB24` writer - Filter bits
        pub type FB24_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB25` reader - Filter bits
        pub type FB25_R = crate::BitReader;
        ///Field `FB25` writer - Filter bits
        pub type FB25_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB26` reader - Filter bits
        pub type FB26_R = crate::BitReader;
        ///Field `FB26` writer - Filter bits
        pub type FB26_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB27` reader - Filter bits
        pub type FB27_R = crate::BitReader;
        ///Field `FB27` writer - Filter bits
        pub type FB27_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB28` reader - Filter bits
        pub type FB28_R = crate::BitReader;
        ///Field `FB28` writer - Filter bits
        pub type FB28_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB29` reader - Filter bits
        pub type FB29_R = crate::BitReader;
        ///Field `FB29` writer - Filter bits
        pub type FB29_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB30` reader - Filter bits
        pub type FB30_R = crate::BitReader;
        ///Field `FB30` writer - Filter bits
        pub type FB30_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB31` reader - Filter bits
        pub type FB31_R = crate::BitReader;
        ///Field `FB31` writer - Filter bits
        pub type FB31_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - Filter bits
            #[inline(always)]
            pub fn fb0(&self) -> FB0_R {
                FB0_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Filter bits
            #[inline(always)]
            pub fn fb1(&self) -> FB1_R {
                FB1_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - Filter bits
            #[inline(always)]
            pub fn fb2(&self) -> FB2_R {
                FB2_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - Filter bits
            #[inline(always)]
            pub fn fb3(&self) -> FB3_R {
                FB3_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - Filter bits
            #[inline(always)]
            pub fn fb4(&self) -> FB4_R {
                FB4_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - Filter bits
            #[inline(always)]
            pub fn fb5(&self) -> FB5_R {
                FB5_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - Filter bits
            #[inline(always)]
            pub fn fb6(&self) -> FB6_R {
                FB6_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - Filter bits
            #[inline(always)]
            pub fn fb7(&self) -> FB7_R {
                FB7_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bit 8 - Filter bits
            #[inline(always)]
            pub fn fb8(&self) -> FB8_R {
                FB8_R::new(((self.bits >> 8) & 1) != 0)
            }
            ///Bit 9 - Filter bits
            #[inline(always)]
            pub fn fb9(&self) -> FB9_R {
                FB9_R::new(((self.bits >> 9) & 1) != 0)
            }
            ///Bit 10 - Filter bits
            #[inline(always)]
            pub fn fb10(&self) -> FB10_R {
                FB10_R::new(((self.bits >> 10) & 1) != 0)
            }
            ///Bit 11 - Filter bits
            #[inline(always)]
            pub fn fb11(&self) -> FB11_R {
                FB11_R::new(((self.bits >> 11) & 1) != 0)
            }
            ///Bit 12 - Filter bits
            #[inline(always)]
            pub fn fb12(&self) -> FB12_R {
                FB12_R::new(((self.bits >> 12) & 1) != 0)
            }
            ///Bit 13 - Filter bits
            #[inline(always)]
            pub fn fb13(&self) -> FB13_R {
                FB13_R::new(((self.bits >> 13) & 1) != 0)
            }
            ///Bit 14 - Filter bits
            #[inline(always)]
            pub fn fb14(&self) -> FB14_R {
                FB14_R::new(((self.bits >> 14) & 1) != 0)
            }
            ///Bit 15 - Filter bits
            #[inline(always)]
            pub fn fb15(&self) -> FB15_R {
                FB15_R::new(((self.bits >> 15) & 1) != 0)
            }
            ///Bit 16 - Filter bits
            #[inline(always)]
            pub fn fb16(&self) -> FB16_R {
                FB16_R::new(((self.bits >> 16) & 1) != 0)
            }
            ///Bit 17 - Filter bits
            #[inline(always)]
            pub fn fb17(&self) -> FB17_R {
                FB17_R::new(((self.bits >> 17) & 1) != 0)
            }
            ///Bit 18 - Filter bits
            #[inline(always)]
            pub fn fb18(&self) -> FB18_R {
                FB18_R::new(((self.bits >> 18) & 1) != 0)
            }
            ///Bit 19 - Filter bits
            #[inline(always)]
            pub fn fb19(&self) -> FB19_R {
                FB19_R::new(((self.bits >> 19) & 1) != 0)
            }
            ///Bit 20 - Filter bits
            #[inline(always)]
            pub fn fb20(&self) -> FB20_R {
                FB20_R::new(((self.bits >> 20) & 1) != 0)
            }
            ///Bit 21 - Filter bits
            #[inline(always)]
            pub fn fb21(&self) -> FB21_R {
                FB21_R::new(((self.bits >> 21) & 1) != 0)
            }
            ///Bit 22 - Filter bits
            #[inline(always)]
            pub fn fb22(&self) -> FB22_R {
                FB22_R::new(((self.bits >> 22) & 1) != 0)
            }
            ///Bit 23 - Filter bits
            #[inline(always)]
            pub fn fb23(&self) -> FB23_R {
                FB23_R::new(((self.bits >> 23) & 1) != 0)
            }
            ///Bit 24 - Filter bits
            #[inline(always)]
            pub fn fb24(&self) -> FB24_R {
                FB24_R::new(((self.bits >> 24) & 1) != 0)
            }
            ///Bit 25 - Filter bits
            #[inline(always)]
            pub fn fb25(&self) -> FB25_R {
                FB25_R::new(((self.bits >> 25) & 1) != 0)
            }
            ///Bit 26 - Filter bits
            #[inline(always)]
            pub fn fb26(&self) -> FB26_R {
                FB26_R::new(((self.bits >> 26) & 1) != 0)
            }
            ///Bit 27 - Filter bits
            #[inline(always)]
            pub fn fb27(&self) -> FB27_R {
                FB27_R::new(((self.bits >> 27) & 1) != 0)
            }
            ///Bit 28 - Filter bits
            #[inline(always)]
            pub fn fb28(&self) -> FB28_R {
                FB28_R::new(((self.bits >> 28) & 1) != 0)
            }
            ///Bit 29 - Filter bits
            #[inline(always)]
            pub fn fb29(&self) -> FB29_R {
                FB29_R::new(((self.bits >> 29) & 1) != 0)
            }
            ///Bit 30 - Filter bits
            #[inline(always)]
            pub fn fb30(&self) -> FB30_R {
                FB30_R::new(((self.bits >> 30) & 1) != 0)
            }
            ///Bit 31 - Filter bits
            #[inline(always)]
            pub fn fb31(&self) -> FB31_R {
                FB31_R::new(((self.bits >> 31) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb0(&mut self) -> FB0_W<F7R1_SPEC> {
                FB0_W::new(self, 0)
            }
            ///Bit 1 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb1(&mut self) -> FB1_W<F7R1_SPEC> {
                FB1_W::new(self, 1)
            }
            ///Bit 2 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb2(&mut self) -> FB2_W<F7R1_SPEC> {
                FB2_W::new(self, 2)
            }
            ///Bit 3 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb3(&mut self) -> FB3_W<F7R1_SPEC> {
                FB3_W::new(self, 3)
            }
            ///Bit 4 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb4(&mut self) -> FB4_W<F7R1_SPEC> {
                FB4_W::new(self, 4)
            }
            ///Bit 5 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb5(&mut self) -> FB5_W<F7R1_SPEC> {
                FB5_W::new(self, 5)
            }
            ///Bit 6 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb6(&mut self) -> FB6_W<F7R1_SPEC> {
                FB6_W::new(self, 6)
            }
            ///Bit 7 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb7(&mut self) -> FB7_W<F7R1_SPEC> {
                FB7_W::new(self, 7)
            }
            ///Bit 8 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb8(&mut self) -> FB8_W<F7R1_SPEC> {
                FB8_W::new(self, 8)
            }
            ///Bit 9 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb9(&mut self) -> FB9_W<F7R1_SPEC> {
                FB9_W::new(self, 9)
            }
            ///Bit 10 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb10(&mut self) -> FB10_W<F7R1_SPEC> {
                FB10_W::new(self, 10)
            }
            ///Bit 11 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb11(&mut self) -> FB11_W<F7R1_SPEC> {
                FB11_W::new(self, 11)
            }
            ///Bit 12 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb12(&mut self) -> FB12_W<F7R1_SPEC> {
                FB12_W::new(self, 12)
            }
            ///Bit 13 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb13(&mut self) -> FB13_W<F7R1_SPEC> {
                FB13_W::new(self, 13)
            }
            ///Bit 14 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb14(&mut self) -> FB14_W<F7R1_SPEC> {
                FB14_W::new(self, 14)
            }
            ///Bit 15 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb15(&mut self) -> FB15_W<F7R1_SPEC> {
                FB15_W::new(self, 15)
            }
            ///Bit 16 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb16(&mut self) -> FB16_W<F7R1_SPEC> {
                FB16_W::new(self, 16)
            }
            ///Bit 17 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb17(&mut self) -> FB17_W<F7R1_SPEC> {
                FB17_W::new(self, 17)
            }
            ///Bit 18 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb18(&mut self) -> FB18_W<F7R1_SPEC> {
                FB18_W::new(self, 18)
            }
            ///Bit 19 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb19(&mut self) -> FB19_W<F7R1_SPEC> {
                FB19_W::new(self, 19)
            }
            ///Bit 20 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb20(&mut self) -> FB20_W<F7R1_SPEC> {
                FB20_W::new(self, 20)
            }
            ///Bit 21 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb21(&mut self) -> FB21_W<F7R1_SPEC> {
                FB21_W::new(self, 21)
            }
            ///Bit 22 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb22(&mut self) -> FB22_W<F7R1_SPEC> {
                FB22_W::new(self, 22)
            }
            ///Bit 23 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb23(&mut self) -> FB23_W<F7R1_SPEC> {
                FB23_W::new(self, 23)
            }
            ///Bit 24 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb24(&mut self) -> FB24_W<F7R1_SPEC> {
                FB24_W::new(self, 24)
            }
            ///Bit 25 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb25(&mut self) -> FB25_W<F7R1_SPEC> {
                FB25_W::new(self, 25)
            }
            ///Bit 26 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb26(&mut self) -> FB26_W<F7R1_SPEC> {
                FB26_W::new(self, 26)
            }
            ///Bit 27 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb27(&mut self) -> FB27_W<F7R1_SPEC> {
                FB27_W::new(self, 27)
            }
            ///Bit 28 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb28(&mut self) -> FB28_W<F7R1_SPEC> {
                FB28_W::new(self, 28)
            }
            ///Bit 29 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb29(&mut self) -> FB29_W<F7R1_SPEC> {
                FB29_W::new(self, 29)
            }
            ///Bit 30 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb30(&mut self) -> FB30_W<F7R1_SPEC> {
                FB30_W::new(self, 30)
            }
            ///Bit 31 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb31(&mut self) -> FB31_W<F7R1_SPEC> {
                FB31_W::new(self, 31)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Filter bank 7 register 1
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`f7r1::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`f7r1::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct F7R1_SPEC;
        impl crate::RegisterSpec for F7R1_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`f7r1::R`](R) reader structure
        impl crate::Readable for F7R1_SPEC {}
        ///`write(|w| ..)` method takes [`f7r1::W`](W) writer structure
        impl crate::Writable for F7R1_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets F7R1 to value 0
        impl crate::Resettable for F7R1_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///F7R2 (rw) register accessor: Filter bank 7 register 2
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`f7r2::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`f7r2::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@f7r2`]
    ///module
    pub type F7R2 = crate::Reg<f7r2::F7R2_SPEC>;
    ///Filter bank 7 register 2
    pub mod f7r2 {
        ///Register `F7R2` reader
        pub type R = crate::R<F7R2_SPEC>;
        ///Register `F7R2` writer
        pub type W = crate::W<F7R2_SPEC>;
        ///Field `FB0` reader - Filter bits
        pub type FB0_R = crate::BitReader;
        ///Field `FB0` writer - Filter bits
        pub type FB0_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB1` reader - Filter bits
        pub type FB1_R = crate::BitReader;
        ///Field `FB1` writer - Filter bits
        pub type FB1_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB2` reader - Filter bits
        pub type FB2_R = crate::BitReader;
        ///Field `FB2` writer - Filter bits
        pub type FB2_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB3` reader - Filter bits
        pub type FB3_R = crate::BitReader;
        ///Field `FB3` writer - Filter bits
        pub type FB3_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB4` reader - Filter bits
        pub type FB4_R = crate::BitReader;
        ///Field `FB4` writer - Filter bits
        pub type FB4_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB5` reader - Filter bits
        pub type FB5_R = crate::BitReader;
        ///Field `FB5` writer - Filter bits
        pub type FB5_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB6` reader - Filter bits
        pub type FB6_R = crate::BitReader;
        ///Field `FB6` writer - Filter bits
        pub type FB6_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB7` reader - Filter bits
        pub type FB7_R = crate::BitReader;
        ///Field `FB7` writer - Filter bits
        pub type FB7_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB8` reader - Filter bits
        pub type FB8_R = crate::BitReader;
        ///Field `FB8` writer - Filter bits
        pub type FB8_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB9` reader - Filter bits
        pub type FB9_R = crate::BitReader;
        ///Field `FB9` writer - Filter bits
        pub type FB9_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB10` reader - Filter bits
        pub type FB10_R = crate::BitReader;
        ///Field `FB10` writer - Filter bits
        pub type FB10_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB11` reader - Filter bits
        pub type FB11_R = crate::BitReader;
        ///Field `FB11` writer - Filter bits
        pub type FB11_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB12` reader - Filter bits
        pub type FB12_R = crate::BitReader;
        ///Field `FB12` writer - Filter bits
        pub type FB12_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB13` reader - Filter bits
        pub type FB13_R = crate::BitReader;
        ///Field `FB13` writer - Filter bits
        pub type FB13_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB14` reader - Filter bits
        pub type FB14_R = crate::BitReader;
        ///Field `FB14` writer - Filter bits
        pub type FB14_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB15` reader - Filter bits
        pub type FB15_R = crate::BitReader;
        ///Field `FB15` writer - Filter bits
        pub type FB15_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB16` reader - Filter bits
        pub type FB16_R = crate::BitReader;
        ///Field `FB16` writer - Filter bits
        pub type FB16_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB17` reader - Filter bits
        pub type FB17_R = crate::BitReader;
        ///Field `FB17` writer - Filter bits
        pub type FB17_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB18` reader - Filter bits
        pub type FB18_R = crate::BitReader;
        ///Field `FB18` writer - Filter bits
        pub type FB18_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB19` reader - Filter bits
        pub type FB19_R = crate::BitReader;
        ///Field `FB19` writer - Filter bits
        pub type FB19_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB20` reader - Filter bits
        pub type FB20_R = crate::BitReader;
        ///Field `FB20` writer - Filter bits
        pub type FB20_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB21` reader - Filter bits
        pub type FB21_R = crate::BitReader;
        ///Field `FB21` writer - Filter bits
        pub type FB21_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB22` reader - Filter bits
        pub type FB22_R = crate::BitReader;
        ///Field `FB22` writer - Filter bits
        pub type FB22_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB23` reader - Filter bits
        pub type FB23_R = crate::BitReader;
        ///Field `FB23` writer - Filter bits
        pub type FB23_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB24` reader - Filter bits
        pub type FB24_R = crate::BitReader;
        ///Field `FB24` writer - Filter bits
        pub type FB24_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB25` reader - Filter bits
        pub type FB25_R = crate::BitReader;
        ///Field `FB25` writer - Filter bits
        pub type FB25_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB26` reader - Filter bits
        pub type FB26_R = crate::BitReader;
        ///Field `FB26` writer - Filter bits
        pub type FB26_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB27` reader - Filter bits
        pub type FB27_R = crate::BitReader;
        ///Field `FB27` writer - Filter bits
        pub type FB27_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB28` reader - Filter bits
        pub type FB28_R = crate::BitReader;
        ///Field `FB28` writer - Filter bits
        pub type FB28_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB29` reader - Filter bits
        pub type FB29_R = crate::BitReader;
        ///Field `FB29` writer - Filter bits
        pub type FB29_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB30` reader - Filter bits
        pub type FB30_R = crate::BitReader;
        ///Field `FB30` writer - Filter bits
        pub type FB30_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB31` reader - Filter bits
        pub type FB31_R = crate::BitReader;
        ///Field `FB31` writer - Filter bits
        pub type FB31_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - Filter bits
            #[inline(always)]
            pub fn fb0(&self) -> FB0_R {
                FB0_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Filter bits
            #[inline(always)]
            pub fn fb1(&self) -> FB1_R {
                FB1_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - Filter bits
            #[inline(always)]
            pub fn fb2(&self) -> FB2_R {
                FB2_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - Filter bits
            #[inline(always)]
            pub fn fb3(&self) -> FB3_R {
                FB3_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - Filter bits
            #[inline(always)]
            pub fn fb4(&self) -> FB4_R {
                FB4_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - Filter bits
            #[inline(always)]
            pub fn fb5(&self) -> FB5_R {
                FB5_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - Filter bits
            #[inline(always)]
            pub fn fb6(&self) -> FB6_R {
                FB6_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - Filter bits
            #[inline(always)]
            pub fn fb7(&self) -> FB7_R {
                FB7_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bit 8 - Filter bits
            #[inline(always)]
            pub fn fb8(&self) -> FB8_R {
                FB8_R::new(((self.bits >> 8) & 1) != 0)
            }
            ///Bit 9 - Filter bits
            #[inline(always)]
            pub fn fb9(&self) -> FB9_R {
                FB9_R::new(((self.bits >> 9) & 1) != 0)
            }
            ///Bit 10 - Filter bits
            #[inline(always)]
            pub fn fb10(&self) -> FB10_R {
                FB10_R::new(((self.bits >> 10) & 1) != 0)
            }
            ///Bit 11 - Filter bits
            #[inline(always)]
            pub fn fb11(&self) -> FB11_R {
                FB11_R::new(((self.bits >> 11) & 1) != 0)
            }
            ///Bit 12 - Filter bits
            #[inline(always)]
            pub fn fb12(&self) -> FB12_R {
                FB12_R::new(((self.bits >> 12) & 1) != 0)
            }
            ///Bit 13 - Filter bits
            #[inline(always)]
            pub fn fb13(&self) -> FB13_R {
                FB13_R::new(((self.bits >> 13) & 1) != 0)
            }
            ///Bit 14 - Filter bits
            #[inline(always)]
            pub fn fb14(&self) -> FB14_R {
                FB14_R::new(((self.bits >> 14) & 1) != 0)
            }
            ///Bit 15 - Filter bits
            #[inline(always)]
            pub fn fb15(&self) -> FB15_R {
                FB15_R::new(((self.bits >> 15) & 1) != 0)
            }
            ///Bit 16 - Filter bits
            #[inline(always)]
            pub fn fb16(&self) -> FB16_R {
                FB16_R::new(((self.bits >> 16) & 1) != 0)
            }
            ///Bit 17 - Filter bits
            #[inline(always)]
            pub fn fb17(&self) -> FB17_R {
                FB17_R::new(((self.bits >> 17) & 1) != 0)
            }
            ///Bit 18 - Filter bits
            #[inline(always)]
            pub fn fb18(&self) -> FB18_R {
                FB18_R::new(((self.bits >> 18) & 1) != 0)
            }
            ///Bit 19 - Filter bits
            #[inline(always)]
            pub fn fb19(&self) -> FB19_R {
                FB19_R::new(((self.bits >> 19) & 1) != 0)
            }
            ///Bit 20 - Filter bits
            #[inline(always)]
            pub fn fb20(&self) -> FB20_R {
                FB20_R::new(((self.bits >> 20) & 1) != 0)
            }
            ///Bit 21 - Filter bits
            #[inline(always)]
            pub fn fb21(&self) -> FB21_R {
                FB21_R::new(((self.bits >> 21) & 1) != 0)
            }
            ///Bit 22 - Filter bits
            #[inline(always)]
            pub fn fb22(&self) -> FB22_R {
                FB22_R::new(((self.bits >> 22) & 1) != 0)
            }
            ///Bit 23 - Filter bits
            #[inline(always)]
            pub fn fb23(&self) -> FB23_R {
                FB23_R::new(((self.bits >> 23) & 1) != 0)
            }
            ///Bit 24 - Filter bits
            #[inline(always)]
            pub fn fb24(&self) -> FB24_R {
                FB24_R::new(((self.bits >> 24) & 1) != 0)
            }
            ///Bit 25 - Filter bits
            #[inline(always)]
            pub fn fb25(&self) -> FB25_R {
                FB25_R::new(((self.bits >> 25) & 1) != 0)
            }
            ///Bit 26 - Filter bits
            #[inline(always)]
            pub fn fb26(&self) -> FB26_R {
                FB26_R::new(((self.bits >> 26) & 1) != 0)
            }
            ///Bit 27 - Filter bits
            #[inline(always)]
            pub fn fb27(&self) -> FB27_R {
                FB27_R::new(((self.bits >> 27) & 1) != 0)
            }
            ///Bit 28 - Filter bits
            #[inline(always)]
            pub fn fb28(&self) -> FB28_R {
                FB28_R::new(((self.bits >> 28) & 1) != 0)
            }
            ///Bit 29 - Filter bits
            #[inline(always)]
            pub fn fb29(&self) -> FB29_R {
                FB29_R::new(((self.bits >> 29) & 1) != 0)
            }
            ///Bit 30 - Filter bits
            #[inline(always)]
            pub fn fb30(&self) -> FB30_R {
                FB30_R::new(((self.bits >> 30) & 1) != 0)
            }
            ///Bit 31 - Filter bits
            #[inline(always)]
            pub fn fb31(&self) -> FB31_R {
                FB31_R::new(((self.bits >> 31) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb0(&mut self) -> FB0_W<F7R2_SPEC> {
                FB0_W::new(self, 0)
            }
            ///Bit 1 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb1(&mut self) -> FB1_W<F7R2_SPEC> {
                FB1_W::new(self, 1)
            }
            ///Bit 2 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb2(&mut self) -> FB2_W<F7R2_SPEC> {
                FB2_W::new(self, 2)
            }
            ///Bit 3 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb3(&mut self) -> FB3_W<F7R2_SPEC> {
                FB3_W::new(self, 3)
            }
            ///Bit 4 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb4(&mut self) -> FB4_W<F7R2_SPEC> {
                FB4_W::new(self, 4)
            }
            ///Bit 5 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb5(&mut self) -> FB5_W<F7R2_SPEC> {
                FB5_W::new(self, 5)
            }
            ///Bit 6 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb6(&mut self) -> FB6_W<F7R2_SPEC> {
                FB6_W::new(self, 6)
            }
            ///Bit 7 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb7(&mut self) -> FB7_W<F7R2_SPEC> {
                FB7_W::new(self, 7)
            }
            ///Bit 8 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb8(&mut self) -> FB8_W<F7R2_SPEC> {
                FB8_W::new(self, 8)
            }
            ///Bit 9 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb9(&mut self) -> FB9_W<F7R2_SPEC> {
                FB9_W::new(self, 9)
            }
            ///Bit 10 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb10(&mut self) -> FB10_W<F7R2_SPEC> {
                FB10_W::new(self, 10)
            }
            ///Bit 11 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb11(&mut self) -> FB11_W<F7R2_SPEC> {
                FB11_W::new(self, 11)
            }
            ///Bit 12 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb12(&mut self) -> FB12_W<F7R2_SPEC> {
                FB12_W::new(self, 12)
            }
            ///Bit 13 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb13(&mut self) -> FB13_W<F7R2_SPEC> {
                FB13_W::new(self, 13)
            }
            ///Bit 14 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb14(&mut self) -> FB14_W<F7R2_SPEC> {
                FB14_W::new(self, 14)
            }
            ///Bit 15 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb15(&mut self) -> FB15_W<F7R2_SPEC> {
                FB15_W::new(self, 15)
            }
            ///Bit 16 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb16(&mut self) -> FB16_W<F7R2_SPEC> {
                FB16_W::new(self, 16)
            }
            ///Bit 17 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb17(&mut self) -> FB17_W<F7R2_SPEC> {
                FB17_W::new(self, 17)
            }
            ///Bit 18 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb18(&mut self) -> FB18_W<F7R2_SPEC> {
                FB18_W::new(self, 18)
            }
            ///Bit 19 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb19(&mut self) -> FB19_W<F7R2_SPEC> {
                FB19_W::new(self, 19)
            }
            ///Bit 20 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb20(&mut self) -> FB20_W<F7R2_SPEC> {
                FB20_W::new(self, 20)
            }
            ///Bit 21 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb21(&mut self) -> FB21_W<F7R2_SPEC> {
                FB21_W::new(self, 21)
            }
            ///Bit 22 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb22(&mut self) -> FB22_W<F7R2_SPEC> {
                FB22_W::new(self, 22)
            }
            ///Bit 23 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb23(&mut self) -> FB23_W<F7R2_SPEC> {
                FB23_W::new(self, 23)
            }
            ///Bit 24 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb24(&mut self) -> FB24_W<F7R2_SPEC> {
                FB24_W::new(self, 24)
            }
            ///Bit 25 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb25(&mut self) -> FB25_W<F7R2_SPEC> {
                FB25_W::new(self, 25)
            }
            ///Bit 26 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb26(&mut self) -> FB26_W<F7R2_SPEC> {
                FB26_W::new(self, 26)
            }
            ///Bit 27 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb27(&mut self) -> FB27_W<F7R2_SPEC> {
                FB27_W::new(self, 27)
            }
            ///Bit 28 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb28(&mut self) -> FB28_W<F7R2_SPEC> {
                FB28_W::new(self, 28)
            }
            ///Bit 29 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb29(&mut self) -> FB29_W<F7R2_SPEC> {
                FB29_W::new(self, 29)
            }
            ///Bit 30 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb30(&mut self) -> FB30_W<F7R2_SPEC> {
                FB30_W::new(self, 30)
            }
            ///Bit 31 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb31(&mut self) -> FB31_W<F7R2_SPEC> {
                FB31_W::new(self, 31)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Filter bank 7 register 2
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`f7r2::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`f7r2::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct F7R2_SPEC;
        impl crate::RegisterSpec for F7R2_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`f7r2::R`](R) reader structure
        impl crate::Readable for F7R2_SPEC {}
        ///`write(|w| ..)` method takes [`f7r2::W`](W) writer structure
        impl crate::Writable for F7R2_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets F7R2 to value 0
        impl crate::Resettable for F7R2_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///F8R1 (rw) register accessor: Filter bank 8 register 1
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`f8r1::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`f8r1::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@f8r1`]
    ///module
    pub type F8R1 = crate::Reg<f8r1::F8R1_SPEC>;
    ///Filter bank 8 register 1
    pub mod f8r1 {
        ///Register `F8R1` reader
        pub type R = crate::R<F8R1_SPEC>;
        ///Register `F8R1` writer
        pub type W = crate::W<F8R1_SPEC>;
        ///Field `FB0` reader - Filter bits
        pub type FB0_R = crate::BitReader;
        ///Field `FB0` writer - Filter bits
        pub type FB0_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB1` reader - Filter bits
        pub type FB1_R = crate::BitReader;
        ///Field `FB1` writer - Filter bits
        pub type FB1_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB2` reader - Filter bits
        pub type FB2_R = crate::BitReader;
        ///Field `FB2` writer - Filter bits
        pub type FB2_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB3` reader - Filter bits
        pub type FB3_R = crate::BitReader;
        ///Field `FB3` writer - Filter bits
        pub type FB3_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB4` reader - Filter bits
        pub type FB4_R = crate::BitReader;
        ///Field `FB4` writer - Filter bits
        pub type FB4_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB5` reader - Filter bits
        pub type FB5_R = crate::BitReader;
        ///Field `FB5` writer - Filter bits
        pub type FB5_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB6` reader - Filter bits
        pub type FB6_R = crate::BitReader;
        ///Field `FB6` writer - Filter bits
        pub type FB6_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB7` reader - Filter bits
        pub type FB7_R = crate::BitReader;
        ///Field `FB7` writer - Filter bits
        pub type FB7_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB8` reader - Filter bits
        pub type FB8_R = crate::BitReader;
        ///Field `FB8` writer - Filter bits
        pub type FB8_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB9` reader - Filter bits
        pub type FB9_R = crate::BitReader;
        ///Field `FB9` writer - Filter bits
        pub type FB9_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB10` reader - Filter bits
        pub type FB10_R = crate::BitReader;
        ///Field `FB10` writer - Filter bits
        pub type FB10_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB11` reader - Filter bits
        pub type FB11_R = crate::BitReader;
        ///Field `FB11` writer - Filter bits
        pub type FB11_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB12` reader - Filter bits
        pub type FB12_R = crate::BitReader;
        ///Field `FB12` writer - Filter bits
        pub type FB12_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB13` reader - Filter bits
        pub type FB13_R = crate::BitReader;
        ///Field `FB13` writer - Filter bits
        pub type FB13_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB14` reader - Filter bits
        pub type FB14_R = crate::BitReader;
        ///Field `FB14` writer - Filter bits
        pub type FB14_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB15` reader - Filter bits
        pub type FB15_R = crate::BitReader;
        ///Field `FB15` writer - Filter bits
        pub type FB15_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB16` reader - Filter bits
        pub type FB16_R = crate::BitReader;
        ///Field `FB16` writer - Filter bits
        pub type FB16_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB17` reader - Filter bits
        pub type FB17_R = crate::BitReader;
        ///Field `FB17` writer - Filter bits
        pub type FB17_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB18` reader - Filter bits
        pub type FB18_R = crate::BitReader;
        ///Field `FB18` writer - Filter bits
        pub type FB18_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB19` reader - Filter bits
        pub type FB19_R = crate::BitReader;
        ///Field `FB19` writer - Filter bits
        pub type FB19_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB20` reader - Filter bits
        pub type FB20_R = crate::BitReader;
        ///Field `FB20` writer - Filter bits
        pub type FB20_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB21` reader - Filter bits
        pub type FB21_R = crate::BitReader;
        ///Field `FB21` writer - Filter bits
        pub type FB21_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB22` reader - Filter bits
        pub type FB22_R = crate::BitReader;
        ///Field `FB22` writer - Filter bits
        pub type FB22_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB23` reader - Filter bits
        pub type FB23_R = crate::BitReader;
        ///Field `FB23` writer - Filter bits
        pub type FB23_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB24` reader - Filter bits
        pub type FB24_R = crate::BitReader;
        ///Field `FB24` writer - Filter bits
        pub type FB24_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB25` reader - Filter bits
        pub type FB25_R = crate::BitReader;
        ///Field `FB25` writer - Filter bits
        pub type FB25_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB26` reader - Filter bits
        pub type FB26_R = crate::BitReader;
        ///Field `FB26` writer - Filter bits
        pub type FB26_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB27` reader - Filter bits
        pub type FB27_R = crate::BitReader;
        ///Field `FB27` writer - Filter bits
        pub type FB27_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB28` reader - Filter bits
        pub type FB28_R = crate::BitReader;
        ///Field `FB28` writer - Filter bits
        pub type FB28_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB29` reader - Filter bits
        pub type FB29_R = crate::BitReader;
        ///Field `FB29` writer - Filter bits
        pub type FB29_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB30` reader - Filter bits
        pub type FB30_R = crate::BitReader;
        ///Field `FB30` writer - Filter bits
        pub type FB30_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB31` reader - Filter bits
        pub type FB31_R = crate::BitReader;
        ///Field `FB31` writer - Filter bits
        pub type FB31_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - Filter bits
            #[inline(always)]
            pub fn fb0(&self) -> FB0_R {
                FB0_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Filter bits
            #[inline(always)]
            pub fn fb1(&self) -> FB1_R {
                FB1_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - Filter bits
            #[inline(always)]
            pub fn fb2(&self) -> FB2_R {
                FB2_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - Filter bits
            #[inline(always)]
            pub fn fb3(&self) -> FB3_R {
                FB3_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - Filter bits
            #[inline(always)]
            pub fn fb4(&self) -> FB4_R {
                FB4_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - Filter bits
            #[inline(always)]
            pub fn fb5(&self) -> FB5_R {
                FB5_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - Filter bits
            #[inline(always)]
            pub fn fb6(&self) -> FB6_R {
                FB6_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - Filter bits
            #[inline(always)]
            pub fn fb7(&self) -> FB7_R {
                FB7_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bit 8 - Filter bits
            #[inline(always)]
            pub fn fb8(&self) -> FB8_R {
                FB8_R::new(((self.bits >> 8) & 1) != 0)
            }
            ///Bit 9 - Filter bits
            #[inline(always)]
            pub fn fb9(&self) -> FB9_R {
                FB9_R::new(((self.bits >> 9) & 1) != 0)
            }
            ///Bit 10 - Filter bits
            #[inline(always)]
            pub fn fb10(&self) -> FB10_R {
                FB10_R::new(((self.bits >> 10) & 1) != 0)
            }
            ///Bit 11 - Filter bits
            #[inline(always)]
            pub fn fb11(&self) -> FB11_R {
                FB11_R::new(((self.bits >> 11) & 1) != 0)
            }
            ///Bit 12 - Filter bits
            #[inline(always)]
            pub fn fb12(&self) -> FB12_R {
                FB12_R::new(((self.bits >> 12) & 1) != 0)
            }
            ///Bit 13 - Filter bits
            #[inline(always)]
            pub fn fb13(&self) -> FB13_R {
                FB13_R::new(((self.bits >> 13) & 1) != 0)
            }
            ///Bit 14 - Filter bits
            #[inline(always)]
            pub fn fb14(&self) -> FB14_R {
                FB14_R::new(((self.bits >> 14) & 1) != 0)
            }
            ///Bit 15 - Filter bits
            #[inline(always)]
            pub fn fb15(&self) -> FB15_R {
                FB15_R::new(((self.bits >> 15) & 1) != 0)
            }
            ///Bit 16 - Filter bits
            #[inline(always)]
            pub fn fb16(&self) -> FB16_R {
                FB16_R::new(((self.bits >> 16) & 1) != 0)
            }
            ///Bit 17 - Filter bits
            #[inline(always)]
            pub fn fb17(&self) -> FB17_R {
                FB17_R::new(((self.bits >> 17) & 1) != 0)
            }
            ///Bit 18 - Filter bits
            #[inline(always)]
            pub fn fb18(&self) -> FB18_R {
                FB18_R::new(((self.bits >> 18) & 1) != 0)
            }
            ///Bit 19 - Filter bits
            #[inline(always)]
            pub fn fb19(&self) -> FB19_R {
                FB19_R::new(((self.bits >> 19) & 1) != 0)
            }
            ///Bit 20 - Filter bits
            #[inline(always)]
            pub fn fb20(&self) -> FB20_R {
                FB20_R::new(((self.bits >> 20) & 1) != 0)
            }
            ///Bit 21 - Filter bits
            #[inline(always)]
            pub fn fb21(&self) -> FB21_R {
                FB21_R::new(((self.bits >> 21) & 1) != 0)
            }
            ///Bit 22 - Filter bits
            #[inline(always)]
            pub fn fb22(&self) -> FB22_R {
                FB22_R::new(((self.bits >> 22) & 1) != 0)
            }
            ///Bit 23 - Filter bits
            #[inline(always)]
            pub fn fb23(&self) -> FB23_R {
                FB23_R::new(((self.bits >> 23) & 1) != 0)
            }
            ///Bit 24 - Filter bits
            #[inline(always)]
            pub fn fb24(&self) -> FB24_R {
                FB24_R::new(((self.bits >> 24) & 1) != 0)
            }
            ///Bit 25 - Filter bits
            #[inline(always)]
            pub fn fb25(&self) -> FB25_R {
                FB25_R::new(((self.bits >> 25) & 1) != 0)
            }
            ///Bit 26 - Filter bits
            #[inline(always)]
            pub fn fb26(&self) -> FB26_R {
                FB26_R::new(((self.bits >> 26) & 1) != 0)
            }
            ///Bit 27 - Filter bits
            #[inline(always)]
            pub fn fb27(&self) -> FB27_R {
                FB27_R::new(((self.bits >> 27) & 1) != 0)
            }
            ///Bit 28 - Filter bits
            #[inline(always)]
            pub fn fb28(&self) -> FB28_R {
                FB28_R::new(((self.bits >> 28) & 1) != 0)
            }
            ///Bit 29 - Filter bits
            #[inline(always)]
            pub fn fb29(&self) -> FB29_R {
                FB29_R::new(((self.bits >> 29) & 1) != 0)
            }
            ///Bit 30 - Filter bits
            #[inline(always)]
            pub fn fb30(&self) -> FB30_R {
                FB30_R::new(((self.bits >> 30) & 1) != 0)
            }
            ///Bit 31 - Filter bits
            #[inline(always)]
            pub fn fb31(&self) -> FB31_R {
                FB31_R::new(((self.bits >> 31) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb0(&mut self) -> FB0_W<F8R1_SPEC> {
                FB0_W::new(self, 0)
            }
            ///Bit 1 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb1(&mut self) -> FB1_W<F8R1_SPEC> {
                FB1_W::new(self, 1)
            }
            ///Bit 2 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb2(&mut self) -> FB2_W<F8R1_SPEC> {
                FB2_W::new(self, 2)
            }
            ///Bit 3 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb3(&mut self) -> FB3_W<F8R1_SPEC> {
                FB3_W::new(self, 3)
            }
            ///Bit 4 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb4(&mut self) -> FB4_W<F8R1_SPEC> {
                FB4_W::new(self, 4)
            }
            ///Bit 5 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb5(&mut self) -> FB5_W<F8R1_SPEC> {
                FB5_W::new(self, 5)
            }
            ///Bit 6 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb6(&mut self) -> FB6_W<F8R1_SPEC> {
                FB6_W::new(self, 6)
            }
            ///Bit 7 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb7(&mut self) -> FB7_W<F8R1_SPEC> {
                FB7_W::new(self, 7)
            }
            ///Bit 8 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb8(&mut self) -> FB8_W<F8R1_SPEC> {
                FB8_W::new(self, 8)
            }
            ///Bit 9 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb9(&mut self) -> FB9_W<F8R1_SPEC> {
                FB9_W::new(self, 9)
            }
            ///Bit 10 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb10(&mut self) -> FB10_W<F8R1_SPEC> {
                FB10_W::new(self, 10)
            }
            ///Bit 11 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb11(&mut self) -> FB11_W<F8R1_SPEC> {
                FB11_W::new(self, 11)
            }
            ///Bit 12 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb12(&mut self) -> FB12_W<F8R1_SPEC> {
                FB12_W::new(self, 12)
            }
            ///Bit 13 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb13(&mut self) -> FB13_W<F8R1_SPEC> {
                FB13_W::new(self, 13)
            }
            ///Bit 14 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb14(&mut self) -> FB14_W<F8R1_SPEC> {
                FB14_W::new(self, 14)
            }
            ///Bit 15 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb15(&mut self) -> FB15_W<F8R1_SPEC> {
                FB15_W::new(self, 15)
            }
            ///Bit 16 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb16(&mut self) -> FB16_W<F8R1_SPEC> {
                FB16_W::new(self, 16)
            }
            ///Bit 17 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb17(&mut self) -> FB17_W<F8R1_SPEC> {
                FB17_W::new(self, 17)
            }
            ///Bit 18 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb18(&mut self) -> FB18_W<F8R1_SPEC> {
                FB18_W::new(self, 18)
            }
            ///Bit 19 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb19(&mut self) -> FB19_W<F8R1_SPEC> {
                FB19_W::new(self, 19)
            }
            ///Bit 20 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb20(&mut self) -> FB20_W<F8R1_SPEC> {
                FB20_W::new(self, 20)
            }
            ///Bit 21 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb21(&mut self) -> FB21_W<F8R1_SPEC> {
                FB21_W::new(self, 21)
            }
            ///Bit 22 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb22(&mut self) -> FB22_W<F8R1_SPEC> {
                FB22_W::new(self, 22)
            }
            ///Bit 23 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb23(&mut self) -> FB23_W<F8R1_SPEC> {
                FB23_W::new(self, 23)
            }
            ///Bit 24 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb24(&mut self) -> FB24_W<F8R1_SPEC> {
                FB24_W::new(self, 24)
            }
            ///Bit 25 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb25(&mut self) -> FB25_W<F8R1_SPEC> {
                FB25_W::new(self, 25)
            }
            ///Bit 26 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb26(&mut self) -> FB26_W<F8R1_SPEC> {
                FB26_W::new(self, 26)
            }
            ///Bit 27 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb27(&mut self) -> FB27_W<F8R1_SPEC> {
                FB27_W::new(self, 27)
            }
            ///Bit 28 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb28(&mut self) -> FB28_W<F8R1_SPEC> {
                FB28_W::new(self, 28)
            }
            ///Bit 29 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb29(&mut self) -> FB29_W<F8R1_SPEC> {
                FB29_W::new(self, 29)
            }
            ///Bit 30 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb30(&mut self) -> FB30_W<F8R1_SPEC> {
                FB30_W::new(self, 30)
            }
            ///Bit 31 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb31(&mut self) -> FB31_W<F8R1_SPEC> {
                FB31_W::new(self, 31)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Filter bank 8 register 1
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`f8r1::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`f8r1::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct F8R1_SPEC;
        impl crate::RegisterSpec for F8R1_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`f8r1::R`](R) reader structure
        impl crate::Readable for F8R1_SPEC {}
        ///`write(|w| ..)` method takes [`f8r1::W`](W) writer structure
        impl crate::Writable for F8R1_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets F8R1 to value 0
        impl crate::Resettable for F8R1_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///F8R2 (rw) register accessor: Filter bank 8 register 2
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`f8r2::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`f8r2::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@f8r2`]
    ///module
    pub type F8R2 = crate::Reg<f8r2::F8R2_SPEC>;
    ///Filter bank 8 register 2
    pub mod f8r2 {
        ///Register `F8R2` reader
        pub type R = crate::R<F8R2_SPEC>;
        ///Register `F8R2` writer
        pub type W = crate::W<F8R2_SPEC>;
        ///Field `FB0` reader - Filter bits
        pub type FB0_R = crate::BitReader;
        ///Field `FB0` writer - Filter bits
        pub type FB0_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB1` reader - Filter bits
        pub type FB1_R = crate::BitReader;
        ///Field `FB1` writer - Filter bits
        pub type FB1_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB2` reader - Filter bits
        pub type FB2_R = crate::BitReader;
        ///Field `FB2` writer - Filter bits
        pub type FB2_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB3` reader - Filter bits
        pub type FB3_R = crate::BitReader;
        ///Field `FB3` writer - Filter bits
        pub type FB3_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB4` reader - Filter bits
        pub type FB4_R = crate::BitReader;
        ///Field `FB4` writer - Filter bits
        pub type FB4_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB5` reader - Filter bits
        pub type FB5_R = crate::BitReader;
        ///Field `FB5` writer - Filter bits
        pub type FB5_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB6` reader - Filter bits
        pub type FB6_R = crate::BitReader;
        ///Field `FB6` writer - Filter bits
        pub type FB6_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB7` reader - Filter bits
        pub type FB7_R = crate::BitReader;
        ///Field `FB7` writer - Filter bits
        pub type FB7_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB8` reader - Filter bits
        pub type FB8_R = crate::BitReader;
        ///Field `FB8` writer - Filter bits
        pub type FB8_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB9` reader - Filter bits
        pub type FB9_R = crate::BitReader;
        ///Field `FB9` writer - Filter bits
        pub type FB9_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB10` reader - Filter bits
        pub type FB10_R = crate::BitReader;
        ///Field `FB10` writer - Filter bits
        pub type FB10_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB11` reader - Filter bits
        pub type FB11_R = crate::BitReader;
        ///Field `FB11` writer - Filter bits
        pub type FB11_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB12` reader - Filter bits
        pub type FB12_R = crate::BitReader;
        ///Field `FB12` writer - Filter bits
        pub type FB12_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB13` reader - Filter bits
        pub type FB13_R = crate::BitReader;
        ///Field `FB13` writer - Filter bits
        pub type FB13_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB14` reader - Filter bits
        pub type FB14_R = crate::BitReader;
        ///Field `FB14` writer - Filter bits
        pub type FB14_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB15` reader - Filter bits
        pub type FB15_R = crate::BitReader;
        ///Field `FB15` writer - Filter bits
        pub type FB15_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB16` reader - Filter bits
        pub type FB16_R = crate::BitReader;
        ///Field `FB16` writer - Filter bits
        pub type FB16_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB17` reader - Filter bits
        pub type FB17_R = crate::BitReader;
        ///Field `FB17` writer - Filter bits
        pub type FB17_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB18` reader - Filter bits
        pub type FB18_R = crate::BitReader;
        ///Field `FB18` writer - Filter bits
        pub type FB18_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB19` reader - Filter bits
        pub type FB19_R = crate::BitReader;
        ///Field `FB19` writer - Filter bits
        pub type FB19_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB20` reader - Filter bits
        pub type FB20_R = crate::BitReader;
        ///Field `FB20` writer - Filter bits
        pub type FB20_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB21` reader - Filter bits
        pub type FB21_R = crate::BitReader;
        ///Field `FB21` writer - Filter bits
        pub type FB21_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB22` reader - Filter bits
        pub type FB22_R = crate::BitReader;
        ///Field `FB22` writer - Filter bits
        pub type FB22_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB23` reader - Filter bits
        pub type FB23_R = crate::BitReader;
        ///Field `FB23` writer - Filter bits
        pub type FB23_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB24` reader - Filter bits
        pub type FB24_R = crate::BitReader;
        ///Field `FB24` writer - Filter bits
        pub type FB24_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB25` reader - Filter bits
        pub type FB25_R = crate::BitReader;
        ///Field `FB25` writer - Filter bits
        pub type FB25_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB26` reader - Filter bits
        pub type FB26_R = crate::BitReader;
        ///Field `FB26` writer - Filter bits
        pub type FB26_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB27` reader - Filter bits
        pub type FB27_R = crate::BitReader;
        ///Field `FB27` writer - Filter bits
        pub type FB27_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB28` reader - Filter bits
        pub type FB28_R = crate::BitReader;
        ///Field `FB28` writer - Filter bits
        pub type FB28_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB29` reader - Filter bits
        pub type FB29_R = crate::BitReader;
        ///Field `FB29` writer - Filter bits
        pub type FB29_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB30` reader - Filter bits
        pub type FB30_R = crate::BitReader;
        ///Field `FB30` writer - Filter bits
        pub type FB30_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB31` reader - Filter bits
        pub type FB31_R = crate::BitReader;
        ///Field `FB31` writer - Filter bits
        pub type FB31_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - Filter bits
            #[inline(always)]
            pub fn fb0(&self) -> FB0_R {
                FB0_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Filter bits
            #[inline(always)]
            pub fn fb1(&self) -> FB1_R {
                FB1_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - Filter bits
            #[inline(always)]
            pub fn fb2(&self) -> FB2_R {
                FB2_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - Filter bits
            #[inline(always)]
            pub fn fb3(&self) -> FB3_R {
                FB3_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - Filter bits
            #[inline(always)]
            pub fn fb4(&self) -> FB4_R {
                FB4_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - Filter bits
            #[inline(always)]
            pub fn fb5(&self) -> FB5_R {
                FB5_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - Filter bits
            #[inline(always)]
            pub fn fb6(&self) -> FB6_R {
                FB6_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - Filter bits
            #[inline(always)]
            pub fn fb7(&self) -> FB7_R {
                FB7_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bit 8 - Filter bits
            #[inline(always)]
            pub fn fb8(&self) -> FB8_R {
                FB8_R::new(((self.bits >> 8) & 1) != 0)
            }
            ///Bit 9 - Filter bits
            #[inline(always)]
            pub fn fb9(&self) -> FB9_R {
                FB9_R::new(((self.bits >> 9) & 1) != 0)
            }
            ///Bit 10 - Filter bits
            #[inline(always)]
            pub fn fb10(&self) -> FB10_R {
                FB10_R::new(((self.bits >> 10) & 1) != 0)
            }
            ///Bit 11 - Filter bits
            #[inline(always)]
            pub fn fb11(&self) -> FB11_R {
                FB11_R::new(((self.bits >> 11) & 1) != 0)
            }
            ///Bit 12 - Filter bits
            #[inline(always)]
            pub fn fb12(&self) -> FB12_R {
                FB12_R::new(((self.bits >> 12) & 1) != 0)
            }
            ///Bit 13 - Filter bits
            #[inline(always)]
            pub fn fb13(&self) -> FB13_R {
                FB13_R::new(((self.bits >> 13) & 1) != 0)
            }
            ///Bit 14 - Filter bits
            #[inline(always)]
            pub fn fb14(&self) -> FB14_R {
                FB14_R::new(((self.bits >> 14) & 1) != 0)
            }
            ///Bit 15 - Filter bits
            #[inline(always)]
            pub fn fb15(&self) -> FB15_R {
                FB15_R::new(((self.bits >> 15) & 1) != 0)
            }
            ///Bit 16 - Filter bits
            #[inline(always)]
            pub fn fb16(&self) -> FB16_R {
                FB16_R::new(((self.bits >> 16) & 1) != 0)
            }
            ///Bit 17 - Filter bits
            #[inline(always)]
            pub fn fb17(&self) -> FB17_R {
                FB17_R::new(((self.bits >> 17) & 1) != 0)
            }
            ///Bit 18 - Filter bits
            #[inline(always)]
            pub fn fb18(&self) -> FB18_R {
                FB18_R::new(((self.bits >> 18) & 1) != 0)
            }
            ///Bit 19 - Filter bits
            #[inline(always)]
            pub fn fb19(&self) -> FB19_R {
                FB19_R::new(((self.bits >> 19) & 1) != 0)
            }
            ///Bit 20 - Filter bits
            #[inline(always)]
            pub fn fb20(&self) -> FB20_R {
                FB20_R::new(((self.bits >> 20) & 1) != 0)
            }
            ///Bit 21 - Filter bits
            #[inline(always)]
            pub fn fb21(&self) -> FB21_R {
                FB21_R::new(((self.bits >> 21) & 1) != 0)
            }
            ///Bit 22 - Filter bits
            #[inline(always)]
            pub fn fb22(&self) -> FB22_R {
                FB22_R::new(((self.bits >> 22) & 1) != 0)
            }
            ///Bit 23 - Filter bits
            #[inline(always)]
            pub fn fb23(&self) -> FB23_R {
                FB23_R::new(((self.bits >> 23) & 1) != 0)
            }
            ///Bit 24 - Filter bits
            #[inline(always)]
            pub fn fb24(&self) -> FB24_R {
                FB24_R::new(((self.bits >> 24) & 1) != 0)
            }
            ///Bit 25 - Filter bits
            #[inline(always)]
            pub fn fb25(&self) -> FB25_R {
                FB25_R::new(((self.bits >> 25) & 1) != 0)
            }
            ///Bit 26 - Filter bits
            #[inline(always)]
            pub fn fb26(&self) -> FB26_R {
                FB26_R::new(((self.bits >> 26) & 1) != 0)
            }
            ///Bit 27 - Filter bits
            #[inline(always)]
            pub fn fb27(&self) -> FB27_R {
                FB27_R::new(((self.bits >> 27) & 1) != 0)
            }
            ///Bit 28 - Filter bits
            #[inline(always)]
            pub fn fb28(&self) -> FB28_R {
                FB28_R::new(((self.bits >> 28) & 1) != 0)
            }
            ///Bit 29 - Filter bits
            #[inline(always)]
            pub fn fb29(&self) -> FB29_R {
                FB29_R::new(((self.bits >> 29) & 1) != 0)
            }
            ///Bit 30 - Filter bits
            #[inline(always)]
            pub fn fb30(&self) -> FB30_R {
                FB30_R::new(((self.bits >> 30) & 1) != 0)
            }
            ///Bit 31 - Filter bits
            #[inline(always)]
            pub fn fb31(&self) -> FB31_R {
                FB31_R::new(((self.bits >> 31) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb0(&mut self) -> FB0_W<F8R2_SPEC> {
                FB0_W::new(self, 0)
            }
            ///Bit 1 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb1(&mut self) -> FB1_W<F8R2_SPEC> {
                FB1_W::new(self, 1)
            }
            ///Bit 2 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb2(&mut self) -> FB2_W<F8R2_SPEC> {
                FB2_W::new(self, 2)
            }
            ///Bit 3 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb3(&mut self) -> FB3_W<F8R2_SPEC> {
                FB3_W::new(self, 3)
            }
            ///Bit 4 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb4(&mut self) -> FB4_W<F8R2_SPEC> {
                FB4_W::new(self, 4)
            }
            ///Bit 5 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb5(&mut self) -> FB5_W<F8R2_SPEC> {
                FB5_W::new(self, 5)
            }
            ///Bit 6 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb6(&mut self) -> FB6_W<F8R2_SPEC> {
                FB6_W::new(self, 6)
            }
            ///Bit 7 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb7(&mut self) -> FB7_W<F8R2_SPEC> {
                FB7_W::new(self, 7)
            }
            ///Bit 8 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb8(&mut self) -> FB8_W<F8R2_SPEC> {
                FB8_W::new(self, 8)
            }
            ///Bit 9 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb9(&mut self) -> FB9_W<F8R2_SPEC> {
                FB9_W::new(self, 9)
            }
            ///Bit 10 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb10(&mut self) -> FB10_W<F8R2_SPEC> {
                FB10_W::new(self, 10)
            }
            ///Bit 11 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb11(&mut self) -> FB11_W<F8R2_SPEC> {
                FB11_W::new(self, 11)
            }
            ///Bit 12 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb12(&mut self) -> FB12_W<F8R2_SPEC> {
                FB12_W::new(self, 12)
            }
            ///Bit 13 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb13(&mut self) -> FB13_W<F8R2_SPEC> {
                FB13_W::new(self, 13)
            }
            ///Bit 14 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb14(&mut self) -> FB14_W<F8R2_SPEC> {
                FB14_W::new(self, 14)
            }
            ///Bit 15 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb15(&mut self) -> FB15_W<F8R2_SPEC> {
                FB15_W::new(self, 15)
            }
            ///Bit 16 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb16(&mut self) -> FB16_W<F8R2_SPEC> {
                FB16_W::new(self, 16)
            }
            ///Bit 17 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb17(&mut self) -> FB17_W<F8R2_SPEC> {
                FB17_W::new(self, 17)
            }
            ///Bit 18 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb18(&mut self) -> FB18_W<F8R2_SPEC> {
                FB18_W::new(self, 18)
            }
            ///Bit 19 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb19(&mut self) -> FB19_W<F8R2_SPEC> {
                FB19_W::new(self, 19)
            }
            ///Bit 20 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb20(&mut self) -> FB20_W<F8R2_SPEC> {
                FB20_W::new(self, 20)
            }
            ///Bit 21 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb21(&mut self) -> FB21_W<F8R2_SPEC> {
                FB21_W::new(self, 21)
            }
            ///Bit 22 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb22(&mut self) -> FB22_W<F8R2_SPEC> {
                FB22_W::new(self, 22)
            }
            ///Bit 23 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb23(&mut self) -> FB23_W<F8R2_SPEC> {
                FB23_W::new(self, 23)
            }
            ///Bit 24 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb24(&mut self) -> FB24_W<F8R2_SPEC> {
                FB24_W::new(self, 24)
            }
            ///Bit 25 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb25(&mut self) -> FB25_W<F8R2_SPEC> {
                FB25_W::new(self, 25)
            }
            ///Bit 26 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb26(&mut self) -> FB26_W<F8R2_SPEC> {
                FB26_W::new(self, 26)
            }
            ///Bit 27 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb27(&mut self) -> FB27_W<F8R2_SPEC> {
                FB27_W::new(self, 27)
            }
            ///Bit 28 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb28(&mut self) -> FB28_W<F8R2_SPEC> {
                FB28_W::new(self, 28)
            }
            ///Bit 29 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb29(&mut self) -> FB29_W<F8R2_SPEC> {
                FB29_W::new(self, 29)
            }
            ///Bit 30 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb30(&mut self) -> FB30_W<F8R2_SPEC> {
                FB30_W::new(self, 30)
            }
            ///Bit 31 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb31(&mut self) -> FB31_W<F8R2_SPEC> {
                FB31_W::new(self, 31)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Filter bank 8 register 2
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`f8r2::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`f8r2::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct F8R2_SPEC;
        impl crate::RegisterSpec for F8R2_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`f8r2::R`](R) reader structure
        impl crate::Readable for F8R2_SPEC {}
        ///`write(|w| ..)` method takes [`f8r2::W`](W) writer structure
        impl crate::Writable for F8R2_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets F8R2 to value 0
        impl crate::Resettable for F8R2_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///F9R1 (rw) register accessor: Filter bank 9 register 1
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`f9r1::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`f9r1::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@f9r1`]
    ///module
    pub type F9R1 = crate::Reg<f9r1::F9R1_SPEC>;
    ///Filter bank 9 register 1
    pub mod f9r1 {
        ///Register `F9R1` reader
        pub type R = crate::R<F9R1_SPEC>;
        ///Register `F9R1` writer
        pub type W = crate::W<F9R1_SPEC>;
        ///Field `FB0` reader - Filter bits
        pub type FB0_R = crate::BitReader;
        ///Field `FB0` writer - Filter bits
        pub type FB0_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB1` reader - Filter bits
        pub type FB1_R = crate::BitReader;
        ///Field `FB1` writer - Filter bits
        pub type FB1_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB2` reader - Filter bits
        pub type FB2_R = crate::BitReader;
        ///Field `FB2` writer - Filter bits
        pub type FB2_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB3` reader - Filter bits
        pub type FB3_R = crate::BitReader;
        ///Field `FB3` writer - Filter bits
        pub type FB3_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB4` reader - Filter bits
        pub type FB4_R = crate::BitReader;
        ///Field `FB4` writer - Filter bits
        pub type FB4_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB5` reader - Filter bits
        pub type FB5_R = crate::BitReader;
        ///Field `FB5` writer - Filter bits
        pub type FB5_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB6` reader - Filter bits
        pub type FB6_R = crate::BitReader;
        ///Field `FB6` writer - Filter bits
        pub type FB6_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB7` reader - Filter bits
        pub type FB7_R = crate::BitReader;
        ///Field `FB7` writer - Filter bits
        pub type FB7_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB8` reader - Filter bits
        pub type FB8_R = crate::BitReader;
        ///Field `FB8` writer - Filter bits
        pub type FB8_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB9` reader - Filter bits
        pub type FB9_R = crate::BitReader;
        ///Field `FB9` writer - Filter bits
        pub type FB9_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB10` reader - Filter bits
        pub type FB10_R = crate::BitReader;
        ///Field `FB10` writer - Filter bits
        pub type FB10_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB11` reader - Filter bits
        pub type FB11_R = crate::BitReader;
        ///Field `FB11` writer - Filter bits
        pub type FB11_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB12` reader - Filter bits
        pub type FB12_R = crate::BitReader;
        ///Field `FB12` writer - Filter bits
        pub type FB12_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB13` reader - Filter bits
        pub type FB13_R = crate::BitReader;
        ///Field `FB13` writer - Filter bits
        pub type FB13_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB14` reader - Filter bits
        pub type FB14_R = crate::BitReader;
        ///Field `FB14` writer - Filter bits
        pub type FB14_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB15` reader - Filter bits
        pub type FB15_R = crate::BitReader;
        ///Field `FB15` writer - Filter bits
        pub type FB15_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB16` reader - Filter bits
        pub type FB16_R = crate::BitReader;
        ///Field `FB16` writer - Filter bits
        pub type FB16_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB17` reader - Filter bits
        pub type FB17_R = crate::BitReader;
        ///Field `FB17` writer - Filter bits
        pub type FB17_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB18` reader - Filter bits
        pub type FB18_R = crate::BitReader;
        ///Field `FB18` writer - Filter bits
        pub type FB18_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB19` reader - Filter bits
        pub type FB19_R = crate::BitReader;
        ///Field `FB19` writer - Filter bits
        pub type FB19_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB20` reader - Filter bits
        pub type FB20_R = crate::BitReader;
        ///Field `FB20` writer - Filter bits
        pub type FB20_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB21` reader - Filter bits
        pub type FB21_R = crate::BitReader;
        ///Field `FB21` writer - Filter bits
        pub type FB21_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB22` reader - Filter bits
        pub type FB22_R = crate::BitReader;
        ///Field `FB22` writer - Filter bits
        pub type FB22_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB23` reader - Filter bits
        pub type FB23_R = crate::BitReader;
        ///Field `FB23` writer - Filter bits
        pub type FB23_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB24` reader - Filter bits
        pub type FB24_R = crate::BitReader;
        ///Field `FB24` writer - Filter bits
        pub type FB24_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB25` reader - Filter bits
        pub type FB25_R = crate::BitReader;
        ///Field `FB25` writer - Filter bits
        pub type FB25_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB26` reader - Filter bits
        pub type FB26_R = crate::BitReader;
        ///Field `FB26` writer - Filter bits
        pub type FB26_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB27` reader - Filter bits
        pub type FB27_R = crate::BitReader;
        ///Field `FB27` writer - Filter bits
        pub type FB27_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB28` reader - Filter bits
        pub type FB28_R = crate::BitReader;
        ///Field `FB28` writer - Filter bits
        pub type FB28_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB29` reader - Filter bits
        pub type FB29_R = crate::BitReader;
        ///Field `FB29` writer - Filter bits
        pub type FB29_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB30` reader - Filter bits
        pub type FB30_R = crate::BitReader;
        ///Field `FB30` writer - Filter bits
        pub type FB30_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB31` reader - Filter bits
        pub type FB31_R = crate::BitReader;
        ///Field `FB31` writer - Filter bits
        pub type FB31_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - Filter bits
            #[inline(always)]
            pub fn fb0(&self) -> FB0_R {
                FB0_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Filter bits
            #[inline(always)]
            pub fn fb1(&self) -> FB1_R {
                FB1_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - Filter bits
            #[inline(always)]
            pub fn fb2(&self) -> FB2_R {
                FB2_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - Filter bits
            #[inline(always)]
            pub fn fb3(&self) -> FB3_R {
                FB3_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - Filter bits
            #[inline(always)]
            pub fn fb4(&self) -> FB4_R {
                FB4_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - Filter bits
            #[inline(always)]
            pub fn fb5(&self) -> FB5_R {
                FB5_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - Filter bits
            #[inline(always)]
            pub fn fb6(&self) -> FB6_R {
                FB6_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - Filter bits
            #[inline(always)]
            pub fn fb7(&self) -> FB7_R {
                FB7_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bit 8 - Filter bits
            #[inline(always)]
            pub fn fb8(&self) -> FB8_R {
                FB8_R::new(((self.bits >> 8) & 1) != 0)
            }
            ///Bit 9 - Filter bits
            #[inline(always)]
            pub fn fb9(&self) -> FB9_R {
                FB9_R::new(((self.bits >> 9) & 1) != 0)
            }
            ///Bit 10 - Filter bits
            #[inline(always)]
            pub fn fb10(&self) -> FB10_R {
                FB10_R::new(((self.bits >> 10) & 1) != 0)
            }
            ///Bit 11 - Filter bits
            #[inline(always)]
            pub fn fb11(&self) -> FB11_R {
                FB11_R::new(((self.bits >> 11) & 1) != 0)
            }
            ///Bit 12 - Filter bits
            #[inline(always)]
            pub fn fb12(&self) -> FB12_R {
                FB12_R::new(((self.bits >> 12) & 1) != 0)
            }
            ///Bit 13 - Filter bits
            #[inline(always)]
            pub fn fb13(&self) -> FB13_R {
                FB13_R::new(((self.bits >> 13) & 1) != 0)
            }
            ///Bit 14 - Filter bits
            #[inline(always)]
            pub fn fb14(&self) -> FB14_R {
                FB14_R::new(((self.bits >> 14) & 1) != 0)
            }
            ///Bit 15 - Filter bits
            #[inline(always)]
            pub fn fb15(&self) -> FB15_R {
                FB15_R::new(((self.bits >> 15) & 1) != 0)
            }
            ///Bit 16 - Filter bits
            #[inline(always)]
            pub fn fb16(&self) -> FB16_R {
                FB16_R::new(((self.bits >> 16) & 1) != 0)
            }
            ///Bit 17 - Filter bits
            #[inline(always)]
            pub fn fb17(&self) -> FB17_R {
                FB17_R::new(((self.bits >> 17) & 1) != 0)
            }
            ///Bit 18 - Filter bits
            #[inline(always)]
            pub fn fb18(&self) -> FB18_R {
                FB18_R::new(((self.bits >> 18) & 1) != 0)
            }
            ///Bit 19 - Filter bits
            #[inline(always)]
            pub fn fb19(&self) -> FB19_R {
                FB19_R::new(((self.bits >> 19) & 1) != 0)
            }
            ///Bit 20 - Filter bits
            #[inline(always)]
            pub fn fb20(&self) -> FB20_R {
                FB20_R::new(((self.bits >> 20) & 1) != 0)
            }
            ///Bit 21 - Filter bits
            #[inline(always)]
            pub fn fb21(&self) -> FB21_R {
                FB21_R::new(((self.bits >> 21) & 1) != 0)
            }
            ///Bit 22 - Filter bits
            #[inline(always)]
            pub fn fb22(&self) -> FB22_R {
                FB22_R::new(((self.bits >> 22) & 1) != 0)
            }
            ///Bit 23 - Filter bits
            #[inline(always)]
            pub fn fb23(&self) -> FB23_R {
                FB23_R::new(((self.bits >> 23) & 1) != 0)
            }
            ///Bit 24 - Filter bits
            #[inline(always)]
            pub fn fb24(&self) -> FB24_R {
                FB24_R::new(((self.bits >> 24) & 1) != 0)
            }
            ///Bit 25 - Filter bits
            #[inline(always)]
            pub fn fb25(&self) -> FB25_R {
                FB25_R::new(((self.bits >> 25) & 1) != 0)
            }
            ///Bit 26 - Filter bits
            #[inline(always)]
            pub fn fb26(&self) -> FB26_R {
                FB26_R::new(((self.bits >> 26) & 1) != 0)
            }
            ///Bit 27 - Filter bits
            #[inline(always)]
            pub fn fb27(&self) -> FB27_R {
                FB27_R::new(((self.bits >> 27) & 1) != 0)
            }
            ///Bit 28 - Filter bits
            #[inline(always)]
            pub fn fb28(&self) -> FB28_R {
                FB28_R::new(((self.bits >> 28) & 1) != 0)
            }
            ///Bit 29 - Filter bits
            #[inline(always)]
            pub fn fb29(&self) -> FB29_R {
                FB29_R::new(((self.bits >> 29) & 1) != 0)
            }
            ///Bit 30 - Filter bits
            #[inline(always)]
            pub fn fb30(&self) -> FB30_R {
                FB30_R::new(((self.bits >> 30) & 1) != 0)
            }
            ///Bit 31 - Filter bits
            #[inline(always)]
            pub fn fb31(&self) -> FB31_R {
                FB31_R::new(((self.bits >> 31) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb0(&mut self) -> FB0_W<F9R1_SPEC> {
                FB0_W::new(self, 0)
            }
            ///Bit 1 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb1(&mut self) -> FB1_W<F9R1_SPEC> {
                FB1_W::new(self, 1)
            }
            ///Bit 2 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb2(&mut self) -> FB2_W<F9R1_SPEC> {
                FB2_W::new(self, 2)
            }
            ///Bit 3 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb3(&mut self) -> FB3_W<F9R1_SPEC> {
                FB3_W::new(self, 3)
            }
            ///Bit 4 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb4(&mut self) -> FB4_W<F9R1_SPEC> {
                FB4_W::new(self, 4)
            }
            ///Bit 5 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb5(&mut self) -> FB5_W<F9R1_SPEC> {
                FB5_W::new(self, 5)
            }
            ///Bit 6 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb6(&mut self) -> FB6_W<F9R1_SPEC> {
                FB6_W::new(self, 6)
            }
            ///Bit 7 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb7(&mut self) -> FB7_W<F9R1_SPEC> {
                FB7_W::new(self, 7)
            }
            ///Bit 8 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb8(&mut self) -> FB8_W<F9R1_SPEC> {
                FB8_W::new(self, 8)
            }
            ///Bit 9 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb9(&mut self) -> FB9_W<F9R1_SPEC> {
                FB9_W::new(self, 9)
            }
            ///Bit 10 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb10(&mut self) -> FB10_W<F9R1_SPEC> {
                FB10_W::new(self, 10)
            }
            ///Bit 11 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb11(&mut self) -> FB11_W<F9R1_SPEC> {
                FB11_W::new(self, 11)
            }
            ///Bit 12 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb12(&mut self) -> FB12_W<F9R1_SPEC> {
                FB12_W::new(self, 12)
            }
            ///Bit 13 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb13(&mut self) -> FB13_W<F9R1_SPEC> {
                FB13_W::new(self, 13)
            }
            ///Bit 14 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb14(&mut self) -> FB14_W<F9R1_SPEC> {
                FB14_W::new(self, 14)
            }
            ///Bit 15 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb15(&mut self) -> FB15_W<F9R1_SPEC> {
                FB15_W::new(self, 15)
            }
            ///Bit 16 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb16(&mut self) -> FB16_W<F9R1_SPEC> {
                FB16_W::new(self, 16)
            }
            ///Bit 17 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb17(&mut self) -> FB17_W<F9R1_SPEC> {
                FB17_W::new(self, 17)
            }
            ///Bit 18 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb18(&mut self) -> FB18_W<F9R1_SPEC> {
                FB18_W::new(self, 18)
            }
            ///Bit 19 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb19(&mut self) -> FB19_W<F9R1_SPEC> {
                FB19_W::new(self, 19)
            }
            ///Bit 20 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb20(&mut self) -> FB20_W<F9R1_SPEC> {
                FB20_W::new(self, 20)
            }
            ///Bit 21 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb21(&mut self) -> FB21_W<F9R1_SPEC> {
                FB21_W::new(self, 21)
            }
            ///Bit 22 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb22(&mut self) -> FB22_W<F9R1_SPEC> {
                FB22_W::new(self, 22)
            }
            ///Bit 23 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb23(&mut self) -> FB23_W<F9R1_SPEC> {
                FB23_W::new(self, 23)
            }
            ///Bit 24 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb24(&mut self) -> FB24_W<F9R1_SPEC> {
                FB24_W::new(self, 24)
            }
            ///Bit 25 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb25(&mut self) -> FB25_W<F9R1_SPEC> {
                FB25_W::new(self, 25)
            }
            ///Bit 26 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb26(&mut self) -> FB26_W<F9R1_SPEC> {
                FB26_W::new(self, 26)
            }
            ///Bit 27 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb27(&mut self) -> FB27_W<F9R1_SPEC> {
                FB27_W::new(self, 27)
            }
            ///Bit 28 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb28(&mut self) -> FB28_W<F9R1_SPEC> {
                FB28_W::new(self, 28)
            }
            ///Bit 29 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb29(&mut self) -> FB29_W<F9R1_SPEC> {
                FB29_W::new(self, 29)
            }
            ///Bit 30 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb30(&mut self) -> FB30_W<F9R1_SPEC> {
                FB30_W::new(self, 30)
            }
            ///Bit 31 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb31(&mut self) -> FB31_W<F9R1_SPEC> {
                FB31_W::new(self, 31)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Filter bank 9 register 1
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`f9r1::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`f9r1::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct F9R1_SPEC;
        impl crate::RegisterSpec for F9R1_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`f9r1::R`](R) reader structure
        impl crate::Readable for F9R1_SPEC {}
        ///`write(|w| ..)` method takes [`f9r1::W`](W) writer structure
        impl crate::Writable for F9R1_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets F9R1 to value 0
        impl crate::Resettable for F9R1_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///F9R2 (rw) register accessor: Filter bank 9 register 2
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`f9r2::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`f9r2::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@f9r2`]
    ///module
    pub type F9R2 = crate::Reg<f9r2::F9R2_SPEC>;
    ///Filter bank 9 register 2
    pub mod f9r2 {
        ///Register `F9R2` reader
        pub type R = crate::R<F9R2_SPEC>;
        ///Register `F9R2` writer
        pub type W = crate::W<F9R2_SPEC>;
        ///Field `FB0` reader - Filter bits
        pub type FB0_R = crate::BitReader;
        ///Field `FB0` writer - Filter bits
        pub type FB0_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB1` reader - Filter bits
        pub type FB1_R = crate::BitReader;
        ///Field `FB1` writer - Filter bits
        pub type FB1_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB2` reader - Filter bits
        pub type FB2_R = crate::BitReader;
        ///Field `FB2` writer - Filter bits
        pub type FB2_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB3` reader - Filter bits
        pub type FB3_R = crate::BitReader;
        ///Field `FB3` writer - Filter bits
        pub type FB3_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB4` reader - Filter bits
        pub type FB4_R = crate::BitReader;
        ///Field `FB4` writer - Filter bits
        pub type FB4_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB5` reader - Filter bits
        pub type FB5_R = crate::BitReader;
        ///Field `FB5` writer - Filter bits
        pub type FB5_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB6` reader - Filter bits
        pub type FB6_R = crate::BitReader;
        ///Field `FB6` writer - Filter bits
        pub type FB6_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB7` reader - Filter bits
        pub type FB7_R = crate::BitReader;
        ///Field `FB7` writer - Filter bits
        pub type FB7_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB8` reader - Filter bits
        pub type FB8_R = crate::BitReader;
        ///Field `FB8` writer - Filter bits
        pub type FB8_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB9` reader - Filter bits
        pub type FB9_R = crate::BitReader;
        ///Field `FB9` writer - Filter bits
        pub type FB9_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB10` reader - Filter bits
        pub type FB10_R = crate::BitReader;
        ///Field `FB10` writer - Filter bits
        pub type FB10_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB11` reader - Filter bits
        pub type FB11_R = crate::BitReader;
        ///Field `FB11` writer - Filter bits
        pub type FB11_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB12` reader - Filter bits
        pub type FB12_R = crate::BitReader;
        ///Field `FB12` writer - Filter bits
        pub type FB12_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB13` reader - Filter bits
        pub type FB13_R = crate::BitReader;
        ///Field `FB13` writer - Filter bits
        pub type FB13_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB14` reader - Filter bits
        pub type FB14_R = crate::BitReader;
        ///Field `FB14` writer - Filter bits
        pub type FB14_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB15` reader - Filter bits
        pub type FB15_R = crate::BitReader;
        ///Field `FB15` writer - Filter bits
        pub type FB15_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB16` reader - Filter bits
        pub type FB16_R = crate::BitReader;
        ///Field `FB16` writer - Filter bits
        pub type FB16_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB17` reader - Filter bits
        pub type FB17_R = crate::BitReader;
        ///Field `FB17` writer - Filter bits
        pub type FB17_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB18` reader - Filter bits
        pub type FB18_R = crate::BitReader;
        ///Field `FB18` writer - Filter bits
        pub type FB18_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB19` reader - Filter bits
        pub type FB19_R = crate::BitReader;
        ///Field `FB19` writer - Filter bits
        pub type FB19_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB20` reader - Filter bits
        pub type FB20_R = crate::BitReader;
        ///Field `FB20` writer - Filter bits
        pub type FB20_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB21` reader - Filter bits
        pub type FB21_R = crate::BitReader;
        ///Field `FB21` writer - Filter bits
        pub type FB21_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB22` reader - Filter bits
        pub type FB22_R = crate::BitReader;
        ///Field `FB22` writer - Filter bits
        pub type FB22_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB23` reader - Filter bits
        pub type FB23_R = crate::BitReader;
        ///Field `FB23` writer - Filter bits
        pub type FB23_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB24` reader - Filter bits
        pub type FB24_R = crate::BitReader;
        ///Field `FB24` writer - Filter bits
        pub type FB24_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB25` reader - Filter bits
        pub type FB25_R = crate::BitReader;
        ///Field `FB25` writer - Filter bits
        pub type FB25_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB26` reader - Filter bits
        pub type FB26_R = crate::BitReader;
        ///Field `FB26` writer - Filter bits
        pub type FB26_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB27` reader - Filter bits
        pub type FB27_R = crate::BitReader;
        ///Field `FB27` writer - Filter bits
        pub type FB27_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB28` reader - Filter bits
        pub type FB28_R = crate::BitReader;
        ///Field `FB28` writer - Filter bits
        pub type FB28_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB29` reader - Filter bits
        pub type FB29_R = crate::BitReader;
        ///Field `FB29` writer - Filter bits
        pub type FB29_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB30` reader - Filter bits
        pub type FB30_R = crate::BitReader;
        ///Field `FB30` writer - Filter bits
        pub type FB30_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB31` reader - Filter bits
        pub type FB31_R = crate::BitReader;
        ///Field `FB31` writer - Filter bits
        pub type FB31_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - Filter bits
            #[inline(always)]
            pub fn fb0(&self) -> FB0_R {
                FB0_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Filter bits
            #[inline(always)]
            pub fn fb1(&self) -> FB1_R {
                FB1_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - Filter bits
            #[inline(always)]
            pub fn fb2(&self) -> FB2_R {
                FB2_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - Filter bits
            #[inline(always)]
            pub fn fb3(&self) -> FB3_R {
                FB3_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - Filter bits
            #[inline(always)]
            pub fn fb4(&self) -> FB4_R {
                FB4_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - Filter bits
            #[inline(always)]
            pub fn fb5(&self) -> FB5_R {
                FB5_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - Filter bits
            #[inline(always)]
            pub fn fb6(&self) -> FB6_R {
                FB6_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - Filter bits
            #[inline(always)]
            pub fn fb7(&self) -> FB7_R {
                FB7_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bit 8 - Filter bits
            #[inline(always)]
            pub fn fb8(&self) -> FB8_R {
                FB8_R::new(((self.bits >> 8) & 1) != 0)
            }
            ///Bit 9 - Filter bits
            #[inline(always)]
            pub fn fb9(&self) -> FB9_R {
                FB9_R::new(((self.bits >> 9) & 1) != 0)
            }
            ///Bit 10 - Filter bits
            #[inline(always)]
            pub fn fb10(&self) -> FB10_R {
                FB10_R::new(((self.bits >> 10) & 1) != 0)
            }
            ///Bit 11 - Filter bits
            #[inline(always)]
            pub fn fb11(&self) -> FB11_R {
                FB11_R::new(((self.bits >> 11) & 1) != 0)
            }
            ///Bit 12 - Filter bits
            #[inline(always)]
            pub fn fb12(&self) -> FB12_R {
                FB12_R::new(((self.bits >> 12) & 1) != 0)
            }
            ///Bit 13 - Filter bits
            #[inline(always)]
            pub fn fb13(&self) -> FB13_R {
                FB13_R::new(((self.bits >> 13) & 1) != 0)
            }
            ///Bit 14 - Filter bits
            #[inline(always)]
            pub fn fb14(&self) -> FB14_R {
                FB14_R::new(((self.bits >> 14) & 1) != 0)
            }
            ///Bit 15 - Filter bits
            #[inline(always)]
            pub fn fb15(&self) -> FB15_R {
                FB15_R::new(((self.bits >> 15) & 1) != 0)
            }
            ///Bit 16 - Filter bits
            #[inline(always)]
            pub fn fb16(&self) -> FB16_R {
                FB16_R::new(((self.bits >> 16) & 1) != 0)
            }
            ///Bit 17 - Filter bits
            #[inline(always)]
            pub fn fb17(&self) -> FB17_R {
                FB17_R::new(((self.bits >> 17) & 1) != 0)
            }
            ///Bit 18 - Filter bits
            #[inline(always)]
            pub fn fb18(&self) -> FB18_R {
                FB18_R::new(((self.bits >> 18) & 1) != 0)
            }
            ///Bit 19 - Filter bits
            #[inline(always)]
            pub fn fb19(&self) -> FB19_R {
                FB19_R::new(((self.bits >> 19) & 1) != 0)
            }
            ///Bit 20 - Filter bits
            #[inline(always)]
            pub fn fb20(&self) -> FB20_R {
                FB20_R::new(((self.bits >> 20) & 1) != 0)
            }
            ///Bit 21 - Filter bits
            #[inline(always)]
            pub fn fb21(&self) -> FB21_R {
                FB21_R::new(((self.bits >> 21) & 1) != 0)
            }
            ///Bit 22 - Filter bits
            #[inline(always)]
            pub fn fb22(&self) -> FB22_R {
                FB22_R::new(((self.bits >> 22) & 1) != 0)
            }
            ///Bit 23 - Filter bits
            #[inline(always)]
            pub fn fb23(&self) -> FB23_R {
                FB23_R::new(((self.bits >> 23) & 1) != 0)
            }
            ///Bit 24 - Filter bits
            #[inline(always)]
            pub fn fb24(&self) -> FB24_R {
                FB24_R::new(((self.bits >> 24) & 1) != 0)
            }
            ///Bit 25 - Filter bits
            #[inline(always)]
            pub fn fb25(&self) -> FB25_R {
                FB25_R::new(((self.bits >> 25) & 1) != 0)
            }
            ///Bit 26 - Filter bits
            #[inline(always)]
            pub fn fb26(&self) -> FB26_R {
                FB26_R::new(((self.bits >> 26) & 1) != 0)
            }
            ///Bit 27 - Filter bits
            #[inline(always)]
            pub fn fb27(&self) -> FB27_R {
                FB27_R::new(((self.bits >> 27) & 1) != 0)
            }
            ///Bit 28 - Filter bits
            #[inline(always)]
            pub fn fb28(&self) -> FB28_R {
                FB28_R::new(((self.bits >> 28) & 1) != 0)
            }
            ///Bit 29 - Filter bits
            #[inline(always)]
            pub fn fb29(&self) -> FB29_R {
                FB29_R::new(((self.bits >> 29) & 1) != 0)
            }
            ///Bit 30 - Filter bits
            #[inline(always)]
            pub fn fb30(&self) -> FB30_R {
                FB30_R::new(((self.bits >> 30) & 1) != 0)
            }
            ///Bit 31 - Filter bits
            #[inline(always)]
            pub fn fb31(&self) -> FB31_R {
                FB31_R::new(((self.bits >> 31) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb0(&mut self) -> FB0_W<F9R2_SPEC> {
                FB0_W::new(self, 0)
            }
            ///Bit 1 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb1(&mut self) -> FB1_W<F9R2_SPEC> {
                FB1_W::new(self, 1)
            }
            ///Bit 2 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb2(&mut self) -> FB2_W<F9R2_SPEC> {
                FB2_W::new(self, 2)
            }
            ///Bit 3 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb3(&mut self) -> FB3_W<F9R2_SPEC> {
                FB3_W::new(self, 3)
            }
            ///Bit 4 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb4(&mut self) -> FB4_W<F9R2_SPEC> {
                FB4_W::new(self, 4)
            }
            ///Bit 5 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb5(&mut self) -> FB5_W<F9R2_SPEC> {
                FB5_W::new(self, 5)
            }
            ///Bit 6 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb6(&mut self) -> FB6_W<F9R2_SPEC> {
                FB6_W::new(self, 6)
            }
            ///Bit 7 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb7(&mut self) -> FB7_W<F9R2_SPEC> {
                FB7_W::new(self, 7)
            }
            ///Bit 8 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb8(&mut self) -> FB8_W<F9R2_SPEC> {
                FB8_W::new(self, 8)
            }
            ///Bit 9 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb9(&mut self) -> FB9_W<F9R2_SPEC> {
                FB9_W::new(self, 9)
            }
            ///Bit 10 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb10(&mut self) -> FB10_W<F9R2_SPEC> {
                FB10_W::new(self, 10)
            }
            ///Bit 11 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb11(&mut self) -> FB11_W<F9R2_SPEC> {
                FB11_W::new(self, 11)
            }
            ///Bit 12 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb12(&mut self) -> FB12_W<F9R2_SPEC> {
                FB12_W::new(self, 12)
            }
            ///Bit 13 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb13(&mut self) -> FB13_W<F9R2_SPEC> {
                FB13_W::new(self, 13)
            }
            ///Bit 14 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb14(&mut self) -> FB14_W<F9R2_SPEC> {
                FB14_W::new(self, 14)
            }
            ///Bit 15 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb15(&mut self) -> FB15_W<F9R2_SPEC> {
                FB15_W::new(self, 15)
            }
            ///Bit 16 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb16(&mut self) -> FB16_W<F9R2_SPEC> {
                FB16_W::new(self, 16)
            }
            ///Bit 17 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb17(&mut self) -> FB17_W<F9R2_SPEC> {
                FB17_W::new(self, 17)
            }
            ///Bit 18 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb18(&mut self) -> FB18_W<F9R2_SPEC> {
                FB18_W::new(self, 18)
            }
            ///Bit 19 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb19(&mut self) -> FB19_W<F9R2_SPEC> {
                FB19_W::new(self, 19)
            }
            ///Bit 20 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb20(&mut self) -> FB20_W<F9R2_SPEC> {
                FB20_W::new(self, 20)
            }
            ///Bit 21 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb21(&mut self) -> FB21_W<F9R2_SPEC> {
                FB21_W::new(self, 21)
            }
            ///Bit 22 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb22(&mut self) -> FB22_W<F9R2_SPEC> {
                FB22_W::new(self, 22)
            }
            ///Bit 23 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb23(&mut self) -> FB23_W<F9R2_SPEC> {
                FB23_W::new(self, 23)
            }
            ///Bit 24 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb24(&mut self) -> FB24_W<F9R2_SPEC> {
                FB24_W::new(self, 24)
            }
            ///Bit 25 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb25(&mut self) -> FB25_W<F9R2_SPEC> {
                FB25_W::new(self, 25)
            }
            ///Bit 26 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb26(&mut self) -> FB26_W<F9R2_SPEC> {
                FB26_W::new(self, 26)
            }
            ///Bit 27 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb27(&mut self) -> FB27_W<F9R2_SPEC> {
                FB27_W::new(self, 27)
            }
            ///Bit 28 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb28(&mut self) -> FB28_W<F9R2_SPEC> {
                FB28_W::new(self, 28)
            }
            ///Bit 29 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb29(&mut self) -> FB29_W<F9R2_SPEC> {
                FB29_W::new(self, 29)
            }
            ///Bit 30 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb30(&mut self) -> FB30_W<F9R2_SPEC> {
                FB30_W::new(self, 30)
            }
            ///Bit 31 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb31(&mut self) -> FB31_W<F9R2_SPEC> {
                FB31_W::new(self, 31)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Filter bank 9 register 2
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`f9r2::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`f9r2::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct F9R2_SPEC;
        impl crate::RegisterSpec for F9R2_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`f9r2::R`](R) reader structure
        impl crate::Readable for F9R2_SPEC {}
        ///`write(|w| ..)` method takes [`f9r2::W`](W) writer structure
        impl crate::Writable for F9R2_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets F9R2 to value 0
        impl crate::Resettable for F9R2_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///F10R1 (rw) register accessor: Filter bank 10 register 1
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`f10r1::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`f10r1::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@f10r1`]
    ///module
    pub type F10R1 = crate::Reg<f10r1::F10R1_SPEC>;
    ///Filter bank 10 register 1
    pub mod f10r1 {
        ///Register `F10R1` reader
        pub type R = crate::R<F10R1_SPEC>;
        ///Register `F10R1` writer
        pub type W = crate::W<F10R1_SPEC>;
        ///Field `FB0` reader - Filter bits
        pub type FB0_R = crate::BitReader;
        ///Field `FB0` writer - Filter bits
        pub type FB0_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB1` reader - Filter bits
        pub type FB1_R = crate::BitReader;
        ///Field `FB1` writer - Filter bits
        pub type FB1_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB2` reader - Filter bits
        pub type FB2_R = crate::BitReader;
        ///Field `FB2` writer - Filter bits
        pub type FB2_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB3` reader - Filter bits
        pub type FB3_R = crate::BitReader;
        ///Field `FB3` writer - Filter bits
        pub type FB3_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB4` reader - Filter bits
        pub type FB4_R = crate::BitReader;
        ///Field `FB4` writer - Filter bits
        pub type FB4_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB5` reader - Filter bits
        pub type FB5_R = crate::BitReader;
        ///Field `FB5` writer - Filter bits
        pub type FB5_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB6` reader - Filter bits
        pub type FB6_R = crate::BitReader;
        ///Field `FB6` writer - Filter bits
        pub type FB6_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB7` reader - Filter bits
        pub type FB7_R = crate::BitReader;
        ///Field `FB7` writer - Filter bits
        pub type FB7_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB8` reader - Filter bits
        pub type FB8_R = crate::BitReader;
        ///Field `FB8` writer - Filter bits
        pub type FB8_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB9` reader - Filter bits
        pub type FB9_R = crate::BitReader;
        ///Field `FB9` writer - Filter bits
        pub type FB9_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB10` reader - Filter bits
        pub type FB10_R = crate::BitReader;
        ///Field `FB10` writer - Filter bits
        pub type FB10_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB11` reader - Filter bits
        pub type FB11_R = crate::BitReader;
        ///Field `FB11` writer - Filter bits
        pub type FB11_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB12` reader - Filter bits
        pub type FB12_R = crate::BitReader;
        ///Field `FB12` writer - Filter bits
        pub type FB12_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB13` reader - Filter bits
        pub type FB13_R = crate::BitReader;
        ///Field `FB13` writer - Filter bits
        pub type FB13_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB14` reader - Filter bits
        pub type FB14_R = crate::BitReader;
        ///Field `FB14` writer - Filter bits
        pub type FB14_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB15` reader - Filter bits
        pub type FB15_R = crate::BitReader;
        ///Field `FB15` writer - Filter bits
        pub type FB15_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB16` reader - Filter bits
        pub type FB16_R = crate::BitReader;
        ///Field `FB16` writer - Filter bits
        pub type FB16_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB17` reader - Filter bits
        pub type FB17_R = crate::BitReader;
        ///Field `FB17` writer - Filter bits
        pub type FB17_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB18` reader - Filter bits
        pub type FB18_R = crate::BitReader;
        ///Field `FB18` writer - Filter bits
        pub type FB18_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB19` reader - Filter bits
        pub type FB19_R = crate::BitReader;
        ///Field `FB19` writer - Filter bits
        pub type FB19_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB20` reader - Filter bits
        pub type FB20_R = crate::BitReader;
        ///Field `FB20` writer - Filter bits
        pub type FB20_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB21` reader - Filter bits
        pub type FB21_R = crate::BitReader;
        ///Field `FB21` writer - Filter bits
        pub type FB21_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB22` reader - Filter bits
        pub type FB22_R = crate::BitReader;
        ///Field `FB22` writer - Filter bits
        pub type FB22_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB23` reader - Filter bits
        pub type FB23_R = crate::BitReader;
        ///Field `FB23` writer - Filter bits
        pub type FB23_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB24` reader - Filter bits
        pub type FB24_R = crate::BitReader;
        ///Field `FB24` writer - Filter bits
        pub type FB24_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB25` reader - Filter bits
        pub type FB25_R = crate::BitReader;
        ///Field `FB25` writer - Filter bits
        pub type FB25_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB26` reader - Filter bits
        pub type FB26_R = crate::BitReader;
        ///Field `FB26` writer - Filter bits
        pub type FB26_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB27` reader - Filter bits
        pub type FB27_R = crate::BitReader;
        ///Field `FB27` writer - Filter bits
        pub type FB27_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB28` reader - Filter bits
        pub type FB28_R = crate::BitReader;
        ///Field `FB28` writer - Filter bits
        pub type FB28_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB29` reader - Filter bits
        pub type FB29_R = crate::BitReader;
        ///Field `FB29` writer - Filter bits
        pub type FB29_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB30` reader - Filter bits
        pub type FB30_R = crate::BitReader;
        ///Field `FB30` writer - Filter bits
        pub type FB30_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB31` reader - Filter bits
        pub type FB31_R = crate::BitReader;
        ///Field `FB31` writer - Filter bits
        pub type FB31_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - Filter bits
            #[inline(always)]
            pub fn fb0(&self) -> FB0_R {
                FB0_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Filter bits
            #[inline(always)]
            pub fn fb1(&self) -> FB1_R {
                FB1_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - Filter bits
            #[inline(always)]
            pub fn fb2(&self) -> FB2_R {
                FB2_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - Filter bits
            #[inline(always)]
            pub fn fb3(&self) -> FB3_R {
                FB3_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - Filter bits
            #[inline(always)]
            pub fn fb4(&self) -> FB4_R {
                FB4_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - Filter bits
            #[inline(always)]
            pub fn fb5(&self) -> FB5_R {
                FB5_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - Filter bits
            #[inline(always)]
            pub fn fb6(&self) -> FB6_R {
                FB6_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - Filter bits
            #[inline(always)]
            pub fn fb7(&self) -> FB7_R {
                FB7_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bit 8 - Filter bits
            #[inline(always)]
            pub fn fb8(&self) -> FB8_R {
                FB8_R::new(((self.bits >> 8) & 1) != 0)
            }
            ///Bit 9 - Filter bits
            #[inline(always)]
            pub fn fb9(&self) -> FB9_R {
                FB9_R::new(((self.bits >> 9) & 1) != 0)
            }
            ///Bit 10 - Filter bits
            #[inline(always)]
            pub fn fb10(&self) -> FB10_R {
                FB10_R::new(((self.bits >> 10) & 1) != 0)
            }
            ///Bit 11 - Filter bits
            #[inline(always)]
            pub fn fb11(&self) -> FB11_R {
                FB11_R::new(((self.bits >> 11) & 1) != 0)
            }
            ///Bit 12 - Filter bits
            #[inline(always)]
            pub fn fb12(&self) -> FB12_R {
                FB12_R::new(((self.bits >> 12) & 1) != 0)
            }
            ///Bit 13 - Filter bits
            #[inline(always)]
            pub fn fb13(&self) -> FB13_R {
                FB13_R::new(((self.bits >> 13) & 1) != 0)
            }
            ///Bit 14 - Filter bits
            #[inline(always)]
            pub fn fb14(&self) -> FB14_R {
                FB14_R::new(((self.bits >> 14) & 1) != 0)
            }
            ///Bit 15 - Filter bits
            #[inline(always)]
            pub fn fb15(&self) -> FB15_R {
                FB15_R::new(((self.bits >> 15) & 1) != 0)
            }
            ///Bit 16 - Filter bits
            #[inline(always)]
            pub fn fb16(&self) -> FB16_R {
                FB16_R::new(((self.bits >> 16) & 1) != 0)
            }
            ///Bit 17 - Filter bits
            #[inline(always)]
            pub fn fb17(&self) -> FB17_R {
                FB17_R::new(((self.bits >> 17) & 1) != 0)
            }
            ///Bit 18 - Filter bits
            #[inline(always)]
            pub fn fb18(&self) -> FB18_R {
                FB18_R::new(((self.bits >> 18) & 1) != 0)
            }
            ///Bit 19 - Filter bits
            #[inline(always)]
            pub fn fb19(&self) -> FB19_R {
                FB19_R::new(((self.bits >> 19) & 1) != 0)
            }
            ///Bit 20 - Filter bits
            #[inline(always)]
            pub fn fb20(&self) -> FB20_R {
                FB20_R::new(((self.bits >> 20) & 1) != 0)
            }
            ///Bit 21 - Filter bits
            #[inline(always)]
            pub fn fb21(&self) -> FB21_R {
                FB21_R::new(((self.bits >> 21) & 1) != 0)
            }
            ///Bit 22 - Filter bits
            #[inline(always)]
            pub fn fb22(&self) -> FB22_R {
                FB22_R::new(((self.bits >> 22) & 1) != 0)
            }
            ///Bit 23 - Filter bits
            #[inline(always)]
            pub fn fb23(&self) -> FB23_R {
                FB23_R::new(((self.bits >> 23) & 1) != 0)
            }
            ///Bit 24 - Filter bits
            #[inline(always)]
            pub fn fb24(&self) -> FB24_R {
                FB24_R::new(((self.bits >> 24) & 1) != 0)
            }
            ///Bit 25 - Filter bits
            #[inline(always)]
            pub fn fb25(&self) -> FB25_R {
                FB25_R::new(((self.bits >> 25) & 1) != 0)
            }
            ///Bit 26 - Filter bits
            #[inline(always)]
            pub fn fb26(&self) -> FB26_R {
                FB26_R::new(((self.bits >> 26) & 1) != 0)
            }
            ///Bit 27 - Filter bits
            #[inline(always)]
            pub fn fb27(&self) -> FB27_R {
                FB27_R::new(((self.bits >> 27) & 1) != 0)
            }
            ///Bit 28 - Filter bits
            #[inline(always)]
            pub fn fb28(&self) -> FB28_R {
                FB28_R::new(((self.bits >> 28) & 1) != 0)
            }
            ///Bit 29 - Filter bits
            #[inline(always)]
            pub fn fb29(&self) -> FB29_R {
                FB29_R::new(((self.bits >> 29) & 1) != 0)
            }
            ///Bit 30 - Filter bits
            #[inline(always)]
            pub fn fb30(&self) -> FB30_R {
                FB30_R::new(((self.bits >> 30) & 1) != 0)
            }
            ///Bit 31 - Filter bits
            #[inline(always)]
            pub fn fb31(&self) -> FB31_R {
                FB31_R::new(((self.bits >> 31) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb0(&mut self) -> FB0_W<F10R1_SPEC> {
                FB0_W::new(self, 0)
            }
            ///Bit 1 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb1(&mut self) -> FB1_W<F10R1_SPEC> {
                FB1_W::new(self, 1)
            }
            ///Bit 2 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb2(&mut self) -> FB2_W<F10R1_SPEC> {
                FB2_W::new(self, 2)
            }
            ///Bit 3 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb3(&mut self) -> FB3_W<F10R1_SPEC> {
                FB3_W::new(self, 3)
            }
            ///Bit 4 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb4(&mut self) -> FB4_W<F10R1_SPEC> {
                FB4_W::new(self, 4)
            }
            ///Bit 5 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb5(&mut self) -> FB5_W<F10R1_SPEC> {
                FB5_W::new(self, 5)
            }
            ///Bit 6 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb6(&mut self) -> FB6_W<F10R1_SPEC> {
                FB6_W::new(self, 6)
            }
            ///Bit 7 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb7(&mut self) -> FB7_W<F10R1_SPEC> {
                FB7_W::new(self, 7)
            }
            ///Bit 8 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb8(&mut self) -> FB8_W<F10R1_SPEC> {
                FB8_W::new(self, 8)
            }
            ///Bit 9 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb9(&mut self) -> FB9_W<F10R1_SPEC> {
                FB9_W::new(self, 9)
            }
            ///Bit 10 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb10(&mut self) -> FB10_W<F10R1_SPEC> {
                FB10_W::new(self, 10)
            }
            ///Bit 11 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb11(&mut self) -> FB11_W<F10R1_SPEC> {
                FB11_W::new(self, 11)
            }
            ///Bit 12 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb12(&mut self) -> FB12_W<F10R1_SPEC> {
                FB12_W::new(self, 12)
            }
            ///Bit 13 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb13(&mut self) -> FB13_W<F10R1_SPEC> {
                FB13_W::new(self, 13)
            }
            ///Bit 14 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb14(&mut self) -> FB14_W<F10R1_SPEC> {
                FB14_W::new(self, 14)
            }
            ///Bit 15 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb15(&mut self) -> FB15_W<F10R1_SPEC> {
                FB15_W::new(self, 15)
            }
            ///Bit 16 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb16(&mut self) -> FB16_W<F10R1_SPEC> {
                FB16_W::new(self, 16)
            }
            ///Bit 17 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb17(&mut self) -> FB17_W<F10R1_SPEC> {
                FB17_W::new(self, 17)
            }
            ///Bit 18 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb18(&mut self) -> FB18_W<F10R1_SPEC> {
                FB18_W::new(self, 18)
            }
            ///Bit 19 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb19(&mut self) -> FB19_W<F10R1_SPEC> {
                FB19_W::new(self, 19)
            }
            ///Bit 20 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb20(&mut self) -> FB20_W<F10R1_SPEC> {
                FB20_W::new(self, 20)
            }
            ///Bit 21 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb21(&mut self) -> FB21_W<F10R1_SPEC> {
                FB21_W::new(self, 21)
            }
            ///Bit 22 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb22(&mut self) -> FB22_W<F10R1_SPEC> {
                FB22_W::new(self, 22)
            }
            ///Bit 23 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb23(&mut self) -> FB23_W<F10R1_SPEC> {
                FB23_W::new(self, 23)
            }
            ///Bit 24 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb24(&mut self) -> FB24_W<F10R1_SPEC> {
                FB24_W::new(self, 24)
            }
            ///Bit 25 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb25(&mut self) -> FB25_W<F10R1_SPEC> {
                FB25_W::new(self, 25)
            }
            ///Bit 26 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb26(&mut self) -> FB26_W<F10R1_SPEC> {
                FB26_W::new(self, 26)
            }
            ///Bit 27 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb27(&mut self) -> FB27_W<F10R1_SPEC> {
                FB27_W::new(self, 27)
            }
            ///Bit 28 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb28(&mut self) -> FB28_W<F10R1_SPEC> {
                FB28_W::new(self, 28)
            }
            ///Bit 29 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb29(&mut self) -> FB29_W<F10R1_SPEC> {
                FB29_W::new(self, 29)
            }
            ///Bit 30 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb30(&mut self) -> FB30_W<F10R1_SPEC> {
                FB30_W::new(self, 30)
            }
            ///Bit 31 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb31(&mut self) -> FB31_W<F10R1_SPEC> {
                FB31_W::new(self, 31)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Filter bank 10 register 1
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`f10r1::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`f10r1::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct F10R1_SPEC;
        impl crate::RegisterSpec for F10R1_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`f10r1::R`](R) reader structure
        impl crate::Readable for F10R1_SPEC {}
        ///`write(|w| ..)` method takes [`f10r1::W`](W) writer structure
        impl crate::Writable for F10R1_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets F10R1 to value 0
        impl crate::Resettable for F10R1_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///F10R2 (rw) register accessor: Filter bank 10 register 2
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`f10r2::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`f10r2::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@f10r2`]
    ///module
    pub type F10R2 = crate::Reg<f10r2::F10R2_SPEC>;
    ///Filter bank 10 register 2
    pub mod f10r2 {
        ///Register `F10R2` reader
        pub type R = crate::R<F10R2_SPEC>;
        ///Register `F10R2` writer
        pub type W = crate::W<F10R2_SPEC>;
        ///Field `FB0` reader - Filter bits
        pub type FB0_R = crate::BitReader;
        ///Field `FB0` writer - Filter bits
        pub type FB0_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB1` reader - Filter bits
        pub type FB1_R = crate::BitReader;
        ///Field `FB1` writer - Filter bits
        pub type FB1_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB2` reader - Filter bits
        pub type FB2_R = crate::BitReader;
        ///Field `FB2` writer - Filter bits
        pub type FB2_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB3` reader - Filter bits
        pub type FB3_R = crate::BitReader;
        ///Field `FB3` writer - Filter bits
        pub type FB3_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB4` reader - Filter bits
        pub type FB4_R = crate::BitReader;
        ///Field `FB4` writer - Filter bits
        pub type FB4_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB5` reader - Filter bits
        pub type FB5_R = crate::BitReader;
        ///Field `FB5` writer - Filter bits
        pub type FB5_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB6` reader - Filter bits
        pub type FB6_R = crate::BitReader;
        ///Field `FB6` writer - Filter bits
        pub type FB6_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB7` reader - Filter bits
        pub type FB7_R = crate::BitReader;
        ///Field `FB7` writer - Filter bits
        pub type FB7_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB8` reader - Filter bits
        pub type FB8_R = crate::BitReader;
        ///Field `FB8` writer - Filter bits
        pub type FB8_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB9` reader - Filter bits
        pub type FB9_R = crate::BitReader;
        ///Field `FB9` writer - Filter bits
        pub type FB9_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB10` reader - Filter bits
        pub type FB10_R = crate::BitReader;
        ///Field `FB10` writer - Filter bits
        pub type FB10_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB11` reader - Filter bits
        pub type FB11_R = crate::BitReader;
        ///Field `FB11` writer - Filter bits
        pub type FB11_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB12` reader - Filter bits
        pub type FB12_R = crate::BitReader;
        ///Field `FB12` writer - Filter bits
        pub type FB12_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB13` reader - Filter bits
        pub type FB13_R = crate::BitReader;
        ///Field `FB13` writer - Filter bits
        pub type FB13_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB14` reader - Filter bits
        pub type FB14_R = crate::BitReader;
        ///Field `FB14` writer - Filter bits
        pub type FB14_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB15` reader - Filter bits
        pub type FB15_R = crate::BitReader;
        ///Field `FB15` writer - Filter bits
        pub type FB15_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB16` reader - Filter bits
        pub type FB16_R = crate::BitReader;
        ///Field `FB16` writer - Filter bits
        pub type FB16_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB17` reader - Filter bits
        pub type FB17_R = crate::BitReader;
        ///Field `FB17` writer - Filter bits
        pub type FB17_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB18` reader - Filter bits
        pub type FB18_R = crate::BitReader;
        ///Field `FB18` writer - Filter bits
        pub type FB18_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB19` reader - Filter bits
        pub type FB19_R = crate::BitReader;
        ///Field `FB19` writer - Filter bits
        pub type FB19_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB20` reader - Filter bits
        pub type FB20_R = crate::BitReader;
        ///Field `FB20` writer - Filter bits
        pub type FB20_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB21` reader - Filter bits
        pub type FB21_R = crate::BitReader;
        ///Field `FB21` writer - Filter bits
        pub type FB21_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB22` reader - Filter bits
        pub type FB22_R = crate::BitReader;
        ///Field `FB22` writer - Filter bits
        pub type FB22_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB23` reader - Filter bits
        pub type FB23_R = crate::BitReader;
        ///Field `FB23` writer - Filter bits
        pub type FB23_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB24` reader - Filter bits
        pub type FB24_R = crate::BitReader;
        ///Field `FB24` writer - Filter bits
        pub type FB24_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB25` reader - Filter bits
        pub type FB25_R = crate::BitReader;
        ///Field `FB25` writer - Filter bits
        pub type FB25_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB26` reader - Filter bits
        pub type FB26_R = crate::BitReader;
        ///Field `FB26` writer - Filter bits
        pub type FB26_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB27` reader - Filter bits
        pub type FB27_R = crate::BitReader;
        ///Field `FB27` writer - Filter bits
        pub type FB27_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB28` reader - Filter bits
        pub type FB28_R = crate::BitReader;
        ///Field `FB28` writer - Filter bits
        pub type FB28_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB29` reader - Filter bits
        pub type FB29_R = crate::BitReader;
        ///Field `FB29` writer - Filter bits
        pub type FB29_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB30` reader - Filter bits
        pub type FB30_R = crate::BitReader;
        ///Field `FB30` writer - Filter bits
        pub type FB30_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB31` reader - Filter bits
        pub type FB31_R = crate::BitReader;
        ///Field `FB31` writer - Filter bits
        pub type FB31_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - Filter bits
            #[inline(always)]
            pub fn fb0(&self) -> FB0_R {
                FB0_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Filter bits
            #[inline(always)]
            pub fn fb1(&self) -> FB1_R {
                FB1_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - Filter bits
            #[inline(always)]
            pub fn fb2(&self) -> FB2_R {
                FB2_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - Filter bits
            #[inline(always)]
            pub fn fb3(&self) -> FB3_R {
                FB3_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - Filter bits
            #[inline(always)]
            pub fn fb4(&self) -> FB4_R {
                FB4_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - Filter bits
            #[inline(always)]
            pub fn fb5(&self) -> FB5_R {
                FB5_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - Filter bits
            #[inline(always)]
            pub fn fb6(&self) -> FB6_R {
                FB6_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - Filter bits
            #[inline(always)]
            pub fn fb7(&self) -> FB7_R {
                FB7_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bit 8 - Filter bits
            #[inline(always)]
            pub fn fb8(&self) -> FB8_R {
                FB8_R::new(((self.bits >> 8) & 1) != 0)
            }
            ///Bit 9 - Filter bits
            #[inline(always)]
            pub fn fb9(&self) -> FB9_R {
                FB9_R::new(((self.bits >> 9) & 1) != 0)
            }
            ///Bit 10 - Filter bits
            #[inline(always)]
            pub fn fb10(&self) -> FB10_R {
                FB10_R::new(((self.bits >> 10) & 1) != 0)
            }
            ///Bit 11 - Filter bits
            #[inline(always)]
            pub fn fb11(&self) -> FB11_R {
                FB11_R::new(((self.bits >> 11) & 1) != 0)
            }
            ///Bit 12 - Filter bits
            #[inline(always)]
            pub fn fb12(&self) -> FB12_R {
                FB12_R::new(((self.bits >> 12) & 1) != 0)
            }
            ///Bit 13 - Filter bits
            #[inline(always)]
            pub fn fb13(&self) -> FB13_R {
                FB13_R::new(((self.bits >> 13) & 1) != 0)
            }
            ///Bit 14 - Filter bits
            #[inline(always)]
            pub fn fb14(&self) -> FB14_R {
                FB14_R::new(((self.bits >> 14) & 1) != 0)
            }
            ///Bit 15 - Filter bits
            #[inline(always)]
            pub fn fb15(&self) -> FB15_R {
                FB15_R::new(((self.bits >> 15) & 1) != 0)
            }
            ///Bit 16 - Filter bits
            #[inline(always)]
            pub fn fb16(&self) -> FB16_R {
                FB16_R::new(((self.bits >> 16) & 1) != 0)
            }
            ///Bit 17 - Filter bits
            #[inline(always)]
            pub fn fb17(&self) -> FB17_R {
                FB17_R::new(((self.bits >> 17) & 1) != 0)
            }
            ///Bit 18 - Filter bits
            #[inline(always)]
            pub fn fb18(&self) -> FB18_R {
                FB18_R::new(((self.bits >> 18) & 1) != 0)
            }
            ///Bit 19 - Filter bits
            #[inline(always)]
            pub fn fb19(&self) -> FB19_R {
                FB19_R::new(((self.bits >> 19) & 1) != 0)
            }
            ///Bit 20 - Filter bits
            #[inline(always)]
            pub fn fb20(&self) -> FB20_R {
                FB20_R::new(((self.bits >> 20) & 1) != 0)
            }
            ///Bit 21 - Filter bits
            #[inline(always)]
            pub fn fb21(&self) -> FB21_R {
                FB21_R::new(((self.bits >> 21) & 1) != 0)
            }
            ///Bit 22 - Filter bits
            #[inline(always)]
            pub fn fb22(&self) -> FB22_R {
                FB22_R::new(((self.bits >> 22) & 1) != 0)
            }
            ///Bit 23 - Filter bits
            #[inline(always)]
            pub fn fb23(&self) -> FB23_R {
                FB23_R::new(((self.bits >> 23) & 1) != 0)
            }
            ///Bit 24 - Filter bits
            #[inline(always)]
            pub fn fb24(&self) -> FB24_R {
                FB24_R::new(((self.bits >> 24) & 1) != 0)
            }
            ///Bit 25 - Filter bits
            #[inline(always)]
            pub fn fb25(&self) -> FB25_R {
                FB25_R::new(((self.bits >> 25) & 1) != 0)
            }
            ///Bit 26 - Filter bits
            #[inline(always)]
            pub fn fb26(&self) -> FB26_R {
                FB26_R::new(((self.bits >> 26) & 1) != 0)
            }
            ///Bit 27 - Filter bits
            #[inline(always)]
            pub fn fb27(&self) -> FB27_R {
                FB27_R::new(((self.bits >> 27) & 1) != 0)
            }
            ///Bit 28 - Filter bits
            #[inline(always)]
            pub fn fb28(&self) -> FB28_R {
                FB28_R::new(((self.bits >> 28) & 1) != 0)
            }
            ///Bit 29 - Filter bits
            #[inline(always)]
            pub fn fb29(&self) -> FB29_R {
                FB29_R::new(((self.bits >> 29) & 1) != 0)
            }
            ///Bit 30 - Filter bits
            #[inline(always)]
            pub fn fb30(&self) -> FB30_R {
                FB30_R::new(((self.bits >> 30) & 1) != 0)
            }
            ///Bit 31 - Filter bits
            #[inline(always)]
            pub fn fb31(&self) -> FB31_R {
                FB31_R::new(((self.bits >> 31) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb0(&mut self) -> FB0_W<F10R2_SPEC> {
                FB0_W::new(self, 0)
            }
            ///Bit 1 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb1(&mut self) -> FB1_W<F10R2_SPEC> {
                FB1_W::new(self, 1)
            }
            ///Bit 2 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb2(&mut self) -> FB2_W<F10R2_SPEC> {
                FB2_W::new(self, 2)
            }
            ///Bit 3 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb3(&mut self) -> FB3_W<F10R2_SPEC> {
                FB3_W::new(self, 3)
            }
            ///Bit 4 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb4(&mut self) -> FB4_W<F10R2_SPEC> {
                FB4_W::new(self, 4)
            }
            ///Bit 5 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb5(&mut self) -> FB5_W<F10R2_SPEC> {
                FB5_W::new(self, 5)
            }
            ///Bit 6 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb6(&mut self) -> FB6_W<F10R2_SPEC> {
                FB6_W::new(self, 6)
            }
            ///Bit 7 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb7(&mut self) -> FB7_W<F10R2_SPEC> {
                FB7_W::new(self, 7)
            }
            ///Bit 8 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb8(&mut self) -> FB8_W<F10R2_SPEC> {
                FB8_W::new(self, 8)
            }
            ///Bit 9 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb9(&mut self) -> FB9_W<F10R2_SPEC> {
                FB9_W::new(self, 9)
            }
            ///Bit 10 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb10(&mut self) -> FB10_W<F10R2_SPEC> {
                FB10_W::new(self, 10)
            }
            ///Bit 11 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb11(&mut self) -> FB11_W<F10R2_SPEC> {
                FB11_W::new(self, 11)
            }
            ///Bit 12 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb12(&mut self) -> FB12_W<F10R2_SPEC> {
                FB12_W::new(self, 12)
            }
            ///Bit 13 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb13(&mut self) -> FB13_W<F10R2_SPEC> {
                FB13_W::new(self, 13)
            }
            ///Bit 14 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb14(&mut self) -> FB14_W<F10R2_SPEC> {
                FB14_W::new(self, 14)
            }
            ///Bit 15 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb15(&mut self) -> FB15_W<F10R2_SPEC> {
                FB15_W::new(self, 15)
            }
            ///Bit 16 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb16(&mut self) -> FB16_W<F10R2_SPEC> {
                FB16_W::new(self, 16)
            }
            ///Bit 17 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb17(&mut self) -> FB17_W<F10R2_SPEC> {
                FB17_W::new(self, 17)
            }
            ///Bit 18 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb18(&mut self) -> FB18_W<F10R2_SPEC> {
                FB18_W::new(self, 18)
            }
            ///Bit 19 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb19(&mut self) -> FB19_W<F10R2_SPEC> {
                FB19_W::new(self, 19)
            }
            ///Bit 20 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb20(&mut self) -> FB20_W<F10R2_SPEC> {
                FB20_W::new(self, 20)
            }
            ///Bit 21 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb21(&mut self) -> FB21_W<F10R2_SPEC> {
                FB21_W::new(self, 21)
            }
            ///Bit 22 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb22(&mut self) -> FB22_W<F10R2_SPEC> {
                FB22_W::new(self, 22)
            }
            ///Bit 23 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb23(&mut self) -> FB23_W<F10R2_SPEC> {
                FB23_W::new(self, 23)
            }
            ///Bit 24 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb24(&mut self) -> FB24_W<F10R2_SPEC> {
                FB24_W::new(self, 24)
            }
            ///Bit 25 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb25(&mut self) -> FB25_W<F10R2_SPEC> {
                FB25_W::new(self, 25)
            }
            ///Bit 26 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb26(&mut self) -> FB26_W<F10R2_SPEC> {
                FB26_W::new(self, 26)
            }
            ///Bit 27 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb27(&mut self) -> FB27_W<F10R2_SPEC> {
                FB27_W::new(self, 27)
            }
            ///Bit 28 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb28(&mut self) -> FB28_W<F10R2_SPEC> {
                FB28_W::new(self, 28)
            }
            ///Bit 29 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb29(&mut self) -> FB29_W<F10R2_SPEC> {
                FB29_W::new(self, 29)
            }
            ///Bit 30 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb30(&mut self) -> FB30_W<F10R2_SPEC> {
                FB30_W::new(self, 30)
            }
            ///Bit 31 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb31(&mut self) -> FB31_W<F10R2_SPEC> {
                FB31_W::new(self, 31)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Filter bank 10 register 2
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`f10r2::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`f10r2::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct F10R2_SPEC;
        impl crate::RegisterSpec for F10R2_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`f10r2::R`](R) reader structure
        impl crate::Readable for F10R2_SPEC {}
        ///`write(|w| ..)` method takes [`f10r2::W`](W) writer structure
        impl crate::Writable for F10R2_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets F10R2 to value 0
        impl crate::Resettable for F10R2_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///F11R1 (rw) register accessor: Filter bank 11 register 1
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`f11r1::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`f11r1::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@f11r1`]
    ///module
    pub type F11R1 = crate::Reg<f11r1::F11R1_SPEC>;
    ///Filter bank 11 register 1
    pub mod f11r1 {
        ///Register `F11R1` reader
        pub type R = crate::R<F11R1_SPEC>;
        ///Register `F11R1` writer
        pub type W = crate::W<F11R1_SPEC>;
        ///Field `FB0` reader - Filter bits
        pub type FB0_R = crate::BitReader;
        ///Field `FB0` writer - Filter bits
        pub type FB0_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB1` reader - Filter bits
        pub type FB1_R = crate::BitReader;
        ///Field `FB1` writer - Filter bits
        pub type FB1_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB2` reader - Filter bits
        pub type FB2_R = crate::BitReader;
        ///Field `FB2` writer - Filter bits
        pub type FB2_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB3` reader - Filter bits
        pub type FB3_R = crate::BitReader;
        ///Field `FB3` writer - Filter bits
        pub type FB3_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB4` reader - Filter bits
        pub type FB4_R = crate::BitReader;
        ///Field `FB4` writer - Filter bits
        pub type FB4_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB5` reader - Filter bits
        pub type FB5_R = crate::BitReader;
        ///Field `FB5` writer - Filter bits
        pub type FB5_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB6` reader - Filter bits
        pub type FB6_R = crate::BitReader;
        ///Field `FB6` writer - Filter bits
        pub type FB6_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB7` reader - Filter bits
        pub type FB7_R = crate::BitReader;
        ///Field `FB7` writer - Filter bits
        pub type FB7_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB8` reader - Filter bits
        pub type FB8_R = crate::BitReader;
        ///Field `FB8` writer - Filter bits
        pub type FB8_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB9` reader - Filter bits
        pub type FB9_R = crate::BitReader;
        ///Field `FB9` writer - Filter bits
        pub type FB9_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB10` reader - Filter bits
        pub type FB10_R = crate::BitReader;
        ///Field `FB10` writer - Filter bits
        pub type FB10_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB11` reader - Filter bits
        pub type FB11_R = crate::BitReader;
        ///Field `FB11` writer - Filter bits
        pub type FB11_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB12` reader - Filter bits
        pub type FB12_R = crate::BitReader;
        ///Field `FB12` writer - Filter bits
        pub type FB12_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB13` reader - Filter bits
        pub type FB13_R = crate::BitReader;
        ///Field `FB13` writer - Filter bits
        pub type FB13_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB14` reader - Filter bits
        pub type FB14_R = crate::BitReader;
        ///Field `FB14` writer - Filter bits
        pub type FB14_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB15` reader - Filter bits
        pub type FB15_R = crate::BitReader;
        ///Field `FB15` writer - Filter bits
        pub type FB15_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB16` reader - Filter bits
        pub type FB16_R = crate::BitReader;
        ///Field `FB16` writer - Filter bits
        pub type FB16_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB17` reader - Filter bits
        pub type FB17_R = crate::BitReader;
        ///Field `FB17` writer - Filter bits
        pub type FB17_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB18` reader - Filter bits
        pub type FB18_R = crate::BitReader;
        ///Field `FB18` writer - Filter bits
        pub type FB18_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB19` reader - Filter bits
        pub type FB19_R = crate::BitReader;
        ///Field `FB19` writer - Filter bits
        pub type FB19_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB20` reader - Filter bits
        pub type FB20_R = crate::BitReader;
        ///Field `FB20` writer - Filter bits
        pub type FB20_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB21` reader - Filter bits
        pub type FB21_R = crate::BitReader;
        ///Field `FB21` writer - Filter bits
        pub type FB21_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB22` reader - Filter bits
        pub type FB22_R = crate::BitReader;
        ///Field `FB22` writer - Filter bits
        pub type FB22_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB23` reader - Filter bits
        pub type FB23_R = crate::BitReader;
        ///Field `FB23` writer - Filter bits
        pub type FB23_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB24` reader - Filter bits
        pub type FB24_R = crate::BitReader;
        ///Field `FB24` writer - Filter bits
        pub type FB24_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB25` reader - Filter bits
        pub type FB25_R = crate::BitReader;
        ///Field `FB25` writer - Filter bits
        pub type FB25_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB26` reader - Filter bits
        pub type FB26_R = crate::BitReader;
        ///Field `FB26` writer - Filter bits
        pub type FB26_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB27` reader - Filter bits
        pub type FB27_R = crate::BitReader;
        ///Field `FB27` writer - Filter bits
        pub type FB27_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB28` reader - Filter bits
        pub type FB28_R = crate::BitReader;
        ///Field `FB28` writer - Filter bits
        pub type FB28_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB29` reader - Filter bits
        pub type FB29_R = crate::BitReader;
        ///Field `FB29` writer - Filter bits
        pub type FB29_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB30` reader - Filter bits
        pub type FB30_R = crate::BitReader;
        ///Field `FB30` writer - Filter bits
        pub type FB30_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB31` reader - Filter bits
        pub type FB31_R = crate::BitReader;
        ///Field `FB31` writer - Filter bits
        pub type FB31_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - Filter bits
            #[inline(always)]
            pub fn fb0(&self) -> FB0_R {
                FB0_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Filter bits
            #[inline(always)]
            pub fn fb1(&self) -> FB1_R {
                FB1_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - Filter bits
            #[inline(always)]
            pub fn fb2(&self) -> FB2_R {
                FB2_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - Filter bits
            #[inline(always)]
            pub fn fb3(&self) -> FB3_R {
                FB3_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - Filter bits
            #[inline(always)]
            pub fn fb4(&self) -> FB4_R {
                FB4_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - Filter bits
            #[inline(always)]
            pub fn fb5(&self) -> FB5_R {
                FB5_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - Filter bits
            #[inline(always)]
            pub fn fb6(&self) -> FB6_R {
                FB6_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - Filter bits
            #[inline(always)]
            pub fn fb7(&self) -> FB7_R {
                FB7_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bit 8 - Filter bits
            #[inline(always)]
            pub fn fb8(&self) -> FB8_R {
                FB8_R::new(((self.bits >> 8) & 1) != 0)
            }
            ///Bit 9 - Filter bits
            #[inline(always)]
            pub fn fb9(&self) -> FB9_R {
                FB9_R::new(((self.bits >> 9) & 1) != 0)
            }
            ///Bit 10 - Filter bits
            #[inline(always)]
            pub fn fb10(&self) -> FB10_R {
                FB10_R::new(((self.bits >> 10) & 1) != 0)
            }
            ///Bit 11 - Filter bits
            #[inline(always)]
            pub fn fb11(&self) -> FB11_R {
                FB11_R::new(((self.bits >> 11) & 1) != 0)
            }
            ///Bit 12 - Filter bits
            #[inline(always)]
            pub fn fb12(&self) -> FB12_R {
                FB12_R::new(((self.bits >> 12) & 1) != 0)
            }
            ///Bit 13 - Filter bits
            #[inline(always)]
            pub fn fb13(&self) -> FB13_R {
                FB13_R::new(((self.bits >> 13) & 1) != 0)
            }
            ///Bit 14 - Filter bits
            #[inline(always)]
            pub fn fb14(&self) -> FB14_R {
                FB14_R::new(((self.bits >> 14) & 1) != 0)
            }
            ///Bit 15 - Filter bits
            #[inline(always)]
            pub fn fb15(&self) -> FB15_R {
                FB15_R::new(((self.bits >> 15) & 1) != 0)
            }
            ///Bit 16 - Filter bits
            #[inline(always)]
            pub fn fb16(&self) -> FB16_R {
                FB16_R::new(((self.bits >> 16) & 1) != 0)
            }
            ///Bit 17 - Filter bits
            #[inline(always)]
            pub fn fb17(&self) -> FB17_R {
                FB17_R::new(((self.bits >> 17) & 1) != 0)
            }
            ///Bit 18 - Filter bits
            #[inline(always)]
            pub fn fb18(&self) -> FB18_R {
                FB18_R::new(((self.bits >> 18) & 1) != 0)
            }
            ///Bit 19 - Filter bits
            #[inline(always)]
            pub fn fb19(&self) -> FB19_R {
                FB19_R::new(((self.bits >> 19) & 1) != 0)
            }
            ///Bit 20 - Filter bits
            #[inline(always)]
            pub fn fb20(&self) -> FB20_R {
                FB20_R::new(((self.bits >> 20) & 1) != 0)
            }
            ///Bit 21 - Filter bits
            #[inline(always)]
            pub fn fb21(&self) -> FB21_R {
                FB21_R::new(((self.bits >> 21) & 1) != 0)
            }
            ///Bit 22 - Filter bits
            #[inline(always)]
            pub fn fb22(&self) -> FB22_R {
                FB22_R::new(((self.bits >> 22) & 1) != 0)
            }
            ///Bit 23 - Filter bits
            #[inline(always)]
            pub fn fb23(&self) -> FB23_R {
                FB23_R::new(((self.bits >> 23) & 1) != 0)
            }
            ///Bit 24 - Filter bits
            #[inline(always)]
            pub fn fb24(&self) -> FB24_R {
                FB24_R::new(((self.bits >> 24) & 1) != 0)
            }
            ///Bit 25 - Filter bits
            #[inline(always)]
            pub fn fb25(&self) -> FB25_R {
                FB25_R::new(((self.bits >> 25) & 1) != 0)
            }
            ///Bit 26 - Filter bits
            #[inline(always)]
            pub fn fb26(&self) -> FB26_R {
                FB26_R::new(((self.bits >> 26) & 1) != 0)
            }
            ///Bit 27 - Filter bits
            #[inline(always)]
            pub fn fb27(&self) -> FB27_R {
                FB27_R::new(((self.bits >> 27) & 1) != 0)
            }
            ///Bit 28 - Filter bits
            #[inline(always)]
            pub fn fb28(&self) -> FB28_R {
                FB28_R::new(((self.bits >> 28) & 1) != 0)
            }
            ///Bit 29 - Filter bits
            #[inline(always)]
            pub fn fb29(&self) -> FB29_R {
                FB29_R::new(((self.bits >> 29) & 1) != 0)
            }
            ///Bit 30 - Filter bits
            #[inline(always)]
            pub fn fb30(&self) -> FB30_R {
                FB30_R::new(((self.bits >> 30) & 1) != 0)
            }
            ///Bit 31 - Filter bits
            #[inline(always)]
            pub fn fb31(&self) -> FB31_R {
                FB31_R::new(((self.bits >> 31) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb0(&mut self) -> FB0_W<F11R1_SPEC> {
                FB0_W::new(self, 0)
            }
            ///Bit 1 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb1(&mut self) -> FB1_W<F11R1_SPEC> {
                FB1_W::new(self, 1)
            }
            ///Bit 2 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb2(&mut self) -> FB2_W<F11R1_SPEC> {
                FB2_W::new(self, 2)
            }
            ///Bit 3 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb3(&mut self) -> FB3_W<F11R1_SPEC> {
                FB3_W::new(self, 3)
            }
            ///Bit 4 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb4(&mut self) -> FB4_W<F11R1_SPEC> {
                FB4_W::new(self, 4)
            }
            ///Bit 5 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb5(&mut self) -> FB5_W<F11R1_SPEC> {
                FB5_W::new(self, 5)
            }
            ///Bit 6 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb6(&mut self) -> FB6_W<F11R1_SPEC> {
                FB6_W::new(self, 6)
            }
            ///Bit 7 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb7(&mut self) -> FB7_W<F11R1_SPEC> {
                FB7_W::new(self, 7)
            }
            ///Bit 8 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb8(&mut self) -> FB8_W<F11R1_SPEC> {
                FB8_W::new(self, 8)
            }
            ///Bit 9 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb9(&mut self) -> FB9_W<F11R1_SPEC> {
                FB9_W::new(self, 9)
            }
            ///Bit 10 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb10(&mut self) -> FB10_W<F11R1_SPEC> {
                FB10_W::new(self, 10)
            }
            ///Bit 11 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb11(&mut self) -> FB11_W<F11R1_SPEC> {
                FB11_W::new(self, 11)
            }
            ///Bit 12 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb12(&mut self) -> FB12_W<F11R1_SPEC> {
                FB12_W::new(self, 12)
            }
            ///Bit 13 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb13(&mut self) -> FB13_W<F11R1_SPEC> {
                FB13_W::new(self, 13)
            }
            ///Bit 14 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb14(&mut self) -> FB14_W<F11R1_SPEC> {
                FB14_W::new(self, 14)
            }
            ///Bit 15 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb15(&mut self) -> FB15_W<F11R1_SPEC> {
                FB15_W::new(self, 15)
            }
            ///Bit 16 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb16(&mut self) -> FB16_W<F11R1_SPEC> {
                FB16_W::new(self, 16)
            }
            ///Bit 17 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb17(&mut self) -> FB17_W<F11R1_SPEC> {
                FB17_W::new(self, 17)
            }
            ///Bit 18 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb18(&mut self) -> FB18_W<F11R1_SPEC> {
                FB18_W::new(self, 18)
            }
            ///Bit 19 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb19(&mut self) -> FB19_W<F11R1_SPEC> {
                FB19_W::new(self, 19)
            }
            ///Bit 20 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb20(&mut self) -> FB20_W<F11R1_SPEC> {
                FB20_W::new(self, 20)
            }
            ///Bit 21 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb21(&mut self) -> FB21_W<F11R1_SPEC> {
                FB21_W::new(self, 21)
            }
            ///Bit 22 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb22(&mut self) -> FB22_W<F11R1_SPEC> {
                FB22_W::new(self, 22)
            }
            ///Bit 23 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb23(&mut self) -> FB23_W<F11R1_SPEC> {
                FB23_W::new(self, 23)
            }
            ///Bit 24 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb24(&mut self) -> FB24_W<F11R1_SPEC> {
                FB24_W::new(self, 24)
            }
            ///Bit 25 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb25(&mut self) -> FB25_W<F11R1_SPEC> {
                FB25_W::new(self, 25)
            }
            ///Bit 26 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb26(&mut self) -> FB26_W<F11R1_SPEC> {
                FB26_W::new(self, 26)
            }
            ///Bit 27 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb27(&mut self) -> FB27_W<F11R1_SPEC> {
                FB27_W::new(self, 27)
            }
            ///Bit 28 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb28(&mut self) -> FB28_W<F11R1_SPEC> {
                FB28_W::new(self, 28)
            }
            ///Bit 29 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb29(&mut self) -> FB29_W<F11R1_SPEC> {
                FB29_W::new(self, 29)
            }
            ///Bit 30 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb30(&mut self) -> FB30_W<F11R1_SPEC> {
                FB30_W::new(self, 30)
            }
            ///Bit 31 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb31(&mut self) -> FB31_W<F11R1_SPEC> {
                FB31_W::new(self, 31)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Filter bank 11 register 1
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`f11r1::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`f11r1::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct F11R1_SPEC;
        impl crate::RegisterSpec for F11R1_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`f11r1::R`](R) reader structure
        impl crate::Readable for F11R1_SPEC {}
        ///`write(|w| ..)` method takes [`f11r1::W`](W) writer structure
        impl crate::Writable for F11R1_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets F11R1 to value 0
        impl crate::Resettable for F11R1_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///F11R2 (rw) register accessor: Filter bank 11 register 2
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`f11r2::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`f11r2::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@f11r2`]
    ///module
    pub type F11R2 = crate::Reg<f11r2::F11R2_SPEC>;
    ///Filter bank 11 register 2
    pub mod f11r2 {
        ///Register `F11R2` reader
        pub type R = crate::R<F11R2_SPEC>;
        ///Register `F11R2` writer
        pub type W = crate::W<F11R2_SPEC>;
        ///Field `FB0` reader - Filter bits
        pub type FB0_R = crate::BitReader;
        ///Field `FB0` writer - Filter bits
        pub type FB0_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB1` reader - Filter bits
        pub type FB1_R = crate::BitReader;
        ///Field `FB1` writer - Filter bits
        pub type FB1_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB2` reader - Filter bits
        pub type FB2_R = crate::BitReader;
        ///Field `FB2` writer - Filter bits
        pub type FB2_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB3` reader - Filter bits
        pub type FB3_R = crate::BitReader;
        ///Field `FB3` writer - Filter bits
        pub type FB3_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB4` reader - Filter bits
        pub type FB4_R = crate::BitReader;
        ///Field `FB4` writer - Filter bits
        pub type FB4_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB5` reader - Filter bits
        pub type FB5_R = crate::BitReader;
        ///Field `FB5` writer - Filter bits
        pub type FB5_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB6` reader - Filter bits
        pub type FB6_R = crate::BitReader;
        ///Field `FB6` writer - Filter bits
        pub type FB6_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB7` reader - Filter bits
        pub type FB7_R = crate::BitReader;
        ///Field `FB7` writer - Filter bits
        pub type FB7_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB8` reader - Filter bits
        pub type FB8_R = crate::BitReader;
        ///Field `FB8` writer - Filter bits
        pub type FB8_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB9` reader - Filter bits
        pub type FB9_R = crate::BitReader;
        ///Field `FB9` writer - Filter bits
        pub type FB9_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB10` reader - Filter bits
        pub type FB10_R = crate::BitReader;
        ///Field `FB10` writer - Filter bits
        pub type FB10_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB11` reader - Filter bits
        pub type FB11_R = crate::BitReader;
        ///Field `FB11` writer - Filter bits
        pub type FB11_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB12` reader - Filter bits
        pub type FB12_R = crate::BitReader;
        ///Field `FB12` writer - Filter bits
        pub type FB12_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB13` reader - Filter bits
        pub type FB13_R = crate::BitReader;
        ///Field `FB13` writer - Filter bits
        pub type FB13_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB14` reader - Filter bits
        pub type FB14_R = crate::BitReader;
        ///Field `FB14` writer - Filter bits
        pub type FB14_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB15` reader - Filter bits
        pub type FB15_R = crate::BitReader;
        ///Field `FB15` writer - Filter bits
        pub type FB15_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB16` reader - Filter bits
        pub type FB16_R = crate::BitReader;
        ///Field `FB16` writer - Filter bits
        pub type FB16_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB17` reader - Filter bits
        pub type FB17_R = crate::BitReader;
        ///Field `FB17` writer - Filter bits
        pub type FB17_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB18` reader - Filter bits
        pub type FB18_R = crate::BitReader;
        ///Field `FB18` writer - Filter bits
        pub type FB18_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB19` reader - Filter bits
        pub type FB19_R = crate::BitReader;
        ///Field `FB19` writer - Filter bits
        pub type FB19_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB20` reader - Filter bits
        pub type FB20_R = crate::BitReader;
        ///Field `FB20` writer - Filter bits
        pub type FB20_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB21` reader - Filter bits
        pub type FB21_R = crate::BitReader;
        ///Field `FB21` writer - Filter bits
        pub type FB21_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB22` reader - Filter bits
        pub type FB22_R = crate::BitReader;
        ///Field `FB22` writer - Filter bits
        pub type FB22_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB23` reader - Filter bits
        pub type FB23_R = crate::BitReader;
        ///Field `FB23` writer - Filter bits
        pub type FB23_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB24` reader - Filter bits
        pub type FB24_R = crate::BitReader;
        ///Field `FB24` writer - Filter bits
        pub type FB24_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB25` reader - Filter bits
        pub type FB25_R = crate::BitReader;
        ///Field `FB25` writer - Filter bits
        pub type FB25_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB26` reader - Filter bits
        pub type FB26_R = crate::BitReader;
        ///Field `FB26` writer - Filter bits
        pub type FB26_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB27` reader - Filter bits
        pub type FB27_R = crate::BitReader;
        ///Field `FB27` writer - Filter bits
        pub type FB27_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB28` reader - Filter bits
        pub type FB28_R = crate::BitReader;
        ///Field `FB28` writer - Filter bits
        pub type FB28_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB29` reader - Filter bits
        pub type FB29_R = crate::BitReader;
        ///Field `FB29` writer - Filter bits
        pub type FB29_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB30` reader - Filter bits
        pub type FB30_R = crate::BitReader;
        ///Field `FB30` writer - Filter bits
        pub type FB30_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB31` reader - Filter bits
        pub type FB31_R = crate::BitReader;
        ///Field `FB31` writer - Filter bits
        pub type FB31_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - Filter bits
            #[inline(always)]
            pub fn fb0(&self) -> FB0_R {
                FB0_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Filter bits
            #[inline(always)]
            pub fn fb1(&self) -> FB1_R {
                FB1_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - Filter bits
            #[inline(always)]
            pub fn fb2(&self) -> FB2_R {
                FB2_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - Filter bits
            #[inline(always)]
            pub fn fb3(&self) -> FB3_R {
                FB3_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - Filter bits
            #[inline(always)]
            pub fn fb4(&self) -> FB4_R {
                FB4_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - Filter bits
            #[inline(always)]
            pub fn fb5(&self) -> FB5_R {
                FB5_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - Filter bits
            #[inline(always)]
            pub fn fb6(&self) -> FB6_R {
                FB6_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - Filter bits
            #[inline(always)]
            pub fn fb7(&self) -> FB7_R {
                FB7_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bit 8 - Filter bits
            #[inline(always)]
            pub fn fb8(&self) -> FB8_R {
                FB8_R::new(((self.bits >> 8) & 1) != 0)
            }
            ///Bit 9 - Filter bits
            #[inline(always)]
            pub fn fb9(&self) -> FB9_R {
                FB9_R::new(((self.bits >> 9) & 1) != 0)
            }
            ///Bit 10 - Filter bits
            #[inline(always)]
            pub fn fb10(&self) -> FB10_R {
                FB10_R::new(((self.bits >> 10) & 1) != 0)
            }
            ///Bit 11 - Filter bits
            #[inline(always)]
            pub fn fb11(&self) -> FB11_R {
                FB11_R::new(((self.bits >> 11) & 1) != 0)
            }
            ///Bit 12 - Filter bits
            #[inline(always)]
            pub fn fb12(&self) -> FB12_R {
                FB12_R::new(((self.bits >> 12) & 1) != 0)
            }
            ///Bit 13 - Filter bits
            #[inline(always)]
            pub fn fb13(&self) -> FB13_R {
                FB13_R::new(((self.bits >> 13) & 1) != 0)
            }
            ///Bit 14 - Filter bits
            #[inline(always)]
            pub fn fb14(&self) -> FB14_R {
                FB14_R::new(((self.bits >> 14) & 1) != 0)
            }
            ///Bit 15 - Filter bits
            #[inline(always)]
            pub fn fb15(&self) -> FB15_R {
                FB15_R::new(((self.bits >> 15) & 1) != 0)
            }
            ///Bit 16 - Filter bits
            #[inline(always)]
            pub fn fb16(&self) -> FB16_R {
                FB16_R::new(((self.bits >> 16) & 1) != 0)
            }
            ///Bit 17 - Filter bits
            #[inline(always)]
            pub fn fb17(&self) -> FB17_R {
                FB17_R::new(((self.bits >> 17) & 1) != 0)
            }
            ///Bit 18 - Filter bits
            #[inline(always)]
            pub fn fb18(&self) -> FB18_R {
                FB18_R::new(((self.bits >> 18) & 1) != 0)
            }
            ///Bit 19 - Filter bits
            #[inline(always)]
            pub fn fb19(&self) -> FB19_R {
                FB19_R::new(((self.bits >> 19) & 1) != 0)
            }
            ///Bit 20 - Filter bits
            #[inline(always)]
            pub fn fb20(&self) -> FB20_R {
                FB20_R::new(((self.bits >> 20) & 1) != 0)
            }
            ///Bit 21 - Filter bits
            #[inline(always)]
            pub fn fb21(&self) -> FB21_R {
                FB21_R::new(((self.bits >> 21) & 1) != 0)
            }
            ///Bit 22 - Filter bits
            #[inline(always)]
            pub fn fb22(&self) -> FB22_R {
                FB22_R::new(((self.bits >> 22) & 1) != 0)
            }
            ///Bit 23 - Filter bits
            #[inline(always)]
            pub fn fb23(&self) -> FB23_R {
                FB23_R::new(((self.bits >> 23) & 1) != 0)
            }
            ///Bit 24 - Filter bits
            #[inline(always)]
            pub fn fb24(&self) -> FB24_R {
                FB24_R::new(((self.bits >> 24) & 1) != 0)
            }
            ///Bit 25 - Filter bits
            #[inline(always)]
            pub fn fb25(&self) -> FB25_R {
                FB25_R::new(((self.bits >> 25) & 1) != 0)
            }
            ///Bit 26 - Filter bits
            #[inline(always)]
            pub fn fb26(&self) -> FB26_R {
                FB26_R::new(((self.bits >> 26) & 1) != 0)
            }
            ///Bit 27 - Filter bits
            #[inline(always)]
            pub fn fb27(&self) -> FB27_R {
                FB27_R::new(((self.bits >> 27) & 1) != 0)
            }
            ///Bit 28 - Filter bits
            #[inline(always)]
            pub fn fb28(&self) -> FB28_R {
                FB28_R::new(((self.bits >> 28) & 1) != 0)
            }
            ///Bit 29 - Filter bits
            #[inline(always)]
            pub fn fb29(&self) -> FB29_R {
                FB29_R::new(((self.bits >> 29) & 1) != 0)
            }
            ///Bit 30 - Filter bits
            #[inline(always)]
            pub fn fb30(&self) -> FB30_R {
                FB30_R::new(((self.bits >> 30) & 1) != 0)
            }
            ///Bit 31 - Filter bits
            #[inline(always)]
            pub fn fb31(&self) -> FB31_R {
                FB31_R::new(((self.bits >> 31) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb0(&mut self) -> FB0_W<F11R2_SPEC> {
                FB0_W::new(self, 0)
            }
            ///Bit 1 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb1(&mut self) -> FB1_W<F11R2_SPEC> {
                FB1_W::new(self, 1)
            }
            ///Bit 2 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb2(&mut self) -> FB2_W<F11R2_SPEC> {
                FB2_W::new(self, 2)
            }
            ///Bit 3 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb3(&mut self) -> FB3_W<F11R2_SPEC> {
                FB3_W::new(self, 3)
            }
            ///Bit 4 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb4(&mut self) -> FB4_W<F11R2_SPEC> {
                FB4_W::new(self, 4)
            }
            ///Bit 5 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb5(&mut self) -> FB5_W<F11R2_SPEC> {
                FB5_W::new(self, 5)
            }
            ///Bit 6 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb6(&mut self) -> FB6_W<F11R2_SPEC> {
                FB6_W::new(self, 6)
            }
            ///Bit 7 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb7(&mut self) -> FB7_W<F11R2_SPEC> {
                FB7_W::new(self, 7)
            }
            ///Bit 8 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb8(&mut self) -> FB8_W<F11R2_SPEC> {
                FB8_W::new(self, 8)
            }
            ///Bit 9 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb9(&mut self) -> FB9_W<F11R2_SPEC> {
                FB9_W::new(self, 9)
            }
            ///Bit 10 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb10(&mut self) -> FB10_W<F11R2_SPEC> {
                FB10_W::new(self, 10)
            }
            ///Bit 11 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb11(&mut self) -> FB11_W<F11R2_SPEC> {
                FB11_W::new(self, 11)
            }
            ///Bit 12 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb12(&mut self) -> FB12_W<F11R2_SPEC> {
                FB12_W::new(self, 12)
            }
            ///Bit 13 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb13(&mut self) -> FB13_W<F11R2_SPEC> {
                FB13_W::new(self, 13)
            }
            ///Bit 14 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb14(&mut self) -> FB14_W<F11R2_SPEC> {
                FB14_W::new(self, 14)
            }
            ///Bit 15 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb15(&mut self) -> FB15_W<F11R2_SPEC> {
                FB15_W::new(self, 15)
            }
            ///Bit 16 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb16(&mut self) -> FB16_W<F11R2_SPEC> {
                FB16_W::new(self, 16)
            }
            ///Bit 17 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb17(&mut self) -> FB17_W<F11R2_SPEC> {
                FB17_W::new(self, 17)
            }
            ///Bit 18 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb18(&mut self) -> FB18_W<F11R2_SPEC> {
                FB18_W::new(self, 18)
            }
            ///Bit 19 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb19(&mut self) -> FB19_W<F11R2_SPEC> {
                FB19_W::new(self, 19)
            }
            ///Bit 20 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb20(&mut self) -> FB20_W<F11R2_SPEC> {
                FB20_W::new(self, 20)
            }
            ///Bit 21 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb21(&mut self) -> FB21_W<F11R2_SPEC> {
                FB21_W::new(self, 21)
            }
            ///Bit 22 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb22(&mut self) -> FB22_W<F11R2_SPEC> {
                FB22_W::new(self, 22)
            }
            ///Bit 23 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb23(&mut self) -> FB23_W<F11R2_SPEC> {
                FB23_W::new(self, 23)
            }
            ///Bit 24 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb24(&mut self) -> FB24_W<F11R2_SPEC> {
                FB24_W::new(self, 24)
            }
            ///Bit 25 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb25(&mut self) -> FB25_W<F11R2_SPEC> {
                FB25_W::new(self, 25)
            }
            ///Bit 26 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb26(&mut self) -> FB26_W<F11R2_SPEC> {
                FB26_W::new(self, 26)
            }
            ///Bit 27 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb27(&mut self) -> FB27_W<F11R2_SPEC> {
                FB27_W::new(self, 27)
            }
            ///Bit 28 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb28(&mut self) -> FB28_W<F11R2_SPEC> {
                FB28_W::new(self, 28)
            }
            ///Bit 29 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb29(&mut self) -> FB29_W<F11R2_SPEC> {
                FB29_W::new(self, 29)
            }
            ///Bit 30 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb30(&mut self) -> FB30_W<F11R2_SPEC> {
                FB30_W::new(self, 30)
            }
            ///Bit 31 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb31(&mut self) -> FB31_W<F11R2_SPEC> {
                FB31_W::new(self, 31)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Filter bank 11 register 2
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`f11r2::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`f11r2::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct F11R2_SPEC;
        impl crate::RegisterSpec for F11R2_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`f11r2::R`](R) reader structure
        impl crate::Readable for F11R2_SPEC {}
        ///`write(|w| ..)` method takes [`f11r2::W`](W) writer structure
        impl crate::Writable for F11R2_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets F11R2 to value 0
        impl crate::Resettable for F11R2_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///F12R1 (rw) register accessor: Filter bank 4 register 1
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`f12r1::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`f12r1::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@f12r1`]
    ///module
    pub type F12R1 = crate::Reg<f12r1::F12R1_SPEC>;
    ///Filter bank 4 register 1
    pub mod f12r1 {
        ///Register `F12R1` reader
        pub type R = crate::R<F12R1_SPEC>;
        ///Register `F12R1` writer
        pub type W = crate::W<F12R1_SPEC>;
        ///Field `FB0` reader - Filter bits
        pub type FB0_R = crate::BitReader;
        ///Field `FB0` writer - Filter bits
        pub type FB0_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB1` reader - Filter bits
        pub type FB1_R = crate::BitReader;
        ///Field `FB1` writer - Filter bits
        pub type FB1_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB2` reader - Filter bits
        pub type FB2_R = crate::BitReader;
        ///Field `FB2` writer - Filter bits
        pub type FB2_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB3` reader - Filter bits
        pub type FB3_R = crate::BitReader;
        ///Field `FB3` writer - Filter bits
        pub type FB3_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB4` reader - Filter bits
        pub type FB4_R = crate::BitReader;
        ///Field `FB4` writer - Filter bits
        pub type FB4_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB5` reader - Filter bits
        pub type FB5_R = crate::BitReader;
        ///Field `FB5` writer - Filter bits
        pub type FB5_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB6` reader - Filter bits
        pub type FB6_R = crate::BitReader;
        ///Field `FB6` writer - Filter bits
        pub type FB6_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB7` reader - Filter bits
        pub type FB7_R = crate::BitReader;
        ///Field `FB7` writer - Filter bits
        pub type FB7_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB8` reader - Filter bits
        pub type FB8_R = crate::BitReader;
        ///Field `FB8` writer - Filter bits
        pub type FB8_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB9` reader - Filter bits
        pub type FB9_R = crate::BitReader;
        ///Field `FB9` writer - Filter bits
        pub type FB9_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB10` reader - Filter bits
        pub type FB10_R = crate::BitReader;
        ///Field `FB10` writer - Filter bits
        pub type FB10_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB11` reader - Filter bits
        pub type FB11_R = crate::BitReader;
        ///Field `FB11` writer - Filter bits
        pub type FB11_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB12` reader - Filter bits
        pub type FB12_R = crate::BitReader;
        ///Field `FB12` writer - Filter bits
        pub type FB12_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB13` reader - Filter bits
        pub type FB13_R = crate::BitReader;
        ///Field `FB13` writer - Filter bits
        pub type FB13_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB14` reader - Filter bits
        pub type FB14_R = crate::BitReader;
        ///Field `FB14` writer - Filter bits
        pub type FB14_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB15` reader - Filter bits
        pub type FB15_R = crate::BitReader;
        ///Field `FB15` writer - Filter bits
        pub type FB15_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB16` reader - Filter bits
        pub type FB16_R = crate::BitReader;
        ///Field `FB16` writer - Filter bits
        pub type FB16_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB17` reader - Filter bits
        pub type FB17_R = crate::BitReader;
        ///Field `FB17` writer - Filter bits
        pub type FB17_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB18` reader - Filter bits
        pub type FB18_R = crate::BitReader;
        ///Field `FB18` writer - Filter bits
        pub type FB18_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB19` reader - Filter bits
        pub type FB19_R = crate::BitReader;
        ///Field `FB19` writer - Filter bits
        pub type FB19_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB20` reader - Filter bits
        pub type FB20_R = crate::BitReader;
        ///Field `FB20` writer - Filter bits
        pub type FB20_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB21` reader - Filter bits
        pub type FB21_R = crate::BitReader;
        ///Field `FB21` writer - Filter bits
        pub type FB21_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB22` reader - Filter bits
        pub type FB22_R = crate::BitReader;
        ///Field `FB22` writer - Filter bits
        pub type FB22_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB23` reader - Filter bits
        pub type FB23_R = crate::BitReader;
        ///Field `FB23` writer - Filter bits
        pub type FB23_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB24` reader - Filter bits
        pub type FB24_R = crate::BitReader;
        ///Field `FB24` writer - Filter bits
        pub type FB24_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB25` reader - Filter bits
        pub type FB25_R = crate::BitReader;
        ///Field `FB25` writer - Filter bits
        pub type FB25_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB26` reader - Filter bits
        pub type FB26_R = crate::BitReader;
        ///Field `FB26` writer - Filter bits
        pub type FB26_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB27` reader - Filter bits
        pub type FB27_R = crate::BitReader;
        ///Field `FB27` writer - Filter bits
        pub type FB27_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB28` reader - Filter bits
        pub type FB28_R = crate::BitReader;
        ///Field `FB28` writer - Filter bits
        pub type FB28_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB29` reader - Filter bits
        pub type FB29_R = crate::BitReader;
        ///Field `FB29` writer - Filter bits
        pub type FB29_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB30` reader - Filter bits
        pub type FB30_R = crate::BitReader;
        ///Field `FB30` writer - Filter bits
        pub type FB30_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB31` reader - Filter bits
        pub type FB31_R = crate::BitReader;
        ///Field `FB31` writer - Filter bits
        pub type FB31_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - Filter bits
            #[inline(always)]
            pub fn fb0(&self) -> FB0_R {
                FB0_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Filter bits
            #[inline(always)]
            pub fn fb1(&self) -> FB1_R {
                FB1_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - Filter bits
            #[inline(always)]
            pub fn fb2(&self) -> FB2_R {
                FB2_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - Filter bits
            #[inline(always)]
            pub fn fb3(&self) -> FB3_R {
                FB3_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - Filter bits
            #[inline(always)]
            pub fn fb4(&self) -> FB4_R {
                FB4_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - Filter bits
            #[inline(always)]
            pub fn fb5(&self) -> FB5_R {
                FB5_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - Filter bits
            #[inline(always)]
            pub fn fb6(&self) -> FB6_R {
                FB6_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - Filter bits
            #[inline(always)]
            pub fn fb7(&self) -> FB7_R {
                FB7_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bit 8 - Filter bits
            #[inline(always)]
            pub fn fb8(&self) -> FB8_R {
                FB8_R::new(((self.bits >> 8) & 1) != 0)
            }
            ///Bit 9 - Filter bits
            #[inline(always)]
            pub fn fb9(&self) -> FB9_R {
                FB9_R::new(((self.bits >> 9) & 1) != 0)
            }
            ///Bit 10 - Filter bits
            #[inline(always)]
            pub fn fb10(&self) -> FB10_R {
                FB10_R::new(((self.bits >> 10) & 1) != 0)
            }
            ///Bit 11 - Filter bits
            #[inline(always)]
            pub fn fb11(&self) -> FB11_R {
                FB11_R::new(((self.bits >> 11) & 1) != 0)
            }
            ///Bit 12 - Filter bits
            #[inline(always)]
            pub fn fb12(&self) -> FB12_R {
                FB12_R::new(((self.bits >> 12) & 1) != 0)
            }
            ///Bit 13 - Filter bits
            #[inline(always)]
            pub fn fb13(&self) -> FB13_R {
                FB13_R::new(((self.bits >> 13) & 1) != 0)
            }
            ///Bit 14 - Filter bits
            #[inline(always)]
            pub fn fb14(&self) -> FB14_R {
                FB14_R::new(((self.bits >> 14) & 1) != 0)
            }
            ///Bit 15 - Filter bits
            #[inline(always)]
            pub fn fb15(&self) -> FB15_R {
                FB15_R::new(((self.bits >> 15) & 1) != 0)
            }
            ///Bit 16 - Filter bits
            #[inline(always)]
            pub fn fb16(&self) -> FB16_R {
                FB16_R::new(((self.bits >> 16) & 1) != 0)
            }
            ///Bit 17 - Filter bits
            #[inline(always)]
            pub fn fb17(&self) -> FB17_R {
                FB17_R::new(((self.bits >> 17) & 1) != 0)
            }
            ///Bit 18 - Filter bits
            #[inline(always)]
            pub fn fb18(&self) -> FB18_R {
                FB18_R::new(((self.bits >> 18) & 1) != 0)
            }
            ///Bit 19 - Filter bits
            #[inline(always)]
            pub fn fb19(&self) -> FB19_R {
                FB19_R::new(((self.bits >> 19) & 1) != 0)
            }
            ///Bit 20 - Filter bits
            #[inline(always)]
            pub fn fb20(&self) -> FB20_R {
                FB20_R::new(((self.bits >> 20) & 1) != 0)
            }
            ///Bit 21 - Filter bits
            #[inline(always)]
            pub fn fb21(&self) -> FB21_R {
                FB21_R::new(((self.bits >> 21) & 1) != 0)
            }
            ///Bit 22 - Filter bits
            #[inline(always)]
            pub fn fb22(&self) -> FB22_R {
                FB22_R::new(((self.bits >> 22) & 1) != 0)
            }
            ///Bit 23 - Filter bits
            #[inline(always)]
            pub fn fb23(&self) -> FB23_R {
                FB23_R::new(((self.bits >> 23) & 1) != 0)
            }
            ///Bit 24 - Filter bits
            #[inline(always)]
            pub fn fb24(&self) -> FB24_R {
                FB24_R::new(((self.bits >> 24) & 1) != 0)
            }
            ///Bit 25 - Filter bits
            #[inline(always)]
            pub fn fb25(&self) -> FB25_R {
                FB25_R::new(((self.bits >> 25) & 1) != 0)
            }
            ///Bit 26 - Filter bits
            #[inline(always)]
            pub fn fb26(&self) -> FB26_R {
                FB26_R::new(((self.bits >> 26) & 1) != 0)
            }
            ///Bit 27 - Filter bits
            #[inline(always)]
            pub fn fb27(&self) -> FB27_R {
                FB27_R::new(((self.bits >> 27) & 1) != 0)
            }
            ///Bit 28 - Filter bits
            #[inline(always)]
            pub fn fb28(&self) -> FB28_R {
                FB28_R::new(((self.bits >> 28) & 1) != 0)
            }
            ///Bit 29 - Filter bits
            #[inline(always)]
            pub fn fb29(&self) -> FB29_R {
                FB29_R::new(((self.bits >> 29) & 1) != 0)
            }
            ///Bit 30 - Filter bits
            #[inline(always)]
            pub fn fb30(&self) -> FB30_R {
                FB30_R::new(((self.bits >> 30) & 1) != 0)
            }
            ///Bit 31 - Filter bits
            #[inline(always)]
            pub fn fb31(&self) -> FB31_R {
                FB31_R::new(((self.bits >> 31) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb0(&mut self) -> FB0_W<F12R1_SPEC> {
                FB0_W::new(self, 0)
            }
            ///Bit 1 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb1(&mut self) -> FB1_W<F12R1_SPEC> {
                FB1_W::new(self, 1)
            }
            ///Bit 2 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb2(&mut self) -> FB2_W<F12R1_SPEC> {
                FB2_W::new(self, 2)
            }
            ///Bit 3 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb3(&mut self) -> FB3_W<F12R1_SPEC> {
                FB3_W::new(self, 3)
            }
            ///Bit 4 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb4(&mut self) -> FB4_W<F12R1_SPEC> {
                FB4_W::new(self, 4)
            }
            ///Bit 5 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb5(&mut self) -> FB5_W<F12R1_SPEC> {
                FB5_W::new(self, 5)
            }
            ///Bit 6 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb6(&mut self) -> FB6_W<F12R1_SPEC> {
                FB6_W::new(self, 6)
            }
            ///Bit 7 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb7(&mut self) -> FB7_W<F12R1_SPEC> {
                FB7_W::new(self, 7)
            }
            ///Bit 8 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb8(&mut self) -> FB8_W<F12R1_SPEC> {
                FB8_W::new(self, 8)
            }
            ///Bit 9 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb9(&mut self) -> FB9_W<F12R1_SPEC> {
                FB9_W::new(self, 9)
            }
            ///Bit 10 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb10(&mut self) -> FB10_W<F12R1_SPEC> {
                FB10_W::new(self, 10)
            }
            ///Bit 11 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb11(&mut self) -> FB11_W<F12R1_SPEC> {
                FB11_W::new(self, 11)
            }
            ///Bit 12 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb12(&mut self) -> FB12_W<F12R1_SPEC> {
                FB12_W::new(self, 12)
            }
            ///Bit 13 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb13(&mut self) -> FB13_W<F12R1_SPEC> {
                FB13_W::new(self, 13)
            }
            ///Bit 14 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb14(&mut self) -> FB14_W<F12R1_SPEC> {
                FB14_W::new(self, 14)
            }
            ///Bit 15 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb15(&mut self) -> FB15_W<F12R1_SPEC> {
                FB15_W::new(self, 15)
            }
            ///Bit 16 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb16(&mut self) -> FB16_W<F12R1_SPEC> {
                FB16_W::new(self, 16)
            }
            ///Bit 17 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb17(&mut self) -> FB17_W<F12R1_SPEC> {
                FB17_W::new(self, 17)
            }
            ///Bit 18 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb18(&mut self) -> FB18_W<F12R1_SPEC> {
                FB18_W::new(self, 18)
            }
            ///Bit 19 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb19(&mut self) -> FB19_W<F12R1_SPEC> {
                FB19_W::new(self, 19)
            }
            ///Bit 20 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb20(&mut self) -> FB20_W<F12R1_SPEC> {
                FB20_W::new(self, 20)
            }
            ///Bit 21 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb21(&mut self) -> FB21_W<F12R1_SPEC> {
                FB21_W::new(self, 21)
            }
            ///Bit 22 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb22(&mut self) -> FB22_W<F12R1_SPEC> {
                FB22_W::new(self, 22)
            }
            ///Bit 23 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb23(&mut self) -> FB23_W<F12R1_SPEC> {
                FB23_W::new(self, 23)
            }
            ///Bit 24 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb24(&mut self) -> FB24_W<F12R1_SPEC> {
                FB24_W::new(self, 24)
            }
            ///Bit 25 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb25(&mut self) -> FB25_W<F12R1_SPEC> {
                FB25_W::new(self, 25)
            }
            ///Bit 26 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb26(&mut self) -> FB26_W<F12R1_SPEC> {
                FB26_W::new(self, 26)
            }
            ///Bit 27 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb27(&mut self) -> FB27_W<F12R1_SPEC> {
                FB27_W::new(self, 27)
            }
            ///Bit 28 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb28(&mut self) -> FB28_W<F12R1_SPEC> {
                FB28_W::new(self, 28)
            }
            ///Bit 29 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb29(&mut self) -> FB29_W<F12R1_SPEC> {
                FB29_W::new(self, 29)
            }
            ///Bit 30 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb30(&mut self) -> FB30_W<F12R1_SPEC> {
                FB30_W::new(self, 30)
            }
            ///Bit 31 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb31(&mut self) -> FB31_W<F12R1_SPEC> {
                FB31_W::new(self, 31)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Filter bank 4 register 1
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`f12r1::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`f12r1::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct F12R1_SPEC;
        impl crate::RegisterSpec for F12R1_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`f12r1::R`](R) reader structure
        impl crate::Readable for F12R1_SPEC {}
        ///`write(|w| ..)` method takes [`f12r1::W`](W) writer structure
        impl crate::Writable for F12R1_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets F12R1 to value 0
        impl crate::Resettable for F12R1_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///F12R2 (rw) register accessor: Filter bank 12 register 2
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`f12r2::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`f12r2::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@f12r2`]
    ///module
    pub type F12R2 = crate::Reg<f12r2::F12R2_SPEC>;
    ///Filter bank 12 register 2
    pub mod f12r2 {
        ///Register `F12R2` reader
        pub type R = crate::R<F12R2_SPEC>;
        ///Register `F12R2` writer
        pub type W = crate::W<F12R2_SPEC>;
        ///Field `FB0` reader - Filter bits
        pub type FB0_R = crate::BitReader;
        ///Field `FB0` writer - Filter bits
        pub type FB0_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB1` reader - Filter bits
        pub type FB1_R = crate::BitReader;
        ///Field `FB1` writer - Filter bits
        pub type FB1_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB2` reader - Filter bits
        pub type FB2_R = crate::BitReader;
        ///Field `FB2` writer - Filter bits
        pub type FB2_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB3` reader - Filter bits
        pub type FB3_R = crate::BitReader;
        ///Field `FB3` writer - Filter bits
        pub type FB3_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB4` reader - Filter bits
        pub type FB4_R = crate::BitReader;
        ///Field `FB4` writer - Filter bits
        pub type FB4_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB5` reader - Filter bits
        pub type FB5_R = crate::BitReader;
        ///Field `FB5` writer - Filter bits
        pub type FB5_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB6` reader - Filter bits
        pub type FB6_R = crate::BitReader;
        ///Field `FB6` writer - Filter bits
        pub type FB6_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB7` reader - Filter bits
        pub type FB7_R = crate::BitReader;
        ///Field `FB7` writer - Filter bits
        pub type FB7_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB8` reader - Filter bits
        pub type FB8_R = crate::BitReader;
        ///Field `FB8` writer - Filter bits
        pub type FB8_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB9` reader - Filter bits
        pub type FB9_R = crate::BitReader;
        ///Field `FB9` writer - Filter bits
        pub type FB9_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB10` reader - Filter bits
        pub type FB10_R = crate::BitReader;
        ///Field `FB10` writer - Filter bits
        pub type FB10_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB11` reader - Filter bits
        pub type FB11_R = crate::BitReader;
        ///Field `FB11` writer - Filter bits
        pub type FB11_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB12` reader - Filter bits
        pub type FB12_R = crate::BitReader;
        ///Field `FB12` writer - Filter bits
        pub type FB12_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB13` reader - Filter bits
        pub type FB13_R = crate::BitReader;
        ///Field `FB13` writer - Filter bits
        pub type FB13_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB14` reader - Filter bits
        pub type FB14_R = crate::BitReader;
        ///Field `FB14` writer - Filter bits
        pub type FB14_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB15` reader - Filter bits
        pub type FB15_R = crate::BitReader;
        ///Field `FB15` writer - Filter bits
        pub type FB15_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB16` reader - Filter bits
        pub type FB16_R = crate::BitReader;
        ///Field `FB16` writer - Filter bits
        pub type FB16_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB17` reader - Filter bits
        pub type FB17_R = crate::BitReader;
        ///Field `FB17` writer - Filter bits
        pub type FB17_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB18` reader - Filter bits
        pub type FB18_R = crate::BitReader;
        ///Field `FB18` writer - Filter bits
        pub type FB18_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB19` reader - Filter bits
        pub type FB19_R = crate::BitReader;
        ///Field `FB19` writer - Filter bits
        pub type FB19_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB20` reader - Filter bits
        pub type FB20_R = crate::BitReader;
        ///Field `FB20` writer - Filter bits
        pub type FB20_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB21` reader - Filter bits
        pub type FB21_R = crate::BitReader;
        ///Field `FB21` writer - Filter bits
        pub type FB21_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB22` reader - Filter bits
        pub type FB22_R = crate::BitReader;
        ///Field `FB22` writer - Filter bits
        pub type FB22_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB23` reader - Filter bits
        pub type FB23_R = crate::BitReader;
        ///Field `FB23` writer - Filter bits
        pub type FB23_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB24` reader - Filter bits
        pub type FB24_R = crate::BitReader;
        ///Field `FB24` writer - Filter bits
        pub type FB24_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB25` reader - Filter bits
        pub type FB25_R = crate::BitReader;
        ///Field `FB25` writer - Filter bits
        pub type FB25_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB26` reader - Filter bits
        pub type FB26_R = crate::BitReader;
        ///Field `FB26` writer - Filter bits
        pub type FB26_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB27` reader - Filter bits
        pub type FB27_R = crate::BitReader;
        ///Field `FB27` writer - Filter bits
        pub type FB27_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB28` reader - Filter bits
        pub type FB28_R = crate::BitReader;
        ///Field `FB28` writer - Filter bits
        pub type FB28_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB29` reader - Filter bits
        pub type FB29_R = crate::BitReader;
        ///Field `FB29` writer - Filter bits
        pub type FB29_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB30` reader - Filter bits
        pub type FB30_R = crate::BitReader;
        ///Field `FB30` writer - Filter bits
        pub type FB30_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB31` reader - Filter bits
        pub type FB31_R = crate::BitReader;
        ///Field `FB31` writer - Filter bits
        pub type FB31_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - Filter bits
            #[inline(always)]
            pub fn fb0(&self) -> FB0_R {
                FB0_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Filter bits
            #[inline(always)]
            pub fn fb1(&self) -> FB1_R {
                FB1_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - Filter bits
            #[inline(always)]
            pub fn fb2(&self) -> FB2_R {
                FB2_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - Filter bits
            #[inline(always)]
            pub fn fb3(&self) -> FB3_R {
                FB3_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - Filter bits
            #[inline(always)]
            pub fn fb4(&self) -> FB4_R {
                FB4_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - Filter bits
            #[inline(always)]
            pub fn fb5(&self) -> FB5_R {
                FB5_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - Filter bits
            #[inline(always)]
            pub fn fb6(&self) -> FB6_R {
                FB6_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - Filter bits
            #[inline(always)]
            pub fn fb7(&self) -> FB7_R {
                FB7_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bit 8 - Filter bits
            #[inline(always)]
            pub fn fb8(&self) -> FB8_R {
                FB8_R::new(((self.bits >> 8) & 1) != 0)
            }
            ///Bit 9 - Filter bits
            #[inline(always)]
            pub fn fb9(&self) -> FB9_R {
                FB9_R::new(((self.bits >> 9) & 1) != 0)
            }
            ///Bit 10 - Filter bits
            #[inline(always)]
            pub fn fb10(&self) -> FB10_R {
                FB10_R::new(((self.bits >> 10) & 1) != 0)
            }
            ///Bit 11 - Filter bits
            #[inline(always)]
            pub fn fb11(&self) -> FB11_R {
                FB11_R::new(((self.bits >> 11) & 1) != 0)
            }
            ///Bit 12 - Filter bits
            #[inline(always)]
            pub fn fb12(&self) -> FB12_R {
                FB12_R::new(((self.bits >> 12) & 1) != 0)
            }
            ///Bit 13 - Filter bits
            #[inline(always)]
            pub fn fb13(&self) -> FB13_R {
                FB13_R::new(((self.bits >> 13) & 1) != 0)
            }
            ///Bit 14 - Filter bits
            #[inline(always)]
            pub fn fb14(&self) -> FB14_R {
                FB14_R::new(((self.bits >> 14) & 1) != 0)
            }
            ///Bit 15 - Filter bits
            #[inline(always)]
            pub fn fb15(&self) -> FB15_R {
                FB15_R::new(((self.bits >> 15) & 1) != 0)
            }
            ///Bit 16 - Filter bits
            #[inline(always)]
            pub fn fb16(&self) -> FB16_R {
                FB16_R::new(((self.bits >> 16) & 1) != 0)
            }
            ///Bit 17 - Filter bits
            #[inline(always)]
            pub fn fb17(&self) -> FB17_R {
                FB17_R::new(((self.bits >> 17) & 1) != 0)
            }
            ///Bit 18 - Filter bits
            #[inline(always)]
            pub fn fb18(&self) -> FB18_R {
                FB18_R::new(((self.bits >> 18) & 1) != 0)
            }
            ///Bit 19 - Filter bits
            #[inline(always)]
            pub fn fb19(&self) -> FB19_R {
                FB19_R::new(((self.bits >> 19) & 1) != 0)
            }
            ///Bit 20 - Filter bits
            #[inline(always)]
            pub fn fb20(&self) -> FB20_R {
                FB20_R::new(((self.bits >> 20) & 1) != 0)
            }
            ///Bit 21 - Filter bits
            #[inline(always)]
            pub fn fb21(&self) -> FB21_R {
                FB21_R::new(((self.bits >> 21) & 1) != 0)
            }
            ///Bit 22 - Filter bits
            #[inline(always)]
            pub fn fb22(&self) -> FB22_R {
                FB22_R::new(((self.bits >> 22) & 1) != 0)
            }
            ///Bit 23 - Filter bits
            #[inline(always)]
            pub fn fb23(&self) -> FB23_R {
                FB23_R::new(((self.bits >> 23) & 1) != 0)
            }
            ///Bit 24 - Filter bits
            #[inline(always)]
            pub fn fb24(&self) -> FB24_R {
                FB24_R::new(((self.bits >> 24) & 1) != 0)
            }
            ///Bit 25 - Filter bits
            #[inline(always)]
            pub fn fb25(&self) -> FB25_R {
                FB25_R::new(((self.bits >> 25) & 1) != 0)
            }
            ///Bit 26 - Filter bits
            #[inline(always)]
            pub fn fb26(&self) -> FB26_R {
                FB26_R::new(((self.bits >> 26) & 1) != 0)
            }
            ///Bit 27 - Filter bits
            #[inline(always)]
            pub fn fb27(&self) -> FB27_R {
                FB27_R::new(((self.bits >> 27) & 1) != 0)
            }
            ///Bit 28 - Filter bits
            #[inline(always)]
            pub fn fb28(&self) -> FB28_R {
                FB28_R::new(((self.bits >> 28) & 1) != 0)
            }
            ///Bit 29 - Filter bits
            #[inline(always)]
            pub fn fb29(&self) -> FB29_R {
                FB29_R::new(((self.bits >> 29) & 1) != 0)
            }
            ///Bit 30 - Filter bits
            #[inline(always)]
            pub fn fb30(&self) -> FB30_R {
                FB30_R::new(((self.bits >> 30) & 1) != 0)
            }
            ///Bit 31 - Filter bits
            #[inline(always)]
            pub fn fb31(&self) -> FB31_R {
                FB31_R::new(((self.bits >> 31) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb0(&mut self) -> FB0_W<F12R2_SPEC> {
                FB0_W::new(self, 0)
            }
            ///Bit 1 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb1(&mut self) -> FB1_W<F12R2_SPEC> {
                FB1_W::new(self, 1)
            }
            ///Bit 2 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb2(&mut self) -> FB2_W<F12R2_SPEC> {
                FB2_W::new(self, 2)
            }
            ///Bit 3 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb3(&mut self) -> FB3_W<F12R2_SPEC> {
                FB3_W::new(self, 3)
            }
            ///Bit 4 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb4(&mut self) -> FB4_W<F12R2_SPEC> {
                FB4_W::new(self, 4)
            }
            ///Bit 5 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb5(&mut self) -> FB5_W<F12R2_SPEC> {
                FB5_W::new(self, 5)
            }
            ///Bit 6 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb6(&mut self) -> FB6_W<F12R2_SPEC> {
                FB6_W::new(self, 6)
            }
            ///Bit 7 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb7(&mut self) -> FB7_W<F12R2_SPEC> {
                FB7_W::new(self, 7)
            }
            ///Bit 8 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb8(&mut self) -> FB8_W<F12R2_SPEC> {
                FB8_W::new(self, 8)
            }
            ///Bit 9 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb9(&mut self) -> FB9_W<F12R2_SPEC> {
                FB9_W::new(self, 9)
            }
            ///Bit 10 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb10(&mut self) -> FB10_W<F12R2_SPEC> {
                FB10_W::new(self, 10)
            }
            ///Bit 11 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb11(&mut self) -> FB11_W<F12R2_SPEC> {
                FB11_W::new(self, 11)
            }
            ///Bit 12 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb12(&mut self) -> FB12_W<F12R2_SPEC> {
                FB12_W::new(self, 12)
            }
            ///Bit 13 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb13(&mut self) -> FB13_W<F12R2_SPEC> {
                FB13_W::new(self, 13)
            }
            ///Bit 14 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb14(&mut self) -> FB14_W<F12R2_SPEC> {
                FB14_W::new(self, 14)
            }
            ///Bit 15 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb15(&mut self) -> FB15_W<F12R2_SPEC> {
                FB15_W::new(self, 15)
            }
            ///Bit 16 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb16(&mut self) -> FB16_W<F12R2_SPEC> {
                FB16_W::new(self, 16)
            }
            ///Bit 17 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb17(&mut self) -> FB17_W<F12R2_SPEC> {
                FB17_W::new(self, 17)
            }
            ///Bit 18 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb18(&mut self) -> FB18_W<F12R2_SPEC> {
                FB18_W::new(self, 18)
            }
            ///Bit 19 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb19(&mut self) -> FB19_W<F12R2_SPEC> {
                FB19_W::new(self, 19)
            }
            ///Bit 20 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb20(&mut self) -> FB20_W<F12R2_SPEC> {
                FB20_W::new(self, 20)
            }
            ///Bit 21 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb21(&mut self) -> FB21_W<F12R2_SPEC> {
                FB21_W::new(self, 21)
            }
            ///Bit 22 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb22(&mut self) -> FB22_W<F12R2_SPEC> {
                FB22_W::new(self, 22)
            }
            ///Bit 23 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb23(&mut self) -> FB23_W<F12R2_SPEC> {
                FB23_W::new(self, 23)
            }
            ///Bit 24 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb24(&mut self) -> FB24_W<F12R2_SPEC> {
                FB24_W::new(self, 24)
            }
            ///Bit 25 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb25(&mut self) -> FB25_W<F12R2_SPEC> {
                FB25_W::new(self, 25)
            }
            ///Bit 26 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb26(&mut self) -> FB26_W<F12R2_SPEC> {
                FB26_W::new(self, 26)
            }
            ///Bit 27 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb27(&mut self) -> FB27_W<F12R2_SPEC> {
                FB27_W::new(self, 27)
            }
            ///Bit 28 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb28(&mut self) -> FB28_W<F12R2_SPEC> {
                FB28_W::new(self, 28)
            }
            ///Bit 29 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb29(&mut self) -> FB29_W<F12R2_SPEC> {
                FB29_W::new(self, 29)
            }
            ///Bit 30 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb30(&mut self) -> FB30_W<F12R2_SPEC> {
                FB30_W::new(self, 30)
            }
            ///Bit 31 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb31(&mut self) -> FB31_W<F12R2_SPEC> {
                FB31_W::new(self, 31)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Filter bank 12 register 2
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`f12r2::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`f12r2::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct F12R2_SPEC;
        impl crate::RegisterSpec for F12R2_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`f12r2::R`](R) reader structure
        impl crate::Readable for F12R2_SPEC {}
        ///`write(|w| ..)` method takes [`f12r2::W`](W) writer structure
        impl crate::Writable for F12R2_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets F12R2 to value 0
        impl crate::Resettable for F12R2_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///F13R1 (rw) register accessor: Filter bank 13 register 1
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`f13r1::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`f13r1::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@f13r1`]
    ///module
    pub type F13R1 = crate::Reg<f13r1::F13R1_SPEC>;
    ///Filter bank 13 register 1
    pub mod f13r1 {
        ///Register `F13R1` reader
        pub type R = crate::R<F13R1_SPEC>;
        ///Register `F13R1` writer
        pub type W = crate::W<F13R1_SPEC>;
        ///Field `FB0` reader - Filter bits
        pub type FB0_R = crate::BitReader;
        ///Field `FB0` writer - Filter bits
        pub type FB0_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB1` reader - Filter bits
        pub type FB1_R = crate::BitReader;
        ///Field `FB1` writer - Filter bits
        pub type FB1_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB2` reader - Filter bits
        pub type FB2_R = crate::BitReader;
        ///Field `FB2` writer - Filter bits
        pub type FB2_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB3` reader - Filter bits
        pub type FB3_R = crate::BitReader;
        ///Field `FB3` writer - Filter bits
        pub type FB3_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB4` reader - Filter bits
        pub type FB4_R = crate::BitReader;
        ///Field `FB4` writer - Filter bits
        pub type FB4_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB5` reader - Filter bits
        pub type FB5_R = crate::BitReader;
        ///Field `FB5` writer - Filter bits
        pub type FB5_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB6` reader - Filter bits
        pub type FB6_R = crate::BitReader;
        ///Field `FB6` writer - Filter bits
        pub type FB6_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB7` reader - Filter bits
        pub type FB7_R = crate::BitReader;
        ///Field `FB7` writer - Filter bits
        pub type FB7_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB8` reader - Filter bits
        pub type FB8_R = crate::BitReader;
        ///Field `FB8` writer - Filter bits
        pub type FB8_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB9` reader - Filter bits
        pub type FB9_R = crate::BitReader;
        ///Field `FB9` writer - Filter bits
        pub type FB9_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB10` reader - Filter bits
        pub type FB10_R = crate::BitReader;
        ///Field `FB10` writer - Filter bits
        pub type FB10_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB11` reader - Filter bits
        pub type FB11_R = crate::BitReader;
        ///Field `FB11` writer - Filter bits
        pub type FB11_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB12` reader - Filter bits
        pub type FB12_R = crate::BitReader;
        ///Field `FB12` writer - Filter bits
        pub type FB12_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB13` reader - Filter bits
        pub type FB13_R = crate::BitReader;
        ///Field `FB13` writer - Filter bits
        pub type FB13_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB14` reader - Filter bits
        pub type FB14_R = crate::BitReader;
        ///Field `FB14` writer - Filter bits
        pub type FB14_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB15` reader - Filter bits
        pub type FB15_R = crate::BitReader;
        ///Field `FB15` writer - Filter bits
        pub type FB15_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB16` reader - Filter bits
        pub type FB16_R = crate::BitReader;
        ///Field `FB16` writer - Filter bits
        pub type FB16_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB17` reader - Filter bits
        pub type FB17_R = crate::BitReader;
        ///Field `FB17` writer - Filter bits
        pub type FB17_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB18` reader - Filter bits
        pub type FB18_R = crate::BitReader;
        ///Field `FB18` writer - Filter bits
        pub type FB18_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB19` reader - Filter bits
        pub type FB19_R = crate::BitReader;
        ///Field `FB19` writer - Filter bits
        pub type FB19_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB20` reader - Filter bits
        pub type FB20_R = crate::BitReader;
        ///Field `FB20` writer - Filter bits
        pub type FB20_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB21` reader - Filter bits
        pub type FB21_R = crate::BitReader;
        ///Field `FB21` writer - Filter bits
        pub type FB21_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB22` reader - Filter bits
        pub type FB22_R = crate::BitReader;
        ///Field `FB22` writer - Filter bits
        pub type FB22_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB23` reader - Filter bits
        pub type FB23_R = crate::BitReader;
        ///Field `FB23` writer - Filter bits
        pub type FB23_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB24` reader - Filter bits
        pub type FB24_R = crate::BitReader;
        ///Field `FB24` writer - Filter bits
        pub type FB24_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB25` reader - Filter bits
        pub type FB25_R = crate::BitReader;
        ///Field `FB25` writer - Filter bits
        pub type FB25_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB26` reader - Filter bits
        pub type FB26_R = crate::BitReader;
        ///Field `FB26` writer - Filter bits
        pub type FB26_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB27` reader - Filter bits
        pub type FB27_R = crate::BitReader;
        ///Field `FB27` writer - Filter bits
        pub type FB27_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB28` reader - Filter bits
        pub type FB28_R = crate::BitReader;
        ///Field `FB28` writer - Filter bits
        pub type FB28_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB29` reader - Filter bits
        pub type FB29_R = crate::BitReader;
        ///Field `FB29` writer - Filter bits
        pub type FB29_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB30` reader - Filter bits
        pub type FB30_R = crate::BitReader;
        ///Field `FB30` writer - Filter bits
        pub type FB30_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB31` reader - Filter bits
        pub type FB31_R = crate::BitReader;
        ///Field `FB31` writer - Filter bits
        pub type FB31_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - Filter bits
            #[inline(always)]
            pub fn fb0(&self) -> FB0_R {
                FB0_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Filter bits
            #[inline(always)]
            pub fn fb1(&self) -> FB1_R {
                FB1_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - Filter bits
            #[inline(always)]
            pub fn fb2(&self) -> FB2_R {
                FB2_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - Filter bits
            #[inline(always)]
            pub fn fb3(&self) -> FB3_R {
                FB3_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - Filter bits
            #[inline(always)]
            pub fn fb4(&self) -> FB4_R {
                FB4_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - Filter bits
            #[inline(always)]
            pub fn fb5(&self) -> FB5_R {
                FB5_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - Filter bits
            #[inline(always)]
            pub fn fb6(&self) -> FB6_R {
                FB6_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - Filter bits
            #[inline(always)]
            pub fn fb7(&self) -> FB7_R {
                FB7_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bit 8 - Filter bits
            #[inline(always)]
            pub fn fb8(&self) -> FB8_R {
                FB8_R::new(((self.bits >> 8) & 1) != 0)
            }
            ///Bit 9 - Filter bits
            #[inline(always)]
            pub fn fb9(&self) -> FB9_R {
                FB9_R::new(((self.bits >> 9) & 1) != 0)
            }
            ///Bit 10 - Filter bits
            #[inline(always)]
            pub fn fb10(&self) -> FB10_R {
                FB10_R::new(((self.bits >> 10) & 1) != 0)
            }
            ///Bit 11 - Filter bits
            #[inline(always)]
            pub fn fb11(&self) -> FB11_R {
                FB11_R::new(((self.bits >> 11) & 1) != 0)
            }
            ///Bit 12 - Filter bits
            #[inline(always)]
            pub fn fb12(&self) -> FB12_R {
                FB12_R::new(((self.bits >> 12) & 1) != 0)
            }
            ///Bit 13 - Filter bits
            #[inline(always)]
            pub fn fb13(&self) -> FB13_R {
                FB13_R::new(((self.bits >> 13) & 1) != 0)
            }
            ///Bit 14 - Filter bits
            #[inline(always)]
            pub fn fb14(&self) -> FB14_R {
                FB14_R::new(((self.bits >> 14) & 1) != 0)
            }
            ///Bit 15 - Filter bits
            #[inline(always)]
            pub fn fb15(&self) -> FB15_R {
                FB15_R::new(((self.bits >> 15) & 1) != 0)
            }
            ///Bit 16 - Filter bits
            #[inline(always)]
            pub fn fb16(&self) -> FB16_R {
                FB16_R::new(((self.bits >> 16) & 1) != 0)
            }
            ///Bit 17 - Filter bits
            #[inline(always)]
            pub fn fb17(&self) -> FB17_R {
                FB17_R::new(((self.bits >> 17) & 1) != 0)
            }
            ///Bit 18 - Filter bits
            #[inline(always)]
            pub fn fb18(&self) -> FB18_R {
                FB18_R::new(((self.bits >> 18) & 1) != 0)
            }
            ///Bit 19 - Filter bits
            #[inline(always)]
            pub fn fb19(&self) -> FB19_R {
                FB19_R::new(((self.bits >> 19) & 1) != 0)
            }
            ///Bit 20 - Filter bits
            #[inline(always)]
            pub fn fb20(&self) -> FB20_R {
                FB20_R::new(((self.bits >> 20) & 1) != 0)
            }
            ///Bit 21 - Filter bits
            #[inline(always)]
            pub fn fb21(&self) -> FB21_R {
                FB21_R::new(((self.bits >> 21) & 1) != 0)
            }
            ///Bit 22 - Filter bits
            #[inline(always)]
            pub fn fb22(&self) -> FB22_R {
                FB22_R::new(((self.bits >> 22) & 1) != 0)
            }
            ///Bit 23 - Filter bits
            #[inline(always)]
            pub fn fb23(&self) -> FB23_R {
                FB23_R::new(((self.bits >> 23) & 1) != 0)
            }
            ///Bit 24 - Filter bits
            #[inline(always)]
            pub fn fb24(&self) -> FB24_R {
                FB24_R::new(((self.bits >> 24) & 1) != 0)
            }
            ///Bit 25 - Filter bits
            #[inline(always)]
            pub fn fb25(&self) -> FB25_R {
                FB25_R::new(((self.bits >> 25) & 1) != 0)
            }
            ///Bit 26 - Filter bits
            #[inline(always)]
            pub fn fb26(&self) -> FB26_R {
                FB26_R::new(((self.bits >> 26) & 1) != 0)
            }
            ///Bit 27 - Filter bits
            #[inline(always)]
            pub fn fb27(&self) -> FB27_R {
                FB27_R::new(((self.bits >> 27) & 1) != 0)
            }
            ///Bit 28 - Filter bits
            #[inline(always)]
            pub fn fb28(&self) -> FB28_R {
                FB28_R::new(((self.bits >> 28) & 1) != 0)
            }
            ///Bit 29 - Filter bits
            #[inline(always)]
            pub fn fb29(&self) -> FB29_R {
                FB29_R::new(((self.bits >> 29) & 1) != 0)
            }
            ///Bit 30 - Filter bits
            #[inline(always)]
            pub fn fb30(&self) -> FB30_R {
                FB30_R::new(((self.bits >> 30) & 1) != 0)
            }
            ///Bit 31 - Filter bits
            #[inline(always)]
            pub fn fb31(&self) -> FB31_R {
                FB31_R::new(((self.bits >> 31) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb0(&mut self) -> FB0_W<F13R1_SPEC> {
                FB0_W::new(self, 0)
            }
            ///Bit 1 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb1(&mut self) -> FB1_W<F13R1_SPEC> {
                FB1_W::new(self, 1)
            }
            ///Bit 2 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb2(&mut self) -> FB2_W<F13R1_SPEC> {
                FB2_W::new(self, 2)
            }
            ///Bit 3 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb3(&mut self) -> FB3_W<F13R1_SPEC> {
                FB3_W::new(self, 3)
            }
            ///Bit 4 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb4(&mut self) -> FB4_W<F13R1_SPEC> {
                FB4_W::new(self, 4)
            }
            ///Bit 5 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb5(&mut self) -> FB5_W<F13R1_SPEC> {
                FB5_W::new(self, 5)
            }
            ///Bit 6 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb6(&mut self) -> FB6_W<F13R1_SPEC> {
                FB6_W::new(self, 6)
            }
            ///Bit 7 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb7(&mut self) -> FB7_W<F13R1_SPEC> {
                FB7_W::new(self, 7)
            }
            ///Bit 8 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb8(&mut self) -> FB8_W<F13R1_SPEC> {
                FB8_W::new(self, 8)
            }
            ///Bit 9 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb9(&mut self) -> FB9_W<F13R1_SPEC> {
                FB9_W::new(self, 9)
            }
            ///Bit 10 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb10(&mut self) -> FB10_W<F13R1_SPEC> {
                FB10_W::new(self, 10)
            }
            ///Bit 11 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb11(&mut self) -> FB11_W<F13R1_SPEC> {
                FB11_W::new(self, 11)
            }
            ///Bit 12 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb12(&mut self) -> FB12_W<F13R1_SPEC> {
                FB12_W::new(self, 12)
            }
            ///Bit 13 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb13(&mut self) -> FB13_W<F13R1_SPEC> {
                FB13_W::new(self, 13)
            }
            ///Bit 14 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb14(&mut self) -> FB14_W<F13R1_SPEC> {
                FB14_W::new(self, 14)
            }
            ///Bit 15 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb15(&mut self) -> FB15_W<F13R1_SPEC> {
                FB15_W::new(self, 15)
            }
            ///Bit 16 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb16(&mut self) -> FB16_W<F13R1_SPEC> {
                FB16_W::new(self, 16)
            }
            ///Bit 17 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb17(&mut self) -> FB17_W<F13R1_SPEC> {
                FB17_W::new(self, 17)
            }
            ///Bit 18 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb18(&mut self) -> FB18_W<F13R1_SPEC> {
                FB18_W::new(self, 18)
            }
            ///Bit 19 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb19(&mut self) -> FB19_W<F13R1_SPEC> {
                FB19_W::new(self, 19)
            }
            ///Bit 20 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb20(&mut self) -> FB20_W<F13R1_SPEC> {
                FB20_W::new(self, 20)
            }
            ///Bit 21 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb21(&mut self) -> FB21_W<F13R1_SPEC> {
                FB21_W::new(self, 21)
            }
            ///Bit 22 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb22(&mut self) -> FB22_W<F13R1_SPEC> {
                FB22_W::new(self, 22)
            }
            ///Bit 23 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb23(&mut self) -> FB23_W<F13R1_SPEC> {
                FB23_W::new(self, 23)
            }
            ///Bit 24 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb24(&mut self) -> FB24_W<F13R1_SPEC> {
                FB24_W::new(self, 24)
            }
            ///Bit 25 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb25(&mut self) -> FB25_W<F13R1_SPEC> {
                FB25_W::new(self, 25)
            }
            ///Bit 26 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb26(&mut self) -> FB26_W<F13R1_SPEC> {
                FB26_W::new(self, 26)
            }
            ///Bit 27 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb27(&mut self) -> FB27_W<F13R1_SPEC> {
                FB27_W::new(self, 27)
            }
            ///Bit 28 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb28(&mut self) -> FB28_W<F13R1_SPEC> {
                FB28_W::new(self, 28)
            }
            ///Bit 29 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb29(&mut self) -> FB29_W<F13R1_SPEC> {
                FB29_W::new(self, 29)
            }
            ///Bit 30 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb30(&mut self) -> FB30_W<F13R1_SPEC> {
                FB30_W::new(self, 30)
            }
            ///Bit 31 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb31(&mut self) -> FB31_W<F13R1_SPEC> {
                FB31_W::new(self, 31)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Filter bank 13 register 1
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`f13r1::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`f13r1::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct F13R1_SPEC;
        impl crate::RegisterSpec for F13R1_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`f13r1::R`](R) reader structure
        impl crate::Readable for F13R1_SPEC {}
        ///`write(|w| ..)` method takes [`f13r1::W`](W) writer structure
        impl crate::Writable for F13R1_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets F13R1 to value 0
        impl crate::Resettable for F13R1_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///F13R2 (rw) register accessor: Filter bank 13 register 2
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`f13r2::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`f13r2::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@f13r2`]
    ///module
    pub type F13R2 = crate::Reg<f13r2::F13R2_SPEC>;
    ///Filter bank 13 register 2
    pub mod f13r2 {
        ///Register `F13R2` reader
        pub type R = crate::R<F13R2_SPEC>;
        ///Register `F13R2` writer
        pub type W = crate::W<F13R2_SPEC>;
        ///Field `FB0` reader - Filter bits
        pub type FB0_R = crate::BitReader;
        ///Field `FB0` writer - Filter bits
        pub type FB0_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB1` reader - Filter bits
        pub type FB1_R = crate::BitReader;
        ///Field `FB1` writer - Filter bits
        pub type FB1_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB2` reader - Filter bits
        pub type FB2_R = crate::BitReader;
        ///Field `FB2` writer - Filter bits
        pub type FB2_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB3` reader - Filter bits
        pub type FB3_R = crate::BitReader;
        ///Field `FB3` writer - Filter bits
        pub type FB3_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB4` reader - Filter bits
        pub type FB4_R = crate::BitReader;
        ///Field `FB4` writer - Filter bits
        pub type FB4_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB5` reader - Filter bits
        pub type FB5_R = crate::BitReader;
        ///Field `FB5` writer - Filter bits
        pub type FB5_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB6` reader - Filter bits
        pub type FB6_R = crate::BitReader;
        ///Field `FB6` writer - Filter bits
        pub type FB6_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB7` reader - Filter bits
        pub type FB7_R = crate::BitReader;
        ///Field `FB7` writer - Filter bits
        pub type FB7_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB8` reader - Filter bits
        pub type FB8_R = crate::BitReader;
        ///Field `FB8` writer - Filter bits
        pub type FB8_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB9` reader - Filter bits
        pub type FB9_R = crate::BitReader;
        ///Field `FB9` writer - Filter bits
        pub type FB9_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB10` reader - Filter bits
        pub type FB10_R = crate::BitReader;
        ///Field `FB10` writer - Filter bits
        pub type FB10_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB11` reader - Filter bits
        pub type FB11_R = crate::BitReader;
        ///Field `FB11` writer - Filter bits
        pub type FB11_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB12` reader - Filter bits
        pub type FB12_R = crate::BitReader;
        ///Field `FB12` writer - Filter bits
        pub type FB12_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB13` reader - Filter bits
        pub type FB13_R = crate::BitReader;
        ///Field `FB13` writer - Filter bits
        pub type FB13_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB14` reader - Filter bits
        pub type FB14_R = crate::BitReader;
        ///Field `FB14` writer - Filter bits
        pub type FB14_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB15` reader - Filter bits
        pub type FB15_R = crate::BitReader;
        ///Field `FB15` writer - Filter bits
        pub type FB15_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB16` reader - Filter bits
        pub type FB16_R = crate::BitReader;
        ///Field `FB16` writer - Filter bits
        pub type FB16_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB17` reader - Filter bits
        pub type FB17_R = crate::BitReader;
        ///Field `FB17` writer - Filter bits
        pub type FB17_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB18` reader - Filter bits
        pub type FB18_R = crate::BitReader;
        ///Field `FB18` writer - Filter bits
        pub type FB18_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB19` reader - Filter bits
        pub type FB19_R = crate::BitReader;
        ///Field `FB19` writer - Filter bits
        pub type FB19_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB20` reader - Filter bits
        pub type FB20_R = crate::BitReader;
        ///Field `FB20` writer - Filter bits
        pub type FB20_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB21` reader - Filter bits
        pub type FB21_R = crate::BitReader;
        ///Field `FB21` writer - Filter bits
        pub type FB21_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB22` reader - Filter bits
        pub type FB22_R = crate::BitReader;
        ///Field `FB22` writer - Filter bits
        pub type FB22_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB23` reader - Filter bits
        pub type FB23_R = crate::BitReader;
        ///Field `FB23` writer - Filter bits
        pub type FB23_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB24` reader - Filter bits
        pub type FB24_R = crate::BitReader;
        ///Field `FB24` writer - Filter bits
        pub type FB24_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB25` reader - Filter bits
        pub type FB25_R = crate::BitReader;
        ///Field `FB25` writer - Filter bits
        pub type FB25_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB26` reader - Filter bits
        pub type FB26_R = crate::BitReader;
        ///Field `FB26` writer - Filter bits
        pub type FB26_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB27` reader - Filter bits
        pub type FB27_R = crate::BitReader;
        ///Field `FB27` writer - Filter bits
        pub type FB27_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB28` reader - Filter bits
        pub type FB28_R = crate::BitReader;
        ///Field `FB28` writer - Filter bits
        pub type FB28_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB29` reader - Filter bits
        pub type FB29_R = crate::BitReader;
        ///Field `FB29` writer - Filter bits
        pub type FB29_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB30` reader - Filter bits
        pub type FB30_R = crate::BitReader;
        ///Field `FB30` writer - Filter bits
        pub type FB30_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FB31` reader - Filter bits
        pub type FB31_R = crate::BitReader;
        ///Field `FB31` writer - Filter bits
        pub type FB31_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - Filter bits
            #[inline(always)]
            pub fn fb0(&self) -> FB0_R {
                FB0_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Filter bits
            #[inline(always)]
            pub fn fb1(&self) -> FB1_R {
                FB1_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - Filter bits
            #[inline(always)]
            pub fn fb2(&self) -> FB2_R {
                FB2_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - Filter bits
            #[inline(always)]
            pub fn fb3(&self) -> FB3_R {
                FB3_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - Filter bits
            #[inline(always)]
            pub fn fb4(&self) -> FB4_R {
                FB4_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - Filter bits
            #[inline(always)]
            pub fn fb5(&self) -> FB5_R {
                FB5_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - Filter bits
            #[inline(always)]
            pub fn fb6(&self) -> FB6_R {
                FB6_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - Filter bits
            #[inline(always)]
            pub fn fb7(&self) -> FB7_R {
                FB7_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bit 8 - Filter bits
            #[inline(always)]
            pub fn fb8(&self) -> FB8_R {
                FB8_R::new(((self.bits >> 8) & 1) != 0)
            }
            ///Bit 9 - Filter bits
            #[inline(always)]
            pub fn fb9(&self) -> FB9_R {
                FB9_R::new(((self.bits >> 9) & 1) != 0)
            }
            ///Bit 10 - Filter bits
            #[inline(always)]
            pub fn fb10(&self) -> FB10_R {
                FB10_R::new(((self.bits >> 10) & 1) != 0)
            }
            ///Bit 11 - Filter bits
            #[inline(always)]
            pub fn fb11(&self) -> FB11_R {
                FB11_R::new(((self.bits >> 11) & 1) != 0)
            }
            ///Bit 12 - Filter bits
            #[inline(always)]
            pub fn fb12(&self) -> FB12_R {
                FB12_R::new(((self.bits >> 12) & 1) != 0)
            }
            ///Bit 13 - Filter bits
            #[inline(always)]
            pub fn fb13(&self) -> FB13_R {
                FB13_R::new(((self.bits >> 13) & 1) != 0)
            }
            ///Bit 14 - Filter bits
            #[inline(always)]
            pub fn fb14(&self) -> FB14_R {
                FB14_R::new(((self.bits >> 14) & 1) != 0)
            }
            ///Bit 15 - Filter bits
            #[inline(always)]
            pub fn fb15(&self) -> FB15_R {
                FB15_R::new(((self.bits >> 15) & 1) != 0)
            }
            ///Bit 16 - Filter bits
            #[inline(always)]
            pub fn fb16(&self) -> FB16_R {
                FB16_R::new(((self.bits >> 16) & 1) != 0)
            }
            ///Bit 17 - Filter bits
            #[inline(always)]
            pub fn fb17(&self) -> FB17_R {
                FB17_R::new(((self.bits >> 17) & 1) != 0)
            }
            ///Bit 18 - Filter bits
            #[inline(always)]
            pub fn fb18(&self) -> FB18_R {
                FB18_R::new(((self.bits >> 18) & 1) != 0)
            }
            ///Bit 19 - Filter bits
            #[inline(always)]
            pub fn fb19(&self) -> FB19_R {
                FB19_R::new(((self.bits >> 19) & 1) != 0)
            }
            ///Bit 20 - Filter bits
            #[inline(always)]
            pub fn fb20(&self) -> FB20_R {
                FB20_R::new(((self.bits >> 20) & 1) != 0)
            }
            ///Bit 21 - Filter bits
            #[inline(always)]
            pub fn fb21(&self) -> FB21_R {
                FB21_R::new(((self.bits >> 21) & 1) != 0)
            }
            ///Bit 22 - Filter bits
            #[inline(always)]
            pub fn fb22(&self) -> FB22_R {
                FB22_R::new(((self.bits >> 22) & 1) != 0)
            }
            ///Bit 23 - Filter bits
            #[inline(always)]
            pub fn fb23(&self) -> FB23_R {
                FB23_R::new(((self.bits >> 23) & 1) != 0)
            }
            ///Bit 24 - Filter bits
            #[inline(always)]
            pub fn fb24(&self) -> FB24_R {
                FB24_R::new(((self.bits >> 24) & 1) != 0)
            }
            ///Bit 25 - Filter bits
            #[inline(always)]
            pub fn fb25(&self) -> FB25_R {
                FB25_R::new(((self.bits >> 25) & 1) != 0)
            }
            ///Bit 26 - Filter bits
            #[inline(always)]
            pub fn fb26(&self) -> FB26_R {
                FB26_R::new(((self.bits >> 26) & 1) != 0)
            }
            ///Bit 27 - Filter bits
            #[inline(always)]
            pub fn fb27(&self) -> FB27_R {
                FB27_R::new(((self.bits >> 27) & 1) != 0)
            }
            ///Bit 28 - Filter bits
            #[inline(always)]
            pub fn fb28(&self) -> FB28_R {
                FB28_R::new(((self.bits >> 28) & 1) != 0)
            }
            ///Bit 29 - Filter bits
            #[inline(always)]
            pub fn fb29(&self) -> FB29_R {
                FB29_R::new(((self.bits >> 29) & 1) != 0)
            }
            ///Bit 30 - Filter bits
            #[inline(always)]
            pub fn fb30(&self) -> FB30_R {
                FB30_R::new(((self.bits >> 30) & 1) != 0)
            }
            ///Bit 31 - Filter bits
            #[inline(always)]
            pub fn fb31(&self) -> FB31_R {
                FB31_R::new(((self.bits >> 31) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb0(&mut self) -> FB0_W<F13R2_SPEC> {
                FB0_W::new(self, 0)
            }
            ///Bit 1 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb1(&mut self) -> FB1_W<F13R2_SPEC> {
                FB1_W::new(self, 1)
            }
            ///Bit 2 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb2(&mut self) -> FB2_W<F13R2_SPEC> {
                FB2_W::new(self, 2)
            }
            ///Bit 3 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb3(&mut self) -> FB3_W<F13R2_SPEC> {
                FB3_W::new(self, 3)
            }
            ///Bit 4 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb4(&mut self) -> FB4_W<F13R2_SPEC> {
                FB4_W::new(self, 4)
            }
            ///Bit 5 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb5(&mut self) -> FB5_W<F13R2_SPEC> {
                FB5_W::new(self, 5)
            }
            ///Bit 6 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb6(&mut self) -> FB6_W<F13R2_SPEC> {
                FB6_W::new(self, 6)
            }
            ///Bit 7 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb7(&mut self) -> FB7_W<F13R2_SPEC> {
                FB7_W::new(self, 7)
            }
            ///Bit 8 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb8(&mut self) -> FB8_W<F13R2_SPEC> {
                FB8_W::new(self, 8)
            }
            ///Bit 9 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb9(&mut self) -> FB9_W<F13R2_SPEC> {
                FB9_W::new(self, 9)
            }
            ///Bit 10 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb10(&mut self) -> FB10_W<F13R2_SPEC> {
                FB10_W::new(self, 10)
            }
            ///Bit 11 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb11(&mut self) -> FB11_W<F13R2_SPEC> {
                FB11_W::new(self, 11)
            }
            ///Bit 12 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb12(&mut self) -> FB12_W<F13R2_SPEC> {
                FB12_W::new(self, 12)
            }
            ///Bit 13 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb13(&mut self) -> FB13_W<F13R2_SPEC> {
                FB13_W::new(self, 13)
            }
            ///Bit 14 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb14(&mut self) -> FB14_W<F13R2_SPEC> {
                FB14_W::new(self, 14)
            }
            ///Bit 15 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb15(&mut self) -> FB15_W<F13R2_SPEC> {
                FB15_W::new(self, 15)
            }
            ///Bit 16 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb16(&mut self) -> FB16_W<F13R2_SPEC> {
                FB16_W::new(self, 16)
            }
            ///Bit 17 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb17(&mut self) -> FB17_W<F13R2_SPEC> {
                FB17_W::new(self, 17)
            }
            ///Bit 18 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb18(&mut self) -> FB18_W<F13R2_SPEC> {
                FB18_W::new(self, 18)
            }
            ///Bit 19 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb19(&mut self) -> FB19_W<F13R2_SPEC> {
                FB19_W::new(self, 19)
            }
            ///Bit 20 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb20(&mut self) -> FB20_W<F13R2_SPEC> {
                FB20_W::new(self, 20)
            }
            ///Bit 21 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb21(&mut self) -> FB21_W<F13R2_SPEC> {
                FB21_W::new(self, 21)
            }
            ///Bit 22 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb22(&mut self) -> FB22_W<F13R2_SPEC> {
                FB22_W::new(self, 22)
            }
            ///Bit 23 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb23(&mut self) -> FB23_W<F13R2_SPEC> {
                FB23_W::new(self, 23)
            }
            ///Bit 24 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb24(&mut self) -> FB24_W<F13R2_SPEC> {
                FB24_W::new(self, 24)
            }
            ///Bit 25 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb25(&mut self) -> FB25_W<F13R2_SPEC> {
                FB25_W::new(self, 25)
            }
            ///Bit 26 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb26(&mut self) -> FB26_W<F13R2_SPEC> {
                FB26_W::new(self, 26)
            }
            ///Bit 27 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb27(&mut self) -> FB27_W<F13R2_SPEC> {
                FB27_W::new(self, 27)
            }
            ///Bit 28 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb28(&mut self) -> FB28_W<F13R2_SPEC> {
                FB28_W::new(self, 28)
            }
            ///Bit 29 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb29(&mut self) -> FB29_W<F13R2_SPEC> {
                FB29_W::new(self, 29)
            }
            ///Bit 30 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb30(&mut self) -> FB30_W<F13R2_SPEC> {
                FB30_W::new(self, 30)
            }
            ///Bit 31 - Filter bits
            #[inline(always)]
            #[must_use]
            pub fn fb31(&mut self) -> FB31_W<F13R2_SPEC> {
                FB31_W::new(self, 31)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Filter bank 13 register 2
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`f13r2::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`f13r2::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct F13R2_SPEC;
        impl crate::RegisterSpec for F13R2_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`f13r2::R`](R) reader structure
        impl crate::Readable for F13R2_SPEC {}
        ///`write(|w| ..)` method takes [`f13r2::W`](W) writer structure
        impl crate::Writable for F13R2_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets F13R2 to value 0
        impl crate::Resettable for F13R2_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
}
///Power control
pub struct PWR {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for PWR {}
impl PWR {
    ///Pointer to the register block
    pub const PTR: *const pwr::RegisterBlock = 0x4000_7000 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const pwr::RegisterBlock {
        Self::PTR
    }
    /// Steal an instance of this peripheral
    ///
    /// # Safety
    ///
    /// Ensure that the new instance of the peripheral cannot be used in a way
    /// that may race with any existing instances, for example by only
    /// accessing read-only or write-only registers, or by consuming the
    /// original peripheral and using critical sections to coordinate
    /// access between multiple new instances.
    ///
    /// Additionally, other software such as HALs may rely on only one
    /// peripheral instance existing to ensure memory safety; ensure
    /// no stolen instances are passed to such software.
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for PWR {
    type Target = pwr::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for PWR {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("PWR").finish()
    }
}
///Power control
pub mod pwr {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        ctlr: CTLR,
        csr: CSR,
    }
    impl RegisterBlock {
        ///0x00 - Power control register (PWR_CTRL)
        #[inline(always)]
        pub const fn ctlr(&self) -> &CTLR {
            &self.ctlr
        }
        ///0x04 - Power control register(PWR_CSR)
        #[inline(always)]
        pub const fn csr(&self) -> &CSR {
            &self.csr
        }
    }
    ///CTLR (rw) register accessor: Power control register (PWR_CTRL)
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`ctlr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ctlr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@ctlr`]
    ///module
    pub type CTLR = crate::Reg<ctlr::CTLR_SPEC>;
    ///Power control register (PWR_CTRL)
    pub mod ctlr {
        ///Register `CTLR` reader
        pub type R = crate::R<CTLR_SPEC>;
        ///Register `CTLR` writer
        pub type W = crate::W<CTLR_SPEC>;
        ///Field `LPDS` reader - Low Power Deep Sleep
        pub type LPDS_R = crate::BitReader;
        ///Field `LPDS` writer - Low Power Deep Sleep
        pub type LPDS_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PDDS` reader - Power Down Deep Sleep
        pub type PDDS_R = crate::BitReader;
        ///Field `PDDS` writer - Power Down Deep Sleep
        pub type PDDS_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CWUF` reader - Clear Wake-up Flag
        pub type CWUF_R = crate::BitReader;
        ///Field `CWUF` writer - Clear Wake-up Flag
        pub type CWUF_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CSBF` reader - Clear STANDBY Flag
        pub type CSBF_R = crate::BitReader;
        ///Field `CSBF` writer - Clear STANDBY Flag
        pub type CSBF_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PVDE` reader - Power Voltage Detector Enable
        pub type PVDE_R = crate::BitReader;
        ///Field `PVDE` writer - Power Voltage Detector Enable
        pub type PVDE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PLS` reader - PVD Level Selection
        pub type PLS_R = crate::FieldReader;
        ///Field `PLS` writer - PVD Level Selection
        pub type PLS_W<'a, REG> = crate::FieldWriter<'a, REG, 3>;
        ///Field `DBP` reader - Disable Backup Domain write protection
        pub type DBP_R = crate::BitReader;
        ///Field `DBP` writer - Disable Backup Domain write protection
        pub type DBP_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FLASH_LP_REG` reader - FLASH Low-power enable
        pub type FLASH_LP_REG_R = crate::BitReader;
        ///Field `FLASH_LP_REG` writer - FLASH Low-power enable
        pub type FLASH_LP_REG_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FLASH_LP` reader - configuration FLASH status
        pub type FLASH_LP_R = crate::FieldReader;
        ///Field `FLASH_LP` writer - configuration FLASH status
        pub type FLASH_LP_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `AUTO_LDO_LP` reader - LDO status
        pub type AUTO_LDO_LP_R = crate::BitReader;
        ///Field `AUTO_LDO_LP` writer - LDO status
        pub type AUTO_LDO_LP_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `LDO_LP` reader - LDO low-power mode enable
        pub type LDO_LP_R = crate::BitReader;
        ///Field `LDO_LP` writer - LDO low-power mode enable
        pub type LDO_LP_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `R2KSTY` reader - standby 2k ram enable
        pub type R2KSTY_R = crate::BitReader;
        ///Field `R2KSTY` writer - standby 2k ram enable
        pub type R2KSTY_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `R18KSTY` reader - standby 18k ram enable
        pub type R18KSTY_R = crate::BitReader;
        ///Field `R18KSTY` writer - standby 18k ram enable
        pub type R18KSTY_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `R2KVBAT` reader - VBAT 2k ram enable
        pub type R2KVBAT_R = crate::BitReader;
        ///Field `R2KVBAT` writer - VBAT 2k ram enable
        pub type R2KVBAT_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `R18KVBAT` reader - VBAT 18k ram enable
        pub type R18KVBAT_R = crate::BitReader;
        ///Field `R18KVBAT` writer - VBAT 18k ram enable
        pub type R18KVBAT_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `RAMLV` reader - Ram LV Enable
        pub type RAMLV_R = crate::BitReader;
        ///Field `RAMLV` writer - Ram LV Enable
        pub type RAMLV_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - Low Power Deep Sleep
            #[inline(always)]
            pub fn lpds(&self) -> LPDS_R {
                LPDS_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Power Down Deep Sleep
            #[inline(always)]
            pub fn pdds(&self) -> PDDS_R {
                PDDS_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - Clear Wake-up Flag
            #[inline(always)]
            pub fn cwuf(&self) -> CWUF_R {
                CWUF_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - Clear STANDBY Flag
            #[inline(always)]
            pub fn csbf(&self) -> CSBF_R {
                CSBF_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - Power Voltage Detector Enable
            #[inline(always)]
            pub fn pvde(&self) -> PVDE_R {
                PVDE_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bits 5:7 - PVD Level Selection
            #[inline(always)]
            pub fn pls(&self) -> PLS_R {
                PLS_R::new(((self.bits >> 5) & 7) as u8)
            }
            ///Bit 8 - Disable Backup Domain write protection
            #[inline(always)]
            pub fn dbp(&self) -> DBP_R {
                DBP_R::new(((self.bits >> 8) & 1) != 0)
            }
            ///Bit 9 - FLASH Low-power enable
            #[inline(always)]
            pub fn flash_lp_reg(&self) -> FLASH_LP_REG_R {
                FLASH_LP_REG_R::new(((self.bits >> 9) & 1) != 0)
            }
            ///Bits 10:11 - configuration FLASH status
            #[inline(always)]
            pub fn flash_lp(&self) -> FLASH_LP_R {
                FLASH_LP_R::new(((self.bits >> 10) & 3) as u8)
            }
            ///Bit 12 - LDO status
            #[inline(always)]
            pub fn auto_ldo_lp(&self) -> AUTO_LDO_LP_R {
                AUTO_LDO_LP_R::new(((self.bits >> 12) & 1) != 0)
            }
            ///Bit 13 - LDO low-power mode enable
            #[inline(always)]
            pub fn ldo_lp(&self) -> LDO_LP_R {
                LDO_LP_R::new(((self.bits >> 13) & 1) != 0)
            }
            ///Bit 16 - standby 2k ram enable
            #[inline(always)]
            pub fn r2ksty(&self) -> R2KSTY_R {
                R2KSTY_R::new(((self.bits >> 16) & 1) != 0)
            }
            ///Bit 17 - standby 18k ram enable
            #[inline(always)]
            pub fn r18ksty(&self) -> R18KSTY_R {
                R18KSTY_R::new(((self.bits >> 17) & 1) != 0)
            }
            ///Bit 18 - VBAT 2k ram enable
            #[inline(always)]
            pub fn r2kvbat(&self) -> R2KVBAT_R {
                R2KVBAT_R::new(((self.bits >> 18) & 1) != 0)
            }
            ///Bit 19 - VBAT 18k ram enable
            #[inline(always)]
            pub fn r18kvbat(&self) -> R18KVBAT_R {
                R18KVBAT_R::new(((self.bits >> 19) & 1) != 0)
            }
            ///Bit 20 - Ram LV Enable
            #[inline(always)]
            pub fn ramlv(&self) -> RAMLV_R {
                RAMLV_R::new(((self.bits >> 20) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - Low Power Deep Sleep
            #[inline(always)]
            #[must_use]
            pub fn lpds(&mut self) -> LPDS_W<CTLR_SPEC> {
                LPDS_W::new(self, 0)
            }
            ///Bit 1 - Power Down Deep Sleep
            #[inline(always)]
            #[must_use]
            pub fn pdds(&mut self) -> PDDS_W<CTLR_SPEC> {
                PDDS_W::new(self, 1)
            }
            ///Bit 2 - Clear Wake-up Flag
            #[inline(always)]
            #[must_use]
            pub fn cwuf(&mut self) -> CWUF_W<CTLR_SPEC> {
                CWUF_W::new(self, 2)
            }
            ///Bit 3 - Clear STANDBY Flag
            #[inline(always)]
            #[must_use]
            pub fn csbf(&mut self) -> CSBF_W<CTLR_SPEC> {
                CSBF_W::new(self, 3)
            }
            ///Bit 4 - Power Voltage Detector Enable
            #[inline(always)]
            #[must_use]
            pub fn pvde(&mut self) -> PVDE_W<CTLR_SPEC> {
                PVDE_W::new(self, 4)
            }
            ///Bits 5:7 - PVD Level Selection
            #[inline(always)]
            #[must_use]
            pub fn pls(&mut self) -> PLS_W<CTLR_SPEC> {
                PLS_W::new(self, 5)
            }
            ///Bit 8 - Disable Backup Domain write protection
            #[inline(always)]
            #[must_use]
            pub fn dbp(&mut self) -> DBP_W<CTLR_SPEC> {
                DBP_W::new(self, 8)
            }
            ///Bit 9 - FLASH Low-power enable
            #[inline(always)]
            #[must_use]
            pub fn flash_lp_reg(&mut self) -> FLASH_LP_REG_W<CTLR_SPEC> {
                FLASH_LP_REG_W::new(self, 9)
            }
            ///Bits 10:11 - configuration FLASH status
            #[inline(always)]
            #[must_use]
            pub fn flash_lp(&mut self) -> FLASH_LP_W<CTLR_SPEC> {
                FLASH_LP_W::new(self, 10)
            }
            ///Bit 12 - LDO status
            #[inline(always)]
            #[must_use]
            pub fn auto_ldo_lp(&mut self) -> AUTO_LDO_LP_W<CTLR_SPEC> {
                AUTO_LDO_LP_W::new(self, 12)
            }
            ///Bit 13 - LDO low-power mode enable
            #[inline(always)]
            #[must_use]
            pub fn ldo_lp(&mut self) -> LDO_LP_W<CTLR_SPEC> {
                LDO_LP_W::new(self, 13)
            }
            ///Bit 16 - standby 2k ram enable
            #[inline(always)]
            #[must_use]
            pub fn r2ksty(&mut self) -> R2KSTY_W<CTLR_SPEC> {
                R2KSTY_W::new(self, 16)
            }
            ///Bit 17 - standby 18k ram enable
            #[inline(always)]
            #[must_use]
            pub fn r18ksty(&mut self) -> R18KSTY_W<CTLR_SPEC> {
                R18KSTY_W::new(self, 17)
            }
            ///Bit 18 - VBAT 2k ram enable
            #[inline(always)]
            #[must_use]
            pub fn r2kvbat(&mut self) -> R2KVBAT_W<CTLR_SPEC> {
                R2KVBAT_W::new(self, 18)
            }
            ///Bit 19 - VBAT 18k ram enable
            #[inline(always)]
            #[must_use]
            pub fn r18kvbat(&mut self) -> R18KVBAT_W<CTLR_SPEC> {
                R18KVBAT_W::new(self, 19)
            }
            ///Bit 20 - Ram LV Enable
            #[inline(always)]
            #[must_use]
            pub fn ramlv(&mut self) -> RAMLV_W<CTLR_SPEC> {
                RAMLV_W::new(self, 20)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Power control register (PWR_CTRL)
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`ctlr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ctlr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct CTLR_SPEC;
        impl crate::RegisterSpec for CTLR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`ctlr::R`](R) reader structure
        impl crate::Readable for CTLR_SPEC {}
        ///`write(|w| ..)` method takes [`ctlr::W`](W) writer structure
        impl crate::Writable for CTLR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets CTLR to value 0
        impl crate::Resettable for CTLR_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///CSR (rw) register accessor: Power control register(PWR_CSR)
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`csr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`csr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@csr`]
    ///module
    pub type CSR = crate::Reg<csr::CSR_SPEC>;
    ///Power control register(PWR_CSR)
    pub mod csr {
        ///Register `CSR` reader
        pub type R = crate::R<CSR_SPEC>;
        ///Register `CSR` writer
        pub type W = crate::W<CSR_SPEC>;
        ///Field `WUF` reader - Wake-Up Flag
        pub type WUF_R = crate::BitReader;
        ///Field `SBF` reader - STANDBY Flag
        pub type SBF_R = crate::BitReader;
        ///Field `PVDO` reader - PVD Output
        pub type PVDO_R = crate::BitReader;
        ///Field `EWUP` reader - Enable WKUP pin
        pub type EWUP_R = crate::BitReader;
        ///Field `EWUP` writer - Enable WKUP pin
        pub type EWUP_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - Wake-Up Flag
            #[inline(always)]
            pub fn wuf(&self) -> WUF_R {
                WUF_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - STANDBY Flag
            #[inline(always)]
            pub fn sbf(&self) -> SBF_R {
                SBF_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - PVD Output
            #[inline(always)]
            pub fn pvdo(&self) -> PVDO_R {
                PVDO_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 8 - Enable WKUP pin
            #[inline(always)]
            pub fn ewup(&self) -> EWUP_R {
                EWUP_R::new(((self.bits >> 8) & 1) != 0)
            }
        }
        impl W {
            ///Bit 8 - Enable WKUP pin
            #[inline(always)]
            #[must_use]
            pub fn ewup(&mut self) -> EWUP_W<CSR_SPEC> {
                EWUP_W::new(self, 8)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Power control register(PWR_CSR)
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`csr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`csr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct CSR_SPEC;
        impl crate::RegisterSpec for CSR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`csr::R`](R) reader structure
        impl crate::Readable for CSR_SPEC {}
        ///`write(|w| ..)` method takes [`csr::W`](W) writer structure
        impl crate::Writable for CSR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets CSR to value 0
        impl crate::Resettable for CSR_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
}
///Reset and clock control
pub struct RCC {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for RCC {}
impl RCC {
    ///Pointer to the register block
    pub const PTR: *const rcc::RegisterBlock = 0x4002_1000 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const rcc::RegisterBlock {
        Self::PTR
    }
    /// Steal an instance of this peripheral
    ///
    /// # Safety
    ///
    /// Ensure that the new instance of the peripheral cannot be used in a way
    /// that may race with any existing instances, for example by only
    /// accessing read-only or write-only registers, or by consuming the
    /// original peripheral and using critical sections to coordinate
    /// access between multiple new instances.
    ///
    /// Additionally, other software such as HALs may rely on only one
    /// peripheral instance existing to ensure memory safety; ensure
    /// no stolen instances are passed to such software.
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for RCC {
    type Target = rcc::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for RCC {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("RCC").finish()
    }
}
///Reset and clock control
pub mod rcc {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        ctlr: CTLR,
        cfgr0: CFGR0,
        intr: INTR,
        apb2prstr: APB2PRSTR,
        apb1prstr: APB1PRSTR,
        ahbpcenr: AHBPCENR,
        apb2pcenr: APB2PCENR,
        apb1pcenr: APB1PCENR,
        bdctlr: BDCTLR,
        rstsckr: RSTSCKR,
        ahbrstr: AHBRSTR,
    }
    impl RegisterBlock {
        ///0x00 - Clock control register
        #[inline(always)]
        pub const fn ctlr(&self) -> &CTLR {
            &self.ctlr
        }
        ///0x04 - Clock configuration register (RCC_CFGR0)
        #[inline(always)]
        pub const fn cfgr0(&self) -> &CFGR0 {
            &self.cfgr0
        }
        ///0x08 - Clock interrupt register (RCC_INTR)
        #[inline(always)]
        pub const fn intr(&self) -> &INTR {
            &self.intr
        }
        ///0x0c - APB2 peripheral reset register (RCC_APB2PRSTR)
        #[inline(always)]
        pub const fn apb2prstr(&self) -> &APB2PRSTR {
            &self.apb2prstr
        }
        ///0x10 - APB1 peripheral reset register (RCC_APB1PRSTR)
        #[inline(always)]
        pub const fn apb1prstr(&self) -> &APB1PRSTR {
            &self.apb1prstr
        }
        ///0x14 - AHB Peripheral Clock enable register (RCC_AHBPCENR)
        #[inline(always)]
        pub const fn ahbpcenr(&self) -> &AHBPCENR {
            &self.ahbpcenr
        }
        ///0x18 - APB2 peripheral clock enable register (RCC_APB2PCENR)
        #[inline(always)]
        pub const fn apb2pcenr(&self) -> &APB2PCENR {
            &self.apb2pcenr
        }
        ///0x1c - APB1 peripheral clock enable register (RCC_APB1PCENR)
        #[inline(always)]
        pub const fn apb1pcenr(&self) -> &APB1PCENR {
            &self.apb1pcenr
        }
        ///0x20 - Backup domain control register (RCC_BDCTLR)
        #[inline(always)]
        pub const fn bdctlr(&self) -> &BDCTLR {
            &self.bdctlr
        }
        ///0x24 - Control/status register (RCC_RSTSCKR)
        #[inline(always)]
        pub const fn rstsckr(&self) -> &RSTSCKR {
            &self.rstsckr
        }
        ///0x28 - AHB reset register (RCC_APHBRSTR)
        #[inline(always)]
        pub const fn ahbrstr(&self) -> &AHBRSTR {
            &self.ahbrstr
        }
    }
    ///CTLR (rw) register accessor: Clock control register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`ctlr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ctlr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@ctlr`]
    ///module
    pub type CTLR = crate::Reg<ctlr::CTLR_SPEC>;
    ///Clock control register
    pub mod ctlr {
        ///Register `CTLR` reader
        pub type R = crate::R<CTLR_SPEC>;
        ///Register `CTLR` writer
        pub type W = crate::W<CTLR_SPEC>;
        ///Field `HSION` reader - Internal High Speed clock enable
        pub type HSION_R = crate::BitReader;
        ///Field `HSION` writer - Internal High Speed clock enable
        pub type HSION_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `HSIRDY` reader - HSI Internal High Speed clock ready flag
        pub type HSIRDY_R = crate::BitReader;
        ///Field `HSILP` reader - HSI Internal low-power mode
        pub type HSILP_R = crate::BitReader;
        ///Field `HSITRIM` reader - Internal High Speed clock trimming
        pub type HSITRIM_R = crate::FieldReader;
        ///Field `HSITRIM` writer - Internal High Speed clock trimming
        pub type HSITRIM_W<'a, REG> = crate::FieldWriter<'a, REG, 5>;
        ///Field `HSICAL` reader - Internal High Speed clock Calibration
        pub type HSICAL_R = crate::FieldReader;
        ///Field `HSEON` reader - External High Speed clock enable
        pub type HSEON_R = crate::BitReader;
        ///Field `HSEON` writer - External High Speed clock enable
        pub type HSEON_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `HSERDY` reader - External High Speed clock ready flag
        pub type HSERDY_R = crate::BitReader;
        ///Field `HSEBYP` reader - External High Speed clock Bypass
        pub type HSEBYP_R = crate::BitReader;
        ///Field `HSEBYP` writer - External High Speed clock Bypass
        pub type HSEBYP_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CSSON` reader - Clock Security System enable
        pub type CSSON_R = crate::BitReader;
        ///Field `CSSON` writer - Clock Security System enable
        pub type CSSON_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `HSELP` reader - HSE low-power mode
        pub type HSELP_R = crate::BitReader;
        ///Field `HSELP` writer - HSE low-power mode
        pub type HSELP_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PLLON` reader - PLL enable
        pub type PLLON_R = crate::BitReader;
        ///Field `PLLON` writer - PLL enable
        pub type PLLON_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PLLRDY` reader - PLL clock ready flag
        pub type PLLRDY_R = crate::BitReader;
        impl R {
            ///Bit 0 - Internal High Speed clock enable
            #[inline(always)]
            pub fn hsion(&self) -> HSION_R {
                HSION_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - HSI Internal High Speed clock ready flag
            #[inline(always)]
            pub fn hsirdy(&self) -> HSIRDY_R {
                HSIRDY_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - HSI Internal low-power mode
            #[inline(always)]
            pub fn hsilp(&self) -> HSILP_R {
                HSILP_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bits 3:7 - Internal High Speed clock trimming
            #[inline(always)]
            pub fn hsitrim(&self) -> HSITRIM_R {
                HSITRIM_R::new(((self.bits >> 3) & 0x1f) as u8)
            }
            ///Bits 8:15 - Internal High Speed clock Calibration
            #[inline(always)]
            pub fn hsical(&self) -> HSICAL_R {
                HSICAL_R::new(((self.bits >> 8) & 0xff) as u8)
            }
            ///Bit 16 - External High Speed clock enable
            #[inline(always)]
            pub fn hseon(&self) -> HSEON_R {
                HSEON_R::new(((self.bits >> 16) & 1) != 0)
            }
            ///Bit 17 - External High Speed clock ready flag
            #[inline(always)]
            pub fn hserdy(&self) -> HSERDY_R {
                HSERDY_R::new(((self.bits >> 17) & 1) != 0)
            }
            ///Bit 18 - External High Speed clock Bypass
            #[inline(always)]
            pub fn hsebyp(&self) -> HSEBYP_R {
                HSEBYP_R::new(((self.bits >> 18) & 1) != 0)
            }
            ///Bit 19 - Clock Security System enable
            #[inline(always)]
            pub fn csson(&self) -> CSSON_R {
                CSSON_R::new(((self.bits >> 19) & 1) != 0)
            }
            ///Bit 20 - HSE low-power mode
            #[inline(always)]
            pub fn hselp(&self) -> HSELP_R {
                HSELP_R::new(((self.bits >> 20) & 1) != 0)
            }
            ///Bit 24 - PLL enable
            #[inline(always)]
            pub fn pllon(&self) -> PLLON_R {
                PLLON_R::new(((self.bits >> 24) & 1) != 0)
            }
            ///Bit 25 - PLL clock ready flag
            #[inline(always)]
            pub fn pllrdy(&self) -> PLLRDY_R {
                PLLRDY_R::new(((self.bits >> 25) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - Internal High Speed clock enable
            #[inline(always)]
            #[must_use]
            pub fn hsion(&mut self) -> HSION_W<CTLR_SPEC> {
                HSION_W::new(self, 0)
            }
            ///Bits 3:7 - Internal High Speed clock trimming
            #[inline(always)]
            #[must_use]
            pub fn hsitrim(&mut self) -> HSITRIM_W<CTLR_SPEC> {
                HSITRIM_W::new(self, 3)
            }
            ///Bit 16 - External High Speed clock enable
            #[inline(always)]
            #[must_use]
            pub fn hseon(&mut self) -> HSEON_W<CTLR_SPEC> {
                HSEON_W::new(self, 16)
            }
            ///Bit 18 - External High Speed clock Bypass
            #[inline(always)]
            #[must_use]
            pub fn hsebyp(&mut self) -> HSEBYP_W<CTLR_SPEC> {
                HSEBYP_W::new(self, 18)
            }
            ///Bit 19 - Clock Security System enable
            #[inline(always)]
            #[must_use]
            pub fn csson(&mut self) -> CSSON_W<CTLR_SPEC> {
                CSSON_W::new(self, 19)
            }
            ///Bit 20 - HSE low-power mode
            #[inline(always)]
            #[must_use]
            pub fn hselp(&mut self) -> HSELP_W<CTLR_SPEC> {
                HSELP_W::new(self, 20)
            }
            ///Bit 24 - PLL enable
            #[inline(always)]
            #[must_use]
            pub fn pllon(&mut self) -> PLLON_W<CTLR_SPEC> {
                PLLON_W::new(self, 24)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Clock control register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`ctlr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ctlr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct CTLR_SPEC;
        impl crate::RegisterSpec for CTLR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`ctlr::R`](R) reader structure
        impl crate::Readable for CTLR_SPEC {}
        ///`write(|w| ..)` method takes [`ctlr::W`](W) writer structure
        impl crate::Writable for CTLR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets CTLR to value 0x83
        impl crate::Resettable for CTLR_SPEC {
            const RESET_VALUE: u32 = 0x83;
        }
    }
    ///CFGR0 (rw) register accessor: Clock configuration register (RCC_CFGR0)
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`cfgr0::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cfgr0::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@cfgr0`]
    ///module
    pub type CFGR0 = crate::Reg<cfgr0::CFGR0_SPEC>;
    ///Clock configuration register (RCC_CFGR0)
    pub mod cfgr0 {
        ///Register `CFGR0` reader
        pub type R = crate::R<CFGR0_SPEC>;
        ///Register `CFGR0` writer
        pub type W = crate::W<CFGR0_SPEC>;
        ///Field `SW` reader - System clock Switch
        pub type SW_R = crate::FieldReader;
        ///Field `SW` writer - System clock Switch
        pub type SW_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `SWS` reader - System Clock Switch Status
        pub type SWS_R = crate::FieldReader;
        ///Field `HPRE` reader - AHB prescaler
        pub type HPRE_R = crate::FieldReader;
        ///Field `HPRE` writer - AHB prescaler
        pub type HPRE_W<'a, REG> = crate::FieldWriter<'a, REG, 4>;
        ///Field `PPRE1` reader - APB Low speed prescaler (APB1)
        pub type PPRE1_R = crate::FieldReader;
        ///Field `PPRE1` writer - APB Low speed prescaler (APB1)
        pub type PPRE1_W<'a, REG> = crate::FieldWriter<'a, REG, 3>;
        ///Field `PPRE2` reader - APB High speed prescaler (APB2)
        pub type PPRE2_R = crate::FieldReader;
        ///Field `PPRE2` writer - APB High speed prescaler (APB2)
        pub type PPRE2_W<'a, REG> = crate::FieldWriter<'a, REG, 3>;
        ///Field `ADCPRE` reader - ADC prescaler
        pub type ADCPRE_R = crate::FieldReader;
        ///Field `ADCPRE` writer - ADC prescaler
        pub type ADCPRE_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `PLLSRC` reader - PLL entry clock source
        pub type PLLSRC_R = crate::BitReader;
        ///Field `PLLSRC` writer - PLL entry clock source
        pub type PLLSRC_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PLLXTPRE` reader - HSE divider for PLL entry
        pub type PLLXTPRE_R = crate::BitReader;
        ///Field `PLLXTPRE` writer - HSE divider for PLL entry
        pub type PLLXTPRE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PLLMUL` reader - PLL Multiplication Factor
        pub type PLLMUL_R = crate::FieldReader;
        ///Field `PLLMUL` writer - PLL Multiplication Factor
        pub type PLLMUL_W<'a, REG> = crate::FieldWriter<'a, REG, 4>;
        ///Field `USBPRE` reader - USB prescaler
        pub type USBPRE_R = crate::FieldReader;
        ///Field `USBPRE` writer - USB prescaler
        pub type USBPRE_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `MCO` reader - Microcontroller clock output
        pub type MCO_R = crate::FieldReader;
        ///Field `MCO` writer - Microcontroller clock output
        pub type MCO_W<'a, REG> = crate::FieldWriter<'a, REG, 3>;
        ///Field `ADC_DUTY_CHG` reader - ADC clock duty cycle control
        pub type ADC_DUTY_CHG_R = crate::FieldReader;
        ///Field `ADC_DUTY_CHG` writer - ADC clock duty cycle control
        pub type ADC_DUTY_CHG_W<'a, REG> = crate::FieldWriter<'a, REG, 3>;
        ///Field `ADC_PRE_ADJ` reader - ADC clock input selection
        pub type ADC_PRE_ADJ_R = crate::BitReader;
        ///Field `ADC_PRE_ADJ` writer - ADC clock input selection
        pub type ADC_PRE_ADJ_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bits 0:1 - System clock Switch
            #[inline(always)]
            pub fn sw(&self) -> SW_R {
                SW_R::new((self.bits & 3) as u8)
            }
            ///Bits 2:3 - System Clock Switch Status
            #[inline(always)]
            pub fn sws(&self) -> SWS_R {
                SWS_R::new(((self.bits >> 2) & 3) as u8)
            }
            ///Bits 4:7 - AHB prescaler
            #[inline(always)]
            pub fn hpre(&self) -> HPRE_R {
                HPRE_R::new(((self.bits >> 4) & 0x0f) as u8)
            }
            ///Bits 8:10 - APB Low speed prescaler (APB1)
            #[inline(always)]
            pub fn ppre1(&self) -> PPRE1_R {
                PPRE1_R::new(((self.bits >> 8) & 7) as u8)
            }
            ///Bits 11:13 - APB High speed prescaler (APB2)
            #[inline(always)]
            pub fn ppre2(&self) -> PPRE2_R {
                PPRE2_R::new(((self.bits >> 11) & 7) as u8)
            }
            ///Bits 14:15 - ADC prescaler
            #[inline(always)]
            pub fn adcpre(&self) -> ADCPRE_R {
                ADCPRE_R::new(((self.bits >> 14) & 3) as u8)
            }
            ///Bit 16 - PLL entry clock source
            #[inline(always)]
            pub fn pllsrc(&self) -> PLLSRC_R {
                PLLSRC_R::new(((self.bits >> 16) & 1) != 0)
            }
            ///Bit 17 - HSE divider for PLL entry
            #[inline(always)]
            pub fn pllxtpre(&self) -> PLLXTPRE_R {
                PLLXTPRE_R::new(((self.bits >> 17) & 1) != 0)
            }
            ///Bits 18:21 - PLL Multiplication Factor
            #[inline(always)]
            pub fn pllmul(&self) -> PLLMUL_R {
                PLLMUL_R::new(((self.bits >> 18) & 0x0f) as u8)
            }
            ///Bits 22:23 - USB prescaler
            #[inline(always)]
            pub fn usbpre(&self) -> USBPRE_R {
                USBPRE_R::new(((self.bits >> 22) & 3) as u8)
            }
            ///Bits 24:26 - Microcontroller clock output
            #[inline(always)]
            pub fn mco(&self) -> MCO_R {
                MCO_R::new(((self.bits >> 24) & 7) as u8)
            }
            ///Bits 28:30 - ADC clock duty cycle control
            #[inline(always)]
            pub fn adc_duty_chg(&self) -> ADC_DUTY_CHG_R {
                ADC_DUTY_CHG_R::new(((self.bits >> 28) & 7) as u8)
            }
            ///Bit 31 - ADC clock input selection
            #[inline(always)]
            pub fn adc_pre_adj(&self) -> ADC_PRE_ADJ_R {
                ADC_PRE_ADJ_R::new(((self.bits >> 31) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:1 - System clock Switch
            #[inline(always)]
            #[must_use]
            pub fn sw(&mut self) -> SW_W<CFGR0_SPEC> {
                SW_W::new(self, 0)
            }
            ///Bits 4:7 - AHB prescaler
            #[inline(always)]
            #[must_use]
            pub fn hpre(&mut self) -> HPRE_W<CFGR0_SPEC> {
                HPRE_W::new(self, 4)
            }
            ///Bits 8:10 - APB Low speed prescaler (APB1)
            #[inline(always)]
            #[must_use]
            pub fn ppre1(&mut self) -> PPRE1_W<CFGR0_SPEC> {
                PPRE1_W::new(self, 8)
            }
            ///Bits 11:13 - APB High speed prescaler (APB2)
            #[inline(always)]
            #[must_use]
            pub fn ppre2(&mut self) -> PPRE2_W<CFGR0_SPEC> {
                PPRE2_W::new(self, 11)
            }
            ///Bits 14:15 - ADC prescaler
            #[inline(always)]
            #[must_use]
            pub fn adcpre(&mut self) -> ADCPRE_W<CFGR0_SPEC> {
                ADCPRE_W::new(self, 14)
            }
            ///Bit 16 - PLL entry clock source
            #[inline(always)]
            #[must_use]
            pub fn pllsrc(&mut self) -> PLLSRC_W<CFGR0_SPEC> {
                PLLSRC_W::new(self, 16)
            }
            ///Bit 17 - HSE divider for PLL entry
            #[inline(always)]
            #[must_use]
            pub fn pllxtpre(&mut self) -> PLLXTPRE_W<CFGR0_SPEC> {
                PLLXTPRE_W::new(self, 17)
            }
            ///Bits 18:21 - PLL Multiplication Factor
            #[inline(always)]
            #[must_use]
            pub fn pllmul(&mut self) -> PLLMUL_W<CFGR0_SPEC> {
                PLLMUL_W::new(self, 18)
            }
            ///Bits 22:23 - USB prescaler
            #[inline(always)]
            #[must_use]
            pub fn usbpre(&mut self) -> USBPRE_W<CFGR0_SPEC> {
                USBPRE_W::new(self, 22)
            }
            ///Bits 24:26 - Microcontroller clock output
            #[inline(always)]
            #[must_use]
            pub fn mco(&mut self) -> MCO_W<CFGR0_SPEC> {
                MCO_W::new(self, 24)
            }
            ///Bits 28:30 - ADC clock duty cycle control
            #[inline(always)]
            #[must_use]
            pub fn adc_duty_chg(&mut self) -> ADC_DUTY_CHG_W<CFGR0_SPEC> {
                ADC_DUTY_CHG_W::new(self, 28)
            }
            ///Bit 31 - ADC clock input selection
            #[inline(always)]
            #[must_use]
            pub fn adc_pre_adj(&mut self) -> ADC_PRE_ADJ_W<CFGR0_SPEC> {
                ADC_PRE_ADJ_W::new(self, 31)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Clock configuration register (RCC_CFGR0)
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`cfgr0::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cfgr0::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct CFGR0_SPEC;
        impl crate::RegisterSpec for CFGR0_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`cfgr0::R`](R) reader structure
        impl crate::Readable for CFGR0_SPEC {}
        ///`write(|w| ..)` method takes [`cfgr0::W`](W) writer structure
        impl crate::Writable for CFGR0_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets CFGR0 to value 0
        impl crate::Resettable for CFGR0_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///INTR (rw) register accessor: Clock interrupt register (RCC_INTR)
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`intr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`intr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@intr`]
    ///module
    pub type INTR = crate::Reg<intr::INTR_SPEC>;
    ///Clock interrupt register (RCC_INTR)
    pub mod intr {
        ///Register `INTR` reader
        pub type R = crate::R<INTR_SPEC>;
        ///Register `INTR` writer
        pub type W = crate::W<INTR_SPEC>;
        ///Field `LSIRDYF` reader - LSI Ready Interrupt flag
        pub type LSIRDYF_R = crate::BitReader;
        ///Field `LSERDYF` reader - LSE Ready Interrupt flag
        pub type LSERDYF_R = crate::BitReader;
        ///Field `HSIRDYF` reader - HSI Ready Interrupt flag
        pub type HSIRDYF_R = crate::BitReader;
        ///Field `HSERDYF` reader - HSE Ready Interrupt flag
        pub type HSERDYF_R = crate::BitReader;
        ///Field `PLLRDYF` reader - PLL Ready Interrupt flag
        pub type PLLRDYF_R = crate::BitReader;
        ///Field `CSSF` reader - Clock Security System Interrupt flag
        pub type CSSF_R = crate::BitReader;
        ///Field `LSIRDYIE` reader - LSI Ready Interrupt Enable
        pub type LSIRDYIE_R = crate::BitReader;
        ///Field `LSIRDYIE` writer - LSI Ready Interrupt Enable
        pub type LSIRDYIE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `LSERDYIE` reader - LSE Ready Interrupt Enable
        pub type LSERDYIE_R = crate::BitReader;
        ///Field `LSERDYIE` writer - LSE Ready Interrupt Enable
        pub type LSERDYIE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `HSIRDYIE` reader - HSI Ready Interrupt Enable
        pub type HSIRDYIE_R = crate::BitReader;
        ///Field `HSIRDYIE` writer - HSI Ready Interrupt Enable
        pub type HSIRDYIE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `HSERDYIE` reader - HSE Ready Interrupt Enable
        pub type HSERDYIE_R = crate::BitReader;
        ///Field `HSERDYIE` writer - HSE Ready Interrupt Enable
        pub type HSERDYIE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PLLRDYIE` reader - PLL Ready Interrupt Enable
        pub type PLLRDYIE_R = crate::BitReader;
        ///Field `PLLRDYIE` writer - PLL Ready Interrupt Enable
        pub type PLLRDYIE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `LSIRDYC` writer - LSI Ready Interrupt Clear
        pub type LSIRDYC_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `LSERDYC` writer - LSE Ready Interrupt Clear
        pub type LSERDYC_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `HSIRDYC` writer - HSI Ready Interrupt Clear
        pub type HSIRDYC_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `HSERDYC` writer - HSE Ready Interrupt Clear
        pub type HSERDYC_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PLLRDYC` writer - PLL Ready Interrupt Clear
        pub type PLLRDYC_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CSSC` writer - Clock security system interrupt clear
        pub type CSSC_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - LSI Ready Interrupt flag
            #[inline(always)]
            pub fn lsirdyf(&self) -> LSIRDYF_R {
                LSIRDYF_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - LSE Ready Interrupt flag
            #[inline(always)]
            pub fn lserdyf(&self) -> LSERDYF_R {
                LSERDYF_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - HSI Ready Interrupt flag
            #[inline(always)]
            pub fn hsirdyf(&self) -> HSIRDYF_R {
                HSIRDYF_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - HSE Ready Interrupt flag
            #[inline(always)]
            pub fn hserdyf(&self) -> HSERDYF_R {
                HSERDYF_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - PLL Ready Interrupt flag
            #[inline(always)]
            pub fn pllrdyf(&self) -> PLLRDYF_R {
                PLLRDYF_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 7 - Clock Security System Interrupt flag
            #[inline(always)]
            pub fn cssf(&self) -> CSSF_R {
                CSSF_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bit 8 - LSI Ready Interrupt Enable
            #[inline(always)]
            pub fn lsirdyie(&self) -> LSIRDYIE_R {
                LSIRDYIE_R::new(((self.bits >> 8) & 1) != 0)
            }
            ///Bit 9 - LSE Ready Interrupt Enable
            #[inline(always)]
            pub fn lserdyie(&self) -> LSERDYIE_R {
                LSERDYIE_R::new(((self.bits >> 9) & 1) != 0)
            }
            ///Bit 10 - HSI Ready Interrupt Enable
            #[inline(always)]
            pub fn hsirdyie(&self) -> HSIRDYIE_R {
                HSIRDYIE_R::new(((self.bits >> 10) & 1) != 0)
            }
            ///Bit 11 - HSE Ready Interrupt Enable
            #[inline(always)]
            pub fn hserdyie(&self) -> HSERDYIE_R {
                HSERDYIE_R::new(((self.bits >> 11) & 1) != 0)
            }
            ///Bit 12 - PLL Ready Interrupt Enable
            #[inline(always)]
            pub fn pllrdyie(&self) -> PLLRDYIE_R {
                PLLRDYIE_R::new(((self.bits >> 12) & 1) != 0)
            }
        }
        impl W {
            ///Bit 8 - LSI Ready Interrupt Enable
            #[inline(always)]
            #[must_use]
            pub fn lsirdyie(&mut self) -> LSIRDYIE_W<INTR_SPEC> {
                LSIRDYIE_W::new(self, 8)
            }
            ///Bit 9 - LSE Ready Interrupt Enable
            #[inline(always)]
            #[must_use]
            pub fn lserdyie(&mut self) -> LSERDYIE_W<INTR_SPEC> {
                LSERDYIE_W::new(self, 9)
            }
            ///Bit 10 - HSI Ready Interrupt Enable
            #[inline(always)]
            #[must_use]
            pub fn hsirdyie(&mut self) -> HSIRDYIE_W<INTR_SPEC> {
                HSIRDYIE_W::new(self, 10)
            }
            ///Bit 11 - HSE Ready Interrupt Enable
            #[inline(always)]
            #[must_use]
            pub fn hserdyie(&mut self) -> HSERDYIE_W<INTR_SPEC> {
                HSERDYIE_W::new(self, 11)
            }
            ///Bit 12 - PLL Ready Interrupt Enable
            #[inline(always)]
            #[must_use]
            pub fn pllrdyie(&mut self) -> PLLRDYIE_W<INTR_SPEC> {
                PLLRDYIE_W::new(self, 12)
            }
            ///Bit 16 - LSI Ready Interrupt Clear
            #[inline(always)]
            #[must_use]
            pub fn lsirdyc(&mut self) -> LSIRDYC_W<INTR_SPEC> {
                LSIRDYC_W::new(self, 16)
            }
            ///Bit 17 - LSE Ready Interrupt Clear
            #[inline(always)]
            #[must_use]
            pub fn lserdyc(&mut self) -> LSERDYC_W<INTR_SPEC> {
                LSERDYC_W::new(self, 17)
            }
            ///Bit 18 - HSI Ready Interrupt Clear
            #[inline(always)]
            #[must_use]
            pub fn hsirdyc(&mut self) -> HSIRDYC_W<INTR_SPEC> {
                HSIRDYC_W::new(self, 18)
            }
            ///Bit 19 - HSE Ready Interrupt Clear
            #[inline(always)]
            #[must_use]
            pub fn hserdyc(&mut self) -> HSERDYC_W<INTR_SPEC> {
                HSERDYC_W::new(self, 19)
            }
            ///Bit 20 - PLL Ready Interrupt Clear
            #[inline(always)]
            #[must_use]
            pub fn pllrdyc(&mut self) -> PLLRDYC_W<INTR_SPEC> {
                PLLRDYC_W::new(self, 20)
            }
            ///Bit 23 - Clock security system interrupt clear
            #[inline(always)]
            #[must_use]
            pub fn cssc(&mut self) -> CSSC_W<INTR_SPEC> {
                CSSC_W::new(self, 23)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Clock interrupt register (RCC_INTR)
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`intr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`intr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct INTR_SPEC;
        impl crate::RegisterSpec for INTR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`intr::R`](R) reader structure
        impl crate::Readable for INTR_SPEC {}
        ///`write(|w| ..)` method takes [`intr::W`](W) writer structure
        impl crate::Writable for INTR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets INTR to value 0
        impl crate::Resettable for INTR_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///APB2PRSTR (rw) register accessor: APB2 peripheral reset register (RCC_APB2PRSTR)
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`apb2prstr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`apb2prstr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@apb2prstr`]
    ///module
    pub type APB2PRSTR = crate::Reg<apb2prstr::APB2PRSTR_SPEC>;
    ///APB2 peripheral reset register (RCC_APB2PRSTR)
    pub mod apb2prstr {
        ///Register `APB2PRSTR` reader
        pub type R = crate::R<APB2PRSTR_SPEC>;
        ///Register `APB2PRSTR` writer
        pub type W = crate::W<APB2PRSTR_SPEC>;
        ///Field `AFIORST` reader - Alternate function I/O reset
        pub type AFIORST_R = crate::BitReader;
        ///Field `AFIORST` writer - Alternate function I/O reset
        pub type AFIORST_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `IOPARST` reader - IO port A reset
        pub type IOPARST_R = crate::BitReader;
        ///Field `IOPARST` writer - IO port A reset
        pub type IOPARST_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `IOPBRST` reader - IO port B reset
        pub type IOPBRST_R = crate::BitReader;
        ///Field `IOPBRST` writer - IO port B reset
        pub type IOPBRST_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `IOPCRST` reader - IO port C reset
        pub type IOPCRST_R = crate::BitReader;
        ///Field `IOPCRST` writer - IO port C reset
        pub type IOPCRST_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `IOPDRST` reader - IO port D reset
        pub type IOPDRST_R = crate::BitReader;
        ///Field `IOPDRST` writer - IO port D reset
        pub type IOPDRST_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `ADCRST` reader - ADC 1 interface reset
        pub type ADCRST_R = crate::BitReader;
        ///Field `ADCRST` writer - ADC 1 interface reset
        pub type ADCRST_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TIM1RST` reader - TIM1 timer reset
        pub type TIM1RST_R = crate::BitReader;
        ///Field `TIM1RST` writer - TIM1 timer reset
        pub type TIM1RST_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `SPI1RST` reader - SPI 1 reset
        pub type SPI1RST_R = crate::BitReader;
        ///Field `SPI1RST` writer - SPI 1 reset
        pub type SPI1RST_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `USART1RST` reader - USART1 reset
        pub type USART1RST_R = crate::BitReader;
        ///Field `USART1RST` writer - USART1 reset
        pub type USART1RST_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - Alternate function I/O reset
            #[inline(always)]
            pub fn afiorst(&self) -> AFIORST_R {
                AFIORST_R::new((self.bits & 1) != 0)
            }
            ///Bit 2 - IO port A reset
            #[inline(always)]
            pub fn ioparst(&self) -> IOPARST_R {
                IOPARST_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - IO port B reset
            #[inline(always)]
            pub fn iopbrst(&self) -> IOPBRST_R {
                IOPBRST_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - IO port C reset
            #[inline(always)]
            pub fn iopcrst(&self) -> IOPCRST_R {
                IOPCRST_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - IO port D reset
            #[inline(always)]
            pub fn iopdrst(&self) -> IOPDRST_R {
                IOPDRST_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 9 - ADC 1 interface reset
            #[inline(always)]
            pub fn adcrst(&self) -> ADCRST_R {
                ADCRST_R::new(((self.bits >> 9) & 1) != 0)
            }
            ///Bit 11 - TIM1 timer reset
            #[inline(always)]
            pub fn tim1rst(&self) -> TIM1RST_R {
                TIM1RST_R::new(((self.bits >> 11) & 1) != 0)
            }
            ///Bit 12 - SPI 1 reset
            #[inline(always)]
            pub fn spi1rst(&self) -> SPI1RST_R {
                SPI1RST_R::new(((self.bits >> 12) & 1) != 0)
            }
            ///Bit 14 - USART1 reset
            #[inline(always)]
            pub fn usart1rst(&self) -> USART1RST_R {
                USART1RST_R::new(((self.bits >> 14) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - Alternate function I/O reset
            #[inline(always)]
            #[must_use]
            pub fn afiorst(&mut self) -> AFIORST_W<APB2PRSTR_SPEC> {
                AFIORST_W::new(self, 0)
            }
            ///Bit 2 - IO port A reset
            #[inline(always)]
            #[must_use]
            pub fn ioparst(&mut self) -> IOPARST_W<APB2PRSTR_SPEC> {
                IOPARST_W::new(self, 2)
            }
            ///Bit 3 - IO port B reset
            #[inline(always)]
            #[must_use]
            pub fn iopbrst(&mut self) -> IOPBRST_W<APB2PRSTR_SPEC> {
                IOPBRST_W::new(self, 3)
            }
            ///Bit 4 - IO port C reset
            #[inline(always)]
            #[must_use]
            pub fn iopcrst(&mut self) -> IOPCRST_W<APB2PRSTR_SPEC> {
                IOPCRST_W::new(self, 4)
            }
            ///Bit 5 - IO port D reset
            #[inline(always)]
            #[must_use]
            pub fn iopdrst(&mut self) -> IOPDRST_W<APB2PRSTR_SPEC> {
                IOPDRST_W::new(self, 5)
            }
            ///Bit 9 - ADC 1 interface reset
            #[inline(always)]
            #[must_use]
            pub fn adcrst(&mut self) -> ADCRST_W<APB2PRSTR_SPEC> {
                ADCRST_W::new(self, 9)
            }
            ///Bit 11 - TIM1 timer reset
            #[inline(always)]
            #[must_use]
            pub fn tim1rst(&mut self) -> TIM1RST_W<APB2PRSTR_SPEC> {
                TIM1RST_W::new(self, 11)
            }
            ///Bit 12 - SPI 1 reset
            #[inline(always)]
            #[must_use]
            pub fn spi1rst(&mut self) -> SPI1RST_W<APB2PRSTR_SPEC> {
                SPI1RST_W::new(self, 12)
            }
            ///Bit 14 - USART1 reset
            #[inline(always)]
            #[must_use]
            pub fn usart1rst(&mut self) -> USART1RST_W<APB2PRSTR_SPEC> {
                USART1RST_W::new(self, 14)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///APB2 peripheral reset register (RCC_APB2PRSTR)
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`apb2prstr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`apb2prstr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct APB2PRSTR_SPEC;
        impl crate::RegisterSpec for APB2PRSTR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`apb2prstr::R`](R) reader structure
        impl crate::Readable for APB2PRSTR_SPEC {}
        ///`write(|w| ..)` method takes [`apb2prstr::W`](W) writer structure
        impl crate::Writable for APB2PRSTR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets APB2PRSTR to value 0
        impl crate::Resettable for APB2PRSTR_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///APB1PRSTR (rw) register accessor: APB1 peripheral reset register (RCC_APB1PRSTR)
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`apb1prstr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`apb1prstr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@apb1prstr`]
    ///module
    pub type APB1PRSTR = crate::Reg<apb1prstr::APB1PRSTR_SPEC>;
    ///APB1 peripheral reset register (RCC_APB1PRSTR)
    pub mod apb1prstr {
        ///Register `APB1PRSTR` reader
        pub type R = crate::R<APB1PRSTR_SPEC>;
        ///Register `APB1PRSTR` writer
        pub type W = crate::W<APB1PRSTR_SPEC>;
        ///Field `TIM2RST` reader - Timer 2 reset
        pub type TIM2RST_R = crate::BitReader;
        ///Field `TIM2RST` writer - Timer 2 reset
        pub type TIM2RST_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TIM3RST` reader - Timer 3 reset
        pub type TIM3RST_R = crate::BitReader;
        ///Field `TIM3RST` writer - Timer 3 reset
        pub type TIM3RST_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TIM4RST` reader - Timer 4 reset
        pub type TIM4RST_R = crate::BitReader;
        ///Field `TIM4RST` writer - Timer 4 reset
        pub type TIM4RST_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `WWDGRST` reader - Window watchdog reset
        pub type WWDGRST_R = crate::BitReader;
        ///Field `WWDGRST` writer - Window watchdog reset
        pub type WWDGRST_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `SPI2RST` reader - SPI2 reset
        pub type SPI2RST_R = crate::BitReader;
        ///Field `SPI2RST` writer - SPI2 reset
        pub type SPI2RST_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `USART2RST` reader - USART 2 reset
        pub type USART2RST_R = crate::BitReader;
        ///Field `USART2RST` writer - USART 2 reset
        pub type USART2RST_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `USART3RST` reader - USART 3 reset
        pub type USART3RST_R = crate::BitReader;
        ///Field `USART3RST` writer - USART 3 reset
        pub type USART3RST_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `USART4RST` reader - USART 4 reset
        pub type USART4RST_R = crate::BitReader;
        ///Field `USART4RST` writer - USART 4 reset
        pub type USART4RST_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `I2C1RST` reader - I2C1 reset
        pub type I2C1RST_R = crate::BitReader;
        ///Field `I2C1RST` writer - I2C1 reset
        pub type I2C1RST_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `I2C2RST` reader - I2C2 reset
        pub type I2C2RST_R = crate::BitReader;
        ///Field `I2C2RST` writer - I2C2 reset
        pub type I2C2RST_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CANRST` reader - CAN reset
        pub type CANRST_R = crate::BitReader;
        ///Field `CANRST` writer - CAN reset
        pub type CANRST_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `BKPRST` reader - Backup interface reset
        pub type BKPRST_R = crate::BitReader;
        ///Field `BKPRST` writer - Backup interface reset
        pub type BKPRST_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PWRRST` reader - Power interface reset
        pub type PWRRST_R = crate::BitReader;
        ///Field `PWRRST` writer - Power interface reset
        pub type PWRRST_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `LPTIMRST` reader - LPTIM reset
        pub type LPTIMRST_R = crate::BitReader;
        ///Field `LPTIMRST` writer - LPTIM reset
        pub type LPTIMRST_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - Timer 2 reset
            #[inline(always)]
            pub fn tim2rst(&self) -> TIM2RST_R {
                TIM2RST_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Timer 3 reset
            #[inline(always)]
            pub fn tim3rst(&self) -> TIM3RST_R {
                TIM3RST_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - Timer 4 reset
            #[inline(always)]
            pub fn tim4rst(&self) -> TIM4RST_R {
                TIM4RST_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 11 - Window watchdog reset
            #[inline(always)]
            pub fn wwdgrst(&self) -> WWDGRST_R {
                WWDGRST_R::new(((self.bits >> 11) & 1) != 0)
            }
            ///Bit 14 - SPI2 reset
            #[inline(always)]
            pub fn spi2rst(&self) -> SPI2RST_R {
                SPI2RST_R::new(((self.bits >> 14) & 1) != 0)
            }
            ///Bit 17 - USART 2 reset
            #[inline(always)]
            pub fn usart2rst(&self) -> USART2RST_R {
                USART2RST_R::new(((self.bits >> 17) & 1) != 0)
            }
            ///Bit 18 - USART 3 reset
            #[inline(always)]
            pub fn usart3rst(&self) -> USART3RST_R {
                USART3RST_R::new(((self.bits >> 18) & 1) != 0)
            }
            ///Bit 19 - USART 4 reset
            #[inline(always)]
            pub fn usart4rst(&self) -> USART4RST_R {
                USART4RST_R::new(((self.bits >> 19) & 1) != 0)
            }
            ///Bit 21 - I2C1 reset
            #[inline(always)]
            pub fn i2c1rst(&self) -> I2C1RST_R {
                I2C1RST_R::new(((self.bits >> 21) & 1) != 0)
            }
            ///Bit 22 - I2C2 reset
            #[inline(always)]
            pub fn i2c2rst(&self) -> I2C2RST_R {
                I2C2RST_R::new(((self.bits >> 22) & 1) != 0)
            }
            ///Bit 25 - CAN reset
            #[inline(always)]
            pub fn canrst(&self) -> CANRST_R {
                CANRST_R::new(((self.bits >> 25) & 1) != 0)
            }
            ///Bit 27 - Backup interface reset
            #[inline(always)]
            pub fn bkprst(&self) -> BKPRST_R {
                BKPRST_R::new(((self.bits >> 27) & 1) != 0)
            }
            ///Bit 28 - Power interface reset
            #[inline(always)]
            pub fn pwrrst(&self) -> PWRRST_R {
                PWRRST_R::new(((self.bits >> 28) & 1) != 0)
            }
            ///Bit 31 - LPTIM reset
            #[inline(always)]
            pub fn lptimrst(&self) -> LPTIMRST_R {
                LPTIMRST_R::new(((self.bits >> 31) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - Timer 2 reset
            #[inline(always)]
            #[must_use]
            pub fn tim2rst(&mut self) -> TIM2RST_W<APB1PRSTR_SPEC> {
                TIM2RST_W::new(self, 0)
            }
            ///Bit 1 - Timer 3 reset
            #[inline(always)]
            #[must_use]
            pub fn tim3rst(&mut self) -> TIM3RST_W<APB1PRSTR_SPEC> {
                TIM3RST_W::new(self, 1)
            }
            ///Bit 2 - Timer 4 reset
            #[inline(always)]
            #[must_use]
            pub fn tim4rst(&mut self) -> TIM4RST_W<APB1PRSTR_SPEC> {
                TIM4RST_W::new(self, 2)
            }
            ///Bit 11 - Window watchdog reset
            #[inline(always)]
            #[must_use]
            pub fn wwdgrst(&mut self) -> WWDGRST_W<APB1PRSTR_SPEC> {
                WWDGRST_W::new(self, 11)
            }
            ///Bit 14 - SPI2 reset
            #[inline(always)]
            #[must_use]
            pub fn spi2rst(&mut self) -> SPI2RST_W<APB1PRSTR_SPEC> {
                SPI2RST_W::new(self, 14)
            }
            ///Bit 17 - USART 2 reset
            #[inline(always)]
            #[must_use]
            pub fn usart2rst(&mut self) -> USART2RST_W<APB1PRSTR_SPEC> {
                USART2RST_W::new(self, 17)
            }
            ///Bit 18 - USART 3 reset
            #[inline(always)]
            #[must_use]
            pub fn usart3rst(&mut self) -> USART3RST_W<APB1PRSTR_SPEC> {
                USART3RST_W::new(self, 18)
            }
            ///Bit 19 - USART 4 reset
            #[inline(always)]
            #[must_use]
            pub fn usart4rst(&mut self) -> USART4RST_W<APB1PRSTR_SPEC> {
                USART4RST_W::new(self, 19)
            }
            ///Bit 21 - I2C1 reset
            #[inline(always)]
            #[must_use]
            pub fn i2c1rst(&mut self) -> I2C1RST_W<APB1PRSTR_SPEC> {
                I2C1RST_W::new(self, 21)
            }
            ///Bit 22 - I2C2 reset
            #[inline(always)]
            #[must_use]
            pub fn i2c2rst(&mut self) -> I2C2RST_W<APB1PRSTR_SPEC> {
                I2C2RST_W::new(self, 22)
            }
            ///Bit 25 - CAN reset
            #[inline(always)]
            #[must_use]
            pub fn canrst(&mut self) -> CANRST_W<APB1PRSTR_SPEC> {
                CANRST_W::new(self, 25)
            }
            ///Bit 27 - Backup interface reset
            #[inline(always)]
            #[must_use]
            pub fn bkprst(&mut self) -> BKPRST_W<APB1PRSTR_SPEC> {
                BKPRST_W::new(self, 27)
            }
            ///Bit 28 - Power interface reset
            #[inline(always)]
            #[must_use]
            pub fn pwrrst(&mut self) -> PWRRST_W<APB1PRSTR_SPEC> {
                PWRRST_W::new(self, 28)
            }
            ///Bit 31 - LPTIM reset
            #[inline(always)]
            #[must_use]
            pub fn lptimrst(&mut self) -> LPTIMRST_W<APB1PRSTR_SPEC> {
                LPTIMRST_W::new(self, 31)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///APB1 peripheral reset register (RCC_APB1PRSTR)
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`apb1prstr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`apb1prstr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct APB1PRSTR_SPEC;
        impl crate::RegisterSpec for APB1PRSTR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`apb1prstr::R`](R) reader structure
        impl crate::Readable for APB1PRSTR_SPEC {}
        ///`write(|w| ..)` method takes [`apb1prstr::W`](W) writer structure
        impl crate::Writable for APB1PRSTR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets APB1PRSTR to value 0
        impl crate::Resettable for APB1PRSTR_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///AHBPCENR (rw) register accessor: AHB Peripheral Clock enable register (RCC_AHBPCENR)
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`ahbpcenr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ahbpcenr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@ahbpcenr`]
    ///module
    pub type AHBPCENR = crate::Reg<ahbpcenr::AHBPCENR_SPEC>;
    ///AHB Peripheral Clock enable register (RCC_AHBPCENR)
    pub mod ahbpcenr {
        ///Register `AHBPCENR` reader
        pub type R = crate::R<AHBPCENR_SPEC>;
        ///Register `AHBPCENR` writer
        pub type W = crate::W<AHBPCENR_SPEC>;
        ///Field `DMAEN` reader - DMA clock enable
        pub type DMAEN_R = crate::BitReader;
        ///Field `DMAEN` writer - DMA clock enable
        pub type DMAEN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `SRAMEN` reader - SRAM interface clock enable
        pub type SRAMEN_R = crate::BitReader;
        ///Field `SRAMEN` writer - SRAM interface clock enable
        pub type SRAMEN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CRCEN` reader - CRC clock enable
        pub type CRCEN_R = crate::BitReader;
        ///Field `CRCEN` writer - CRC clock enable
        pub type CRCEN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `USBFSEN` reader - USBFSEN clock enable
        pub type USBFSEN_R = crate::BitReader;
        ///Field `USBFSEN` writer - USBFSEN clock enable
        pub type USBFSEN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `USBPDEN` reader - USBPD clock enable
        pub type USBPDEN_R = crate::BitReader;
        ///Field `USBPDEN` writer - USBPD clock enable
        pub type USBPDEN_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - DMA clock enable
            #[inline(always)]
            pub fn dmaen(&self) -> DMAEN_R {
                DMAEN_R::new((self.bits & 1) != 0)
            }
            ///Bit 2 - SRAM interface clock enable
            #[inline(always)]
            pub fn sramen(&self) -> SRAMEN_R {
                SRAMEN_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 6 - CRC clock enable
            #[inline(always)]
            pub fn crcen(&self) -> CRCEN_R {
                CRCEN_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 12 - USBFSEN clock enable
            #[inline(always)]
            pub fn usbfsen(&self) -> USBFSEN_R {
                USBFSEN_R::new(((self.bits >> 12) & 1) != 0)
            }
            ///Bit 17 - USBPD clock enable
            #[inline(always)]
            pub fn usbpden(&self) -> USBPDEN_R {
                USBPDEN_R::new(((self.bits >> 17) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - DMA clock enable
            #[inline(always)]
            #[must_use]
            pub fn dmaen(&mut self) -> DMAEN_W<AHBPCENR_SPEC> {
                DMAEN_W::new(self, 0)
            }
            ///Bit 2 - SRAM interface clock enable
            #[inline(always)]
            #[must_use]
            pub fn sramen(&mut self) -> SRAMEN_W<AHBPCENR_SPEC> {
                SRAMEN_W::new(self, 2)
            }
            ///Bit 6 - CRC clock enable
            #[inline(always)]
            #[must_use]
            pub fn crcen(&mut self) -> CRCEN_W<AHBPCENR_SPEC> {
                CRCEN_W::new(self, 6)
            }
            ///Bit 12 - USBFSEN clock enable
            #[inline(always)]
            #[must_use]
            pub fn usbfsen(&mut self) -> USBFSEN_W<AHBPCENR_SPEC> {
                USBFSEN_W::new(self, 12)
            }
            ///Bit 17 - USBPD clock enable
            #[inline(always)]
            #[must_use]
            pub fn usbpden(&mut self) -> USBPDEN_W<AHBPCENR_SPEC> {
                USBPDEN_W::new(self, 17)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///AHB Peripheral Clock enable register (RCC_AHBPCENR)
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`ahbpcenr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ahbpcenr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct AHBPCENR_SPEC;
        impl crate::RegisterSpec for AHBPCENR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`ahbpcenr::R`](R) reader structure
        impl crate::Readable for AHBPCENR_SPEC {}
        ///`write(|w| ..)` method takes [`ahbpcenr::W`](W) writer structure
        impl crate::Writable for AHBPCENR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets AHBPCENR to value 0x14
        impl crate::Resettable for AHBPCENR_SPEC {
            const RESET_VALUE: u32 = 0x14;
        }
    }
    ///APB2PCENR (rw) register accessor: APB2 peripheral clock enable register (RCC_APB2PCENR)
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`apb2pcenr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`apb2pcenr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@apb2pcenr`]
    ///module
    pub type APB2PCENR = crate::Reg<apb2pcenr::APB2PCENR_SPEC>;
    ///APB2 peripheral clock enable register (RCC_APB2PCENR)
    pub mod apb2pcenr {
        ///Register `APB2PCENR` reader
        pub type R = crate::R<APB2PCENR_SPEC>;
        ///Register `APB2PCENR` writer
        pub type W = crate::W<APB2PCENR_SPEC>;
        ///Field `AFIOEN` reader - Alternate function I/O clock enable
        pub type AFIOEN_R = crate::BitReader;
        ///Field `AFIOEN` writer - Alternate function I/O clock enable
        pub type AFIOEN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `IOPAEN` reader - I/O port A clock enable
        pub type IOPAEN_R = crate::BitReader;
        ///Field `IOPAEN` writer - I/O port A clock enable
        pub type IOPAEN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `IOPBEN` reader - I/O port B clock enable
        pub type IOPBEN_R = crate::BitReader;
        ///Field `IOPBEN` writer - I/O port B clock enable
        pub type IOPBEN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `IOPCEN` reader - I/O port C clock enable
        pub type IOPCEN_R = crate::BitReader;
        ///Field `IOPCEN` writer - I/O port C clock enable
        pub type IOPCEN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `IOPDEN` reader - I/O port D clock enable
        pub type IOPDEN_R = crate::BitReader;
        ///Field `IOPDEN` writer - I/O port D clock enable
        pub type IOPDEN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `ADCEN` reader - ADC interface clock enable
        pub type ADCEN_R = crate::BitReader;
        ///Field `ADCEN` writer - ADC interface clock enable
        pub type ADCEN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TIM1EN` reader - TIM1 Timer clock enable
        pub type TIM1EN_R = crate::BitReader;
        ///Field `TIM1EN` writer - TIM1 Timer clock enable
        pub type TIM1EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `SPI1EN` reader - SPI 1 clock enable
        pub type SPI1EN_R = crate::BitReader;
        ///Field `SPI1EN` writer - SPI 1 clock enable
        pub type SPI1EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `USART1EN` reader - USART1 clock enable
        pub type USART1EN_R = crate::BitReader;
        ///Field `USART1EN` writer - USART1 clock enable
        pub type USART1EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - Alternate function I/O clock enable
            #[inline(always)]
            pub fn afioen(&self) -> AFIOEN_R {
                AFIOEN_R::new((self.bits & 1) != 0)
            }
            ///Bit 2 - I/O port A clock enable
            #[inline(always)]
            pub fn iopaen(&self) -> IOPAEN_R {
                IOPAEN_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - I/O port B clock enable
            #[inline(always)]
            pub fn iopben(&self) -> IOPBEN_R {
                IOPBEN_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - I/O port C clock enable
            #[inline(always)]
            pub fn iopcen(&self) -> IOPCEN_R {
                IOPCEN_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - I/O port D clock enable
            #[inline(always)]
            pub fn iopden(&self) -> IOPDEN_R {
                IOPDEN_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 9 - ADC interface clock enable
            #[inline(always)]
            pub fn adcen(&self) -> ADCEN_R {
                ADCEN_R::new(((self.bits >> 9) & 1) != 0)
            }
            ///Bit 11 - TIM1 Timer clock enable
            #[inline(always)]
            pub fn tim1en(&self) -> TIM1EN_R {
                TIM1EN_R::new(((self.bits >> 11) & 1) != 0)
            }
            ///Bit 12 - SPI 1 clock enable
            #[inline(always)]
            pub fn spi1en(&self) -> SPI1EN_R {
                SPI1EN_R::new(((self.bits >> 12) & 1) != 0)
            }
            ///Bit 14 - USART1 clock enable
            #[inline(always)]
            pub fn usart1en(&self) -> USART1EN_R {
                USART1EN_R::new(((self.bits >> 14) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - Alternate function I/O clock enable
            #[inline(always)]
            #[must_use]
            pub fn afioen(&mut self) -> AFIOEN_W<APB2PCENR_SPEC> {
                AFIOEN_W::new(self, 0)
            }
            ///Bit 2 - I/O port A clock enable
            #[inline(always)]
            #[must_use]
            pub fn iopaen(&mut self) -> IOPAEN_W<APB2PCENR_SPEC> {
                IOPAEN_W::new(self, 2)
            }
            ///Bit 3 - I/O port B clock enable
            #[inline(always)]
            #[must_use]
            pub fn iopben(&mut self) -> IOPBEN_W<APB2PCENR_SPEC> {
                IOPBEN_W::new(self, 3)
            }
            ///Bit 4 - I/O port C clock enable
            #[inline(always)]
            #[must_use]
            pub fn iopcen(&mut self) -> IOPCEN_W<APB2PCENR_SPEC> {
                IOPCEN_W::new(self, 4)
            }
            ///Bit 5 - I/O port D clock enable
            #[inline(always)]
            #[must_use]
            pub fn iopden(&mut self) -> IOPDEN_W<APB2PCENR_SPEC> {
                IOPDEN_W::new(self, 5)
            }
            ///Bit 9 - ADC interface clock enable
            #[inline(always)]
            #[must_use]
            pub fn adcen(&mut self) -> ADCEN_W<APB2PCENR_SPEC> {
                ADCEN_W::new(self, 9)
            }
            ///Bit 11 - TIM1 Timer clock enable
            #[inline(always)]
            #[must_use]
            pub fn tim1en(&mut self) -> TIM1EN_W<APB2PCENR_SPEC> {
                TIM1EN_W::new(self, 11)
            }
            ///Bit 12 - SPI 1 clock enable
            #[inline(always)]
            #[must_use]
            pub fn spi1en(&mut self) -> SPI1EN_W<APB2PCENR_SPEC> {
                SPI1EN_W::new(self, 12)
            }
            ///Bit 14 - USART1 clock enable
            #[inline(always)]
            #[must_use]
            pub fn usart1en(&mut self) -> USART1EN_W<APB2PCENR_SPEC> {
                USART1EN_W::new(self, 14)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///APB2 peripheral clock enable register (RCC_APB2PCENR)
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`apb2pcenr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`apb2pcenr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct APB2PCENR_SPEC;
        impl crate::RegisterSpec for APB2PCENR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`apb2pcenr::R`](R) reader structure
        impl crate::Readable for APB2PCENR_SPEC {}
        ///`write(|w| ..)` method takes [`apb2pcenr::W`](W) writer structure
        impl crate::Writable for APB2PCENR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets APB2PCENR to value 0
        impl crate::Resettable for APB2PCENR_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///APB1PCENR (rw) register accessor: APB1 peripheral clock enable register (RCC_APB1PCENR)
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`apb1pcenr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`apb1pcenr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@apb1pcenr`]
    ///module
    pub type APB1PCENR = crate::Reg<apb1pcenr::APB1PCENR_SPEC>;
    ///APB1 peripheral clock enable register (RCC_APB1PCENR)
    pub mod apb1pcenr {
        ///Register `APB1PCENR` reader
        pub type R = crate::R<APB1PCENR_SPEC>;
        ///Register `APB1PCENR` writer
        pub type W = crate::W<APB1PCENR_SPEC>;
        ///Field `TIM2EN` reader - Timer 2 clock enable
        pub type TIM2EN_R = crate::BitReader;
        ///Field `TIM2EN` writer - Timer 2 clock enable
        pub type TIM2EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TIM3EN` reader - Timer 3 clock enable
        pub type TIM3EN_R = crate::BitReader;
        ///Field `TIM3EN` writer - Timer 3 clock enable
        pub type TIM3EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TIM4EN` reader - Timer 4 clock enable
        pub type TIM4EN_R = crate::BitReader;
        ///Field `TIM4EN` writer - Timer 4 clock enable
        pub type TIM4EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `WWDGEN` reader - Window watchdog clock enable
        pub type WWDGEN_R = crate::BitReader;
        ///Field `WWDGEN` writer - Window watchdog clock enable
        pub type WWDGEN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `SPI2EN` reader - SPI 2 clock enable
        pub type SPI2EN_R = crate::BitReader;
        ///Field `SPI2EN` writer - SPI 2 clock enable
        pub type SPI2EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `USART2EN` reader - USART 2 clock enable
        pub type USART2EN_R = crate::BitReader;
        ///Field `USART2EN` writer - USART 2 clock enable
        pub type USART2EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `USART3EN` reader - USART 3 clock enable
        pub type USART3EN_R = crate::BitReader;
        ///Field `USART3EN` writer - USART 3 clock enable
        pub type USART3EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UART4EN` reader - UART 4 clock enable
        pub type UART4EN_R = crate::BitReader;
        ///Field `UART4EN` writer - UART 4 clock enable
        pub type UART4EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `I2C1EN` reader - I2C 1 clock enable
        pub type I2C1EN_R = crate::BitReader;
        ///Field `I2C1EN` writer - I2C 1 clock enable
        pub type I2C1EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `I2C2EN` reader - I2C 2 clock enable
        pub type I2C2EN_R = crate::BitReader;
        ///Field `I2C2EN` writer - I2C 2 clock enable
        pub type I2C2EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CANEN` reader - CAN clock enable
        pub type CANEN_R = crate::BitReader;
        ///Field `CANEN` writer - CAN clock enable
        pub type CANEN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `BKPEN` reader - Backup interface clock enable
        pub type BKPEN_R = crate::BitReader;
        ///Field `BKPEN` writer - Backup interface clock enable
        pub type BKPEN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PWREN` reader - Power interface clock enable
        pub type PWREN_R = crate::BitReader;
        ///Field `PWREN` writer - Power interface clock enable
        pub type PWREN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `LPTIMEN` reader - LPTIM clock enable
        pub type LPTIMEN_R = crate::BitReader;
        ///Field `LPTIMEN` writer - LPTIM clock enable
        pub type LPTIMEN_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - Timer 2 clock enable
            #[inline(always)]
            pub fn tim2en(&self) -> TIM2EN_R {
                TIM2EN_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Timer 3 clock enable
            #[inline(always)]
            pub fn tim3en(&self) -> TIM3EN_R {
                TIM3EN_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - Timer 4 clock enable
            #[inline(always)]
            pub fn tim4en(&self) -> TIM4EN_R {
                TIM4EN_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 11 - Window watchdog clock enable
            #[inline(always)]
            pub fn wwdgen(&self) -> WWDGEN_R {
                WWDGEN_R::new(((self.bits >> 11) & 1) != 0)
            }
            ///Bit 14 - SPI 2 clock enable
            #[inline(always)]
            pub fn spi2en(&self) -> SPI2EN_R {
                SPI2EN_R::new(((self.bits >> 14) & 1) != 0)
            }
            ///Bit 17 - USART 2 clock enable
            #[inline(always)]
            pub fn usart2en(&self) -> USART2EN_R {
                USART2EN_R::new(((self.bits >> 17) & 1) != 0)
            }
            ///Bit 18 - USART 3 clock enable
            #[inline(always)]
            pub fn usart3en(&self) -> USART3EN_R {
                USART3EN_R::new(((self.bits >> 18) & 1) != 0)
            }
            ///Bit 19 - UART 4 clock enable
            #[inline(always)]
            pub fn uart4en(&self) -> UART4EN_R {
                UART4EN_R::new(((self.bits >> 19) & 1) != 0)
            }
            ///Bit 21 - I2C 1 clock enable
            #[inline(always)]
            pub fn i2c1en(&self) -> I2C1EN_R {
                I2C1EN_R::new(((self.bits >> 21) & 1) != 0)
            }
            ///Bit 22 - I2C 2 clock enable
            #[inline(always)]
            pub fn i2c2en(&self) -> I2C2EN_R {
                I2C2EN_R::new(((self.bits >> 22) & 1) != 0)
            }
            ///Bit 25 - CAN clock enable
            #[inline(always)]
            pub fn canen(&self) -> CANEN_R {
                CANEN_R::new(((self.bits >> 25) & 1) != 0)
            }
            ///Bit 27 - Backup interface clock enable
            #[inline(always)]
            pub fn bkpen(&self) -> BKPEN_R {
                BKPEN_R::new(((self.bits >> 27) & 1) != 0)
            }
            ///Bit 28 - Power interface clock enable
            #[inline(always)]
            pub fn pwren(&self) -> PWREN_R {
                PWREN_R::new(((self.bits >> 28) & 1) != 0)
            }
            ///Bit 31 - LPTIM clock enable
            #[inline(always)]
            pub fn lptimen(&self) -> LPTIMEN_R {
                LPTIMEN_R::new(((self.bits >> 31) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - Timer 2 clock enable
            #[inline(always)]
            #[must_use]
            pub fn tim2en(&mut self) -> TIM2EN_W<APB1PCENR_SPEC> {
                TIM2EN_W::new(self, 0)
            }
            ///Bit 1 - Timer 3 clock enable
            #[inline(always)]
            #[must_use]
            pub fn tim3en(&mut self) -> TIM3EN_W<APB1PCENR_SPEC> {
                TIM3EN_W::new(self, 1)
            }
            ///Bit 2 - Timer 4 clock enable
            #[inline(always)]
            #[must_use]
            pub fn tim4en(&mut self) -> TIM4EN_W<APB1PCENR_SPEC> {
                TIM4EN_W::new(self, 2)
            }
            ///Bit 11 - Window watchdog clock enable
            #[inline(always)]
            #[must_use]
            pub fn wwdgen(&mut self) -> WWDGEN_W<APB1PCENR_SPEC> {
                WWDGEN_W::new(self, 11)
            }
            ///Bit 14 - SPI 2 clock enable
            #[inline(always)]
            #[must_use]
            pub fn spi2en(&mut self) -> SPI2EN_W<APB1PCENR_SPEC> {
                SPI2EN_W::new(self, 14)
            }
            ///Bit 17 - USART 2 clock enable
            #[inline(always)]
            #[must_use]
            pub fn usart2en(&mut self) -> USART2EN_W<APB1PCENR_SPEC> {
                USART2EN_W::new(self, 17)
            }
            ///Bit 18 - USART 3 clock enable
            #[inline(always)]
            #[must_use]
            pub fn usart3en(&mut self) -> USART3EN_W<APB1PCENR_SPEC> {
                USART3EN_W::new(self, 18)
            }
            ///Bit 19 - UART 4 clock enable
            #[inline(always)]
            #[must_use]
            pub fn uart4en(&mut self) -> UART4EN_W<APB1PCENR_SPEC> {
                UART4EN_W::new(self, 19)
            }
            ///Bit 21 - I2C 1 clock enable
            #[inline(always)]
            #[must_use]
            pub fn i2c1en(&mut self) -> I2C1EN_W<APB1PCENR_SPEC> {
                I2C1EN_W::new(self, 21)
            }
            ///Bit 22 - I2C 2 clock enable
            #[inline(always)]
            #[must_use]
            pub fn i2c2en(&mut self) -> I2C2EN_W<APB1PCENR_SPEC> {
                I2C2EN_W::new(self, 22)
            }
            ///Bit 25 - CAN clock enable
            #[inline(always)]
            #[must_use]
            pub fn canen(&mut self) -> CANEN_W<APB1PCENR_SPEC> {
                CANEN_W::new(self, 25)
            }
            ///Bit 27 - Backup interface clock enable
            #[inline(always)]
            #[must_use]
            pub fn bkpen(&mut self) -> BKPEN_W<APB1PCENR_SPEC> {
                BKPEN_W::new(self, 27)
            }
            ///Bit 28 - Power interface clock enable
            #[inline(always)]
            #[must_use]
            pub fn pwren(&mut self) -> PWREN_W<APB1PCENR_SPEC> {
                PWREN_W::new(self, 28)
            }
            ///Bit 31 - LPTIM clock enable
            #[inline(always)]
            #[must_use]
            pub fn lptimen(&mut self) -> LPTIMEN_W<APB1PCENR_SPEC> {
                LPTIMEN_W::new(self, 31)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///APB1 peripheral clock enable register (RCC_APB1PCENR)
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`apb1pcenr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`apb1pcenr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct APB1PCENR_SPEC;
        impl crate::RegisterSpec for APB1PCENR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`apb1pcenr::R`](R) reader structure
        impl crate::Readable for APB1PCENR_SPEC {}
        ///`write(|w| ..)` method takes [`apb1pcenr::W`](W) writer structure
        impl crate::Writable for APB1PCENR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets APB1PCENR to value 0
        impl crate::Resettable for APB1PCENR_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///BDCTLR (rw) register accessor: Backup domain control register (RCC_BDCTLR)
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`bdctlr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`bdctlr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@bdctlr`]
    ///module
    pub type BDCTLR = crate::Reg<bdctlr::BDCTLR_SPEC>;
    ///Backup domain control register (RCC_BDCTLR)
    pub mod bdctlr {
        ///Register `BDCTLR` reader
        pub type R = crate::R<BDCTLR_SPEC>;
        ///Register `BDCTLR` writer
        pub type W = crate::W<BDCTLR_SPEC>;
        ///Field `LSEON` reader - External Low Speed oscillator enable
        pub type LSEON_R = crate::BitReader;
        ///Field `LSERDY` reader - External Low Speed oscillator ready
        pub type LSERDY_R = crate::BitReader;
        ///Field `LSEBYP` reader - External Low Speed oscillator bypass
        pub type LSEBYP_R = crate::BitReader;
        ///Field `RTCSEL` reader - RTC clock source selection
        pub type RTCSEL_R = crate::FieldReader;
        ///Field `RTCEN` reader - RTC clock enable
        pub type RTCEN_R = crate::BitReader;
        ///Field `BDRST` reader - Backup domain software reset
        pub type BDRST_R = crate::BitReader;
        ///Field `BDRST` writer - Backup domain software reset
        pub type BDRST_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - External Low Speed oscillator enable
            #[inline(always)]
            pub fn lseon(&self) -> LSEON_R {
                LSEON_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - External Low Speed oscillator ready
            #[inline(always)]
            pub fn lserdy(&self) -> LSERDY_R {
                LSERDY_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - External Low Speed oscillator bypass
            #[inline(always)]
            pub fn lsebyp(&self) -> LSEBYP_R {
                LSEBYP_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bits 8:9 - RTC clock source selection
            #[inline(always)]
            pub fn rtcsel(&self) -> RTCSEL_R {
                RTCSEL_R::new(((self.bits >> 8) & 3) as u8)
            }
            ///Bit 15 - RTC clock enable
            #[inline(always)]
            pub fn rtcen(&self) -> RTCEN_R {
                RTCEN_R::new(((self.bits >> 15) & 1) != 0)
            }
            ///Bit 16 - Backup domain software reset
            #[inline(always)]
            pub fn bdrst(&self) -> BDRST_R {
                BDRST_R::new(((self.bits >> 16) & 1) != 0)
            }
        }
        impl W {
            ///Bit 16 - Backup domain software reset
            #[inline(always)]
            #[must_use]
            pub fn bdrst(&mut self) -> BDRST_W<BDCTLR_SPEC> {
                BDRST_W::new(self, 16)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Backup domain control register (RCC_BDCTLR)
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`bdctlr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`bdctlr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct BDCTLR_SPEC;
        impl crate::RegisterSpec for BDCTLR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`bdctlr::R`](R) reader structure
        impl crate::Readable for BDCTLR_SPEC {}
        ///`write(|w| ..)` method takes [`bdctlr::W`](W) writer structure
        impl crate::Writable for BDCTLR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets BDCTLR to value 0
        impl crate::Resettable for BDCTLR_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///RSTSCKR (rw) register accessor: Control/status register (RCC_RSTSCKR)
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`rstsckr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`rstsckr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@rstsckr`]
    ///module
    pub type RSTSCKR = crate::Reg<rstsckr::RSTSCKR_SPEC>;
    ///Control/status register (RCC_RSTSCKR)
    pub mod rstsckr {
        ///Register `RSTSCKR` reader
        pub type R = crate::R<RSTSCKR_SPEC>;
        ///Register `RSTSCKR` writer
        pub type W = crate::W<RSTSCKR_SPEC>;
        ///Field `LSION` reader - Internal low speed oscillator enable
        pub type LSION_R = crate::BitReader;
        ///Field `LSION` writer - Internal low speed oscillator enable
        pub type LSION_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `LSIRDY` reader - Internal low speed oscillator ready
        pub type LSIRDY_R = crate::BitReader;
        ///Field `RMVF` reader - Remove reset flag
        pub type RMVF_R = crate::BitReader;
        ///Field `RMVF` writer - Remove reset flag
        pub type RMVF_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PINRSTF` reader - PIN reset flag
        pub type PINRSTF_R = crate::BitReader;
        ///Field `PORRSTF` reader - POR/PDR reset flag
        pub type PORRSTF_R = crate::BitReader;
        ///Field `SFTRSTF` reader - Software reset flag
        pub type SFTRSTF_R = crate::BitReader;
        ///Field `IWDGRSTF` reader - Independent watchdog reset flag
        pub type IWDGRSTF_R = crate::BitReader;
        ///Field `WWDGRSTF` reader - Window watchdog reset flag
        pub type WWDGRSTF_R = crate::BitReader;
        ///Field `LPWRRSTF` reader - Low-power reset flag
        pub type LPWRRSTF_R = crate::BitReader;
        impl R {
            ///Bit 0 - Internal low speed oscillator enable
            #[inline(always)]
            pub fn lsion(&self) -> LSION_R {
                LSION_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Internal low speed oscillator ready
            #[inline(always)]
            pub fn lsirdy(&self) -> LSIRDY_R {
                LSIRDY_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 24 - Remove reset flag
            #[inline(always)]
            pub fn rmvf(&self) -> RMVF_R {
                RMVF_R::new(((self.bits >> 24) & 1) != 0)
            }
            ///Bit 26 - PIN reset flag
            #[inline(always)]
            pub fn pinrstf(&self) -> PINRSTF_R {
                PINRSTF_R::new(((self.bits >> 26) & 1) != 0)
            }
            ///Bit 27 - POR/PDR reset flag
            #[inline(always)]
            pub fn porrstf(&self) -> PORRSTF_R {
                PORRSTF_R::new(((self.bits >> 27) & 1) != 0)
            }
            ///Bit 28 - Software reset flag
            #[inline(always)]
            pub fn sftrstf(&self) -> SFTRSTF_R {
                SFTRSTF_R::new(((self.bits >> 28) & 1) != 0)
            }
            ///Bit 29 - Independent watchdog reset flag
            #[inline(always)]
            pub fn iwdgrstf(&self) -> IWDGRSTF_R {
                IWDGRSTF_R::new(((self.bits >> 29) & 1) != 0)
            }
            ///Bit 30 - Window watchdog reset flag
            #[inline(always)]
            pub fn wwdgrstf(&self) -> WWDGRSTF_R {
                WWDGRSTF_R::new(((self.bits >> 30) & 1) != 0)
            }
            ///Bit 31 - Low-power reset flag
            #[inline(always)]
            pub fn lpwrrstf(&self) -> LPWRRSTF_R {
                LPWRRSTF_R::new(((self.bits >> 31) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - Internal low speed oscillator enable
            #[inline(always)]
            #[must_use]
            pub fn lsion(&mut self) -> LSION_W<RSTSCKR_SPEC> {
                LSION_W::new(self, 0)
            }
            ///Bit 24 - Remove reset flag
            #[inline(always)]
            #[must_use]
            pub fn rmvf(&mut self) -> RMVF_W<RSTSCKR_SPEC> {
                RMVF_W::new(self, 24)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Control/status register (RCC_RSTSCKR)
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`rstsckr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`rstsckr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct RSTSCKR_SPEC;
        impl crate::RegisterSpec for RSTSCKR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`rstsckr::R`](R) reader structure
        impl crate::Readable for RSTSCKR_SPEC {}
        ///`write(|w| ..)` method takes [`rstsckr::W`](W) writer structure
        impl crate::Writable for RSTSCKR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets RSTSCKR to value 0x0c00_0000
        impl crate::Resettable for RSTSCKR_SPEC {
            const RESET_VALUE: u32 = 0x0c00_0000;
        }
    }
    ///AHBRSTR (rw) register accessor: AHB reset register (RCC_APHBRSTR)
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`ahbrstr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ahbrstr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@ahbrstr`]
    ///module
    pub type AHBRSTR = crate::Reg<ahbrstr::AHBRSTR_SPEC>;
    ///AHB reset register (RCC_APHBRSTR)
    pub mod ahbrstr {
        ///Register `AHBRSTR` reader
        pub type R = crate::R<AHBRSTR_SPEC>;
        ///Register `AHBRSTR` writer
        pub type W = crate::W<AHBRSTR_SPEC>;
        ///Field `USBFSRST` reader - USBFD reset control
        pub type USBFSRST_R = crate::BitReader;
        ///Field `USBFSRST` writer - USBFD reset control
        pub type USBFSRST_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `USBPDRST` reader - USBPD reset control
        pub type USBPDRST_R = crate::BitReader;
        ///Field `USBPDRST` writer - USBPD reset control
        pub type USBPDRST_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 12 - USBFD reset control
            #[inline(always)]
            pub fn usbfsrst(&self) -> USBFSRST_R {
                USBFSRST_R::new(((self.bits >> 12) & 1) != 0)
            }
            ///Bit 17 - USBPD reset control
            #[inline(always)]
            pub fn usbpdrst(&self) -> USBPDRST_R {
                USBPDRST_R::new(((self.bits >> 17) & 1) != 0)
            }
        }
        impl W {
            ///Bit 12 - USBFD reset control
            #[inline(always)]
            #[must_use]
            pub fn usbfsrst(&mut self) -> USBFSRST_W<AHBRSTR_SPEC> {
                USBFSRST_W::new(self, 12)
            }
            ///Bit 17 - USBPD reset control
            #[inline(always)]
            #[must_use]
            pub fn usbpdrst(&mut self) -> USBPDRST_W<AHBRSTR_SPEC> {
                USBPDRST_W::new(self, 17)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///AHB reset register (RCC_APHBRSTR)
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`ahbrstr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ahbrstr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct AHBRSTR_SPEC;
        impl crate::RegisterSpec for AHBRSTR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`ahbrstr::R`](R) reader structure
        impl crate::Readable for AHBRSTR_SPEC {}
        ///`write(|w| ..)` method takes [`ahbrstr::W`](W) writer structure
        impl crate::Writable for AHBRSTR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets AHBRSTR to value 0
        impl crate::Resettable for AHBRSTR_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
}
///Exten configuration
pub struct EXTEN {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for EXTEN {}
impl EXTEN {
    ///Pointer to the register block
    pub const PTR: *const exten::RegisterBlock = 0x4002_3800 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const exten::RegisterBlock {
        Self::PTR
    }
    /// Steal an instance of this peripheral
    ///
    /// # Safety
    ///
    /// Ensure that the new instance of the peripheral cannot be used in a way
    /// that may race with any existing instances, for example by only
    /// accessing read-only or write-only registers, or by consuming the
    /// original peripheral and using critical sections to coordinate
    /// access between multiple new instances.
    ///
    /// Additionally, other software such as HALs may rely on only one
    /// peripheral instance existing to ensure memory safety; ensure
    /// no stolen instances are passed to such software.
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for EXTEN {
    type Target = exten::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for EXTEN {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("EXTEN").finish()
    }
}
///Exten configuration
pub mod exten {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        exten_ctr: EXTEN_CTR,
    }
    impl RegisterBlock {
        ///0x00 - EXTEN control register
        #[inline(always)]
        pub const fn exten_ctr(&self) -> &EXTEN_CTR {
            &self.exten_ctr
        }
    }
    ///EXTEN_CTR (rw) register accessor: EXTEN control register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`exten_ctr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`exten_ctr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@exten_ctr`]
    ///module
    pub type EXTEN_CTR = crate::Reg<exten_ctr::EXTEN_CTR_SPEC>;
    ///EXTEN control register
    pub mod exten_ctr {
        ///Register `EXTEN_CTR` reader
        pub type R = crate::R<EXTEN_CTR_SPEC>;
        ///Register `EXTEN_CTR` writer
        pub type W = crate::W<EXTEN_CTR_SPEC>;
        ///Field `HSIPRE` reader - Whether HSI is divided
        pub type HSIPRE_R = crate::BitReader;
        ///Field `HSIPRE` writer - Whether HSI is divided
        pub type HSIPRE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `LKUPEN` reader - LOCKUP_Eable
        pub type LKUPEN_R = crate::BitReader;
        ///Field `LKUPEN` writer - LOCKUP_Eable
        pub type LKUPEN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `LKUPRST` reader - LOCKUP RESET
        pub type LKUPRST_R = crate::BitReader;
        ///Field `LKUPRST` writer - LOCKUP RESET
        pub type LKUPRST_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `ULLDOTRIM` reader - ULLDOTRIM
        pub type ULLDOTRIM_R = crate::FieldReader;
        ///Field `ULLDOTRIM` writer - ULLDOTRIM
        pub type ULLDOTRIM_W<'a, REG> = crate::FieldWriter<'a, REG, 3>;
        ///Field `LDOTRIM` reader - LDOTRIM
        pub type LDOTRIM_R = crate::FieldReader;
        ///Field `LDOTRIM` writer - LDOTRIM
        pub type LDOTRIM_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        impl R {
            ///Bit 4 - Whether HSI is divided
            #[inline(always)]
            pub fn hsipre(&self) -> HSIPRE_R {
                HSIPRE_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 6 - LOCKUP_Eable
            #[inline(always)]
            pub fn lkupen(&self) -> LKUPEN_R {
                LKUPEN_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - LOCKUP RESET
            #[inline(always)]
            pub fn lkuprst(&self) -> LKUPRST_R {
                LKUPRST_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bits 8:10 - ULLDOTRIM
            #[inline(always)]
            pub fn ulldotrim(&self) -> ULLDOTRIM_R {
                ULLDOTRIM_R::new(((self.bits >> 8) & 7) as u8)
            }
            ///Bits 12:13 - LDOTRIM
            #[inline(always)]
            pub fn ldotrim(&self) -> LDOTRIM_R {
                LDOTRIM_R::new(((self.bits >> 12) & 3) as u8)
            }
        }
        impl W {
            ///Bit 4 - Whether HSI is divided
            #[inline(always)]
            #[must_use]
            pub fn hsipre(&mut self) -> HSIPRE_W<EXTEN_CTR_SPEC> {
                HSIPRE_W::new(self, 4)
            }
            ///Bit 6 - LOCKUP_Eable
            #[inline(always)]
            #[must_use]
            pub fn lkupen(&mut self) -> LKUPEN_W<EXTEN_CTR_SPEC> {
                LKUPEN_W::new(self, 6)
            }
            ///Bit 7 - LOCKUP RESET
            #[inline(always)]
            #[must_use]
            pub fn lkuprst(&mut self) -> LKUPRST_W<EXTEN_CTR_SPEC> {
                LKUPRST_W::new(self, 7)
            }
            ///Bits 8:10 - ULLDOTRIM
            #[inline(always)]
            #[must_use]
            pub fn ulldotrim(&mut self) -> ULLDOTRIM_W<EXTEN_CTR_SPEC> {
                ULLDOTRIM_W::new(self, 8)
            }
            ///Bits 12:13 - LDOTRIM
            #[inline(always)]
            #[must_use]
            pub fn ldotrim(&mut self) -> LDOTRIM_W<EXTEN_CTR_SPEC> {
                LDOTRIM_W::new(self, 12)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///EXTEN control register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`exten_ctr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`exten_ctr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct EXTEN_CTR_SPEC;
        impl crate::RegisterSpec for EXTEN_CTR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`exten_ctr::R`](R) reader structure
        impl crate::Readable for EXTEN_CTR_SPEC {}
        ///`write(|w| ..)` method takes [`exten_ctr::W`](W) writer structure
        impl crate::Writable for EXTEN_CTR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets EXTEN_CTR to value 0x0a00
        impl crate::Resettable for EXTEN_CTR_SPEC {
            const RESET_VALUE: u32 = 0x0a00;
        }
    }
}
///OPA configuration
pub struct OPA {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for OPA {}
impl OPA {
    ///Pointer to the register block
    pub const PTR: *const opa::RegisterBlock = 0x4002_6000 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const opa::RegisterBlock {
        Self::PTR
    }
    /// Steal an instance of this peripheral
    ///
    /// # Safety
    ///
    /// Ensure that the new instance of the peripheral cannot be used in a way
    /// that may race with any existing instances, for example by only
    /// accessing read-only or write-only registers, or by consuming the
    /// original peripheral and using critical sections to coordinate
    /// access between multiple new instances.
    ///
    /// Additionally, other software such as HALs may rely on only one
    /// peripheral instance existing to ensure memory safety; ensure
    /// no stolen instances are passed to such software.
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for OPA {
    type Target = opa::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for OPA {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("OPA").finish()
    }
}
///OPA configuration
pub mod opa {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        cfgr1: CFGR1,
        cfgr2: CFGR2,
        ctlr1: CTLR1,
        ctlr2: CTLR2,
        opa_key: OPA_KEY,
        cmp_key: CMP_KEY,
        poll_key: POLL_KEY,
    }
    impl RegisterBlock {
        ///0x00 - OPA configuration 1
        #[inline(always)]
        pub const fn cfgr1(&self) -> &CFGR1 {
            &self.cfgr1
        }
        ///0x02 - OPA configuration 2
        #[inline(always)]
        pub const fn cfgr2(&self) -> &CFGR2 {
            &self.cfgr2
        }
        ///0x04 - OPA control register 1
        #[inline(always)]
        pub const fn ctlr1(&self) -> &CTLR1 {
            &self.ctlr1
        }
        ///0x08 - OPA control register 2
        #[inline(always)]
        pub const fn ctlr2(&self) -> &CTLR2 {
            &self.ctlr2
        }
        ///0x0c - OPA unlockkey
        #[inline(always)]
        pub const fn opa_key(&self) -> &OPA_KEY {
            &self.opa_key
        }
        ///0x10 - CMP unlockkey
        #[inline(always)]
        pub const fn cmp_key(&self) -> &CMP_KEY {
            &self.cmp_key
        }
        ///0x14 - polling unlockkey
        #[inline(always)]
        pub const fn poll_key(&self) -> &POLL_KEY {
            &self.poll_key
        }
    }
    ///CFGR1 (rw) register accessor: OPA configuration 1
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`cfgr1::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cfgr1::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@cfgr1`]
    ///module
    pub type CFGR1 = crate::Reg<cfgr1::CFGR1_SPEC>;
    ///OPA configuration 1
    pub mod cfgr1 {
        ///Register `CFGR1` reader
        pub type R = crate::R<CFGR1_SPEC>;
        ///Register `CFGR1` writer
        pub type W = crate::W<CFGR1_SPEC>;
        ///Field `POLL_EN` reader - OPA1 enable positive polling
        pub type POLL_EN_R = crate::BitReader;
        ///Field `POLL_EN` writer - OPA1 enable positive polling
        pub type POLL_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `BKIN_EN` reader - OPA1 break function enable
        pub type BKIN_EN_R = crate::BitReader;
        ///Field `BKIN_EN` writer - OPA1 break function enable
        pub type BKIN_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `RST_EN` reader - OPA1 reset enable
        pub type RST_EN_R = crate::BitReader;
        ///Field `RST_EN` writer - OPA1 reset enable
        pub type RST_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `POLL_LOCK` reader - POLL LOCK
        pub type POLL_LOCK_R = crate::BitReader;
        ///Field `POLL_LOCK` writer - POLL LOCK
        pub type POLL_LOCK_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `IE_OUT` reader - OPA1 interrupt enable
        pub type IE_OUT_R = crate::BitReader;
        ///Field `IE_OUT` writer - OPA1 interrupt enable
        pub type IE_OUT_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `IE_CNT` reader - OPA interrupt enable at the end of polling interval
        pub type IE_CNT_R = crate::BitReader;
        ///Field `IE_CNT` writer - OPA interrupt enable at the end of polling interval
        pub type IE_CNT_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `NMI_EN` reader - OPA connection NMI interrupt enable
        pub type NMI_EN_R = crate::BitReader;
        ///Field `NMI_EN` writer - OPA connection NMI interrupt enable
        pub type NMI_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `IF_OUT` reader - OPA1 output interrupt
        pub type IF_OUT_R = crate::BitReader;
        ///Field `IF_OUT` writer - OPA1 output interrupt
        pub type IF_OUT_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `IF_CNT` reader - OPA interrupt flag at the end of polling interval
        pub type IF_CNT_R = crate::BitReader;
        ///Field `IF_CNT` writer - OPA interrupt flag at the end of polling interval
        pub type IF_CNT_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - OPA1 enable positive polling
            #[inline(always)]
            pub fn poll_en(&self) -> POLL_EN_R {
                POLL_EN_R::new((self.bits & 1) != 0)
            }
            ///Bit 2 - OPA1 break function enable
            #[inline(always)]
            pub fn bkin_en(&self) -> BKIN_EN_R {
                BKIN_EN_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 4 - OPA1 reset enable
            #[inline(always)]
            pub fn rst_en(&self) -> RST_EN_R {
                RST_EN_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 7 - POLL LOCK
            #[inline(always)]
            pub fn poll_lock(&self) -> POLL_LOCK_R {
                POLL_LOCK_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bit 8 - OPA1 interrupt enable
            #[inline(always)]
            pub fn ie_out(&self) -> IE_OUT_R {
                IE_OUT_R::new(((self.bits >> 8) & 1) != 0)
            }
            ///Bit 10 - OPA interrupt enable at the end of polling interval
            #[inline(always)]
            pub fn ie_cnt(&self) -> IE_CNT_R {
                IE_CNT_R::new(((self.bits >> 10) & 1) != 0)
            }
            ///Bit 11 - OPA connection NMI interrupt enable
            #[inline(always)]
            pub fn nmi_en(&self) -> NMI_EN_R {
                NMI_EN_R::new(((self.bits >> 11) & 1) != 0)
            }
            ///Bit 12 - OPA1 output interrupt
            #[inline(always)]
            pub fn if_out(&self) -> IF_OUT_R {
                IF_OUT_R::new(((self.bits >> 12) & 1) != 0)
            }
            ///Bit 14 - OPA interrupt flag at the end of polling interval
            #[inline(always)]
            pub fn if_cnt(&self) -> IF_CNT_R {
                IF_CNT_R::new(((self.bits >> 14) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - OPA1 enable positive polling
            #[inline(always)]
            #[must_use]
            pub fn poll_en(&mut self) -> POLL_EN_W<CFGR1_SPEC> {
                POLL_EN_W::new(self, 0)
            }
            ///Bit 2 - OPA1 break function enable
            #[inline(always)]
            #[must_use]
            pub fn bkin_en(&mut self) -> BKIN_EN_W<CFGR1_SPEC> {
                BKIN_EN_W::new(self, 2)
            }
            ///Bit 4 - OPA1 reset enable
            #[inline(always)]
            #[must_use]
            pub fn rst_en(&mut self) -> RST_EN_W<CFGR1_SPEC> {
                RST_EN_W::new(self, 4)
            }
            ///Bit 7 - POLL LOCK
            #[inline(always)]
            #[must_use]
            pub fn poll_lock(&mut self) -> POLL_LOCK_W<CFGR1_SPEC> {
                POLL_LOCK_W::new(self, 7)
            }
            ///Bit 8 - OPA1 interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn ie_out(&mut self) -> IE_OUT_W<CFGR1_SPEC> {
                IE_OUT_W::new(self, 8)
            }
            ///Bit 10 - OPA interrupt enable at the end of polling interval
            #[inline(always)]
            #[must_use]
            pub fn ie_cnt(&mut self) -> IE_CNT_W<CFGR1_SPEC> {
                IE_CNT_W::new(self, 10)
            }
            ///Bit 11 - OPA connection NMI interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn nmi_en(&mut self) -> NMI_EN_W<CFGR1_SPEC> {
                NMI_EN_W::new(self, 11)
            }
            ///Bit 12 - OPA1 output interrupt
            #[inline(always)]
            #[must_use]
            pub fn if_out(&mut self) -> IF_OUT_W<CFGR1_SPEC> {
                IF_OUT_W::new(self, 12)
            }
            ///Bit 14 - OPA interrupt flag at the end of polling interval
            #[inline(always)]
            #[must_use]
            pub fn if_cnt(&mut self) -> IF_CNT_W<CFGR1_SPEC> {
                IF_CNT_W::new(self, 14)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///OPA configuration 1
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`cfgr1::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cfgr1::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct CFGR1_SPEC;
        impl crate::RegisterSpec for CFGR1_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`cfgr1::R`](R) reader structure
        impl crate::Readable for CFGR1_SPEC {}
        ///`write(|w| ..)` method takes [`cfgr1::W`](W) writer structure
        impl crate::Writable for CFGR1_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets CFGR1 to value 0x80
        impl crate::Resettable for CFGR1_SPEC {
            const RESET_VALUE: u16 = 0x80;
        }
    }
    ///CFGR2 (rw) register accessor: OPA configuration 2
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`cfgr2::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cfgr2::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@cfgr2`]
    ///module
    pub type CFGR2 = crate::Reg<cfgr2::CFGR2_SPEC>;
    ///OPA configuration 2
    pub mod cfgr2 {
        ///Register `CFGR2` reader
        pub type R = crate::R<CFGR2_SPEC>;
        ///Register `CFGR2` writer
        pub type W = crate::W<CFGR2_SPEC>;
        ///Field `POLL_VLU` reader - OPA1 polling interval
        pub type POLL_VLU_R = crate::FieldReader<u16>;
        ///Field `POLL_VLU` writer - OPA1 polling interval
        pub type POLL_VLU_W<'a, REG> = crate::FieldWriter<'a, REG, 9, u16>;
        ///Field `POLL1_NUM` reader - OPA1 polling the number of positive ends
        pub type POLL1_NUM_R = crate::FieldReader;
        ///Field `POLL1_NUM` writer - OPA1 polling the number of positive ends
        pub type POLL1_NUM_W<'a, REG> = crate::FieldWriter<'a, REG, 3>;
        impl R {
            ///Bits 0:8 - OPA1 polling interval
            #[inline(always)]
            pub fn poll_vlu(&self) -> POLL_VLU_R {
                POLL_VLU_R::new(self.bits & 0x01ff)
            }
            ///Bits 9:11 - OPA1 polling the number of positive ends
            #[inline(always)]
            pub fn poll1_num(&self) -> POLL1_NUM_R {
                POLL1_NUM_R::new(((self.bits >> 9) & 7) as u8)
            }
        }
        impl W {
            ///Bits 0:8 - OPA1 polling interval
            #[inline(always)]
            #[must_use]
            pub fn poll_vlu(&mut self) -> POLL_VLU_W<CFGR2_SPEC> {
                POLL_VLU_W::new(self, 0)
            }
            ///Bits 9:11 - OPA1 polling the number of positive ends
            #[inline(always)]
            #[must_use]
            pub fn poll1_num(&mut self) -> POLL1_NUM_W<CFGR2_SPEC> {
                POLL1_NUM_W::new(self, 9)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///OPA configuration 2
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`cfgr2::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cfgr2::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct CFGR2_SPEC;
        impl crate::RegisterSpec for CFGR2_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`cfgr2::R`](R) reader structure
        impl crate::Readable for CFGR2_SPEC {}
        ///`write(|w| ..)` method takes [`cfgr2::W`](W) writer structure
        impl crate::Writable for CFGR2_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets CFGR2 to value 0
        impl crate::Resettable for CFGR2_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///CTLR1 (rw) register accessor: OPA control register 1
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`ctlr1::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ctlr1::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@ctlr1`]
    ///module
    pub type CTLR1 = crate::Reg<ctlr1::CTLR1_SPEC>;
    ///OPA control register 1
    pub mod ctlr1 {
        ///Register `CTLR1` reader
        pub type R = crate::R<CTLR1_SPEC>;
        ///Register `CTLR1` writer
        pub type W = crate::W<CTLR1_SPEC>;
        ///Field `EN1` reader - OPA1 enable
        pub type EN1_R = crate::BitReader;
        ///Field `EN1` writer - OPA1 enable
        pub type EN1_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `MODE1` reader - OPA1 output channel selection
        pub type MODE1_R = crate::FieldReader;
        ///Field `MODE1` writer - OPA1 output channel selection
        pub type MODE1_W<'a, REG> = crate::FieldWriter<'a, REG, 3>;
        ///Field `PSEL1` reader - OPA1 forward input selection
        pub type PSEL1_R = crate::FieldReader;
        ///Field `PSEL1` writer - OPA1 forward input selection
        pub type PSEL1_W<'a, REG> = crate::FieldWriter<'a, REG, 3>;
        ///Field `FB_EN1` reader - OPA1 internal feedback resistance enable
        pub type FB_EN1_R = crate::BitReader;
        ///Field `FB_EN1` writer - OPA1 internal feedback resistance enable
        pub type FB_EN1_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `NSEL1` reader - OPA1 negative end channel selection with PGA gain selection
        pub type NSEL1_R = crate::FieldReader;
        ///Field `NSEL1` writer - OPA1 negative end channel selection with PGA gain selection
        pub type NSEL1_W<'a, REG> = crate::FieldWriter<'a, REG, 4>;
        ///Field `LP1` reader - OPA1 low-power mode selection
        pub type LP1_R = crate::BitReader;
        ///Field `LP1` writer - OPA1 low-power mode selection
        pub type LP1_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `INTRIMP` reader - OPA1 high-level offset voltage value polarity selection
        pub type INTRIMP_R = crate::BitReader;
        ///Field `INTRIMP` writer - OPA1 high-level offset voltage value polarity selection
        pub type INTRIMP_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `ITRIMP` reader - OPA1 high-level offset voltage value selection
        pub type ITRIMP_R = crate::FieldReader;
        ///Field `ITRIMP` writer - OPA1 high-level offset voltage value selection
        pub type ITRIMP_W<'a, REG> = crate::FieldWriter<'a, REG, 5>;
        ///Field `INTRIMN` reader - OPA1 low-level offset voltage value polarity selection
        pub type INTRIMN_R = crate::BitReader;
        ///Field `INTRIMN` writer - OPA1 low-level offset voltage value polarity selection
        pub type INTRIMN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `ITRIMN` reader - OPA1 low-level offset voltage value selection
        pub type ITRIMN_R = crate::FieldReader;
        ///Field `ITRIMN` writer - OPA1 low-level offset voltage value selection
        pub type ITRIMN_W<'a, REG> = crate::FieldWriter<'a, REG, 5>;
        ///Field `OPA_LOCK` reader - OPA lock
        pub type OPA_LOCK_R = crate::BitReader;
        ///Field `OPA_LOCK` writer - OPA lock
        pub type OPA_LOCK_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - OPA1 enable
            #[inline(always)]
            pub fn en1(&self) -> EN1_R {
                EN1_R::new((self.bits & 1) != 0)
            }
            ///Bits 1:3 - OPA1 output channel selection
            #[inline(always)]
            pub fn mode1(&self) -> MODE1_R {
                MODE1_R::new(((self.bits >> 1) & 7) as u8)
            }
            ///Bits 4:6 - OPA1 forward input selection
            #[inline(always)]
            pub fn psel1(&self) -> PSEL1_R {
                PSEL1_R::new(((self.bits >> 4) & 7) as u8)
            }
            ///Bit 7 - OPA1 internal feedback resistance enable
            #[inline(always)]
            pub fn fb_en1(&self) -> FB_EN1_R {
                FB_EN1_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bits 8:11 - OPA1 negative end channel selection with PGA gain selection
            #[inline(always)]
            pub fn nsel1(&self) -> NSEL1_R {
                NSEL1_R::new(((self.bits >> 8) & 0x0f) as u8)
            }
            ///Bit 12 - OPA1 low-power mode selection
            #[inline(always)]
            pub fn lp1(&self) -> LP1_R {
                LP1_R::new(((self.bits >> 12) & 1) != 0)
            }
            ///Bit 16 - OPA1 high-level offset voltage value polarity selection
            #[inline(always)]
            pub fn intrimp(&self) -> INTRIMP_R {
                INTRIMP_R::new(((self.bits >> 16) & 1) != 0)
            }
            ///Bits 17:21 - OPA1 high-level offset voltage value selection
            #[inline(always)]
            pub fn itrimp(&self) -> ITRIMP_R {
                ITRIMP_R::new(((self.bits >> 17) & 0x1f) as u8)
            }
            ///Bit 24 - OPA1 low-level offset voltage value polarity selection
            #[inline(always)]
            pub fn intrimn(&self) -> INTRIMN_R {
                INTRIMN_R::new(((self.bits >> 24) & 1) != 0)
            }
            ///Bits 25:29 - OPA1 low-level offset voltage value selection
            #[inline(always)]
            pub fn itrimn(&self) -> ITRIMN_R {
                ITRIMN_R::new(((self.bits >> 25) & 0x1f) as u8)
            }
            ///Bit 31 - OPA lock
            #[inline(always)]
            pub fn opa_lock(&self) -> OPA_LOCK_R {
                OPA_LOCK_R::new(((self.bits >> 31) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - OPA1 enable
            #[inline(always)]
            #[must_use]
            pub fn en1(&mut self) -> EN1_W<CTLR1_SPEC> {
                EN1_W::new(self, 0)
            }
            ///Bits 1:3 - OPA1 output channel selection
            #[inline(always)]
            #[must_use]
            pub fn mode1(&mut self) -> MODE1_W<CTLR1_SPEC> {
                MODE1_W::new(self, 1)
            }
            ///Bits 4:6 - OPA1 forward input selection
            #[inline(always)]
            #[must_use]
            pub fn psel1(&mut self) -> PSEL1_W<CTLR1_SPEC> {
                PSEL1_W::new(self, 4)
            }
            ///Bit 7 - OPA1 internal feedback resistance enable
            #[inline(always)]
            #[must_use]
            pub fn fb_en1(&mut self) -> FB_EN1_W<CTLR1_SPEC> {
                FB_EN1_W::new(self, 7)
            }
            ///Bits 8:11 - OPA1 negative end channel selection with PGA gain selection
            #[inline(always)]
            #[must_use]
            pub fn nsel1(&mut self) -> NSEL1_W<CTLR1_SPEC> {
                NSEL1_W::new(self, 8)
            }
            ///Bit 12 - OPA1 low-power mode selection
            #[inline(always)]
            #[must_use]
            pub fn lp1(&mut self) -> LP1_W<CTLR1_SPEC> {
                LP1_W::new(self, 12)
            }
            ///Bit 16 - OPA1 high-level offset voltage value polarity selection
            #[inline(always)]
            #[must_use]
            pub fn intrimp(&mut self) -> INTRIMP_W<CTLR1_SPEC> {
                INTRIMP_W::new(self, 16)
            }
            ///Bits 17:21 - OPA1 high-level offset voltage value selection
            #[inline(always)]
            #[must_use]
            pub fn itrimp(&mut self) -> ITRIMP_W<CTLR1_SPEC> {
                ITRIMP_W::new(self, 17)
            }
            ///Bit 24 - OPA1 low-level offset voltage value polarity selection
            #[inline(always)]
            #[must_use]
            pub fn intrimn(&mut self) -> INTRIMN_W<CTLR1_SPEC> {
                INTRIMN_W::new(self, 24)
            }
            ///Bits 25:29 - OPA1 low-level offset voltage value selection
            #[inline(always)]
            #[must_use]
            pub fn itrimn(&mut self) -> ITRIMN_W<CTLR1_SPEC> {
                ITRIMN_W::new(self, 25)
            }
            ///Bit 31 - OPA lock
            #[inline(always)]
            #[must_use]
            pub fn opa_lock(&mut self) -> OPA_LOCK_W<CTLR1_SPEC> {
                OPA_LOCK_W::new(self, 31)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///OPA control register 1
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`ctlr1::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ctlr1::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct CTLR1_SPEC;
        impl crate::RegisterSpec for CTLR1_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`ctlr1::R`](R) reader structure
        impl crate::Readable for CTLR1_SPEC {}
        ///`write(|w| ..)` method takes [`ctlr1::W`](W) writer structure
        impl crate::Writable for CTLR1_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets CTLR1 to value 0x81d8_01d8
        impl crate::Resettable for CTLR1_SPEC {
            const RESET_VALUE: u32 = 0x81d8_01d8;
        }
    }
    ///CTLR2 (rw) register accessor: OPA control register 2
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`ctlr2::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ctlr2::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@ctlr2`]
    ///module
    pub type CTLR2 = crate::Reg<ctlr2::CTLR2_SPEC>;
    ///OPA control register 2
    pub mod ctlr2 {
        ///Register `CTLR2` reader
        pub type R = crate::R<CTLR2_SPEC>;
        ///Register `CTLR2` writer
        pub type W = crate::W<CTLR2_SPEC>;
        ///Field `EN1` reader - CMP1 enable
        pub type EN1_R = crate::BitReader;
        ///Field `EN1` writer - CMP1 enable
        pub type EN1_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `MODE1` reader - CMP1 Output channel selection
        pub type MODE1_R = crate::FieldReader;
        ///Field `MODE1` writer - CMP1 Output channel selection
        pub type MODE1_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `NSEL1` reader - CMP1 negative input selection
        pub type NSEL1_R = crate::BitReader;
        ///Field `NSEL1` writer - CMP1 negative input selection
        pub type NSEL1_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PSEL1` reader - CMP1 forward input selection
        pub type PSEL1_R = crate::BitReader;
        ///Field `PSEL1` writer - CMP1 forward input selection
        pub type PSEL1_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `HYEN1` reader - CMP1 hysteresis function selection
        pub type HYEN1_R = crate::BitReader;
        ///Field `HYEN1` writer - CMP1 hysteresis function selection
        pub type HYEN1_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `LP1` reader - CMP1 low-power switch
        pub type LP1_R = crate::BitReader;
        ///Field `LP1` writer - CMP1 low-power switch
        pub type LP1_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `EN2` reader - CMP2 enable
        pub type EN2_R = crate::BitReader;
        ///Field `EN2` writer - CMP2 enable
        pub type EN2_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `MODE2` reader - CMP2 Output channel selection
        pub type MODE2_R = crate::FieldReader;
        ///Field `MODE2` writer - CMP2 Output channel selection
        pub type MODE2_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `NSE2L` reader - CMP2 negative input selection
        pub type NSE2L_R = crate::BitReader;
        ///Field `NSE2L` writer - CMP2 negative input selection
        pub type NSE2L_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PSEL2` reader - CMP2 forward input selection
        pub type PSEL2_R = crate::BitReader;
        ///Field `PSEL2` writer - CMP2 forward input selection
        pub type PSEL2_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `HYEN2` reader - CMP2 hysteresis function selection
        pub type HYEN2_R = crate::BitReader;
        ///Field `HYEN2` writer - CMP2 hysteresis function selection
        pub type HYEN2_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `LP2` reader - CMP2 low-power switch
        pub type LP2_R = crate::BitReader;
        ///Field `LP2` writer - CMP2 low-power switch
        pub type LP2_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `EN3` reader - CMP3 enable
        pub type EN3_R = crate::BitReader;
        ///Field `EN3` writer - CMP3 enable
        pub type EN3_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `MODE3` reader - CMP3 Output channel selection
        pub type MODE3_R = crate::FieldReader;
        ///Field `MODE3` writer - CMP3 Output channel selection
        pub type MODE3_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `NSEL3` reader - CMP3 negative input selection
        pub type NSEL3_R = crate::BitReader;
        ///Field `NSEL3` writer - CMP3 negative input selection
        pub type NSEL3_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PSEL3` reader - CMP3 forward input selection
        pub type PSEL3_R = crate::BitReader;
        ///Field `PSEL3` writer - CMP3 forward input selection
        pub type PSEL3_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `HYEN3` reader - CMP3 hysteresis function selection
        pub type HYEN3_R = crate::BitReader;
        ///Field `HYEN3` writer - CMP3 hysteresis function selection
        pub type HYEN3_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `LP3` reader - CMP3 low-power switch
        pub type LP3_R = crate::BitReader;
        ///Field `LP3` writer - CMP3 low-power switch
        pub type LP3_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `WKUP_MD` reader - CMP wake-up signal mode selection
        pub type WKUP_MD_R = crate::FieldReader;
        ///Field `WKUP_MD` writer - CMP wake-up signal mode selection
        pub type WKUP_MD_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `CMP_LOCK` reader - CMP lock
        pub type CMP_LOCK_R = crate::BitReader;
        ///Field `CMP_LOCK` writer - CMP lock
        pub type CMP_LOCK_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - CMP1 enable
            #[inline(always)]
            pub fn en1(&self) -> EN1_R {
                EN1_R::new((self.bits & 1) != 0)
            }
            ///Bits 1:2 - CMP1 Output channel selection
            #[inline(always)]
            pub fn mode1(&self) -> MODE1_R {
                MODE1_R::new(((self.bits >> 1) & 3) as u8)
            }
            ///Bit 3 - CMP1 negative input selection
            #[inline(always)]
            pub fn nsel1(&self) -> NSEL1_R {
                NSEL1_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - CMP1 forward input selection
            #[inline(always)]
            pub fn psel1(&self) -> PSEL1_R {
                PSEL1_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - CMP1 hysteresis function selection
            #[inline(always)]
            pub fn hyen1(&self) -> HYEN1_R {
                HYEN1_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - CMP1 low-power switch
            #[inline(always)]
            pub fn lp1(&self) -> LP1_R {
                LP1_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 8 - CMP2 enable
            #[inline(always)]
            pub fn en2(&self) -> EN2_R {
                EN2_R::new(((self.bits >> 8) & 1) != 0)
            }
            ///Bits 9:10 - CMP2 Output channel selection
            #[inline(always)]
            pub fn mode2(&self) -> MODE2_R {
                MODE2_R::new(((self.bits >> 9) & 3) as u8)
            }
            ///Bit 11 - CMP2 negative input selection
            #[inline(always)]
            pub fn nse2l(&self) -> NSE2L_R {
                NSE2L_R::new(((self.bits >> 11) & 1) != 0)
            }
            ///Bit 12 - CMP2 forward input selection
            #[inline(always)]
            pub fn psel2(&self) -> PSEL2_R {
                PSEL2_R::new(((self.bits >> 12) & 1) != 0)
            }
            ///Bit 13 - CMP2 hysteresis function selection
            #[inline(always)]
            pub fn hyen2(&self) -> HYEN2_R {
                HYEN2_R::new(((self.bits >> 13) & 1) != 0)
            }
            ///Bit 14 - CMP2 low-power switch
            #[inline(always)]
            pub fn lp2(&self) -> LP2_R {
                LP2_R::new(((self.bits >> 14) & 1) != 0)
            }
            ///Bit 16 - CMP3 enable
            #[inline(always)]
            pub fn en3(&self) -> EN3_R {
                EN3_R::new(((self.bits >> 16) & 1) != 0)
            }
            ///Bits 17:18 - CMP3 Output channel selection
            #[inline(always)]
            pub fn mode3(&self) -> MODE3_R {
                MODE3_R::new(((self.bits >> 17) & 3) as u8)
            }
            ///Bit 19 - CMP3 negative input selection
            #[inline(always)]
            pub fn nsel3(&self) -> NSEL3_R {
                NSEL3_R::new(((self.bits >> 19) & 1) != 0)
            }
            ///Bit 20 - CMP3 forward input selection
            #[inline(always)]
            pub fn psel3(&self) -> PSEL3_R {
                PSEL3_R::new(((self.bits >> 20) & 1) != 0)
            }
            ///Bit 21 - CMP3 hysteresis function selection
            #[inline(always)]
            pub fn hyen3(&self) -> HYEN3_R {
                HYEN3_R::new(((self.bits >> 21) & 1) != 0)
            }
            ///Bit 22 - CMP3 low-power switch
            #[inline(always)]
            pub fn lp3(&self) -> LP3_R {
                LP3_R::new(((self.bits >> 22) & 1) != 0)
            }
            ///Bits 24:25 - CMP wake-up signal mode selection
            #[inline(always)]
            pub fn wkup_md(&self) -> WKUP_MD_R {
                WKUP_MD_R::new(((self.bits >> 24) & 3) as u8)
            }
            ///Bit 31 - CMP lock
            #[inline(always)]
            pub fn cmp_lock(&self) -> CMP_LOCK_R {
                CMP_LOCK_R::new(((self.bits >> 31) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - CMP1 enable
            #[inline(always)]
            #[must_use]
            pub fn en1(&mut self) -> EN1_W<CTLR2_SPEC> {
                EN1_W::new(self, 0)
            }
            ///Bits 1:2 - CMP1 Output channel selection
            #[inline(always)]
            #[must_use]
            pub fn mode1(&mut self) -> MODE1_W<CTLR2_SPEC> {
                MODE1_W::new(self, 1)
            }
            ///Bit 3 - CMP1 negative input selection
            #[inline(always)]
            #[must_use]
            pub fn nsel1(&mut self) -> NSEL1_W<CTLR2_SPEC> {
                NSEL1_W::new(self, 3)
            }
            ///Bit 4 - CMP1 forward input selection
            #[inline(always)]
            #[must_use]
            pub fn psel1(&mut self) -> PSEL1_W<CTLR2_SPEC> {
                PSEL1_W::new(self, 4)
            }
            ///Bit 5 - CMP1 hysteresis function selection
            #[inline(always)]
            #[must_use]
            pub fn hyen1(&mut self) -> HYEN1_W<CTLR2_SPEC> {
                HYEN1_W::new(self, 5)
            }
            ///Bit 6 - CMP1 low-power switch
            #[inline(always)]
            #[must_use]
            pub fn lp1(&mut self) -> LP1_W<CTLR2_SPEC> {
                LP1_W::new(self, 6)
            }
            ///Bit 8 - CMP2 enable
            #[inline(always)]
            #[must_use]
            pub fn en2(&mut self) -> EN2_W<CTLR2_SPEC> {
                EN2_W::new(self, 8)
            }
            ///Bits 9:10 - CMP2 Output channel selection
            #[inline(always)]
            #[must_use]
            pub fn mode2(&mut self) -> MODE2_W<CTLR2_SPEC> {
                MODE2_W::new(self, 9)
            }
            ///Bit 11 - CMP2 negative input selection
            #[inline(always)]
            #[must_use]
            pub fn nse2l(&mut self) -> NSE2L_W<CTLR2_SPEC> {
                NSE2L_W::new(self, 11)
            }
            ///Bit 12 - CMP2 forward input selection
            #[inline(always)]
            #[must_use]
            pub fn psel2(&mut self) -> PSEL2_W<CTLR2_SPEC> {
                PSEL2_W::new(self, 12)
            }
            ///Bit 13 - CMP2 hysteresis function selection
            #[inline(always)]
            #[must_use]
            pub fn hyen2(&mut self) -> HYEN2_W<CTLR2_SPEC> {
                HYEN2_W::new(self, 13)
            }
            ///Bit 14 - CMP2 low-power switch
            #[inline(always)]
            #[must_use]
            pub fn lp2(&mut self) -> LP2_W<CTLR2_SPEC> {
                LP2_W::new(self, 14)
            }
            ///Bit 16 - CMP3 enable
            #[inline(always)]
            #[must_use]
            pub fn en3(&mut self) -> EN3_W<CTLR2_SPEC> {
                EN3_W::new(self, 16)
            }
            ///Bits 17:18 - CMP3 Output channel selection
            #[inline(always)]
            #[must_use]
            pub fn mode3(&mut self) -> MODE3_W<CTLR2_SPEC> {
                MODE3_W::new(self, 17)
            }
            ///Bit 19 - CMP3 negative input selection
            #[inline(always)]
            #[must_use]
            pub fn nsel3(&mut self) -> NSEL3_W<CTLR2_SPEC> {
                NSEL3_W::new(self, 19)
            }
            ///Bit 20 - CMP3 forward input selection
            #[inline(always)]
            #[must_use]
            pub fn psel3(&mut self) -> PSEL3_W<CTLR2_SPEC> {
                PSEL3_W::new(self, 20)
            }
            ///Bit 21 - CMP3 hysteresis function selection
            #[inline(always)]
            #[must_use]
            pub fn hyen3(&mut self) -> HYEN3_W<CTLR2_SPEC> {
                HYEN3_W::new(self, 21)
            }
            ///Bit 22 - CMP3 low-power switch
            #[inline(always)]
            #[must_use]
            pub fn lp3(&mut self) -> LP3_W<CTLR2_SPEC> {
                LP3_W::new(self, 22)
            }
            ///Bits 24:25 - CMP wake-up signal mode selection
            #[inline(always)]
            #[must_use]
            pub fn wkup_md(&mut self) -> WKUP_MD_W<CTLR2_SPEC> {
                WKUP_MD_W::new(self, 24)
            }
            ///Bit 31 - CMP lock
            #[inline(always)]
            #[must_use]
            pub fn cmp_lock(&mut self) -> CMP_LOCK_W<CTLR2_SPEC> {
                CMP_LOCK_W::new(self, 31)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///OPA control register 2
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`ctlr2::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ctlr2::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct CTLR2_SPEC;
        impl crate::RegisterSpec for CTLR2_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`ctlr2::R`](R) reader structure
        impl crate::Readable for CTLR2_SPEC {}
        ///`write(|w| ..)` method takes [`ctlr2::W`](W) writer structure
        impl crate::Writable for CTLR2_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets CTLR2 to value 0x8000_0000
        impl crate::Resettable for CTLR2_SPEC {
            const RESET_VALUE: u32 = 0x8000_0000;
        }
    }
    ///OPA_KEY (rw) register accessor: OPA unlockkey
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`opa_key::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`opa_key::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@opa_key`]
    ///module
    pub type OPA_KEY = crate::Reg<opa_key::OPA_KEY_SPEC>;
    ///OPA unlockkey
    pub mod opa_key {
        ///Register `OPA_KEY` reader
        pub type R = crate::R<OPA_KEY_SPEC>;
        ///Register `OPA_KEY` writer
        pub type W = crate::W<OPA_KEY_SPEC>;
        ///Field `OPA_KEY` reader - OPA unlockkey
        pub type OPA_KEY_R = crate::FieldReader<u32>;
        ///Field `OPA_KEY` writer - OPA unlockkey
        pub type OPA_KEY_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - OPA unlockkey
            #[inline(always)]
            pub fn opa_key(&self) -> OPA_KEY_R {
                OPA_KEY_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - OPA unlockkey
            #[inline(always)]
            #[must_use]
            pub fn opa_key(&mut self) -> OPA_KEY_W<OPA_KEY_SPEC> {
                OPA_KEY_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///OPA unlockkey
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`opa_key::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`opa_key::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct OPA_KEY_SPEC;
        impl crate::RegisterSpec for OPA_KEY_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`opa_key::R`](R) reader structure
        impl crate::Readable for OPA_KEY_SPEC {}
        ///`write(|w| ..)` method takes [`opa_key::W`](W) writer structure
        impl crate::Writable for OPA_KEY_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets OPA_KEY to value 0
        impl crate::Resettable for OPA_KEY_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///CMP_KEY (rw) register accessor: CMP unlockkey
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`cmp_key::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cmp_key::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@cmp_key`]
    ///module
    pub type CMP_KEY = crate::Reg<cmp_key::CMP_KEY_SPEC>;
    ///CMP unlockkey
    pub mod cmp_key {
        ///Register `CMP_KEY` reader
        pub type R = crate::R<CMP_KEY_SPEC>;
        ///Register `CMP_KEY` writer
        pub type W = crate::W<CMP_KEY_SPEC>;
        ///Field `CMP_KEY` reader - CMP unlockkey
        pub type CMP_KEY_R = crate::FieldReader<u32>;
        ///Field `CMP_KEY` writer - CMP unlockkey
        pub type CMP_KEY_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - CMP unlockkey
            #[inline(always)]
            pub fn cmp_key(&self) -> CMP_KEY_R {
                CMP_KEY_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - CMP unlockkey
            #[inline(always)]
            #[must_use]
            pub fn cmp_key(&mut self) -> CMP_KEY_W<CMP_KEY_SPEC> {
                CMP_KEY_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///CMP unlockkey
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`cmp_key::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cmp_key::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct CMP_KEY_SPEC;
        impl crate::RegisterSpec for CMP_KEY_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`cmp_key::R`](R) reader structure
        impl crate::Readable for CMP_KEY_SPEC {}
        ///`write(|w| ..)` method takes [`cmp_key::W`](W) writer structure
        impl crate::Writable for CMP_KEY_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets CMP_KEY to value 0
        impl crate::Resettable for CMP_KEY_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///POLL_KEY (rw) register accessor: polling unlockkey
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`poll_key::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`poll_key::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@poll_key`]
    ///module
    pub type POLL_KEY = crate::Reg<poll_key::POLL_KEY_SPEC>;
    ///polling unlockkey
    pub mod poll_key {
        ///Register `POLL_KEY` reader
        pub type R = crate::R<POLL_KEY_SPEC>;
        ///Register `POLL_KEY` writer
        pub type W = crate::W<POLL_KEY_SPEC>;
        ///Field `POLL_KEY` reader - polling unlockkey
        pub type POLL_KEY_R = crate::FieldReader<u32>;
        ///Field `POLL_KEY` writer - polling unlockkey
        pub type POLL_KEY_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - polling unlockkey
            #[inline(always)]
            pub fn poll_key(&self) -> POLL_KEY_R {
                POLL_KEY_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - polling unlockkey
            #[inline(always)]
            #[must_use]
            pub fn poll_key(&mut self) -> POLL_KEY_W<POLL_KEY_SPEC> {
                POLL_KEY_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///polling unlockkey
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`poll_key::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`poll_key::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct POLL_KEY_SPEC;
        impl crate::RegisterSpec for POLL_KEY_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`poll_key::R`](R) reader structure
        impl crate::Readable for POLL_KEY_SPEC {}
        ///`write(|w| ..)` method takes [`poll_key::W`](W) writer structure
        impl crate::Writable for POLL_KEY_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets POLL_KEY to value 0
        impl crate::Resettable for POLL_KEY_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
}
///General purpose I/O
pub struct GPIOA {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for GPIOA {}
impl GPIOA {
    ///Pointer to the register block
    pub const PTR: *const gpioa::RegisterBlock = 0x4001_0800 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const gpioa::RegisterBlock {
        Self::PTR
    }
    /// Steal an instance of this peripheral
    ///
    /// # Safety
    ///
    /// Ensure that the new instance of the peripheral cannot be used in a way
    /// that may race with any existing instances, for example by only
    /// accessing read-only or write-only registers, or by consuming the
    /// original peripheral and using critical sections to coordinate
    /// access between multiple new instances.
    ///
    /// Additionally, other software such as HALs may rely on only one
    /// peripheral instance existing to ensure memory safety; ensure
    /// no stolen instances are passed to such software.
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for GPIOA {
    type Target = gpioa::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for GPIOA {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GPIOA").finish()
    }
}
///General purpose I/O
pub mod gpioa {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        cfglr: CFGLR,
        cfghr: CFGHR,
        indr: INDR,
        outdr: OUTDR,
        bshr: BSHR,
        bcr: BCR,
        lckr: LCKR,
    }
    impl RegisterBlock {
        ///0x00 - Port configuration register low(GPIOn_CFGLR)
        #[inline(always)]
        pub const fn cfglr(&self) -> &CFGLR {
            &self.cfglr
        }
        ///0x04 - Port configuration register high (GPIOn_CFGHR)
        #[inline(always)]
        pub const fn cfghr(&self) -> &CFGHR {
            &self.cfghr
        }
        ///0x08 - Port input data register (GPIOn_INDR)
        #[inline(always)]
        pub const fn indr(&self) -> &INDR {
            &self.indr
        }
        ///0x0c - Port output data register (GPIOn_OUTDR)
        #[inline(always)]
        pub const fn outdr(&self) -> &OUTDR {
            &self.outdr
        }
        ///0x10 - Port bit set/reset register (GPIOn_BSHR)
        #[inline(always)]
        pub const fn bshr(&self) -> &BSHR {
            &self.bshr
        }
        ///0x14 - Port bit reset register (GPIOn_BCR)
        #[inline(always)]
        pub const fn bcr(&self) -> &BCR {
            &self.bcr
        }
        ///0x18 - Port configuration lock register
        #[inline(always)]
        pub const fn lckr(&self) -> &LCKR {
            &self.lckr
        }
    }
    ///CFGLR (rw) register accessor: Port configuration register low(GPIOn_CFGLR)
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`cfglr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cfglr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@cfglr`]
    ///module
    pub type CFGLR = crate::Reg<cfglr::CFGLR_SPEC>;
    ///Port configuration register low(GPIOn_CFGLR)
    pub mod cfglr {
        ///Register `CFGLR` reader
        pub type R = crate::R<CFGLR_SPEC>;
        ///Register `CFGLR` writer
        pub type W = crate::W<CFGLR_SPEC>;
        ///Field `MODE0` reader - Port n.0 mode bits
        pub type MODE0_R = crate::FieldReader;
        ///Field `MODE0` writer - Port n.0 mode bits
        pub type MODE0_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `CNF0` reader - Port n.0 configuration bits
        pub type CNF0_R = crate::FieldReader;
        ///Field `CNF0` writer - Port n.0 configuration bits
        pub type CNF0_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `MODE1` reader - Port n.1 mode bits
        pub type MODE1_R = crate::FieldReader;
        ///Field `MODE1` writer - Port n.1 mode bits
        pub type MODE1_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `CNF1` reader - Port n.1 configuration bits
        pub type CNF1_R = crate::FieldReader;
        ///Field `CNF1` writer - Port n.1 configuration bits
        pub type CNF1_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `MODE2` reader - Port n.2 mode bits
        pub type MODE2_R = crate::FieldReader;
        ///Field `MODE2` writer - Port n.2 mode bits
        pub type MODE2_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `CNF2` reader - Port n.2 configuration bits
        pub type CNF2_R = crate::FieldReader;
        ///Field `CNF2` writer - Port n.2 configuration bits
        pub type CNF2_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `MODE3` reader - Port n.3 mode bits
        pub type MODE3_R = crate::FieldReader;
        ///Field `MODE3` writer - Port n.3 mode bits
        pub type MODE3_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `CNF3` reader - Port n.3 configuration bits
        pub type CNF3_R = crate::FieldReader;
        ///Field `CNF3` writer - Port n.3 configuration bits
        pub type CNF3_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `MODE4` reader - Port n.4 mode bits
        pub type MODE4_R = crate::FieldReader;
        ///Field `MODE4` writer - Port n.4 mode bits
        pub type MODE4_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `CNF4` reader - Port n.4 configuration bits
        pub type CNF4_R = crate::FieldReader;
        ///Field `CNF4` writer - Port n.4 configuration bits
        pub type CNF4_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `MODE5` reader - Port n.5 mode bits
        pub type MODE5_R = crate::FieldReader;
        ///Field `MODE5` writer - Port n.5 mode bits
        pub type MODE5_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `CNF5` reader - Port n.5 configuration bits
        pub type CNF5_R = crate::FieldReader;
        ///Field `CNF5` writer - Port n.5 configuration bits
        pub type CNF5_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `MODE6` reader - Port n.6 mode bits
        pub type MODE6_R = crate::FieldReader;
        ///Field `MODE6` writer - Port n.6 mode bits
        pub type MODE6_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `CNF6` reader - Port n.6 configuration bits
        pub type CNF6_R = crate::FieldReader;
        ///Field `CNF6` writer - Port n.6 configuration bits
        pub type CNF6_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `MODE7` reader - Port n.7 mode bits
        pub type MODE7_R = crate::FieldReader;
        ///Field `MODE7` writer - Port n.7 mode bits
        pub type MODE7_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `CNF7` reader - Port n.7 configuration bits
        pub type CNF7_R = crate::FieldReader;
        ///Field `CNF7` writer - Port n.7 configuration bits
        pub type CNF7_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        impl R {
            ///Bits 0:1 - Port n.0 mode bits
            #[inline(always)]
            pub fn mode0(&self) -> MODE0_R {
                MODE0_R::new((self.bits & 3) as u8)
            }
            ///Bits 2:3 - Port n.0 configuration bits
            #[inline(always)]
            pub fn cnf0(&self) -> CNF0_R {
                CNF0_R::new(((self.bits >> 2) & 3) as u8)
            }
            ///Bits 4:5 - Port n.1 mode bits
            #[inline(always)]
            pub fn mode1(&self) -> MODE1_R {
                MODE1_R::new(((self.bits >> 4) & 3) as u8)
            }
            ///Bits 6:7 - Port n.1 configuration bits
            #[inline(always)]
            pub fn cnf1(&self) -> CNF1_R {
                CNF1_R::new(((self.bits >> 6) & 3) as u8)
            }
            ///Bits 8:9 - Port n.2 mode bits
            #[inline(always)]
            pub fn mode2(&self) -> MODE2_R {
                MODE2_R::new(((self.bits >> 8) & 3) as u8)
            }
            ///Bits 10:11 - Port n.2 configuration bits
            #[inline(always)]
            pub fn cnf2(&self) -> CNF2_R {
                CNF2_R::new(((self.bits >> 10) & 3) as u8)
            }
            ///Bits 12:13 - Port n.3 mode bits
            #[inline(always)]
            pub fn mode3(&self) -> MODE3_R {
                MODE3_R::new(((self.bits >> 12) & 3) as u8)
            }
            ///Bits 14:15 - Port n.3 configuration bits
            #[inline(always)]
            pub fn cnf3(&self) -> CNF3_R {
                CNF3_R::new(((self.bits >> 14) & 3) as u8)
            }
            ///Bits 16:17 - Port n.4 mode bits
            #[inline(always)]
            pub fn mode4(&self) -> MODE4_R {
                MODE4_R::new(((self.bits >> 16) & 3) as u8)
            }
            ///Bits 18:19 - Port n.4 configuration bits
            #[inline(always)]
            pub fn cnf4(&self) -> CNF4_R {
                CNF4_R::new(((self.bits >> 18) & 3) as u8)
            }
            ///Bits 20:21 - Port n.5 mode bits
            #[inline(always)]
            pub fn mode5(&self) -> MODE5_R {
                MODE5_R::new(((self.bits >> 20) & 3) as u8)
            }
            ///Bits 22:23 - Port n.5 configuration bits
            #[inline(always)]
            pub fn cnf5(&self) -> CNF5_R {
                CNF5_R::new(((self.bits >> 22) & 3) as u8)
            }
            ///Bits 24:25 - Port n.6 mode bits
            #[inline(always)]
            pub fn mode6(&self) -> MODE6_R {
                MODE6_R::new(((self.bits >> 24) & 3) as u8)
            }
            ///Bits 26:27 - Port n.6 configuration bits
            #[inline(always)]
            pub fn cnf6(&self) -> CNF6_R {
                CNF6_R::new(((self.bits >> 26) & 3) as u8)
            }
            ///Bits 28:29 - Port n.7 mode bits
            #[inline(always)]
            pub fn mode7(&self) -> MODE7_R {
                MODE7_R::new(((self.bits >> 28) & 3) as u8)
            }
            ///Bits 30:31 - Port n.7 configuration bits
            #[inline(always)]
            pub fn cnf7(&self) -> CNF7_R {
                CNF7_R::new(((self.bits >> 30) & 3) as u8)
            }
        }
        impl W {
            ///Bits 0:1 - Port n.0 mode bits
            #[inline(always)]
            #[must_use]
            pub fn mode0(&mut self) -> MODE0_W<CFGLR_SPEC> {
                MODE0_W::new(self, 0)
            }
            ///Bits 2:3 - Port n.0 configuration bits
            #[inline(always)]
            #[must_use]
            pub fn cnf0(&mut self) -> CNF0_W<CFGLR_SPEC> {
                CNF0_W::new(self, 2)
            }
            ///Bits 4:5 - Port n.1 mode bits
            #[inline(always)]
            #[must_use]
            pub fn mode1(&mut self) -> MODE1_W<CFGLR_SPEC> {
                MODE1_W::new(self, 4)
            }
            ///Bits 6:7 - Port n.1 configuration bits
            #[inline(always)]
            #[must_use]
            pub fn cnf1(&mut self) -> CNF1_W<CFGLR_SPEC> {
                CNF1_W::new(self, 6)
            }
            ///Bits 8:9 - Port n.2 mode bits
            #[inline(always)]
            #[must_use]
            pub fn mode2(&mut self) -> MODE2_W<CFGLR_SPEC> {
                MODE2_W::new(self, 8)
            }
            ///Bits 10:11 - Port n.2 configuration bits
            #[inline(always)]
            #[must_use]
            pub fn cnf2(&mut self) -> CNF2_W<CFGLR_SPEC> {
                CNF2_W::new(self, 10)
            }
            ///Bits 12:13 - Port n.3 mode bits
            #[inline(always)]
            #[must_use]
            pub fn mode3(&mut self) -> MODE3_W<CFGLR_SPEC> {
                MODE3_W::new(self, 12)
            }
            ///Bits 14:15 - Port n.3 configuration bits
            #[inline(always)]
            #[must_use]
            pub fn cnf3(&mut self) -> CNF3_W<CFGLR_SPEC> {
                CNF3_W::new(self, 14)
            }
            ///Bits 16:17 - Port n.4 mode bits
            #[inline(always)]
            #[must_use]
            pub fn mode4(&mut self) -> MODE4_W<CFGLR_SPEC> {
                MODE4_W::new(self, 16)
            }
            ///Bits 18:19 - Port n.4 configuration bits
            #[inline(always)]
            #[must_use]
            pub fn cnf4(&mut self) -> CNF4_W<CFGLR_SPEC> {
                CNF4_W::new(self, 18)
            }
            ///Bits 20:21 - Port n.5 mode bits
            #[inline(always)]
            #[must_use]
            pub fn mode5(&mut self) -> MODE5_W<CFGLR_SPEC> {
                MODE5_W::new(self, 20)
            }
            ///Bits 22:23 - Port n.5 configuration bits
            #[inline(always)]
            #[must_use]
            pub fn cnf5(&mut self) -> CNF5_W<CFGLR_SPEC> {
                CNF5_W::new(self, 22)
            }
            ///Bits 24:25 - Port n.6 mode bits
            #[inline(always)]
            #[must_use]
            pub fn mode6(&mut self) -> MODE6_W<CFGLR_SPEC> {
                MODE6_W::new(self, 24)
            }
            ///Bits 26:27 - Port n.6 configuration bits
            #[inline(always)]
            #[must_use]
            pub fn cnf6(&mut self) -> CNF6_W<CFGLR_SPEC> {
                CNF6_W::new(self, 26)
            }
            ///Bits 28:29 - Port n.7 mode bits
            #[inline(always)]
            #[must_use]
            pub fn mode7(&mut self) -> MODE7_W<CFGLR_SPEC> {
                MODE7_W::new(self, 28)
            }
            ///Bits 30:31 - Port n.7 configuration bits
            #[inline(always)]
            #[must_use]
            pub fn cnf7(&mut self) -> CNF7_W<CFGLR_SPEC> {
                CNF7_W::new(self, 30)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Port configuration register low(GPIOn_CFGLR)
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`cfglr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cfglr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct CFGLR_SPEC;
        impl crate::RegisterSpec for CFGLR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`cfglr::R`](R) reader structure
        impl crate::Readable for CFGLR_SPEC {}
        ///`write(|w| ..)` method takes [`cfglr::W`](W) writer structure
        impl crate::Writable for CFGLR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets CFGLR to value 0x4444_4444
        impl crate::Resettable for CFGLR_SPEC {
            const RESET_VALUE: u32 = 0x4444_4444;
        }
    }
    ///CFGHR (rw) register accessor: Port configuration register high (GPIOn_CFGHR)
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`cfghr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cfghr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@cfghr`]
    ///module
    pub type CFGHR = crate::Reg<cfghr::CFGHR_SPEC>;
    ///Port configuration register high (GPIOn_CFGHR)
    pub mod cfghr {
        ///Register `CFGHR` reader
        pub type R = crate::R<CFGHR_SPEC>;
        ///Register `CFGHR` writer
        pub type W = crate::W<CFGHR_SPEC>;
        ///Field `MODE8` reader - Port n.8 mode bits
        pub type MODE8_R = crate::FieldReader;
        ///Field `MODE8` writer - Port n.8 mode bits
        pub type MODE8_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `CNF8` reader - Port n.8 configuration bits
        pub type CNF8_R = crate::FieldReader;
        ///Field `CNF8` writer - Port n.8 configuration bits
        pub type CNF8_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `MODE9` reader - Port n.9 mode bits
        pub type MODE9_R = crate::FieldReader;
        ///Field `MODE9` writer - Port n.9 mode bits
        pub type MODE9_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `CNF9` reader - Port n.9 configuration bits
        pub type CNF9_R = crate::FieldReader;
        ///Field `CNF9` writer - Port n.9 configuration bits
        pub type CNF9_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `MODE10` reader - Port n.10 mode bits
        pub type MODE10_R = crate::FieldReader;
        ///Field `MODE10` writer - Port n.10 mode bits
        pub type MODE10_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `CNF10` reader - Port n.10 configuration bits
        pub type CNF10_R = crate::FieldReader;
        ///Field `CNF10` writer - Port n.10 configuration bits
        pub type CNF10_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `MODE11` reader - Port n.11 mode bits
        pub type MODE11_R = crate::FieldReader;
        ///Field `MODE11` writer - Port n.11 mode bits
        pub type MODE11_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `CNF11` reader - Port n.11 configuration bits
        pub type CNF11_R = crate::FieldReader;
        ///Field `CNF11` writer - Port n.11 configuration bits
        pub type CNF11_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `MODE12` reader - Port n.12 mode bits
        pub type MODE12_R = crate::FieldReader;
        ///Field `MODE12` writer - Port n.12 mode bits
        pub type MODE12_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `CNF12` reader - Port n.12 configuration bits
        pub type CNF12_R = crate::FieldReader;
        ///Field `CNF12` writer - Port n.12 configuration bits
        pub type CNF12_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `MODE13` reader - Port n.13 mode bits
        pub type MODE13_R = crate::FieldReader;
        ///Field `MODE13` writer - Port n.13 mode bits
        pub type MODE13_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `CNF13` reader - Port n.13 configuration bits
        pub type CNF13_R = crate::FieldReader;
        ///Field `CNF13` writer - Port n.13 configuration bits
        pub type CNF13_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `MODE14` reader - Port n.14 mode bits
        pub type MODE14_R = crate::FieldReader;
        ///Field `MODE14` writer - Port n.14 mode bits
        pub type MODE14_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `CNF14` reader - Port n.14 configuration bits
        pub type CNF14_R = crate::FieldReader;
        ///Field `CNF14` writer - Port n.14 configuration bits
        pub type CNF14_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `MODE15` reader - Port n.15 mode bits
        pub type MODE15_R = crate::FieldReader;
        ///Field `MODE15` writer - Port n.15 mode bits
        pub type MODE15_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `CNF15` reader - Port n.15 configuration bits
        pub type CNF15_R = crate::FieldReader;
        ///Field `CNF15` writer - Port n.15 configuration bits
        pub type CNF15_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        impl R {
            ///Bits 0:1 - Port n.8 mode bits
            #[inline(always)]
            pub fn mode8(&self) -> MODE8_R {
                MODE8_R::new((self.bits & 3) as u8)
            }
            ///Bits 2:3 - Port n.8 configuration bits
            #[inline(always)]
            pub fn cnf8(&self) -> CNF8_R {
                CNF8_R::new(((self.bits >> 2) & 3) as u8)
            }
            ///Bits 4:5 - Port n.9 mode bits
            #[inline(always)]
            pub fn mode9(&self) -> MODE9_R {
                MODE9_R::new(((self.bits >> 4) & 3) as u8)
            }
            ///Bits 6:7 - Port n.9 configuration bits
            #[inline(always)]
            pub fn cnf9(&self) -> CNF9_R {
                CNF9_R::new(((self.bits >> 6) & 3) as u8)
            }
            ///Bits 8:9 - Port n.10 mode bits
            #[inline(always)]
            pub fn mode10(&self) -> MODE10_R {
                MODE10_R::new(((self.bits >> 8) & 3) as u8)
            }
            ///Bits 10:11 - Port n.10 configuration bits
            #[inline(always)]
            pub fn cnf10(&self) -> CNF10_R {
                CNF10_R::new(((self.bits >> 10) & 3) as u8)
            }
            ///Bits 12:13 - Port n.11 mode bits
            #[inline(always)]
            pub fn mode11(&self) -> MODE11_R {
                MODE11_R::new(((self.bits >> 12) & 3) as u8)
            }
            ///Bits 14:15 - Port n.11 configuration bits
            #[inline(always)]
            pub fn cnf11(&self) -> CNF11_R {
                CNF11_R::new(((self.bits >> 14) & 3) as u8)
            }
            ///Bits 16:17 - Port n.12 mode bits
            #[inline(always)]
            pub fn mode12(&self) -> MODE12_R {
                MODE12_R::new(((self.bits >> 16) & 3) as u8)
            }
            ///Bits 18:19 - Port n.12 configuration bits
            #[inline(always)]
            pub fn cnf12(&self) -> CNF12_R {
                CNF12_R::new(((self.bits >> 18) & 3) as u8)
            }
            ///Bits 20:21 - Port n.13 mode bits
            #[inline(always)]
            pub fn mode13(&self) -> MODE13_R {
                MODE13_R::new(((self.bits >> 20) & 3) as u8)
            }
            ///Bits 22:23 - Port n.13 configuration bits
            #[inline(always)]
            pub fn cnf13(&self) -> CNF13_R {
                CNF13_R::new(((self.bits >> 22) & 3) as u8)
            }
            ///Bits 24:25 - Port n.14 mode bits
            #[inline(always)]
            pub fn mode14(&self) -> MODE14_R {
                MODE14_R::new(((self.bits >> 24) & 3) as u8)
            }
            ///Bits 26:27 - Port n.14 configuration bits
            #[inline(always)]
            pub fn cnf14(&self) -> CNF14_R {
                CNF14_R::new(((self.bits >> 26) & 3) as u8)
            }
            ///Bits 28:29 - Port n.15 mode bits
            #[inline(always)]
            pub fn mode15(&self) -> MODE15_R {
                MODE15_R::new(((self.bits >> 28) & 3) as u8)
            }
            ///Bits 30:31 - Port n.15 configuration bits
            #[inline(always)]
            pub fn cnf15(&self) -> CNF15_R {
                CNF15_R::new(((self.bits >> 30) & 3) as u8)
            }
        }
        impl W {
            ///Bits 0:1 - Port n.8 mode bits
            #[inline(always)]
            #[must_use]
            pub fn mode8(&mut self) -> MODE8_W<CFGHR_SPEC> {
                MODE8_W::new(self, 0)
            }
            ///Bits 2:3 - Port n.8 configuration bits
            #[inline(always)]
            #[must_use]
            pub fn cnf8(&mut self) -> CNF8_W<CFGHR_SPEC> {
                CNF8_W::new(self, 2)
            }
            ///Bits 4:5 - Port n.9 mode bits
            #[inline(always)]
            #[must_use]
            pub fn mode9(&mut self) -> MODE9_W<CFGHR_SPEC> {
                MODE9_W::new(self, 4)
            }
            ///Bits 6:7 - Port n.9 configuration bits
            #[inline(always)]
            #[must_use]
            pub fn cnf9(&mut self) -> CNF9_W<CFGHR_SPEC> {
                CNF9_W::new(self, 6)
            }
            ///Bits 8:9 - Port n.10 mode bits
            #[inline(always)]
            #[must_use]
            pub fn mode10(&mut self) -> MODE10_W<CFGHR_SPEC> {
                MODE10_W::new(self, 8)
            }
            ///Bits 10:11 - Port n.10 configuration bits
            #[inline(always)]
            #[must_use]
            pub fn cnf10(&mut self) -> CNF10_W<CFGHR_SPEC> {
                CNF10_W::new(self, 10)
            }
            ///Bits 12:13 - Port n.11 mode bits
            #[inline(always)]
            #[must_use]
            pub fn mode11(&mut self) -> MODE11_W<CFGHR_SPEC> {
                MODE11_W::new(self, 12)
            }
            ///Bits 14:15 - Port n.11 configuration bits
            #[inline(always)]
            #[must_use]
            pub fn cnf11(&mut self) -> CNF11_W<CFGHR_SPEC> {
                CNF11_W::new(self, 14)
            }
            ///Bits 16:17 - Port n.12 mode bits
            #[inline(always)]
            #[must_use]
            pub fn mode12(&mut self) -> MODE12_W<CFGHR_SPEC> {
                MODE12_W::new(self, 16)
            }
            ///Bits 18:19 - Port n.12 configuration bits
            #[inline(always)]
            #[must_use]
            pub fn cnf12(&mut self) -> CNF12_W<CFGHR_SPEC> {
                CNF12_W::new(self, 18)
            }
            ///Bits 20:21 - Port n.13 mode bits
            #[inline(always)]
            #[must_use]
            pub fn mode13(&mut self) -> MODE13_W<CFGHR_SPEC> {
                MODE13_W::new(self, 20)
            }
            ///Bits 22:23 - Port n.13 configuration bits
            #[inline(always)]
            #[must_use]
            pub fn cnf13(&mut self) -> CNF13_W<CFGHR_SPEC> {
                CNF13_W::new(self, 22)
            }
            ///Bits 24:25 - Port n.14 mode bits
            #[inline(always)]
            #[must_use]
            pub fn mode14(&mut self) -> MODE14_W<CFGHR_SPEC> {
                MODE14_W::new(self, 24)
            }
            ///Bits 26:27 - Port n.14 configuration bits
            #[inline(always)]
            #[must_use]
            pub fn cnf14(&mut self) -> CNF14_W<CFGHR_SPEC> {
                CNF14_W::new(self, 26)
            }
            ///Bits 28:29 - Port n.15 mode bits
            #[inline(always)]
            #[must_use]
            pub fn mode15(&mut self) -> MODE15_W<CFGHR_SPEC> {
                MODE15_W::new(self, 28)
            }
            ///Bits 30:31 - Port n.15 configuration bits
            #[inline(always)]
            #[must_use]
            pub fn cnf15(&mut self) -> CNF15_W<CFGHR_SPEC> {
                CNF15_W::new(self, 30)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Port configuration register high (GPIOn_CFGHR)
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`cfghr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cfghr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct CFGHR_SPEC;
        impl crate::RegisterSpec for CFGHR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`cfghr::R`](R) reader structure
        impl crate::Readable for CFGHR_SPEC {}
        ///`write(|w| ..)` method takes [`cfghr::W`](W) writer structure
        impl crate::Writable for CFGHR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets CFGHR to value 0x4444_4444
        impl crate::Resettable for CFGHR_SPEC {
            const RESET_VALUE: u32 = 0x4444_4444;
        }
    }
    ///INDR (r) register accessor: Port input data register (GPIOn_INDR)
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`indr::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@indr`]
    ///module
    pub type INDR = crate::Reg<indr::INDR_SPEC>;
    ///Port input data register (GPIOn_INDR)
    pub mod indr {
        ///Register `INDR` reader
        pub type R = crate::R<INDR_SPEC>;
        ///Field `IDR0` reader - Port input data
        pub type IDR0_R = crate::BitReader;
        ///Field `IDR1` reader - Port input data
        pub type IDR1_R = crate::BitReader;
        ///Field `IDR2` reader - Port input data
        pub type IDR2_R = crate::BitReader;
        ///Field `IDR3` reader - Port input data
        pub type IDR3_R = crate::BitReader;
        ///Field `IDR4` reader - Port input data
        pub type IDR4_R = crate::BitReader;
        ///Field `IDR5` reader - Port input data
        pub type IDR5_R = crate::BitReader;
        ///Field `IDR6` reader - Port input data
        pub type IDR6_R = crate::BitReader;
        ///Field `IDR7` reader - Port input data
        pub type IDR7_R = crate::BitReader;
        ///Field `IDR8` reader - Port input data
        pub type IDR8_R = crate::BitReader;
        ///Field `IDR9` reader - Port input data
        pub type IDR9_R = crate::BitReader;
        ///Field `IDR10` reader - Port input data
        pub type IDR10_R = crate::BitReader;
        ///Field `IDR11` reader - Port input data
        pub type IDR11_R = crate::BitReader;
        ///Field `IDR12` reader - Port input data
        pub type IDR12_R = crate::BitReader;
        ///Field `IDR13` reader - Port input data
        pub type IDR13_R = crate::BitReader;
        ///Field `IDR14` reader - Port input data
        pub type IDR14_R = crate::BitReader;
        ///Field `IDR15` reader - Port input data
        pub type IDR15_R = crate::BitReader;
        impl R {
            ///Bit 0 - Port input data
            #[inline(always)]
            pub fn idr0(&self) -> IDR0_R {
                IDR0_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Port input data
            #[inline(always)]
            pub fn idr1(&self) -> IDR1_R {
                IDR1_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - Port input data
            #[inline(always)]
            pub fn idr2(&self) -> IDR2_R {
                IDR2_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - Port input data
            #[inline(always)]
            pub fn idr3(&self) -> IDR3_R {
                IDR3_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - Port input data
            #[inline(always)]
            pub fn idr4(&self) -> IDR4_R {
                IDR4_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - Port input data
            #[inline(always)]
            pub fn idr5(&self) -> IDR5_R {
                IDR5_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - Port input data
            #[inline(always)]
            pub fn idr6(&self) -> IDR6_R {
                IDR6_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - Port input data
            #[inline(always)]
            pub fn idr7(&self) -> IDR7_R {
                IDR7_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bit 8 - Port input data
            #[inline(always)]
            pub fn idr8(&self) -> IDR8_R {
                IDR8_R::new(((self.bits >> 8) & 1) != 0)
            }
            ///Bit 9 - Port input data
            #[inline(always)]
            pub fn idr9(&self) -> IDR9_R {
                IDR9_R::new(((self.bits >> 9) & 1) != 0)
            }
            ///Bit 10 - Port input data
            #[inline(always)]
            pub fn idr10(&self) -> IDR10_R {
                IDR10_R::new(((self.bits >> 10) & 1) != 0)
            }
            ///Bit 11 - Port input data
            #[inline(always)]
            pub fn idr11(&self) -> IDR11_R {
                IDR11_R::new(((self.bits >> 11) & 1) != 0)
            }
            ///Bit 12 - Port input data
            #[inline(always)]
            pub fn idr12(&self) -> IDR12_R {
                IDR12_R::new(((self.bits >> 12) & 1) != 0)
            }
            ///Bit 13 - Port input data
            #[inline(always)]
            pub fn idr13(&self) -> IDR13_R {
                IDR13_R::new(((self.bits >> 13) & 1) != 0)
            }
            ///Bit 14 - Port input data
            #[inline(always)]
            pub fn idr14(&self) -> IDR14_R {
                IDR14_R::new(((self.bits >> 14) & 1) != 0)
            }
            ///Bit 15 - Port input data
            #[inline(always)]
            pub fn idr15(&self) -> IDR15_R {
                IDR15_R::new(((self.bits >> 15) & 1) != 0)
            }
        }
        ///Port input data register (GPIOn_INDR)
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`indr::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct INDR_SPEC;
        impl crate::RegisterSpec for INDR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`indr::R`](R) reader structure
        impl crate::Readable for INDR_SPEC {}
        ///`reset()` method sets INDR to value 0
        impl crate::Resettable for INDR_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///OUTDR (rw) register accessor: Port output data register (GPIOn_OUTDR)
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`outdr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`outdr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@outdr`]
    ///module
    pub type OUTDR = crate::Reg<outdr::OUTDR_SPEC>;
    ///Port output data register (GPIOn_OUTDR)
    pub mod outdr {
        ///Register `OUTDR` reader
        pub type R = crate::R<OUTDR_SPEC>;
        ///Register `OUTDR` writer
        pub type W = crate::W<OUTDR_SPEC>;
        ///Field `ODR0` reader - Port output data
        pub type ODR0_R = crate::BitReader;
        ///Field `ODR0` writer - Port output data
        pub type ODR0_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `ODR1` reader - Port output data
        pub type ODR1_R = crate::BitReader;
        ///Field `ODR1` writer - Port output data
        pub type ODR1_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `ODR2` reader - Port output data
        pub type ODR2_R = crate::BitReader;
        ///Field `ODR2` writer - Port output data
        pub type ODR2_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `ODR3` reader - Port output data
        pub type ODR3_R = crate::BitReader;
        ///Field `ODR3` writer - Port output data
        pub type ODR3_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `ODR4` reader - Port output data
        pub type ODR4_R = crate::BitReader;
        ///Field `ODR4` writer - Port output data
        pub type ODR4_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `ODR5` reader - Port output data
        pub type ODR5_R = crate::BitReader;
        ///Field `ODR5` writer - Port output data
        pub type ODR5_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `ODR6` reader - Port output data
        pub type ODR6_R = crate::BitReader;
        ///Field `ODR6` writer - Port output data
        pub type ODR6_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `ODR7` reader - Port output data
        pub type ODR7_R = crate::BitReader;
        ///Field `ODR7` writer - Port output data
        pub type ODR7_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `ODR8` reader - Port output data
        pub type ODR8_R = crate::BitReader;
        ///Field `ODR8` writer - Port output data
        pub type ODR8_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `ODR9` reader - Port output data
        pub type ODR9_R = crate::BitReader;
        ///Field `ODR9` writer - Port output data
        pub type ODR9_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `ODR10` reader - Port output data
        pub type ODR10_R = crate::BitReader;
        ///Field `ODR10` writer - Port output data
        pub type ODR10_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `ODR11` reader - Port output data
        pub type ODR11_R = crate::BitReader;
        ///Field `ODR11` writer - Port output data
        pub type ODR11_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `ODR12` reader - Port output data
        pub type ODR12_R = crate::BitReader;
        ///Field `ODR12` writer - Port output data
        pub type ODR12_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `ODR13` reader - Port output data
        pub type ODR13_R = crate::BitReader;
        ///Field `ODR13` writer - Port output data
        pub type ODR13_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `ODR14` reader - Port output data
        pub type ODR14_R = crate::BitReader;
        ///Field `ODR14` writer - Port output data
        pub type ODR14_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `ODR15` reader - Port output data
        pub type ODR15_R = crate::BitReader;
        ///Field `ODR15` writer - Port output data
        pub type ODR15_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - Port output data
            #[inline(always)]
            pub fn odr0(&self) -> ODR0_R {
                ODR0_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Port output data
            #[inline(always)]
            pub fn odr1(&self) -> ODR1_R {
                ODR1_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - Port output data
            #[inline(always)]
            pub fn odr2(&self) -> ODR2_R {
                ODR2_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - Port output data
            #[inline(always)]
            pub fn odr3(&self) -> ODR3_R {
                ODR3_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - Port output data
            #[inline(always)]
            pub fn odr4(&self) -> ODR4_R {
                ODR4_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - Port output data
            #[inline(always)]
            pub fn odr5(&self) -> ODR5_R {
                ODR5_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - Port output data
            #[inline(always)]
            pub fn odr6(&self) -> ODR6_R {
                ODR6_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - Port output data
            #[inline(always)]
            pub fn odr7(&self) -> ODR7_R {
                ODR7_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bit 8 - Port output data
            #[inline(always)]
            pub fn odr8(&self) -> ODR8_R {
                ODR8_R::new(((self.bits >> 8) & 1) != 0)
            }
            ///Bit 9 - Port output data
            #[inline(always)]
            pub fn odr9(&self) -> ODR9_R {
                ODR9_R::new(((self.bits >> 9) & 1) != 0)
            }
            ///Bit 10 - Port output data
            #[inline(always)]
            pub fn odr10(&self) -> ODR10_R {
                ODR10_R::new(((self.bits >> 10) & 1) != 0)
            }
            ///Bit 11 - Port output data
            #[inline(always)]
            pub fn odr11(&self) -> ODR11_R {
                ODR11_R::new(((self.bits >> 11) & 1) != 0)
            }
            ///Bit 12 - Port output data
            #[inline(always)]
            pub fn odr12(&self) -> ODR12_R {
                ODR12_R::new(((self.bits >> 12) & 1) != 0)
            }
            ///Bit 13 - Port output data
            #[inline(always)]
            pub fn odr13(&self) -> ODR13_R {
                ODR13_R::new(((self.bits >> 13) & 1) != 0)
            }
            ///Bit 14 - Port output data
            #[inline(always)]
            pub fn odr14(&self) -> ODR14_R {
                ODR14_R::new(((self.bits >> 14) & 1) != 0)
            }
            ///Bit 15 - Port output data
            #[inline(always)]
            pub fn odr15(&self) -> ODR15_R {
                ODR15_R::new(((self.bits >> 15) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - Port output data
            #[inline(always)]
            #[must_use]
            pub fn odr0(&mut self) -> ODR0_W<OUTDR_SPEC> {
                ODR0_W::new(self, 0)
            }
            ///Bit 1 - Port output data
            #[inline(always)]
            #[must_use]
            pub fn odr1(&mut self) -> ODR1_W<OUTDR_SPEC> {
                ODR1_W::new(self, 1)
            }
            ///Bit 2 - Port output data
            #[inline(always)]
            #[must_use]
            pub fn odr2(&mut self) -> ODR2_W<OUTDR_SPEC> {
                ODR2_W::new(self, 2)
            }
            ///Bit 3 - Port output data
            #[inline(always)]
            #[must_use]
            pub fn odr3(&mut self) -> ODR3_W<OUTDR_SPEC> {
                ODR3_W::new(self, 3)
            }
            ///Bit 4 - Port output data
            #[inline(always)]
            #[must_use]
            pub fn odr4(&mut self) -> ODR4_W<OUTDR_SPEC> {
                ODR4_W::new(self, 4)
            }
            ///Bit 5 - Port output data
            #[inline(always)]
            #[must_use]
            pub fn odr5(&mut self) -> ODR5_W<OUTDR_SPEC> {
                ODR5_W::new(self, 5)
            }
            ///Bit 6 - Port output data
            #[inline(always)]
            #[must_use]
            pub fn odr6(&mut self) -> ODR6_W<OUTDR_SPEC> {
                ODR6_W::new(self, 6)
            }
            ///Bit 7 - Port output data
            #[inline(always)]
            #[must_use]
            pub fn odr7(&mut self) -> ODR7_W<OUTDR_SPEC> {
                ODR7_W::new(self, 7)
            }
            ///Bit 8 - Port output data
            #[inline(always)]
            #[must_use]
            pub fn odr8(&mut self) -> ODR8_W<OUTDR_SPEC> {
                ODR8_W::new(self, 8)
            }
            ///Bit 9 - Port output data
            #[inline(always)]
            #[must_use]
            pub fn odr9(&mut self) -> ODR9_W<OUTDR_SPEC> {
                ODR9_W::new(self, 9)
            }
            ///Bit 10 - Port output data
            #[inline(always)]
            #[must_use]
            pub fn odr10(&mut self) -> ODR10_W<OUTDR_SPEC> {
                ODR10_W::new(self, 10)
            }
            ///Bit 11 - Port output data
            #[inline(always)]
            #[must_use]
            pub fn odr11(&mut self) -> ODR11_W<OUTDR_SPEC> {
                ODR11_W::new(self, 11)
            }
            ///Bit 12 - Port output data
            #[inline(always)]
            #[must_use]
            pub fn odr12(&mut self) -> ODR12_W<OUTDR_SPEC> {
                ODR12_W::new(self, 12)
            }
            ///Bit 13 - Port output data
            #[inline(always)]
            #[must_use]
            pub fn odr13(&mut self) -> ODR13_W<OUTDR_SPEC> {
                ODR13_W::new(self, 13)
            }
            ///Bit 14 - Port output data
            #[inline(always)]
            #[must_use]
            pub fn odr14(&mut self) -> ODR14_W<OUTDR_SPEC> {
                ODR14_W::new(self, 14)
            }
            ///Bit 15 - Port output data
            #[inline(always)]
            #[must_use]
            pub fn odr15(&mut self) -> ODR15_W<OUTDR_SPEC> {
                ODR15_W::new(self, 15)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Port output data register (GPIOn_OUTDR)
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`outdr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`outdr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct OUTDR_SPEC;
        impl crate::RegisterSpec for OUTDR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`outdr::R`](R) reader structure
        impl crate::Readable for OUTDR_SPEC {}
        ///`write(|w| ..)` method takes [`outdr::W`](W) writer structure
        impl crate::Writable for OUTDR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets OUTDR to value 0
        impl crate::Resettable for OUTDR_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///BSHR (w) register accessor: Port bit set/reset register (GPIOn_BSHR)
    ///
    ///You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`bshr::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@bshr`]
    ///module
    pub type BSHR = crate::Reg<bshr::BSHR_SPEC>;
    ///Port bit set/reset register (GPIOn_BSHR)
    pub mod bshr {
        ///Register `BSHR` writer
        pub type W = crate::W<BSHR_SPEC>;
        ///Field `BS0` writer - Set bit 0
        pub type BS0_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `BS1` writer - Set bit 1
        pub type BS1_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `BS2` writer - Set bit 1
        pub type BS2_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `BS3` writer - Set bit 3
        pub type BS3_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `BS4` writer - Set bit 4
        pub type BS4_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `BS5` writer - Set bit 5
        pub type BS5_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `BS6` writer - Set bit 6
        pub type BS6_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `BS7` writer - Set bit 7
        pub type BS7_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `BS8` writer - Set bit 8
        pub type BS8_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `BS9` writer - Set bit 9
        pub type BS9_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `BS10` writer - Set bit 10
        pub type BS10_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `BS11` writer - Set bit 11
        pub type BS11_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `BS12` writer - Set bit 12
        pub type BS12_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `BS13` writer - Set bit 13
        pub type BS13_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `BS14` writer - Set bit 14
        pub type BS14_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `BS15` writer - Set bit 15
        pub type BS15_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `BR0` writer - Reset bit 0
        pub type BR0_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `BR1` writer - Reset bit 1
        pub type BR1_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `BR2` writer - Reset bit 2
        pub type BR2_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `BR3` writer - Reset bit 3
        pub type BR3_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `BR4` writer - Reset bit 4
        pub type BR4_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `BR5` writer - Reset bit 5
        pub type BR5_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `BR6` writer - Reset bit 6
        pub type BR6_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `BR7` writer - Reset bit 7
        pub type BR7_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `BR8` writer - Reset bit 8
        pub type BR8_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `BR9` writer - Reset bit 9
        pub type BR9_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `BR10` writer - Reset bit 10
        pub type BR10_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `BR11` writer - Reset bit 11
        pub type BR11_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `BR12` writer - Reset bit 12
        pub type BR12_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `BR13` writer - Reset bit 13
        pub type BR13_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `BR14` writer - Reset bit 14
        pub type BR14_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `BR15` writer - Reset bit 15
        pub type BR15_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl W {
            ///Bit 0 - Set bit 0
            #[inline(always)]
            #[must_use]
            pub fn bs0(&mut self) -> BS0_W<BSHR_SPEC> {
                BS0_W::new(self, 0)
            }
            ///Bit 1 - Set bit 1
            #[inline(always)]
            #[must_use]
            pub fn bs1(&mut self) -> BS1_W<BSHR_SPEC> {
                BS1_W::new(self, 1)
            }
            ///Bit 2 - Set bit 1
            #[inline(always)]
            #[must_use]
            pub fn bs2(&mut self) -> BS2_W<BSHR_SPEC> {
                BS2_W::new(self, 2)
            }
            ///Bit 3 - Set bit 3
            #[inline(always)]
            #[must_use]
            pub fn bs3(&mut self) -> BS3_W<BSHR_SPEC> {
                BS3_W::new(self, 3)
            }
            ///Bit 4 - Set bit 4
            #[inline(always)]
            #[must_use]
            pub fn bs4(&mut self) -> BS4_W<BSHR_SPEC> {
                BS4_W::new(self, 4)
            }
            ///Bit 5 - Set bit 5
            #[inline(always)]
            #[must_use]
            pub fn bs5(&mut self) -> BS5_W<BSHR_SPEC> {
                BS5_W::new(self, 5)
            }
            ///Bit 6 - Set bit 6
            #[inline(always)]
            #[must_use]
            pub fn bs6(&mut self) -> BS6_W<BSHR_SPEC> {
                BS6_W::new(self, 6)
            }
            ///Bit 7 - Set bit 7
            #[inline(always)]
            #[must_use]
            pub fn bs7(&mut self) -> BS7_W<BSHR_SPEC> {
                BS7_W::new(self, 7)
            }
            ///Bit 8 - Set bit 8
            #[inline(always)]
            #[must_use]
            pub fn bs8(&mut self) -> BS8_W<BSHR_SPEC> {
                BS8_W::new(self, 8)
            }
            ///Bit 9 - Set bit 9
            #[inline(always)]
            #[must_use]
            pub fn bs9(&mut self) -> BS9_W<BSHR_SPEC> {
                BS9_W::new(self, 9)
            }
            ///Bit 10 - Set bit 10
            #[inline(always)]
            #[must_use]
            pub fn bs10(&mut self) -> BS10_W<BSHR_SPEC> {
                BS10_W::new(self, 10)
            }
            ///Bit 11 - Set bit 11
            #[inline(always)]
            #[must_use]
            pub fn bs11(&mut self) -> BS11_W<BSHR_SPEC> {
                BS11_W::new(self, 11)
            }
            ///Bit 12 - Set bit 12
            #[inline(always)]
            #[must_use]
            pub fn bs12(&mut self) -> BS12_W<BSHR_SPEC> {
                BS12_W::new(self, 12)
            }
            ///Bit 13 - Set bit 13
            #[inline(always)]
            #[must_use]
            pub fn bs13(&mut self) -> BS13_W<BSHR_SPEC> {
                BS13_W::new(self, 13)
            }
            ///Bit 14 - Set bit 14
            #[inline(always)]
            #[must_use]
            pub fn bs14(&mut self) -> BS14_W<BSHR_SPEC> {
                BS14_W::new(self, 14)
            }
            ///Bit 15 - Set bit 15
            #[inline(always)]
            #[must_use]
            pub fn bs15(&mut self) -> BS15_W<BSHR_SPEC> {
                BS15_W::new(self, 15)
            }
            ///Bit 16 - Reset bit 0
            #[inline(always)]
            #[must_use]
            pub fn br0(&mut self) -> BR0_W<BSHR_SPEC> {
                BR0_W::new(self, 16)
            }
            ///Bit 17 - Reset bit 1
            #[inline(always)]
            #[must_use]
            pub fn br1(&mut self) -> BR1_W<BSHR_SPEC> {
                BR1_W::new(self, 17)
            }
            ///Bit 18 - Reset bit 2
            #[inline(always)]
            #[must_use]
            pub fn br2(&mut self) -> BR2_W<BSHR_SPEC> {
                BR2_W::new(self, 18)
            }
            ///Bit 19 - Reset bit 3
            #[inline(always)]
            #[must_use]
            pub fn br3(&mut self) -> BR3_W<BSHR_SPEC> {
                BR3_W::new(self, 19)
            }
            ///Bit 20 - Reset bit 4
            #[inline(always)]
            #[must_use]
            pub fn br4(&mut self) -> BR4_W<BSHR_SPEC> {
                BR4_W::new(self, 20)
            }
            ///Bit 21 - Reset bit 5
            #[inline(always)]
            #[must_use]
            pub fn br5(&mut self) -> BR5_W<BSHR_SPEC> {
                BR5_W::new(self, 21)
            }
            ///Bit 22 - Reset bit 6
            #[inline(always)]
            #[must_use]
            pub fn br6(&mut self) -> BR6_W<BSHR_SPEC> {
                BR6_W::new(self, 22)
            }
            ///Bit 23 - Reset bit 7
            #[inline(always)]
            #[must_use]
            pub fn br7(&mut self) -> BR7_W<BSHR_SPEC> {
                BR7_W::new(self, 23)
            }
            ///Bit 24 - Reset bit 8
            #[inline(always)]
            #[must_use]
            pub fn br8(&mut self) -> BR8_W<BSHR_SPEC> {
                BR8_W::new(self, 24)
            }
            ///Bit 25 - Reset bit 9
            #[inline(always)]
            #[must_use]
            pub fn br9(&mut self) -> BR9_W<BSHR_SPEC> {
                BR9_W::new(self, 25)
            }
            ///Bit 26 - Reset bit 10
            #[inline(always)]
            #[must_use]
            pub fn br10(&mut self) -> BR10_W<BSHR_SPEC> {
                BR10_W::new(self, 26)
            }
            ///Bit 27 - Reset bit 11
            #[inline(always)]
            #[must_use]
            pub fn br11(&mut self) -> BR11_W<BSHR_SPEC> {
                BR11_W::new(self, 27)
            }
            ///Bit 28 - Reset bit 12
            #[inline(always)]
            #[must_use]
            pub fn br12(&mut self) -> BR12_W<BSHR_SPEC> {
                BR12_W::new(self, 28)
            }
            ///Bit 29 - Reset bit 13
            #[inline(always)]
            #[must_use]
            pub fn br13(&mut self) -> BR13_W<BSHR_SPEC> {
                BR13_W::new(self, 29)
            }
            ///Bit 30 - Reset bit 14
            #[inline(always)]
            #[must_use]
            pub fn br14(&mut self) -> BR14_W<BSHR_SPEC> {
                BR14_W::new(self, 30)
            }
            ///Bit 31 - Reset bit 15
            #[inline(always)]
            #[must_use]
            pub fn br15(&mut self) -> BR15_W<BSHR_SPEC> {
                BR15_W::new(self, 31)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Port bit set/reset register (GPIOn_BSHR)
        ///
        ///You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`bshr::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct BSHR_SPEC;
        impl crate::RegisterSpec for BSHR_SPEC {
            type Ux = u32;
        }
        ///`write(|w| ..)` method takes [`bshr::W`](W) writer structure
        impl crate::Writable for BSHR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets BSHR to value 0
        impl crate::Resettable for BSHR_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///BCR (w) register accessor: Port bit reset register (GPIOn_BCR)
    ///
    ///You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`bcr::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@bcr`]
    ///module
    pub type BCR = crate::Reg<bcr::BCR_SPEC>;
    ///Port bit reset register (GPIOn_BCR)
    pub mod bcr {
        ///Register `BCR` writer
        pub type W = crate::W<BCR_SPEC>;
        ///Field `BR0` writer - Reset bit 0
        pub type BR0_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `BR1` writer - Reset bit 1
        pub type BR1_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `BR2` writer - Reset bit 1
        pub type BR2_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `BR3` writer - Reset bit 3
        pub type BR3_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `BR4` writer - Reset bit 4
        pub type BR4_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `BR5` writer - Reset bit 5
        pub type BR5_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `BR6` writer - Reset bit 6
        pub type BR6_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `BR7` writer - Reset bit 7
        pub type BR7_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `BR8` writer - Reset bit 8
        pub type BR8_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `BR9` writer - Reset bit 9
        pub type BR9_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `BR10` writer - Reset bit 10
        pub type BR10_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `BR11` writer - Reset bit 11
        pub type BR11_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `BR12` writer - Reset bit 12
        pub type BR12_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `BR13` writer - Reset bit 13
        pub type BR13_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `BR14` writer - Reset bit 14
        pub type BR14_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `BR15` writer - Reset bit 15
        pub type BR15_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl W {
            ///Bit 0 - Reset bit 0
            #[inline(always)]
            #[must_use]
            pub fn br0(&mut self) -> BR0_W<BCR_SPEC> {
                BR0_W::new(self, 0)
            }
            ///Bit 1 - Reset bit 1
            #[inline(always)]
            #[must_use]
            pub fn br1(&mut self) -> BR1_W<BCR_SPEC> {
                BR1_W::new(self, 1)
            }
            ///Bit 2 - Reset bit 1
            #[inline(always)]
            #[must_use]
            pub fn br2(&mut self) -> BR2_W<BCR_SPEC> {
                BR2_W::new(self, 2)
            }
            ///Bit 3 - Reset bit 3
            #[inline(always)]
            #[must_use]
            pub fn br3(&mut self) -> BR3_W<BCR_SPEC> {
                BR3_W::new(self, 3)
            }
            ///Bit 4 - Reset bit 4
            #[inline(always)]
            #[must_use]
            pub fn br4(&mut self) -> BR4_W<BCR_SPEC> {
                BR4_W::new(self, 4)
            }
            ///Bit 5 - Reset bit 5
            #[inline(always)]
            #[must_use]
            pub fn br5(&mut self) -> BR5_W<BCR_SPEC> {
                BR5_W::new(self, 5)
            }
            ///Bit 6 - Reset bit 6
            #[inline(always)]
            #[must_use]
            pub fn br6(&mut self) -> BR6_W<BCR_SPEC> {
                BR6_W::new(self, 6)
            }
            ///Bit 7 - Reset bit 7
            #[inline(always)]
            #[must_use]
            pub fn br7(&mut self) -> BR7_W<BCR_SPEC> {
                BR7_W::new(self, 7)
            }
            ///Bit 8 - Reset bit 8
            #[inline(always)]
            #[must_use]
            pub fn br8(&mut self) -> BR8_W<BCR_SPEC> {
                BR8_W::new(self, 8)
            }
            ///Bit 9 - Reset bit 9
            #[inline(always)]
            #[must_use]
            pub fn br9(&mut self) -> BR9_W<BCR_SPEC> {
                BR9_W::new(self, 9)
            }
            ///Bit 10 - Reset bit 10
            #[inline(always)]
            #[must_use]
            pub fn br10(&mut self) -> BR10_W<BCR_SPEC> {
                BR10_W::new(self, 10)
            }
            ///Bit 11 - Reset bit 11
            #[inline(always)]
            #[must_use]
            pub fn br11(&mut self) -> BR11_W<BCR_SPEC> {
                BR11_W::new(self, 11)
            }
            ///Bit 12 - Reset bit 12
            #[inline(always)]
            #[must_use]
            pub fn br12(&mut self) -> BR12_W<BCR_SPEC> {
                BR12_W::new(self, 12)
            }
            ///Bit 13 - Reset bit 13
            #[inline(always)]
            #[must_use]
            pub fn br13(&mut self) -> BR13_W<BCR_SPEC> {
                BR13_W::new(self, 13)
            }
            ///Bit 14 - Reset bit 14
            #[inline(always)]
            #[must_use]
            pub fn br14(&mut self) -> BR14_W<BCR_SPEC> {
                BR14_W::new(self, 14)
            }
            ///Bit 15 - Reset bit 15
            #[inline(always)]
            #[must_use]
            pub fn br15(&mut self) -> BR15_W<BCR_SPEC> {
                BR15_W::new(self, 15)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Port bit reset register (GPIOn_BCR)
        ///
        ///You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`bcr::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct BCR_SPEC;
        impl crate::RegisterSpec for BCR_SPEC {
            type Ux = u32;
        }
        ///`write(|w| ..)` method takes [`bcr::W`](W) writer structure
        impl crate::Writable for BCR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets BCR to value 0
        impl crate::Resettable for BCR_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///LCKR (rw) register accessor: Port configuration lock register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`lckr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`lckr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@lckr`]
    ///module
    pub type LCKR = crate::Reg<lckr::LCKR_SPEC>;
    ///Port configuration lock register
    pub mod lckr {
        ///Register `LCKR` reader
        pub type R = crate::R<LCKR_SPEC>;
        ///Register `LCKR` writer
        pub type W = crate::W<LCKR_SPEC>;
        ///Field `LCK0` reader - Port A Lock bit 0
        pub type LCK0_R = crate::BitReader;
        ///Field `LCK0` writer - Port A Lock bit 0
        pub type LCK0_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `LCK1` reader - Port A Lock bit 1
        pub type LCK1_R = crate::BitReader;
        ///Field `LCK1` writer - Port A Lock bit 1
        pub type LCK1_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `LCK2` reader - Port A Lock bit 2
        pub type LCK2_R = crate::BitReader;
        ///Field `LCK2` writer - Port A Lock bit 2
        pub type LCK2_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `LCK3` reader - Port A Lock bit 3
        pub type LCK3_R = crate::BitReader;
        ///Field `LCK3` writer - Port A Lock bit 3
        pub type LCK3_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `LCK4` reader - Port A Lock bit 4
        pub type LCK4_R = crate::BitReader;
        ///Field `LCK4` writer - Port A Lock bit 4
        pub type LCK4_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `LCK5` reader - Port A Lock bit 5
        pub type LCK5_R = crate::BitReader;
        ///Field `LCK5` writer - Port A Lock bit 5
        pub type LCK5_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `LCK6` reader - Port A Lock bit 6
        pub type LCK6_R = crate::BitReader;
        ///Field `LCK6` writer - Port A Lock bit 6
        pub type LCK6_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `LCK7` reader - Port A Lock bit 7
        pub type LCK7_R = crate::BitReader;
        ///Field `LCK7` writer - Port A Lock bit 7
        pub type LCK7_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `LCK8` reader - Port A Lock bit 8
        pub type LCK8_R = crate::BitReader;
        ///Field `LCK8` writer - Port A Lock bit 8
        pub type LCK8_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `LCK9` reader - Port A Lock bit 9
        pub type LCK9_R = crate::BitReader;
        ///Field `LCK9` writer - Port A Lock bit 9
        pub type LCK9_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `LCK10` reader - Port A Lock bit 10
        pub type LCK10_R = crate::BitReader;
        ///Field `LCK10` writer - Port A Lock bit 10
        pub type LCK10_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `LCK11` reader - Port A Lock bit 11
        pub type LCK11_R = crate::BitReader;
        ///Field `LCK11` writer - Port A Lock bit 11
        pub type LCK11_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `LCK12` reader - Port A Lock bit 12
        pub type LCK12_R = crate::BitReader;
        ///Field `LCK12` writer - Port A Lock bit 12
        pub type LCK12_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `LCK13` reader - Port A Lock bit 13
        pub type LCK13_R = crate::BitReader;
        ///Field `LCK13` writer - Port A Lock bit 13
        pub type LCK13_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `LCK14` reader - Port A Lock bit 14
        pub type LCK14_R = crate::BitReader;
        ///Field `LCK14` writer - Port A Lock bit 14
        pub type LCK14_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `LCK15` reader - Port A Lock bit 15
        pub type LCK15_R = crate::BitReader;
        ///Field `LCK15` writer - Port A Lock bit 15
        pub type LCK15_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `LCKK` reader - Lock key
        pub type LCKK_R = crate::BitReader;
        ///Field `LCKK` writer - Lock key
        pub type LCKK_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - Port A Lock bit 0
            #[inline(always)]
            pub fn lck0(&self) -> LCK0_R {
                LCK0_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Port A Lock bit 1
            #[inline(always)]
            pub fn lck1(&self) -> LCK1_R {
                LCK1_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - Port A Lock bit 2
            #[inline(always)]
            pub fn lck2(&self) -> LCK2_R {
                LCK2_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - Port A Lock bit 3
            #[inline(always)]
            pub fn lck3(&self) -> LCK3_R {
                LCK3_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - Port A Lock bit 4
            #[inline(always)]
            pub fn lck4(&self) -> LCK4_R {
                LCK4_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - Port A Lock bit 5
            #[inline(always)]
            pub fn lck5(&self) -> LCK5_R {
                LCK5_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - Port A Lock bit 6
            #[inline(always)]
            pub fn lck6(&self) -> LCK6_R {
                LCK6_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - Port A Lock bit 7
            #[inline(always)]
            pub fn lck7(&self) -> LCK7_R {
                LCK7_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bit 8 - Port A Lock bit 8
            #[inline(always)]
            pub fn lck8(&self) -> LCK8_R {
                LCK8_R::new(((self.bits >> 8) & 1) != 0)
            }
            ///Bit 9 - Port A Lock bit 9
            #[inline(always)]
            pub fn lck9(&self) -> LCK9_R {
                LCK9_R::new(((self.bits >> 9) & 1) != 0)
            }
            ///Bit 10 - Port A Lock bit 10
            #[inline(always)]
            pub fn lck10(&self) -> LCK10_R {
                LCK10_R::new(((self.bits >> 10) & 1) != 0)
            }
            ///Bit 11 - Port A Lock bit 11
            #[inline(always)]
            pub fn lck11(&self) -> LCK11_R {
                LCK11_R::new(((self.bits >> 11) & 1) != 0)
            }
            ///Bit 12 - Port A Lock bit 12
            #[inline(always)]
            pub fn lck12(&self) -> LCK12_R {
                LCK12_R::new(((self.bits >> 12) & 1) != 0)
            }
            ///Bit 13 - Port A Lock bit 13
            #[inline(always)]
            pub fn lck13(&self) -> LCK13_R {
                LCK13_R::new(((self.bits >> 13) & 1) != 0)
            }
            ///Bit 14 - Port A Lock bit 14
            #[inline(always)]
            pub fn lck14(&self) -> LCK14_R {
                LCK14_R::new(((self.bits >> 14) & 1) != 0)
            }
            ///Bit 15 - Port A Lock bit 15
            #[inline(always)]
            pub fn lck15(&self) -> LCK15_R {
                LCK15_R::new(((self.bits >> 15) & 1) != 0)
            }
            ///Bit 16 - Lock key
            #[inline(always)]
            pub fn lckk(&self) -> LCKK_R {
                LCKK_R::new(((self.bits >> 16) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - Port A Lock bit 0
            #[inline(always)]
            #[must_use]
            pub fn lck0(&mut self) -> LCK0_W<LCKR_SPEC> {
                LCK0_W::new(self, 0)
            }
            ///Bit 1 - Port A Lock bit 1
            #[inline(always)]
            #[must_use]
            pub fn lck1(&mut self) -> LCK1_W<LCKR_SPEC> {
                LCK1_W::new(self, 1)
            }
            ///Bit 2 - Port A Lock bit 2
            #[inline(always)]
            #[must_use]
            pub fn lck2(&mut self) -> LCK2_W<LCKR_SPEC> {
                LCK2_W::new(self, 2)
            }
            ///Bit 3 - Port A Lock bit 3
            #[inline(always)]
            #[must_use]
            pub fn lck3(&mut self) -> LCK3_W<LCKR_SPEC> {
                LCK3_W::new(self, 3)
            }
            ///Bit 4 - Port A Lock bit 4
            #[inline(always)]
            #[must_use]
            pub fn lck4(&mut self) -> LCK4_W<LCKR_SPEC> {
                LCK4_W::new(self, 4)
            }
            ///Bit 5 - Port A Lock bit 5
            #[inline(always)]
            #[must_use]
            pub fn lck5(&mut self) -> LCK5_W<LCKR_SPEC> {
                LCK5_W::new(self, 5)
            }
            ///Bit 6 - Port A Lock bit 6
            #[inline(always)]
            #[must_use]
            pub fn lck6(&mut self) -> LCK6_W<LCKR_SPEC> {
                LCK6_W::new(self, 6)
            }
            ///Bit 7 - Port A Lock bit 7
            #[inline(always)]
            #[must_use]
            pub fn lck7(&mut self) -> LCK7_W<LCKR_SPEC> {
                LCK7_W::new(self, 7)
            }
            ///Bit 8 - Port A Lock bit 8
            #[inline(always)]
            #[must_use]
            pub fn lck8(&mut self) -> LCK8_W<LCKR_SPEC> {
                LCK8_W::new(self, 8)
            }
            ///Bit 9 - Port A Lock bit 9
            #[inline(always)]
            #[must_use]
            pub fn lck9(&mut self) -> LCK9_W<LCKR_SPEC> {
                LCK9_W::new(self, 9)
            }
            ///Bit 10 - Port A Lock bit 10
            #[inline(always)]
            #[must_use]
            pub fn lck10(&mut self) -> LCK10_W<LCKR_SPEC> {
                LCK10_W::new(self, 10)
            }
            ///Bit 11 - Port A Lock bit 11
            #[inline(always)]
            #[must_use]
            pub fn lck11(&mut self) -> LCK11_W<LCKR_SPEC> {
                LCK11_W::new(self, 11)
            }
            ///Bit 12 - Port A Lock bit 12
            #[inline(always)]
            #[must_use]
            pub fn lck12(&mut self) -> LCK12_W<LCKR_SPEC> {
                LCK12_W::new(self, 12)
            }
            ///Bit 13 - Port A Lock bit 13
            #[inline(always)]
            #[must_use]
            pub fn lck13(&mut self) -> LCK13_W<LCKR_SPEC> {
                LCK13_W::new(self, 13)
            }
            ///Bit 14 - Port A Lock bit 14
            #[inline(always)]
            #[must_use]
            pub fn lck14(&mut self) -> LCK14_W<LCKR_SPEC> {
                LCK14_W::new(self, 14)
            }
            ///Bit 15 - Port A Lock bit 15
            #[inline(always)]
            #[must_use]
            pub fn lck15(&mut self) -> LCK15_W<LCKR_SPEC> {
                LCK15_W::new(self, 15)
            }
            ///Bit 16 - Lock key
            #[inline(always)]
            #[must_use]
            pub fn lckk(&mut self) -> LCKK_W<LCKR_SPEC> {
                LCKK_W::new(self, 16)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Port configuration lock register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`lckr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`lckr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct LCKR_SPEC;
        impl crate::RegisterSpec for LCKR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`lckr::R`](R) reader structure
        impl crate::Readable for LCKR_SPEC {}
        ///`write(|w| ..)` method takes [`lckr::W`](W) writer structure
        impl crate::Writable for LCKR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets LCKR to value 0
        impl crate::Resettable for LCKR_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
}
///General purpose I/O
pub struct GPIOB {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for GPIOB {}
impl GPIOB {
    ///Pointer to the register block
    pub const PTR: *const gpioa::RegisterBlock = 0x4001_0c00 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const gpioa::RegisterBlock {
        Self::PTR
    }
    /// Steal an instance of this peripheral
    ///
    /// # Safety
    ///
    /// Ensure that the new instance of the peripheral cannot be used in a way
    /// that may race with any existing instances, for example by only
    /// accessing read-only or write-only registers, or by consuming the
    /// original peripheral and using critical sections to coordinate
    /// access between multiple new instances.
    ///
    /// Additionally, other software such as HALs may rely on only one
    /// peripheral instance existing to ensure memory safety; ensure
    /// no stolen instances are passed to such software.
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for GPIOB {
    type Target = gpioa::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for GPIOB {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GPIOB").finish()
    }
}
///General purpose I/O
pub use self::gpioa as gpiob;
///General purpose I/O
pub struct GPIOC {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for GPIOC {}
impl GPIOC {
    ///Pointer to the register block
    pub const PTR: *const gpioa::RegisterBlock = 0x4001_1000 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const gpioa::RegisterBlock {
        Self::PTR
    }
    /// Steal an instance of this peripheral
    ///
    /// # Safety
    ///
    /// Ensure that the new instance of the peripheral cannot be used in a way
    /// that may race with any existing instances, for example by only
    /// accessing read-only or write-only registers, or by consuming the
    /// original peripheral and using critical sections to coordinate
    /// access between multiple new instances.
    ///
    /// Additionally, other software such as HALs may rely on only one
    /// peripheral instance existing to ensure memory safety; ensure
    /// no stolen instances are passed to such software.
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for GPIOC {
    type Target = gpioa::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for GPIOC {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GPIOC").finish()
    }
}
///General purpose I/O
pub use self::gpioa as gpioc;
///General purpose I/O
pub struct GPIOD {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for GPIOD {}
impl GPIOD {
    ///Pointer to the register block
    pub const PTR: *const gpioa::RegisterBlock = 0x4001_1400 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const gpioa::RegisterBlock {
        Self::PTR
    }
    /// Steal an instance of this peripheral
    ///
    /// # Safety
    ///
    /// Ensure that the new instance of the peripheral cannot be used in a way
    /// that may race with any existing instances, for example by only
    /// accessing read-only or write-only registers, or by consuming the
    /// original peripheral and using critical sections to coordinate
    /// access between multiple new instances.
    ///
    /// Additionally, other software such as HALs may rely on only one
    /// peripheral instance existing to ensure memory safety; ensure
    /// no stolen instances are passed to such software.
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for GPIOD {
    type Target = gpioa::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for GPIOD {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GPIOD").finish()
    }
}
///General purpose I/O
pub use self::gpioa as gpiod;
///Alternate function I/O
pub struct AFIO {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for AFIO {}
impl AFIO {
    ///Pointer to the register block
    pub const PTR: *const afio::RegisterBlock = 0x4001_0000 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const afio::RegisterBlock {
        Self::PTR
    }
    /// Steal an instance of this peripheral
    ///
    /// # Safety
    ///
    /// Ensure that the new instance of the peripheral cannot be used in a way
    /// that may race with any existing instances, for example by only
    /// accessing read-only or write-only registers, or by consuming the
    /// original peripheral and using critical sections to coordinate
    /// access between multiple new instances.
    ///
    /// Additionally, other software such as HALs may rely on only one
    /// peripheral instance existing to ensure memory safety; ensure
    /// no stolen instances are passed to such software.
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for AFIO {
    type Target = afio::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for AFIO {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("AFIO").finish()
    }
}
///Alternate function I/O
pub mod afio {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        ecr: ECR,
        pcfr1: PCFR1,
        exticr1: EXTICR1,
        exticr2: EXTICR2,
        exticr3: EXTICR3,
        exticr4: EXTICR4,
        cr: CR,
        pcfr2: PCFR2,
    }
    impl RegisterBlock {
        ///0x00 - Event Control Register (AFIO_ECR)
        #[inline(always)]
        pub const fn ecr(&self) -> &ECR {
            &self.ecr
        }
        ///0x04 - AF remap and debug I/O configuration register 1 (AFIO_PCFR1)
        #[inline(always)]
        pub const fn pcfr1(&self) -> &PCFR1 {
            &self.pcfr1
        }
        ///0x08 - External interrupt configuration register 1 (AFIO_EXTICR1)
        #[inline(always)]
        pub const fn exticr1(&self) -> &EXTICR1 {
            &self.exticr1
        }
        ///0x0c - External interrupt configuration register 2 (AFIO_EXTICR2)
        #[inline(always)]
        pub const fn exticr2(&self) -> &EXTICR2 {
            &self.exticr2
        }
        ///0x10 - External interrupt configuration register 3 (AFIO_EXTICR3)
        #[inline(always)]
        pub const fn exticr3(&self) -> &EXTICR3 {
            &self.exticr3
        }
        ///0x14 - External interrupt configuration register 4 (AFIO_EXTICR4)
        #[inline(always)]
        pub const fn exticr4(&self) -> &EXTICR4 {
            &self.exticr4
        }
        ///0x18 - AFIO control register (AFIO_CR)
        #[inline(always)]
        pub const fn cr(&self) -> &CR {
            &self.cr
        }
        ///0x1c - AF remap and debug I/O configuration register (AFIO_PCFR2)
        #[inline(always)]
        pub const fn pcfr2(&self) -> &PCFR2 {
            &self.pcfr2
        }
    }
    ///ECR (rw) register accessor: Event Control Register (AFIO_ECR)
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`ecr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ecr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@ecr`]
    ///module
    pub type ECR = crate::Reg<ecr::ECR_SPEC>;
    ///Event Control Register (AFIO_ECR)
    pub mod ecr {
        ///Register `ECR` reader
        pub type R = crate::R<ECR_SPEC>;
        ///Register `ECR` writer
        pub type W = crate::W<ECR_SPEC>;
        ///Field `PIN` reader - Pin selection
        pub type PIN_R = crate::FieldReader;
        ///Field `PIN` writer - Pin selection
        pub type PIN_W<'a, REG> = crate::FieldWriter<'a, REG, 4>;
        ///Field `PORT` reader - Port selection
        pub type PORT_R = crate::FieldReader;
        ///Field `PORT` writer - Port selection
        pub type PORT_W<'a, REG> = crate::FieldWriter<'a, REG, 3>;
        ///Field `EVOE` reader - Event Output Enable
        pub type EVOE_R = crate::BitReader;
        ///Field `EVOE` writer - Event Output Enable
        pub type EVOE_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bits 0:3 - Pin selection
            #[inline(always)]
            pub fn pin(&self) -> PIN_R {
                PIN_R::new((self.bits & 0x0f) as u8)
            }
            ///Bits 4:6 - Port selection
            #[inline(always)]
            pub fn port(&self) -> PORT_R {
                PORT_R::new(((self.bits >> 4) & 7) as u8)
            }
            ///Bit 7 - Event Output Enable
            #[inline(always)]
            pub fn evoe(&self) -> EVOE_R {
                EVOE_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:3 - Pin selection
            #[inline(always)]
            #[must_use]
            pub fn pin(&mut self) -> PIN_W<ECR_SPEC> {
                PIN_W::new(self, 0)
            }
            ///Bits 4:6 - Port selection
            #[inline(always)]
            #[must_use]
            pub fn port(&mut self) -> PORT_W<ECR_SPEC> {
                PORT_W::new(self, 4)
            }
            ///Bit 7 - Event Output Enable
            #[inline(always)]
            #[must_use]
            pub fn evoe(&mut self) -> EVOE_W<ECR_SPEC> {
                EVOE_W::new(self, 7)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Event Control Register (AFIO_ECR)
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`ecr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ecr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct ECR_SPEC;
        impl crate::RegisterSpec for ECR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`ecr::R`](R) reader structure
        impl crate::Readable for ECR_SPEC {}
        ///`write(|w| ..)` method takes [`ecr::W`](W) writer structure
        impl crate::Writable for ECR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets ECR to value 0
        impl crate::Resettable for ECR_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///PCFR1 (rw) register accessor: AF remap and debug I/O configuration register 1 (AFIO_PCFR1)
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`pcfr1::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pcfr1::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@pcfr1`]
    ///module
    pub type PCFR1 = crate::Reg<pcfr1::PCFR1_SPEC>;
    ///AF remap and debug I/O configuration register 1 (AFIO_PCFR1)
    pub mod pcfr1 {
        ///Register `PCFR1` reader
        pub type R = crate::R<PCFR1_SPEC>;
        ///Register `PCFR1` writer
        pub type W = crate::W<PCFR1_SPEC>;
        ///Field `SPI1_RM` reader - SPI1 remapping
        pub type SPI1_RM_R = crate::BitReader;
        ///Field `SPI1_RM` writer - SPI1 remapping
        pub type SPI1_RM_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `I2C1_RM` reader - I2C1 remapping
        pub type I2C1_RM_R = crate::BitReader;
        ///Field `I2C1_RM` writer - I2C1 remapping
        pub type I2C1_RM_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `USART1_RM` reader - USART1 remapping
        pub type USART1_RM_R = crate::BitReader;
        ///Field `USART1_RM` writer - USART1 remapping
        pub type USART1_RM_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `USART2_RM` reader - USART2 remapping
        pub type USART2_RM_R = crate::BitReader;
        ///Field `USART2_RM` writer - USART2 remapping
        pub type USART2_RM_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `USART3_RM` reader - USART3 remapping
        pub type USART3_RM_R = crate::FieldReader;
        ///Field `USART3_RM` writer - USART3 remapping
        pub type USART3_RM_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `TIM1_RM` reader - TIM1 remapping
        pub type TIM1_RM_R = crate::FieldReader;
        ///Field `TIM1_RM` writer - TIM1 remapping
        pub type TIM1_RM_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `TIM2_RM` reader - TIM2 remapping
        pub type TIM2_RM_R = crate::FieldReader;
        ///Field `TIM2_RM` writer - TIM2 remapping
        pub type TIM2_RM_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `TIM3_RM` reader - TIM3 remapping
        pub type TIM3_RM_R = crate::BitReader;
        ///Field `TIM3_RM` writer - TIM3 remapping
        pub type TIM3_RM_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TIM4_RM` reader - TIM4 remapping
        pub type TIM4_RM_R = crate::BitReader;
        ///Field `TIM4_RM` writer - TIM4 remapping
        pub type TIM4_RM_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CAN_RM` reader - CAN remapping
        pub type CAN_RM_R = crate::FieldReader;
        ///Field `CAN_RM` writer - CAN remapping
        pub type CAN_RM_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `PD01_RM` reader - Port D0/Port D1 mapping on OSCIN/OSCOUT
        pub type PD01_RM_R = crate::BitReader;
        ///Field `PD01_RM` writer - Port D0/Port D1 mapping on OSCIN/OSCOUT
        pub type PD01_RM_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `SW_CFG` writer - Serial wire JTAG configuration
        pub type SW_CFG_W<'a, REG> = crate::FieldWriter<'a, REG, 3>;
        impl R {
            ///Bit 0 - SPI1 remapping
            #[inline(always)]
            pub fn spi1_rm(&self) -> SPI1_RM_R {
                SPI1_RM_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - I2C1 remapping
            #[inline(always)]
            pub fn i2c1_rm(&self) -> I2C1_RM_R {
                I2C1_RM_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - USART1 remapping
            #[inline(always)]
            pub fn usart1_rm(&self) -> USART1_RM_R {
                USART1_RM_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - USART2 remapping
            #[inline(always)]
            pub fn usart2_rm(&self) -> USART2_RM_R {
                USART2_RM_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bits 4:5 - USART3 remapping
            #[inline(always)]
            pub fn usart3_rm(&self) -> USART3_RM_R {
                USART3_RM_R::new(((self.bits >> 4) & 3) as u8)
            }
            ///Bits 6:7 - TIM1 remapping
            #[inline(always)]
            pub fn tim1_rm(&self) -> TIM1_RM_R {
                TIM1_RM_R::new(((self.bits >> 6) & 3) as u8)
            }
            ///Bits 8:9 - TIM2 remapping
            #[inline(always)]
            pub fn tim2_rm(&self) -> TIM2_RM_R {
                TIM2_RM_R::new(((self.bits >> 8) & 3) as u8)
            }
            ///Bit 10 - TIM3 remapping
            #[inline(always)]
            pub fn tim3_rm(&self) -> TIM3_RM_R {
                TIM3_RM_R::new(((self.bits >> 10) & 1) != 0)
            }
            ///Bit 12 - TIM4 remapping
            #[inline(always)]
            pub fn tim4_rm(&self) -> TIM4_RM_R {
                TIM4_RM_R::new(((self.bits >> 12) & 1) != 0)
            }
            ///Bits 13:14 - CAN remapping
            #[inline(always)]
            pub fn can_rm(&self) -> CAN_RM_R {
                CAN_RM_R::new(((self.bits >> 13) & 3) as u8)
            }
            ///Bit 15 - Port D0/Port D1 mapping on OSCIN/OSCOUT
            #[inline(always)]
            pub fn pd01_rm(&self) -> PD01_RM_R {
                PD01_RM_R::new(((self.bits >> 15) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - SPI1 remapping
            #[inline(always)]
            #[must_use]
            pub fn spi1_rm(&mut self) -> SPI1_RM_W<PCFR1_SPEC> {
                SPI1_RM_W::new(self, 0)
            }
            ///Bit 1 - I2C1 remapping
            #[inline(always)]
            #[must_use]
            pub fn i2c1_rm(&mut self) -> I2C1_RM_W<PCFR1_SPEC> {
                I2C1_RM_W::new(self, 1)
            }
            ///Bit 2 - USART1 remapping
            #[inline(always)]
            #[must_use]
            pub fn usart1_rm(&mut self) -> USART1_RM_W<PCFR1_SPEC> {
                USART1_RM_W::new(self, 2)
            }
            ///Bit 3 - USART2 remapping
            #[inline(always)]
            #[must_use]
            pub fn usart2_rm(&mut self) -> USART2_RM_W<PCFR1_SPEC> {
                USART2_RM_W::new(self, 3)
            }
            ///Bits 4:5 - USART3 remapping
            #[inline(always)]
            #[must_use]
            pub fn usart3_rm(&mut self) -> USART3_RM_W<PCFR1_SPEC> {
                USART3_RM_W::new(self, 4)
            }
            ///Bits 6:7 - TIM1 remapping
            #[inline(always)]
            #[must_use]
            pub fn tim1_rm(&mut self) -> TIM1_RM_W<PCFR1_SPEC> {
                TIM1_RM_W::new(self, 6)
            }
            ///Bits 8:9 - TIM2 remapping
            #[inline(always)]
            #[must_use]
            pub fn tim2_rm(&mut self) -> TIM2_RM_W<PCFR1_SPEC> {
                TIM2_RM_W::new(self, 8)
            }
            ///Bit 10 - TIM3 remapping
            #[inline(always)]
            #[must_use]
            pub fn tim3_rm(&mut self) -> TIM3_RM_W<PCFR1_SPEC> {
                TIM3_RM_W::new(self, 10)
            }
            ///Bit 12 - TIM4 remapping
            #[inline(always)]
            #[must_use]
            pub fn tim4_rm(&mut self) -> TIM4_RM_W<PCFR1_SPEC> {
                TIM4_RM_W::new(self, 12)
            }
            ///Bits 13:14 - CAN remapping
            #[inline(always)]
            #[must_use]
            pub fn can_rm(&mut self) -> CAN_RM_W<PCFR1_SPEC> {
                CAN_RM_W::new(self, 13)
            }
            ///Bit 15 - Port D0/Port D1 mapping on OSCIN/OSCOUT
            #[inline(always)]
            #[must_use]
            pub fn pd01_rm(&mut self) -> PD01_RM_W<PCFR1_SPEC> {
                PD01_RM_W::new(self, 15)
            }
            ///Bits 24:26 - Serial wire JTAG configuration
            #[inline(always)]
            #[must_use]
            pub fn sw_cfg(&mut self) -> SW_CFG_W<PCFR1_SPEC> {
                SW_CFG_W::new(self, 24)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///AF remap and debug I/O configuration register 1 (AFIO_PCFR1)
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`pcfr1::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pcfr1::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct PCFR1_SPEC;
        impl crate::RegisterSpec for PCFR1_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`pcfr1::R`](R) reader structure
        impl crate::Readable for PCFR1_SPEC {}
        ///`write(|w| ..)` method takes [`pcfr1::W`](W) writer structure
        impl crate::Writable for PCFR1_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets PCFR1 to value 0
        impl crate::Resettable for PCFR1_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///EXTICR1 (rw) register accessor: External interrupt configuration register 1 (AFIO_EXTICR1)
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`exticr1::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`exticr1::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@exticr1`]
    ///module
    pub type EXTICR1 = crate::Reg<exticr1::EXTICR1_SPEC>;
    ///External interrupt configuration register 1 (AFIO_EXTICR1)
    pub mod exticr1 {
        ///Register `EXTICR1` reader
        pub type R = crate::R<EXTICR1_SPEC>;
        ///Register `EXTICR1` writer
        pub type W = crate::W<EXTICR1_SPEC>;
        ///Field `EXTI0` reader - EXTI0 configuration
        pub type EXTI0_R = crate::FieldReader;
        ///Field `EXTI0` writer - EXTI0 configuration
        pub type EXTI0_W<'a, REG> = crate::FieldWriter<'a, REG, 4>;
        ///Field `EXTI1` reader - EXTI1 configuration
        pub type EXTI1_R = crate::FieldReader;
        ///Field `EXTI1` writer - EXTI1 configuration
        pub type EXTI1_W<'a, REG> = crate::FieldWriter<'a, REG, 4>;
        ///Field `EXTI2` reader - EXTI2 configuration
        pub type EXTI2_R = crate::FieldReader;
        ///Field `EXTI2` writer - EXTI2 configuration
        pub type EXTI2_W<'a, REG> = crate::FieldWriter<'a, REG, 4>;
        ///Field `EXTI3` reader - EXTI3 configuration
        pub type EXTI3_R = crate::FieldReader;
        ///Field `EXTI3` writer - EXTI3 configuration
        pub type EXTI3_W<'a, REG> = crate::FieldWriter<'a, REG, 4>;
        impl R {
            ///Bits 0:3 - EXTI0 configuration
            #[inline(always)]
            pub fn exti0(&self) -> EXTI0_R {
                EXTI0_R::new((self.bits & 0x0f) as u8)
            }
            ///Bits 4:7 - EXTI1 configuration
            #[inline(always)]
            pub fn exti1(&self) -> EXTI1_R {
                EXTI1_R::new(((self.bits >> 4) & 0x0f) as u8)
            }
            ///Bits 8:11 - EXTI2 configuration
            #[inline(always)]
            pub fn exti2(&self) -> EXTI2_R {
                EXTI2_R::new(((self.bits >> 8) & 0x0f) as u8)
            }
            ///Bits 12:15 - EXTI3 configuration
            #[inline(always)]
            pub fn exti3(&self) -> EXTI3_R {
                EXTI3_R::new(((self.bits >> 12) & 0x0f) as u8)
            }
        }
        impl W {
            ///Bits 0:3 - EXTI0 configuration
            #[inline(always)]
            #[must_use]
            pub fn exti0(&mut self) -> EXTI0_W<EXTICR1_SPEC> {
                EXTI0_W::new(self, 0)
            }
            ///Bits 4:7 - EXTI1 configuration
            #[inline(always)]
            #[must_use]
            pub fn exti1(&mut self) -> EXTI1_W<EXTICR1_SPEC> {
                EXTI1_W::new(self, 4)
            }
            ///Bits 8:11 - EXTI2 configuration
            #[inline(always)]
            #[must_use]
            pub fn exti2(&mut self) -> EXTI2_W<EXTICR1_SPEC> {
                EXTI2_W::new(self, 8)
            }
            ///Bits 12:15 - EXTI3 configuration
            #[inline(always)]
            #[must_use]
            pub fn exti3(&mut self) -> EXTI3_W<EXTICR1_SPEC> {
                EXTI3_W::new(self, 12)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///External interrupt configuration register 1 (AFIO_EXTICR1)
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`exticr1::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`exticr1::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct EXTICR1_SPEC;
        impl crate::RegisterSpec for EXTICR1_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`exticr1::R`](R) reader structure
        impl crate::Readable for EXTICR1_SPEC {}
        ///`write(|w| ..)` method takes [`exticr1::W`](W) writer structure
        impl crate::Writable for EXTICR1_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets EXTICR1 to value 0
        impl crate::Resettable for EXTICR1_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///EXTICR2 (rw) register accessor: External interrupt configuration register 2 (AFIO_EXTICR2)
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`exticr2::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`exticr2::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@exticr2`]
    ///module
    pub type EXTICR2 = crate::Reg<exticr2::EXTICR2_SPEC>;
    ///External interrupt configuration register 2 (AFIO_EXTICR2)
    pub mod exticr2 {
        ///Register `EXTICR2` reader
        pub type R = crate::R<EXTICR2_SPEC>;
        ///Register `EXTICR2` writer
        pub type W = crate::W<EXTICR2_SPEC>;
        ///Field `EXTI4` reader - EXTI4 configuration
        pub type EXTI4_R = crate::FieldReader;
        ///Field `EXTI4` writer - EXTI4 configuration
        pub type EXTI4_W<'a, REG> = crate::FieldWriter<'a, REG, 4>;
        ///Field `EXTI5` reader - EXTI5 configuration
        pub type EXTI5_R = crate::FieldReader;
        ///Field `EXTI5` writer - EXTI5 configuration
        pub type EXTI5_W<'a, REG> = crate::FieldWriter<'a, REG, 4>;
        ///Field `EXTI6` reader - EXTI6 configuration
        pub type EXTI6_R = crate::FieldReader;
        ///Field `EXTI6` writer - EXTI6 configuration
        pub type EXTI6_W<'a, REG> = crate::FieldWriter<'a, REG, 4>;
        ///Field `EXTI7` reader - EXTI7 configuration
        pub type EXTI7_R = crate::FieldReader;
        ///Field `EXTI7` writer - EXTI7 configuration
        pub type EXTI7_W<'a, REG> = crate::FieldWriter<'a, REG, 4>;
        impl R {
            ///Bits 0:3 - EXTI4 configuration
            #[inline(always)]
            pub fn exti4(&self) -> EXTI4_R {
                EXTI4_R::new((self.bits & 0x0f) as u8)
            }
            ///Bits 4:7 - EXTI5 configuration
            #[inline(always)]
            pub fn exti5(&self) -> EXTI5_R {
                EXTI5_R::new(((self.bits >> 4) & 0x0f) as u8)
            }
            ///Bits 8:11 - EXTI6 configuration
            #[inline(always)]
            pub fn exti6(&self) -> EXTI6_R {
                EXTI6_R::new(((self.bits >> 8) & 0x0f) as u8)
            }
            ///Bits 12:15 - EXTI7 configuration
            #[inline(always)]
            pub fn exti7(&self) -> EXTI7_R {
                EXTI7_R::new(((self.bits >> 12) & 0x0f) as u8)
            }
        }
        impl W {
            ///Bits 0:3 - EXTI4 configuration
            #[inline(always)]
            #[must_use]
            pub fn exti4(&mut self) -> EXTI4_W<EXTICR2_SPEC> {
                EXTI4_W::new(self, 0)
            }
            ///Bits 4:7 - EXTI5 configuration
            #[inline(always)]
            #[must_use]
            pub fn exti5(&mut self) -> EXTI5_W<EXTICR2_SPEC> {
                EXTI5_W::new(self, 4)
            }
            ///Bits 8:11 - EXTI6 configuration
            #[inline(always)]
            #[must_use]
            pub fn exti6(&mut self) -> EXTI6_W<EXTICR2_SPEC> {
                EXTI6_W::new(self, 8)
            }
            ///Bits 12:15 - EXTI7 configuration
            #[inline(always)]
            #[must_use]
            pub fn exti7(&mut self) -> EXTI7_W<EXTICR2_SPEC> {
                EXTI7_W::new(self, 12)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///External interrupt configuration register 2 (AFIO_EXTICR2)
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`exticr2::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`exticr2::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct EXTICR2_SPEC;
        impl crate::RegisterSpec for EXTICR2_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`exticr2::R`](R) reader structure
        impl crate::Readable for EXTICR2_SPEC {}
        ///`write(|w| ..)` method takes [`exticr2::W`](W) writer structure
        impl crate::Writable for EXTICR2_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets EXTICR2 to value 0
        impl crate::Resettable for EXTICR2_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///EXTICR3 (rw) register accessor: External interrupt configuration register 3 (AFIO_EXTICR3)
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`exticr3::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`exticr3::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@exticr3`]
    ///module
    pub type EXTICR3 = crate::Reg<exticr3::EXTICR3_SPEC>;
    ///External interrupt configuration register 3 (AFIO_EXTICR3)
    pub mod exticr3 {
        ///Register `EXTICR3` reader
        pub type R = crate::R<EXTICR3_SPEC>;
        ///Register `EXTICR3` writer
        pub type W = crate::W<EXTICR3_SPEC>;
        ///Field `EXTI8` reader - EXTI8 configuration
        pub type EXTI8_R = crate::FieldReader;
        ///Field `EXTI8` writer - EXTI8 configuration
        pub type EXTI8_W<'a, REG> = crate::FieldWriter<'a, REG, 4>;
        ///Field `EXTI9` reader - EXTI9 configuration
        pub type EXTI9_R = crate::FieldReader;
        ///Field `EXTI9` writer - EXTI9 configuration
        pub type EXTI9_W<'a, REG> = crate::FieldWriter<'a, REG, 4>;
        ///Field `EXTI10` reader - EXTI10 configuration
        pub type EXTI10_R = crate::FieldReader;
        ///Field `EXTI10` writer - EXTI10 configuration
        pub type EXTI10_W<'a, REG> = crate::FieldWriter<'a, REG, 4>;
        ///Field `EXTI11` reader - EXTI11 configuration
        pub type EXTI11_R = crate::FieldReader;
        ///Field `EXTI11` writer - EXTI11 configuration
        pub type EXTI11_W<'a, REG> = crate::FieldWriter<'a, REG, 4>;
        impl R {
            ///Bits 0:3 - EXTI8 configuration
            #[inline(always)]
            pub fn exti8(&self) -> EXTI8_R {
                EXTI8_R::new((self.bits & 0x0f) as u8)
            }
            ///Bits 4:7 - EXTI9 configuration
            #[inline(always)]
            pub fn exti9(&self) -> EXTI9_R {
                EXTI9_R::new(((self.bits >> 4) & 0x0f) as u8)
            }
            ///Bits 8:11 - EXTI10 configuration
            #[inline(always)]
            pub fn exti10(&self) -> EXTI10_R {
                EXTI10_R::new(((self.bits >> 8) & 0x0f) as u8)
            }
            ///Bits 12:15 - EXTI11 configuration
            #[inline(always)]
            pub fn exti11(&self) -> EXTI11_R {
                EXTI11_R::new(((self.bits >> 12) & 0x0f) as u8)
            }
        }
        impl W {
            ///Bits 0:3 - EXTI8 configuration
            #[inline(always)]
            #[must_use]
            pub fn exti8(&mut self) -> EXTI8_W<EXTICR3_SPEC> {
                EXTI8_W::new(self, 0)
            }
            ///Bits 4:7 - EXTI9 configuration
            #[inline(always)]
            #[must_use]
            pub fn exti9(&mut self) -> EXTI9_W<EXTICR3_SPEC> {
                EXTI9_W::new(self, 4)
            }
            ///Bits 8:11 - EXTI10 configuration
            #[inline(always)]
            #[must_use]
            pub fn exti10(&mut self) -> EXTI10_W<EXTICR3_SPEC> {
                EXTI10_W::new(self, 8)
            }
            ///Bits 12:15 - EXTI11 configuration
            #[inline(always)]
            #[must_use]
            pub fn exti11(&mut self) -> EXTI11_W<EXTICR3_SPEC> {
                EXTI11_W::new(self, 12)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///External interrupt configuration register 3 (AFIO_EXTICR3)
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`exticr3::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`exticr3::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct EXTICR3_SPEC;
        impl crate::RegisterSpec for EXTICR3_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`exticr3::R`](R) reader structure
        impl crate::Readable for EXTICR3_SPEC {}
        ///`write(|w| ..)` method takes [`exticr3::W`](W) writer structure
        impl crate::Writable for EXTICR3_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets EXTICR3 to value 0
        impl crate::Resettable for EXTICR3_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///EXTICR4 (rw) register accessor: External interrupt configuration register 4 (AFIO_EXTICR4)
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`exticr4::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`exticr4::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@exticr4`]
    ///module
    pub type EXTICR4 = crate::Reg<exticr4::EXTICR4_SPEC>;
    ///External interrupt configuration register 4 (AFIO_EXTICR4)
    pub mod exticr4 {
        ///Register `EXTICR4` reader
        pub type R = crate::R<EXTICR4_SPEC>;
        ///Register `EXTICR4` writer
        pub type W = crate::W<EXTICR4_SPEC>;
        ///Field `EXTI12` reader - EXTI12 configuration
        pub type EXTI12_R = crate::FieldReader;
        ///Field `EXTI12` writer - EXTI12 configuration
        pub type EXTI12_W<'a, REG> = crate::FieldWriter<'a, REG, 4>;
        ///Field `EXTI13` reader - EXTI13 configuration
        pub type EXTI13_R = crate::FieldReader;
        ///Field `EXTI13` writer - EXTI13 configuration
        pub type EXTI13_W<'a, REG> = crate::FieldWriter<'a, REG, 4>;
        ///Field `EXTI14` reader - EXTI14 configuration
        pub type EXTI14_R = crate::FieldReader;
        ///Field `EXTI14` writer - EXTI14 configuration
        pub type EXTI14_W<'a, REG> = crate::FieldWriter<'a, REG, 4>;
        ///Field `EXTI15` reader - EXTI15 configuration
        pub type EXTI15_R = crate::FieldReader;
        ///Field `EXTI15` writer - EXTI15 configuration
        pub type EXTI15_W<'a, REG> = crate::FieldWriter<'a, REG, 4>;
        impl R {
            ///Bits 0:3 - EXTI12 configuration
            #[inline(always)]
            pub fn exti12(&self) -> EXTI12_R {
                EXTI12_R::new((self.bits & 0x0f) as u8)
            }
            ///Bits 4:7 - EXTI13 configuration
            #[inline(always)]
            pub fn exti13(&self) -> EXTI13_R {
                EXTI13_R::new(((self.bits >> 4) & 0x0f) as u8)
            }
            ///Bits 8:11 - EXTI14 configuration
            #[inline(always)]
            pub fn exti14(&self) -> EXTI14_R {
                EXTI14_R::new(((self.bits >> 8) & 0x0f) as u8)
            }
            ///Bits 12:15 - EXTI15 configuration
            #[inline(always)]
            pub fn exti15(&self) -> EXTI15_R {
                EXTI15_R::new(((self.bits >> 12) & 0x0f) as u8)
            }
        }
        impl W {
            ///Bits 0:3 - EXTI12 configuration
            #[inline(always)]
            #[must_use]
            pub fn exti12(&mut self) -> EXTI12_W<EXTICR4_SPEC> {
                EXTI12_W::new(self, 0)
            }
            ///Bits 4:7 - EXTI13 configuration
            #[inline(always)]
            #[must_use]
            pub fn exti13(&mut self) -> EXTI13_W<EXTICR4_SPEC> {
                EXTI13_W::new(self, 4)
            }
            ///Bits 8:11 - EXTI14 configuration
            #[inline(always)]
            #[must_use]
            pub fn exti14(&mut self) -> EXTI14_W<EXTICR4_SPEC> {
                EXTI14_W::new(self, 8)
            }
            ///Bits 12:15 - EXTI15 configuration
            #[inline(always)]
            #[must_use]
            pub fn exti15(&mut self) -> EXTI15_W<EXTICR4_SPEC> {
                EXTI15_W::new(self, 12)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///External interrupt configuration register 4 (AFIO_EXTICR4)
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`exticr4::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`exticr4::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct EXTICR4_SPEC;
        impl crate::RegisterSpec for EXTICR4_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`exticr4::R`](R) reader structure
        impl crate::Readable for EXTICR4_SPEC {}
        ///`write(|w| ..)` method takes [`exticr4::W`](W) writer structure
        impl crate::Writable for EXTICR4_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets EXTICR4 to value 0
        impl crate::Resettable for EXTICR4_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///CR (rw) register accessor: AFIO control register (AFIO_CR)
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`cr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@cr`]
    ///module
    pub type CR = crate::Reg<cr::CR_SPEC>;
    ///AFIO control register (AFIO_CR)
    pub mod cr {
        ///Register `CR` reader
        pub type R = crate::R<CR_SPEC>;
        ///Register `CR` writer
        pub type W = crate::W<CR_SPEC>;
        ///Field `USBPD_IN_HVT` reader - PD pin PB6/PD7 High threshold input mode
        pub type USBPD_IN_HVT_R = crate::BitReader;
        ///Field `USBPD_IN_HVT` writer - PD pin PB6/PD7 High threshold input mode
        pub type USBPD_IN_HVT_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UDP_BC_VSRC` reader - PA12/UDP pin BC source voltage enable
        pub type UDP_BC_VSRC_R = crate::BitReader;
        ///Field `UDP_BC_VSRC` writer - PA12/UDP pin BC source voltage enable
        pub type UDP_BC_VSRC_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UDM_BC_VSRC` reader - PA11/UDM pin BC source voltage enable
        pub type UDM_BC_VSRC_R = crate::BitReader;
        ///Field `UDM_BC_VSRC` writer - PA11/UDM pin BC source voltage enable
        pub type UDM_BC_VSRC_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UDP_BC_CMPE` reader - PA12/UDP pin BC protocol comparator enable
        pub type UDP_BC_CMPE_R = crate::BitReader;
        ///Field `UDP_BC_CMPE` writer - PA12/UDP pin BC protocol comparator enable
        pub type UDP_BC_CMPE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UDM_BC_CMPE` reader - PA11/UDM pin BC protocol comparator enable
        pub type UDM_BC_CMPE_R = crate::BitReader;
        ///Field `UDM_BC_CMPE` writer - PA11/UDM pin BC protocol comparator enable
        pub type UDM_BC_CMPE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UDP_BC_CMPO` reader - PA12/UDP pin BC protocol comparator status
        pub type UDP_BC_CMPO_R = crate::BitReader;
        ///Field `UDM_BC_CMPO` reader - PA11/UDM pin BC protocol comparator status
        pub type UDM_BC_CMPO_R = crate::BitReader;
        impl R {
            ///Bit 9 - PD pin PB6/PD7 High threshold input mode
            #[inline(always)]
            pub fn usbpd_in_hvt(&self) -> USBPD_IN_HVT_R {
                USBPD_IN_HVT_R::new(((self.bits >> 9) & 1) != 0)
            }
            ///Bit 16 - PA12/UDP pin BC source voltage enable
            #[inline(always)]
            pub fn udp_bc_vsrc(&self) -> UDP_BC_VSRC_R {
                UDP_BC_VSRC_R::new(((self.bits >> 16) & 1) != 0)
            }
            ///Bit 17 - PA11/UDM pin BC source voltage enable
            #[inline(always)]
            pub fn udm_bc_vsrc(&self) -> UDM_BC_VSRC_R {
                UDM_BC_VSRC_R::new(((self.bits >> 17) & 1) != 0)
            }
            ///Bit 18 - PA12/UDP pin BC protocol comparator enable
            #[inline(always)]
            pub fn udp_bc_cmpe(&self) -> UDP_BC_CMPE_R {
                UDP_BC_CMPE_R::new(((self.bits >> 18) & 1) != 0)
            }
            ///Bit 19 - PA11/UDM pin BC protocol comparator enable
            #[inline(always)]
            pub fn udm_bc_cmpe(&self) -> UDM_BC_CMPE_R {
                UDM_BC_CMPE_R::new(((self.bits >> 19) & 1) != 0)
            }
            ///Bit 20 - PA12/UDP pin BC protocol comparator status
            #[inline(always)]
            pub fn udp_bc_cmpo(&self) -> UDP_BC_CMPO_R {
                UDP_BC_CMPO_R::new(((self.bits >> 20) & 1) != 0)
            }
            ///Bit 21 - PA11/UDM pin BC protocol comparator status
            #[inline(always)]
            pub fn udm_bc_cmpo(&self) -> UDM_BC_CMPO_R {
                UDM_BC_CMPO_R::new(((self.bits >> 21) & 1) != 0)
            }
        }
        impl W {
            ///Bit 9 - PD pin PB6/PD7 High threshold input mode
            #[inline(always)]
            #[must_use]
            pub fn usbpd_in_hvt(&mut self) -> USBPD_IN_HVT_W<CR_SPEC> {
                USBPD_IN_HVT_W::new(self, 9)
            }
            ///Bit 16 - PA12/UDP pin BC source voltage enable
            #[inline(always)]
            #[must_use]
            pub fn udp_bc_vsrc(&mut self) -> UDP_BC_VSRC_W<CR_SPEC> {
                UDP_BC_VSRC_W::new(self, 16)
            }
            ///Bit 17 - PA11/UDM pin BC source voltage enable
            #[inline(always)]
            #[must_use]
            pub fn udm_bc_vsrc(&mut self) -> UDM_BC_VSRC_W<CR_SPEC> {
                UDM_BC_VSRC_W::new(self, 17)
            }
            ///Bit 18 - PA12/UDP pin BC protocol comparator enable
            #[inline(always)]
            #[must_use]
            pub fn udp_bc_cmpe(&mut self) -> UDP_BC_CMPE_W<CR_SPEC> {
                UDP_BC_CMPE_W::new(self, 18)
            }
            ///Bit 19 - PA11/UDM pin BC protocol comparator enable
            #[inline(always)]
            #[must_use]
            pub fn udm_bc_cmpe(&mut self) -> UDM_BC_CMPE_W<CR_SPEC> {
                UDM_BC_CMPE_W::new(self, 19)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///AFIO control register (AFIO_CR)
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`cr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct CR_SPEC;
        impl crate::RegisterSpec for CR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`cr::R`](R) reader structure
        impl crate::Readable for CR_SPEC {}
        ///`write(|w| ..)` method takes [`cr::W`](W) writer structure
        impl crate::Writable for CR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets CR to value 0
        impl crate::Resettable for CR_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///PCFR2 (rw) register accessor: AF remap and debug I/O configuration register (AFIO_PCFR2)
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`pcfr2::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pcfr2::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@pcfr2`]
    ///module
    pub type PCFR2 = crate::Reg<pcfr2::PCFR2_SPEC>;
    ///AF remap and debug I/O configuration register (AFIO_PCFR2)
    pub mod pcfr2 {
        ///Register `PCFR2` reader
        pub type R = crate::R<PCFR2_SPEC>;
        ///Register `PCFR2` writer
        pub type W = crate::W<PCFR2_SPEC>;
        ///Field `USART4_RM` reader - USART4 remapping
        pub type USART4_RM_R = crate::BitReader;
        ///Field `USART4_RM` writer - USART4 remapping
        pub type USART4_RM_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `USART2_RM_H` reader - USART2 remapping
        pub type USART2_RM_H_R = crate::BitReader;
        ///Field `USART2_RM_H` writer - USART2 remapping
        pub type USART2_RM_H_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `USART1_RM_H` reader - USART1 remapping
        pub type USART1_RM_H_R = crate::FieldReader;
        ///Field `USART1_RM_H` writer - USART1 remapping
        pub type USART1_RM_H_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `TIM2_RM_H` reader - TIM2 remapping
        pub type TIM2_RM_H_R = crate::BitReader;
        ///Field `TIM2_RM_H` writer - TIM2 remapping
        pub type TIM2_RM_H_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TIM1_RM_H` reader - TIM1 remapping
        pub type TIM1_RM_H_R = crate::BitReader;
        ///Field `TIM1_RM_H` writer - TIM1 remapping
        pub type TIM1_RM_H_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `I2C1_RM_H` reader - I2C1 remapping
        pub type I2C1_RM_H_R = crate::BitReader;
        ///Field `I2C1_RM_H` writer - I2C1 remapping
        pub type I2C1_RM_H_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `SPI1_RM_H` reader - SPI1 remapping
        pub type SPI1_RM_H_R = crate::BitReader;
        ///Field `SPI1_RM_H` writer - SPI1 remapping
        pub type SPI1_RM_H_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `LPTIM_RM` reader - LPTIM remapping
        pub type LPTIM_RM_R = crate::BitReader;
        ///Field `LPTIM_RM` writer - LPTIM remapping
        pub type LPTIM_RM_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 16 - USART4 remapping
            #[inline(always)]
            pub fn usart4_rm(&self) -> USART4_RM_R {
                USART4_RM_R::new(((self.bits >> 16) & 1) != 0)
            }
            ///Bit 18 - USART2 remapping
            #[inline(always)]
            pub fn usart2_rm_h(&self) -> USART2_RM_H_R {
                USART2_RM_H_R::new(((self.bits >> 18) & 1) != 0)
            }
            ///Bits 19:20 - USART1 remapping
            #[inline(always)]
            pub fn usart1_rm_h(&self) -> USART1_RM_H_R {
                USART1_RM_H_R::new(((self.bits >> 19) & 3) as u8)
            }
            ///Bit 21 - TIM2 remapping
            #[inline(always)]
            pub fn tim2_rm_h(&self) -> TIM2_RM_H_R {
                TIM2_RM_H_R::new(((self.bits >> 21) & 1) != 0)
            }
            ///Bit 22 - TIM1 remapping
            #[inline(always)]
            pub fn tim1_rm_h(&self) -> TIM1_RM_H_R {
                TIM1_RM_H_R::new(((self.bits >> 22) & 1) != 0)
            }
            ///Bit 23 - I2C1 remapping
            #[inline(always)]
            pub fn i2c1_rm_h(&self) -> I2C1_RM_H_R {
                I2C1_RM_H_R::new(((self.bits >> 23) & 1) != 0)
            }
            ///Bit 24 - SPI1 remapping
            #[inline(always)]
            pub fn spi1_rm_h(&self) -> SPI1_RM_H_R {
                SPI1_RM_H_R::new(((self.bits >> 24) & 1) != 0)
            }
            ///Bit 25 - LPTIM remapping
            #[inline(always)]
            pub fn lptim_rm(&self) -> LPTIM_RM_R {
                LPTIM_RM_R::new(((self.bits >> 25) & 1) != 0)
            }
        }
        impl W {
            ///Bit 16 - USART4 remapping
            #[inline(always)]
            #[must_use]
            pub fn usart4_rm(&mut self) -> USART4_RM_W<PCFR2_SPEC> {
                USART4_RM_W::new(self, 16)
            }
            ///Bit 18 - USART2 remapping
            #[inline(always)]
            #[must_use]
            pub fn usart2_rm_h(&mut self) -> USART2_RM_H_W<PCFR2_SPEC> {
                USART2_RM_H_W::new(self, 18)
            }
            ///Bits 19:20 - USART1 remapping
            #[inline(always)]
            #[must_use]
            pub fn usart1_rm_h(&mut self) -> USART1_RM_H_W<PCFR2_SPEC> {
                USART1_RM_H_W::new(self, 19)
            }
            ///Bit 21 - TIM2 remapping
            #[inline(always)]
            #[must_use]
            pub fn tim2_rm_h(&mut self) -> TIM2_RM_H_W<PCFR2_SPEC> {
                TIM2_RM_H_W::new(self, 21)
            }
            ///Bit 22 - TIM1 remapping
            #[inline(always)]
            #[must_use]
            pub fn tim1_rm_h(&mut self) -> TIM1_RM_H_W<PCFR2_SPEC> {
                TIM1_RM_H_W::new(self, 22)
            }
            ///Bit 23 - I2C1 remapping
            #[inline(always)]
            #[must_use]
            pub fn i2c1_rm_h(&mut self) -> I2C1_RM_H_W<PCFR2_SPEC> {
                I2C1_RM_H_W::new(self, 23)
            }
            ///Bit 24 - SPI1 remapping
            #[inline(always)]
            #[must_use]
            pub fn spi1_rm_h(&mut self) -> SPI1_RM_H_W<PCFR2_SPEC> {
                SPI1_RM_H_W::new(self, 24)
            }
            ///Bit 25 - LPTIM remapping
            #[inline(always)]
            #[must_use]
            pub fn lptim_rm(&mut self) -> LPTIM_RM_W<PCFR2_SPEC> {
                LPTIM_RM_W::new(self, 25)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///AF remap and debug I/O configuration register (AFIO_PCFR2)
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`pcfr2::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pcfr2::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct PCFR2_SPEC;
        impl crate::RegisterSpec for PCFR2_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`pcfr2::R`](R) reader structure
        impl crate::Readable for PCFR2_SPEC {}
        ///`write(|w| ..)` method takes [`pcfr2::W`](W) writer structure
        impl crate::Writable for PCFR2_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets PCFR2 to value 0
        impl crate::Resettable for PCFR2_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
}
///EXTI
pub struct EXTI {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for EXTI {}
impl EXTI {
    ///Pointer to the register block
    pub const PTR: *const exti::RegisterBlock = 0x4001_0400 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const exti::RegisterBlock {
        Self::PTR
    }
    /// Steal an instance of this peripheral
    ///
    /// # Safety
    ///
    /// Ensure that the new instance of the peripheral cannot be used in a way
    /// that may race with any existing instances, for example by only
    /// accessing read-only or write-only registers, or by consuming the
    /// original peripheral and using critical sections to coordinate
    /// access between multiple new instances.
    ///
    /// Additionally, other software such as HALs may rely on only one
    /// peripheral instance existing to ensure memory safety; ensure
    /// no stolen instances are passed to such software.
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for EXTI {
    type Target = exti::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for EXTI {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("EXTI").finish()
    }
}
///EXTI
pub mod exti {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        intenr: INTENR,
        evenr: EVENR,
        rtenr: RTENR,
        ftenr: FTENR,
        swievr: SWIEVR,
        intfr: INTFR,
    }
    impl RegisterBlock {
        ///0x00 - Interrupt mask register (EXTI_INTENR)
        #[inline(always)]
        pub const fn intenr(&self) -> &INTENR {
            &self.intenr
        }
        ///0x04 - Event mask register (EXTI_EVENR)
        #[inline(always)]
        pub const fn evenr(&self) -> &EVENR {
            &self.evenr
        }
        ///0x08 - Rising Trigger selection register (EXTI_RTENR)
        #[inline(always)]
        pub const fn rtenr(&self) -> &RTENR {
            &self.rtenr
        }
        ///0x0c - Falling Trigger selection register (EXTI_FTENR)
        #[inline(always)]
        pub const fn ftenr(&self) -> &FTENR {
            &self.ftenr
        }
        ///0x10 - Software interrupt event register (EXTI_SWIEVR)
        #[inline(always)]
        pub const fn swievr(&self) -> &SWIEVR {
            &self.swievr
        }
        ///0x14 - interrupt flag register (EXTI_INTFR)
        #[inline(always)]
        pub const fn intfr(&self) -> &INTFR {
            &self.intfr
        }
    }
    ///INTENR (rw) register accessor: Interrupt mask register (EXTI_INTENR)
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`intenr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`intenr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@intenr`]
    ///module
    pub type INTENR = crate::Reg<intenr::INTENR_SPEC>;
    ///Interrupt mask register (EXTI_INTENR)
    pub mod intenr {
        ///Register `INTENR` reader
        pub type R = crate::R<INTENR_SPEC>;
        ///Register `INTENR` writer
        pub type W = crate::W<INTENR_SPEC>;
        ///Field `MR0` reader - Interrupt Mask on line 0
        pub type MR0_R = crate::BitReader;
        ///Field `MR0` writer - Interrupt Mask on line 0
        pub type MR0_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `MR1` reader - Interrupt Mask on line 1
        pub type MR1_R = crate::BitReader;
        ///Field `MR1` writer - Interrupt Mask on line 1
        pub type MR1_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `MR2` reader - Interrupt Mask on line 2
        pub type MR2_R = crate::BitReader;
        ///Field `MR2` writer - Interrupt Mask on line 2
        pub type MR2_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `MR3` reader - Interrupt Mask on line 3
        pub type MR3_R = crate::BitReader;
        ///Field `MR3` writer - Interrupt Mask on line 3
        pub type MR3_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `MR4` reader - Interrupt Mask on line 4
        pub type MR4_R = crate::BitReader;
        ///Field `MR4` writer - Interrupt Mask on line 4
        pub type MR4_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `MR5` reader - Interrupt Mask on line 5
        pub type MR5_R = crate::BitReader;
        ///Field `MR5` writer - Interrupt Mask on line 5
        pub type MR5_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `MR6` reader - Interrupt Mask on line 6
        pub type MR6_R = crate::BitReader;
        ///Field `MR6` writer - Interrupt Mask on line 6
        pub type MR6_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `MR7` reader - Interrupt Mask on line 7
        pub type MR7_R = crate::BitReader;
        ///Field `MR7` writer - Interrupt Mask on line 7
        pub type MR7_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `MR8` reader - Interrupt Mask on line 8
        pub type MR8_R = crate::BitReader;
        ///Field `MR8` writer - Interrupt Mask on line 8
        pub type MR8_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `MR9` reader - Interrupt Mask on line 9
        pub type MR9_R = crate::BitReader;
        ///Field `MR9` writer - Interrupt Mask on line 9
        pub type MR9_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `MR10` reader - Interrupt Mask on line 10
        pub type MR10_R = crate::BitReader;
        ///Field `MR10` writer - Interrupt Mask on line 10
        pub type MR10_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `MR11` reader - Interrupt Mask on line 11
        pub type MR11_R = crate::BitReader;
        ///Field `MR11` writer - Interrupt Mask on line 11
        pub type MR11_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `MR12` reader - Interrupt Mask on line 12
        pub type MR12_R = crate::BitReader;
        ///Field `MR12` writer - Interrupt Mask on line 12
        pub type MR12_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `MR13` reader - Interrupt Mask on line 13
        pub type MR13_R = crate::BitReader;
        ///Field `MR13` writer - Interrupt Mask on line 13
        pub type MR13_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `MR14` reader - Interrupt Mask on line 14
        pub type MR14_R = crate::BitReader;
        ///Field `MR14` writer - Interrupt Mask on line 14
        pub type MR14_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `MR15` reader - Interrupt Mask on line 15
        pub type MR15_R = crate::BitReader;
        ///Field `MR15` writer - Interrupt Mask on line 15
        pub type MR15_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `MR16` reader - Interrupt Mask on line 16
        pub type MR16_R = crate::BitReader;
        ///Field `MR16` writer - Interrupt Mask on line 16
        pub type MR16_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `MR17` reader - Interrupt Mask on line 17
        pub type MR17_R = crate::BitReader;
        ///Field `MR17` writer - Interrupt Mask on line 17
        pub type MR17_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `MR18` reader - Interrupt Mask on line 18
        pub type MR18_R = crate::BitReader;
        ///Field `MR18` writer - Interrupt Mask on line 18
        pub type MR18_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `MR19` reader - Interrupt Mask on line 19
        pub type MR19_R = crate::BitReader;
        ///Field `MR19` writer - Interrupt Mask on line 19
        pub type MR19_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `MR20` reader - Interrupt Mask on line 20
        pub type MR20_R = crate::BitReader;
        ///Field `MR20` writer - Interrupt Mask on line 20
        pub type MR20_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `MR21` reader - Interrupt Mask on line 21
        pub type MR21_R = crate::BitReader;
        ///Field `MR21` writer - Interrupt Mask on line 21
        pub type MR21_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `MR22` reader - Interrupt Mask on line 22
        pub type MR22_R = crate::BitReader;
        ///Field `MR22` writer - Interrupt Mask on line 22
        pub type MR22_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - Interrupt Mask on line 0
            #[inline(always)]
            pub fn mr0(&self) -> MR0_R {
                MR0_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Interrupt Mask on line 1
            #[inline(always)]
            pub fn mr1(&self) -> MR1_R {
                MR1_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - Interrupt Mask on line 2
            #[inline(always)]
            pub fn mr2(&self) -> MR2_R {
                MR2_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - Interrupt Mask on line 3
            #[inline(always)]
            pub fn mr3(&self) -> MR3_R {
                MR3_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - Interrupt Mask on line 4
            #[inline(always)]
            pub fn mr4(&self) -> MR4_R {
                MR4_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - Interrupt Mask on line 5
            #[inline(always)]
            pub fn mr5(&self) -> MR5_R {
                MR5_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - Interrupt Mask on line 6
            #[inline(always)]
            pub fn mr6(&self) -> MR6_R {
                MR6_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - Interrupt Mask on line 7
            #[inline(always)]
            pub fn mr7(&self) -> MR7_R {
                MR7_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bit 8 - Interrupt Mask on line 8
            #[inline(always)]
            pub fn mr8(&self) -> MR8_R {
                MR8_R::new(((self.bits >> 8) & 1) != 0)
            }
            ///Bit 9 - Interrupt Mask on line 9
            #[inline(always)]
            pub fn mr9(&self) -> MR9_R {
                MR9_R::new(((self.bits >> 9) & 1) != 0)
            }
            ///Bit 10 - Interrupt Mask on line 10
            #[inline(always)]
            pub fn mr10(&self) -> MR10_R {
                MR10_R::new(((self.bits >> 10) & 1) != 0)
            }
            ///Bit 11 - Interrupt Mask on line 11
            #[inline(always)]
            pub fn mr11(&self) -> MR11_R {
                MR11_R::new(((self.bits >> 11) & 1) != 0)
            }
            ///Bit 12 - Interrupt Mask on line 12
            #[inline(always)]
            pub fn mr12(&self) -> MR12_R {
                MR12_R::new(((self.bits >> 12) & 1) != 0)
            }
            ///Bit 13 - Interrupt Mask on line 13
            #[inline(always)]
            pub fn mr13(&self) -> MR13_R {
                MR13_R::new(((self.bits >> 13) & 1) != 0)
            }
            ///Bit 14 - Interrupt Mask on line 14
            #[inline(always)]
            pub fn mr14(&self) -> MR14_R {
                MR14_R::new(((self.bits >> 14) & 1) != 0)
            }
            ///Bit 15 - Interrupt Mask on line 15
            #[inline(always)]
            pub fn mr15(&self) -> MR15_R {
                MR15_R::new(((self.bits >> 15) & 1) != 0)
            }
            ///Bit 16 - Interrupt Mask on line 16
            #[inline(always)]
            pub fn mr16(&self) -> MR16_R {
                MR16_R::new(((self.bits >> 16) & 1) != 0)
            }
            ///Bit 17 - Interrupt Mask on line 17
            #[inline(always)]
            pub fn mr17(&self) -> MR17_R {
                MR17_R::new(((self.bits >> 17) & 1) != 0)
            }
            ///Bit 18 - Interrupt Mask on line 18
            #[inline(always)]
            pub fn mr18(&self) -> MR18_R {
                MR18_R::new(((self.bits >> 18) & 1) != 0)
            }
            ///Bit 19 - Interrupt Mask on line 19
            #[inline(always)]
            pub fn mr19(&self) -> MR19_R {
                MR19_R::new(((self.bits >> 19) & 1) != 0)
            }
            ///Bit 20 - Interrupt Mask on line 20
            #[inline(always)]
            pub fn mr20(&self) -> MR20_R {
                MR20_R::new(((self.bits >> 20) & 1) != 0)
            }
            ///Bit 21 - Interrupt Mask on line 21
            #[inline(always)]
            pub fn mr21(&self) -> MR21_R {
                MR21_R::new(((self.bits >> 21) & 1) != 0)
            }
            ///Bit 22 - Interrupt Mask on line 22
            #[inline(always)]
            pub fn mr22(&self) -> MR22_R {
                MR22_R::new(((self.bits >> 22) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - Interrupt Mask on line 0
            #[inline(always)]
            #[must_use]
            pub fn mr0(&mut self) -> MR0_W<INTENR_SPEC> {
                MR0_W::new(self, 0)
            }
            ///Bit 1 - Interrupt Mask on line 1
            #[inline(always)]
            #[must_use]
            pub fn mr1(&mut self) -> MR1_W<INTENR_SPEC> {
                MR1_W::new(self, 1)
            }
            ///Bit 2 - Interrupt Mask on line 2
            #[inline(always)]
            #[must_use]
            pub fn mr2(&mut self) -> MR2_W<INTENR_SPEC> {
                MR2_W::new(self, 2)
            }
            ///Bit 3 - Interrupt Mask on line 3
            #[inline(always)]
            #[must_use]
            pub fn mr3(&mut self) -> MR3_W<INTENR_SPEC> {
                MR3_W::new(self, 3)
            }
            ///Bit 4 - Interrupt Mask on line 4
            #[inline(always)]
            #[must_use]
            pub fn mr4(&mut self) -> MR4_W<INTENR_SPEC> {
                MR4_W::new(self, 4)
            }
            ///Bit 5 - Interrupt Mask on line 5
            #[inline(always)]
            #[must_use]
            pub fn mr5(&mut self) -> MR5_W<INTENR_SPEC> {
                MR5_W::new(self, 5)
            }
            ///Bit 6 - Interrupt Mask on line 6
            #[inline(always)]
            #[must_use]
            pub fn mr6(&mut self) -> MR6_W<INTENR_SPEC> {
                MR6_W::new(self, 6)
            }
            ///Bit 7 - Interrupt Mask on line 7
            #[inline(always)]
            #[must_use]
            pub fn mr7(&mut self) -> MR7_W<INTENR_SPEC> {
                MR7_W::new(self, 7)
            }
            ///Bit 8 - Interrupt Mask on line 8
            #[inline(always)]
            #[must_use]
            pub fn mr8(&mut self) -> MR8_W<INTENR_SPEC> {
                MR8_W::new(self, 8)
            }
            ///Bit 9 - Interrupt Mask on line 9
            #[inline(always)]
            #[must_use]
            pub fn mr9(&mut self) -> MR9_W<INTENR_SPEC> {
                MR9_W::new(self, 9)
            }
            ///Bit 10 - Interrupt Mask on line 10
            #[inline(always)]
            #[must_use]
            pub fn mr10(&mut self) -> MR10_W<INTENR_SPEC> {
                MR10_W::new(self, 10)
            }
            ///Bit 11 - Interrupt Mask on line 11
            #[inline(always)]
            #[must_use]
            pub fn mr11(&mut self) -> MR11_W<INTENR_SPEC> {
                MR11_W::new(self, 11)
            }
            ///Bit 12 - Interrupt Mask on line 12
            #[inline(always)]
            #[must_use]
            pub fn mr12(&mut self) -> MR12_W<INTENR_SPEC> {
                MR12_W::new(self, 12)
            }
            ///Bit 13 - Interrupt Mask on line 13
            #[inline(always)]
            #[must_use]
            pub fn mr13(&mut self) -> MR13_W<INTENR_SPEC> {
                MR13_W::new(self, 13)
            }
            ///Bit 14 - Interrupt Mask on line 14
            #[inline(always)]
            #[must_use]
            pub fn mr14(&mut self) -> MR14_W<INTENR_SPEC> {
                MR14_W::new(self, 14)
            }
            ///Bit 15 - Interrupt Mask on line 15
            #[inline(always)]
            #[must_use]
            pub fn mr15(&mut self) -> MR15_W<INTENR_SPEC> {
                MR15_W::new(self, 15)
            }
            ///Bit 16 - Interrupt Mask on line 16
            #[inline(always)]
            #[must_use]
            pub fn mr16(&mut self) -> MR16_W<INTENR_SPEC> {
                MR16_W::new(self, 16)
            }
            ///Bit 17 - Interrupt Mask on line 17
            #[inline(always)]
            #[must_use]
            pub fn mr17(&mut self) -> MR17_W<INTENR_SPEC> {
                MR17_W::new(self, 17)
            }
            ///Bit 18 - Interrupt Mask on line 18
            #[inline(always)]
            #[must_use]
            pub fn mr18(&mut self) -> MR18_W<INTENR_SPEC> {
                MR18_W::new(self, 18)
            }
            ///Bit 19 - Interrupt Mask on line 19
            #[inline(always)]
            #[must_use]
            pub fn mr19(&mut self) -> MR19_W<INTENR_SPEC> {
                MR19_W::new(self, 19)
            }
            ///Bit 20 - Interrupt Mask on line 20
            #[inline(always)]
            #[must_use]
            pub fn mr20(&mut self) -> MR20_W<INTENR_SPEC> {
                MR20_W::new(self, 20)
            }
            ///Bit 21 - Interrupt Mask on line 21
            #[inline(always)]
            #[must_use]
            pub fn mr21(&mut self) -> MR21_W<INTENR_SPEC> {
                MR21_W::new(self, 21)
            }
            ///Bit 22 - Interrupt Mask on line 22
            #[inline(always)]
            #[must_use]
            pub fn mr22(&mut self) -> MR22_W<INTENR_SPEC> {
                MR22_W::new(self, 22)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt mask register (EXTI_INTENR)
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`intenr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`intenr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct INTENR_SPEC;
        impl crate::RegisterSpec for INTENR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`intenr::R`](R) reader structure
        impl crate::Readable for INTENR_SPEC {}
        ///`write(|w| ..)` method takes [`intenr::W`](W) writer structure
        impl crate::Writable for INTENR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets INTENR to value 0
        impl crate::Resettable for INTENR_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///EVENR (rw) register accessor: Event mask register (EXTI_EVENR)
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`evenr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`evenr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@evenr`]
    ///module
    pub type EVENR = crate::Reg<evenr::EVENR_SPEC>;
    ///Event mask register (EXTI_EVENR)
    pub mod evenr {
        ///Register `EVENR` reader
        pub type R = crate::R<EVENR_SPEC>;
        ///Register `EVENR` writer
        pub type W = crate::W<EVENR_SPEC>;
        ///Field `MR0` reader - Event Mask on line 0
        pub type MR0_R = crate::BitReader;
        ///Field `MR0` writer - Event Mask on line 0
        pub type MR0_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `MR1` reader - Event Mask on line 1
        pub type MR1_R = crate::BitReader;
        ///Field `MR1` writer - Event Mask on line 1
        pub type MR1_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `MR2` reader - Event Mask on line 2
        pub type MR2_R = crate::BitReader;
        ///Field `MR2` writer - Event Mask on line 2
        pub type MR2_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `MR3` reader - Event Mask on line 3
        pub type MR3_R = crate::BitReader;
        ///Field `MR3` writer - Event Mask on line 3
        pub type MR3_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `MR4` reader - Event Mask on line 4
        pub type MR4_R = crate::BitReader;
        ///Field `MR4` writer - Event Mask on line 4
        pub type MR4_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `MR5` reader - Event Mask on line 5
        pub type MR5_R = crate::BitReader;
        ///Field `MR5` writer - Event Mask on line 5
        pub type MR5_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `MR6` reader - Event Mask on line 6
        pub type MR6_R = crate::BitReader;
        ///Field `MR6` writer - Event Mask on line 6
        pub type MR6_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `MR7` reader - Event Mask on line 7
        pub type MR7_R = crate::BitReader;
        ///Field `MR7` writer - Event Mask on line 7
        pub type MR7_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `MR8` reader - Event Mask on line 8
        pub type MR8_R = crate::BitReader;
        ///Field `MR8` writer - Event Mask on line 8
        pub type MR8_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `MR9` reader - Event Mask on line 9
        pub type MR9_R = crate::BitReader;
        ///Field `MR9` writer - Event Mask on line 9
        pub type MR9_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `MR10` reader - Event Mask on line 10
        pub type MR10_R = crate::BitReader;
        ///Field `MR10` writer - Event Mask on line 10
        pub type MR10_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `MR11` reader - Event Mask on line 11
        pub type MR11_R = crate::BitReader;
        ///Field `MR11` writer - Event Mask on line 11
        pub type MR11_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `MR12` reader - Event Mask on line 12
        pub type MR12_R = crate::BitReader;
        ///Field `MR12` writer - Event Mask on line 12
        pub type MR12_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `MR13` reader - Event Mask on line 13
        pub type MR13_R = crate::BitReader;
        ///Field `MR13` writer - Event Mask on line 13
        pub type MR13_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `MR14` reader - Event Mask on line 14
        pub type MR14_R = crate::BitReader;
        ///Field `MR14` writer - Event Mask on line 14
        pub type MR14_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `MR15` reader - Event Mask on line 15
        pub type MR15_R = crate::BitReader;
        ///Field `MR15` writer - Event Mask on line 15
        pub type MR15_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `MR16` reader - Event Mask on line 16
        pub type MR16_R = crate::BitReader;
        ///Field `MR16` writer - Event Mask on line 16
        pub type MR16_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `MR17` reader - Event Mask on line 17
        pub type MR17_R = crate::BitReader;
        ///Field `MR17` writer - Event Mask on line 17
        pub type MR17_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `MR18` reader - Event Mask on line 18
        pub type MR18_R = crate::BitReader;
        ///Field `MR18` writer - Event Mask on line 18
        pub type MR18_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `MR19` reader - Event Mask on line 19
        pub type MR19_R = crate::BitReader;
        ///Field `MR19` writer - Event Mask on line 19
        pub type MR19_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `MR20` reader - Event Mask on line 20
        pub type MR20_R = crate::BitReader;
        ///Field `MR20` writer - Event Mask on line 20
        pub type MR20_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `MR21` reader - Event Mask on line 21
        pub type MR21_R = crate::BitReader;
        ///Field `MR21` writer - Event Mask on line 21
        pub type MR21_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `MR22` reader - Event Mask on line 22
        pub type MR22_R = crate::BitReader;
        ///Field `MR22` writer - Event Mask on line 22
        pub type MR22_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - Event Mask on line 0
            #[inline(always)]
            pub fn mr0(&self) -> MR0_R {
                MR0_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Event Mask on line 1
            #[inline(always)]
            pub fn mr1(&self) -> MR1_R {
                MR1_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - Event Mask on line 2
            #[inline(always)]
            pub fn mr2(&self) -> MR2_R {
                MR2_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - Event Mask on line 3
            #[inline(always)]
            pub fn mr3(&self) -> MR3_R {
                MR3_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - Event Mask on line 4
            #[inline(always)]
            pub fn mr4(&self) -> MR4_R {
                MR4_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - Event Mask on line 5
            #[inline(always)]
            pub fn mr5(&self) -> MR5_R {
                MR5_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - Event Mask on line 6
            #[inline(always)]
            pub fn mr6(&self) -> MR6_R {
                MR6_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - Event Mask on line 7
            #[inline(always)]
            pub fn mr7(&self) -> MR7_R {
                MR7_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bit 8 - Event Mask on line 8
            #[inline(always)]
            pub fn mr8(&self) -> MR8_R {
                MR8_R::new(((self.bits >> 8) & 1) != 0)
            }
            ///Bit 9 - Event Mask on line 9
            #[inline(always)]
            pub fn mr9(&self) -> MR9_R {
                MR9_R::new(((self.bits >> 9) & 1) != 0)
            }
            ///Bit 10 - Event Mask on line 10
            #[inline(always)]
            pub fn mr10(&self) -> MR10_R {
                MR10_R::new(((self.bits >> 10) & 1) != 0)
            }
            ///Bit 11 - Event Mask on line 11
            #[inline(always)]
            pub fn mr11(&self) -> MR11_R {
                MR11_R::new(((self.bits >> 11) & 1) != 0)
            }
            ///Bit 12 - Event Mask on line 12
            #[inline(always)]
            pub fn mr12(&self) -> MR12_R {
                MR12_R::new(((self.bits >> 12) & 1) != 0)
            }
            ///Bit 13 - Event Mask on line 13
            #[inline(always)]
            pub fn mr13(&self) -> MR13_R {
                MR13_R::new(((self.bits >> 13) & 1) != 0)
            }
            ///Bit 14 - Event Mask on line 14
            #[inline(always)]
            pub fn mr14(&self) -> MR14_R {
                MR14_R::new(((self.bits >> 14) & 1) != 0)
            }
            ///Bit 15 - Event Mask on line 15
            #[inline(always)]
            pub fn mr15(&self) -> MR15_R {
                MR15_R::new(((self.bits >> 15) & 1) != 0)
            }
            ///Bit 16 - Event Mask on line 16
            #[inline(always)]
            pub fn mr16(&self) -> MR16_R {
                MR16_R::new(((self.bits >> 16) & 1) != 0)
            }
            ///Bit 17 - Event Mask on line 17
            #[inline(always)]
            pub fn mr17(&self) -> MR17_R {
                MR17_R::new(((self.bits >> 17) & 1) != 0)
            }
            ///Bit 18 - Event Mask on line 18
            #[inline(always)]
            pub fn mr18(&self) -> MR18_R {
                MR18_R::new(((self.bits >> 18) & 1) != 0)
            }
            ///Bit 19 - Event Mask on line 19
            #[inline(always)]
            pub fn mr19(&self) -> MR19_R {
                MR19_R::new(((self.bits >> 19) & 1) != 0)
            }
            ///Bit 20 - Event Mask on line 20
            #[inline(always)]
            pub fn mr20(&self) -> MR20_R {
                MR20_R::new(((self.bits >> 20) & 1) != 0)
            }
            ///Bit 21 - Event Mask on line 21
            #[inline(always)]
            pub fn mr21(&self) -> MR21_R {
                MR21_R::new(((self.bits >> 21) & 1) != 0)
            }
            ///Bit 22 - Event Mask on line 22
            #[inline(always)]
            pub fn mr22(&self) -> MR22_R {
                MR22_R::new(((self.bits >> 22) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - Event Mask on line 0
            #[inline(always)]
            #[must_use]
            pub fn mr0(&mut self) -> MR0_W<EVENR_SPEC> {
                MR0_W::new(self, 0)
            }
            ///Bit 1 - Event Mask on line 1
            #[inline(always)]
            #[must_use]
            pub fn mr1(&mut self) -> MR1_W<EVENR_SPEC> {
                MR1_W::new(self, 1)
            }
            ///Bit 2 - Event Mask on line 2
            #[inline(always)]
            #[must_use]
            pub fn mr2(&mut self) -> MR2_W<EVENR_SPEC> {
                MR2_W::new(self, 2)
            }
            ///Bit 3 - Event Mask on line 3
            #[inline(always)]
            #[must_use]
            pub fn mr3(&mut self) -> MR3_W<EVENR_SPEC> {
                MR3_W::new(self, 3)
            }
            ///Bit 4 - Event Mask on line 4
            #[inline(always)]
            #[must_use]
            pub fn mr4(&mut self) -> MR4_W<EVENR_SPEC> {
                MR4_W::new(self, 4)
            }
            ///Bit 5 - Event Mask on line 5
            #[inline(always)]
            #[must_use]
            pub fn mr5(&mut self) -> MR5_W<EVENR_SPEC> {
                MR5_W::new(self, 5)
            }
            ///Bit 6 - Event Mask on line 6
            #[inline(always)]
            #[must_use]
            pub fn mr6(&mut self) -> MR6_W<EVENR_SPEC> {
                MR6_W::new(self, 6)
            }
            ///Bit 7 - Event Mask on line 7
            #[inline(always)]
            #[must_use]
            pub fn mr7(&mut self) -> MR7_W<EVENR_SPEC> {
                MR7_W::new(self, 7)
            }
            ///Bit 8 - Event Mask on line 8
            #[inline(always)]
            #[must_use]
            pub fn mr8(&mut self) -> MR8_W<EVENR_SPEC> {
                MR8_W::new(self, 8)
            }
            ///Bit 9 - Event Mask on line 9
            #[inline(always)]
            #[must_use]
            pub fn mr9(&mut self) -> MR9_W<EVENR_SPEC> {
                MR9_W::new(self, 9)
            }
            ///Bit 10 - Event Mask on line 10
            #[inline(always)]
            #[must_use]
            pub fn mr10(&mut self) -> MR10_W<EVENR_SPEC> {
                MR10_W::new(self, 10)
            }
            ///Bit 11 - Event Mask on line 11
            #[inline(always)]
            #[must_use]
            pub fn mr11(&mut self) -> MR11_W<EVENR_SPEC> {
                MR11_W::new(self, 11)
            }
            ///Bit 12 - Event Mask on line 12
            #[inline(always)]
            #[must_use]
            pub fn mr12(&mut self) -> MR12_W<EVENR_SPEC> {
                MR12_W::new(self, 12)
            }
            ///Bit 13 - Event Mask on line 13
            #[inline(always)]
            #[must_use]
            pub fn mr13(&mut self) -> MR13_W<EVENR_SPEC> {
                MR13_W::new(self, 13)
            }
            ///Bit 14 - Event Mask on line 14
            #[inline(always)]
            #[must_use]
            pub fn mr14(&mut self) -> MR14_W<EVENR_SPEC> {
                MR14_W::new(self, 14)
            }
            ///Bit 15 - Event Mask on line 15
            #[inline(always)]
            #[must_use]
            pub fn mr15(&mut self) -> MR15_W<EVENR_SPEC> {
                MR15_W::new(self, 15)
            }
            ///Bit 16 - Event Mask on line 16
            #[inline(always)]
            #[must_use]
            pub fn mr16(&mut self) -> MR16_W<EVENR_SPEC> {
                MR16_W::new(self, 16)
            }
            ///Bit 17 - Event Mask on line 17
            #[inline(always)]
            #[must_use]
            pub fn mr17(&mut self) -> MR17_W<EVENR_SPEC> {
                MR17_W::new(self, 17)
            }
            ///Bit 18 - Event Mask on line 18
            #[inline(always)]
            #[must_use]
            pub fn mr18(&mut self) -> MR18_W<EVENR_SPEC> {
                MR18_W::new(self, 18)
            }
            ///Bit 19 - Event Mask on line 19
            #[inline(always)]
            #[must_use]
            pub fn mr19(&mut self) -> MR19_W<EVENR_SPEC> {
                MR19_W::new(self, 19)
            }
            ///Bit 20 - Event Mask on line 20
            #[inline(always)]
            #[must_use]
            pub fn mr20(&mut self) -> MR20_W<EVENR_SPEC> {
                MR20_W::new(self, 20)
            }
            ///Bit 21 - Event Mask on line 21
            #[inline(always)]
            #[must_use]
            pub fn mr21(&mut self) -> MR21_W<EVENR_SPEC> {
                MR21_W::new(self, 21)
            }
            ///Bit 22 - Event Mask on line 22
            #[inline(always)]
            #[must_use]
            pub fn mr22(&mut self) -> MR22_W<EVENR_SPEC> {
                MR22_W::new(self, 22)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Event mask register (EXTI_EVENR)
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`evenr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`evenr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct EVENR_SPEC;
        impl crate::RegisterSpec for EVENR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`evenr::R`](R) reader structure
        impl crate::Readable for EVENR_SPEC {}
        ///`write(|w| ..)` method takes [`evenr::W`](W) writer structure
        impl crate::Writable for EVENR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets EVENR to value 0
        impl crate::Resettable for EVENR_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///RTENR (rw) register accessor: Rising Trigger selection register (EXTI_RTENR)
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`rtenr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`rtenr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@rtenr`]
    ///module
    pub type RTENR = crate::Reg<rtenr::RTENR_SPEC>;
    ///Rising Trigger selection register (EXTI_RTENR)
    pub mod rtenr {
        ///Register `RTENR` reader
        pub type R = crate::R<RTENR_SPEC>;
        ///Register `RTENR` writer
        pub type W = crate::W<RTENR_SPEC>;
        ///Field `TR0` reader - Rising trigger event configuration of line 0
        pub type TR0_R = crate::BitReader;
        ///Field `TR0` writer - Rising trigger event configuration of line 0
        pub type TR0_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TR1` reader - Rising trigger event configuration of line 1
        pub type TR1_R = crate::BitReader;
        ///Field `TR1` writer - Rising trigger event configuration of line 1
        pub type TR1_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TR2` reader - Rising trigger event configuration of line 2
        pub type TR2_R = crate::BitReader;
        ///Field `TR2` writer - Rising trigger event configuration of line 2
        pub type TR2_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TR3` reader - Rising trigger event configuration of line 3
        pub type TR3_R = crate::BitReader;
        ///Field `TR3` writer - Rising trigger event configuration of line 3
        pub type TR3_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TR4` reader - Rising trigger event configuration of line 4
        pub type TR4_R = crate::BitReader;
        ///Field `TR4` writer - Rising trigger event configuration of line 4
        pub type TR4_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TR5` reader - Rising trigger event configuration of line 5
        pub type TR5_R = crate::BitReader;
        ///Field `TR5` writer - Rising trigger event configuration of line 5
        pub type TR5_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TR6` reader - Rising trigger event configuration of line 6
        pub type TR6_R = crate::BitReader;
        ///Field `TR6` writer - Rising trigger event configuration of line 6
        pub type TR6_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TR7` reader - Rising trigger event configuration of line 7
        pub type TR7_R = crate::BitReader;
        ///Field `TR7` writer - Rising trigger event configuration of line 7
        pub type TR7_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TR8` reader - Rising trigger event configuration of line 8
        pub type TR8_R = crate::BitReader;
        ///Field `TR8` writer - Rising trigger event configuration of line 8
        pub type TR8_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TR9` reader - Rising trigger event configuration of line 9
        pub type TR9_R = crate::BitReader;
        ///Field `TR9` writer - Rising trigger event configuration of line 9
        pub type TR9_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TR10` reader - Rising trigger event configuration of line 10
        pub type TR10_R = crate::BitReader;
        ///Field `TR10` writer - Rising trigger event configuration of line 10
        pub type TR10_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TR11` reader - Rising trigger event configuration of line 11
        pub type TR11_R = crate::BitReader;
        ///Field `TR11` writer - Rising trigger event configuration of line 11
        pub type TR11_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TR12` reader - Rising trigger event configuration of line 12
        pub type TR12_R = crate::BitReader;
        ///Field `TR12` writer - Rising trigger event configuration of line 12
        pub type TR12_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TR13` reader - Rising trigger event configuration of line 13
        pub type TR13_R = crate::BitReader;
        ///Field `TR13` writer - Rising trigger event configuration of line 13
        pub type TR13_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TR14` reader - Rising trigger event configuration of line 14
        pub type TR14_R = crate::BitReader;
        ///Field `TR14` writer - Rising trigger event configuration of line 14
        pub type TR14_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TR15` reader - Rising trigger event configuration of line 15
        pub type TR15_R = crate::BitReader;
        ///Field `TR15` writer - Rising trigger event configuration of line 15
        pub type TR15_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TR16` reader - Rising trigger event configuration of line 16
        pub type TR16_R = crate::BitReader;
        ///Field `TR16` writer - Rising trigger event configuration of line 16
        pub type TR16_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TR17` reader - Rising trigger event configuration of line 17
        pub type TR17_R = crate::BitReader;
        ///Field `TR17` writer - Rising trigger event configuration of line 17
        pub type TR17_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TR18` reader - Rising trigger event configuration of line 18
        pub type TR18_R = crate::BitReader;
        ///Field `TR18` writer - Rising trigger event configuration of line 18
        pub type TR18_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TR19` reader - Rising trigger event configuration of line 19
        pub type TR19_R = crate::BitReader;
        ///Field `TR19` writer - Rising trigger event configuration of line 19
        pub type TR19_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TR20` reader - Rising trigger event configuration of line 20
        pub type TR20_R = crate::BitReader;
        ///Field `TR20` writer - Rising trigger event configuration of line 20
        pub type TR20_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TR21` reader - Rising trigger event configuration of line 21
        pub type TR21_R = crate::BitReader;
        ///Field `TR21` writer - Rising trigger event configuration of line 21
        pub type TR21_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TR22` reader - Rising trigger event configuration of line 22
        pub type TR22_R = crate::BitReader;
        ///Field `TR22` writer - Rising trigger event configuration of line 22
        pub type TR22_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - Rising trigger event configuration of line 0
            #[inline(always)]
            pub fn tr0(&self) -> TR0_R {
                TR0_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Rising trigger event configuration of line 1
            #[inline(always)]
            pub fn tr1(&self) -> TR1_R {
                TR1_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - Rising trigger event configuration of line 2
            #[inline(always)]
            pub fn tr2(&self) -> TR2_R {
                TR2_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - Rising trigger event configuration of line 3
            #[inline(always)]
            pub fn tr3(&self) -> TR3_R {
                TR3_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - Rising trigger event configuration of line 4
            #[inline(always)]
            pub fn tr4(&self) -> TR4_R {
                TR4_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - Rising trigger event configuration of line 5
            #[inline(always)]
            pub fn tr5(&self) -> TR5_R {
                TR5_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - Rising trigger event configuration of line 6
            #[inline(always)]
            pub fn tr6(&self) -> TR6_R {
                TR6_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - Rising trigger event configuration of line 7
            #[inline(always)]
            pub fn tr7(&self) -> TR7_R {
                TR7_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bit 8 - Rising trigger event configuration of line 8
            #[inline(always)]
            pub fn tr8(&self) -> TR8_R {
                TR8_R::new(((self.bits >> 8) & 1) != 0)
            }
            ///Bit 9 - Rising trigger event configuration of line 9
            #[inline(always)]
            pub fn tr9(&self) -> TR9_R {
                TR9_R::new(((self.bits >> 9) & 1) != 0)
            }
            ///Bit 10 - Rising trigger event configuration of line 10
            #[inline(always)]
            pub fn tr10(&self) -> TR10_R {
                TR10_R::new(((self.bits >> 10) & 1) != 0)
            }
            ///Bit 11 - Rising trigger event configuration of line 11
            #[inline(always)]
            pub fn tr11(&self) -> TR11_R {
                TR11_R::new(((self.bits >> 11) & 1) != 0)
            }
            ///Bit 12 - Rising trigger event configuration of line 12
            #[inline(always)]
            pub fn tr12(&self) -> TR12_R {
                TR12_R::new(((self.bits >> 12) & 1) != 0)
            }
            ///Bit 13 - Rising trigger event configuration of line 13
            #[inline(always)]
            pub fn tr13(&self) -> TR13_R {
                TR13_R::new(((self.bits >> 13) & 1) != 0)
            }
            ///Bit 14 - Rising trigger event configuration of line 14
            #[inline(always)]
            pub fn tr14(&self) -> TR14_R {
                TR14_R::new(((self.bits >> 14) & 1) != 0)
            }
            ///Bit 15 - Rising trigger event configuration of line 15
            #[inline(always)]
            pub fn tr15(&self) -> TR15_R {
                TR15_R::new(((self.bits >> 15) & 1) != 0)
            }
            ///Bit 16 - Rising trigger event configuration of line 16
            #[inline(always)]
            pub fn tr16(&self) -> TR16_R {
                TR16_R::new(((self.bits >> 16) & 1) != 0)
            }
            ///Bit 17 - Rising trigger event configuration of line 17
            #[inline(always)]
            pub fn tr17(&self) -> TR17_R {
                TR17_R::new(((self.bits >> 17) & 1) != 0)
            }
            ///Bit 18 - Rising trigger event configuration of line 18
            #[inline(always)]
            pub fn tr18(&self) -> TR18_R {
                TR18_R::new(((self.bits >> 18) & 1) != 0)
            }
            ///Bit 19 - Rising trigger event configuration of line 19
            #[inline(always)]
            pub fn tr19(&self) -> TR19_R {
                TR19_R::new(((self.bits >> 19) & 1) != 0)
            }
            ///Bit 20 - Rising trigger event configuration of line 20
            #[inline(always)]
            pub fn tr20(&self) -> TR20_R {
                TR20_R::new(((self.bits >> 20) & 1) != 0)
            }
            ///Bit 21 - Rising trigger event configuration of line 21
            #[inline(always)]
            pub fn tr21(&self) -> TR21_R {
                TR21_R::new(((self.bits >> 21) & 1) != 0)
            }
            ///Bit 22 - Rising trigger event configuration of line 22
            #[inline(always)]
            pub fn tr22(&self) -> TR22_R {
                TR22_R::new(((self.bits >> 22) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - Rising trigger event configuration of line 0
            #[inline(always)]
            #[must_use]
            pub fn tr0(&mut self) -> TR0_W<RTENR_SPEC> {
                TR0_W::new(self, 0)
            }
            ///Bit 1 - Rising trigger event configuration of line 1
            #[inline(always)]
            #[must_use]
            pub fn tr1(&mut self) -> TR1_W<RTENR_SPEC> {
                TR1_W::new(self, 1)
            }
            ///Bit 2 - Rising trigger event configuration of line 2
            #[inline(always)]
            #[must_use]
            pub fn tr2(&mut self) -> TR2_W<RTENR_SPEC> {
                TR2_W::new(self, 2)
            }
            ///Bit 3 - Rising trigger event configuration of line 3
            #[inline(always)]
            #[must_use]
            pub fn tr3(&mut self) -> TR3_W<RTENR_SPEC> {
                TR3_W::new(self, 3)
            }
            ///Bit 4 - Rising trigger event configuration of line 4
            #[inline(always)]
            #[must_use]
            pub fn tr4(&mut self) -> TR4_W<RTENR_SPEC> {
                TR4_W::new(self, 4)
            }
            ///Bit 5 - Rising trigger event configuration of line 5
            #[inline(always)]
            #[must_use]
            pub fn tr5(&mut self) -> TR5_W<RTENR_SPEC> {
                TR5_W::new(self, 5)
            }
            ///Bit 6 - Rising trigger event configuration of line 6
            #[inline(always)]
            #[must_use]
            pub fn tr6(&mut self) -> TR6_W<RTENR_SPEC> {
                TR6_W::new(self, 6)
            }
            ///Bit 7 - Rising trigger event configuration of line 7
            #[inline(always)]
            #[must_use]
            pub fn tr7(&mut self) -> TR7_W<RTENR_SPEC> {
                TR7_W::new(self, 7)
            }
            ///Bit 8 - Rising trigger event configuration of line 8
            #[inline(always)]
            #[must_use]
            pub fn tr8(&mut self) -> TR8_W<RTENR_SPEC> {
                TR8_W::new(self, 8)
            }
            ///Bit 9 - Rising trigger event configuration of line 9
            #[inline(always)]
            #[must_use]
            pub fn tr9(&mut self) -> TR9_W<RTENR_SPEC> {
                TR9_W::new(self, 9)
            }
            ///Bit 10 - Rising trigger event configuration of line 10
            #[inline(always)]
            #[must_use]
            pub fn tr10(&mut self) -> TR10_W<RTENR_SPEC> {
                TR10_W::new(self, 10)
            }
            ///Bit 11 - Rising trigger event configuration of line 11
            #[inline(always)]
            #[must_use]
            pub fn tr11(&mut self) -> TR11_W<RTENR_SPEC> {
                TR11_W::new(self, 11)
            }
            ///Bit 12 - Rising trigger event configuration of line 12
            #[inline(always)]
            #[must_use]
            pub fn tr12(&mut self) -> TR12_W<RTENR_SPEC> {
                TR12_W::new(self, 12)
            }
            ///Bit 13 - Rising trigger event configuration of line 13
            #[inline(always)]
            #[must_use]
            pub fn tr13(&mut self) -> TR13_W<RTENR_SPEC> {
                TR13_W::new(self, 13)
            }
            ///Bit 14 - Rising trigger event configuration of line 14
            #[inline(always)]
            #[must_use]
            pub fn tr14(&mut self) -> TR14_W<RTENR_SPEC> {
                TR14_W::new(self, 14)
            }
            ///Bit 15 - Rising trigger event configuration of line 15
            #[inline(always)]
            #[must_use]
            pub fn tr15(&mut self) -> TR15_W<RTENR_SPEC> {
                TR15_W::new(self, 15)
            }
            ///Bit 16 - Rising trigger event configuration of line 16
            #[inline(always)]
            #[must_use]
            pub fn tr16(&mut self) -> TR16_W<RTENR_SPEC> {
                TR16_W::new(self, 16)
            }
            ///Bit 17 - Rising trigger event configuration of line 17
            #[inline(always)]
            #[must_use]
            pub fn tr17(&mut self) -> TR17_W<RTENR_SPEC> {
                TR17_W::new(self, 17)
            }
            ///Bit 18 - Rising trigger event configuration of line 18
            #[inline(always)]
            #[must_use]
            pub fn tr18(&mut self) -> TR18_W<RTENR_SPEC> {
                TR18_W::new(self, 18)
            }
            ///Bit 19 - Rising trigger event configuration of line 19
            #[inline(always)]
            #[must_use]
            pub fn tr19(&mut self) -> TR19_W<RTENR_SPEC> {
                TR19_W::new(self, 19)
            }
            ///Bit 20 - Rising trigger event configuration of line 20
            #[inline(always)]
            #[must_use]
            pub fn tr20(&mut self) -> TR20_W<RTENR_SPEC> {
                TR20_W::new(self, 20)
            }
            ///Bit 21 - Rising trigger event configuration of line 21
            #[inline(always)]
            #[must_use]
            pub fn tr21(&mut self) -> TR21_W<RTENR_SPEC> {
                TR21_W::new(self, 21)
            }
            ///Bit 22 - Rising trigger event configuration of line 22
            #[inline(always)]
            #[must_use]
            pub fn tr22(&mut self) -> TR22_W<RTENR_SPEC> {
                TR22_W::new(self, 22)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Rising Trigger selection register (EXTI_RTENR)
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`rtenr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`rtenr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct RTENR_SPEC;
        impl crate::RegisterSpec for RTENR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`rtenr::R`](R) reader structure
        impl crate::Readable for RTENR_SPEC {}
        ///`write(|w| ..)` method takes [`rtenr::W`](W) writer structure
        impl crate::Writable for RTENR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets RTENR to value 0
        impl crate::Resettable for RTENR_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///FTENR (rw) register accessor: Falling Trigger selection register (EXTI_FTENR)
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`ftenr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ftenr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@ftenr`]
    ///module
    pub type FTENR = crate::Reg<ftenr::FTENR_SPEC>;
    ///Falling Trigger selection register (EXTI_FTENR)
    pub mod ftenr {
        ///Register `FTENR` reader
        pub type R = crate::R<FTENR_SPEC>;
        ///Register `FTENR` writer
        pub type W = crate::W<FTENR_SPEC>;
        ///Field `TR0` reader - Falling trigger event configuration of line 0
        pub type TR0_R = crate::BitReader;
        ///Field `TR0` writer - Falling trigger event configuration of line 0
        pub type TR0_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TR1` reader - Falling trigger event configuration of line 1
        pub type TR1_R = crate::BitReader;
        ///Field `TR1` writer - Falling trigger event configuration of line 1
        pub type TR1_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TR2` reader - Falling trigger event configuration of line 2
        pub type TR2_R = crate::BitReader;
        ///Field `TR2` writer - Falling trigger event configuration of line 2
        pub type TR2_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TR3` reader - Falling trigger event configuration of line 3
        pub type TR3_R = crate::BitReader;
        ///Field `TR3` writer - Falling trigger event configuration of line 3
        pub type TR3_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TR4` reader - Falling trigger event configuration of line 4
        pub type TR4_R = crate::BitReader;
        ///Field `TR4` writer - Falling trigger event configuration of line 4
        pub type TR4_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TR5` reader - Falling trigger event configuration of line 5
        pub type TR5_R = crate::BitReader;
        ///Field `TR5` writer - Falling trigger event configuration of line 5
        pub type TR5_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TR6` reader - Falling trigger event configuration of line 6
        pub type TR6_R = crate::BitReader;
        ///Field `TR6` writer - Falling trigger event configuration of line 6
        pub type TR6_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TR7` reader - Falling trigger event configuration of line 7
        pub type TR7_R = crate::BitReader;
        ///Field `TR7` writer - Falling trigger event configuration of line 7
        pub type TR7_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TR8` reader - Falling trigger event configuration of line 8
        pub type TR8_R = crate::BitReader;
        ///Field `TR8` writer - Falling trigger event configuration of line 8
        pub type TR8_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TR9` reader - Falling trigger event configuration of line 9
        pub type TR9_R = crate::BitReader;
        ///Field `TR9` writer - Falling trigger event configuration of line 9
        pub type TR9_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TR10` reader - Falling trigger event configuration of line 10
        pub type TR10_R = crate::BitReader;
        ///Field `TR10` writer - Falling trigger event configuration of line 10
        pub type TR10_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TR11` reader - Falling trigger event configuration of line 11
        pub type TR11_R = crate::BitReader;
        ///Field `TR11` writer - Falling trigger event configuration of line 11
        pub type TR11_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TR12` reader - Falling trigger event configuration of line 12
        pub type TR12_R = crate::BitReader;
        ///Field `TR12` writer - Falling trigger event configuration of line 12
        pub type TR12_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TR13` reader - Falling trigger event configuration of line 13
        pub type TR13_R = crate::BitReader;
        ///Field `TR13` writer - Falling trigger event configuration of line 13
        pub type TR13_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TR14` reader - Falling trigger event configuration of line 14
        pub type TR14_R = crate::BitReader;
        ///Field `TR14` writer - Falling trigger event configuration of line 14
        pub type TR14_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TR15` reader - Falling trigger event configuration of line 15
        pub type TR15_R = crate::BitReader;
        ///Field `TR15` writer - Falling trigger event configuration of line 15
        pub type TR15_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TR16` reader - Falling trigger event configuration of line 16
        pub type TR16_R = crate::BitReader;
        ///Field `TR16` writer - Falling trigger event configuration of line 16
        pub type TR16_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TR17` reader - Falling trigger event configuration of line 17
        pub type TR17_R = crate::BitReader;
        ///Field `TR17` writer - Falling trigger event configuration of line 17
        pub type TR17_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TR18` reader - Falling trigger event configuration of line 18
        pub type TR18_R = crate::BitReader;
        ///Field `TR18` writer - Falling trigger event configuration of line 18
        pub type TR18_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TR19` reader - Falling trigger event configuration of line 19
        pub type TR19_R = crate::BitReader;
        ///Field `TR19` writer - Falling trigger event configuration of line 19
        pub type TR19_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TR20` reader - Falling trigger event configuration of line 20
        pub type TR20_R = crate::BitReader;
        ///Field `TR20` writer - Falling trigger event configuration of line 20
        pub type TR20_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TR21` reader - Falling trigger event configuration of line 21
        pub type TR21_R = crate::BitReader;
        ///Field `TR21` writer - Falling trigger event configuration of line 21
        pub type TR21_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TR22` reader - Falling trigger event configuration of line 22
        pub type TR22_R = crate::BitReader;
        ///Field `TR22` writer - Falling trigger event configuration of line 22
        pub type TR22_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - Falling trigger event configuration of line 0
            #[inline(always)]
            pub fn tr0(&self) -> TR0_R {
                TR0_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Falling trigger event configuration of line 1
            #[inline(always)]
            pub fn tr1(&self) -> TR1_R {
                TR1_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - Falling trigger event configuration of line 2
            #[inline(always)]
            pub fn tr2(&self) -> TR2_R {
                TR2_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - Falling trigger event configuration of line 3
            #[inline(always)]
            pub fn tr3(&self) -> TR3_R {
                TR3_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - Falling trigger event configuration of line 4
            #[inline(always)]
            pub fn tr4(&self) -> TR4_R {
                TR4_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - Falling trigger event configuration of line 5
            #[inline(always)]
            pub fn tr5(&self) -> TR5_R {
                TR5_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - Falling trigger event configuration of line 6
            #[inline(always)]
            pub fn tr6(&self) -> TR6_R {
                TR6_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - Falling trigger event configuration of line 7
            #[inline(always)]
            pub fn tr7(&self) -> TR7_R {
                TR7_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bit 8 - Falling trigger event configuration of line 8
            #[inline(always)]
            pub fn tr8(&self) -> TR8_R {
                TR8_R::new(((self.bits >> 8) & 1) != 0)
            }
            ///Bit 9 - Falling trigger event configuration of line 9
            #[inline(always)]
            pub fn tr9(&self) -> TR9_R {
                TR9_R::new(((self.bits >> 9) & 1) != 0)
            }
            ///Bit 10 - Falling trigger event configuration of line 10
            #[inline(always)]
            pub fn tr10(&self) -> TR10_R {
                TR10_R::new(((self.bits >> 10) & 1) != 0)
            }
            ///Bit 11 - Falling trigger event configuration of line 11
            #[inline(always)]
            pub fn tr11(&self) -> TR11_R {
                TR11_R::new(((self.bits >> 11) & 1) != 0)
            }
            ///Bit 12 - Falling trigger event configuration of line 12
            #[inline(always)]
            pub fn tr12(&self) -> TR12_R {
                TR12_R::new(((self.bits >> 12) & 1) != 0)
            }
            ///Bit 13 - Falling trigger event configuration of line 13
            #[inline(always)]
            pub fn tr13(&self) -> TR13_R {
                TR13_R::new(((self.bits >> 13) & 1) != 0)
            }
            ///Bit 14 - Falling trigger event configuration of line 14
            #[inline(always)]
            pub fn tr14(&self) -> TR14_R {
                TR14_R::new(((self.bits >> 14) & 1) != 0)
            }
            ///Bit 15 - Falling trigger event configuration of line 15
            #[inline(always)]
            pub fn tr15(&self) -> TR15_R {
                TR15_R::new(((self.bits >> 15) & 1) != 0)
            }
            ///Bit 16 - Falling trigger event configuration of line 16
            #[inline(always)]
            pub fn tr16(&self) -> TR16_R {
                TR16_R::new(((self.bits >> 16) & 1) != 0)
            }
            ///Bit 17 - Falling trigger event configuration of line 17
            #[inline(always)]
            pub fn tr17(&self) -> TR17_R {
                TR17_R::new(((self.bits >> 17) & 1) != 0)
            }
            ///Bit 18 - Falling trigger event configuration of line 18
            #[inline(always)]
            pub fn tr18(&self) -> TR18_R {
                TR18_R::new(((self.bits >> 18) & 1) != 0)
            }
            ///Bit 19 - Falling trigger event configuration of line 19
            #[inline(always)]
            pub fn tr19(&self) -> TR19_R {
                TR19_R::new(((self.bits >> 19) & 1) != 0)
            }
            ///Bit 20 - Falling trigger event configuration of line 20
            #[inline(always)]
            pub fn tr20(&self) -> TR20_R {
                TR20_R::new(((self.bits >> 20) & 1) != 0)
            }
            ///Bit 21 - Falling trigger event configuration of line 21
            #[inline(always)]
            pub fn tr21(&self) -> TR21_R {
                TR21_R::new(((self.bits >> 21) & 1) != 0)
            }
            ///Bit 22 - Falling trigger event configuration of line 22
            #[inline(always)]
            pub fn tr22(&self) -> TR22_R {
                TR22_R::new(((self.bits >> 22) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - Falling trigger event configuration of line 0
            #[inline(always)]
            #[must_use]
            pub fn tr0(&mut self) -> TR0_W<FTENR_SPEC> {
                TR0_W::new(self, 0)
            }
            ///Bit 1 - Falling trigger event configuration of line 1
            #[inline(always)]
            #[must_use]
            pub fn tr1(&mut self) -> TR1_W<FTENR_SPEC> {
                TR1_W::new(self, 1)
            }
            ///Bit 2 - Falling trigger event configuration of line 2
            #[inline(always)]
            #[must_use]
            pub fn tr2(&mut self) -> TR2_W<FTENR_SPEC> {
                TR2_W::new(self, 2)
            }
            ///Bit 3 - Falling trigger event configuration of line 3
            #[inline(always)]
            #[must_use]
            pub fn tr3(&mut self) -> TR3_W<FTENR_SPEC> {
                TR3_W::new(self, 3)
            }
            ///Bit 4 - Falling trigger event configuration of line 4
            #[inline(always)]
            #[must_use]
            pub fn tr4(&mut self) -> TR4_W<FTENR_SPEC> {
                TR4_W::new(self, 4)
            }
            ///Bit 5 - Falling trigger event configuration of line 5
            #[inline(always)]
            #[must_use]
            pub fn tr5(&mut self) -> TR5_W<FTENR_SPEC> {
                TR5_W::new(self, 5)
            }
            ///Bit 6 - Falling trigger event configuration of line 6
            #[inline(always)]
            #[must_use]
            pub fn tr6(&mut self) -> TR6_W<FTENR_SPEC> {
                TR6_W::new(self, 6)
            }
            ///Bit 7 - Falling trigger event configuration of line 7
            #[inline(always)]
            #[must_use]
            pub fn tr7(&mut self) -> TR7_W<FTENR_SPEC> {
                TR7_W::new(self, 7)
            }
            ///Bit 8 - Falling trigger event configuration of line 8
            #[inline(always)]
            #[must_use]
            pub fn tr8(&mut self) -> TR8_W<FTENR_SPEC> {
                TR8_W::new(self, 8)
            }
            ///Bit 9 - Falling trigger event configuration of line 9
            #[inline(always)]
            #[must_use]
            pub fn tr9(&mut self) -> TR9_W<FTENR_SPEC> {
                TR9_W::new(self, 9)
            }
            ///Bit 10 - Falling trigger event configuration of line 10
            #[inline(always)]
            #[must_use]
            pub fn tr10(&mut self) -> TR10_W<FTENR_SPEC> {
                TR10_W::new(self, 10)
            }
            ///Bit 11 - Falling trigger event configuration of line 11
            #[inline(always)]
            #[must_use]
            pub fn tr11(&mut self) -> TR11_W<FTENR_SPEC> {
                TR11_W::new(self, 11)
            }
            ///Bit 12 - Falling trigger event configuration of line 12
            #[inline(always)]
            #[must_use]
            pub fn tr12(&mut self) -> TR12_W<FTENR_SPEC> {
                TR12_W::new(self, 12)
            }
            ///Bit 13 - Falling trigger event configuration of line 13
            #[inline(always)]
            #[must_use]
            pub fn tr13(&mut self) -> TR13_W<FTENR_SPEC> {
                TR13_W::new(self, 13)
            }
            ///Bit 14 - Falling trigger event configuration of line 14
            #[inline(always)]
            #[must_use]
            pub fn tr14(&mut self) -> TR14_W<FTENR_SPEC> {
                TR14_W::new(self, 14)
            }
            ///Bit 15 - Falling trigger event configuration of line 15
            #[inline(always)]
            #[must_use]
            pub fn tr15(&mut self) -> TR15_W<FTENR_SPEC> {
                TR15_W::new(self, 15)
            }
            ///Bit 16 - Falling trigger event configuration of line 16
            #[inline(always)]
            #[must_use]
            pub fn tr16(&mut self) -> TR16_W<FTENR_SPEC> {
                TR16_W::new(self, 16)
            }
            ///Bit 17 - Falling trigger event configuration of line 17
            #[inline(always)]
            #[must_use]
            pub fn tr17(&mut self) -> TR17_W<FTENR_SPEC> {
                TR17_W::new(self, 17)
            }
            ///Bit 18 - Falling trigger event configuration of line 18
            #[inline(always)]
            #[must_use]
            pub fn tr18(&mut self) -> TR18_W<FTENR_SPEC> {
                TR18_W::new(self, 18)
            }
            ///Bit 19 - Falling trigger event configuration of line 19
            #[inline(always)]
            #[must_use]
            pub fn tr19(&mut self) -> TR19_W<FTENR_SPEC> {
                TR19_W::new(self, 19)
            }
            ///Bit 20 - Falling trigger event configuration of line 20
            #[inline(always)]
            #[must_use]
            pub fn tr20(&mut self) -> TR20_W<FTENR_SPEC> {
                TR20_W::new(self, 20)
            }
            ///Bit 21 - Falling trigger event configuration of line 21
            #[inline(always)]
            #[must_use]
            pub fn tr21(&mut self) -> TR21_W<FTENR_SPEC> {
                TR21_W::new(self, 21)
            }
            ///Bit 22 - Falling trigger event configuration of line 22
            #[inline(always)]
            #[must_use]
            pub fn tr22(&mut self) -> TR22_W<FTENR_SPEC> {
                TR22_W::new(self, 22)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Falling Trigger selection register (EXTI_FTENR)
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`ftenr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ftenr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct FTENR_SPEC;
        impl crate::RegisterSpec for FTENR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`ftenr::R`](R) reader structure
        impl crate::Readable for FTENR_SPEC {}
        ///`write(|w| ..)` method takes [`ftenr::W`](W) writer structure
        impl crate::Writable for FTENR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets FTENR to value 0
        impl crate::Resettable for FTENR_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///SWIEVR (rw) register accessor: Software interrupt event register (EXTI_SWIEVR)
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`swievr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`swievr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@swievr`]
    ///module
    pub type SWIEVR = crate::Reg<swievr::SWIEVR_SPEC>;
    ///Software interrupt event register (EXTI_SWIEVR)
    pub mod swievr {
        ///Register `SWIEVR` reader
        pub type R = crate::R<SWIEVR_SPEC>;
        ///Register `SWIEVR` writer
        pub type W = crate::W<SWIEVR_SPEC>;
        ///Field `SWIER0` reader - Software Interrupt on line 0
        pub type SWIER0_R = crate::BitReader;
        ///Field `SWIER0` writer - Software Interrupt on line 0
        pub type SWIER0_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `SWIER1` reader - Software Interrupt on line 1
        pub type SWIER1_R = crate::BitReader;
        ///Field `SWIER1` writer - Software Interrupt on line 1
        pub type SWIER1_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `SWIER2` reader - Software Interrupt on line 2
        pub type SWIER2_R = crate::BitReader;
        ///Field `SWIER2` writer - Software Interrupt on line 2
        pub type SWIER2_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `SWIER3` reader - Software Interrupt on line 3
        pub type SWIER3_R = crate::BitReader;
        ///Field `SWIER3` writer - Software Interrupt on line 3
        pub type SWIER3_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `SWIER4` reader - Software Interrupt on line 4
        pub type SWIER4_R = crate::BitReader;
        ///Field `SWIER4` writer - Software Interrupt on line 4
        pub type SWIER4_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `SWIER5` reader - Software Interrupt on line 5
        pub type SWIER5_R = crate::BitReader;
        ///Field `SWIER5` writer - Software Interrupt on line 5
        pub type SWIER5_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `SWIER6` reader - Software Interrupt on line 6
        pub type SWIER6_R = crate::BitReader;
        ///Field `SWIER6` writer - Software Interrupt on line 6
        pub type SWIER6_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `SWIER7` reader - Software Interrupt on line 7
        pub type SWIER7_R = crate::BitReader;
        ///Field `SWIER7` writer - Software Interrupt on line 7
        pub type SWIER7_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `SWIER8` reader - Software Interrupt on line 8
        pub type SWIER8_R = crate::BitReader;
        ///Field `SWIER8` writer - Software Interrupt on line 8
        pub type SWIER8_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `SWIER9` reader - Software Interrupt on line 9
        pub type SWIER9_R = crate::BitReader;
        ///Field `SWIER9` writer - Software Interrupt on line 9
        pub type SWIER9_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `SWIER10` reader - Software Interrupt on line 10
        pub type SWIER10_R = crate::BitReader;
        ///Field `SWIER10` writer - Software Interrupt on line 10
        pub type SWIER10_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `SWIER11` reader - Software Interrupt on line 11
        pub type SWIER11_R = crate::BitReader;
        ///Field `SWIER11` writer - Software Interrupt on line 11
        pub type SWIER11_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `SWIER12` reader - Software Interrupt on line 12
        pub type SWIER12_R = crate::BitReader;
        ///Field `SWIER12` writer - Software Interrupt on line 12
        pub type SWIER12_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `SWIER13` reader - Software Interrupt on line 13
        pub type SWIER13_R = crate::BitReader;
        ///Field `SWIER13` writer - Software Interrupt on line 13
        pub type SWIER13_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `SWIER14` reader - Software Interrupt on line 14
        pub type SWIER14_R = crate::BitReader;
        ///Field `SWIER14` writer - Software Interrupt on line 14
        pub type SWIER14_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `SWIER15` reader - Software Interrupt on line 15
        pub type SWIER15_R = crate::BitReader;
        ///Field `SWIER15` writer - Software Interrupt on line 15
        pub type SWIER15_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `SWIER16` reader - Software Interrupt on line 16
        pub type SWIER16_R = crate::BitReader;
        ///Field `SWIER16` writer - Software Interrupt on line 16
        pub type SWIER16_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `SWIER17` reader - Software Interrupt on line 17
        pub type SWIER17_R = crate::BitReader;
        ///Field `SWIER17` writer - Software Interrupt on line 17
        pub type SWIER17_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `SWIER18` reader - Software Interrupt on line 18
        pub type SWIER18_R = crate::BitReader;
        ///Field `SWIER18` writer - Software Interrupt on line 18
        pub type SWIER18_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `SWIER19` reader - Software Interrupt on line 19
        pub type SWIER19_R = crate::BitReader;
        ///Field `SWIER19` writer - Software Interrupt on line 19
        pub type SWIER19_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `SWIER20` reader - Software Interrupt on line 20
        pub type SWIER20_R = crate::BitReader;
        ///Field `SWIER20` writer - Software Interrupt on line 20
        pub type SWIER20_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `SWIER21` reader - Software Interrupt on line 21
        pub type SWIER21_R = crate::BitReader;
        ///Field `SWIER21` writer - Software Interrupt on line 21
        pub type SWIER21_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `SWIER22` reader - Software Interrupt on line 22
        pub type SWIER22_R = crate::BitReader;
        ///Field `SWIER22` writer - Software Interrupt on line 22
        pub type SWIER22_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - Software Interrupt on line 0
            #[inline(always)]
            pub fn swier0(&self) -> SWIER0_R {
                SWIER0_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Software Interrupt on line 1
            #[inline(always)]
            pub fn swier1(&self) -> SWIER1_R {
                SWIER1_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - Software Interrupt on line 2
            #[inline(always)]
            pub fn swier2(&self) -> SWIER2_R {
                SWIER2_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - Software Interrupt on line 3
            #[inline(always)]
            pub fn swier3(&self) -> SWIER3_R {
                SWIER3_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - Software Interrupt on line 4
            #[inline(always)]
            pub fn swier4(&self) -> SWIER4_R {
                SWIER4_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - Software Interrupt on line 5
            #[inline(always)]
            pub fn swier5(&self) -> SWIER5_R {
                SWIER5_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - Software Interrupt on line 6
            #[inline(always)]
            pub fn swier6(&self) -> SWIER6_R {
                SWIER6_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - Software Interrupt on line 7
            #[inline(always)]
            pub fn swier7(&self) -> SWIER7_R {
                SWIER7_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bit 8 - Software Interrupt on line 8
            #[inline(always)]
            pub fn swier8(&self) -> SWIER8_R {
                SWIER8_R::new(((self.bits >> 8) & 1) != 0)
            }
            ///Bit 9 - Software Interrupt on line 9
            #[inline(always)]
            pub fn swier9(&self) -> SWIER9_R {
                SWIER9_R::new(((self.bits >> 9) & 1) != 0)
            }
            ///Bit 10 - Software Interrupt on line 10
            #[inline(always)]
            pub fn swier10(&self) -> SWIER10_R {
                SWIER10_R::new(((self.bits >> 10) & 1) != 0)
            }
            ///Bit 11 - Software Interrupt on line 11
            #[inline(always)]
            pub fn swier11(&self) -> SWIER11_R {
                SWIER11_R::new(((self.bits >> 11) & 1) != 0)
            }
            ///Bit 12 - Software Interrupt on line 12
            #[inline(always)]
            pub fn swier12(&self) -> SWIER12_R {
                SWIER12_R::new(((self.bits >> 12) & 1) != 0)
            }
            ///Bit 13 - Software Interrupt on line 13
            #[inline(always)]
            pub fn swier13(&self) -> SWIER13_R {
                SWIER13_R::new(((self.bits >> 13) & 1) != 0)
            }
            ///Bit 14 - Software Interrupt on line 14
            #[inline(always)]
            pub fn swier14(&self) -> SWIER14_R {
                SWIER14_R::new(((self.bits >> 14) & 1) != 0)
            }
            ///Bit 15 - Software Interrupt on line 15
            #[inline(always)]
            pub fn swier15(&self) -> SWIER15_R {
                SWIER15_R::new(((self.bits >> 15) & 1) != 0)
            }
            ///Bit 16 - Software Interrupt on line 16
            #[inline(always)]
            pub fn swier16(&self) -> SWIER16_R {
                SWIER16_R::new(((self.bits >> 16) & 1) != 0)
            }
            ///Bit 17 - Software Interrupt on line 17
            #[inline(always)]
            pub fn swier17(&self) -> SWIER17_R {
                SWIER17_R::new(((self.bits >> 17) & 1) != 0)
            }
            ///Bit 18 - Software Interrupt on line 18
            #[inline(always)]
            pub fn swier18(&self) -> SWIER18_R {
                SWIER18_R::new(((self.bits >> 18) & 1) != 0)
            }
            ///Bit 19 - Software Interrupt on line 19
            #[inline(always)]
            pub fn swier19(&self) -> SWIER19_R {
                SWIER19_R::new(((self.bits >> 19) & 1) != 0)
            }
            ///Bit 20 - Software Interrupt on line 20
            #[inline(always)]
            pub fn swier20(&self) -> SWIER20_R {
                SWIER20_R::new(((self.bits >> 20) & 1) != 0)
            }
            ///Bit 21 - Software Interrupt on line 21
            #[inline(always)]
            pub fn swier21(&self) -> SWIER21_R {
                SWIER21_R::new(((self.bits >> 21) & 1) != 0)
            }
            ///Bit 22 - Software Interrupt on line 22
            #[inline(always)]
            pub fn swier22(&self) -> SWIER22_R {
                SWIER22_R::new(((self.bits >> 22) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - Software Interrupt on line 0
            #[inline(always)]
            #[must_use]
            pub fn swier0(&mut self) -> SWIER0_W<SWIEVR_SPEC> {
                SWIER0_W::new(self, 0)
            }
            ///Bit 1 - Software Interrupt on line 1
            #[inline(always)]
            #[must_use]
            pub fn swier1(&mut self) -> SWIER1_W<SWIEVR_SPEC> {
                SWIER1_W::new(self, 1)
            }
            ///Bit 2 - Software Interrupt on line 2
            #[inline(always)]
            #[must_use]
            pub fn swier2(&mut self) -> SWIER2_W<SWIEVR_SPEC> {
                SWIER2_W::new(self, 2)
            }
            ///Bit 3 - Software Interrupt on line 3
            #[inline(always)]
            #[must_use]
            pub fn swier3(&mut self) -> SWIER3_W<SWIEVR_SPEC> {
                SWIER3_W::new(self, 3)
            }
            ///Bit 4 - Software Interrupt on line 4
            #[inline(always)]
            #[must_use]
            pub fn swier4(&mut self) -> SWIER4_W<SWIEVR_SPEC> {
                SWIER4_W::new(self, 4)
            }
            ///Bit 5 - Software Interrupt on line 5
            #[inline(always)]
            #[must_use]
            pub fn swier5(&mut self) -> SWIER5_W<SWIEVR_SPEC> {
                SWIER5_W::new(self, 5)
            }
            ///Bit 6 - Software Interrupt on line 6
            #[inline(always)]
            #[must_use]
            pub fn swier6(&mut self) -> SWIER6_W<SWIEVR_SPEC> {
                SWIER6_W::new(self, 6)
            }
            ///Bit 7 - Software Interrupt on line 7
            #[inline(always)]
            #[must_use]
            pub fn swier7(&mut self) -> SWIER7_W<SWIEVR_SPEC> {
                SWIER7_W::new(self, 7)
            }
            ///Bit 8 - Software Interrupt on line 8
            #[inline(always)]
            #[must_use]
            pub fn swier8(&mut self) -> SWIER8_W<SWIEVR_SPEC> {
                SWIER8_W::new(self, 8)
            }
            ///Bit 9 - Software Interrupt on line 9
            #[inline(always)]
            #[must_use]
            pub fn swier9(&mut self) -> SWIER9_W<SWIEVR_SPEC> {
                SWIER9_W::new(self, 9)
            }
            ///Bit 10 - Software Interrupt on line 10
            #[inline(always)]
            #[must_use]
            pub fn swier10(&mut self) -> SWIER10_W<SWIEVR_SPEC> {
                SWIER10_W::new(self, 10)
            }
            ///Bit 11 - Software Interrupt on line 11
            #[inline(always)]
            #[must_use]
            pub fn swier11(&mut self) -> SWIER11_W<SWIEVR_SPEC> {
                SWIER11_W::new(self, 11)
            }
            ///Bit 12 - Software Interrupt on line 12
            #[inline(always)]
            #[must_use]
            pub fn swier12(&mut self) -> SWIER12_W<SWIEVR_SPEC> {
                SWIER12_W::new(self, 12)
            }
            ///Bit 13 - Software Interrupt on line 13
            #[inline(always)]
            #[must_use]
            pub fn swier13(&mut self) -> SWIER13_W<SWIEVR_SPEC> {
                SWIER13_W::new(self, 13)
            }
            ///Bit 14 - Software Interrupt on line 14
            #[inline(always)]
            #[must_use]
            pub fn swier14(&mut self) -> SWIER14_W<SWIEVR_SPEC> {
                SWIER14_W::new(self, 14)
            }
            ///Bit 15 - Software Interrupt on line 15
            #[inline(always)]
            #[must_use]
            pub fn swier15(&mut self) -> SWIER15_W<SWIEVR_SPEC> {
                SWIER15_W::new(self, 15)
            }
            ///Bit 16 - Software Interrupt on line 16
            #[inline(always)]
            #[must_use]
            pub fn swier16(&mut self) -> SWIER16_W<SWIEVR_SPEC> {
                SWIER16_W::new(self, 16)
            }
            ///Bit 17 - Software Interrupt on line 17
            #[inline(always)]
            #[must_use]
            pub fn swier17(&mut self) -> SWIER17_W<SWIEVR_SPEC> {
                SWIER17_W::new(self, 17)
            }
            ///Bit 18 - Software Interrupt on line 18
            #[inline(always)]
            #[must_use]
            pub fn swier18(&mut self) -> SWIER18_W<SWIEVR_SPEC> {
                SWIER18_W::new(self, 18)
            }
            ///Bit 19 - Software Interrupt on line 19
            #[inline(always)]
            #[must_use]
            pub fn swier19(&mut self) -> SWIER19_W<SWIEVR_SPEC> {
                SWIER19_W::new(self, 19)
            }
            ///Bit 20 - Software Interrupt on line 20
            #[inline(always)]
            #[must_use]
            pub fn swier20(&mut self) -> SWIER20_W<SWIEVR_SPEC> {
                SWIER20_W::new(self, 20)
            }
            ///Bit 21 - Software Interrupt on line 21
            #[inline(always)]
            #[must_use]
            pub fn swier21(&mut self) -> SWIER21_W<SWIEVR_SPEC> {
                SWIER21_W::new(self, 21)
            }
            ///Bit 22 - Software Interrupt on line 22
            #[inline(always)]
            #[must_use]
            pub fn swier22(&mut self) -> SWIER22_W<SWIEVR_SPEC> {
                SWIER22_W::new(self, 22)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Software interrupt event register (EXTI_SWIEVR)
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`swievr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`swievr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct SWIEVR_SPEC;
        impl crate::RegisterSpec for SWIEVR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`swievr::R`](R) reader structure
        impl crate::Readable for SWIEVR_SPEC {}
        ///`write(|w| ..)` method takes [`swievr::W`](W) writer structure
        impl crate::Writable for SWIEVR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets SWIEVR to value 0
        impl crate::Resettable for SWIEVR_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///INTFR (rw) register accessor: interrupt flag register (EXTI_INTFR)
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`intfr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`intfr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@intfr`]
    ///module
    pub type INTFR = crate::Reg<intfr::INTFR_SPEC>;
    ///interrupt flag register (EXTI_INTFR)
    pub mod intfr {
        ///Register `INTFR` reader
        pub type R = crate::R<INTFR_SPEC>;
        ///Register `INTFR` writer
        pub type W = crate::W<INTFR_SPEC>;
        ///Field `IF0` reader - interrupt flag bit 0
        pub type IF0_R = crate::BitReader;
        ///Field `IF0` writer - interrupt flag bit 0
        pub type IF0_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `IF1` reader - interrupt flag bit 1
        pub type IF1_R = crate::BitReader;
        ///Field `IF1` writer - interrupt flag bit 1
        pub type IF1_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `IF2` reader - interrupt flag bit 2
        pub type IF2_R = crate::BitReader;
        ///Field `IF2` writer - interrupt flag bit 2
        pub type IF2_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `IF3` reader - interrupt flag bit 3
        pub type IF3_R = crate::BitReader;
        ///Field `IF3` writer - interrupt flag bit 3
        pub type IF3_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `IF4` reader - interrupt flag bit 4
        pub type IF4_R = crate::BitReader;
        ///Field `IF4` writer - interrupt flag bit 4
        pub type IF4_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `IF5` reader - interrupt flag bit 5
        pub type IF5_R = crate::BitReader;
        ///Field `IF5` writer - interrupt flag bit 5
        pub type IF5_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `IF6` reader - interrupt flag bit 6
        pub type IF6_R = crate::BitReader;
        ///Field `IF6` writer - interrupt flag bit 6
        pub type IF6_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `IF7` reader - interrupt flag bit 7
        pub type IF7_R = crate::BitReader;
        ///Field `IF7` writer - interrupt flag bit 7
        pub type IF7_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `IF8` reader - interrupt flag bit 8
        pub type IF8_R = crate::BitReader;
        ///Field `IF8` writer - interrupt flag bit 8
        pub type IF8_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `IF9` reader - interrupt flag bit 9
        pub type IF9_R = crate::BitReader;
        ///Field `IF9` writer - interrupt flag bit 9
        pub type IF9_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `IF10` reader - interrupt flag bit 10
        pub type IF10_R = crate::BitReader;
        ///Field `IF10` writer - interrupt flag bit 10
        pub type IF10_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `IF11` reader - interrupt flag bit 11
        pub type IF11_R = crate::BitReader;
        ///Field `IF11` writer - interrupt flag bit 11
        pub type IF11_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `IF12` reader - interrupt flag bit 12
        pub type IF12_R = crate::BitReader;
        ///Field `IF12` writer - interrupt flag bit 12
        pub type IF12_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `IF13` reader - interrupt flag bit 13
        pub type IF13_R = crate::BitReader;
        ///Field `IF13` writer - interrupt flag bit 13
        pub type IF13_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `IF14` reader - interrupt flag bit 14
        pub type IF14_R = crate::BitReader;
        ///Field `IF14` writer - interrupt flag bit 14
        pub type IF14_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `IF15` reader - interrupt flag bit 15
        pub type IF15_R = crate::BitReader;
        ///Field `IF15` writer - interrupt flag bit 15
        pub type IF15_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `IF16` reader - interrupt flag bit 16
        pub type IF16_R = crate::BitReader;
        ///Field `IF16` writer - interrupt flag bit 16
        pub type IF16_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `IF17` reader - interrupt flag bit 17
        pub type IF17_R = crate::BitReader;
        ///Field `IF17` writer - interrupt flag bit 17
        pub type IF17_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `IF18` reader - interrupt flag bit 18
        pub type IF18_R = crate::BitReader;
        ///Field `IF18` writer - interrupt flag bit 18
        pub type IF18_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `IF19` reader - interrupt flag bit 19
        pub type IF19_R = crate::BitReader;
        ///Field `IF19` writer - interrupt flag bit 19
        pub type IF19_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `IF20` reader - interrupt flag bit 20
        pub type IF20_R = crate::BitReader;
        ///Field `IF20` writer - interrupt flag bit 20
        pub type IF20_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `IF21` reader - interrupt flag bit 21
        pub type IF21_R = crate::BitReader;
        ///Field `IF21` writer - interrupt flag bit 21
        pub type IF21_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `IF22` reader - interrupt flag bit 22
        pub type IF22_R = crate::BitReader;
        ///Field `IF22` writer - interrupt flag bit 22
        pub type IF22_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - interrupt flag bit 0
            #[inline(always)]
            pub fn if0(&self) -> IF0_R {
                IF0_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - interrupt flag bit 1
            #[inline(always)]
            pub fn if1(&self) -> IF1_R {
                IF1_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - interrupt flag bit 2
            #[inline(always)]
            pub fn if2(&self) -> IF2_R {
                IF2_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - interrupt flag bit 3
            #[inline(always)]
            pub fn if3(&self) -> IF3_R {
                IF3_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - interrupt flag bit 4
            #[inline(always)]
            pub fn if4(&self) -> IF4_R {
                IF4_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - interrupt flag bit 5
            #[inline(always)]
            pub fn if5(&self) -> IF5_R {
                IF5_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - interrupt flag bit 6
            #[inline(always)]
            pub fn if6(&self) -> IF6_R {
                IF6_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - interrupt flag bit 7
            #[inline(always)]
            pub fn if7(&self) -> IF7_R {
                IF7_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bit 8 - interrupt flag bit 8
            #[inline(always)]
            pub fn if8(&self) -> IF8_R {
                IF8_R::new(((self.bits >> 8) & 1) != 0)
            }
            ///Bit 9 - interrupt flag bit 9
            #[inline(always)]
            pub fn if9(&self) -> IF9_R {
                IF9_R::new(((self.bits >> 9) & 1) != 0)
            }
            ///Bit 10 - interrupt flag bit 10
            #[inline(always)]
            pub fn if10(&self) -> IF10_R {
                IF10_R::new(((self.bits >> 10) & 1) != 0)
            }
            ///Bit 11 - interrupt flag bit 11
            #[inline(always)]
            pub fn if11(&self) -> IF11_R {
                IF11_R::new(((self.bits >> 11) & 1) != 0)
            }
            ///Bit 12 - interrupt flag bit 12
            #[inline(always)]
            pub fn if12(&self) -> IF12_R {
                IF12_R::new(((self.bits >> 12) & 1) != 0)
            }
            ///Bit 13 - interrupt flag bit 13
            #[inline(always)]
            pub fn if13(&self) -> IF13_R {
                IF13_R::new(((self.bits >> 13) & 1) != 0)
            }
            ///Bit 14 - interrupt flag bit 14
            #[inline(always)]
            pub fn if14(&self) -> IF14_R {
                IF14_R::new(((self.bits >> 14) & 1) != 0)
            }
            ///Bit 15 - interrupt flag bit 15
            #[inline(always)]
            pub fn if15(&self) -> IF15_R {
                IF15_R::new(((self.bits >> 15) & 1) != 0)
            }
            ///Bit 16 - interrupt flag bit 16
            #[inline(always)]
            pub fn if16(&self) -> IF16_R {
                IF16_R::new(((self.bits >> 16) & 1) != 0)
            }
            ///Bit 17 - interrupt flag bit 17
            #[inline(always)]
            pub fn if17(&self) -> IF17_R {
                IF17_R::new(((self.bits >> 17) & 1) != 0)
            }
            ///Bit 18 - interrupt flag bit 18
            #[inline(always)]
            pub fn if18(&self) -> IF18_R {
                IF18_R::new(((self.bits >> 18) & 1) != 0)
            }
            ///Bit 19 - interrupt flag bit 19
            #[inline(always)]
            pub fn if19(&self) -> IF19_R {
                IF19_R::new(((self.bits >> 19) & 1) != 0)
            }
            ///Bit 20 - interrupt flag bit 20
            #[inline(always)]
            pub fn if20(&self) -> IF20_R {
                IF20_R::new(((self.bits >> 20) & 1) != 0)
            }
            ///Bit 21 - interrupt flag bit 21
            #[inline(always)]
            pub fn if21(&self) -> IF21_R {
                IF21_R::new(((self.bits >> 21) & 1) != 0)
            }
            ///Bit 22 - interrupt flag bit 22
            #[inline(always)]
            pub fn if22(&self) -> IF22_R {
                IF22_R::new(((self.bits >> 22) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - interrupt flag bit 0
            #[inline(always)]
            #[must_use]
            pub fn if0(&mut self) -> IF0_W<INTFR_SPEC> {
                IF0_W::new(self, 0)
            }
            ///Bit 1 - interrupt flag bit 1
            #[inline(always)]
            #[must_use]
            pub fn if1(&mut self) -> IF1_W<INTFR_SPEC> {
                IF1_W::new(self, 1)
            }
            ///Bit 2 - interrupt flag bit 2
            #[inline(always)]
            #[must_use]
            pub fn if2(&mut self) -> IF2_W<INTFR_SPEC> {
                IF2_W::new(self, 2)
            }
            ///Bit 3 - interrupt flag bit 3
            #[inline(always)]
            #[must_use]
            pub fn if3(&mut self) -> IF3_W<INTFR_SPEC> {
                IF3_W::new(self, 3)
            }
            ///Bit 4 - interrupt flag bit 4
            #[inline(always)]
            #[must_use]
            pub fn if4(&mut self) -> IF4_W<INTFR_SPEC> {
                IF4_W::new(self, 4)
            }
            ///Bit 5 - interrupt flag bit 5
            #[inline(always)]
            #[must_use]
            pub fn if5(&mut self) -> IF5_W<INTFR_SPEC> {
                IF5_W::new(self, 5)
            }
            ///Bit 6 - interrupt flag bit 6
            #[inline(always)]
            #[must_use]
            pub fn if6(&mut self) -> IF6_W<INTFR_SPEC> {
                IF6_W::new(self, 6)
            }
            ///Bit 7 - interrupt flag bit 7
            #[inline(always)]
            #[must_use]
            pub fn if7(&mut self) -> IF7_W<INTFR_SPEC> {
                IF7_W::new(self, 7)
            }
            ///Bit 8 - interrupt flag bit 8
            #[inline(always)]
            #[must_use]
            pub fn if8(&mut self) -> IF8_W<INTFR_SPEC> {
                IF8_W::new(self, 8)
            }
            ///Bit 9 - interrupt flag bit 9
            #[inline(always)]
            #[must_use]
            pub fn if9(&mut self) -> IF9_W<INTFR_SPEC> {
                IF9_W::new(self, 9)
            }
            ///Bit 10 - interrupt flag bit 10
            #[inline(always)]
            #[must_use]
            pub fn if10(&mut self) -> IF10_W<INTFR_SPEC> {
                IF10_W::new(self, 10)
            }
            ///Bit 11 - interrupt flag bit 11
            #[inline(always)]
            #[must_use]
            pub fn if11(&mut self) -> IF11_W<INTFR_SPEC> {
                IF11_W::new(self, 11)
            }
            ///Bit 12 - interrupt flag bit 12
            #[inline(always)]
            #[must_use]
            pub fn if12(&mut self) -> IF12_W<INTFR_SPEC> {
                IF12_W::new(self, 12)
            }
            ///Bit 13 - interrupt flag bit 13
            #[inline(always)]
            #[must_use]
            pub fn if13(&mut self) -> IF13_W<INTFR_SPEC> {
                IF13_W::new(self, 13)
            }
            ///Bit 14 - interrupt flag bit 14
            #[inline(always)]
            #[must_use]
            pub fn if14(&mut self) -> IF14_W<INTFR_SPEC> {
                IF14_W::new(self, 14)
            }
            ///Bit 15 - interrupt flag bit 15
            #[inline(always)]
            #[must_use]
            pub fn if15(&mut self) -> IF15_W<INTFR_SPEC> {
                IF15_W::new(self, 15)
            }
            ///Bit 16 - interrupt flag bit 16
            #[inline(always)]
            #[must_use]
            pub fn if16(&mut self) -> IF16_W<INTFR_SPEC> {
                IF16_W::new(self, 16)
            }
            ///Bit 17 - interrupt flag bit 17
            #[inline(always)]
            #[must_use]
            pub fn if17(&mut self) -> IF17_W<INTFR_SPEC> {
                IF17_W::new(self, 17)
            }
            ///Bit 18 - interrupt flag bit 18
            #[inline(always)]
            #[must_use]
            pub fn if18(&mut self) -> IF18_W<INTFR_SPEC> {
                IF18_W::new(self, 18)
            }
            ///Bit 19 - interrupt flag bit 19
            #[inline(always)]
            #[must_use]
            pub fn if19(&mut self) -> IF19_W<INTFR_SPEC> {
                IF19_W::new(self, 19)
            }
            ///Bit 20 - interrupt flag bit 20
            #[inline(always)]
            #[must_use]
            pub fn if20(&mut self) -> IF20_W<INTFR_SPEC> {
                IF20_W::new(self, 20)
            }
            ///Bit 21 - interrupt flag bit 21
            #[inline(always)]
            #[must_use]
            pub fn if21(&mut self) -> IF21_W<INTFR_SPEC> {
                IF21_W::new(self, 21)
            }
            ///Bit 22 - interrupt flag bit 22
            #[inline(always)]
            #[must_use]
            pub fn if22(&mut self) -> IF22_W<INTFR_SPEC> {
                IF22_W::new(self, 22)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///interrupt flag register (EXTI_INTFR)
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`intfr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`intfr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct INTFR_SPEC;
        impl crate::RegisterSpec for INTFR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`intfr::R`](R) reader structure
        impl crate::Readable for INTFR_SPEC {}
        ///`write(|w| ..)` method takes [`intfr::W`](W) writer structure
        impl crate::Writable for INTFR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets INTFR to value 0
        impl crate::Resettable for INTFR_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
}
///DMA controller
pub struct DMA {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for DMA {}
impl DMA {
    ///Pointer to the register block
    pub const PTR: *const dma::RegisterBlock = 0x4002_0000 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const dma::RegisterBlock {
        Self::PTR
    }
    /// Steal an instance of this peripheral
    ///
    /// # Safety
    ///
    /// Ensure that the new instance of the peripheral cannot be used in a way
    /// that may race with any existing instances, for example by only
    /// accessing read-only or write-only registers, or by consuming the
    /// original peripheral and using critical sections to coordinate
    /// access between multiple new instances.
    ///
    /// Additionally, other software such as HALs may rely on only one
    /// peripheral instance existing to ensure memory safety; ensure
    /// no stolen instances are passed to such software.
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for DMA {
    type Target = dma::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for DMA {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("DMA").finish()
    }
}
///DMA controller
pub mod dma {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        intfr: INTFR,
        intfcr: INTFCR,
        cfgr1: CFGR1,
        cntr1: CNTR1,
        paddr1: PADDR1,
        maddr1: MADDR1,
        _reserved6: [u8; 0x04],
        cfgr2: CFGR2,
        cntr2: CNTR2,
        paddr2: PADDR2,
        maddr2: MADDR2,
        _reserved10: [u8; 0x04],
        cfgr3: CFGR3,
        cntr3: CNTR3,
        paddr3: PADDR3,
        maddr3: MADDR3,
        _reserved14: [u8; 0x04],
        cfgr4: CFGR4,
        cntr4: CNTR4,
        paddr4: PADDR4,
        maddr4: MADDR4,
        _reserved18: [u8; 0x04],
        cfgr5: CFGR5,
        cntr5: CNTR5,
        paddr5: PADDR5,
        maddr5: MADDR5,
        _reserved22: [u8; 0x04],
        cfgr6: CFGR6,
        cntr6: CNTR6,
        paddr6: PADDR6,
        maddr6: MADDR6,
        _reserved26: [u8; 0x04],
        cfgr7: CFGR7,
        cntr7: CNTR7,
        paddr7: PADDR7,
        maddr7: MADDR7,
        _reserved30: [u8; 0x04],
        cfgr8: CFGR8,
        cntr8: CNTR8,
        paddr8: PADDR8,
        maddr8: MADDR8,
    }
    impl RegisterBlock {
        ///0x00 - DMA interrupt status register (DMA_INTFR)
        #[inline(always)]
        pub const fn intfr(&self) -> &INTFR {
            &self.intfr
        }
        ///0x04 - DMA interrupt flag clear register (DMA_INTFCR)
        #[inline(always)]
        pub const fn intfcr(&self) -> &INTFCR {
            &self.intfcr
        }
        ///0x08 - DMA channel configuration register (DMA_CFGR)
        #[inline(always)]
        pub const fn cfgr1(&self) -> &CFGR1 {
            &self.cfgr1
        }
        ///0x0c - DMA channel 1 number of data register
        #[inline(always)]
        pub const fn cntr1(&self) -> &CNTR1 {
            &self.cntr1
        }
        ///0x10 - DMA channel 1 peripheral address register
        #[inline(always)]
        pub const fn paddr1(&self) -> &PADDR1 {
            &self.paddr1
        }
        ///0x14 - DMA channel 1 memory address register
        #[inline(always)]
        pub const fn maddr1(&self) -> &MADDR1 {
            &self.maddr1
        }
        ///0x1c - DMA channel configuration register (DMA_CFGR)
        #[inline(always)]
        pub const fn cfgr2(&self) -> &CFGR2 {
            &self.cfgr2
        }
        ///0x20 - DMA channel 2 number of data register
        #[inline(always)]
        pub const fn cntr2(&self) -> &CNTR2 {
            &self.cntr2
        }
        ///0x24 - DMA channel 2 peripheral address register
        #[inline(always)]
        pub const fn paddr2(&self) -> &PADDR2 {
            &self.paddr2
        }
        ///0x28 - DMA channel 2 memory address register
        #[inline(always)]
        pub const fn maddr2(&self) -> &MADDR2 {
            &self.maddr2
        }
        ///0x30 - DMA channel configuration register (DMA_CFGR)
        #[inline(always)]
        pub const fn cfgr3(&self) -> &CFGR3 {
            &self.cfgr3
        }
        ///0x34 - DMA channel 3 number of data register
        #[inline(always)]
        pub const fn cntr3(&self) -> &CNTR3 {
            &self.cntr3
        }
        ///0x38 - DMA channel 3 peripheral address register
        #[inline(always)]
        pub const fn paddr3(&self) -> &PADDR3 {
            &self.paddr3
        }
        ///0x3c - DMA channel 3 memory address register
        #[inline(always)]
        pub const fn maddr3(&self) -> &MADDR3 {
            &self.maddr3
        }
        ///0x44 - DMA channel configuration register (DMA_CFGR)
        #[inline(always)]
        pub const fn cfgr4(&self) -> &CFGR4 {
            &self.cfgr4
        }
        ///0x48 - DMA channel 4 number of data register
        #[inline(always)]
        pub const fn cntr4(&self) -> &CNTR4 {
            &self.cntr4
        }
        ///0x4c - DMA channel 4 peripheral address register
        #[inline(always)]
        pub const fn paddr4(&self) -> &PADDR4 {
            &self.paddr4
        }
        ///0x50 - DMA channel 4 memory address register
        #[inline(always)]
        pub const fn maddr4(&self) -> &MADDR4 {
            &self.maddr4
        }
        ///0x58 - DMA channel configuration register (DMA_CFGR)
        #[inline(always)]
        pub const fn cfgr5(&self) -> &CFGR5 {
            &self.cfgr5
        }
        ///0x5c - DMA channel 5 number of data register
        #[inline(always)]
        pub const fn cntr5(&self) -> &CNTR5 {
            &self.cntr5
        }
        ///0x60 - DMA channel 5 peripheral address register
        #[inline(always)]
        pub const fn paddr5(&self) -> &PADDR5 {
            &self.paddr5
        }
        ///0x64 - DMA channel 5 memory address register
        #[inline(always)]
        pub const fn maddr5(&self) -> &MADDR5 {
            &self.maddr5
        }
        ///0x6c - DMA channel configuration register (DMA_CFGR)
        #[inline(always)]
        pub const fn cfgr6(&self) -> &CFGR6 {
            &self.cfgr6
        }
        ///0x70 - DMA channel 6 number of data register
        #[inline(always)]
        pub const fn cntr6(&self) -> &CNTR6 {
            &self.cntr6
        }
        ///0x74 - DMA channel 6 peripheral address register
        #[inline(always)]
        pub const fn paddr6(&self) -> &PADDR6 {
            &self.paddr6
        }
        ///0x78 - DMA channel 6 memory address register
        #[inline(always)]
        pub const fn maddr6(&self) -> &MADDR6 {
            &self.maddr6
        }
        ///0x80 - DMA channel configuration register (DMA_CFGR)
        #[inline(always)]
        pub const fn cfgr7(&self) -> &CFGR7 {
            &self.cfgr7
        }
        ///0x84 - DMA channel 7 number of data register
        #[inline(always)]
        pub const fn cntr7(&self) -> &CNTR7 {
            &self.cntr7
        }
        ///0x88 - DMA channel 7 peripheral address register
        #[inline(always)]
        pub const fn paddr7(&self) -> &PADDR7 {
            &self.paddr7
        }
        ///0x8c - DMA channel 7 memory address register
        #[inline(always)]
        pub const fn maddr7(&self) -> &MADDR7 {
            &self.maddr7
        }
        ///0x94 - DMA channel configuration register (DMA_CFGR) use in ch32v20_D8/D8W/D6
        #[inline(always)]
        pub const fn cfgr8(&self) -> &CFGR8 {
            &self.cfgr8
        }
        ///0x98 - DMA channel 8 number of data register use in ch32v20_D8/D8W/D6
        #[inline(always)]
        pub const fn cntr8(&self) -> &CNTR8 {
            &self.cntr8
        }
        ///0x9c - DMA channel 8 peripheral address register use in ch32v20_D8/D8W/D6
        #[inline(always)]
        pub const fn paddr8(&self) -> &PADDR8 {
            &self.paddr8
        }
        ///0xa0 - DMA channel 8 memory address register use in ch32v20_D8/D8W/D6
        #[inline(always)]
        pub const fn maddr8(&self) -> &MADDR8 {
            &self.maddr8
        }
    }
    ///INTFR (r) register accessor: DMA interrupt status register (DMA_INTFR)
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`intfr::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@intfr`]
    ///module
    pub type INTFR = crate::Reg<intfr::INTFR_SPEC>;
    ///DMA interrupt status register (DMA_INTFR)
    pub mod intfr {
        ///Register `INTFR` reader
        pub type R = crate::R<INTFR_SPEC>;
        ///Field `GIF1` reader - Channel 1 Global interrupt flag
        pub type GIF1_R = crate::BitReader;
        ///Field `TCIF1` reader - Channel 1 Transfer Complete flag
        pub type TCIF1_R = crate::BitReader;
        ///Field `HTIF1` reader - Channel 1 Half Transfer Complete flag
        pub type HTIF1_R = crate::BitReader;
        ///Field `TEIF1` reader - Channel 1 Transfer Error flag
        pub type TEIF1_R = crate::BitReader;
        ///Field `GIF2` reader - Channel 2 Global interrupt flag
        pub type GIF2_R = crate::BitReader;
        ///Field `TCIF2` reader - Channel 2 Transfer Complete flag
        pub type TCIF2_R = crate::BitReader;
        ///Field `HTIF2` reader - Channel 2 Half Transfer Complete flag
        pub type HTIF2_R = crate::BitReader;
        ///Field `TEIF2` reader - Channel 2 Transfer Error flag
        pub type TEIF2_R = crate::BitReader;
        ///Field `GIF3` reader - Channel 3 Global interrupt flag
        pub type GIF3_R = crate::BitReader;
        ///Field `TCIF3` reader - Channel 3 Transfer Complete flag
        pub type TCIF3_R = crate::BitReader;
        ///Field `HTIF3` reader - Channel 3 Half Transfer Complete flag
        pub type HTIF3_R = crate::BitReader;
        ///Field `TEIF3` reader - Channel 3 Transfer Error flag
        pub type TEIF3_R = crate::BitReader;
        ///Field `GIF4` reader - Channel 4 Global interrupt flag
        pub type GIF4_R = crate::BitReader;
        ///Field `TCIF4` reader - Channel 4 Transfer Complete flag
        pub type TCIF4_R = crate::BitReader;
        ///Field `HTIF4` reader - Channel 4 Half Transfer Complete flag
        pub type HTIF4_R = crate::BitReader;
        ///Field `TEIF4` reader - Channel 4 Transfer Error flag
        pub type TEIF4_R = crate::BitReader;
        ///Field `GIF5` reader - Channel 5 Global interrupt flag
        pub type GIF5_R = crate::BitReader;
        ///Field `TCIF5` reader - Channel 5 Transfer Complete flag
        pub type TCIF5_R = crate::BitReader;
        ///Field `HTIF5` reader - Channel 5 Half Transfer Complete flag
        pub type HTIF5_R = crate::BitReader;
        ///Field `TEIF5` reader - Channel 5 Transfer Error flag
        pub type TEIF5_R = crate::BitReader;
        ///Field `GIF6` reader - Channel 6 Global interrupt flag
        pub type GIF6_R = crate::BitReader;
        ///Field `TCIF6` reader - Channel 6 Transfer Complete flag
        pub type TCIF6_R = crate::BitReader;
        ///Field `HTIF6` reader - Channel 6 Half Transfer Complete flag
        pub type HTIF6_R = crate::BitReader;
        ///Field `TEIF6` reader - Channel 6 Transfer Error flag
        pub type TEIF6_R = crate::BitReader;
        ///Field `GIF7` reader - Channel 7 Global interrupt flag
        pub type GIF7_R = crate::BitReader;
        ///Field `TCIF7` reader - Channel 7 Transfer Complete flag
        pub type TCIF7_R = crate::BitReader;
        ///Field `HTIF7` reader - Channel 7 Half Transfer Complete flag
        pub type HTIF7_R = crate::BitReader;
        ///Field `TEIF7` reader - Channel 7 Transfer Error flag
        pub type TEIF7_R = crate::BitReader;
        ///Field `GIF8` reader - Channel 8 Global interrupt flag use in ch32v20_D8/D8W/D6
        pub type GIF8_R = crate::BitReader;
        ///Field `TCIF8` reader - Channel 8 Transfer Complete flag use in ch32v20_D8/D8W/D6
        pub type TCIF8_R = crate::BitReader;
        ///Field `HTIF8` reader - Channel 8 Half Transfer Complete flag use in ch32v20_D8/D8W/D6
        pub type HTIF8_R = crate::BitReader;
        ///Field `TEIF8` reader - Channel 8 Transfer Error flag use in ch32v20_D8/D8W/D6
        pub type TEIF8_R = crate::BitReader;
        impl R {
            ///Bit 0 - Channel 1 Global interrupt flag
            #[inline(always)]
            pub fn gif1(&self) -> GIF1_R {
                GIF1_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Channel 1 Transfer Complete flag
            #[inline(always)]
            pub fn tcif1(&self) -> TCIF1_R {
                TCIF1_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - Channel 1 Half Transfer Complete flag
            #[inline(always)]
            pub fn htif1(&self) -> HTIF1_R {
                HTIF1_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - Channel 1 Transfer Error flag
            #[inline(always)]
            pub fn teif1(&self) -> TEIF1_R {
                TEIF1_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - Channel 2 Global interrupt flag
            #[inline(always)]
            pub fn gif2(&self) -> GIF2_R {
                GIF2_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - Channel 2 Transfer Complete flag
            #[inline(always)]
            pub fn tcif2(&self) -> TCIF2_R {
                TCIF2_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - Channel 2 Half Transfer Complete flag
            #[inline(always)]
            pub fn htif2(&self) -> HTIF2_R {
                HTIF2_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - Channel 2 Transfer Error flag
            #[inline(always)]
            pub fn teif2(&self) -> TEIF2_R {
                TEIF2_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bit 8 - Channel 3 Global interrupt flag
            #[inline(always)]
            pub fn gif3(&self) -> GIF3_R {
                GIF3_R::new(((self.bits >> 8) & 1) != 0)
            }
            ///Bit 9 - Channel 3 Transfer Complete flag
            #[inline(always)]
            pub fn tcif3(&self) -> TCIF3_R {
                TCIF3_R::new(((self.bits >> 9) & 1) != 0)
            }
            ///Bit 10 - Channel 3 Half Transfer Complete flag
            #[inline(always)]
            pub fn htif3(&self) -> HTIF3_R {
                HTIF3_R::new(((self.bits >> 10) & 1) != 0)
            }
            ///Bit 11 - Channel 3 Transfer Error flag
            #[inline(always)]
            pub fn teif3(&self) -> TEIF3_R {
                TEIF3_R::new(((self.bits >> 11) & 1) != 0)
            }
            ///Bit 12 - Channel 4 Global interrupt flag
            #[inline(always)]
            pub fn gif4(&self) -> GIF4_R {
                GIF4_R::new(((self.bits >> 12) & 1) != 0)
            }
            ///Bit 13 - Channel 4 Transfer Complete flag
            #[inline(always)]
            pub fn tcif4(&self) -> TCIF4_R {
                TCIF4_R::new(((self.bits >> 13) & 1) != 0)
            }
            ///Bit 14 - Channel 4 Half Transfer Complete flag
            #[inline(always)]
            pub fn htif4(&self) -> HTIF4_R {
                HTIF4_R::new(((self.bits >> 14) & 1) != 0)
            }
            ///Bit 15 - Channel 4 Transfer Error flag
            #[inline(always)]
            pub fn teif4(&self) -> TEIF4_R {
                TEIF4_R::new(((self.bits >> 15) & 1) != 0)
            }
            ///Bit 16 - Channel 5 Global interrupt flag
            #[inline(always)]
            pub fn gif5(&self) -> GIF5_R {
                GIF5_R::new(((self.bits >> 16) & 1) != 0)
            }
            ///Bit 17 - Channel 5 Transfer Complete flag
            #[inline(always)]
            pub fn tcif5(&self) -> TCIF5_R {
                TCIF5_R::new(((self.bits >> 17) & 1) != 0)
            }
            ///Bit 18 - Channel 5 Half Transfer Complete flag
            #[inline(always)]
            pub fn htif5(&self) -> HTIF5_R {
                HTIF5_R::new(((self.bits >> 18) & 1) != 0)
            }
            ///Bit 19 - Channel 5 Transfer Error flag
            #[inline(always)]
            pub fn teif5(&self) -> TEIF5_R {
                TEIF5_R::new(((self.bits >> 19) & 1) != 0)
            }
            ///Bit 20 - Channel 6 Global interrupt flag
            #[inline(always)]
            pub fn gif6(&self) -> GIF6_R {
                GIF6_R::new(((self.bits >> 20) & 1) != 0)
            }
            ///Bit 21 - Channel 6 Transfer Complete flag
            #[inline(always)]
            pub fn tcif6(&self) -> TCIF6_R {
                TCIF6_R::new(((self.bits >> 21) & 1) != 0)
            }
            ///Bit 22 - Channel 6 Half Transfer Complete flag
            #[inline(always)]
            pub fn htif6(&self) -> HTIF6_R {
                HTIF6_R::new(((self.bits >> 22) & 1) != 0)
            }
            ///Bit 23 - Channel 6 Transfer Error flag
            #[inline(always)]
            pub fn teif6(&self) -> TEIF6_R {
                TEIF6_R::new(((self.bits >> 23) & 1) != 0)
            }
            ///Bit 24 - Channel 7 Global interrupt flag
            #[inline(always)]
            pub fn gif7(&self) -> GIF7_R {
                GIF7_R::new(((self.bits >> 24) & 1) != 0)
            }
            ///Bit 25 - Channel 7 Transfer Complete flag
            #[inline(always)]
            pub fn tcif7(&self) -> TCIF7_R {
                TCIF7_R::new(((self.bits >> 25) & 1) != 0)
            }
            ///Bit 26 - Channel 7 Half Transfer Complete flag
            #[inline(always)]
            pub fn htif7(&self) -> HTIF7_R {
                HTIF7_R::new(((self.bits >> 26) & 1) != 0)
            }
            ///Bit 27 - Channel 7 Transfer Error flag
            #[inline(always)]
            pub fn teif7(&self) -> TEIF7_R {
                TEIF7_R::new(((self.bits >> 27) & 1) != 0)
            }
            ///Bit 28 - Channel 8 Global interrupt flag use in ch32v20_D8/D8W/D6
            #[inline(always)]
            pub fn gif8(&self) -> GIF8_R {
                GIF8_R::new(((self.bits >> 28) & 1) != 0)
            }
            ///Bit 29 - Channel 8 Transfer Complete flag use in ch32v20_D8/D8W/D6
            #[inline(always)]
            pub fn tcif8(&self) -> TCIF8_R {
                TCIF8_R::new(((self.bits >> 29) & 1) != 0)
            }
            ///Bit 30 - Channel 8 Half Transfer Complete flag use in ch32v20_D8/D8W/D6
            #[inline(always)]
            pub fn htif8(&self) -> HTIF8_R {
                HTIF8_R::new(((self.bits >> 30) & 1) != 0)
            }
            ///Bit 31 - Channel 8 Transfer Error flag use in ch32v20_D8/D8W/D6
            #[inline(always)]
            pub fn teif8(&self) -> TEIF8_R {
                TEIF8_R::new(((self.bits >> 31) & 1) != 0)
            }
        }
        ///DMA interrupt status register (DMA_INTFR)
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`intfr::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct INTFR_SPEC;
        impl crate::RegisterSpec for INTFR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`intfr::R`](R) reader structure
        impl crate::Readable for INTFR_SPEC {}
        ///`reset()` method sets INTFR to value 0
        impl crate::Resettable for INTFR_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///INTFCR (w) register accessor: DMA interrupt flag clear register (DMA_INTFCR)
    ///
    ///You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`intfcr::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@intfcr`]
    ///module
    pub type INTFCR = crate::Reg<intfcr::INTFCR_SPEC>;
    ///DMA interrupt flag clear register (DMA_INTFCR)
    pub mod intfcr {
        ///Register `INTFCR` writer
        pub type W = crate::W<INTFCR_SPEC>;
        ///Field `CGIF1` writer - Channel 1 Global interrupt clear
        pub type CGIF1_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CTCIF1` writer - Channel 1 Transfer Complete clear
        pub type CTCIF1_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CHTIF1` writer - Channel 1 Half Transfer clear
        pub type CHTIF1_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CTEIF1` writer - Channel 1 Transfer Error clear
        pub type CTEIF1_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CGIF2` writer - Channel 2 Global interrupt clear
        pub type CGIF2_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CTCIF2` writer - Channel 2 Transfer Complete clear
        pub type CTCIF2_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CHTIF2` writer - Channel 2 Half Transfer clear
        pub type CHTIF2_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CTEIF2` writer - Channel 2 Transfer Error clear
        pub type CTEIF2_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CGIF3` writer - Channel 3 Global interrupt clear
        pub type CGIF3_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CTCIF3` writer - Channel 3 Transfer Complete clear
        pub type CTCIF3_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CHTIF3` writer - Channel 3 Half Transfer clear
        pub type CHTIF3_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CTEIF3` writer - Channel 3 Transfer Error clear
        pub type CTEIF3_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CGIF4` writer - Channel 4 Global interrupt clear
        pub type CGIF4_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CTCIF4` writer - Channel 4 Transfer Complete clear
        pub type CTCIF4_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CHTIF4` writer - Channel 4 Half Transfer clear
        pub type CHTIF4_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CTEIF4` writer - Channel 4 Transfer Error clear
        pub type CTEIF4_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CGIF5` writer - Channel 5 Global interrupt clear
        pub type CGIF5_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CTCIF5` writer - Channel 5 Transfer Complete clear
        pub type CTCIF5_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CHTIF5` writer - Channel 5 Half Transfer clear
        pub type CHTIF5_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CTEIF5` writer - Channel 5 Transfer Error clear
        pub type CTEIF5_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CGIF6` writer - Channel 6 Global interrupt clear
        pub type CGIF6_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CTCIF6` writer - Channel 6 Transfer Complete clear
        pub type CTCIF6_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CHTIF6` writer - Channel 6 Half Transfer clear
        pub type CHTIF6_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CTEIF6` writer - Channel 6 Transfer Error clear
        pub type CTEIF6_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CGIF7` writer - Channel 7 Global interrupt clear
        pub type CGIF7_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CTCIF7` writer - Channel 7 Transfer Complete clear
        pub type CTCIF7_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CHTIF7` writer - Channel 7 Half Transfer clear
        pub type CHTIF7_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CTEIF7` writer - Channel 7 Transfer Error clear
        pub type CTEIF7_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CGIF8` writer - Channel 8 Global interrupt clear use in ch32v20_D8/D8W/D6
        pub type CGIF8_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CTCIF8` writer - Channel 8 Transfer Complete clear use in ch32v20_D8/D8W/D6
        pub type CTCIF8_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CHTIF8` writer - Channel 8 Half Transfer clear use in ch32v20_D8/D8W/D6
        pub type CHTIF8_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CTEIF8` writer - Channel 8 Transfer Error clear use in ch32v20_D8/D8W/D6
        pub type CTEIF8_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl W {
            ///Bit 0 - Channel 1 Global interrupt clear
            #[inline(always)]
            #[must_use]
            pub fn cgif1(&mut self) -> CGIF1_W<INTFCR_SPEC> {
                CGIF1_W::new(self, 0)
            }
            ///Bit 1 - Channel 1 Transfer Complete clear
            #[inline(always)]
            #[must_use]
            pub fn ctcif1(&mut self) -> CTCIF1_W<INTFCR_SPEC> {
                CTCIF1_W::new(self, 1)
            }
            ///Bit 2 - Channel 1 Half Transfer clear
            #[inline(always)]
            #[must_use]
            pub fn chtif1(&mut self) -> CHTIF1_W<INTFCR_SPEC> {
                CHTIF1_W::new(self, 2)
            }
            ///Bit 3 - Channel 1 Transfer Error clear
            #[inline(always)]
            #[must_use]
            pub fn cteif1(&mut self) -> CTEIF1_W<INTFCR_SPEC> {
                CTEIF1_W::new(self, 3)
            }
            ///Bit 4 - Channel 2 Global interrupt clear
            #[inline(always)]
            #[must_use]
            pub fn cgif2(&mut self) -> CGIF2_W<INTFCR_SPEC> {
                CGIF2_W::new(self, 4)
            }
            ///Bit 5 - Channel 2 Transfer Complete clear
            #[inline(always)]
            #[must_use]
            pub fn ctcif2(&mut self) -> CTCIF2_W<INTFCR_SPEC> {
                CTCIF2_W::new(self, 5)
            }
            ///Bit 6 - Channel 2 Half Transfer clear
            #[inline(always)]
            #[must_use]
            pub fn chtif2(&mut self) -> CHTIF2_W<INTFCR_SPEC> {
                CHTIF2_W::new(self, 6)
            }
            ///Bit 7 - Channel 2 Transfer Error clear
            #[inline(always)]
            #[must_use]
            pub fn cteif2(&mut self) -> CTEIF2_W<INTFCR_SPEC> {
                CTEIF2_W::new(self, 7)
            }
            ///Bit 8 - Channel 3 Global interrupt clear
            #[inline(always)]
            #[must_use]
            pub fn cgif3(&mut self) -> CGIF3_W<INTFCR_SPEC> {
                CGIF3_W::new(self, 8)
            }
            ///Bit 9 - Channel 3 Transfer Complete clear
            #[inline(always)]
            #[must_use]
            pub fn ctcif3(&mut self) -> CTCIF3_W<INTFCR_SPEC> {
                CTCIF3_W::new(self, 9)
            }
            ///Bit 10 - Channel 3 Half Transfer clear
            #[inline(always)]
            #[must_use]
            pub fn chtif3(&mut self) -> CHTIF3_W<INTFCR_SPEC> {
                CHTIF3_W::new(self, 10)
            }
            ///Bit 11 - Channel 3 Transfer Error clear
            #[inline(always)]
            #[must_use]
            pub fn cteif3(&mut self) -> CTEIF3_W<INTFCR_SPEC> {
                CTEIF3_W::new(self, 11)
            }
            ///Bit 12 - Channel 4 Global interrupt clear
            #[inline(always)]
            #[must_use]
            pub fn cgif4(&mut self) -> CGIF4_W<INTFCR_SPEC> {
                CGIF4_W::new(self, 12)
            }
            ///Bit 13 - Channel 4 Transfer Complete clear
            #[inline(always)]
            #[must_use]
            pub fn ctcif4(&mut self) -> CTCIF4_W<INTFCR_SPEC> {
                CTCIF4_W::new(self, 13)
            }
            ///Bit 14 - Channel 4 Half Transfer clear
            #[inline(always)]
            #[must_use]
            pub fn chtif4(&mut self) -> CHTIF4_W<INTFCR_SPEC> {
                CHTIF4_W::new(self, 14)
            }
            ///Bit 15 - Channel 4 Transfer Error clear
            #[inline(always)]
            #[must_use]
            pub fn cteif4(&mut self) -> CTEIF4_W<INTFCR_SPEC> {
                CTEIF4_W::new(self, 15)
            }
            ///Bit 16 - Channel 5 Global interrupt clear
            #[inline(always)]
            #[must_use]
            pub fn cgif5(&mut self) -> CGIF5_W<INTFCR_SPEC> {
                CGIF5_W::new(self, 16)
            }
            ///Bit 17 - Channel 5 Transfer Complete clear
            #[inline(always)]
            #[must_use]
            pub fn ctcif5(&mut self) -> CTCIF5_W<INTFCR_SPEC> {
                CTCIF5_W::new(self, 17)
            }
            ///Bit 18 - Channel 5 Half Transfer clear
            #[inline(always)]
            #[must_use]
            pub fn chtif5(&mut self) -> CHTIF5_W<INTFCR_SPEC> {
                CHTIF5_W::new(self, 18)
            }
            ///Bit 19 - Channel 5 Transfer Error clear
            #[inline(always)]
            #[must_use]
            pub fn cteif5(&mut self) -> CTEIF5_W<INTFCR_SPEC> {
                CTEIF5_W::new(self, 19)
            }
            ///Bit 20 - Channel 6 Global interrupt clear
            #[inline(always)]
            #[must_use]
            pub fn cgif6(&mut self) -> CGIF6_W<INTFCR_SPEC> {
                CGIF6_W::new(self, 20)
            }
            ///Bit 21 - Channel 6 Transfer Complete clear
            #[inline(always)]
            #[must_use]
            pub fn ctcif6(&mut self) -> CTCIF6_W<INTFCR_SPEC> {
                CTCIF6_W::new(self, 21)
            }
            ///Bit 22 - Channel 6 Half Transfer clear
            #[inline(always)]
            #[must_use]
            pub fn chtif6(&mut self) -> CHTIF6_W<INTFCR_SPEC> {
                CHTIF6_W::new(self, 22)
            }
            ///Bit 23 - Channel 6 Transfer Error clear
            #[inline(always)]
            #[must_use]
            pub fn cteif6(&mut self) -> CTEIF6_W<INTFCR_SPEC> {
                CTEIF6_W::new(self, 23)
            }
            ///Bit 24 - Channel 7 Global interrupt clear
            #[inline(always)]
            #[must_use]
            pub fn cgif7(&mut self) -> CGIF7_W<INTFCR_SPEC> {
                CGIF7_W::new(self, 24)
            }
            ///Bit 25 - Channel 7 Transfer Complete clear
            #[inline(always)]
            #[must_use]
            pub fn ctcif7(&mut self) -> CTCIF7_W<INTFCR_SPEC> {
                CTCIF7_W::new(self, 25)
            }
            ///Bit 26 - Channel 7 Half Transfer clear
            #[inline(always)]
            #[must_use]
            pub fn chtif7(&mut self) -> CHTIF7_W<INTFCR_SPEC> {
                CHTIF7_W::new(self, 26)
            }
            ///Bit 27 - Channel 7 Transfer Error clear
            #[inline(always)]
            #[must_use]
            pub fn cteif7(&mut self) -> CTEIF7_W<INTFCR_SPEC> {
                CTEIF7_W::new(self, 27)
            }
            ///Bit 28 - Channel 8 Global interrupt clear use in ch32v20_D8/D8W/D6
            #[inline(always)]
            #[must_use]
            pub fn cgif8(&mut self) -> CGIF8_W<INTFCR_SPEC> {
                CGIF8_W::new(self, 28)
            }
            ///Bit 29 - Channel 8 Transfer Complete clear use in ch32v20_D8/D8W/D6
            #[inline(always)]
            #[must_use]
            pub fn ctcif8(&mut self) -> CTCIF8_W<INTFCR_SPEC> {
                CTCIF8_W::new(self, 29)
            }
            ///Bit 30 - Channel 8 Half Transfer clear use in ch32v20_D8/D8W/D6
            #[inline(always)]
            #[must_use]
            pub fn chtif8(&mut self) -> CHTIF8_W<INTFCR_SPEC> {
                CHTIF8_W::new(self, 30)
            }
            ///Bit 31 - Channel 8 Transfer Error clear use in ch32v20_D8/D8W/D6
            #[inline(always)]
            #[must_use]
            pub fn cteif8(&mut self) -> CTEIF8_W<INTFCR_SPEC> {
                CTEIF8_W::new(self, 31)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///DMA interrupt flag clear register (DMA_INTFCR)
        ///
        ///You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`intfcr::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct INTFCR_SPEC;
        impl crate::RegisterSpec for INTFCR_SPEC {
            type Ux = u32;
        }
        ///`write(|w| ..)` method takes [`intfcr::W`](W) writer structure
        impl crate::Writable for INTFCR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets INTFCR to value 0
        impl crate::Resettable for INTFCR_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///CFGR1 (rw) register accessor: DMA channel configuration register (DMA_CFGR)
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`cfgr1::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cfgr1::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@cfgr1`]
    ///module
    pub type CFGR1 = crate::Reg<cfgr1::CFGR1_SPEC>;
    ///DMA channel configuration register (DMA_CFGR)
    pub mod cfgr1 {
        ///Register `CFGR1` reader
        pub type R = crate::R<CFGR1_SPEC>;
        ///Register `CFGR1` writer
        pub type W = crate::W<CFGR1_SPEC>;
        ///Field `EN` reader - Channel enable
        pub type EN_R = crate::BitReader;
        ///Field `EN` writer - Channel enable
        pub type EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TCIE` reader - Transfer complete interrupt enable
        pub type TCIE_R = crate::BitReader;
        ///Field `TCIE` writer - Transfer complete interrupt enable
        pub type TCIE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `HTIE` reader - Half Transfer interrupt enable
        pub type HTIE_R = crate::BitReader;
        ///Field `HTIE` writer - Half Transfer interrupt enable
        pub type HTIE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TEIE` reader - Transfer error interrupt enable
        pub type TEIE_R = crate::BitReader;
        ///Field `TEIE` writer - Transfer error interrupt enable
        pub type TEIE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `DIR` reader - Data transfer direction
        pub type DIR_R = crate::BitReader;
        ///Field `DIR` writer - Data transfer direction
        pub type DIR_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CIRC` reader - Circular mode
        pub type CIRC_R = crate::BitReader;
        ///Field `CIRC` writer - Circular mode
        pub type CIRC_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PINC` reader - Peripheral increment mode
        pub type PINC_R = crate::BitReader;
        ///Field `PINC` writer - Peripheral increment mode
        pub type PINC_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `MINC` reader - Memory increment mode
        pub type MINC_R = crate::BitReader;
        ///Field `MINC` writer - Memory increment mode
        pub type MINC_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PSIZE` reader - Peripheral size
        pub type PSIZE_R = crate::FieldReader;
        ///Field `PSIZE` writer - Peripheral size
        pub type PSIZE_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `MSIZE` reader - Memory size
        pub type MSIZE_R = crate::FieldReader;
        ///Field `MSIZE` writer - Memory size
        pub type MSIZE_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `PL` reader - Channel Priority level
        pub type PL_R = crate::FieldReader;
        ///Field `PL` writer - Channel Priority level
        pub type PL_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `MEM2MEM` reader - Memory to memory mode
        pub type MEM2MEM_R = crate::BitReader;
        ///Field `MEM2MEM` writer - Memory to memory mode
        pub type MEM2MEM_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - Channel enable
            #[inline(always)]
            pub fn en(&self) -> EN_R {
                EN_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Transfer complete interrupt enable
            #[inline(always)]
            pub fn tcie(&self) -> TCIE_R {
                TCIE_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - Half Transfer interrupt enable
            #[inline(always)]
            pub fn htie(&self) -> HTIE_R {
                HTIE_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - Transfer error interrupt enable
            #[inline(always)]
            pub fn teie(&self) -> TEIE_R {
                TEIE_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - Data transfer direction
            #[inline(always)]
            pub fn dir(&self) -> DIR_R {
                DIR_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - Circular mode
            #[inline(always)]
            pub fn circ(&self) -> CIRC_R {
                CIRC_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - Peripheral increment mode
            #[inline(always)]
            pub fn pinc(&self) -> PINC_R {
                PINC_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - Memory increment mode
            #[inline(always)]
            pub fn minc(&self) -> MINC_R {
                MINC_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bits 8:9 - Peripheral size
            #[inline(always)]
            pub fn psize(&self) -> PSIZE_R {
                PSIZE_R::new(((self.bits >> 8) & 3) as u8)
            }
            ///Bits 10:11 - Memory size
            #[inline(always)]
            pub fn msize(&self) -> MSIZE_R {
                MSIZE_R::new(((self.bits >> 10) & 3) as u8)
            }
            ///Bits 12:13 - Channel Priority level
            #[inline(always)]
            pub fn pl(&self) -> PL_R {
                PL_R::new(((self.bits >> 12) & 3) as u8)
            }
            ///Bit 14 - Memory to memory mode
            #[inline(always)]
            pub fn mem2mem(&self) -> MEM2MEM_R {
                MEM2MEM_R::new(((self.bits >> 14) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - Channel enable
            #[inline(always)]
            #[must_use]
            pub fn en(&mut self) -> EN_W<CFGR1_SPEC> {
                EN_W::new(self, 0)
            }
            ///Bit 1 - Transfer complete interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn tcie(&mut self) -> TCIE_W<CFGR1_SPEC> {
                TCIE_W::new(self, 1)
            }
            ///Bit 2 - Half Transfer interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn htie(&mut self) -> HTIE_W<CFGR1_SPEC> {
                HTIE_W::new(self, 2)
            }
            ///Bit 3 - Transfer error interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn teie(&mut self) -> TEIE_W<CFGR1_SPEC> {
                TEIE_W::new(self, 3)
            }
            ///Bit 4 - Data transfer direction
            #[inline(always)]
            #[must_use]
            pub fn dir(&mut self) -> DIR_W<CFGR1_SPEC> {
                DIR_W::new(self, 4)
            }
            ///Bit 5 - Circular mode
            #[inline(always)]
            #[must_use]
            pub fn circ(&mut self) -> CIRC_W<CFGR1_SPEC> {
                CIRC_W::new(self, 5)
            }
            ///Bit 6 - Peripheral increment mode
            #[inline(always)]
            #[must_use]
            pub fn pinc(&mut self) -> PINC_W<CFGR1_SPEC> {
                PINC_W::new(self, 6)
            }
            ///Bit 7 - Memory increment mode
            #[inline(always)]
            #[must_use]
            pub fn minc(&mut self) -> MINC_W<CFGR1_SPEC> {
                MINC_W::new(self, 7)
            }
            ///Bits 8:9 - Peripheral size
            #[inline(always)]
            #[must_use]
            pub fn psize(&mut self) -> PSIZE_W<CFGR1_SPEC> {
                PSIZE_W::new(self, 8)
            }
            ///Bits 10:11 - Memory size
            #[inline(always)]
            #[must_use]
            pub fn msize(&mut self) -> MSIZE_W<CFGR1_SPEC> {
                MSIZE_W::new(self, 10)
            }
            ///Bits 12:13 - Channel Priority level
            #[inline(always)]
            #[must_use]
            pub fn pl(&mut self) -> PL_W<CFGR1_SPEC> {
                PL_W::new(self, 12)
            }
            ///Bit 14 - Memory to memory mode
            #[inline(always)]
            #[must_use]
            pub fn mem2mem(&mut self) -> MEM2MEM_W<CFGR1_SPEC> {
                MEM2MEM_W::new(self, 14)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///DMA channel configuration register (DMA_CFGR)
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`cfgr1::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cfgr1::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct CFGR1_SPEC;
        impl crate::RegisterSpec for CFGR1_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`cfgr1::R`](R) reader structure
        impl crate::Readable for CFGR1_SPEC {}
        ///`write(|w| ..)` method takes [`cfgr1::W`](W) writer structure
        impl crate::Writable for CFGR1_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets CFGR1 to value 0
        impl crate::Resettable for CFGR1_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///CNTR1 (rw) register accessor: DMA channel 1 number of data register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`cntr1::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cntr1::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@cntr1`]
    ///module
    pub type CNTR1 = crate::Reg<cntr1::CNTR1_SPEC>;
    ///DMA channel 1 number of data register
    pub mod cntr1 {
        ///Register `CNTR1` reader
        pub type R = crate::R<CNTR1_SPEC>;
        ///Register `CNTR1` writer
        pub type W = crate::W<CNTR1_SPEC>;
        ///Field `NDT` reader - Number of data to transfer
        pub type NDT_R = crate::FieldReader<u16>;
        ///Field `NDT` writer - Number of data to transfer
        pub type NDT_W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            ///Bits 0:15 - Number of data to transfer
            #[inline(always)]
            pub fn ndt(&self) -> NDT_R {
                NDT_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            ///Bits 0:15 - Number of data to transfer
            #[inline(always)]
            #[must_use]
            pub fn ndt(&mut self) -> NDT_W<CNTR1_SPEC> {
                NDT_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///DMA channel 1 number of data register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`cntr1::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cntr1::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct CNTR1_SPEC;
        impl crate::RegisterSpec for CNTR1_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`cntr1::R`](R) reader structure
        impl crate::Readable for CNTR1_SPEC {}
        ///`write(|w| ..)` method takes [`cntr1::W`](W) writer structure
        impl crate::Writable for CNTR1_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets CNTR1 to value 0
        impl crate::Resettable for CNTR1_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///PADDR1 (rw) register accessor: DMA channel 1 peripheral address register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`paddr1::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`paddr1::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@paddr1`]
    ///module
    pub type PADDR1 = crate::Reg<paddr1::PADDR1_SPEC>;
    ///DMA channel 1 peripheral address register
    pub mod paddr1 {
        ///Register `PADDR1` reader
        pub type R = crate::R<PADDR1_SPEC>;
        ///Register `PADDR1` writer
        pub type W = crate::W<PADDR1_SPEC>;
        ///Field `PA` reader - Peripheral address
        pub type PA_R = crate::FieldReader<u32>;
        ///Field `PA` writer - Peripheral address
        pub type PA_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - Peripheral address
            #[inline(always)]
            pub fn pa(&self) -> PA_R {
                PA_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - Peripheral address
            #[inline(always)]
            #[must_use]
            pub fn pa(&mut self) -> PA_W<PADDR1_SPEC> {
                PA_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///DMA channel 1 peripheral address register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`paddr1::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`paddr1::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct PADDR1_SPEC;
        impl crate::RegisterSpec for PADDR1_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`paddr1::R`](R) reader structure
        impl crate::Readable for PADDR1_SPEC {}
        ///`write(|w| ..)` method takes [`paddr1::W`](W) writer structure
        impl crate::Writable for PADDR1_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets PADDR1 to value 0
        impl crate::Resettable for PADDR1_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///MADDR1 (rw) register accessor: DMA channel 1 memory address register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`maddr1::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`maddr1::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@maddr1`]
    ///module
    pub type MADDR1 = crate::Reg<maddr1::MADDR1_SPEC>;
    ///DMA channel 1 memory address register
    pub mod maddr1 {
        ///Register `MADDR1` reader
        pub type R = crate::R<MADDR1_SPEC>;
        ///Register `MADDR1` writer
        pub type W = crate::W<MADDR1_SPEC>;
        ///Field `MA` reader - Memory address
        pub type MA_R = crate::FieldReader<u32>;
        ///Field `MA` writer - Memory address
        pub type MA_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - Memory address
            #[inline(always)]
            pub fn ma(&self) -> MA_R {
                MA_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - Memory address
            #[inline(always)]
            #[must_use]
            pub fn ma(&mut self) -> MA_W<MADDR1_SPEC> {
                MA_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///DMA channel 1 memory address register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`maddr1::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`maddr1::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct MADDR1_SPEC;
        impl crate::RegisterSpec for MADDR1_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`maddr1::R`](R) reader structure
        impl crate::Readable for MADDR1_SPEC {}
        ///`write(|w| ..)` method takes [`maddr1::W`](W) writer structure
        impl crate::Writable for MADDR1_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets MADDR1 to value 0
        impl crate::Resettable for MADDR1_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///CFGR2 (rw) register accessor: DMA channel configuration register (DMA_CFGR)
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`cfgr2::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cfgr2::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@cfgr2`]
    ///module
    pub type CFGR2 = crate::Reg<cfgr2::CFGR2_SPEC>;
    ///DMA channel configuration register (DMA_CFGR)
    pub mod cfgr2 {
        ///Register `CFGR2` reader
        pub type R = crate::R<CFGR2_SPEC>;
        ///Register `CFGR2` writer
        pub type W = crate::W<CFGR2_SPEC>;
        ///Field `EN` reader - Channel enable
        pub type EN_R = crate::BitReader;
        ///Field `EN` writer - Channel enable
        pub type EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TCIE` reader - Transfer complete interrupt enable
        pub type TCIE_R = crate::BitReader;
        ///Field `TCIE` writer - Transfer complete interrupt enable
        pub type TCIE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `HTIE` reader - Half Transfer interrupt enable
        pub type HTIE_R = crate::BitReader;
        ///Field `HTIE` writer - Half Transfer interrupt enable
        pub type HTIE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TEIE` reader - Transfer error interrupt enable
        pub type TEIE_R = crate::BitReader;
        ///Field `TEIE` writer - Transfer error interrupt enable
        pub type TEIE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `DIR` reader - Data transfer direction
        pub type DIR_R = crate::BitReader;
        ///Field `DIR` writer - Data transfer direction
        pub type DIR_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CIRC` reader - Circular mode
        pub type CIRC_R = crate::BitReader;
        ///Field `CIRC` writer - Circular mode
        pub type CIRC_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PINC` reader - Peripheral increment mode
        pub type PINC_R = crate::BitReader;
        ///Field `PINC` writer - Peripheral increment mode
        pub type PINC_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `MINC` reader - Memory increment mode
        pub type MINC_R = crate::BitReader;
        ///Field `MINC` writer - Memory increment mode
        pub type MINC_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PSIZE` reader - Peripheral size
        pub type PSIZE_R = crate::FieldReader;
        ///Field `PSIZE` writer - Peripheral size
        pub type PSIZE_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `MSIZE` reader - Memory size
        pub type MSIZE_R = crate::FieldReader;
        ///Field `MSIZE` writer - Memory size
        pub type MSIZE_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `PL` reader - Channel Priority level
        pub type PL_R = crate::FieldReader;
        ///Field `PL` writer - Channel Priority level
        pub type PL_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `MEM2MEM` reader - Memory to memory mode
        pub type MEM2MEM_R = crate::BitReader;
        ///Field `MEM2MEM` writer - Memory to memory mode
        pub type MEM2MEM_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - Channel enable
            #[inline(always)]
            pub fn en(&self) -> EN_R {
                EN_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Transfer complete interrupt enable
            #[inline(always)]
            pub fn tcie(&self) -> TCIE_R {
                TCIE_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - Half Transfer interrupt enable
            #[inline(always)]
            pub fn htie(&self) -> HTIE_R {
                HTIE_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - Transfer error interrupt enable
            #[inline(always)]
            pub fn teie(&self) -> TEIE_R {
                TEIE_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - Data transfer direction
            #[inline(always)]
            pub fn dir(&self) -> DIR_R {
                DIR_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - Circular mode
            #[inline(always)]
            pub fn circ(&self) -> CIRC_R {
                CIRC_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - Peripheral increment mode
            #[inline(always)]
            pub fn pinc(&self) -> PINC_R {
                PINC_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - Memory increment mode
            #[inline(always)]
            pub fn minc(&self) -> MINC_R {
                MINC_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bits 8:9 - Peripheral size
            #[inline(always)]
            pub fn psize(&self) -> PSIZE_R {
                PSIZE_R::new(((self.bits >> 8) & 3) as u8)
            }
            ///Bits 10:11 - Memory size
            #[inline(always)]
            pub fn msize(&self) -> MSIZE_R {
                MSIZE_R::new(((self.bits >> 10) & 3) as u8)
            }
            ///Bits 12:13 - Channel Priority level
            #[inline(always)]
            pub fn pl(&self) -> PL_R {
                PL_R::new(((self.bits >> 12) & 3) as u8)
            }
            ///Bit 14 - Memory to memory mode
            #[inline(always)]
            pub fn mem2mem(&self) -> MEM2MEM_R {
                MEM2MEM_R::new(((self.bits >> 14) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - Channel enable
            #[inline(always)]
            #[must_use]
            pub fn en(&mut self) -> EN_W<CFGR2_SPEC> {
                EN_W::new(self, 0)
            }
            ///Bit 1 - Transfer complete interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn tcie(&mut self) -> TCIE_W<CFGR2_SPEC> {
                TCIE_W::new(self, 1)
            }
            ///Bit 2 - Half Transfer interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn htie(&mut self) -> HTIE_W<CFGR2_SPEC> {
                HTIE_W::new(self, 2)
            }
            ///Bit 3 - Transfer error interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn teie(&mut self) -> TEIE_W<CFGR2_SPEC> {
                TEIE_W::new(self, 3)
            }
            ///Bit 4 - Data transfer direction
            #[inline(always)]
            #[must_use]
            pub fn dir(&mut self) -> DIR_W<CFGR2_SPEC> {
                DIR_W::new(self, 4)
            }
            ///Bit 5 - Circular mode
            #[inline(always)]
            #[must_use]
            pub fn circ(&mut self) -> CIRC_W<CFGR2_SPEC> {
                CIRC_W::new(self, 5)
            }
            ///Bit 6 - Peripheral increment mode
            #[inline(always)]
            #[must_use]
            pub fn pinc(&mut self) -> PINC_W<CFGR2_SPEC> {
                PINC_W::new(self, 6)
            }
            ///Bit 7 - Memory increment mode
            #[inline(always)]
            #[must_use]
            pub fn minc(&mut self) -> MINC_W<CFGR2_SPEC> {
                MINC_W::new(self, 7)
            }
            ///Bits 8:9 - Peripheral size
            #[inline(always)]
            #[must_use]
            pub fn psize(&mut self) -> PSIZE_W<CFGR2_SPEC> {
                PSIZE_W::new(self, 8)
            }
            ///Bits 10:11 - Memory size
            #[inline(always)]
            #[must_use]
            pub fn msize(&mut self) -> MSIZE_W<CFGR2_SPEC> {
                MSIZE_W::new(self, 10)
            }
            ///Bits 12:13 - Channel Priority level
            #[inline(always)]
            #[must_use]
            pub fn pl(&mut self) -> PL_W<CFGR2_SPEC> {
                PL_W::new(self, 12)
            }
            ///Bit 14 - Memory to memory mode
            #[inline(always)]
            #[must_use]
            pub fn mem2mem(&mut self) -> MEM2MEM_W<CFGR2_SPEC> {
                MEM2MEM_W::new(self, 14)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///DMA channel configuration register (DMA_CFGR)
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`cfgr2::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cfgr2::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct CFGR2_SPEC;
        impl crate::RegisterSpec for CFGR2_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`cfgr2::R`](R) reader structure
        impl crate::Readable for CFGR2_SPEC {}
        ///`write(|w| ..)` method takes [`cfgr2::W`](W) writer structure
        impl crate::Writable for CFGR2_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets CFGR2 to value 0
        impl crate::Resettable for CFGR2_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///CNTR2 (rw) register accessor: DMA channel 2 number of data register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`cntr2::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cntr2::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@cntr2`]
    ///module
    pub type CNTR2 = crate::Reg<cntr2::CNTR2_SPEC>;
    ///DMA channel 2 number of data register
    pub mod cntr2 {
        ///Register `CNTR2` reader
        pub type R = crate::R<CNTR2_SPEC>;
        ///Register `CNTR2` writer
        pub type W = crate::W<CNTR2_SPEC>;
        ///Field `NDT` reader - Number of data to transfer
        pub type NDT_R = crate::FieldReader<u16>;
        ///Field `NDT` writer - Number of data to transfer
        pub type NDT_W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            ///Bits 0:15 - Number of data to transfer
            #[inline(always)]
            pub fn ndt(&self) -> NDT_R {
                NDT_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            ///Bits 0:15 - Number of data to transfer
            #[inline(always)]
            #[must_use]
            pub fn ndt(&mut self) -> NDT_W<CNTR2_SPEC> {
                NDT_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///DMA channel 2 number of data register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`cntr2::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cntr2::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct CNTR2_SPEC;
        impl crate::RegisterSpec for CNTR2_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`cntr2::R`](R) reader structure
        impl crate::Readable for CNTR2_SPEC {}
        ///`write(|w| ..)` method takes [`cntr2::W`](W) writer structure
        impl crate::Writable for CNTR2_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets CNTR2 to value 0
        impl crate::Resettable for CNTR2_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///PADDR2 (rw) register accessor: DMA channel 2 peripheral address register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`paddr2::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`paddr2::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@paddr2`]
    ///module
    pub type PADDR2 = crate::Reg<paddr2::PADDR2_SPEC>;
    ///DMA channel 2 peripheral address register
    pub mod paddr2 {
        ///Register `PADDR2` reader
        pub type R = crate::R<PADDR2_SPEC>;
        ///Register `PADDR2` writer
        pub type W = crate::W<PADDR2_SPEC>;
        ///Field `PA` reader - Peripheral address
        pub type PA_R = crate::FieldReader<u32>;
        ///Field `PA` writer - Peripheral address
        pub type PA_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - Peripheral address
            #[inline(always)]
            pub fn pa(&self) -> PA_R {
                PA_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - Peripheral address
            #[inline(always)]
            #[must_use]
            pub fn pa(&mut self) -> PA_W<PADDR2_SPEC> {
                PA_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///DMA channel 2 peripheral address register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`paddr2::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`paddr2::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct PADDR2_SPEC;
        impl crate::RegisterSpec for PADDR2_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`paddr2::R`](R) reader structure
        impl crate::Readable for PADDR2_SPEC {}
        ///`write(|w| ..)` method takes [`paddr2::W`](W) writer structure
        impl crate::Writable for PADDR2_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets PADDR2 to value 0
        impl crate::Resettable for PADDR2_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///MADDR2 (rw) register accessor: DMA channel 2 memory address register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`maddr2::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`maddr2::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@maddr2`]
    ///module
    pub type MADDR2 = crate::Reg<maddr2::MADDR2_SPEC>;
    ///DMA channel 2 memory address register
    pub mod maddr2 {
        ///Register `MADDR2` reader
        pub type R = crate::R<MADDR2_SPEC>;
        ///Register `MADDR2` writer
        pub type W = crate::W<MADDR2_SPEC>;
        ///Field `MA` reader - Memory address
        pub type MA_R = crate::FieldReader<u32>;
        ///Field `MA` writer - Memory address
        pub type MA_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - Memory address
            #[inline(always)]
            pub fn ma(&self) -> MA_R {
                MA_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - Memory address
            #[inline(always)]
            #[must_use]
            pub fn ma(&mut self) -> MA_W<MADDR2_SPEC> {
                MA_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///DMA channel 2 memory address register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`maddr2::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`maddr2::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct MADDR2_SPEC;
        impl crate::RegisterSpec for MADDR2_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`maddr2::R`](R) reader structure
        impl crate::Readable for MADDR2_SPEC {}
        ///`write(|w| ..)` method takes [`maddr2::W`](W) writer structure
        impl crate::Writable for MADDR2_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets MADDR2 to value 0
        impl crate::Resettable for MADDR2_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///CFGR3 (rw) register accessor: DMA channel configuration register (DMA_CFGR)
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`cfgr3::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cfgr3::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@cfgr3`]
    ///module
    pub type CFGR3 = crate::Reg<cfgr3::CFGR3_SPEC>;
    ///DMA channel configuration register (DMA_CFGR)
    pub mod cfgr3 {
        ///Register `CFGR3` reader
        pub type R = crate::R<CFGR3_SPEC>;
        ///Register `CFGR3` writer
        pub type W = crate::W<CFGR3_SPEC>;
        ///Field `EN` reader - Channel enable
        pub type EN_R = crate::BitReader;
        ///Field `EN` writer - Channel enable
        pub type EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TCIE` reader - Transfer complete interrupt enable
        pub type TCIE_R = crate::BitReader;
        ///Field `TCIE` writer - Transfer complete interrupt enable
        pub type TCIE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `HTIE` reader - Half Transfer interrupt enable
        pub type HTIE_R = crate::BitReader;
        ///Field `HTIE` writer - Half Transfer interrupt enable
        pub type HTIE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TEIE` reader - Transfer error interrupt enable
        pub type TEIE_R = crate::BitReader;
        ///Field `TEIE` writer - Transfer error interrupt enable
        pub type TEIE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `DIR` reader - Data transfer direction
        pub type DIR_R = crate::BitReader;
        ///Field `DIR` writer - Data transfer direction
        pub type DIR_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CIRC` reader - Circular mode
        pub type CIRC_R = crate::BitReader;
        ///Field `CIRC` writer - Circular mode
        pub type CIRC_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PINC` reader - Peripheral increment mode
        pub type PINC_R = crate::BitReader;
        ///Field `PINC` writer - Peripheral increment mode
        pub type PINC_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `MINC` reader - Memory increment mode
        pub type MINC_R = crate::BitReader;
        ///Field `MINC` writer - Memory increment mode
        pub type MINC_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PSIZE` reader - Peripheral size
        pub type PSIZE_R = crate::FieldReader;
        ///Field `PSIZE` writer - Peripheral size
        pub type PSIZE_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `MSIZE` reader - Memory size
        pub type MSIZE_R = crate::FieldReader;
        ///Field `MSIZE` writer - Memory size
        pub type MSIZE_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `PL` reader - Channel Priority level
        pub type PL_R = crate::FieldReader;
        ///Field `PL` writer - Channel Priority level
        pub type PL_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `MEM2MEM` reader - Memory to memory mode
        pub type MEM2MEM_R = crate::BitReader;
        ///Field `MEM2MEM` writer - Memory to memory mode
        pub type MEM2MEM_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - Channel enable
            #[inline(always)]
            pub fn en(&self) -> EN_R {
                EN_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Transfer complete interrupt enable
            #[inline(always)]
            pub fn tcie(&self) -> TCIE_R {
                TCIE_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - Half Transfer interrupt enable
            #[inline(always)]
            pub fn htie(&self) -> HTIE_R {
                HTIE_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - Transfer error interrupt enable
            #[inline(always)]
            pub fn teie(&self) -> TEIE_R {
                TEIE_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - Data transfer direction
            #[inline(always)]
            pub fn dir(&self) -> DIR_R {
                DIR_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - Circular mode
            #[inline(always)]
            pub fn circ(&self) -> CIRC_R {
                CIRC_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - Peripheral increment mode
            #[inline(always)]
            pub fn pinc(&self) -> PINC_R {
                PINC_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - Memory increment mode
            #[inline(always)]
            pub fn minc(&self) -> MINC_R {
                MINC_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bits 8:9 - Peripheral size
            #[inline(always)]
            pub fn psize(&self) -> PSIZE_R {
                PSIZE_R::new(((self.bits >> 8) & 3) as u8)
            }
            ///Bits 10:11 - Memory size
            #[inline(always)]
            pub fn msize(&self) -> MSIZE_R {
                MSIZE_R::new(((self.bits >> 10) & 3) as u8)
            }
            ///Bits 12:13 - Channel Priority level
            #[inline(always)]
            pub fn pl(&self) -> PL_R {
                PL_R::new(((self.bits >> 12) & 3) as u8)
            }
            ///Bit 14 - Memory to memory mode
            #[inline(always)]
            pub fn mem2mem(&self) -> MEM2MEM_R {
                MEM2MEM_R::new(((self.bits >> 14) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - Channel enable
            #[inline(always)]
            #[must_use]
            pub fn en(&mut self) -> EN_W<CFGR3_SPEC> {
                EN_W::new(self, 0)
            }
            ///Bit 1 - Transfer complete interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn tcie(&mut self) -> TCIE_W<CFGR3_SPEC> {
                TCIE_W::new(self, 1)
            }
            ///Bit 2 - Half Transfer interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn htie(&mut self) -> HTIE_W<CFGR3_SPEC> {
                HTIE_W::new(self, 2)
            }
            ///Bit 3 - Transfer error interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn teie(&mut self) -> TEIE_W<CFGR3_SPEC> {
                TEIE_W::new(self, 3)
            }
            ///Bit 4 - Data transfer direction
            #[inline(always)]
            #[must_use]
            pub fn dir(&mut self) -> DIR_W<CFGR3_SPEC> {
                DIR_W::new(self, 4)
            }
            ///Bit 5 - Circular mode
            #[inline(always)]
            #[must_use]
            pub fn circ(&mut self) -> CIRC_W<CFGR3_SPEC> {
                CIRC_W::new(self, 5)
            }
            ///Bit 6 - Peripheral increment mode
            #[inline(always)]
            #[must_use]
            pub fn pinc(&mut self) -> PINC_W<CFGR3_SPEC> {
                PINC_W::new(self, 6)
            }
            ///Bit 7 - Memory increment mode
            #[inline(always)]
            #[must_use]
            pub fn minc(&mut self) -> MINC_W<CFGR3_SPEC> {
                MINC_W::new(self, 7)
            }
            ///Bits 8:9 - Peripheral size
            #[inline(always)]
            #[must_use]
            pub fn psize(&mut self) -> PSIZE_W<CFGR3_SPEC> {
                PSIZE_W::new(self, 8)
            }
            ///Bits 10:11 - Memory size
            #[inline(always)]
            #[must_use]
            pub fn msize(&mut self) -> MSIZE_W<CFGR3_SPEC> {
                MSIZE_W::new(self, 10)
            }
            ///Bits 12:13 - Channel Priority level
            #[inline(always)]
            #[must_use]
            pub fn pl(&mut self) -> PL_W<CFGR3_SPEC> {
                PL_W::new(self, 12)
            }
            ///Bit 14 - Memory to memory mode
            #[inline(always)]
            #[must_use]
            pub fn mem2mem(&mut self) -> MEM2MEM_W<CFGR3_SPEC> {
                MEM2MEM_W::new(self, 14)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///DMA channel configuration register (DMA_CFGR)
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`cfgr3::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cfgr3::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct CFGR3_SPEC;
        impl crate::RegisterSpec for CFGR3_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`cfgr3::R`](R) reader structure
        impl crate::Readable for CFGR3_SPEC {}
        ///`write(|w| ..)` method takes [`cfgr3::W`](W) writer structure
        impl crate::Writable for CFGR3_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets CFGR3 to value 0
        impl crate::Resettable for CFGR3_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///CNTR3 (rw) register accessor: DMA channel 3 number of data register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`cntr3::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cntr3::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@cntr3`]
    ///module
    pub type CNTR3 = crate::Reg<cntr3::CNTR3_SPEC>;
    ///DMA channel 3 number of data register
    pub mod cntr3 {
        ///Register `CNTR3` reader
        pub type R = crate::R<CNTR3_SPEC>;
        ///Register `CNTR3` writer
        pub type W = crate::W<CNTR3_SPEC>;
        ///Field `NDT` reader - Number of data to transfer
        pub type NDT_R = crate::FieldReader<u16>;
        ///Field `NDT` writer - Number of data to transfer
        pub type NDT_W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            ///Bits 0:15 - Number of data to transfer
            #[inline(always)]
            pub fn ndt(&self) -> NDT_R {
                NDT_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            ///Bits 0:15 - Number of data to transfer
            #[inline(always)]
            #[must_use]
            pub fn ndt(&mut self) -> NDT_W<CNTR3_SPEC> {
                NDT_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///DMA channel 3 number of data register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`cntr3::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cntr3::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct CNTR3_SPEC;
        impl crate::RegisterSpec for CNTR3_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`cntr3::R`](R) reader structure
        impl crate::Readable for CNTR3_SPEC {}
        ///`write(|w| ..)` method takes [`cntr3::W`](W) writer structure
        impl crate::Writable for CNTR3_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets CNTR3 to value 0
        impl crate::Resettable for CNTR3_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///PADDR3 (rw) register accessor: DMA channel 3 peripheral address register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`paddr3::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`paddr3::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@paddr3`]
    ///module
    pub type PADDR3 = crate::Reg<paddr3::PADDR3_SPEC>;
    ///DMA channel 3 peripheral address register
    pub mod paddr3 {
        ///Register `PADDR3` reader
        pub type R = crate::R<PADDR3_SPEC>;
        ///Register `PADDR3` writer
        pub type W = crate::W<PADDR3_SPEC>;
        ///Field `PA` reader - Peripheral address
        pub type PA_R = crate::FieldReader<u32>;
        ///Field `PA` writer - Peripheral address
        pub type PA_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - Peripheral address
            #[inline(always)]
            pub fn pa(&self) -> PA_R {
                PA_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - Peripheral address
            #[inline(always)]
            #[must_use]
            pub fn pa(&mut self) -> PA_W<PADDR3_SPEC> {
                PA_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///DMA channel 3 peripheral address register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`paddr3::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`paddr3::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct PADDR3_SPEC;
        impl crate::RegisterSpec for PADDR3_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`paddr3::R`](R) reader structure
        impl crate::Readable for PADDR3_SPEC {}
        ///`write(|w| ..)` method takes [`paddr3::W`](W) writer structure
        impl crate::Writable for PADDR3_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets PADDR3 to value 0
        impl crate::Resettable for PADDR3_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///MADDR3 (rw) register accessor: DMA channel 3 memory address register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`maddr3::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`maddr3::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@maddr3`]
    ///module
    pub type MADDR3 = crate::Reg<maddr3::MADDR3_SPEC>;
    ///DMA channel 3 memory address register
    pub mod maddr3 {
        ///Register `MADDR3` reader
        pub type R = crate::R<MADDR3_SPEC>;
        ///Register `MADDR3` writer
        pub type W = crate::W<MADDR3_SPEC>;
        ///Field `MA` reader - Memory address
        pub type MA_R = crate::FieldReader<u32>;
        ///Field `MA` writer - Memory address
        pub type MA_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - Memory address
            #[inline(always)]
            pub fn ma(&self) -> MA_R {
                MA_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - Memory address
            #[inline(always)]
            #[must_use]
            pub fn ma(&mut self) -> MA_W<MADDR3_SPEC> {
                MA_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///DMA channel 3 memory address register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`maddr3::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`maddr3::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct MADDR3_SPEC;
        impl crate::RegisterSpec for MADDR3_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`maddr3::R`](R) reader structure
        impl crate::Readable for MADDR3_SPEC {}
        ///`write(|w| ..)` method takes [`maddr3::W`](W) writer structure
        impl crate::Writable for MADDR3_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets MADDR3 to value 0
        impl crate::Resettable for MADDR3_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///CFGR4 (rw) register accessor: DMA channel configuration register (DMA_CFGR)
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`cfgr4::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cfgr4::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@cfgr4`]
    ///module
    pub type CFGR4 = crate::Reg<cfgr4::CFGR4_SPEC>;
    ///DMA channel configuration register (DMA_CFGR)
    pub mod cfgr4 {
        ///Register `CFGR4` reader
        pub type R = crate::R<CFGR4_SPEC>;
        ///Register `CFGR4` writer
        pub type W = crate::W<CFGR4_SPEC>;
        ///Field `EN` reader - Channel enable
        pub type EN_R = crate::BitReader;
        ///Field `EN` writer - Channel enable
        pub type EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TCIE` reader - Transfer complete interrupt enable
        pub type TCIE_R = crate::BitReader;
        ///Field `TCIE` writer - Transfer complete interrupt enable
        pub type TCIE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `HTIE` reader - Half Transfer interrupt enable
        pub type HTIE_R = crate::BitReader;
        ///Field `HTIE` writer - Half Transfer interrupt enable
        pub type HTIE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TEIE` reader - Transfer error interrupt enable
        pub type TEIE_R = crate::BitReader;
        ///Field `TEIE` writer - Transfer error interrupt enable
        pub type TEIE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `DIR` reader - Data transfer direction
        pub type DIR_R = crate::BitReader;
        ///Field `DIR` writer - Data transfer direction
        pub type DIR_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CIRC` reader - Circular mode
        pub type CIRC_R = crate::BitReader;
        ///Field `CIRC` writer - Circular mode
        pub type CIRC_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PINC` reader - Peripheral increment mode
        pub type PINC_R = crate::BitReader;
        ///Field `PINC` writer - Peripheral increment mode
        pub type PINC_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `MINC` reader - Memory increment mode
        pub type MINC_R = crate::BitReader;
        ///Field `MINC` writer - Memory increment mode
        pub type MINC_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PSIZE` reader - Peripheral size
        pub type PSIZE_R = crate::FieldReader;
        ///Field `PSIZE` writer - Peripheral size
        pub type PSIZE_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `MSIZE` reader - Memory size
        pub type MSIZE_R = crate::FieldReader;
        ///Field `MSIZE` writer - Memory size
        pub type MSIZE_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `PL` reader - Channel Priority level
        pub type PL_R = crate::FieldReader;
        ///Field `PL` writer - Channel Priority level
        pub type PL_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `MEM2MEM` reader - Memory to memory mode
        pub type MEM2MEM_R = crate::BitReader;
        ///Field `MEM2MEM` writer - Memory to memory mode
        pub type MEM2MEM_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - Channel enable
            #[inline(always)]
            pub fn en(&self) -> EN_R {
                EN_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Transfer complete interrupt enable
            #[inline(always)]
            pub fn tcie(&self) -> TCIE_R {
                TCIE_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - Half Transfer interrupt enable
            #[inline(always)]
            pub fn htie(&self) -> HTIE_R {
                HTIE_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - Transfer error interrupt enable
            #[inline(always)]
            pub fn teie(&self) -> TEIE_R {
                TEIE_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - Data transfer direction
            #[inline(always)]
            pub fn dir(&self) -> DIR_R {
                DIR_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - Circular mode
            #[inline(always)]
            pub fn circ(&self) -> CIRC_R {
                CIRC_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - Peripheral increment mode
            #[inline(always)]
            pub fn pinc(&self) -> PINC_R {
                PINC_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - Memory increment mode
            #[inline(always)]
            pub fn minc(&self) -> MINC_R {
                MINC_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bits 8:9 - Peripheral size
            #[inline(always)]
            pub fn psize(&self) -> PSIZE_R {
                PSIZE_R::new(((self.bits >> 8) & 3) as u8)
            }
            ///Bits 10:11 - Memory size
            #[inline(always)]
            pub fn msize(&self) -> MSIZE_R {
                MSIZE_R::new(((self.bits >> 10) & 3) as u8)
            }
            ///Bits 12:13 - Channel Priority level
            #[inline(always)]
            pub fn pl(&self) -> PL_R {
                PL_R::new(((self.bits >> 12) & 3) as u8)
            }
            ///Bit 14 - Memory to memory mode
            #[inline(always)]
            pub fn mem2mem(&self) -> MEM2MEM_R {
                MEM2MEM_R::new(((self.bits >> 14) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - Channel enable
            #[inline(always)]
            #[must_use]
            pub fn en(&mut self) -> EN_W<CFGR4_SPEC> {
                EN_W::new(self, 0)
            }
            ///Bit 1 - Transfer complete interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn tcie(&mut self) -> TCIE_W<CFGR4_SPEC> {
                TCIE_W::new(self, 1)
            }
            ///Bit 2 - Half Transfer interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn htie(&mut self) -> HTIE_W<CFGR4_SPEC> {
                HTIE_W::new(self, 2)
            }
            ///Bit 3 - Transfer error interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn teie(&mut self) -> TEIE_W<CFGR4_SPEC> {
                TEIE_W::new(self, 3)
            }
            ///Bit 4 - Data transfer direction
            #[inline(always)]
            #[must_use]
            pub fn dir(&mut self) -> DIR_W<CFGR4_SPEC> {
                DIR_W::new(self, 4)
            }
            ///Bit 5 - Circular mode
            #[inline(always)]
            #[must_use]
            pub fn circ(&mut self) -> CIRC_W<CFGR4_SPEC> {
                CIRC_W::new(self, 5)
            }
            ///Bit 6 - Peripheral increment mode
            #[inline(always)]
            #[must_use]
            pub fn pinc(&mut self) -> PINC_W<CFGR4_SPEC> {
                PINC_W::new(self, 6)
            }
            ///Bit 7 - Memory increment mode
            #[inline(always)]
            #[must_use]
            pub fn minc(&mut self) -> MINC_W<CFGR4_SPEC> {
                MINC_W::new(self, 7)
            }
            ///Bits 8:9 - Peripheral size
            #[inline(always)]
            #[must_use]
            pub fn psize(&mut self) -> PSIZE_W<CFGR4_SPEC> {
                PSIZE_W::new(self, 8)
            }
            ///Bits 10:11 - Memory size
            #[inline(always)]
            #[must_use]
            pub fn msize(&mut self) -> MSIZE_W<CFGR4_SPEC> {
                MSIZE_W::new(self, 10)
            }
            ///Bits 12:13 - Channel Priority level
            #[inline(always)]
            #[must_use]
            pub fn pl(&mut self) -> PL_W<CFGR4_SPEC> {
                PL_W::new(self, 12)
            }
            ///Bit 14 - Memory to memory mode
            #[inline(always)]
            #[must_use]
            pub fn mem2mem(&mut self) -> MEM2MEM_W<CFGR4_SPEC> {
                MEM2MEM_W::new(self, 14)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///DMA channel configuration register (DMA_CFGR)
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`cfgr4::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cfgr4::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct CFGR4_SPEC;
        impl crate::RegisterSpec for CFGR4_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`cfgr4::R`](R) reader structure
        impl crate::Readable for CFGR4_SPEC {}
        ///`write(|w| ..)` method takes [`cfgr4::W`](W) writer structure
        impl crate::Writable for CFGR4_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets CFGR4 to value 0
        impl crate::Resettable for CFGR4_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///CNTR4 (rw) register accessor: DMA channel 4 number of data register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`cntr4::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cntr4::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@cntr4`]
    ///module
    pub type CNTR4 = crate::Reg<cntr4::CNTR4_SPEC>;
    ///DMA channel 4 number of data register
    pub mod cntr4 {
        ///Register `CNTR4` reader
        pub type R = crate::R<CNTR4_SPEC>;
        ///Register `CNTR4` writer
        pub type W = crate::W<CNTR4_SPEC>;
        ///Field `NDT` reader - Number of data to transfer
        pub type NDT_R = crate::FieldReader<u16>;
        ///Field `NDT` writer - Number of data to transfer
        pub type NDT_W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            ///Bits 0:15 - Number of data to transfer
            #[inline(always)]
            pub fn ndt(&self) -> NDT_R {
                NDT_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            ///Bits 0:15 - Number of data to transfer
            #[inline(always)]
            #[must_use]
            pub fn ndt(&mut self) -> NDT_W<CNTR4_SPEC> {
                NDT_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///DMA channel 4 number of data register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`cntr4::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cntr4::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct CNTR4_SPEC;
        impl crate::RegisterSpec for CNTR4_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`cntr4::R`](R) reader structure
        impl crate::Readable for CNTR4_SPEC {}
        ///`write(|w| ..)` method takes [`cntr4::W`](W) writer structure
        impl crate::Writable for CNTR4_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets CNTR4 to value 0
        impl crate::Resettable for CNTR4_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///PADDR4 (rw) register accessor: DMA channel 4 peripheral address register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`paddr4::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`paddr4::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@paddr4`]
    ///module
    pub type PADDR4 = crate::Reg<paddr4::PADDR4_SPEC>;
    ///DMA channel 4 peripheral address register
    pub mod paddr4 {
        ///Register `PADDR4` reader
        pub type R = crate::R<PADDR4_SPEC>;
        ///Register `PADDR4` writer
        pub type W = crate::W<PADDR4_SPEC>;
        ///Field `PA` reader - Peripheral address
        pub type PA_R = crate::FieldReader<u32>;
        ///Field `PA` writer - Peripheral address
        pub type PA_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - Peripheral address
            #[inline(always)]
            pub fn pa(&self) -> PA_R {
                PA_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - Peripheral address
            #[inline(always)]
            #[must_use]
            pub fn pa(&mut self) -> PA_W<PADDR4_SPEC> {
                PA_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///DMA channel 4 peripheral address register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`paddr4::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`paddr4::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct PADDR4_SPEC;
        impl crate::RegisterSpec for PADDR4_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`paddr4::R`](R) reader structure
        impl crate::Readable for PADDR4_SPEC {}
        ///`write(|w| ..)` method takes [`paddr4::W`](W) writer structure
        impl crate::Writable for PADDR4_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets PADDR4 to value 0
        impl crate::Resettable for PADDR4_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///MADDR4 (rw) register accessor: DMA channel 4 memory address register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`maddr4::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`maddr4::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@maddr4`]
    ///module
    pub type MADDR4 = crate::Reg<maddr4::MADDR4_SPEC>;
    ///DMA channel 4 memory address register
    pub mod maddr4 {
        ///Register `MADDR4` reader
        pub type R = crate::R<MADDR4_SPEC>;
        ///Register `MADDR4` writer
        pub type W = crate::W<MADDR4_SPEC>;
        ///Field `MA` reader - Memory address
        pub type MA_R = crate::FieldReader<u32>;
        ///Field `MA` writer - Memory address
        pub type MA_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - Memory address
            #[inline(always)]
            pub fn ma(&self) -> MA_R {
                MA_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - Memory address
            #[inline(always)]
            #[must_use]
            pub fn ma(&mut self) -> MA_W<MADDR4_SPEC> {
                MA_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///DMA channel 4 memory address register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`maddr4::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`maddr4::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct MADDR4_SPEC;
        impl crate::RegisterSpec for MADDR4_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`maddr4::R`](R) reader structure
        impl crate::Readable for MADDR4_SPEC {}
        ///`write(|w| ..)` method takes [`maddr4::W`](W) writer structure
        impl crate::Writable for MADDR4_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets MADDR4 to value 0
        impl crate::Resettable for MADDR4_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///CFGR5 (rw) register accessor: DMA channel configuration register (DMA_CFGR)
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`cfgr5::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cfgr5::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@cfgr5`]
    ///module
    pub type CFGR5 = crate::Reg<cfgr5::CFGR5_SPEC>;
    ///DMA channel configuration register (DMA_CFGR)
    pub mod cfgr5 {
        ///Register `CFGR5` reader
        pub type R = crate::R<CFGR5_SPEC>;
        ///Register `CFGR5` writer
        pub type W = crate::W<CFGR5_SPEC>;
        ///Field `EN` reader - Channel enable
        pub type EN_R = crate::BitReader;
        ///Field `EN` writer - Channel enable
        pub type EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TCIE` reader - Transfer complete interrupt enable
        pub type TCIE_R = crate::BitReader;
        ///Field `TCIE` writer - Transfer complete interrupt enable
        pub type TCIE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `HTIE` reader - Half Transfer interrupt enable
        pub type HTIE_R = crate::BitReader;
        ///Field `HTIE` writer - Half Transfer interrupt enable
        pub type HTIE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TEIE` reader - Transfer error interrupt enable
        pub type TEIE_R = crate::BitReader;
        ///Field `TEIE` writer - Transfer error interrupt enable
        pub type TEIE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `DIR` reader - Data transfer direction
        pub type DIR_R = crate::BitReader;
        ///Field `DIR` writer - Data transfer direction
        pub type DIR_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CIRC` reader - Circular mode
        pub type CIRC_R = crate::BitReader;
        ///Field `CIRC` writer - Circular mode
        pub type CIRC_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PINC` reader - Peripheral increment mode
        pub type PINC_R = crate::BitReader;
        ///Field `PINC` writer - Peripheral increment mode
        pub type PINC_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `MINC` reader - Memory increment mode
        pub type MINC_R = crate::BitReader;
        ///Field `MINC` writer - Memory increment mode
        pub type MINC_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PSIZE` reader - Peripheral size
        pub type PSIZE_R = crate::FieldReader;
        ///Field `PSIZE` writer - Peripheral size
        pub type PSIZE_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `MSIZE` reader - Memory size
        pub type MSIZE_R = crate::FieldReader;
        ///Field `MSIZE` writer - Memory size
        pub type MSIZE_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `PL` reader - Channel Priority level
        pub type PL_R = crate::FieldReader;
        ///Field `PL` writer - Channel Priority level
        pub type PL_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `MEM2MEM` reader - Memory to memory mode
        pub type MEM2MEM_R = crate::BitReader;
        ///Field `MEM2MEM` writer - Memory to memory mode
        pub type MEM2MEM_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - Channel enable
            #[inline(always)]
            pub fn en(&self) -> EN_R {
                EN_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Transfer complete interrupt enable
            #[inline(always)]
            pub fn tcie(&self) -> TCIE_R {
                TCIE_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - Half Transfer interrupt enable
            #[inline(always)]
            pub fn htie(&self) -> HTIE_R {
                HTIE_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - Transfer error interrupt enable
            #[inline(always)]
            pub fn teie(&self) -> TEIE_R {
                TEIE_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - Data transfer direction
            #[inline(always)]
            pub fn dir(&self) -> DIR_R {
                DIR_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - Circular mode
            #[inline(always)]
            pub fn circ(&self) -> CIRC_R {
                CIRC_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - Peripheral increment mode
            #[inline(always)]
            pub fn pinc(&self) -> PINC_R {
                PINC_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - Memory increment mode
            #[inline(always)]
            pub fn minc(&self) -> MINC_R {
                MINC_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bits 8:9 - Peripheral size
            #[inline(always)]
            pub fn psize(&self) -> PSIZE_R {
                PSIZE_R::new(((self.bits >> 8) & 3) as u8)
            }
            ///Bits 10:11 - Memory size
            #[inline(always)]
            pub fn msize(&self) -> MSIZE_R {
                MSIZE_R::new(((self.bits >> 10) & 3) as u8)
            }
            ///Bits 12:13 - Channel Priority level
            #[inline(always)]
            pub fn pl(&self) -> PL_R {
                PL_R::new(((self.bits >> 12) & 3) as u8)
            }
            ///Bit 14 - Memory to memory mode
            #[inline(always)]
            pub fn mem2mem(&self) -> MEM2MEM_R {
                MEM2MEM_R::new(((self.bits >> 14) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - Channel enable
            #[inline(always)]
            #[must_use]
            pub fn en(&mut self) -> EN_W<CFGR5_SPEC> {
                EN_W::new(self, 0)
            }
            ///Bit 1 - Transfer complete interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn tcie(&mut self) -> TCIE_W<CFGR5_SPEC> {
                TCIE_W::new(self, 1)
            }
            ///Bit 2 - Half Transfer interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn htie(&mut self) -> HTIE_W<CFGR5_SPEC> {
                HTIE_W::new(self, 2)
            }
            ///Bit 3 - Transfer error interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn teie(&mut self) -> TEIE_W<CFGR5_SPEC> {
                TEIE_W::new(self, 3)
            }
            ///Bit 4 - Data transfer direction
            #[inline(always)]
            #[must_use]
            pub fn dir(&mut self) -> DIR_W<CFGR5_SPEC> {
                DIR_W::new(self, 4)
            }
            ///Bit 5 - Circular mode
            #[inline(always)]
            #[must_use]
            pub fn circ(&mut self) -> CIRC_W<CFGR5_SPEC> {
                CIRC_W::new(self, 5)
            }
            ///Bit 6 - Peripheral increment mode
            #[inline(always)]
            #[must_use]
            pub fn pinc(&mut self) -> PINC_W<CFGR5_SPEC> {
                PINC_W::new(self, 6)
            }
            ///Bit 7 - Memory increment mode
            #[inline(always)]
            #[must_use]
            pub fn minc(&mut self) -> MINC_W<CFGR5_SPEC> {
                MINC_W::new(self, 7)
            }
            ///Bits 8:9 - Peripheral size
            #[inline(always)]
            #[must_use]
            pub fn psize(&mut self) -> PSIZE_W<CFGR5_SPEC> {
                PSIZE_W::new(self, 8)
            }
            ///Bits 10:11 - Memory size
            #[inline(always)]
            #[must_use]
            pub fn msize(&mut self) -> MSIZE_W<CFGR5_SPEC> {
                MSIZE_W::new(self, 10)
            }
            ///Bits 12:13 - Channel Priority level
            #[inline(always)]
            #[must_use]
            pub fn pl(&mut self) -> PL_W<CFGR5_SPEC> {
                PL_W::new(self, 12)
            }
            ///Bit 14 - Memory to memory mode
            #[inline(always)]
            #[must_use]
            pub fn mem2mem(&mut self) -> MEM2MEM_W<CFGR5_SPEC> {
                MEM2MEM_W::new(self, 14)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///DMA channel configuration register (DMA_CFGR)
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`cfgr5::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cfgr5::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct CFGR5_SPEC;
        impl crate::RegisterSpec for CFGR5_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`cfgr5::R`](R) reader structure
        impl crate::Readable for CFGR5_SPEC {}
        ///`write(|w| ..)` method takes [`cfgr5::W`](W) writer structure
        impl crate::Writable for CFGR5_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets CFGR5 to value 0
        impl crate::Resettable for CFGR5_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///CNTR5 (rw) register accessor: DMA channel 5 number of data register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`cntr5::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cntr5::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@cntr5`]
    ///module
    pub type CNTR5 = crate::Reg<cntr5::CNTR5_SPEC>;
    ///DMA channel 5 number of data register
    pub mod cntr5 {
        ///Register `CNTR5` reader
        pub type R = crate::R<CNTR5_SPEC>;
        ///Register `CNTR5` writer
        pub type W = crate::W<CNTR5_SPEC>;
        ///Field `NDT` reader - Number of data to transfer
        pub type NDT_R = crate::FieldReader<u16>;
        ///Field `NDT` writer - Number of data to transfer
        pub type NDT_W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            ///Bits 0:15 - Number of data to transfer
            #[inline(always)]
            pub fn ndt(&self) -> NDT_R {
                NDT_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            ///Bits 0:15 - Number of data to transfer
            #[inline(always)]
            #[must_use]
            pub fn ndt(&mut self) -> NDT_W<CNTR5_SPEC> {
                NDT_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///DMA channel 5 number of data register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`cntr5::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cntr5::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct CNTR5_SPEC;
        impl crate::RegisterSpec for CNTR5_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`cntr5::R`](R) reader structure
        impl crate::Readable for CNTR5_SPEC {}
        ///`write(|w| ..)` method takes [`cntr5::W`](W) writer structure
        impl crate::Writable for CNTR5_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets CNTR5 to value 0
        impl crate::Resettable for CNTR5_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///PADDR5 (rw) register accessor: DMA channel 5 peripheral address register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`paddr5::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`paddr5::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@paddr5`]
    ///module
    pub type PADDR5 = crate::Reg<paddr5::PADDR5_SPEC>;
    ///DMA channel 5 peripheral address register
    pub mod paddr5 {
        ///Register `PADDR5` reader
        pub type R = crate::R<PADDR5_SPEC>;
        ///Register `PADDR5` writer
        pub type W = crate::W<PADDR5_SPEC>;
        ///Field `PA` reader - Peripheral address
        pub type PA_R = crate::FieldReader<u32>;
        ///Field `PA` writer - Peripheral address
        pub type PA_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - Peripheral address
            #[inline(always)]
            pub fn pa(&self) -> PA_R {
                PA_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - Peripheral address
            #[inline(always)]
            #[must_use]
            pub fn pa(&mut self) -> PA_W<PADDR5_SPEC> {
                PA_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///DMA channel 5 peripheral address register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`paddr5::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`paddr5::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct PADDR5_SPEC;
        impl crate::RegisterSpec for PADDR5_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`paddr5::R`](R) reader structure
        impl crate::Readable for PADDR5_SPEC {}
        ///`write(|w| ..)` method takes [`paddr5::W`](W) writer structure
        impl crate::Writable for PADDR5_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets PADDR5 to value 0
        impl crate::Resettable for PADDR5_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///MADDR5 (rw) register accessor: DMA channel 5 memory address register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`maddr5::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`maddr5::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@maddr5`]
    ///module
    pub type MADDR5 = crate::Reg<maddr5::MADDR5_SPEC>;
    ///DMA channel 5 memory address register
    pub mod maddr5 {
        ///Register `MADDR5` reader
        pub type R = crate::R<MADDR5_SPEC>;
        ///Register `MADDR5` writer
        pub type W = crate::W<MADDR5_SPEC>;
        ///Field `MA` reader - Memory address
        pub type MA_R = crate::FieldReader<u32>;
        ///Field `MA` writer - Memory address
        pub type MA_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - Memory address
            #[inline(always)]
            pub fn ma(&self) -> MA_R {
                MA_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - Memory address
            #[inline(always)]
            #[must_use]
            pub fn ma(&mut self) -> MA_W<MADDR5_SPEC> {
                MA_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///DMA channel 5 memory address register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`maddr5::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`maddr5::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct MADDR5_SPEC;
        impl crate::RegisterSpec for MADDR5_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`maddr5::R`](R) reader structure
        impl crate::Readable for MADDR5_SPEC {}
        ///`write(|w| ..)` method takes [`maddr5::W`](W) writer structure
        impl crate::Writable for MADDR5_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets MADDR5 to value 0
        impl crate::Resettable for MADDR5_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///CFGR6 (rw) register accessor: DMA channel configuration register (DMA_CFGR)
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`cfgr6::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cfgr6::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@cfgr6`]
    ///module
    pub type CFGR6 = crate::Reg<cfgr6::CFGR6_SPEC>;
    ///DMA channel configuration register (DMA_CFGR)
    pub mod cfgr6 {
        ///Register `CFGR6` reader
        pub type R = crate::R<CFGR6_SPEC>;
        ///Register `CFGR6` writer
        pub type W = crate::W<CFGR6_SPEC>;
        ///Field `EN` reader - Channel enable
        pub type EN_R = crate::BitReader;
        ///Field `EN` writer - Channel enable
        pub type EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TCIE` reader - Transfer complete interrupt enable
        pub type TCIE_R = crate::BitReader;
        ///Field `TCIE` writer - Transfer complete interrupt enable
        pub type TCIE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `HTIE` reader - Half Transfer interrupt enable
        pub type HTIE_R = crate::BitReader;
        ///Field `HTIE` writer - Half Transfer interrupt enable
        pub type HTIE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TEIE` reader - Transfer error interrupt enable
        pub type TEIE_R = crate::BitReader;
        ///Field `TEIE` writer - Transfer error interrupt enable
        pub type TEIE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `DIR` reader - Data transfer direction
        pub type DIR_R = crate::BitReader;
        ///Field `DIR` writer - Data transfer direction
        pub type DIR_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CIRC` reader - Circular mode
        pub type CIRC_R = crate::BitReader;
        ///Field `CIRC` writer - Circular mode
        pub type CIRC_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PINC` reader - Peripheral increment mode
        pub type PINC_R = crate::BitReader;
        ///Field `PINC` writer - Peripheral increment mode
        pub type PINC_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `MINC` reader - Memory increment mode
        pub type MINC_R = crate::BitReader;
        ///Field `MINC` writer - Memory increment mode
        pub type MINC_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PSIZE` reader - Peripheral size
        pub type PSIZE_R = crate::FieldReader;
        ///Field `PSIZE` writer - Peripheral size
        pub type PSIZE_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `MSIZE` reader - Memory size
        pub type MSIZE_R = crate::FieldReader;
        ///Field `MSIZE` writer - Memory size
        pub type MSIZE_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `PL` reader - Channel Priority level
        pub type PL_R = crate::FieldReader;
        ///Field `PL` writer - Channel Priority level
        pub type PL_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `MEM2MEM` reader - Memory to memory mode
        pub type MEM2MEM_R = crate::BitReader;
        ///Field `MEM2MEM` writer - Memory to memory mode
        pub type MEM2MEM_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - Channel enable
            #[inline(always)]
            pub fn en(&self) -> EN_R {
                EN_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Transfer complete interrupt enable
            #[inline(always)]
            pub fn tcie(&self) -> TCIE_R {
                TCIE_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - Half Transfer interrupt enable
            #[inline(always)]
            pub fn htie(&self) -> HTIE_R {
                HTIE_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - Transfer error interrupt enable
            #[inline(always)]
            pub fn teie(&self) -> TEIE_R {
                TEIE_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - Data transfer direction
            #[inline(always)]
            pub fn dir(&self) -> DIR_R {
                DIR_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - Circular mode
            #[inline(always)]
            pub fn circ(&self) -> CIRC_R {
                CIRC_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - Peripheral increment mode
            #[inline(always)]
            pub fn pinc(&self) -> PINC_R {
                PINC_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - Memory increment mode
            #[inline(always)]
            pub fn minc(&self) -> MINC_R {
                MINC_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bits 8:9 - Peripheral size
            #[inline(always)]
            pub fn psize(&self) -> PSIZE_R {
                PSIZE_R::new(((self.bits >> 8) & 3) as u8)
            }
            ///Bits 10:11 - Memory size
            #[inline(always)]
            pub fn msize(&self) -> MSIZE_R {
                MSIZE_R::new(((self.bits >> 10) & 3) as u8)
            }
            ///Bits 12:13 - Channel Priority level
            #[inline(always)]
            pub fn pl(&self) -> PL_R {
                PL_R::new(((self.bits >> 12) & 3) as u8)
            }
            ///Bit 14 - Memory to memory mode
            #[inline(always)]
            pub fn mem2mem(&self) -> MEM2MEM_R {
                MEM2MEM_R::new(((self.bits >> 14) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - Channel enable
            #[inline(always)]
            #[must_use]
            pub fn en(&mut self) -> EN_W<CFGR6_SPEC> {
                EN_W::new(self, 0)
            }
            ///Bit 1 - Transfer complete interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn tcie(&mut self) -> TCIE_W<CFGR6_SPEC> {
                TCIE_W::new(self, 1)
            }
            ///Bit 2 - Half Transfer interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn htie(&mut self) -> HTIE_W<CFGR6_SPEC> {
                HTIE_W::new(self, 2)
            }
            ///Bit 3 - Transfer error interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn teie(&mut self) -> TEIE_W<CFGR6_SPEC> {
                TEIE_W::new(self, 3)
            }
            ///Bit 4 - Data transfer direction
            #[inline(always)]
            #[must_use]
            pub fn dir(&mut self) -> DIR_W<CFGR6_SPEC> {
                DIR_W::new(self, 4)
            }
            ///Bit 5 - Circular mode
            #[inline(always)]
            #[must_use]
            pub fn circ(&mut self) -> CIRC_W<CFGR6_SPEC> {
                CIRC_W::new(self, 5)
            }
            ///Bit 6 - Peripheral increment mode
            #[inline(always)]
            #[must_use]
            pub fn pinc(&mut self) -> PINC_W<CFGR6_SPEC> {
                PINC_W::new(self, 6)
            }
            ///Bit 7 - Memory increment mode
            #[inline(always)]
            #[must_use]
            pub fn minc(&mut self) -> MINC_W<CFGR6_SPEC> {
                MINC_W::new(self, 7)
            }
            ///Bits 8:9 - Peripheral size
            #[inline(always)]
            #[must_use]
            pub fn psize(&mut self) -> PSIZE_W<CFGR6_SPEC> {
                PSIZE_W::new(self, 8)
            }
            ///Bits 10:11 - Memory size
            #[inline(always)]
            #[must_use]
            pub fn msize(&mut self) -> MSIZE_W<CFGR6_SPEC> {
                MSIZE_W::new(self, 10)
            }
            ///Bits 12:13 - Channel Priority level
            #[inline(always)]
            #[must_use]
            pub fn pl(&mut self) -> PL_W<CFGR6_SPEC> {
                PL_W::new(self, 12)
            }
            ///Bit 14 - Memory to memory mode
            #[inline(always)]
            #[must_use]
            pub fn mem2mem(&mut self) -> MEM2MEM_W<CFGR6_SPEC> {
                MEM2MEM_W::new(self, 14)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///DMA channel configuration register (DMA_CFGR)
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`cfgr6::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cfgr6::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct CFGR6_SPEC;
        impl crate::RegisterSpec for CFGR6_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`cfgr6::R`](R) reader structure
        impl crate::Readable for CFGR6_SPEC {}
        ///`write(|w| ..)` method takes [`cfgr6::W`](W) writer structure
        impl crate::Writable for CFGR6_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets CFGR6 to value 0
        impl crate::Resettable for CFGR6_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///CNTR6 (rw) register accessor: DMA channel 6 number of data register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`cntr6::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cntr6::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@cntr6`]
    ///module
    pub type CNTR6 = crate::Reg<cntr6::CNTR6_SPEC>;
    ///DMA channel 6 number of data register
    pub mod cntr6 {
        ///Register `CNTR6` reader
        pub type R = crate::R<CNTR6_SPEC>;
        ///Register `CNTR6` writer
        pub type W = crate::W<CNTR6_SPEC>;
        ///Field `NDT` reader - Number of data to transfer
        pub type NDT_R = crate::FieldReader<u16>;
        ///Field `NDT` writer - Number of data to transfer
        pub type NDT_W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            ///Bits 0:15 - Number of data to transfer
            #[inline(always)]
            pub fn ndt(&self) -> NDT_R {
                NDT_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            ///Bits 0:15 - Number of data to transfer
            #[inline(always)]
            #[must_use]
            pub fn ndt(&mut self) -> NDT_W<CNTR6_SPEC> {
                NDT_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///DMA channel 6 number of data register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`cntr6::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cntr6::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct CNTR6_SPEC;
        impl crate::RegisterSpec for CNTR6_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`cntr6::R`](R) reader structure
        impl crate::Readable for CNTR6_SPEC {}
        ///`write(|w| ..)` method takes [`cntr6::W`](W) writer structure
        impl crate::Writable for CNTR6_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets CNTR6 to value 0
        impl crate::Resettable for CNTR6_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///PADDR6 (rw) register accessor: DMA channel 6 peripheral address register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`paddr6::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`paddr6::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@paddr6`]
    ///module
    pub type PADDR6 = crate::Reg<paddr6::PADDR6_SPEC>;
    ///DMA channel 6 peripheral address register
    pub mod paddr6 {
        ///Register `PADDR6` reader
        pub type R = crate::R<PADDR6_SPEC>;
        ///Register `PADDR6` writer
        pub type W = crate::W<PADDR6_SPEC>;
        ///Field `PA` reader - Peripheral address
        pub type PA_R = crate::FieldReader<u32>;
        ///Field `PA` writer - Peripheral address
        pub type PA_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - Peripheral address
            #[inline(always)]
            pub fn pa(&self) -> PA_R {
                PA_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - Peripheral address
            #[inline(always)]
            #[must_use]
            pub fn pa(&mut self) -> PA_W<PADDR6_SPEC> {
                PA_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///DMA channel 6 peripheral address register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`paddr6::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`paddr6::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct PADDR6_SPEC;
        impl crate::RegisterSpec for PADDR6_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`paddr6::R`](R) reader structure
        impl crate::Readable for PADDR6_SPEC {}
        ///`write(|w| ..)` method takes [`paddr6::W`](W) writer structure
        impl crate::Writable for PADDR6_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets PADDR6 to value 0
        impl crate::Resettable for PADDR6_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///MADDR6 (rw) register accessor: DMA channel 6 memory address register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`maddr6::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`maddr6::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@maddr6`]
    ///module
    pub type MADDR6 = crate::Reg<maddr6::MADDR6_SPEC>;
    ///DMA channel 6 memory address register
    pub mod maddr6 {
        ///Register `MADDR6` reader
        pub type R = crate::R<MADDR6_SPEC>;
        ///Register `MADDR6` writer
        pub type W = crate::W<MADDR6_SPEC>;
        ///Field `MA` reader - Memory address
        pub type MA_R = crate::FieldReader<u32>;
        ///Field `MA` writer - Memory address
        pub type MA_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - Memory address
            #[inline(always)]
            pub fn ma(&self) -> MA_R {
                MA_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - Memory address
            #[inline(always)]
            #[must_use]
            pub fn ma(&mut self) -> MA_W<MADDR6_SPEC> {
                MA_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///DMA channel 6 memory address register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`maddr6::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`maddr6::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct MADDR6_SPEC;
        impl crate::RegisterSpec for MADDR6_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`maddr6::R`](R) reader structure
        impl crate::Readable for MADDR6_SPEC {}
        ///`write(|w| ..)` method takes [`maddr6::W`](W) writer structure
        impl crate::Writable for MADDR6_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets MADDR6 to value 0
        impl crate::Resettable for MADDR6_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///CFGR7 (rw) register accessor: DMA channel configuration register (DMA_CFGR)
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`cfgr7::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cfgr7::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@cfgr7`]
    ///module
    pub type CFGR7 = crate::Reg<cfgr7::CFGR7_SPEC>;
    ///DMA channel configuration register (DMA_CFGR)
    pub mod cfgr7 {
        ///Register `CFGR7` reader
        pub type R = crate::R<CFGR7_SPEC>;
        ///Register `CFGR7` writer
        pub type W = crate::W<CFGR7_SPEC>;
        ///Field `EN` reader - Channel enable
        pub type EN_R = crate::BitReader;
        ///Field `EN` writer - Channel enable
        pub type EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TCIE` reader - Transfer complete interrupt enable
        pub type TCIE_R = crate::BitReader;
        ///Field `TCIE` writer - Transfer complete interrupt enable
        pub type TCIE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `HTIE` reader - Half Transfer interrupt enable
        pub type HTIE_R = crate::BitReader;
        ///Field `HTIE` writer - Half Transfer interrupt enable
        pub type HTIE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TEIE` reader - Transfer error interrupt enable
        pub type TEIE_R = crate::BitReader;
        ///Field `TEIE` writer - Transfer error interrupt enable
        pub type TEIE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `DIR` reader - Data transfer direction
        pub type DIR_R = crate::BitReader;
        ///Field `DIR` writer - Data transfer direction
        pub type DIR_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CIRC` reader - Circular mode
        pub type CIRC_R = crate::BitReader;
        ///Field `CIRC` writer - Circular mode
        pub type CIRC_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PINC` reader - Peripheral increment mode
        pub type PINC_R = crate::BitReader;
        ///Field `PINC` writer - Peripheral increment mode
        pub type PINC_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `MINC` reader - Memory increment mode
        pub type MINC_R = crate::BitReader;
        ///Field `MINC` writer - Memory increment mode
        pub type MINC_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PSIZE` reader - Peripheral size
        pub type PSIZE_R = crate::FieldReader;
        ///Field `PSIZE` writer - Peripheral size
        pub type PSIZE_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `MSIZE` reader - Memory size
        pub type MSIZE_R = crate::FieldReader;
        ///Field `MSIZE` writer - Memory size
        pub type MSIZE_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `PL` reader - Channel Priority level
        pub type PL_R = crate::FieldReader;
        ///Field `PL` writer - Channel Priority level
        pub type PL_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `MEM2MEM` reader - Memory to memory mode
        pub type MEM2MEM_R = crate::BitReader;
        ///Field `MEM2MEM` writer - Memory to memory mode
        pub type MEM2MEM_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - Channel enable
            #[inline(always)]
            pub fn en(&self) -> EN_R {
                EN_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Transfer complete interrupt enable
            #[inline(always)]
            pub fn tcie(&self) -> TCIE_R {
                TCIE_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - Half Transfer interrupt enable
            #[inline(always)]
            pub fn htie(&self) -> HTIE_R {
                HTIE_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - Transfer error interrupt enable
            #[inline(always)]
            pub fn teie(&self) -> TEIE_R {
                TEIE_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - Data transfer direction
            #[inline(always)]
            pub fn dir(&self) -> DIR_R {
                DIR_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - Circular mode
            #[inline(always)]
            pub fn circ(&self) -> CIRC_R {
                CIRC_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - Peripheral increment mode
            #[inline(always)]
            pub fn pinc(&self) -> PINC_R {
                PINC_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - Memory increment mode
            #[inline(always)]
            pub fn minc(&self) -> MINC_R {
                MINC_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bits 8:9 - Peripheral size
            #[inline(always)]
            pub fn psize(&self) -> PSIZE_R {
                PSIZE_R::new(((self.bits >> 8) & 3) as u8)
            }
            ///Bits 10:11 - Memory size
            #[inline(always)]
            pub fn msize(&self) -> MSIZE_R {
                MSIZE_R::new(((self.bits >> 10) & 3) as u8)
            }
            ///Bits 12:13 - Channel Priority level
            #[inline(always)]
            pub fn pl(&self) -> PL_R {
                PL_R::new(((self.bits >> 12) & 3) as u8)
            }
            ///Bit 14 - Memory to memory mode
            #[inline(always)]
            pub fn mem2mem(&self) -> MEM2MEM_R {
                MEM2MEM_R::new(((self.bits >> 14) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - Channel enable
            #[inline(always)]
            #[must_use]
            pub fn en(&mut self) -> EN_W<CFGR7_SPEC> {
                EN_W::new(self, 0)
            }
            ///Bit 1 - Transfer complete interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn tcie(&mut self) -> TCIE_W<CFGR7_SPEC> {
                TCIE_W::new(self, 1)
            }
            ///Bit 2 - Half Transfer interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn htie(&mut self) -> HTIE_W<CFGR7_SPEC> {
                HTIE_W::new(self, 2)
            }
            ///Bit 3 - Transfer error interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn teie(&mut self) -> TEIE_W<CFGR7_SPEC> {
                TEIE_W::new(self, 3)
            }
            ///Bit 4 - Data transfer direction
            #[inline(always)]
            #[must_use]
            pub fn dir(&mut self) -> DIR_W<CFGR7_SPEC> {
                DIR_W::new(self, 4)
            }
            ///Bit 5 - Circular mode
            #[inline(always)]
            #[must_use]
            pub fn circ(&mut self) -> CIRC_W<CFGR7_SPEC> {
                CIRC_W::new(self, 5)
            }
            ///Bit 6 - Peripheral increment mode
            #[inline(always)]
            #[must_use]
            pub fn pinc(&mut self) -> PINC_W<CFGR7_SPEC> {
                PINC_W::new(self, 6)
            }
            ///Bit 7 - Memory increment mode
            #[inline(always)]
            #[must_use]
            pub fn minc(&mut self) -> MINC_W<CFGR7_SPEC> {
                MINC_W::new(self, 7)
            }
            ///Bits 8:9 - Peripheral size
            #[inline(always)]
            #[must_use]
            pub fn psize(&mut self) -> PSIZE_W<CFGR7_SPEC> {
                PSIZE_W::new(self, 8)
            }
            ///Bits 10:11 - Memory size
            #[inline(always)]
            #[must_use]
            pub fn msize(&mut self) -> MSIZE_W<CFGR7_SPEC> {
                MSIZE_W::new(self, 10)
            }
            ///Bits 12:13 - Channel Priority level
            #[inline(always)]
            #[must_use]
            pub fn pl(&mut self) -> PL_W<CFGR7_SPEC> {
                PL_W::new(self, 12)
            }
            ///Bit 14 - Memory to memory mode
            #[inline(always)]
            #[must_use]
            pub fn mem2mem(&mut self) -> MEM2MEM_W<CFGR7_SPEC> {
                MEM2MEM_W::new(self, 14)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///DMA channel configuration register (DMA_CFGR)
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`cfgr7::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cfgr7::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct CFGR7_SPEC;
        impl crate::RegisterSpec for CFGR7_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`cfgr7::R`](R) reader structure
        impl crate::Readable for CFGR7_SPEC {}
        ///`write(|w| ..)` method takes [`cfgr7::W`](W) writer structure
        impl crate::Writable for CFGR7_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets CFGR7 to value 0
        impl crate::Resettable for CFGR7_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///CNTR7 (rw) register accessor: DMA channel 7 number of data register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`cntr7::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cntr7::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@cntr7`]
    ///module
    pub type CNTR7 = crate::Reg<cntr7::CNTR7_SPEC>;
    ///DMA channel 7 number of data register
    pub mod cntr7 {
        ///Register `CNTR7` reader
        pub type R = crate::R<CNTR7_SPEC>;
        ///Register `CNTR7` writer
        pub type W = crate::W<CNTR7_SPEC>;
        ///Field `NDT` reader - Number of data to transfer
        pub type NDT_R = crate::FieldReader<u16>;
        ///Field `NDT` writer - Number of data to transfer
        pub type NDT_W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            ///Bits 0:15 - Number of data to transfer
            #[inline(always)]
            pub fn ndt(&self) -> NDT_R {
                NDT_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            ///Bits 0:15 - Number of data to transfer
            #[inline(always)]
            #[must_use]
            pub fn ndt(&mut self) -> NDT_W<CNTR7_SPEC> {
                NDT_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///DMA channel 7 number of data register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`cntr7::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cntr7::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct CNTR7_SPEC;
        impl crate::RegisterSpec for CNTR7_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`cntr7::R`](R) reader structure
        impl crate::Readable for CNTR7_SPEC {}
        ///`write(|w| ..)` method takes [`cntr7::W`](W) writer structure
        impl crate::Writable for CNTR7_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets CNTR7 to value 0
        impl crate::Resettable for CNTR7_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///PADDR7 (rw) register accessor: DMA channel 7 peripheral address register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`paddr7::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`paddr7::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@paddr7`]
    ///module
    pub type PADDR7 = crate::Reg<paddr7::PADDR7_SPEC>;
    ///DMA channel 7 peripheral address register
    pub mod paddr7 {
        ///Register `PADDR7` reader
        pub type R = crate::R<PADDR7_SPEC>;
        ///Register `PADDR7` writer
        pub type W = crate::W<PADDR7_SPEC>;
        ///Field `PA` reader - Peripheral address
        pub type PA_R = crate::FieldReader<u32>;
        ///Field `PA` writer - Peripheral address
        pub type PA_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - Peripheral address
            #[inline(always)]
            pub fn pa(&self) -> PA_R {
                PA_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - Peripheral address
            #[inline(always)]
            #[must_use]
            pub fn pa(&mut self) -> PA_W<PADDR7_SPEC> {
                PA_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///DMA channel 7 peripheral address register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`paddr7::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`paddr7::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct PADDR7_SPEC;
        impl crate::RegisterSpec for PADDR7_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`paddr7::R`](R) reader structure
        impl crate::Readable for PADDR7_SPEC {}
        ///`write(|w| ..)` method takes [`paddr7::W`](W) writer structure
        impl crate::Writable for PADDR7_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets PADDR7 to value 0
        impl crate::Resettable for PADDR7_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///MADDR7 (rw) register accessor: DMA channel 7 memory address register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`maddr7::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`maddr7::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@maddr7`]
    ///module
    pub type MADDR7 = crate::Reg<maddr7::MADDR7_SPEC>;
    ///DMA channel 7 memory address register
    pub mod maddr7 {
        ///Register `MADDR7` reader
        pub type R = crate::R<MADDR7_SPEC>;
        ///Register `MADDR7` writer
        pub type W = crate::W<MADDR7_SPEC>;
        ///Field `MA` reader - Memory address
        pub type MA_R = crate::FieldReader<u32>;
        ///Field `MA` writer - Memory address
        pub type MA_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - Memory address
            #[inline(always)]
            pub fn ma(&self) -> MA_R {
                MA_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - Memory address
            #[inline(always)]
            #[must_use]
            pub fn ma(&mut self) -> MA_W<MADDR7_SPEC> {
                MA_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///DMA channel 7 memory address register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`maddr7::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`maddr7::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct MADDR7_SPEC;
        impl crate::RegisterSpec for MADDR7_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`maddr7::R`](R) reader structure
        impl crate::Readable for MADDR7_SPEC {}
        ///`write(|w| ..)` method takes [`maddr7::W`](W) writer structure
        impl crate::Writable for MADDR7_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets MADDR7 to value 0
        impl crate::Resettable for MADDR7_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///CFGR8 (rw) register accessor: DMA channel configuration register (DMA_CFGR) use in ch32v20_D8/D8W/D6
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`cfgr8::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cfgr8::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@cfgr8`]
    ///module
    pub type CFGR8 = crate::Reg<cfgr8::CFGR8_SPEC>;
    ///DMA channel configuration register (DMA_CFGR) use in ch32v20_D8/D8W/D6
    pub mod cfgr8 {
        ///Register `CFGR8` reader
        pub type R = crate::R<CFGR8_SPEC>;
        ///Register `CFGR8` writer
        pub type W = crate::W<CFGR8_SPEC>;
        ///Field `EN` reader - Channel enable
        pub type EN_R = crate::BitReader;
        ///Field `EN` writer - Channel enable
        pub type EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TCIE` reader - Transfer complete interrupt enable
        pub type TCIE_R = crate::BitReader;
        ///Field `TCIE` writer - Transfer complete interrupt enable
        pub type TCIE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `HTIE` reader - Half Transfer interrupt enable
        pub type HTIE_R = crate::BitReader;
        ///Field `HTIE` writer - Half Transfer interrupt enable
        pub type HTIE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TEIE` reader - Transfer error interrupt enable
        pub type TEIE_R = crate::BitReader;
        ///Field `TEIE` writer - Transfer error interrupt enable
        pub type TEIE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `DIR` reader - Data transfer direction
        pub type DIR_R = crate::BitReader;
        ///Field `DIR` writer - Data transfer direction
        pub type DIR_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CIRC` reader - Circular mode
        pub type CIRC_R = crate::BitReader;
        ///Field `CIRC` writer - Circular mode
        pub type CIRC_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PINC` reader - Peripheral increment mode
        pub type PINC_R = crate::BitReader;
        ///Field `PINC` writer - Peripheral increment mode
        pub type PINC_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `MINC` reader - Memory increment mode
        pub type MINC_R = crate::BitReader;
        ///Field `MINC` writer - Memory increment mode
        pub type MINC_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PSIZE` reader - Peripheral size
        pub type PSIZE_R = crate::FieldReader;
        ///Field `PSIZE` writer - Peripheral size
        pub type PSIZE_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `MSIZE` reader - Memory size
        pub type MSIZE_R = crate::FieldReader;
        ///Field `MSIZE` writer - Memory size
        pub type MSIZE_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `PL` reader - Channel Priority level
        pub type PL_R = crate::FieldReader;
        ///Field `PL` writer - Channel Priority level
        pub type PL_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `MEM2MEM` reader - Memory to memory mode
        pub type MEM2MEM_R = crate::BitReader;
        ///Field `MEM2MEM` writer - Memory to memory mode
        pub type MEM2MEM_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - Channel enable
            #[inline(always)]
            pub fn en(&self) -> EN_R {
                EN_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Transfer complete interrupt enable
            #[inline(always)]
            pub fn tcie(&self) -> TCIE_R {
                TCIE_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - Half Transfer interrupt enable
            #[inline(always)]
            pub fn htie(&self) -> HTIE_R {
                HTIE_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - Transfer error interrupt enable
            #[inline(always)]
            pub fn teie(&self) -> TEIE_R {
                TEIE_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - Data transfer direction
            #[inline(always)]
            pub fn dir(&self) -> DIR_R {
                DIR_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - Circular mode
            #[inline(always)]
            pub fn circ(&self) -> CIRC_R {
                CIRC_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - Peripheral increment mode
            #[inline(always)]
            pub fn pinc(&self) -> PINC_R {
                PINC_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - Memory increment mode
            #[inline(always)]
            pub fn minc(&self) -> MINC_R {
                MINC_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bits 8:9 - Peripheral size
            #[inline(always)]
            pub fn psize(&self) -> PSIZE_R {
                PSIZE_R::new(((self.bits >> 8) & 3) as u8)
            }
            ///Bits 10:11 - Memory size
            #[inline(always)]
            pub fn msize(&self) -> MSIZE_R {
                MSIZE_R::new(((self.bits >> 10) & 3) as u8)
            }
            ///Bits 12:13 - Channel Priority level
            #[inline(always)]
            pub fn pl(&self) -> PL_R {
                PL_R::new(((self.bits >> 12) & 3) as u8)
            }
            ///Bit 14 - Memory to memory mode
            #[inline(always)]
            pub fn mem2mem(&self) -> MEM2MEM_R {
                MEM2MEM_R::new(((self.bits >> 14) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - Channel enable
            #[inline(always)]
            #[must_use]
            pub fn en(&mut self) -> EN_W<CFGR8_SPEC> {
                EN_W::new(self, 0)
            }
            ///Bit 1 - Transfer complete interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn tcie(&mut self) -> TCIE_W<CFGR8_SPEC> {
                TCIE_W::new(self, 1)
            }
            ///Bit 2 - Half Transfer interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn htie(&mut self) -> HTIE_W<CFGR8_SPEC> {
                HTIE_W::new(self, 2)
            }
            ///Bit 3 - Transfer error interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn teie(&mut self) -> TEIE_W<CFGR8_SPEC> {
                TEIE_W::new(self, 3)
            }
            ///Bit 4 - Data transfer direction
            #[inline(always)]
            #[must_use]
            pub fn dir(&mut self) -> DIR_W<CFGR8_SPEC> {
                DIR_W::new(self, 4)
            }
            ///Bit 5 - Circular mode
            #[inline(always)]
            #[must_use]
            pub fn circ(&mut self) -> CIRC_W<CFGR8_SPEC> {
                CIRC_W::new(self, 5)
            }
            ///Bit 6 - Peripheral increment mode
            #[inline(always)]
            #[must_use]
            pub fn pinc(&mut self) -> PINC_W<CFGR8_SPEC> {
                PINC_W::new(self, 6)
            }
            ///Bit 7 - Memory increment mode
            #[inline(always)]
            #[must_use]
            pub fn minc(&mut self) -> MINC_W<CFGR8_SPEC> {
                MINC_W::new(self, 7)
            }
            ///Bits 8:9 - Peripheral size
            #[inline(always)]
            #[must_use]
            pub fn psize(&mut self) -> PSIZE_W<CFGR8_SPEC> {
                PSIZE_W::new(self, 8)
            }
            ///Bits 10:11 - Memory size
            #[inline(always)]
            #[must_use]
            pub fn msize(&mut self) -> MSIZE_W<CFGR8_SPEC> {
                MSIZE_W::new(self, 10)
            }
            ///Bits 12:13 - Channel Priority level
            #[inline(always)]
            #[must_use]
            pub fn pl(&mut self) -> PL_W<CFGR8_SPEC> {
                PL_W::new(self, 12)
            }
            ///Bit 14 - Memory to memory mode
            #[inline(always)]
            #[must_use]
            pub fn mem2mem(&mut self) -> MEM2MEM_W<CFGR8_SPEC> {
                MEM2MEM_W::new(self, 14)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///DMA channel configuration register (DMA_CFGR) use in ch32v20_D8/D8W/D6
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`cfgr8::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cfgr8::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct CFGR8_SPEC;
        impl crate::RegisterSpec for CFGR8_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`cfgr8::R`](R) reader structure
        impl crate::Readable for CFGR8_SPEC {}
        ///`write(|w| ..)` method takes [`cfgr8::W`](W) writer structure
        impl crate::Writable for CFGR8_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets CFGR8 to value 0
        impl crate::Resettable for CFGR8_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///CNTR8 (rw) register accessor: DMA channel 8 number of data register use in ch32v20_D8/D8W/D6
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`cntr8::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cntr8::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@cntr8`]
    ///module
    pub type CNTR8 = crate::Reg<cntr8::CNTR8_SPEC>;
    ///DMA channel 8 number of data register use in ch32v20_D8/D8W/D6
    pub mod cntr8 {
        ///Register `CNTR8` reader
        pub type R = crate::R<CNTR8_SPEC>;
        ///Register `CNTR8` writer
        pub type W = crate::W<CNTR8_SPEC>;
        ///Field `NDT` reader - Number of data to transfer
        pub type NDT_R = crate::FieldReader<u16>;
        ///Field `NDT` writer - Number of data to transfer
        pub type NDT_W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            ///Bits 0:15 - Number of data to transfer
            #[inline(always)]
            pub fn ndt(&self) -> NDT_R {
                NDT_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            ///Bits 0:15 - Number of data to transfer
            #[inline(always)]
            #[must_use]
            pub fn ndt(&mut self) -> NDT_W<CNTR8_SPEC> {
                NDT_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///DMA channel 8 number of data register use in ch32v20_D8/D8W/D6
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`cntr8::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cntr8::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct CNTR8_SPEC;
        impl crate::RegisterSpec for CNTR8_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`cntr8::R`](R) reader structure
        impl crate::Readable for CNTR8_SPEC {}
        ///`write(|w| ..)` method takes [`cntr8::W`](W) writer structure
        impl crate::Writable for CNTR8_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets CNTR8 to value 0
        impl crate::Resettable for CNTR8_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///PADDR8 (rw) register accessor: DMA channel 8 peripheral address register use in ch32v20_D8/D8W/D6
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`paddr8::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`paddr8::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@paddr8`]
    ///module
    pub type PADDR8 = crate::Reg<paddr8::PADDR8_SPEC>;
    ///DMA channel 8 peripheral address register use in ch32v20_D8/D8W/D6
    pub mod paddr8 {
        ///Register `PADDR8` reader
        pub type R = crate::R<PADDR8_SPEC>;
        ///Register `PADDR8` writer
        pub type W = crate::W<PADDR8_SPEC>;
        ///Field `PA` reader - Peripheral address
        pub type PA_R = crate::FieldReader<u32>;
        ///Field `PA` writer - Peripheral address
        pub type PA_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - Peripheral address
            #[inline(always)]
            pub fn pa(&self) -> PA_R {
                PA_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - Peripheral address
            #[inline(always)]
            #[must_use]
            pub fn pa(&mut self) -> PA_W<PADDR8_SPEC> {
                PA_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///DMA channel 8 peripheral address register use in ch32v20_D8/D8W/D6
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`paddr8::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`paddr8::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct PADDR8_SPEC;
        impl crate::RegisterSpec for PADDR8_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`paddr8::R`](R) reader structure
        impl crate::Readable for PADDR8_SPEC {}
        ///`write(|w| ..)` method takes [`paddr8::W`](W) writer structure
        impl crate::Writable for PADDR8_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets PADDR8 to value 0
        impl crate::Resettable for PADDR8_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///MADDR8 (rw) register accessor: DMA channel 8 memory address register use in ch32v20_D8/D8W/D6
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`maddr8::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`maddr8::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@maddr8`]
    ///module
    pub type MADDR8 = crate::Reg<maddr8::MADDR8_SPEC>;
    ///DMA channel 8 memory address register use in ch32v20_D8/D8W/D6
    pub mod maddr8 {
        ///Register `MADDR8` reader
        pub type R = crate::R<MADDR8_SPEC>;
        ///Register `MADDR8` writer
        pub type W = crate::W<MADDR8_SPEC>;
        ///Field `MA` reader - Memory address
        pub type MA_R = crate::FieldReader<u32>;
        ///Field `MA` writer - Memory address
        pub type MA_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - Memory address
            #[inline(always)]
            pub fn ma(&self) -> MA_R {
                MA_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - Memory address
            #[inline(always)]
            #[must_use]
            pub fn ma(&mut self) -> MA_W<MADDR8_SPEC> {
                MA_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///DMA channel 8 memory address register use in ch32v20_D8/D8W/D6
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`maddr8::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`maddr8::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct MADDR8_SPEC;
        impl crate::RegisterSpec for MADDR8_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`maddr8::R`](R) reader structure
        impl crate::Readable for MADDR8_SPEC {}
        ///`write(|w| ..)` method takes [`maddr8::W`](W) writer structure
        impl crate::Writable for MADDR8_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets MADDR8 to value 0
        impl crate::Resettable for MADDR8_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
}
///Real time clock
pub struct RTC {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for RTC {}
impl RTC {
    ///Pointer to the register block
    pub const PTR: *const rtc::RegisterBlock = 0x4000_2800 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const rtc::RegisterBlock {
        Self::PTR
    }
    /// Steal an instance of this peripheral
    ///
    /// # Safety
    ///
    /// Ensure that the new instance of the peripheral cannot be used in a way
    /// that may race with any existing instances, for example by only
    /// accessing read-only or write-only registers, or by consuming the
    /// original peripheral and using critical sections to coordinate
    /// access between multiple new instances.
    ///
    /// Additionally, other software such as HALs may rely on only one
    /// peripheral instance existing to ensure memory safety; ensure
    /// no stolen instances are passed to such software.
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for RTC {
    type Target = rtc::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for RTC {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("RTC").finish()
    }
}
///Real time clock
pub mod rtc {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        ctlrh: CTLRH,
        _reserved1: [u8; 0x02],
        ctlrl: CTLRL,
        _reserved2: [u8; 0x02],
        pscrh: PSCRH,
        _reserved3: [u8; 0x02],
        pscrl: PSCRL,
        _reserved4: [u8; 0x02],
        divh: DIVH,
        _reserved5: [u8; 0x02],
        divl: DIVL,
        _reserved6: [u8; 0x02],
        cnth: CNTH,
        _reserved7: [u8; 0x02],
        cntl: CNTL,
        _reserved8: [u8; 0x02],
        alrmh: ALRMH,
        _reserved9: [u8; 0x02],
        alrml: ALRML,
    }
    impl RegisterBlock {
        ///0x00 - RTC Control Register High
        #[inline(always)]
        pub const fn ctlrh(&self) -> &CTLRH {
            &self.ctlrh
        }
        ///0x04 - RTC Control Register Low
        #[inline(always)]
        pub const fn ctlrl(&self) -> &CTLRL {
            &self.ctlrl
        }
        ///0x08 - RTC Prescaler Load Register High
        #[inline(always)]
        pub const fn pscrh(&self) -> &PSCRH {
            &self.pscrh
        }
        ///0x0c - RTC Prescaler Load Register Low
        #[inline(always)]
        pub const fn pscrl(&self) -> &PSCRL {
            &self.pscrl
        }
        ///0x10 - RTC Prescaler Divider Register High
        #[inline(always)]
        pub const fn divh(&self) -> &DIVH {
            &self.divh
        }
        ///0x14 - RTC Prescaler Divider Register Low
        #[inline(always)]
        pub const fn divl(&self) -> &DIVL {
            &self.divl
        }
        ///0x18 - RTC Counter Register High
        #[inline(always)]
        pub const fn cnth(&self) -> &CNTH {
            &self.cnth
        }
        ///0x1c - RTC Counter Register Low
        #[inline(always)]
        pub const fn cntl(&self) -> &CNTL {
            &self.cntl
        }
        ///0x20 - RTC Alarm Register High
        #[inline(always)]
        pub const fn alrmh(&self) -> &ALRMH {
            &self.alrmh
        }
        ///0x24 - RTC Alarm Register Low
        #[inline(always)]
        pub const fn alrml(&self) -> &ALRML {
            &self.alrml
        }
    }
    ///CTLRH (rw) register accessor: RTC Control Register High
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`ctlrh::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ctlrh::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@ctlrh`]
    ///module
    pub type CTLRH = crate::Reg<ctlrh::CTLRH_SPEC>;
    ///RTC Control Register High
    pub mod ctlrh {
        ///Register `CTLRH` reader
        pub type R = crate::R<CTLRH_SPEC>;
        ///Register `CTLRH` writer
        pub type W = crate::W<CTLRH_SPEC>;
        ///Field `SECIE` reader - Second interrupt Enable
        pub type SECIE_R = crate::BitReader;
        ///Field `SECIE` writer - Second interrupt Enable
        pub type SECIE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `ALRIE` reader - Alarm interrupt Enable
        pub type ALRIE_R = crate::BitReader;
        ///Field `ALRIE` writer - Alarm interrupt Enable
        pub type ALRIE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `OWIE` reader - Overflow interrupt Enable
        pub type OWIE_R = crate::BitReader;
        ///Field `OWIE` writer - Overflow interrupt Enable
        pub type OWIE_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - Second interrupt Enable
            #[inline(always)]
            pub fn secie(&self) -> SECIE_R {
                SECIE_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Alarm interrupt Enable
            #[inline(always)]
            pub fn alrie(&self) -> ALRIE_R {
                ALRIE_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - Overflow interrupt Enable
            #[inline(always)]
            pub fn owie(&self) -> OWIE_R {
                OWIE_R::new(((self.bits >> 2) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - Second interrupt Enable
            #[inline(always)]
            #[must_use]
            pub fn secie(&mut self) -> SECIE_W<CTLRH_SPEC> {
                SECIE_W::new(self, 0)
            }
            ///Bit 1 - Alarm interrupt Enable
            #[inline(always)]
            #[must_use]
            pub fn alrie(&mut self) -> ALRIE_W<CTLRH_SPEC> {
                ALRIE_W::new(self, 1)
            }
            ///Bit 2 - Overflow interrupt Enable
            #[inline(always)]
            #[must_use]
            pub fn owie(&mut self) -> OWIE_W<CTLRH_SPEC> {
                OWIE_W::new(self, 2)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RTC Control Register High
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`ctlrh::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ctlrh::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct CTLRH_SPEC;
        impl crate::RegisterSpec for CTLRH_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`ctlrh::R`](R) reader structure
        impl crate::Readable for CTLRH_SPEC {}
        ///`write(|w| ..)` method takes [`ctlrh::W`](W) writer structure
        impl crate::Writable for CTLRH_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets CTLRH to value 0
        impl crate::Resettable for CTLRH_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///CTLRL (rw) register accessor: RTC Control Register Low
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`ctlrl::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ctlrl::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@ctlrl`]
    ///module
    pub type CTLRL = crate::Reg<ctlrl::CTLRL_SPEC>;
    ///RTC Control Register Low
    pub mod ctlrl {
        ///Register `CTLRL` reader
        pub type R = crate::R<CTLRL_SPEC>;
        ///Register `CTLRL` writer
        pub type W = crate::W<CTLRL_SPEC>;
        ///Field `SECF` reader - Second Flag
        pub type SECF_R = crate::BitReader;
        ///Field `SECF` writer - Second Flag
        pub type SECF_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `ALRF` reader - Alarm Flag
        pub type ALRF_R = crate::BitReader;
        ///Field `ALRF` writer - Alarm Flag
        pub type ALRF_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `OWF` reader - Overflow Flag
        pub type OWF_R = crate::BitReader;
        ///Field `OWF` writer - Overflow Flag
        pub type OWF_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `RSF` reader - Registers Synchronized Flag
        pub type RSF_R = crate::BitReader;
        ///Field `RSF` writer - Registers Synchronized Flag
        pub type RSF_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CNF` reader - Configuration Flag
        pub type CNF_R = crate::BitReader;
        ///Field `CNF` writer - Configuration Flag
        pub type CNF_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `RTOFF` reader - RTC operation OFF
        pub type RTOFF_R = crate::BitReader;
        impl R {
            ///Bit 0 - Second Flag
            #[inline(always)]
            pub fn secf(&self) -> SECF_R {
                SECF_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Alarm Flag
            #[inline(always)]
            pub fn alrf(&self) -> ALRF_R {
                ALRF_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - Overflow Flag
            #[inline(always)]
            pub fn owf(&self) -> OWF_R {
                OWF_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - Registers Synchronized Flag
            #[inline(always)]
            pub fn rsf(&self) -> RSF_R {
                RSF_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - Configuration Flag
            #[inline(always)]
            pub fn cnf(&self) -> CNF_R {
                CNF_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - RTC operation OFF
            #[inline(always)]
            pub fn rtoff(&self) -> RTOFF_R {
                RTOFF_R::new(((self.bits >> 5) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - Second Flag
            #[inline(always)]
            #[must_use]
            pub fn secf(&mut self) -> SECF_W<CTLRL_SPEC> {
                SECF_W::new(self, 0)
            }
            ///Bit 1 - Alarm Flag
            #[inline(always)]
            #[must_use]
            pub fn alrf(&mut self) -> ALRF_W<CTLRL_SPEC> {
                ALRF_W::new(self, 1)
            }
            ///Bit 2 - Overflow Flag
            #[inline(always)]
            #[must_use]
            pub fn owf(&mut self) -> OWF_W<CTLRL_SPEC> {
                OWF_W::new(self, 2)
            }
            ///Bit 3 - Registers Synchronized Flag
            #[inline(always)]
            #[must_use]
            pub fn rsf(&mut self) -> RSF_W<CTLRL_SPEC> {
                RSF_W::new(self, 3)
            }
            ///Bit 4 - Configuration Flag
            #[inline(always)]
            #[must_use]
            pub fn cnf(&mut self) -> CNF_W<CTLRL_SPEC> {
                CNF_W::new(self, 4)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RTC Control Register Low
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`ctlrl::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ctlrl::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct CTLRL_SPEC;
        impl crate::RegisterSpec for CTLRL_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`ctlrl::R`](R) reader structure
        impl crate::Readable for CTLRL_SPEC {}
        ///`write(|w| ..)` method takes [`ctlrl::W`](W) writer structure
        impl crate::Writable for CTLRL_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets CTLRL to value 0x20
        impl crate::Resettable for CTLRL_SPEC {
            const RESET_VALUE: u16 = 0x20;
        }
    }
    ///PSCRH (w) register accessor: RTC Prescaler Load Register High
    ///
    ///You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pscrh::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@pscrh`]
    ///module
    pub type PSCRH = crate::Reg<pscrh::PSCRH_SPEC>;
    ///RTC Prescaler Load Register High
    pub mod pscrh {
        ///Register `PSCRH` writer
        pub type W = crate::W<PSCRH_SPEC>;
        ///Field `PRL` writer - RTC Prescaler Load Register High
        pub type PRL_W<'a, REG> = crate::FieldWriter<'a, REG, 4>;
        impl W {
            ///Bits 0:3 - RTC Prescaler Load Register High
            #[inline(always)]
            #[must_use]
            pub fn prl(&mut self) -> PRL_W<PSCRH_SPEC> {
                PRL_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RTC Prescaler Load Register High
        ///
        ///You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pscrh::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct PSCRH_SPEC;
        impl crate::RegisterSpec for PSCRH_SPEC {
            type Ux = u16;
        }
        ///`write(|w| ..)` method takes [`pscrh::W`](W) writer structure
        impl crate::Writable for PSCRH_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets PSCRH to value 0
        impl crate::Resettable for PSCRH_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///PSCRL (w) register accessor: RTC Prescaler Load Register Low
    ///
    ///You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pscrl::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@pscrl`]
    ///module
    pub type PSCRL = crate::Reg<pscrl::PSCRL_SPEC>;
    ///RTC Prescaler Load Register Low
    pub mod pscrl {
        ///Register `PSCRL` writer
        pub type W = crate::W<PSCRL_SPEC>;
        ///Field `PRL` writer - RTC Prescaler Divider Register Low
        pub type PRL_W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl W {
            ///Bits 0:15 - RTC Prescaler Divider Register Low
            #[inline(always)]
            #[must_use]
            pub fn prl(&mut self) -> PRL_W<PSCRL_SPEC> {
                PRL_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RTC Prescaler Load Register Low
        ///
        ///You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pscrl::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct PSCRL_SPEC;
        impl crate::RegisterSpec for PSCRL_SPEC {
            type Ux = u16;
        }
        ///`write(|w| ..)` method takes [`pscrl::W`](W) writer structure
        impl crate::Writable for PSCRL_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets PSCRL to value 0
        impl crate::Resettable for PSCRL_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///DIVH (r) register accessor: RTC Prescaler Divider Register High
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`divh::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@divh`]
    ///module
    pub type DIVH = crate::Reg<divh::DIVH_SPEC>;
    ///RTC Prescaler Divider Register High
    pub mod divh {
        ///Register `DIVH` reader
        pub type R = crate::R<DIVH_SPEC>;
        ///Field `DIV` reader - RTC prescaler divider register high
        pub type DIV_R = crate::FieldReader;
        impl R {
            ///Bits 0:3 - RTC prescaler divider register high
            #[inline(always)]
            pub fn div(&self) -> DIV_R {
                DIV_R::new((self.bits & 0x0f) as u8)
            }
        }
        ///RTC Prescaler Divider Register High
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`divh::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct DIVH_SPEC;
        impl crate::RegisterSpec for DIVH_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`divh::R`](R) reader structure
        impl crate::Readable for DIVH_SPEC {}
        ///`reset()` method sets DIVH to value 0
        impl crate::Resettable for DIVH_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///DIVL (r) register accessor: RTC Prescaler Divider Register Low
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`divl::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@divl`]
    ///module
    pub type DIVL = crate::Reg<divl::DIVL_SPEC>;
    ///RTC Prescaler Divider Register Low
    pub mod divl {
        ///Register `DIVL` reader
        pub type R = crate::R<DIVL_SPEC>;
        ///Field `DIV` reader - RTC prescaler divider register Low
        pub type DIV_R = crate::FieldReader<u16>;
        impl R {
            ///Bits 0:15 - RTC prescaler divider register Low
            #[inline(always)]
            pub fn div(&self) -> DIV_R {
                DIV_R::new(self.bits)
            }
        }
        ///RTC Prescaler Divider Register Low
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`divl::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct DIVL_SPEC;
        impl crate::RegisterSpec for DIVL_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`divl::R`](R) reader structure
        impl crate::Readable for DIVL_SPEC {}
        ///`reset()` method sets DIVL to value 0
        impl crate::Resettable for DIVL_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///CNTH (rw) register accessor: RTC Counter Register High
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`cnth::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cnth::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@cnth`]
    ///module
    pub type CNTH = crate::Reg<cnth::CNTH_SPEC>;
    ///RTC Counter Register High
    pub mod cnth {
        ///Register `CNTH` reader
        pub type R = crate::R<CNTH_SPEC>;
        ///Register `CNTH` writer
        pub type W = crate::W<CNTH_SPEC>;
        ///Field `CNTH` reader - RTC counter register high
        pub type CNTH_R = crate::FieldReader<u16>;
        ///Field `CNTH` writer - RTC counter register high
        pub type CNTH_W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            ///Bits 0:15 - RTC counter register high
            #[inline(always)]
            pub fn cnth(&self) -> CNTH_R {
                CNTH_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - RTC counter register high
            #[inline(always)]
            #[must_use]
            pub fn cnth(&mut self) -> CNTH_W<CNTH_SPEC> {
                CNTH_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RTC Counter Register High
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`cnth::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cnth::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct CNTH_SPEC;
        impl crate::RegisterSpec for CNTH_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`cnth::R`](R) reader structure
        impl crate::Readable for CNTH_SPEC {}
        ///`write(|w| ..)` method takes [`cnth::W`](W) writer structure
        impl crate::Writable for CNTH_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets CNTH to value 0
        impl crate::Resettable for CNTH_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///CNTL (rw) register accessor: RTC Counter Register Low
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`cntl::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cntl::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@cntl`]
    ///module
    pub type CNTL = crate::Reg<cntl::CNTL_SPEC>;
    ///RTC Counter Register Low
    pub mod cntl {
        ///Register `CNTL` reader
        pub type R = crate::R<CNTL_SPEC>;
        ///Register `CNTL` writer
        pub type W = crate::W<CNTL_SPEC>;
        ///Field `CNTL` reader - RTC counter register Low
        pub type CNTL_R = crate::FieldReader<u16>;
        ///Field `CNTL` writer - RTC counter register Low
        pub type CNTL_W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            ///Bits 0:15 - RTC counter register Low
            #[inline(always)]
            pub fn cntl(&self) -> CNTL_R {
                CNTL_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - RTC counter register Low
            #[inline(always)]
            #[must_use]
            pub fn cntl(&mut self) -> CNTL_W<CNTL_SPEC> {
                CNTL_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RTC Counter Register Low
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`cntl::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cntl::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct CNTL_SPEC;
        impl crate::RegisterSpec for CNTL_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`cntl::R`](R) reader structure
        impl crate::Readable for CNTL_SPEC {}
        ///`write(|w| ..)` method takes [`cntl::W`](W) writer structure
        impl crate::Writable for CNTL_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets CNTL to value 0
        impl crate::Resettable for CNTL_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///ALRMH (w) register accessor: RTC Alarm Register High
    ///
    ///You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`alrmh::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@alrmh`]
    ///module
    pub type ALRMH = crate::Reg<alrmh::ALRMH_SPEC>;
    ///RTC Alarm Register High
    pub mod alrmh {
        ///Register `ALRMH` writer
        pub type W = crate::W<ALRMH_SPEC>;
        ///Field `ALR` writer - RTC alarm register high
        pub type ALR_W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl W {
            ///Bits 0:15 - RTC alarm register high
            #[inline(always)]
            #[must_use]
            pub fn alr(&mut self) -> ALR_W<ALRMH_SPEC> {
                ALR_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RTC Alarm Register High
        ///
        ///You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`alrmh::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct ALRMH_SPEC;
        impl crate::RegisterSpec for ALRMH_SPEC {
            type Ux = u16;
        }
        ///`write(|w| ..)` method takes [`alrmh::W`](W) writer structure
        impl crate::Writable for ALRMH_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets ALRMH to value 0
        impl crate::Resettable for ALRMH_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///ALRML (w) register accessor: RTC Alarm Register Low
    ///
    ///You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`alrml::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@alrml`]
    ///module
    pub type ALRML = crate::Reg<alrml::ALRML_SPEC>;
    ///RTC Alarm Register Low
    pub mod alrml {
        ///Register `ALRML` writer
        pub type W = crate::W<ALRML_SPEC>;
        ///Field `ALR` writer - RTC alarm register low
        pub type ALR_W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl W {
            ///Bits 0:15 - RTC alarm register low
            #[inline(always)]
            #[must_use]
            pub fn alr(&mut self) -> ALR_W<ALRML_SPEC> {
                ALR_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RTC Alarm Register Low
        ///
        ///You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`alrml::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct ALRML_SPEC;
        impl crate::RegisterSpec for ALRML_SPEC {
            type Ux = u16;
        }
        ///`write(|w| ..)` method takes [`alrml::W`](W) writer structure
        impl crate::Writable for ALRML_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets ALRML to value 0
        impl crate::Resettable for ALRML_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
}
///Backup registers
pub struct BKP {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for BKP {}
impl BKP {
    ///Pointer to the register block
    pub const PTR: *const bkp::RegisterBlock = 0x4000_6c00 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const bkp::RegisterBlock {
        Self::PTR
    }
    /// Steal an instance of this peripheral
    ///
    /// # Safety
    ///
    /// Ensure that the new instance of the peripheral cannot be used in a way
    /// that may race with any existing instances, for example by only
    /// accessing read-only or write-only registers, or by consuming the
    /// original peripheral and using critical sections to coordinate
    /// access between multiple new instances.
    ///
    /// Additionally, other software such as HALs may rely on only one
    /// peripheral instance existing to ensure memory safety; ensure
    /// no stolen instances are passed to such software.
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for BKP {
    type Target = bkp::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for BKP {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("BKP").finish()
    }
}
///Backup registers
pub mod bkp {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        _reserved0: [u8; 0x04],
        datar1: DATAR1,
        _reserved1: [u8; 0x02],
        datar2: DATAR2,
        _reserved2: [u8; 0x02],
        datar3: DATAR3,
        _reserved3: [u8; 0x02],
        datar4: DATAR4,
        _reserved4: [u8; 0x02],
        datar5: DATAR5,
        _reserved5: [u8; 0x02],
        datar6: DATAR6,
        _reserved6: [u8; 0x02],
        datar7: DATAR7,
        _reserved7: [u8; 0x02],
        datar8: DATAR8,
        _reserved8: [u8; 0x02],
        datar9: DATAR9,
        _reserved9: [u8; 0x02],
        datar10: DATAR10,
        _reserved10: [u8; 0x02],
        octlr: OCTLR,
        _reserved11: [u8; 0x02],
        tpctlr: TPCTLR,
        _reserved12: [u8; 0x02],
        tpcsr: TPCSR,
        _reserved13: [u8; 0x0a],
        datar11: DATAR11,
        _reserved14: [u8; 0x02],
        datar12: DATAR12,
        _reserved15: [u8; 0x02],
        datar13: DATAR13,
    }
    impl RegisterBlock {
        ///0x04 - Backup data register (BKP_DR)
        #[inline(always)]
        pub const fn datar1(&self) -> &DATAR1 {
            &self.datar1
        }
        ///0x08 - Backup data register (BKP_DR)
        #[inline(always)]
        pub const fn datar2(&self) -> &DATAR2 {
            &self.datar2
        }
        ///0x0c - Backup data register (BKP_DR)
        #[inline(always)]
        pub const fn datar3(&self) -> &DATAR3 {
            &self.datar3
        }
        ///0x10 - Backup data register (BKP_DR)
        #[inline(always)]
        pub const fn datar4(&self) -> &DATAR4 {
            &self.datar4
        }
        ///0x14 - Backup data register (BKP_DR)
        #[inline(always)]
        pub const fn datar5(&self) -> &DATAR5 {
            &self.datar5
        }
        ///0x18 - Backup data register (BKP_DR)
        #[inline(always)]
        pub const fn datar6(&self) -> &DATAR6 {
            &self.datar6
        }
        ///0x1c - Backup data register (BKP_DR)
        #[inline(always)]
        pub const fn datar7(&self) -> &DATAR7 {
            &self.datar7
        }
        ///0x20 - Backup data register (BKP_DR)
        #[inline(always)]
        pub const fn datar8(&self) -> &DATAR8 {
            &self.datar8
        }
        ///0x24 - Backup data register (BKP_DR)
        #[inline(always)]
        pub const fn datar9(&self) -> &DATAR9 {
            &self.datar9
        }
        ///0x28 - Backup data register (BKP_DR)
        #[inline(always)]
        pub const fn datar10(&self) -> &DATAR10 {
            &self.datar10
        }
        ///0x2c - RTC clock calibration register (BKP_OCTLR)
        #[inline(always)]
        pub const fn octlr(&self) -> &OCTLR {
            &self.octlr
        }
        ///0x30 - Backup control register (BKP_TPCTLR)
        #[inline(always)]
        pub const fn tpctlr(&self) -> &TPCTLR {
            &self.tpctlr
        }
        ///0x34 - BKP_TPCSR control/status register (BKP_CSR)
        #[inline(always)]
        pub const fn tpcsr(&self) -> &TPCSR {
            &self.tpcsr
        }
        ///0x40 - Backup data register (BKP_DR)
        #[inline(always)]
        pub const fn datar11(&self) -> &DATAR11 {
            &self.datar11
        }
        ///0x44 - Backup data register (BKP_DR)
        #[inline(always)]
        pub const fn datar12(&self) -> &DATAR12 {
            &self.datar12
        }
        ///0x48 - Backup data register (BKP_DR)
        #[inline(always)]
        pub const fn datar13(&self) -> &DATAR13 {
            &self.datar13
        }
    }
    ///DATAR1 (rw) register accessor: Backup data register (BKP_DR)
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`datar1::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`datar1::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@datar1`]
    ///module
    pub type DATAR1 = crate::Reg<datar1::DATAR1_SPEC>;
    ///Backup data register (BKP_DR)
    pub mod datar1 {
        ///Register `DATAR1` reader
        pub type R = crate::R<DATAR1_SPEC>;
        ///Register `DATAR1` writer
        pub type W = crate::W<DATAR1_SPEC>;
        ///Field `D1` reader - Backup data
        pub type D1_R = crate::FieldReader<u16>;
        ///Field `D1` writer - Backup data
        pub type D1_W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            ///Bits 0:15 - Backup data
            #[inline(always)]
            pub fn d1(&self) -> D1_R {
                D1_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - Backup data
            #[inline(always)]
            #[must_use]
            pub fn d1(&mut self) -> D1_W<DATAR1_SPEC> {
                D1_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Backup data register (BKP_DR)
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`datar1::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`datar1::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct DATAR1_SPEC;
        impl crate::RegisterSpec for DATAR1_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`datar1::R`](R) reader structure
        impl crate::Readable for DATAR1_SPEC {}
        ///`write(|w| ..)` method takes [`datar1::W`](W) writer structure
        impl crate::Writable for DATAR1_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets DATAR1 to value 0
        impl crate::Resettable for DATAR1_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///DATAR2 (rw) register accessor: Backup data register (BKP_DR)
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`datar2::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`datar2::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@datar2`]
    ///module
    pub type DATAR2 = crate::Reg<datar2::DATAR2_SPEC>;
    ///Backup data register (BKP_DR)
    pub mod datar2 {
        ///Register `DATAR2` reader
        pub type R = crate::R<DATAR2_SPEC>;
        ///Register `DATAR2` writer
        pub type W = crate::W<DATAR2_SPEC>;
        ///Field `D2` reader - Backup data
        pub type D2_R = crate::FieldReader<u16>;
        ///Field `D2` writer - Backup data
        pub type D2_W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            ///Bits 0:15 - Backup data
            #[inline(always)]
            pub fn d2(&self) -> D2_R {
                D2_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - Backup data
            #[inline(always)]
            #[must_use]
            pub fn d2(&mut self) -> D2_W<DATAR2_SPEC> {
                D2_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Backup data register (BKP_DR)
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`datar2::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`datar2::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct DATAR2_SPEC;
        impl crate::RegisterSpec for DATAR2_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`datar2::R`](R) reader structure
        impl crate::Readable for DATAR2_SPEC {}
        ///`write(|w| ..)` method takes [`datar2::W`](W) writer structure
        impl crate::Writable for DATAR2_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets DATAR2 to value 0
        impl crate::Resettable for DATAR2_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///DATAR3 (rw) register accessor: Backup data register (BKP_DR)
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`datar3::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`datar3::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@datar3`]
    ///module
    pub type DATAR3 = crate::Reg<datar3::DATAR3_SPEC>;
    ///Backup data register (BKP_DR)
    pub mod datar3 {
        ///Register `DATAR3` reader
        pub type R = crate::R<DATAR3_SPEC>;
        ///Register `DATAR3` writer
        pub type W = crate::W<DATAR3_SPEC>;
        ///Field `D3` reader - Backup data
        pub type D3_R = crate::FieldReader<u16>;
        ///Field `D3` writer - Backup data
        pub type D3_W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            ///Bits 0:15 - Backup data
            #[inline(always)]
            pub fn d3(&self) -> D3_R {
                D3_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - Backup data
            #[inline(always)]
            #[must_use]
            pub fn d3(&mut self) -> D3_W<DATAR3_SPEC> {
                D3_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Backup data register (BKP_DR)
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`datar3::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`datar3::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct DATAR3_SPEC;
        impl crate::RegisterSpec for DATAR3_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`datar3::R`](R) reader structure
        impl crate::Readable for DATAR3_SPEC {}
        ///`write(|w| ..)` method takes [`datar3::W`](W) writer structure
        impl crate::Writable for DATAR3_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets DATAR3 to value 0
        impl crate::Resettable for DATAR3_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///DATAR4 (rw) register accessor: Backup data register (BKP_DR)
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`datar4::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`datar4::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@datar4`]
    ///module
    pub type DATAR4 = crate::Reg<datar4::DATAR4_SPEC>;
    ///Backup data register (BKP_DR)
    pub mod datar4 {
        ///Register `DATAR4` reader
        pub type R = crate::R<DATAR4_SPEC>;
        ///Register `DATAR4` writer
        pub type W = crate::W<DATAR4_SPEC>;
        ///Field `D4` reader - Backup data
        pub type D4_R = crate::FieldReader<u16>;
        ///Field `D4` writer - Backup data
        pub type D4_W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            ///Bits 0:15 - Backup data
            #[inline(always)]
            pub fn d4(&self) -> D4_R {
                D4_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - Backup data
            #[inline(always)]
            #[must_use]
            pub fn d4(&mut self) -> D4_W<DATAR4_SPEC> {
                D4_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Backup data register (BKP_DR)
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`datar4::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`datar4::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct DATAR4_SPEC;
        impl crate::RegisterSpec for DATAR4_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`datar4::R`](R) reader structure
        impl crate::Readable for DATAR4_SPEC {}
        ///`write(|w| ..)` method takes [`datar4::W`](W) writer structure
        impl crate::Writable for DATAR4_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets DATAR4 to value 0
        impl crate::Resettable for DATAR4_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///DATAR5 (rw) register accessor: Backup data register (BKP_DR)
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`datar5::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`datar5::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@datar5`]
    ///module
    pub type DATAR5 = crate::Reg<datar5::DATAR5_SPEC>;
    ///Backup data register (BKP_DR)
    pub mod datar5 {
        ///Register `DATAR5` reader
        pub type R = crate::R<DATAR5_SPEC>;
        ///Register `DATAR5` writer
        pub type W = crate::W<DATAR5_SPEC>;
        ///Field `D5` reader - Backup data
        pub type D5_R = crate::FieldReader<u16>;
        ///Field `D5` writer - Backup data
        pub type D5_W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            ///Bits 0:15 - Backup data
            #[inline(always)]
            pub fn d5(&self) -> D5_R {
                D5_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - Backup data
            #[inline(always)]
            #[must_use]
            pub fn d5(&mut self) -> D5_W<DATAR5_SPEC> {
                D5_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Backup data register (BKP_DR)
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`datar5::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`datar5::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct DATAR5_SPEC;
        impl crate::RegisterSpec for DATAR5_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`datar5::R`](R) reader structure
        impl crate::Readable for DATAR5_SPEC {}
        ///`write(|w| ..)` method takes [`datar5::W`](W) writer structure
        impl crate::Writable for DATAR5_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets DATAR5 to value 0
        impl crate::Resettable for DATAR5_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///DATAR6 (rw) register accessor: Backup data register (BKP_DR)
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`datar6::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`datar6::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@datar6`]
    ///module
    pub type DATAR6 = crate::Reg<datar6::DATAR6_SPEC>;
    ///Backup data register (BKP_DR)
    pub mod datar6 {
        ///Register `DATAR6` reader
        pub type R = crate::R<DATAR6_SPEC>;
        ///Register `DATAR6` writer
        pub type W = crate::W<DATAR6_SPEC>;
        ///Field `D6` reader - Backup data
        pub type D6_R = crate::FieldReader<u16>;
        ///Field `D6` writer - Backup data
        pub type D6_W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            ///Bits 0:15 - Backup data
            #[inline(always)]
            pub fn d6(&self) -> D6_R {
                D6_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - Backup data
            #[inline(always)]
            #[must_use]
            pub fn d6(&mut self) -> D6_W<DATAR6_SPEC> {
                D6_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Backup data register (BKP_DR)
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`datar6::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`datar6::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct DATAR6_SPEC;
        impl crate::RegisterSpec for DATAR6_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`datar6::R`](R) reader structure
        impl crate::Readable for DATAR6_SPEC {}
        ///`write(|w| ..)` method takes [`datar6::W`](W) writer structure
        impl crate::Writable for DATAR6_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets DATAR6 to value 0
        impl crate::Resettable for DATAR6_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///DATAR7 (rw) register accessor: Backup data register (BKP_DR)
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`datar7::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`datar7::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@datar7`]
    ///module
    pub type DATAR7 = crate::Reg<datar7::DATAR7_SPEC>;
    ///Backup data register (BKP_DR)
    pub mod datar7 {
        ///Register `DATAR7` reader
        pub type R = crate::R<DATAR7_SPEC>;
        ///Register `DATAR7` writer
        pub type W = crate::W<DATAR7_SPEC>;
        ///Field `D7` reader - Backup data
        pub type D7_R = crate::FieldReader<u16>;
        ///Field `D7` writer - Backup data
        pub type D7_W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            ///Bits 0:15 - Backup data
            #[inline(always)]
            pub fn d7(&self) -> D7_R {
                D7_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - Backup data
            #[inline(always)]
            #[must_use]
            pub fn d7(&mut self) -> D7_W<DATAR7_SPEC> {
                D7_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Backup data register (BKP_DR)
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`datar7::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`datar7::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct DATAR7_SPEC;
        impl crate::RegisterSpec for DATAR7_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`datar7::R`](R) reader structure
        impl crate::Readable for DATAR7_SPEC {}
        ///`write(|w| ..)` method takes [`datar7::W`](W) writer structure
        impl crate::Writable for DATAR7_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets DATAR7 to value 0
        impl crate::Resettable for DATAR7_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///DATAR8 (rw) register accessor: Backup data register (BKP_DR)
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`datar8::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`datar8::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@datar8`]
    ///module
    pub type DATAR8 = crate::Reg<datar8::DATAR8_SPEC>;
    ///Backup data register (BKP_DR)
    pub mod datar8 {
        ///Register `DATAR8` reader
        pub type R = crate::R<DATAR8_SPEC>;
        ///Register `DATAR8` writer
        pub type W = crate::W<DATAR8_SPEC>;
        ///Field `D8` reader - Backup data
        pub type D8_R = crate::FieldReader<u16>;
        ///Field `D8` writer - Backup data
        pub type D8_W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            ///Bits 0:15 - Backup data
            #[inline(always)]
            pub fn d8(&self) -> D8_R {
                D8_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - Backup data
            #[inline(always)]
            #[must_use]
            pub fn d8(&mut self) -> D8_W<DATAR8_SPEC> {
                D8_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Backup data register (BKP_DR)
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`datar8::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`datar8::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct DATAR8_SPEC;
        impl crate::RegisterSpec for DATAR8_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`datar8::R`](R) reader structure
        impl crate::Readable for DATAR8_SPEC {}
        ///`write(|w| ..)` method takes [`datar8::W`](W) writer structure
        impl crate::Writable for DATAR8_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets DATAR8 to value 0
        impl crate::Resettable for DATAR8_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///DATAR9 (rw) register accessor: Backup data register (BKP_DR)
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`datar9::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`datar9::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@datar9`]
    ///module
    pub type DATAR9 = crate::Reg<datar9::DATAR9_SPEC>;
    ///Backup data register (BKP_DR)
    pub mod datar9 {
        ///Register `DATAR9` reader
        pub type R = crate::R<DATAR9_SPEC>;
        ///Register `DATAR9` writer
        pub type W = crate::W<DATAR9_SPEC>;
        ///Field `D9` reader - Backup data
        pub type D9_R = crate::FieldReader<u16>;
        ///Field `D9` writer - Backup data
        pub type D9_W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            ///Bits 0:15 - Backup data
            #[inline(always)]
            pub fn d9(&self) -> D9_R {
                D9_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - Backup data
            #[inline(always)]
            #[must_use]
            pub fn d9(&mut self) -> D9_W<DATAR9_SPEC> {
                D9_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Backup data register (BKP_DR)
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`datar9::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`datar9::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct DATAR9_SPEC;
        impl crate::RegisterSpec for DATAR9_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`datar9::R`](R) reader structure
        impl crate::Readable for DATAR9_SPEC {}
        ///`write(|w| ..)` method takes [`datar9::W`](W) writer structure
        impl crate::Writable for DATAR9_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets DATAR9 to value 0
        impl crate::Resettable for DATAR9_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///DATAR10 (rw) register accessor: Backup data register (BKP_DR)
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`datar10::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`datar10::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@datar10`]
    ///module
    pub type DATAR10 = crate::Reg<datar10::DATAR10_SPEC>;
    ///Backup data register (BKP_DR)
    pub mod datar10 {
        ///Register `DATAR10` reader
        pub type R = crate::R<DATAR10_SPEC>;
        ///Register `DATAR10` writer
        pub type W = crate::W<DATAR10_SPEC>;
        ///Field `D10` reader - Backup data
        pub type D10_R = crate::FieldReader<u16>;
        ///Field `D10` writer - Backup data
        pub type D10_W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            ///Bits 0:15 - Backup data
            #[inline(always)]
            pub fn d10(&self) -> D10_R {
                D10_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - Backup data
            #[inline(always)]
            #[must_use]
            pub fn d10(&mut self) -> D10_W<DATAR10_SPEC> {
                D10_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Backup data register (BKP_DR)
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`datar10::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`datar10::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct DATAR10_SPEC;
        impl crate::RegisterSpec for DATAR10_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`datar10::R`](R) reader structure
        impl crate::Readable for DATAR10_SPEC {}
        ///`write(|w| ..)` method takes [`datar10::W`](W) writer structure
        impl crate::Writable for DATAR10_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets DATAR10 to value 0
        impl crate::Resettable for DATAR10_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///DATAR11 (rw) register accessor: Backup data register (BKP_DR)
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`datar11::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`datar11::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@datar11`]
    ///module
    pub type DATAR11 = crate::Reg<datar11::DATAR11_SPEC>;
    ///Backup data register (BKP_DR)
    pub mod datar11 {
        ///Register `DATAR11` reader
        pub type R = crate::R<DATAR11_SPEC>;
        ///Register `DATAR11` writer
        pub type W = crate::W<DATAR11_SPEC>;
        ///Field `D11` reader - Backup data
        pub type D11_R = crate::FieldReader<u16>;
        ///Field `D11` writer - Backup data
        pub type D11_W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            ///Bits 0:15 - Backup data
            #[inline(always)]
            pub fn d11(&self) -> D11_R {
                D11_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - Backup data
            #[inline(always)]
            #[must_use]
            pub fn d11(&mut self) -> D11_W<DATAR11_SPEC> {
                D11_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Backup data register (BKP_DR)
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`datar11::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`datar11::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct DATAR11_SPEC;
        impl crate::RegisterSpec for DATAR11_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`datar11::R`](R) reader structure
        impl crate::Readable for DATAR11_SPEC {}
        ///`write(|w| ..)` method takes [`datar11::W`](W) writer structure
        impl crate::Writable for DATAR11_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets DATAR11 to value 0
        impl crate::Resettable for DATAR11_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///DATAR12 (rw) register accessor: Backup data register (BKP_DR)
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`datar12::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`datar12::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@datar12`]
    ///module
    pub type DATAR12 = crate::Reg<datar12::DATAR12_SPEC>;
    ///Backup data register (BKP_DR)
    pub mod datar12 {
        ///Register `DATAR12` reader
        pub type R = crate::R<DATAR12_SPEC>;
        ///Register `DATAR12` writer
        pub type W = crate::W<DATAR12_SPEC>;
        ///Field `D12` reader - Backup data
        pub type D12_R = crate::FieldReader<u16>;
        ///Field `D12` writer - Backup data
        pub type D12_W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            ///Bits 0:15 - Backup data
            #[inline(always)]
            pub fn d12(&self) -> D12_R {
                D12_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - Backup data
            #[inline(always)]
            #[must_use]
            pub fn d12(&mut self) -> D12_W<DATAR12_SPEC> {
                D12_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Backup data register (BKP_DR)
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`datar12::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`datar12::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct DATAR12_SPEC;
        impl crate::RegisterSpec for DATAR12_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`datar12::R`](R) reader structure
        impl crate::Readable for DATAR12_SPEC {}
        ///`write(|w| ..)` method takes [`datar12::W`](W) writer structure
        impl crate::Writable for DATAR12_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets DATAR12 to value 0
        impl crate::Resettable for DATAR12_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///DATAR13 (rw) register accessor: Backup data register (BKP_DR)
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`datar13::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`datar13::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@datar13`]
    ///module
    pub type DATAR13 = crate::Reg<datar13::DATAR13_SPEC>;
    ///Backup data register (BKP_DR)
    pub mod datar13 {
        ///Register `DATAR13` reader
        pub type R = crate::R<DATAR13_SPEC>;
        ///Register `DATAR13` writer
        pub type W = crate::W<DATAR13_SPEC>;
        ///Field `D13` reader - Backup data
        pub type D13_R = crate::FieldReader<u16>;
        ///Field `D13` writer - Backup data
        pub type D13_W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            ///Bits 0:15 - Backup data
            #[inline(always)]
            pub fn d13(&self) -> D13_R {
                D13_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - Backup data
            #[inline(always)]
            #[must_use]
            pub fn d13(&mut self) -> D13_W<DATAR13_SPEC> {
                D13_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Backup data register (BKP_DR)
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`datar13::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`datar13::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct DATAR13_SPEC;
        impl crate::RegisterSpec for DATAR13_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`datar13::R`](R) reader structure
        impl crate::Readable for DATAR13_SPEC {}
        ///`write(|w| ..)` method takes [`datar13::W`](W) writer structure
        impl crate::Writable for DATAR13_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets DATAR13 to value 0
        impl crate::Resettable for DATAR13_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///OCTLR (rw) register accessor: RTC clock calibration register (BKP_OCTLR)
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`octlr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`octlr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@octlr`]
    ///module
    pub type OCTLR = crate::Reg<octlr::OCTLR_SPEC>;
    ///RTC clock calibration register (BKP_OCTLR)
    pub mod octlr {
        ///Register `OCTLR` reader
        pub type R = crate::R<OCTLR_SPEC>;
        ///Register `OCTLR` writer
        pub type W = crate::W<OCTLR_SPEC>;
        ///Field `CAL` reader - Calibration value
        pub type CAL_R = crate::FieldReader;
        ///Field `CAL` writer - Calibration value
        pub type CAL_W<'a, REG> = crate::FieldWriter<'a, REG, 7>;
        ///Field `CCO` reader - Calibration Clock Output
        pub type CCO_R = crate::BitReader;
        ///Field `CCO` writer - Calibration Clock Output
        pub type CCO_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `ASOE` reader - Alarm or second output enable
        pub type ASOE_R = crate::BitReader;
        ///Field `ASOE` writer - Alarm or second output enable
        pub type ASOE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `ASOS` reader - Alarm or second output selection
        pub type ASOS_R = crate::BitReader;
        ///Field `ASOS` writer - Alarm or second output selection
        pub type ASOS_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bits 0:6 - Calibration value
            #[inline(always)]
            pub fn cal(&self) -> CAL_R {
                CAL_R::new((self.bits & 0x7f) as u8)
            }
            ///Bit 7 - Calibration Clock Output
            #[inline(always)]
            pub fn cco(&self) -> CCO_R {
                CCO_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bit 8 - Alarm or second output enable
            #[inline(always)]
            pub fn asoe(&self) -> ASOE_R {
                ASOE_R::new(((self.bits >> 8) & 1) != 0)
            }
            ///Bit 9 - Alarm or second output selection
            #[inline(always)]
            pub fn asos(&self) -> ASOS_R {
                ASOS_R::new(((self.bits >> 9) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:6 - Calibration value
            #[inline(always)]
            #[must_use]
            pub fn cal(&mut self) -> CAL_W<OCTLR_SPEC> {
                CAL_W::new(self, 0)
            }
            ///Bit 7 - Calibration Clock Output
            #[inline(always)]
            #[must_use]
            pub fn cco(&mut self) -> CCO_W<OCTLR_SPEC> {
                CCO_W::new(self, 7)
            }
            ///Bit 8 - Alarm or second output enable
            #[inline(always)]
            #[must_use]
            pub fn asoe(&mut self) -> ASOE_W<OCTLR_SPEC> {
                ASOE_W::new(self, 8)
            }
            ///Bit 9 - Alarm or second output selection
            #[inline(always)]
            #[must_use]
            pub fn asos(&mut self) -> ASOS_W<OCTLR_SPEC> {
                ASOS_W::new(self, 9)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RTC clock calibration register (BKP_OCTLR)
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`octlr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`octlr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct OCTLR_SPEC;
        impl crate::RegisterSpec for OCTLR_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`octlr::R`](R) reader structure
        impl crate::Readable for OCTLR_SPEC {}
        ///`write(|w| ..)` method takes [`octlr::W`](W) writer structure
        impl crate::Writable for OCTLR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets OCTLR to value 0
        impl crate::Resettable for OCTLR_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///TPCTLR (rw) register accessor: Backup control register (BKP_TPCTLR)
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`tpctlr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`tpctlr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@tpctlr`]
    ///module
    pub type TPCTLR = crate::Reg<tpctlr::TPCTLR_SPEC>;
    ///Backup control register (BKP_TPCTLR)
    pub mod tpctlr {
        ///Register `TPCTLR` reader
        pub type R = crate::R<TPCTLR_SPEC>;
        ///Register `TPCTLR` writer
        pub type W = crate::W<TPCTLR_SPEC>;
        ///Field `TPE` reader - Tamper pin enable
        pub type TPE_R = crate::BitReader;
        ///Field `TPE` writer - Tamper pin enable
        pub type TPE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TPAL` reader - Tamper pin active level
        pub type TPAL_R = crate::BitReader;
        ///Field `TPAL` writer - Tamper pin active level
        pub type TPAL_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - Tamper pin enable
            #[inline(always)]
            pub fn tpe(&self) -> TPE_R {
                TPE_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Tamper pin active level
            #[inline(always)]
            pub fn tpal(&self) -> TPAL_R {
                TPAL_R::new(((self.bits >> 1) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - Tamper pin enable
            #[inline(always)]
            #[must_use]
            pub fn tpe(&mut self) -> TPE_W<TPCTLR_SPEC> {
                TPE_W::new(self, 0)
            }
            ///Bit 1 - Tamper pin active level
            #[inline(always)]
            #[must_use]
            pub fn tpal(&mut self) -> TPAL_W<TPCTLR_SPEC> {
                TPAL_W::new(self, 1)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Backup control register (BKP_TPCTLR)
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`tpctlr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`tpctlr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct TPCTLR_SPEC;
        impl crate::RegisterSpec for TPCTLR_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`tpctlr::R`](R) reader structure
        impl crate::Readable for TPCTLR_SPEC {}
        ///`write(|w| ..)` method takes [`tpctlr::W`](W) writer structure
        impl crate::Writable for TPCTLR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets TPCTLR to value 0
        impl crate::Resettable for TPCTLR_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///TPCSR (rw) register accessor: BKP_TPCSR control/status register (BKP_CSR)
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`tpcsr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`tpcsr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@tpcsr`]
    ///module
    pub type TPCSR = crate::Reg<tpcsr::TPCSR_SPEC>;
    ///BKP_TPCSR control/status register (BKP_CSR)
    pub mod tpcsr {
        ///Register `TPCSR` reader
        pub type R = crate::R<TPCSR_SPEC>;
        ///Register `TPCSR` writer
        pub type W = crate::W<TPCSR_SPEC>;
        ///Field `CTE` writer - Clear Tamper event
        pub type CTE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CTI` writer - Clear Tamper Interrupt
        pub type CTI_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TPIE` reader - Tamper Pin interrupt enable
        pub type TPIE_R = crate::BitReader;
        ///Field `TPIE` writer - Tamper Pin interrupt enable
        pub type TPIE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TEF` reader - Tamper Event Flag
        pub type TEF_R = crate::BitReader;
        ///Field `TIF` reader - Tamper Interrupt Flag
        pub type TIF_R = crate::BitReader;
        impl R {
            ///Bit 2 - Tamper Pin interrupt enable
            #[inline(always)]
            pub fn tpie(&self) -> TPIE_R {
                TPIE_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 8 - Tamper Event Flag
            #[inline(always)]
            pub fn tef(&self) -> TEF_R {
                TEF_R::new(((self.bits >> 8) & 1) != 0)
            }
            ///Bit 9 - Tamper Interrupt Flag
            #[inline(always)]
            pub fn tif(&self) -> TIF_R {
                TIF_R::new(((self.bits >> 9) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - Clear Tamper event
            #[inline(always)]
            #[must_use]
            pub fn cte(&mut self) -> CTE_W<TPCSR_SPEC> {
                CTE_W::new(self, 0)
            }
            ///Bit 1 - Clear Tamper Interrupt
            #[inline(always)]
            #[must_use]
            pub fn cti(&mut self) -> CTI_W<TPCSR_SPEC> {
                CTI_W::new(self, 1)
            }
            ///Bit 2 - Tamper Pin interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn tpie(&mut self) -> TPIE_W<TPCSR_SPEC> {
                TPIE_W::new(self, 2)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///BKP_TPCSR control/status register (BKP_CSR)
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`tpcsr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`tpcsr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct TPCSR_SPEC;
        impl crate::RegisterSpec for TPCSR_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`tpcsr::R`](R) reader structure
        impl crate::Readable for TPCSR_SPEC {}
        ///`write(|w| ..)` method takes [`tpcsr::W`](W) writer structure
        impl crate::Writable for TPCSR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets TPCSR to value 0
        impl crate::Resettable for TPCSR_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
}
///Independent watchdog
pub struct IWDG {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for IWDG {}
impl IWDG {
    ///Pointer to the register block
    pub const PTR: *const iwdg::RegisterBlock = 0x4000_3000 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const iwdg::RegisterBlock {
        Self::PTR
    }
    /// Steal an instance of this peripheral
    ///
    /// # Safety
    ///
    /// Ensure that the new instance of the peripheral cannot be used in a way
    /// that may race with any existing instances, for example by only
    /// accessing read-only or write-only registers, or by consuming the
    /// original peripheral and using critical sections to coordinate
    /// access between multiple new instances.
    ///
    /// Additionally, other software such as HALs may rely on only one
    /// peripheral instance existing to ensure memory safety; ensure
    /// no stolen instances are passed to such software.
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for IWDG {
    type Target = iwdg::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for IWDG {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("IWDG").finish()
    }
}
///Independent watchdog
pub mod iwdg {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        ctlr: CTLR,
        _reserved1: [u8; 0x02],
        pscr: PSCR,
        _reserved2: [u8; 0x02],
        rldr: RLDR,
        _reserved3: [u8; 0x02],
        statr: STATR,
    }
    impl RegisterBlock {
        ///0x00 - Key register (IWDG_CTLR)
        #[inline(always)]
        pub const fn ctlr(&self) -> &CTLR {
            &self.ctlr
        }
        ///0x04 - Prescaler register (IWDG_PSCR)
        #[inline(always)]
        pub const fn pscr(&self) -> &PSCR {
            &self.pscr
        }
        ///0x08 - Reload register (IWDG_RLDR)
        #[inline(always)]
        pub const fn rldr(&self) -> &RLDR {
            &self.rldr
        }
        ///0x0c - Status register (IWDG_SR)
        #[inline(always)]
        pub const fn statr(&self) -> &STATR {
            &self.statr
        }
    }
    ///CTLR (w) register accessor: Key register (IWDG_CTLR)
    ///
    ///You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ctlr::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@ctlr`]
    ///module
    pub type CTLR = crate::Reg<ctlr::CTLR_SPEC>;
    ///Key register (IWDG_CTLR)
    pub mod ctlr {
        ///Register `CTLR` writer
        pub type W = crate::W<CTLR_SPEC>;
        ///Field `KEY` writer - Key value
        pub type KEY_W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl W {
            ///Bits 0:15 - Key value
            #[inline(always)]
            #[must_use]
            pub fn key(&mut self) -> KEY_W<CTLR_SPEC> {
                KEY_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Key register (IWDG_CTLR)
        ///
        ///You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ctlr::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct CTLR_SPEC;
        impl crate::RegisterSpec for CTLR_SPEC {
            type Ux = u16;
        }
        ///`write(|w| ..)` method takes [`ctlr::W`](W) writer structure
        impl crate::Writable for CTLR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets CTLR to value 0
        impl crate::Resettable for CTLR_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///PSCR (rw) register accessor: Prescaler register (IWDG_PSCR)
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`pscr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pscr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@pscr`]
    ///module
    pub type PSCR = crate::Reg<pscr::PSCR_SPEC>;
    ///Prescaler register (IWDG_PSCR)
    pub mod pscr {
        ///Register `PSCR` reader
        pub type R = crate::R<PSCR_SPEC>;
        ///Register `PSCR` writer
        pub type W = crate::W<PSCR_SPEC>;
        ///Field `PR` reader - Prescaler divider
        pub type PR_R = crate::FieldReader;
        ///Field `PR` writer - Prescaler divider
        pub type PR_W<'a, REG> = crate::FieldWriter<'a, REG, 3>;
        impl R {
            ///Bits 0:2 - Prescaler divider
            #[inline(always)]
            pub fn pr(&self) -> PR_R {
                PR_R::new((self.bits & 7) as u8)
            }
        }
        impl W {
            ///Bits 0:2 - Prescaler divider
            #[inline(always)]
            #[must_use]
            pub fn pr(&mut self) -> PR_W<PSCR_SPEC> {
                PR_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Prescaler register (IWDG_PSCR)
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`pscr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pscr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct PSCR_SPEC;
        impl crate::RegisterSpec for PSCR_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`pscr::R`](R) reader structure
        impl crate::Readable for PSCR_SPEC {}
        ///`write(|w| ..)` method takes [`pscr::W`](W) writer structure
        impl crate::Writable for PSCR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets PSCR to value 0
        impl crate::Resettable for PSCR_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///RLDR (rw) register accessor: Reload register (IWDG_RLDR)
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`rldr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`rldr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@rldr`]
    ///module
    pub type RLDR = crate::Reg<rldr::RLDR_SPEC>;
    ///Reload register (IWDG_RLDR)
    pub mod rldr {
        ///Register `RLDR` reader
        pub type R = crate::R<RLDR_SPEC>;
        ///Register `RLDR` writer
        pub type W = crate::W<RLDR_SPEC>;
        ///Field `RL` reader - Watchdog counter reload value
        pub type RL_R = crate::FieldReader<u16>;
        ///Field `RL` writer - Watchdog counter reload value
        pub type RL_W<'a, REG> = crate::FieldWriter<'a, REG, 12, u16>;
        impl R {
            ///Bits 0:11 - Watchdog counter reload value
            #[inline(always)]
            pub fn rl(&self) -> RL_R {
                RL_R::new(self.bits & 0x0fff)
            }
        }
        impl W {
            ///Bits 0:11 - Watchdog counter reload value
            #[inline(always)]
            #[must_use]
            pub fn rl(&mut self) -> RL_W<RLDR_SPEC> {
                RL_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Reload register (IWDG_RLDR)
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`rldr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`rldr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct RLDR_SPEC;
        impl crate::RegisterSpec for RLDR_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`rldr::R`](R) reader structure
        impl crate::Readable for RLDR_SPEC {}
        ///`write(|w| ..)` method takes [`rldr::W`](W) writer structure
        impl crate::Writable for RLDR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets RLDR to value 0x0fff
        impl crate::Resettable for RLDR_SPEC {
            const RESET_VALUE: u16 = 0x0fff;
        }
    }
    ///STATR (r) register accessor: Status register (IWDG_SR)
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`statr::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@statr`]
    ///module
    pub type STATR = crate::Reg<statr::STATR_SPEC>;
    ///Status register (IWDG_SR)
    pub mod statr {
        ///Register `STATR` reader
        pub type R = crate::R<STATR_SPEC>;
        ///Field `PVU` reader - Watchdog prescaler value update
        pub type PVU_R = crate::BitReader;
        ///Field `RVU` reader - Watchdog counter reload value update
        pub type RVU_R = crate::BitReader;
        impl R {
            ///Bit 0 - Watchdog prescaler value update
            #[inline(always)]
            pub fn pvu(&self) -> PVU_R {
                PVU_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Watchdog counter reload value update
            #[inline(always)]
            pub fn rvu(&self) -> RVU_R {
                RVU_R::new(((self.bits >> 1) & 1) != 0)
            }
        }
        ///Status register (IWDG_SR)
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`statr::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct STATR_SPEC;
        impl crate::RegisterSpec for STATR_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`statr::R`](R) reader structure
        impl crate::Readable for STATR_SPEC {}
        ///`reset()` method sets STATR to value 0
        impl crate::Resettable for STATR_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
}
///Window watchdog
pub struct WWDG {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for WWDG {}
impl WWDG {
    ///Pointer to the register block
    pub const PTR: *const wwdg::RegisterBlock = 0x4000_2c00 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const wwdg::RegisterBlock {
        Self::PTR
    }
    /// Steal an instance of this peripheral
    ///
    /// # Safety
    ///
    /// Ensure that the new instance of the peripheral cannot be used in a way
    /// that may race with any existing instances, for example by only
    /// accessing read-only or write-only registers, or by consuming the
    /// original peripheral and using critical sections to coordinate
    /// access between multiple new instances.
    ///
    /// Additionally, other software such as HALs may rely on only one
    /// peripheral instance existing to ensure memory safety; ensure
    /// no stolen instances are passed to such software.
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for WWDG {
    type Target = wwdg::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for WWDG {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("WWDG").finish()
    }
}
///Window watchdog
pub mod wwdg {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        ctlr: CTLR,
        _reserved1: [u8; 0x02],
        cfgr: CFGR,
        _reserved2: [u8; 0x02],
        statr: STATR,
    }
    impl RegisterBlock {
        ///0x00 - Control register (WWDG_CR)
        #[inline(always)]
        pub const fn ctlr(&self) -> &CTLR {
            &self.ctlr
        }
        ///0x04 - Configuration register (WWDG_CFR)
        #[inline(always)]
        pub const fn cfgr(&self) -> &CFGR {
            &self.cfgr
        }
        ///0x08 - Status register (WWDG_SR)
        #[inline(always)]
        pub const fn statr(&self) -> &STATR {
            &self.statr
        }
    }
    ///CTLR (rw) register accessor: Control register (WWDG_CR)
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`ctlr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ctlr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@ctlr`]
    ///module
    pub type CTLR = crate::Reg<ctlr::CTLR_SPEC>;
    ///Control register (WWDG_CR)
    pub mod ctlr {
        ///Register `CTLR` reader
        pub type R = crate::R<CTLR_SPEC>;
        ///Register `CTLR` writer
        pub type W = crate::W<CTLR_SPEC>;
        ///Field `T` reader - 7-bit counter (MSB to LSB)
        pub type T_R = crate::FieldReader;
        ///Field `T` writer - 7-bit counter (MSB to LSB)
        pub type T_W<'a, REG> = crate::FieldWriter<'a, REG, 7>;
        ///Field `WDGA` reader - Activation bit
        pub type WDGA_R = crate::BitReader;
        ///Field `WDGA` writer - Activation bit
        pub type WDGA_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bits 0:6 - 7-bit counter (MSB to LSB)
            #[inline(always)]
            pub fn t(&self) -> T_R {
                T_R::new((self.bits & 0x7f) as u8)
            }
            ///Bit 7 - Activation bit
            #[inline(always)]
            pub fn wdga(&self) -> WDGA_R {
                WDGA_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:6 - 7-bit counter (MSB to LSB)
            #[inline(always)]
            #[must_use]
            pub fn t(&mut self) -> T_W<CTLR_SPEC> {
                T_W::new(self, 0)
            }
            ///Bit 7 - Activation bit
            #[inline(always)]
            #[must_use]
            pub fn wdga(&mut self) -> WDGA_W<CTLR_SPEC> {
                WDGA_W::new(self, 7)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Control register (WWDG_CR)
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`ctlr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ctlr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct CTLR_SPEC;
        impl crate::RegisterSpec for CTLR_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`ctlr::R`](R) reader structure
        impl crate::Readable for CTLR_SPEC {}
        ///`write(|w| ..)` method takes [`ctlr::W`](W) writer structure
        impl crate::Writable for CTLR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets CTLR to value 0x7f
        impl crate::Resettable for CTLR_SPEC {
            const RESET_VALUE: u16 = 0x7f;
        }
    }
    ///CFGR (rw) register accessor: Configuration register (WWDG_CFR)
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`cfgr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cfgr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@cfgr`]
    ///module
    pub type CFGR = crate::Reg<cfgr::CFGR_SPEC>;
    ///Configuration register (WWDG_CFR)
    pub mod cfgr {
        ///Register `CFGR` reader
        pub type R = crate::R<CFGR_SPEC>;
        ///Register `CFGR` writer
        pub type W = crate::W<CFGR_SPEC>;
        ///Field `W` reader - 7-bit window value
        pub type W_R = crate::FieldReader;
        ///Field `W` writer - 7-bit window value
        pub type W_W<'a, REG> = crate::FieldWriter<'a, REG, 7>;
        ///Field `WDGTB` reader - Timer Base
        pub type WDGTB_R = crate::FieldReader;
        ///Field `WDGTB` writer - Timer Base
        pub type WDGTB_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `EWI` reader - Early Wakeup Interrupt
        pub type EWI_R = crate::BitReader;
        ///Field `EWI` writer - Early Wakeup Interrupt
        pub type EWI_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bits 0:6 - 7-bit window value
            #[inline(always)]
            pub fn w(&self) -> W_R {
                W_R::new((self.bits & 0x7f) as u8)
            }
            ///Bits 7:8 - Timer Base
            #[inline(always)]
            pub fn wdgtb(&self) -> WDGTB_R {
                WDGTB_R::new(((self.bits >> 7) & 3) as u8)
            }
            ///Bit 9 - Early Wakeup Interrupt
            #[inline(always)]
            pub fn ewi(&self) -> EWI_R {
                EWI_R::new(((self.bits >> 9) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:6 - 7-bit window value
            #[inline(always)]
            #[must_use]
            pub fn w(&mut self) -> W_W<CFGR_SPEC> {
                W_W::new(self, 0)
            }
            ///Bits 7:8 - Timer Base
            #[inline(always)]
            #[must_use]
            pub fn wdgtb(&mut self) -> WDGTB_W<CFGR_SPEC> {
                WDGTB_W::new(self, 7)
            }
            ///Bit 9 - Early Wakeup Interrupt
            #[inline(always)]
            #[must_use]
            pub fn ewi(&mut self) -> EWI_W<CFGR_SPEC> {
                EWI_W::new(self, 9)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Configuration register (WWDG_CFR)
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`cfgr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cfgr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct CFGR_SPEC;
        impl crate::RegisterSpec for CFGR_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`cfgr::R`](R) reader structure
        impl crate::Readable for CFGR_SPEC {}
        ///`write(|w| ..)` method takes [`cfgr::W`](W) writer structure
        impl crate::Writable for CFGR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets CFGR to value 0x7f
        impl crate::Resettable for CFGR_SPEC {
            const RESET_VALUE: u16 = 0x7f;
        }
    }
    ///STATR (rw) register accessor: Status register (WWDG_SR)
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`statr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`statr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@statr`]
    ///module
    pub type STATR = crate::Reg<statr::STATR_SPEC>;
    ///Status register (WWDG_SR)
    pub mod statr {
        ///Register `STATR` reader
        pub type R = crate::R<STATR_SPEC>;
        ///Register `STATR` writer
        pub type W = crate::W<STATR_SPEC>;
        ///Field `WEIF` reader - Early Wakeup Interrupt Flag
        pub type WEIF_R = crate::BitReader;
        ///Field `WEIF` writer - Early Wakeup Interrupt Flag
        pub type WEIF_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - Early Wakeup Interrupt Flag
            #[inline(always)]
            pub fn weif(&self) -> WEIF_R {
                WEIF_R::new((self.bits & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - Early Wakeup Interrupt Flag
            #[inline(always)]
            #[must_use]
            pub fn weif(&mut self) -> WEIF_W<STATR_SPEC> {
                WEIF_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Status register (WWDG_SR)
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`statr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`statr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct STATR_SPEC;
        impl crate::RegisterSpec for STATR_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`statr::R`](R) reader structure
        impl crate::Readable for STATR_SPEC {}
        ///`write(|w| ..)` method takes [`statr::W`](W) writer structure
        impl crate::Writable for STATR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets STATR to value 0
        impl crate::Resettable for STATR_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
}
///Advanced timer
pub struct TIM1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for TIM1 {}
impl TIM1 {
    ///Pointer to the register block
    pub const PTR: *const tim1::RegisterBlock = 0x4001_2c00 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const tim1::RegisterBlock {
        Self::PTR
    }
    /// Steal an instance of this peripheral
    ///
    /// # Safety
    ///
    /// Ensure that the new instance of the peripheral cannot be used in a way
    /// that may race with any existing instances, for example by only
    /// accessing read-only or write-only registers, or by consuming the
    /// original peripheral and using critical sections to coordinate
    /// access between multiple new instances.
    ///
    /// Additionally, other software such as HALs may rely on only one
    /// peripheral instance existing to ensure memory safety; ensure
    /// no stolen instances are passed to such software.
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for TIM1 {
    type Target = tim1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for TIM1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("TIM1").finish()
    }
}
///Advanced timer
pub mod tim1 {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        ctlr1: CTLR1,
        _reserved1: [u8; 0x02],
        ctlr2: CTLR2,
        _reserved2: [u8; 0x02],
        smcfgr: SMCFGR,
        _reserved3: [u8; 0x02],
        dmaintenr: DMAINTENR,
        _reserved4: [u8; 0x02],
        intfr: INTFR,
        _reserved5: [u8; 0x02],
        swevgr: SWEVGR,
        _reserved6: [u8; 0x02],
        _reserved_6_chctlr1: [u8; 0x04],
        _reserved_7_chctlr2: [u8; 0x02],
        _reserved8: [u8; 0x02],
        ccer: CCER,
        _reserved9: [u8; 0x02],
        cnt: CNT,
        _reserved10: [u8; 0x02],
        psc: PSC,
        _reserved11: [u8; 0x02],
        atrlr: ATRLR,
        _reserved12: [u8; 0x02],
        rptcr: RPTCR,
        _reserved13: [u8; 0x02],
        ch1cvr: CH1CVR,
        _reserved14: [u8; 0x02],
        ch2cvr: CH2CVR,
        _reserved15: [u8; 0x02],
        ch3cvr: CH3CVR,
        _reserved16: [u8; 0x02],
        ch4cvr: CH4CVR,
        _reserved17: [u8; 0x02],
        bdtr: BDTR,
        _reserved18: [u8; 0x02],
        dmacfgr: DMACFGR,
        _reserved19: [u8; 0x02],
        dmaadr: DMAADR,
    }
    impl RegisterBlock {
        ///0x00 - control register 1
        #[inline(always)]
        pub const fn ctlr1(&self) -> &CTLR1 {
            &self.ctlr1
        }
        ///0x04 - control register 2
        #[inline(always)]
        pub const fn ctlr2(&self) -> &CTLR2 {
            &self.ctlr2
        }
        ///0x08 - slave mode control register
        #[inline(always)]
        pub const fn smcfgr(&self) -> &SMCFGR {
            &self.smcfgr
        }
        ///0x0c - DMA/Interrupt enable register
        #[inline(always)]
        pub const fn dmaintenr(&self) -> &DMAINTENR {
            &self.dmaintenr
        }
        ///0x10 - status register
        #[inline(always)]
        pub const fn intfr(&self) -> &INTFR {
            &self.intfr
        }
        ///0x14 - event generation register
        #[inline(always)]
        pub const fn swevgr(&self) -> &SWEVGR {
            &self.swevgr
        }
        ///0x18 - capture/compare mode register 1 (input mode)
        #[inline(always)]
        pub const fn chctlr1_input(&self) -> &CHCTLR1_INPUT {
            unsafe { &*(self as *const Self).cast::<u8>().add(24).cast() }
        }
        ///0x18 - capture/compare mode register (output mode)
        #[inline(always)]
        pub const fn chctlr1_output(&self) -> &CHCTLR1_OUTPUT {
            unsafe { &*(self as *const Self).cast::<u8>().add(24).cast() }
        }
        ///0x1c - capture/compare mode register 2 (input mode)
        #[inline(always)]
        pub const fn chctlr2_input(&self) -> &CHCTLR2_INPUT {
            unsafe { &*(self as *const Self).cast::<u8>().add(28).cast() }
        }
        ///0x1c - capture/compare mode register (output mode)
        #[inline(always)]
        pub const fn chctlr2_output(&self) -> &CHCTLR2_OUTPUT {
            unsafe { &*(self as *const Self).cast::<u8>().add(28).cast() }
        }
        ///0x20 - capture/compare enable register
        #[inline(always)]
        pub const fn ccer(&self) -> &CCER {
            &self.ccer
        }
        ///0x24 - counter
        #[inline(always)]
        pub const fn cnt(&self) -> &CNT {
            &self.cnt
        }
        ///0x28 - prescaler
        #[inline(always)]
        pub const fn psc(&self) -> &PSC {
            &self.psc
        }
        ///0x2c - auto-reload register
        #[inline(always)]
        pub const fn atrlr(&self) -> &ATRLR {
            &self.atrlr
        }
        ///0x30 - repetition counter register
        #[inline(always)]
        pub const fn rptcr(&self) -> &RPTCR {
            &self.rptcr
        }
        ///0x34 - capture/compare register 1
        #[inline(always)]
        pub const fn ch1cvr(&self) -> &CH1CVR {
            &self.ch1cvr
        }
        ///0x38 - capture/compare register 2
        #[inline(always)]
        pub const fn ch2cvr(&self) -> &CH2CVR {
            &self.ch2cvr
        }
        ///0x3c - capture/compare register 3
        #[inline(always)]
        pub const fn ch3cvr(&self) -> &CH3CVR {
            &self.ch3cvr
        }
        ///0x40 - capture/compare register 4
        #[inline(always)]
        pub const fn ch4cvr(&self) -> &CH4CVR {
            &self.ch4cvr
        }
        ///0x44 - break and dead-time register
        #[inline(always)]
        pub const fn bdtr(&self) -> &BDTR {
            &self.bdtr
        }
        ///0x48 - DMA control register
        #[inline(always)]
        pub const fn dmacfgr(&self) -> &DMACFGR {
            &self.dmacfgr
        }
        ///0x4c - DMA address for full transfer
        #[inline(always)]
        pub const fn dmaadr(&self) -> &DMAADR {
            &self.dmaadr
        }
    }
    ///CTLR1 (rw) register accessor: control register 1
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`ctlr1::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ctlr1::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@ctlr1`]
    ///module
    pub type CTLR1 = crate::Reg<ctlr1::CTLR1_SPEC>;
    ///control register 1
    pub mod ctlr1 {
        ///Register `CTLR1` reader
        pub type R = crate::R<CTLR1_SPEC>;
        ///Register `CTLR1` writer
        pub type W = crate::W<CTLR1_SPEC>;
        ///Field `CEN` reader - Counter enable
        pub type CEN_R = crate::BitReader;
        ///Field `CEN` writer - Counter enable
        pub type CEN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UDIS` reader - Update disable
        pub type UDIS_R = crate::BitReader;
        ///Field `UDIS` writer - Update disable
        pub type UDIS_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `URS` reader - Update request source
        pub type URS_R = crate::BitReader;
        ///Field `URS` writer - Update request source
        pub type URS_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `OPM` reader - One-pulse mode
        pub type OPM_R = crate::BitReader;
        ///Field `OPM` writer - One-pulse mode
        pub type OPM_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `DIR` reader - Direction
        pub type DIR_R = crate::BitReader;
        ///Field `DIR` writer - Direction
        pub type DIR_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CMS` reader - Center-aligned mode selection
        pub type CMS_R = crate::FieldReader;
        ///Field `CMS` writer - Center-aligned mode selection
        pub type CMS_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `ARPE` reader - Auto-reload preload enable
        pub type ARPE_R = crate::BitReader;
        ///Field `ARPE` writer - Auto-reload preload enable
        pub type ARPE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CKD` reader - Clock division
        pub type CKD_R = crate::FieldReader;
        ///Field `CKD` writer - Clock division
        pub type CKD_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `TMR_CAP_OV_EN` reader - Capture the value mode configuration
        pub type TMR_CAP_OV_EN_R = crate::BitReader;
        ///Field `TMR_CAP_OV_EN` writer - Capture the value mode configuration
        pub type TMR_CAP_OV_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TMR_CAP_LVL_EN` reader - Directive function enable
        pub type TMR_CAP_LVL_EN_R = crate::BitReader;
        ///Field `TMR_CAP_LVL_EN` writer - Directive function enable
        pub type TMR_CAP_LVL_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - Counter enable
            #[inline(always)]
            pub fn cen(&self) -> CEN_R {
                CEN_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Update disable
            #[inline(always)]
            pub fn udis(&self) -> UDIS_R {
                UDIS_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - Update request source
            #[inline(always)]
            pub fn urs(&self) -> URS_R {
                URS_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - One-pulse mode
            #[inline(always)]
            pub fn opm(&self) -> OPM_R {
                OPM_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - Direction
            #[inline(always)]
            pub fn dir(&self) -> DIR_R {
                DIR_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bits 5:6 - Center-aligned mode selection
            #[inline(always)]
            pub fn cms(&self) -> CMS_R {
                CMS_R::new(((self.bits >> 5) & 3) as u8)
            }
            ///Bit 7 - Auto-reload preload enable
            #[inline(always)]
            pub fn arpe(&self) -> ARPE_R {
                ARPE_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bits 8:9 - Clock division
            #[inline(always)]
            pub fn ckd(&self) -> CKD_R {
                CKD_R::new(((self.bits >> 8) & 3) as u8)
            }
            ///Bit 14 - Capture the value mode configuration
            #[inline(always)]
            pub fn tmr_cap_ov_en(&self) -> TMR_CAP_OV_EN_R {
                TMR_CAP_OV_EN_R::new(((self.bits >> 14) & 1) != 0)
            }
            ///Bit 15 - Directive function enable
            #[inline(always)]
            pub fn tmr_cap_lvl_en(&self) -> TMR_CAP_LVL_EN_R {
                TMR_CAP_LVL_EN_R::new(((self.bits >> 15) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - Counter enable
            #[inline(always)]
            #[must_use]
            pub fn cen(&mut self) -> CEN_W<CTLR1_SPEC> {
                CEN_W::new(self, 0)
            }
            ///Bit 1 - Update disable
            #[inline(always)]
            #[must_use]
            pub fn udis(&mut self) -> UDIS_W<CTLR1_SPEC> {
                UDIS_W::new(self, 1)
            }
            ///Bit 2 - Update request source
            #[inline(always)]
            #[must_use]
            pub fn urs(&mut self) -> URS_W<CTLR1_SPEC> {
                URS_W::new(self, 2)
            }
            ///Bit 3 - One-pulse mode
            #[inline(always)]
            #[must_use]
            pub fn opm(&mut self) -> OPM_W<CTLR1_SPEC> {
                OPM_W::new(self, 3)
            }
            ///Bit 4 - Direction
            #[inline(always)]
            #[must_use]
            pub fn dir(&mut self) -> DIR_W<CTLR1_SPEC> {
                DIR_W::new(self, 4)
            }
            ///Bits 5:6 - Center-aligned mode selection
            #[inline(always)]
            #[must_use]
            pub fn cms(&mut self) -> CMS_W<CTLR1_SPEC> {
                CMS_W::new(self, 5)
            }
            ///Bit 7 - Auto-reload preload enable
            #[inline(always)]
            #[must_use]
            pub fn arpe(&mut self) -> ARPE_W<CTLR1_SPEC> {
                ARPE_W::new(self, 7)
            }
            ///Bits 8:9 - Clock division
            #[inline(always)]
            #[must_use]
            pub fn ckd(&mut self) -> CKD_W<CTLR1_SPEC> {
                CKD_W::new(self, 8)
            }
            ///Bit 14 - Capture the value mode configuration
            #[inline(always)]
            #[must_use]
            pub fn tmr_cap_ov_en(&mut self) -> TMR_CAP_OV_EN_W<CTLR1_SPEC> {
                TMR_CAP_OV_EN_W::new(self, 14)
            }
            ///Bit 15 - Directive function enable
            #[inline(always)]
            #[must_use]
            pub fn tmr_cap_lvl_en(&mut self) -> TMR_CAP_LVL_EN_W<CTLR1_SPEC> {
                TMR_CAP_LVL_EN_W::new(self, 15)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///control register 1
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`ctlr1::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ctlr1::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct CTLR1_SPEC;
        impl crate::RegisterSpec for CTLR1_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`ctlr1::R`](R) reader structure
        impl crate::Readable for CTLR1_SPEC {}
        ///`write(|w| ..)` method takes [`ctlr1::W`](W) writer structure
        impl crate::Writable for CTLR1_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets CTLR1 to value 0
        impl crate::Resettable for CTLR1_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///CTLR2 (rw) register accessor: control register 2
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`ctlr2::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ctlr2::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@ctlr2`]
    ///module
    pub type CTLR2 = crate::Reg<ctlr2::CTLR2_SPEC>;
    ///control register 2
    pub mod ctlr2 {
        ///Register `CTLR2` reader
        pub type R = crate::R<CTLR2_SPEC>;
        ///Register `CTLR2` writer
        pub type W = crate::W<CTLR2_SPEC>;
        ///Field `CCPC` reader - Capture/compare preloaded control
        pub type CCPC_R = crate::BitReader;
        ///Field `CCPC` writer - Capture/compare preloaded control
        pub type CCPC_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CCUS` reader - Capture/compare control update selection
        pub type CCUS_R = crate::BitReader;
        ///Field `CCUS` writer - Capture/compare control update selection
        pub type CCUS_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CCDS` reader - Capture/compare DMA selection
        pub type CCDS_R = crate::BitReader;
        ///Field `CCDS` writer - Capture/compare DMA selection
        pub type CCDS_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `MMS` reader - Master mode selection
        pub type MMS_R = crate::FieldReader;
        ///Field `MMS` writer - Master mode selection
        pub type MMS_W<'a, REG> = crate::FieldWriter<'a, REG, 3>;
        ///Field `TI1S` reader - TI1 selection
        pub type TI1S_R = crate::BitReader;
        ///Field `TI1S` writer - TI1 selection
        pub type TI1S_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `OIS1` reader - Output Idle state 1
        pub type OIS1_R = crate::BitReader;
        ///Field `OIS1` writer - Output Idle state 1
        pub type OIS1_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `OIS1N` reader - Output Idle state 1
        pub type OIS1N_R = crate::BitReader;
        ///Field `OIS1N` writer - Output Idle state 1
        pub type OIS1N_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `OIS2` reader - Output Idle state 2
        pub type OIS2_R = crate::BitReader;
        ///Field `OIS2` writer - Output Idle state 2
        pub type OIS2_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `OIS2N` reader - Output Idle state 2
        pub type OIS2N_R = crate::BitReader;
        ///Field `OIS2N` writer - Output Idle state 2
        pub type OIS2N_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `OIS3` reader - Output Idle state 3
        pub type OIS3_R = crate::BitReader;
        ///Field `OIS3` writer - Output Idle state 3
        pub type OIS3_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `OIS3N` reader - Output Idle state 3
        pub type OIS3N_R = crate::BitReader;
        ///Field `OIS3N` writer - Output Idle state 3
        pub type OIS3N_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `OIS4` reader - Output Idle state 4
        pub type OIS4_R = crate::BitReader;
        ///Field `OIS4` writer - Output Idle state 4
        pub type OIS4_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - Capture/compare preloaded control
            #[inline(always)]
            pub fn ccpc(&self) -> CCPC_R {
                CCPC_R::new((self.bits & 1) != 0)
            }
            ///Bit 2 - Capture/compare control update selection
            #[inline(always)]
            pub fn ccus(&self) -> CCUS_R {
                CCUS_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - Capture/compare DMA selection
            #[inline(always)]
            pub fn ccds(&self) -> CCDS_R {
                CCDS_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bits 4:6 - Master mode selection
            #[inline(always)]
            pub fn mms(&self) -> MMS_R {
                MMS_R::new(((self.bits >> 4) & 7) as u8)
            }
            ///Bit 7 - TI1 selection
            #[inline(always)]
            pub fn ti1s(&self) -> TI1S_R {
                TI1S_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bit 8 - Output Idle state 1
            #[inline(always)]
            pub fn ois1(&self) -> OIS1_R {
                OIS1_R::new(((self.bits >> 8) & 1) != 0)
            }
            ///Bit 9 - Output Idle state 1
            #[inline(always)]
            pub fn ois1n(&self) -> OIS1N_R {
                OIS1N_R::new(((self.bits >> 9) & 1) != 0)
            }
            ///Bit 10 - Output Idle state 2
            #[inline(always)]
            pub fn ois2(&self) -> OIS2_R {
                OIS2_R::new(((self.bits >> 10) & 1) != 0)
            }
            ///Bit 11 - Output Idle state 2
            #[inline(always)]
            pub fn ois2n(&self) -> OIS2N_R {
                OIS2N_R::new(((self.bits >> 11) & 1) != 0)
            }
            ///Bit 12 - Output Idle state 3
            #[inline(always)]
            pub fn ois3(&self) -> OIS3_R {
                OIS3_R::new(((self.bits >> 12) & 1) != 0)
            }
            ///Bit 13 - Output Idle state 3
            #[inline(always)]
            pub fn ois3n(&self) -> OIS3N_R {
                OIS3N_R::new(((self.bits >> 13) & 1) != 0)
            }
            ///Bit 14 - Output Idle state 4
            #[inline(always)]
            pub fn ois4(&self) -> OIS4_R {
                OIS4_R::new(((self.bits >> 14) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - Capture/compare preloaded control
            #[inline(always)]
            #[must_use]
            pub fn ccpc(&mut self) -> CCPC_W<CTLR2_SPEC> {
                CCPC_W::new(self, 0)
            }
            ///Bit 2 - Capture/compare control update selection
            #[inline(always)]
            #[must_use]
            pub fn ccus(&mut self) -> CCUS_W<CTLR2_SPEC> {
                CCUS_W::new(self, 2)
            }
            ///Bit 3 - Capture/compare DMA selection
            #[inline(always)]
            #[must_use]
            pub fn ccds(&mut self) -> CCDS_W<CTLR2_SPEC> {
                CCDS_W::new(self, 3)
            }
            ///Bits 4:6 - Master mode selection
            #[inline(always)]
            #[must_use]
            pub fn mms(&mut self) -> MMS_W<CTLR2_SPEC> {
                MMS_W::new(self, 4)
            }
            ///Bit 7 - TI1 selection
            #[inline(always)]
            #[must_use]
            pub fn ti1s(&mut self) -> TI1S_W<CTLR2_SPEC> {
                TI1S_W::new(self, 7)
            }
            ///Bit 8 - Output Idle state 1
            #[inline(always)]
            #[must_use]
            pub fn ois1(&mut self) -> OIS1_W<CTLR2_SPEC> {
                OIS1_W::new(self, 8)
            }
            ///Bit 9 - Output Idle state 1
            #[inline(always)]
            #[must_use]
            pub fn ois1n(&mut self) -> OIS1N_W<CTLR2_SPEC> {
                OIS1N_W::new(self, 9)
            }
            ///Bit 10 - Output Idle state 2
            #[inline(always)]
            #[must_use]
            pub fn ois2(&mut self) -> OIS2_W<CTLR2_SPEC> {
                OIS2_W::new(self, 10)
            }
            ///Bit 11 - Output Idle state 2
            #[inline(always)]
            #[must_use]
            pub fn ois2n(&mut self) -> OIS2N_W<CTLR2_SPEC> {
                OIS2N_W::new(self, 11)
            }
            ///Bit 12 - Output Idle state 3
            #[inline(always)]
            #[must_use]
            pub fn ois3(&mut self) -> OIS3_W<CTLR2_SPEC> {
                OIS3_W::new(self, 12)
            }
            ///Bit 13 - Output Idle state 3
            #[inline(always)]
            #[must_use]
            pub fn ois3n(&mut self) -> OIS3N_W<CTLR2_SPEC> {
                OIS3N_W::new(self, 13)
            }
            ///Bit 14 - Output Idle state 4
            #[inline(always)]
            #[must_use]
            pub fn ois4(&mut self) -> OIS4_W<CTLR2_SPEC> {
                OIS4_W::new(self, 14)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///control register 2
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`ctlr2::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ctlr2::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct CTLR2_SPEC;
        impl crate::RegisterSpec for CTLR2_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`ctlr2::R`](R) reader structure
        impl crate::Readable for CTLR2_SPEC {}
        ///`write(|w| ..)` method takes [`ctlr2::W`](W) writer structure
        impl crate::Writable for CTLR2_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets CTLR2 to value 0
        impl crate::Resettable for CTLR2_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///SMCFGR (rw) register accessor: slave mode control register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`smcfgr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`smcfgr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@smcfgr`]
    ///module
    pub type SMCFGR = crate::Reg<smcfgr::SMCFGR_SPEC>;
    ///slave mode control register
    pub mod smcfgr {
        ///Register `SMCFGR` reader
        pub type R = crate::R<SMCFGR_SPEC>;
        ///Register `SMCFGR` writer
        pub type W = crate::W<SMCFGR_SPEC>;
        ///Field `SMS` reader - Slave mode selection
        pub type SMS_R = crate::FieldReader;
        ///Field `SMS` writer - Slave mode selection
        pub type SMS_W<'a, REG> = crate::FieldWriter<'a, REG, 3>;
        ///Field `TS` reader - Trigger selection
        pub type TS_R = crate::FieldReader;
        ///Field `TS` writer - Trigger selection
        pub type TS_W<'a, REG> = crate::FieldWriter<'a, REG, 3>;
        ///Field `MSM` reader - Master/Slave mode
        pub type MSM_R = crate::BitReader;
        ///Field `MSM` writer - Master/Slave mode
        pub type MSM_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `ETF` reader - External trigger filter
        pub type ETF_R = crate::FieldReader;
        ///Field `ETF` writer - External trigger filter
        pub type ETF_W<'a, REG> = crate::FieldWriter<'a, REG, 4>;
        ///Field `ETPS` reader - External trigger prescaler
        pub type ETPS_R = crate::FieldReader;
        ///Field `ETPS` writer - External trigger prescaler
        pub type ETPS_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `ECE` reader - External clock enable
        pub type ECE_R = crate::BitReader;
        ///Field `ECE` writer - External clock enable
        pub type ECE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `ETP` reader - External trigger polarity
        pub type ETP_R = crate::BitReader;
        ///Field `ETP` writer - External trigger polarity
        pub type ETP_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bits 0:2 - Slave mode selection
            #[inline(always)]
            pub fn sms(&self) -> SMS_R {
                SMS_R::new((self.bits & 7) as u8)
            }
            ///Bits 4:6 - Trigger selection
            #[inline(always)]
            pub fn ts(&self) -> TS_R {
                TS_R::new(((self.bits >> 4) & 7) as u8)
            }
            ///Bit 7 - Master/Slave mode
            #[inline(always)]
            pub fn msm(&self) -> MSM_R {
                MSM_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bits 8:11 - External trigger filter
            #[inline(always)]
            pub fn etf(&self) -> ETF_R {
                ETF_R::new(((self.bits >> 8) & 0x0f) as u8)
            }
            ///Bits 12:13 - External trigger prescaler
            #[inline(always)]
            pub fn etps(&self) -> ETPS_R {
                ETPS_R::new(((self.bits >> 12) & 3) as u8)
            }
            ///Bit 14 - External clock enable
            #[inline(always)]
            pub fn ece(&self) -> ECE_R {
                ECE_R::new(((self.bits >> 14) & 1) != 0)
            }
            ///Bit 15 - External trigger polarity
            #[inline(always)]
            pub fn etp(&self) -> ETP_R {
                ETP_R::new(((self.bits >> 15) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:2 - Slave mode selection
            #[inline(always)]
            #[must_use]
            pub fn sms(&mut self) -> SMS_W<SMCFGR_SPEC> {
                SMS_W::new(self, 0)
            }
            ///Bits 4:6 - Trigger selection
            #[inline(always)]
            #[must_use]
            pub fn ts(&mut self) -> TS_W<SMCFGR_SPEC> {
                TS_W::new(self, 4)
            }
            ///Bit 7 - Master/Slave mode
            #[inline(always)]
            #[must_use]
            pub fn msm(&mut self) -> MSM_W<SMCFGR_SPEC> {
                MSM_W::new(self, 7)
            }
            ///Bits 8:11 - External trigger filter
            #[inline(always)]
            #[must_use]
            pub fn etf(&mut self) -> ETF_W<SMCFGR_SPEC> {
                ETF_W::new(self, 8)
            }
            ///Bits 12:13 - External trigger prescaler
            #[inline(always)]
            #[must_use]
            pub fn etps(&mut self) -> ETPS_W<SMCFGR_SPEC> {
                ETPS_W::new(self, 12)
            }
            ///Bit 14 - External clock enable
            #[inline(always)]
            #[must_use]
            pub fn ece(&mut self) -> ECE_W<SMCFGR_SPEC> {
                ECE_W::new(self, 14)
            }
            ///Bit 15 - External trigger polarity
            #[inline(always)]
            #[must_use]
            pub fn etp(&mut self) -> ETP_W<SMCFGR_SPEC> {
                ETP_W::new(self, 15)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///slave mode control register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`smcfgr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`smcfgr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct SMCFGR_SPEC;
        impl crate::RegisterSpec for SMCFGR_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`smcfgr::R`](R) reader structure
        impl crate::Readable for SMCFGR_SPEC {}
        ///`write(|w| ..)` method takes [`smcfgr::W`](W) writer structure
        impl crate::Writable for SMCFGR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets SMCFGR to value 0
        impl crate::Resettable for SMCFGR_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///DMAINTENR (rw) register accessor: DMA/Interrupt enable register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`dmaintenr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dmaintenr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@dmaintenr`]
    ///module
    pub type DMAINTENR = crate::Reg<dmaintenr::DMAINTENR_SPEC>;
    ///DMA/Interrupt enable register
    pub mod dmaintenr {
        ///Register `DMAINTENR` reader
        pub type R = crate::R<DMAINTENR_SPEC>;
        ///Register `DMAINTENR` writer
        pub type W = crate::W<DMAINTENR_SPEC>;
        ///Field `UIE` reader - Update interrupt enable
        pub type UIE_R = crate::BitReader;
        ///Field `UIE` writer - Update interrupt enable
        pub type UIE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CC1IE` reader - Capture/Compare 1 interrupt enable
        pub type CC1IE_R = crate::BitReader;
        ///Field `CC1IE` writer - Capture/Compare 1 interrupt enable
        pub type CC1IE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CC2IE` reader - Capture/Compare 2 interrupt enable
        pub type CC2IE_R = crate::BitReader;
        ///Field `CC2IE` writer - Capture/Compare 2 interrupt enable
        pub type CC2IE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CC3IE` reader - Capture/Compare 3 interrupt enable
        pub type CC3IE_R = crate::BitReader;
        ///Field `CC3IE` writer - Capture/Compare 3 interrupt enable
        pub type CC3IE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CC4IE` reader - Capture/Compare 4 interrupt enable
        pub type CC4IE_R = crate::BitReader;
        ///Field `CC4IE` writer - Capture/Compare 4 interrupt enable
        pub type CC4IE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `COMIE` reader - COM interrupt enable
        pub type COMIE_R = crate::BitReader;
        ///Field `COMIE` writer - COM interrupt enable
        pub type COMIE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TIE` reader - Trigger interrupt enable
        pub type TIE_R = crate::BitReader;
        ///Field `TIE` writer - Trigger interrupt enable
        pub type TIE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `BIE` reader - Break interrupt enable
        pub type BIE_R = crate::BitReader;
        ///Field `BIE` writer - Break interrupt enable
        pub type BIE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UDE` reader - Update DMA request enable
        pub type UDE_R = crate::BitReader;
        ///Field `UDE` writer - Update DMA request enable
        pub type UDE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CC1DE` reader - Capture/Compare 1 DMA request enable
        pub type CC1DE_R = crate::BitReader;
        ///Field `CC1DE` writer - Capture/Compare 1 DMA request enable
        pub type CC1DE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CC2DE` reader - Capture/Compare 2 DMA request enable
        pub type CC2DE_R = crate::BitReader;
        ///Field `CC2DE` writer - Capture/Compare 2 DMA request enable
        pub type CC2DE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CC3DE` reader - Capture/Compare 3 DMA request enable
        pub type CC3DE_R = crate::BitReader;
        ///Field `CC3DE` writer - Capture/Compare 3 DMA request enable
        pub type CC3DE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CC4DE` reader - Capture/Compare 4 DMA request enable
        pub type CC4DE_R = crate::BitReader;
        ///Field `CC4DE` writer - Capture/Compare 4 DMA request enable
        pub type CC4DE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `COMDE` reader - COM DMA request enable
        pub type COMDE_R = crate::BitReader;
        ///Field `COMDE` writer - COM DMA request enable
        pub type COMDE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TDE` reader - Trigger DMA request enable
        pub type TDE_R = crate::BitReader;
        ///Field `TDE` writer - Trigger DMA request enable
        pub type TDE_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - Update interrupt enable
            #[inline(always)]
            pub fn uie(&self) -> UIE_R {
                UIE_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Capture/Compare 1 interrupt enable
            #[inline(always)]
            pub fn cc1ie(&self) -> CC1IE_R {
                CC1IE_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - Capture/Compare 2 interrupt enable
            #[inline(always)]
            pub fn cc2ie(&self) -> CC2IE_R {
                CC2IE_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - Capture/Compare 3 interrupt enable
            #[inline(always)]
            pub fn cc3ie(&self) -> CC3IE_R {
                CC3IE_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - Capture/Compare 4 interrupt enable
            #[inline(always)]
            pub fn cc4ie(&self) -> CC4IE_R {
                CC4IE_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - COM interrupt enable
            #[inline(always)]
            pub fn comie(&self) -> COMIE_R {
                COMIE_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - Trigger interrupt enable
            #[inline(always)]
            pub fn tie(&self) -> TIE_R {
                TIE_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - Break interrupt enable
            #[inline(always)]
            pub fn bie(&self) -> BIE_R {
                BIE_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bit 8 - Update DMA request enable
            #[inline(always)]
            pub fn ude(&self) -> UDE_R {
                UDE_R::new(((self.bits >> 8) & 1) != 0)
            }
            ///Bit 9 - Capture/Compare 1 DMA request enable
            #[inline(always)]
            pub fn cc1de(&self) -> CC1DE_R {
                CC1DE_R::new(((self.bits >> 9) & 1) != 0)
            }
            ///Bit 10 - Capture/Compare 2 DMA request enable
            #[inline(always)]
            pub fn cc2de(&self) -> CC2DE_R {
                CC2DE_R::new(((self.bits >> 10) & 1) != 0)
            }
            ///Bit 11 - Capture/Compare 3 DMA request enable
            #[inline(always)]
            pub fn cc3de(&self) -> CC3DE_R {
                CC3DE_R::new(((self.bits >> 11) & 1) != 0)
            }
            ///Bit 12 - Capture/Compare 4 DMA request enable
            #[inline(always)]
            pub fn cc4de(&self) -> CC4DE_R {
                CC4DE_R::new(((self.bits >> 12) & 1) != 0)
            }
            ///Bit 13 - COM DMA request enable
            #[inline(always)]
            pub fn comde(&self) -> COMDE_R {
                COMDE_R::new(((self.bits >> 13) & 1) != 0)
            }
            ///Bit 14 - Trigger DMA request enable
            #[inline(always)]
            pub fn tde(&self) -> TDE_R {
                TDE_R::new(((self.bits >> 14) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - Update interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn uie(&mut self) -> UIE_W<DMAINTENR_SPEC> {
                UIE_W::new(self, 0)
            }
            ///Bit 1 - Capture/Compare 1 interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn cc1ie(&mut self) -> CC1IE_W<DMAINTENR_SPEC> {
                CC1IE_W::new(self, 1)
            }
            ///Bit 2 - Capture/Compare 2 interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn cc2ie(&mut self) -> CC2IE_W<DMAINTENR_SPEC> {
                CC2IE_W::new(self, 2)
            }
            ///Bit 3 - Capture/Compare 3 interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn cc3ie(&mut self) -> CC3IE_W<DMAINTENR_SPEC> {
                CC3IE_W::new(self, 3)
            }
            ///Bit 4 - Capture/Compare 4 interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn cc4ie(&mut self) -> CC4IE_W<DMAINTENR_SPEC> {
                CC4IE_W::new(self, 4)
            }
            ///Bit 5 - COM interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn comie(&mut self) -> COMIE_W<DMAINTENR_SPEC> {
                COMIE_W::new(self, 5)
            }
            ///Bit 6 - Trigger interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn tie(&mut self) -> TIE_W<DMAINTENR_SPEC> {
                TIE_W::new(self, 6)
            }
            ///Bit 7 - Break interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn bie(&mut self) -> BIE_W<DMAINTENR_SPEC> {
                BIE_W::new(self, 7)
            }
            ///Bit 8 - Update DMA request enable
            #[inline(always)]
            #[must_use]
            pub fn ude(&mut self) -> UDE_W<DMAINTENR_SPEC> {
                UDE_W::new(self, 8)
            }
            ///Bit 9 - Capture/Compare 1 DMA request enable
            #[inline(always)]
            #[must_use]
            pub fn cc1de(&mut self) -> CC1DE_W<DMAINTENR_SPEC> {
                CC1DE_W::new(self, 9)
            }
            ///Bit 10 - Capture/Compare 2 DMA request enable
            #[inline(always)]
            #[must_use]
            pub fn cc2de(&mut self) -> CC2DE_W<DMAINTENR_SPEC> {
                CC2DE_W::new(self, 10)
            }
            ///Bit 11 - Capture/Compare 3 DMA request enable
            #[inline(always)]
            #[must_use]
            pub fn cc3de(&mut self) -> CC3DE_W<DMAINTENR_SPEC> {
                CC3DE_W::new(self, 11)
            }
            ///Bit 12 - Capture/Compare 4 DMA request enable
            #[inline(always)]
            #[must_use]
            pub fn cc4de(&mut self) -> CC4DE_W<DMAINTENR_SPEC> {
                CC4DE_W::new(self, 12)
            }
            ///Bit 13 - COM DMA request enable
            #[inline(always)]
            #[must_use]
            pub fn comde(&mut self) -> COMDE_W<DMAINTENR_SPEC> {
                COMDE_W::new(self, 13)
            }
            ///Bit 14 - Trigger DMA request enable
            #[inline(always)]
            #[must_use]
            pub fn tde(&mut self) -> TDE_W<DMAINTENR_SPEC> {
                TDE_W::new(self, 14)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///DMA/Interrupt enable register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`dmaintenr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dmaintenr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct DMAINTENR_SPEC;
        impl crate::RegisterSpec for DMAINTENR_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`dmaintenr::R`](R) reader structure
        impl crate::Readable for DMAINTENR_SPEC {}
        ///`write(|w| ..)` method takes [`dmaintenr::W`](W) writer structure
        impl crate::Writable for DMAINTENR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets DMAINTENR to value 0
        impl crate::Resettable for DMAINTENR_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///INTFR (rw) register accessor: status register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`intfr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`intfr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@intfr`]
    ///module
    pub type INTFR = crate::Reg<intfr::INTFR_SPEC>;
    ///status register
    pub mod intfr {
        ///Register `INTFR` reader
        pub type R = crate::R<INTFR_SPEC>;
        ///Register `INTFR` writer
        pub type W = crate::W<INTFR_SPEC>;
        ///Field `UIF` reader - Update interrupt flag
        pub type UIF_R = crate::BitReader;
        ///Field `UIF` writer - Update interrupt flag
        pub type UIF_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CC1IF` reader - Capture/compare 1 interrupt flag
        pub type CC1IF_R = crate::BitReader;
        ///Field `CC1IF` writer - Capture/compare 1 interrupt flag
        pub type CC1IF_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CC2IF` reader - Capture/Compare 2 interrupt flag
        pub type CC2IF_R = crate::BitReader;
        ///Field `CC2IF` writer - Capture/Compare 2 interrupt flag
        pub type CC2IF_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CC3IF` reader - Capture/Compare 3 interrupt flag
        pub type CC3IF_R = crate::BitReader;
        ///Field `CC3IF` writer - Capture/Compare 3 interrupt flag
        pub type CC3IF_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CC4IF` reader - Capture/Compare 4 interrupt flag
        pub type CC4IF_R = crate::BitReader;
        ///Field `CC4IF` writer - Capture/Compare 4 interrupt flag
        pub type CC4IF_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `COMIF` reader - COM interrupt flag
        pub type COMIF_R = crate::BitReader;
        ///Field `COMIF` writer - COM interrupt flag
        pub type COMIF_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TIF` reader - Trigger interrupt flag
        pub type TIF_R = crate::BitReader;
        ///Field `TIF` writer - Trigger interrupt flag
        pub type TIF_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `BIF` reader - Break interrupt flag
        pub type BIF_R = crate::BitReader;
        ///Field `BIF` writer - Break interrupt flag
        pub type BIF_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CC1OF` reader - Capture/Compare 1 overcapture flag
        pub type CC1OF_R = crate::BitReader;
        ///Field `CC1OF` writer - Capture/Compare 1 overcapture flag
        pub type CC1OF_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CC2OF` reader - Capture/compare 2 overcapture flag
        pub type CC2OF_R = crate::BitReader;
        ///Field `CC2OF` writer - Capture/compare 2 overcapture flag
        pub type CC2OF_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CC3OF` reader - Capture/Compare 3 overcapture flag
        pub type CC3OF_R = crate::BitReader;
        ///Field `CC3OF` writer - Capture/Compare 3 overcapture flag
        pub type CC3OF_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CC4OF` reader - Capture/Compare 4 overcapture flag
        pub type CC4OF_R = crate::BitReader;
        ///Field `CC4OF` writer - Capture/Compare 4 overcapture flag
        pub type CC4OF_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - Update interrupt flag
            #[inline(always)]
            pub fn uif(&self) -> UIF_R {
                UIF_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Capture/compare 1 interrupt flag
            #[inline(always)]
            pub fn cc1if(&self) -> CC1IF_R {
                CC1IF_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - Capture/Compare 2 interrupt flag
            #[inline(always)]
            pub fn cc2if(&self) -> CC2IF_R {
                CC2IF_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - Capture/Compare 3 interrupt flag
            #[inline(always)]
            pub fn cc3if(&self) -> CC3IF_R {
                CC3IF_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - Capture/Compare 4 interrupt flag
            #[inline(always)]
            pub fn cc4if(&self) -> CC4IF_R {
                CC4IF_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - COM interrupt flag
            #[inline(always)]
            pub fn comif(&self) -> COMIF_R {
                COMIF_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - Trigger interrupt flag
            #[inline(always)]
            pub fn tif(&self) -> TIF_R {
                TIF_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - Break interrupt flag
            #[inline(always)]
            pub fn bif(&self) -> BIF_R {
                BIF_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bit 9 - Capture/Compare 1 overcapture flag
            #[inline(always)]
            pub fn cc1of(&self) -> CC1OF_R {
                CC1OF_R::new(((self.bits >> 9) & 1) != 0)
            }
            ///Bit 10 - Capture/compare 2 overcapture flag
            #[inline(always)]
            pub fn cc2of(&self) -> CC2OF_R {
                CC2OF_R::new(((self.bits >> 10) & 1) != 0)
            }
            ///Bit 11 - Capture/Compare 3 overcapture flag
            #[inline(always)]
            pub fn cc3of(&self) -> CC3OF_R {
                CC3OF_R::new(((self.bits >> 11) & 1) != 0)
            }
            ///Bit 12 - Capture/Compare 4 overcapture flag
            #[inline(always)]
            pub fn cc4of(&self) -> CC4OF_R {
                CC4OF_R::new(((self.bits >> 12) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - Update interrupt flag
            #[inline(always)]
            #[must_use]
            pub fn uif(&mut self) -> UIF_W<INTFR_SPEC> {
                UIF_W::new(self, 0)
            }
            ///Bit 1 - Capture/compare 1 interrupt flag
            #[inline(always)]
            #[must_use]
            pub fn cc1if(&mut self) -> CC1IF_W<INTFR_SPEC> {
                CC1IF_W::new(self, 1)
            }
            ///Bit 2 - Capture/Compare 2 interrupt flag
            #[inline(always)]
            #[must_use]
            pub fn cc2if(&mut self) -> CC2IF_W<INTFR_SPEC> {
                CC2IF_W::new(self, 2)
            }
            ///Bit 3 - Capture/Compare 3 interrupt flag
            #[inline(always)]
            #[must_use]
            pub fn cc3if(&mut self) -> CC3IF_W<INTFR_SPEC> {
                CC3IF_W::new(self, 3)
            }
            ///Bit 4 - Capture/Compare 4 interrupt flag
            #[inline(always)]
            #[must_use]
            pub fn cc4if(&mut self) -> CC4IF_W<INTFR_SPEC> {
                CC4IF_W::new(self, 4)
            }
            ///Bit 5 - COM interrupt flag
            #[inline(always)]
            #[must_use]
            pub fn comif(&mut self) -> COMIF_W<INTFR_SPEC> {
                COMIF_W::new(self, 5)
            }
            ///Bit 6 - Trigger interrupt flag
            #[inline(always)]
            #[must_use]
            pub fn tif(&mut self) -> TIF_W<INTFR_SPEC> {
                TIF_W::new(self, 6)
            }
            ///Bit 7 - Break interrupt flag
            #[inline(always)]
            #[must_use]
            pub fn bif(&mut self) -> BIF_W<INTFR_SPEC> {
                BIF_W::new(self, 7)
            }
            ///Bit 9 - Capture/Compare 1 overcapture flag
            #[inline(always)]
            #[must_use]
            pub fn cc1of(&mut self) -> CC1OF_W<INTFR_SPEC> {
                CC1OF_W::new(self, 9)
            }
            ///Bit 10 - Capture/compare 2 overcapture flag
            #[inline(always)]
            #[must_use]
            pub fn cc2of(&mut self) -> CC2OF_W<INTFR_SPEC> {
                CC2OF_W::new(self, 10)
            }
            ///Bit 11 - Capture/Compare 3 overcapture flag
            #[inline(always)]
            #[must_use]
            pub fn cc3of(&mut self) -> CC3OF_W<INTFR_SPEC> {
                CC3OF_W::new(self, 11)
            }
            ///Bit 12 - Capture/Compare 4 overcapture flag
            #[inline(always)]
            #[must_use]
            pub fn cc4of(&mut self) -> CC4OF_W<INTFR_SPEC> {
                CC4OF_W::new(self, 12)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///status register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`intfr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`intfr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct INTFR_SPEC;
        impl crate::RegisterSpec for INTFR_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`intfr::R`](R) reader structure
        impl crate::Readable for INTFR_SPEC {}
        ///`write(|w| ..)` method takes [`intfr::W`](W) writer structure
        impl crate::Writable for INTFR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets INTFR to value 0
        impl crate::Resettable for INTFR_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///SWEVGR (w) register accessor: event generation register
    ///
    ///You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`swevgr::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@swevgr`]
    ///module
    pub type SWEVGR = crate::Reg<swevgr::SWEVGR_SPEC>;
    ///event generation register
    pub mod swevgr {
        ///Register `SWEVGR` writer
        pub type W = crate::W<SWEVGR_SPEC>;
        ///Field `UG` writer - Update generation
        pub type UG_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CC1G` writer - Capture/compare 1 generation
        pub type CC1G_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CC2G` writer - Capture/compare 2 generation
        pub type CC2G_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CC3G` writer - Capture/compare 3 generation
        pub type CC3G_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CC4G` writer - Capture/compare 4 generation
        pub type CC4G_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `COMG` writer - Capture/Compare control update generation
        pub type COMG_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TG` writer - Trigger generation
        pub type TG_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `BG` writer - Break generation
        pub type BG_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl W {
            ///Bit 0 - Update generation
            #[inline(always)]
            #[must_use]
            pub fn ug(&mut self) -> UG_W<SWEVGR_SPEC> {
                UG_W::new(self, 0)
            }
            ///Bit 1 - Capture/compare 1 generation
            #[inline(always)]
            #[must_use]
            pub fn cc1g(&mut self) -> CC1G_W<SWEVGR_SPEC> {
                CC1G_W::new(self, 1)
            }
            ///Bit 2 - Capture/compare 2 generation
            #[inline(always)]
            #[must_use]
            pub fn cc2g(&mut self) -> CC2G_W<SWEVGR_SPEC> {
                CC2G_W::new(self, 2)
            }
            ///Bit 3 - Capture/compare 3 generation
            #[inline(always)]
            #[must_use]
            pub fn cc3g(&mut self) -> CC3G_W<SWEVGR_SPEC> {
                CC3G_W::new(self, 3)
            }
            ///Bit 4 - Capture/compare 4 generation
            #[inline(always)]
            #[must_use]
            pub fn cc4g(&mut self) -> CC4G_W<SWEVGR_SPEC> {
                CC4G_W::new(self, 4)
            }
            ///Bit 5 - Capture/Compare control update generation
            #[inline(always)]
            #[must_use]
            pub fn comg(&mut self) -> COMG_W<SWEVGR_SPEC> {
                COMG_W::new(self, 5)
            }
            ///Bit 6 - Trigger generation
            #[inline(always)]
            #[must_use]
            pub fn tg(&mut self) -> TG_W<SWEVGR_SPEC> {
                TG_W::new(self, 6)
            }
            ///Bit 7 - Break generation
            #[inline(always)]
            #[must_use]
            pub fn bg(&mut self) -> BG_W<SWEVGR_SPEC> {
                BG_W::new(self, 7)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///event generation register
        ///
        ///You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`swevgr::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct SWEVGR_SPEC;
        impl crate::RegisterSpec for SWEVGR_SPEC {
            type Ux = u16;
        }
        ///`write(|w| ..)` method takes [`swevgr::W`](W) writer structure
        impl crate::Writable for SWEVGR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets SWEVGR to value 0
        impl crate::Resettable for SWEVGR_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///CHCTLR1_Output (rw) register accessor: capture/compare mode register (output mode)
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`chctlr1_output::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`chctlr1_output::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@chctlr1_output`]
    ///module
    pub type CHCTLR1_OUTPUT = crate::Reg<chctlr1_output::CHCTLR1_OUTPUT_SPEC>;
    ///capture/compare mode register (output mode)
    pub mod chctlr1_output {
        ///Register `CHCTLR1_Output` reader
        pub type R = crate::R<CHCTLR1_OUTPUT_SPEC>;
        ///Register `CHCTLR1_Output` writer
        pub type W = crate::W<CHCTLR1_OUTPUT_SPEC>;
        ///Field `CC1S` reader - Capture/Compare 1 selection
        pub type CC1S_R = crate::FieldReader;
        ///Field `CC1S` writer - Capture/Compare 1 selection
        pub type CC1S_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `OC1FE` reader - Output Compare 1 fast enable
        pub type OC1FE_R = crate::BitReader;
        ///Field `OC1FE` writer - Output Compare 1 fast enable
        pub type OC1FE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `OC1PE` reader - Output Compare 1 preload enable
        pub type OC1PE_R = crate::BitReader;
        ///Field `OC1PE` writer - Output Compare 1 preload enable
        pub type OC1PE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `OC1M` reader - Output Compare 1 mode
        pub type OC1M_R = crate::FieldReader;
        ///Field `OC1M` writer - Output Compare 1 mode
        pub type OC1M_W<'a, REG> = crate::FieldWriter<'a, REG, 3>;
        ///Field `OC1CE` reader - Output Compare 1 clear enable
        pub type OC1CE_R = crate::BitReader;
        ///Field `OC1CE` writer - Output Compare 1 clear enable
        pub type OC1CE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CC2S` reader - Capture/Compare 2 selection
        pub type CC2S_R = crate::FieldReader;
        ///Field `CC2S` writer - Capture/Compare 2 selection
        pub type CC2S_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `OC2FE` reader - Output Compare 2 fast enable
        pub type OC2FE_R = crate::BitReader;
        ///Field `OC2FE` writer - Output Compare 2 fast enable
        pub type OC2FE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `OC2PE` reader - Output Compare 2 preload enable
        pub type OC2PE_R = crate::BitReader;
        ///Field `OC2PE` writer - Output Compare 2 preload enable
        pub type OC2PE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `OC2M` reader - Output Compare 2 mode
        pub type OC2M_R = crate::FieldReader;
        ///Field `OC2M` writer - Output Compare 2 mode
        pub type OC2M_W<'a, REG> = crate::FieldWriter<'a, REG, 3>;
        ///Field `OC2CE` reader - Output Compare 2 clear enable
        pub type OC2CE_R = crate::BitReader;
        ///Field `OC2CE` writer - Output Compare 2 clear enable
        pub type OC2CE_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bits 0:1 - Capture/Compare 1 selection
            #[inline(always)]
            pub fn cc1s(&self) -> CC1S_R {
                CC1S_R::new((self.bits & 3) as u8)
            }
            ///Bit 2 - Output Compare 1 fast enable
            #[inline(always)]
            pub fn oc1fe(&self) -> OC1FE_R {
                OC1FE_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - Output Compare 1 preload enable
            #[inline(always)]
            pub fn oc1pe(&self) -> OC1PE_R {
                OC1PE_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bits 4:6 - Output Compare 1 mode
            #[inline(always)]
            pub fn oc1m(&self) -> OC1M_R {
                OC1M_R::new(((self.bits >> 4) & 7) as u8)
            }
            ///Bit 7 - Output Compare 1 clear enable
            #[inline(always)]
            pub fn oc1ce(&self) -> OC1CE_R {
                OC1CE_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bits 8:9 - Capture/Compare 2 selection
            #[inline(always)]
            pub fn cc2s(&self) -> CC2S_R {
                CC2S_R::new(((self.bits >> 8) & 3) as u8)
            }
            ///Bit 10 - Output Compare 2 fast enable
            #[inline(always)]
            pub fn oc2fe(&self) -> OC2FE_R {
                OC2FE_R::new(((self.bits >> 10) & 1) != 0)
            }
            ///Bit 11 - Output Compare 2 preload enable
            #[inline(always)]
            pub fn oc2pe(&self) -> OC2PE_R {
                OC2PE_R::new(((self.bits >> 11) & 1) != 0)
            }
            ///Bits 12:14 - Output Compare 2 mode
            #[inline(always)]
            pub fn oc2m(&self) -> OC2M_R {
                OC2M_R::new(((self.bits >> 12) & 7) as u8)
            }
            ///Bit 15 - Output Compare 2 clear enable
            #[inline(always)]
            pub fn oc2ce(&self) -> OC2CE_R {
                OC2CE_R::new(((self.bits >> 15) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:1 - Capture/Compare 1 selection
            #[inline(always)]
            #[must_use]
            pub fn cc1s(&mut self) -> CC1S_W<CHCTLR1_OUTPUT_SPEC> {
                CC1S_W::new(self, 0)
            }
            ///Bit 2 - Output Compare 1 fast enable
            #[inline(always)]
            #[must_use]
            pub fn oc1fe(&mut self) -> OC1FE_W<CHCTLR1_OUTPUT_SPEC> {
                OC1FE_W::new(self, 2)
            }
            ///Bit 3 - Output Compare 1 preload enable
            #[inline(always)]
            #[must_use]
            pub fn oc1pe(&mut self) -> OC1PE_W<CHCTLR1_OUTPUT_SPEC> {
                OC1PE_W::new(self, 3)
            }
            ///Bits 4:6 - Output Compare 1 mode
            #[inline(always)]
            #[must_use]
            pub fn oc1m(&mut self) -> OC1M_W<CHCTLR1_OUTPUT_SPEC> {
                OC1M_W::new(self, 4)
            }
            ///Bit 7 - Output Compare 1 clear enable
            #[inline(always)]
            #[must_use]
            pub fn oc1ce(&mut self) -> OC1CE_W<CHCTLR1_OUTPUT_SPEC> {
                OC1CE_W::new(self, 7)
            }
            ///Bits 8:9 - Capture/Compare 2 selection
            #[inline(always)]
            #[must_use]
            pub fn cc2s(&mut self) -> CC2S_W<CHCTLR1_OUTPUT_SPEC> {
                CC2S_W::new(self, 8)
            }
            ///Bit 10 - Output Compare 2 fast enable
            #[inline(always)]
            #[must_use]
            pub fn oc2fe(&mut self) -> OC2FE_W<CHCTLR1_OUTPUT_SPEC> {
                OC2FE_W::new(self, 10)
            }
            ///Bit 11 - Output Compare 2 preload enable
            #[inline(always)]
            #[must_use]
            pub fn oc2pe(&mut self) -> OC2PE_W<CHCTLR1_OUTPUT_SPEC> {
                OC2PE_W::new(self, 11)
            }
            ///Bits 12:14 - Output Compare 2 mode
            #[inline(always)]
            #[must_use]
            pub fn oc2m(&mut self) -> OC2M_W<CHCTLR1_OUTPUT_SPEC> {
                OC2M_W::new(self, 12)
            }
            ///Bit 15 - Output Compare 2 clear enable
            #[inline(always)]
            #[must_use]
            pub fn oc2ce(&mut self) -> OC2CE_W<CHCTLR1_OUTPUT_SPEC> {
                OC2CE_W::new(self, 15)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///capture/compare mode register (output mode)
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`chctlr1_output::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`chctlr1_output::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct CHCTLR1_OUTPUT_SPEC;
        impl crate::RegisterSpec for CHCTLR1_OUTPUT_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`chctlr1_output::R`](R) reader structure
        impl crate::Readable for CHCTLR1_OUTPUT_SPEC {}
        ///`write(|w| ..)` method takes [`chctlr1_output::W`](W) writer structure
        impl crate::Writable for CHCTLR1_OUTPUT_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets CHCTLR1_Output to value 0
        impl crate::Resettable for CHCTLR1_OUTPUT_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///CHCTLR1_Input (rw) register accessor: capture/compare mode register 1 (input mode)
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`chctlr1_input::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`chctlr1_input::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@chctlr1_input`]
    ///module
    pub type CHCTLR1_INPUT = crate::Reg<chctlr1_input::CHCTLR1_INPUT_SPEC>;
    ///capture/compare mode register 1 (input mode)
    pub mod chctlr1_input {
        ///Register `CHCTLR1_Input` reader
        pub type R = crate::R<CHCTLR1_INPUT_SPEC>;
        ///Register `CHCTLR1_Input` writer
        pub type W = crate::W<CHCTLR1_INPUT_SPEC>;
        ///Field `CC1S` reader - Capture/Compare 1 selection
        pub type CC1S_R = crate::FieldReader;
        ///Field `CC1S` writer - Capture/Compare 1 selection
        pub type CC1S_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `IC1PSC` reader - Input capture 1 prescaler
        pub type IC1PSC_R = crate::FieldReader;
        ///Field `IC1PSC` writer - Input capture 1 prescaler
        pub type IC1PSC_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `IC1F` reader - Input capture 1 filter
        pub type IC1F_R = crate::FieldReader;
        ///Field `IC1F` writer - Input capture 1 filter
        pub type IC1F_W<'a, REG> = crate::FieldWriter<'a, REG, 4>;
        ///Field `CC2S` reader - Capture/Compare 2 selection
        pub type CC2S_R = crate::FieldReader;
        ///Field `CC2S` writer - Capture/Compare 2 selection
        pub type CC2S_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `IC2PCS` reader - Input capture 2 prescaler
        pub type IC2PCS_R = crate::FieldReader;
        ///Field `IC2PCS` writer - Input capture 2 prescaler
        pub type IC2PCS_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `IC2F` reader - Input capture 2 filter
        pub type IC2F_R = crate::FieldReader;
        ///Field `IC2F` writer - Input capture 2 filter
        pub type IC2F_W<'a, REG> = crate::FieldWriter<'a, REG, 4>;
        impl R {
            ///Bits 0:1 - Capture/Compare 1 selection
            #[inline(always)]
            pub fn cc1s(&self) -> CC1S_R {
                CC1S_R::new((self.bits & 3) as u8)
            }
            ///Bits 2:3 - Input capture 1 prescaler
            #[inline(always)]
            pub fn ic1psc(&self) -> IC1PSC_R {
                IC1PSC_R::new(((self.bits >> 2) & 3) as u8)
            }
            ///Bits 4:7 - Input capture 1 filter
            #[inline(always)]
            pub fn ic1f(&self) -> IC1F_R {
                IC1F_R::new(((self.bits >> 4) & 0x0f) as u8)
            }
            ///Bits 8:9 - Capture/Compare 2 selection
            #[inline(always)]
            pub fn cc2s(&self) -> CC2S_R {
                CC2S_R::new(((self.bits >> 8) & 3) as u8)
            }
            ///Bits 10:11 - Input capture 2 prescaler
            #[inline(always)]
            pub fn ic2pcs(&self) -> IC2PCS_R {
                IC2PCS_R::new(((self.bits >> 10) & 3) as u8)
            }
            ///Bits 12:15 - Input capture 2 filter
            #[inline(always)]
            pub fn ic2f(&self) -> IC2F_R {
                IC2F_R::new(((self.bits >> 12) & 0x0f) as u8)
            }
        }
        impl W {
            ///Bits 0:1 - Capture/Compare 1 selection
            #[inline(always)]
            #[must_use]
            pub fn cc1s(&mut self) -> CC1S_W<CHCTLR1_INPUT_SPEC> {
                CC1S_W::new(self, 0)
            }
            ///Bits 2:3 - Input capture 1 prescaler
            #[inline(always)]
            #[must_use]
            pub fn ic1psc(&mut self) -> IC1PSC_W<CHCTLR1_INPUT_SPEC> {
                IC1PSC_W::new(self, 2)
            }
            ///Bits 4:7 - Input capture 1 filter
            #[inline(always)]
            #[must_use]
            pub fn ic1f(&mut self) -> IC1F_W<CHCTLR1_INPUT_SPEC> {
                IC1F_W::new(self, 4)
            }
            ///Bits 8:9 - Capture/Compare 2 selection
            #[inline(always)]
            #[must_use]
            pub fn cc2s(&mut self) -> CC2S_W<CHCTLR1_INPUT_SPEC> {
                CC2S_W::new(self, 8)
            }
            ///Bits 10:11 - Input capture 2 prescaler
            #[inline(always)]
            #[must_use]
            pub fn ic2pcs(&mut self) -> IC2PCS_W<CHCTLR1_INPUT_SPEC> {
                IC2PCS_W::new(self, 10)
            }
            ///Bits 12:15 - Input capture 2 filter
            #[inline(always)]
            #[must_use]
            pub fn ic2f(&mut self) -> IC2F_W<CHCTLR1_INPUT_SPEC> {
                IC2F_W::new(self, 12)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///capture/compare mode register 1 (input mode)
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`chctlr1_input::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`chctlr1_input::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct CHCTLR1_INPUT_SPEC;
        impl crate::RegisterSpec for CHCTLR1_INPUT_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`chctlr1_input::R`](R) reader structure
        impl crate::Readable for CHCTLR1_INPUT_SPEC {}
        ///`write(|w| ..)` method takes [`chctlr1_input::W`](W) writer structure
        impl crate::Writable for CHCTLR1_INPUT_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets CHCTLR1_Input to value 0
        impl crate::Resettable for CHCTLR1_INPUT_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///CHCTLR2_Output (rw) register accessor: capture/compare mode register (output mode)
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`chctlr2_output::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`chctlr2_output::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@chctlr2_output`]
    ///module
    pub type CHCTLR2_OUTPUT = crate::Reg<chctlr2_output::CHCTLR2_OUTPUT_SPEC>;
    ///capture/compare mode register (output mode)
    pub mod chctlr2_output {
        ///Register `CHCTLR2_Output` reader
        pub type R = crate::R<CHCTLR2_OUTPUT_SPEC>;
        ///Register `CHCTLR2_Output` writer
        pub type W = crate::W<CHCTLR2_OUTPUT_SPEC>;
        ///Field `CC3S` reader - Capture/Compare 3 selection
        pub type CC3S_R = crate::FieldReader;
        ///Field `CC3S` writer - Capture/Compare 3 selection
        pub type CC3S_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `OC3FE` reader - Output compare 3 fast enable
        pub type OC3FE_R = crate::BitReader;
        ///Field `OC3FE` writer - Output compare 3 fast enable
        pub type OC3FE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `OC3PE` reader - Output compare 3 preload enable
        pub type OC3PE_R = crate::BitReader;
        ///Field `OC3PE` writer - Output compare 3 preload enable
        pub type OC3PE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `OC3M` reader - Output compare 3 mode
        pub type OC3M_R = crate::FieldReader;
        ///Field `OC3M` writer - Output compare 3 mode
        pub type OC3M_W<'a, REG> = crate::FieldWriter<'a, REG, 3>;
        ///Field `OC3CE` reader - Output compare 3 clear enable
        pub type OC3CE_R = crate::BitReader;
        ///Field `OC3CE` writer - Output compare 3 clear enable
        pub type OC3CE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CC4S` reader - Capture/Compare 4 selection
        pub type CC4S_R = crate::FieldReader;
        ///Field `CC4S` writer - Capture/Compare 4 selection
        pub type CC4S_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `OC4FE` reader - Output compare 4 fast enable
        pub type OC4FE_R = crate::BitReader;
        ///Field `OC4FE` writer - Output compare 4 fast enable
        pub type OC4FE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `OC4PE` reader - Output compare 4 preload enable
        pub type OC4PE_R = crate::BitReader;
        ///Field `OC4PE` writer - Output compare 4 preload enable
        pub type OC4PE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `OC4M` reader - Output compare 4 mode
        pub type OC4M_R = crate::FieldReader;
        ///Field `OC4M` writer - Output compare 4 mode
        pub type OC4M_W<'a, REG> = crate::FieldWriter<'a, REG, 3>;
        ///Field `OC4CE` reader - Output compare 4 clear enable
        pub type OC4CE_R = crate::BitReader;
        ///Field `OC4CE` writer - Output compare 4 clear enable
        pub type OC4CE_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bits 0:1 - Capture/Compare 3 selection
            #[inline(always)]
            pub fn cc3s(&self) -> CC3S_R {
                CC3S_R::new((self.bits & 3) as u8)
            }
            ///Bit 2 - Output compare 3 fast enable
            #[inline(always)]
            pub fn oc3fe(&self) -> OC3FE_R {
                OC3FE_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - Output compare 3 preload enable
            #[inline(always)]
            pub fn oc3pe(&self) -> OC3PE_R {
                OC3PE_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bits 4:6 - Output compare 3 mode
            #[inline(always)]
            pub fn oc3m(&self) -> OC3M_R {
                OC3M_R::new(((self.bits >> 4) & 7) as u8)
            }
            ///Bit 7 - Output compare 3 clear enable
            #[inline(always)]
            pub fn oc3ce(&self) -> OC3CE_R {
                OC3CE_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bits 8:9 - Capture/Compare 4 selection
            #[inline(always)]
            pub fn cc4s(&self) -> CC4S_R {
                CC4S_R::new(((self.bits >> 8) & 3) as u8)
            }
            ///Bit 10 - Output compare 4 fast enable
            #[inline(always)]
            pub fn oc4fe(&self) -> OC4FE_R {
                OC4FE_R::new(((self.bits >> 10) & 1) != 0)
            }
            ///Bit 11 - Output compare 4 preload enable
            #[inline(always)]
            pub fn oc4pe(&self) -> OC4PE_R {
                OC4PE_R::new(((self.bits >> 11) & 1) != 0)
            }
            ///Bits 12:14 - Output compare 4 mode
            #[inline(always)]
            pub fn oc4m(&self) -> OC4M_R {
                OC4M_R::new(((self.bits >> 12) & 7) as u8)
            }
            ///Bit 15 - Output compare 4 clear enable
            #[inline(always)]
            pub fn oc4ce(&self) -> OC4CE_R {
                OC4CE_R::new(((self.bits >> 15) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:1 - Capture/Compare 3 selection
            #[inline(always)]
            #[must_use]
            pub fn cc3s(&mut self) -> CC3S_W<CHCTLR2_OUTPUT_SPEC> {
                CC3S_W::new(self, 0)
            }
            ///Bit 2 - Output compare 3 fast enable
            #[inline(always)]
            #[must_use]
            pub fn oc3fe(&mut self) -> OC3FE_W<CHCTLR2_OUTPUT_SPEC> {
                OC3FE_W::new(self, 2)
            }
            ///Bit 3 - Output compare 3 preload enable
            #[inline(always)]
            #[must_use]
            pub fn oc3pe(&mut self) -> OC3PE_W<CHCTLR2_OUTPUT_SPEC> {
                OC3PE_W::new(self, 3)
            }
            ///Bits 4:6 - Output compare 3 mode
            #[inline(always)]
            #[must_use]
            pub fn oc3m(&mut self) -> OC3M_W<CHCTLR2_OUTPUT_SPEC> {
                OC3M_W::new(self, 4)
            }
            ///Bit 7 - Output compare 3 clear enable
            #[inline(always)]
            #[must_use]
            pub fn oc3ce(&mut self) -> OC3CE_W<CHCTLR2_OUTPUT_SPEC> {
                OC3CE_W::new(self, 7)
            }
            ///Bits 8:9 - Capture/Compare 4 selection
            #[inline(always)]
            #[must_use]
            pub fn cc4s(&mut self) -> CC4S_W<CHCTLR2_OUTPUT_SPEC> {
                CC4S_W::new(self, 8)
            }
            ///Bit 10 - Output compare 4 fast enable
            #[inline(always)]
            #[must_use]
            pub fn oc4fe(&mut self) -> OC4FE_W<CHCTLR2_OUTPUT_SPEC> {
                OC4FE_W::new(self, 10)
            }
            ///Bit 11 - Output compare 4 preload enable
            #[inline(always)]
            #[must_use]
            pub fn oc4pe(&mut self) -> OC4PE_W<CHCTLR2_OUTPUT_SPEC> {
                OC4PE_W::new(self, 11)
            }
            ///Bits 12:14 - Output compare 4 mode
            #[inline(always)]
            #[must_use]
            pub fn oc4m(&mut self) -> OC4M_W<CHCTLR2_OUTPUT_SPEC> {
                OC4M_W::new(self, 12)
            }
            ///Bit 15 - Output compare 4 clear enable
            #[inline(always)]
            #[must_use]
            pub fn oc4ce(&mut self) -> OC4CE_W<CHCTLR2_OUTPUT_SPEC> {
                OC4CE_W::new(self, 15)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///capture/compare mode register (output mode)
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`chctlr2_output::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`chctlr2_output::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct CHCTLR2_OUTPUT_SPEC;
        impl crate::RegisterSpec for CHCTLR2_OUTPUT_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`chctlr2_output::R`](R) reader structure
        impl crate::Readable for CHCTLR2_OUTPUT_SPEC {}
        ///`write(|w| ..)` method takes [`chctlr2_output::W`](W) writer structure
        impl crate::Writable for CHCTLR2_OUTPUT_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets CHCTLR2_Output to value 0
        impl crate::Resettable for CHCTLR2_OUTPUT_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///CHCTLR2_Input (rw) register accessor: capture/compare mode register 2 (input mode)
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`chctlr2_input::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`chctlr2_input::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@chctlr2_input`]
    ///module
    pub type CHCTLR2_INPUT = crate::Reg<chctlr2_input::CHCTLR2_INPUT_SPEC>;
    ///capture/compare mode register 2 (input mode)
    pub mod chctlr2_input {
        ///Register `CHCTLR2_Input` reader
        pub type R = crate::R<CHCTLR2_INPUT_SPEC>;
        ///Register `CHCTLR2_Input` writer
        pub type W = crate::W<CHCTLR2_INPUT_SPEC>;
        ///Field `CC3S` reader - Capture/compare 3 selection
        pub type CC3S_R = crate::FieldReader;
        ///Field `CC3S` writer - Capture/compare 3 selection
        pub type CC3S_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `IC3PSC` reader - Input capture 3 prescaler
        pub type IC3PSC_R = crate::FieldReader;
        ///Field `IC3PSC` writer - Input capture 3 prescaler
        pub type IC3PSC_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `IC3F` reader - Input capture 3 filter
        pub type IC3F_R = crate::FieldReader;
        ///Field `IC3F` writer - Input capture 3 filter
        pub type IC3F_W<'a, REG> = crate::FieldWriter<'a, REG, 4>;
        ///Field `CC4S` reader - Capture/Compare 4 selection
        pub type CC4S_R = crate::FieldReader;
        ///Field `CC4S` writer - Capture/Compare 4 selection
        pub type CC4S_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `IC4PSC` reader - Input capture 4 prescaler
        pub type IC4PSC_R = crate::FieldReader;
        ///Field `IC4PSC` writer - Input capture 4 prescaler
        pub type IC4PSC_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `IC4F` reader - Input capture 4 filter
        pub type IC4F_R = crate::FieldReader;
        ///Field `IC4F` writer - Input capture 4 filter
        pub type IC4F_W<'a, REG> = crate::FieldWriter<'a, REG, 4>;
        impl R {
            ///Bits 0:1 - Capture/compare 3 selection
            #[inline(always)]
            pub fn cc3s(&self) -> CC3S_R {
                CC3S_R::new((self.bits & 3) as u8)
            }
            ///Bits 2:3 - Input capture 3 prescaler
            #[inline(always)]
            pub fn ic3psc(&self) -> IC3PSC_R {
                IC3PSC_R::new(((self.bits >> 2) & 3) as u8)
            }
            ///Bits 4:7 - Input capture 3 filter
            #[inline(always)]
            pub fn ic3f(&self) -> IC3F_R {
                IC3F_R::new(((self.bits >> 4) & 0x0f) as u8)
            }
            ///Bits 8:9 - Capture/Compare 4 selection
            #[inline(always)]
            pub fn cc4s(&self) -> CC4S_R {
                CC4S_R::new(((self.bits >> 8) & 3) as u8)
            }
            ///Bits 10:11 - Input capture 4 prescaler
            #[inline(always)]
            pub fn ic4psc(&self) -> IC4PSC_R {
                IC4PSC_R::new(((self.bits >> 10) & 3) as u8)
            }
            ///Bits 12:15 - Input capture 4 filter
            #[inline(always)]
            pub fn ic4f(&self) -> IC4F_R {
                IC4F_R::new(((self.bits >> 12) & 0x0f) as u8)
            }
        }
        impl W {
            ///Bits 0:1 - Capture/compare 3 selection
            #[inline(always)]
            #[must_use]
            pub fn cc3s(&mut self) -> CC3S_W<CHCTLR2_INPUT_SPEC> {
                CC3S_W::new(self, 0)
            }
            ///Bits 2:3 - Input capture 3 prescaler
            #[inline(always)]
            #[must_use]
            pub fn ic3psc(&mut self) -> IC3PSC_W<CHCTLR2_INPUT_SPEC> {
                IC3PSC_W::new(self, 2)
            }
            ///Bits 4:7 - Input capture 3 filter
            #[inline(always)]
            #[must_use]
            pub fn ic3f(&mut self) -> IC3F_W<CHCTLR2_INPUT_SPEC> {
                IC3F_W::new(self, 4)
            }
            ///Bits 8:9 - Capture/Compare 4 selection
            #[inline(always)]
            #[must_use]
            pub fn cc4s(&mut self) -> CC4S_W<CHCTLR2_INPUT_SPEC> {
                CC4S_W::new(self, 8)
            }
            ///Bits 10:11 - Input capture 4 prescaler
            #[inline(always)]
            #[must_use]
            pub fn ic4psc(&mut self) -> IC4PSC_W<CHCTLR2_INPUT_SPEC> {
                IC4PSC_W::new(self, 10)
            }
            ///Bits 12:15 - Input capture 4 filter
            #[inline(always)]
            #[must_use]
            pub fn ic4f(&mut self) -> IC4F_W<CHCTLR2_INPUT_SPEC> {
                IC4F_W::new(self, 12)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///capture/compare mode register 2 (input mode)
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`chctlr2_input::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`chctlr2_input::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct CHCTLR2_INPUT_SPEC;
        impl crate::RegisterSpec for CHCTLR2_INPUT_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`chctlr2_input::R`](R) reader structure
        impl crate::Readable for CHCTLR2_INPUT_SPEC {}
        ///`write(|w| ..)` method takes [`chctlr2_input::W`](W) writer structure
        impl crate::Writable for CHCTLR2_INPUT_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets CHCTLR2_Input to value 0
        impl crate::Resettable for CHCTLR2_INPUT_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///CCER (rw) register accessor: capture/compare enable register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`ccer::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ccer::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@ccer`]
    ///module
    pub type CCER = crate::Reg<ccer::CCER_SPEC>;
    ///capture/compare enable register
    pub mod ccer {
        ///Register `CCER` reader
        pub type R = crate::R<CCER_SPEC>;
        ///Register `CCER` writer
        pub type W = crate::W<CCER_SPEC>;
        ///Field `CC1E` reader - Capture/Compare 1 output enable
        pub type CC1E_R = crate::BitReader;
        ///Field `CC1E` writer - Capture/Compare 1 output enable
        pub type CC1E_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CC1P` reader - Capture/Compare 1 output Polarity
        pub type CC1P_R = crate::BitReader;
        ///Field `CC1P` writer - Capture/Compare 1 output Polarity
        pub type CC1P_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CC1NE` reader - Capture/Compare 1 complementary output enable
        pub type CC1NE_R = crate::BitReader;
        ///Field `CC1NE` writer - Capture/Compare 1 complementary output enable
        pub type CC1NE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CC1NP` reader - Capture/Compare 1 output Polarity
        pub type CC1NP_R = crate::BitReader;
        ///Field `CC1NP` writer - Capture/Compare 1 output Polarity
        pub type CC1NP_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CC2E` reader - Capture/Compare 2 output enable
        pub type CC2E_R = crate::BitReader;
        ///Field `CC2E` writer - Capture/Compare 2 output enable
        pub type CC2E_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CC2P` reader - Capture/Compare 2 output Polarity
        pub type CC2P_R = crate::BitReader;
        ///Field `CC2P` writer - Capture/Compare 2 output Polarity
        pub type CC2P_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CC2NE` reader - Capture/Compare 2 complementary output enable
        pub type CC2NE_R = crate::BitReader;
        ///Field `CC2NE` writer - Capture/Compare 2 complementary output enable
        pub type CC2NE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CC2NP` reader - Capture/Compare 2 output Polarity
        pub type CC2NP_R = crate::BitReader;
        ///Field `CC2NP` writer - Capture/Compare 2 output Polarity
        pub type CC2NP_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CC3E` reader - Capture/Compare 3 output enable
        pub type CC3E_R = crate::BitReader;
        ///Field `CC3E` writer - Capture/Compare 3 output enable
        pub type CC3E_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CC3P` reader - Capture/Compare 3 output Polarity
        pub type CC3P_R = crate::BitReader;
        ///Field `CC3P` writer - Capture/Compare 3 output Polarity
        pub type CC3P_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CC3NE` reader - Capture/Compare 3 complementary output enable
        pub type CC3NE_R = crate::BitReader;
        ///Field `CC3NE` writer - Capture/Compare 3 complementary output enable
        pub type CC3NE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CC3NP` reader - Capture/Compare 3 output Polarity
        pub type CC3NP_R = crate::BitReader;
        ///Field `CC3NP` writer - Capture/Compare 3 output Polarity
        pub type CC3NP_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CC4E` reader - Capture/Compare 4 output enable
        pub type CC4E_R = crate::BitReader;
        ///Field `CC4E` writer - Capture/Compare 4 output enable
        pub type CC4E_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CC4P` reader - Capture/Compare 3 output Polarity
        pub type CC4P_R = crate::BitReader;
        ///Field `CC4P` writer - Capture/Compare 3 output Polarity
        pub type CC4P_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - Capture/Compare 1 output enable
            #[inline(always)]
            pub fn cc1e(&self) -> CC1E_R {
                CC1E_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Capture/Compare 1 output Polarity
            #[inline(always)]
            pub fn cc1p(&self) -> CC1P_R {
                CC1P_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - Capture/Compare 1 complementary output enable
            #[inline(always)]
            pub fn cc1ne(&self) -> CC1NE_R {
                CC1NE_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - Capture/Compare 1 output Polarity
            #[inline(always)]
            pub fn cc1np(&self) -> CC1NP_R {
                CC1NP_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - Capture/Compare 2 output enable
            #[inline(always)]
            pub fn cc2e(&self) -> CC2E_R {
                CC2E_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - Capture/Compare 2 output Polarity
            #[inline(always)]
            pub fn cc2p(&self) -> CC2P_R {
                CC2P_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - Capture/Compare 2 complementary output enable
            #[inline(always)]
            pub fn cc2ne(&self) -> CC2NE_R {
                CC2NE_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - Capture/Compare 2 output Polarity
            #[inline(always)]
            pub fn cc2np(&self) -> CC2NP_R {
                CC2NP_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bit 8 - Capture/Compare 3 output enable
            #[inline(always)]
            pub fn cc3e(&self) -> CC3E_R {
                CC3E_R::new(((self.bits >> 8) & 1) != 0)
            }
            ///Bit 9 - Capture/Compare 3 output Polarity
            #[inline(always)]
            pub fn cc3p(&self) -> CC3P_R {
                CC3P_R::new(((self.bits >> 9) & 1) != 0)
            }
            ///Bit 10 - Capture/Compare 3 complementary output enable
            #[inline(always)]
            pub fn cc3ne(&self) -> CC3NE_R {
                CC3NE_R::new(((self.bits >> 10) & 1) != 0)
            }
            ///Bit 11 - Capture/Compare 3 output Polarity
            #[inline(always)]
            pub fn cc3np(&self) -> CC3NP_R {
                CC3NP_R::new(((self.bits >> 11) & 1) != 0)
            }
            ///Bit 12 - Capture/Compare 4 output enable
            #[inline(always)]
            pub fn cc4e(&self) -> CC4E_R {
                CC4E_R::new(((self.bits >> 12) & 1) != 0)
            }
            ///Bit 13 - Capture/Compare 3 output Polarity
            #[inline(always)]
            pub fn cc4p(&self) -> CC4P_R {
                CC4P_R::new(((self.bits >> 13) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - Capture/Compare 1 output enable
            #[inline(always)]
            #[must_use]
            pub fn cc1e(&mut self) -> CC1E_W<CCER_SPEC> {
                CC1E_W::new(self, 0)
            }
            ///Bit 1 - Capture/Compare 1 output Polarity
            #[inline(always)]
            #[must_use]
            pub fn cc1p(&mut self) -> CC1P_W<CCER_SPEC> {
                CC1P_W::new(self, 1)
            }
            ///Bit 2 - Capture/Compare 1 complementary output enable
            #[inline(always)]
            #[must_use]
            pub fn cc1ne(&mut self) -> CC1NE_W<CCER_SPEC> {
                CC1NE_W::new(self, 2)
            }
            ///Bit 3 - Capture/Compare 1 output Polarity
            #[inline(always)]
            #[must_use]
            pub fn cc1np(&mut self) -> CC1NP_W<CCER_SPEC> {
                CC1NP_W::new(self, 3)
            }
            ///Bit 4 - Capture/Compare 2 output enable
            #[inline(always)]
            #[must_use]
            pub fn cc2e(&mut self) -> CC2E_W<CCER_SPEC> {
                CC2E_W::new(self, 4)
            }
            ///Bit 5 - Capture/Compare 2 output Polarity
            #[inline(always)]
            #[must_use]
            pub fn cc2p(&mut self) -> CC2P_W<CCER_SPEC> {
                CC2P_W::new(self, 5)
            }
            ///Bit 6 - Capture/Compare 2 complementary output enable
            #[inline(always)]
            #[must_use]
            pub fn cc2ne(&mut self) -> CC2NE_W<CCER_SPEC> {
                CC2NE_W::new(self, 6)
            }
            ///Bit 7 - Capture/Compare 2 output Polarity
            #[inline(always)]
            #[must_use]
            pub fn cc2np(&mut self) -> CC2NP_W<CCER_SPEC> {
                CC2NP_W::new(self, 7)
            }
            ///Bit 8 - Capture/Compare 3 output enable
            #[inline(always)]
            #[must_use]
            pub fn cc3e(&mut self) -> CC3E_W<CCER_SPEC> {
                CC3E_W::new(self, 8)
            }
            ///Bit 9 - Capture/Compare 3 output Polarity
            #[inline(always)]
            #[must_use]
            pub fn cc3p(&mut self) -> CC3P_W<CCER_SPEC> {
                CC3P_W::new(self, 9)
            }
            ///Bit 10 - Capture/Compare 3 complementary output enable
            #[inline(always)]
            #[must_use]
            pub fn cc3ne(&mut self) -> CC3NE_W<CCER_SPEC> {
                CC3NE_W::new(self, 10)
            }
            ///Bit 11 - Capture/Compare 3 output Polarity
            #[inline(always)]
            #[must_use]
            pub fn cc3np(&mut self) -> CC3NP_W<CCER_SPEC> {
                CC3NP_W::new(self, 11)
            }
            ///Bit 12 - Capture/Compare 4 output enable
            #[inline(always)]
            #[must_use]
            pub fn cc4e(&mut self) -> CC4E_W<CCER_SPEC> {
                CC4E_W::new(self, 12)
            }
            ///Bit 13 - Capture/Compare 3 output Polarity
            #[inline(always)]
            #[must_use]
            pub fn cc4p(&mut self) -> CC4P_W<CCER_SPEC> {
                CC4P_W::new(self, 13)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///capture/compare enable register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`ccer::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ccer::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct CCER_SPEC;
        impl crate::RegisterSpec for CCER_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`ccer::R`](R) reader structure
        impl crate::Readable for CCER_SPEC {}
        ///`write(|w| ..)` method takes [`ccer::W`](W) writer structure
        impl crate::Writable for CCER_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets CCER to value 0
        impl crate::Resettable for CCER_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///CNT (rw) register accessor: counter
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`cnt::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cnt::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@cnt`]
    ///module
    pub type CNT = crate::Reg<cnt::CNT_SPEC>;
    ///counter
    pub mod cnt {
        ///Register `CNT` reader
        pub type R = crate::R<CNT_SPEC>;
        ///Register `CNT` writer
        pub type W = crate::W<CNT_SPEC>;
        ///Field `CNT` reader - counter value
        pub type CNT_R = crate::FieldReader<u16>;
        ///Field `CNT` writer - counter value
        pub type CNT_W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            ///Bits 0:15 - counter value
            #[inline(always)]
            pub fn cnt(&self) -> CNT_R {
                CNT_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - counter value
            #[inline(always)]
            #[must_use]
            pub fn cnt(&mut self) -> CNT_W<CNT_SPEC> {
                CNT_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///counter
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`cnt::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cnt::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct CNT_SPEC;
        impl crate::RegisterSpec for CNT_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`cnt::R`](R) reader structure
        impl crate::Readable for CNT_SPEC {}
        ///`write(|w| ..)` method takes [`cnt::W`](W) writer structure
        impl crate::Writable for CNT_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets CNT to value 0
        impl crate::Resettable for CNT_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///PSC (rw) register accessor: prescaler
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`psc::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`psc::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@psc`]
    ///module
    pub type PSC = crate::Reg<psc::PSC_SPEC>;
    ///prescaler
    pub mod psc {
        ///Register `PSC` reader
        pub type R = crate::R<PSC_SPEC>;
        ///Register `PSC` writer
        pub type W = crate::W<PSC_SPEC>;
        ///Field `PSC` reader - Prescaler value
        pub type PSC_R = crate::FieldReader<u16>;
        ///Field `PSC` writer - Prescaler value
        pub type PSC_W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            ///Bits 0:15 - Prescaler value
            #[inline(always)]
            pub fn psc(&self) -> PSC_R {
                PSC_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - Prescaler value
            #[inline(always)]
            #[must_use]
            pub fn psc(&mut self) -> PSC_W<PSC_SPEC> {
                PSC_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///prescaler
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`psc::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`psc::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct PSC_SPEC;
        impl crate::RegisterSpec for PSC_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`psc::R`](R) reader structure
        impl crate::Readable for PSC_SPEC {}
        ///`write(|w| ..)` method takes [`psc::W`](W) writer structure
        impl crate::Writable for PSC_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets PSC to value 0
        impl crate::Resettable for PSC_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///ATRLR (rw) register accessor: auto-reload register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`atrlr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`atrlr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@atrlr`]
    ///module
    pub type ATRLR = crate::Reg<atrlr::ATRLR_SPEC>;
    ///auto-reload register
    pub mod atrlr {
        ///Register `ATRLR` reader
        pub type R = crate::R<ATRLR_SPEC>;
        ///Register `ATRLR` writer
        pub type W = crate::W<ATRLR_SPEC>;
        ///Field `ARR` reader - Auto-reload value
        pub type ARR_R = crate::FieldReader<u16>;
        ///Field `ARR` writer - Auto-reload value
        pub type ARR_W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            ///Bits 0:15 - Auto-reload value
            #[inline(always)]
            pub fn arr(&self) -> ARR_R {
                ARR_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - Auto-reload value
            #[inline(always)]
            #[must_use]
            pub fn arr(&mut self) -> ARR_W<ATRLR_SPEC> {
                ARR_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///auto-reload register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`atrlr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`atrlr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct ATRLR_SPEC;
        impl crate::RegisterSpec for ATRLR_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`atrlr::R`](R) reader structure
        impl crate::Readable for ATRLR_SPEC {}
        ///`write(|w| ..)` method takes [`atrlr::W`](W) writer structure
        impl crate::Writable for ATRLR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets ATRLR to value 0
        impl crate::Resettable for ATRLR_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///RPTCR (rw) register accessor: repetition counter register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`rptcr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`rptcr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@rptcr`]
    ///module
    pub type RPTCR = crate::Reg<rptcr::RPTCR_SPEC>;
    ///repetition counter register
    pub mod rptcr {
        ///Register `RPTCR` reader
        pub type R = crate::R<RPTCR_SPEC>;
        ///Register `RPTCR` writer
        pub type W = crate::W<RPTCR_SPEC>;
        ///Field `REP` reader - Repetition counter value
        pub type REP_R = crate::FieldReader;
        ///Field `REP` writer - Repetition counter value
        pub type REP_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            ///Bits 0:7 - Repetition counter value
            #[inline(always)]
            pub fn rep(&self) -> REP_R {
                REP_R::new((self.bits & 0xff) as u8)
            }
        }
        impl W {
            ///Bits 0:7 - Repetition counter value
            #[inline(always)]
            #[must_use]
            pub fn rep(&mut self) -> REP_W<RPTCR_SPEC> {
                REP_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///repetition counter register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`rptcr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`rptcr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct RPTCR_SPEC;
        impl crate::RegisterSpec for RPTCR_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`rptcr::R`](R) reader structure
        impl crate::Readable for RPTCR_SPEC {}
        ///`write(|w| ..)` method takes [`rptcr::W`](W) writer structure
        impl crate::Writable for RPTCR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets RPTCR to value 0
        impl crate::Resettable for RPTCR_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///CH1CVR (rw) register accessor: capture/compare register 1
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`ch1cvr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ch1cvr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@ch1cvr`]
    ///module
    pub type CH1CVR = crate::Reg<ch1cvr::CH1CVR_SPEC>;
    ///capture/compare register 1
    pub mod ch1cvr {
        ///Register `CH1CVR` reader
        pub type R = crate::R<CH1CVR_SPEC>;
        ///Register `CH1CVR` writer
        pub type W = crate::W<CH1CVR_SPEC>;
        ///Field `CCR1` reader - Capture/Compare 1 value
        pub type CCR1_R = crate::FieldReader<u16>;
        ///Field `CCR1` writer - Capture/Compare 1 value
        pub type CCR1_W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            ///Bits 0:15 - Capture/Compare 1 value
            #[inline(always)]
            pub fn ccr1(&self) -> CCR1_R {
                CCR1_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - Capture/Compare 1 value
            #[inline(always)]
            #[must_use]
            pub fn ccr1(&mut self) -> CCR1_W<CH1CVR_SPEC> {
                CCR1_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///capture/compare register 1
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`ch1cvr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ch1cvr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct CH1CVR_SPEC;
        impl crate::RegisterSpec for CH1CVR_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`ch1cvr::R`](R) reader structure
        impl crate::Readable for CH1CVR_SPEC {}
        ///`write(|w| ..)` method takes [`ch1cvr::W`](W) writer structure
        impl crate::Writable for CH1CVR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets CH1CVR to value 0
        impl crate::Resettable for CH1CVR_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///CH2CVR (rw) register accessor: capture/compare register 2
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`ch2cvr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ch2cvr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@ch2cvr`]
    ///module
    pub type CH2CVR = crate::Reg<ch2cvr::CH2CVR_SPEC>;
    ///capture/compare register 2
    pub mod ch2cvr {
        ///Register `CH2CVR` reader
        pub type R = crate::R<CH2CVR_SPEC>;
        ///Register `CH2CVR` writer
        pub type W = crate::W<CH2CVR_SPEC>;
        ///Field `CCR2` reader - Capture/Compare 2 value
        pub type CCR2_R = crate::FieldReader<u16>;
        ///Field `CCR2` writer - Capture/Compare 2 value
        pub type CCR2_W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            ///Bits 0:15 - Capture/Compare 2 value
            #[inline(always)]
            pub fn ccr2(&self) -> CCR2_R {
                CCR2_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - Capture/Compare 2 value
            #[inline(always)]
            #[must_use]
            pub fn ccr2(&mut self) -> CCR2_W<CH2CVR_SPEC> {
                CCR2_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///capture/compare register 2
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`ch2cvr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ch2cvr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct CH2CVR_SPEC;
        impl crate::RegisterSpec for CH2CVR_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`ch2cvr::R`](R) reader structure
        impl crate::Readable for CH2CVR_SPEC {}
        ///`write(|w| ..)` method takes [`ch2cvr::W`](W) writer structure
        impl crate::Writable for CH2CVR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets CH2CVR to value 0
        impl crate::Resettable for CH2CVR_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///CH3CVR (rw) register accessor: capture/compare register 3
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`ch3cvr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ch3cvr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@ch3cvr`]
    ///module
    pub type CH3CVR = crate::Reg<ch3cvr::CH3CVR_SPEC>;
    ///capture/compare register 3
    pub mod ch3cvr {
        ///Register `CH3CVR` reader
        pub type R = crate::R<CH3CVR_SPEC>;
        ///Register `CH3CVR` writer
        pub type W = crate::W<CH3CVR_SPEC>;
        ///Field `CCR3` reader - Capture/Compare value
        pub type CCR3_R = crate::FieldReader<u16>;
        ///Field `CCR3` writer - Capture/Compare value
        pub type CCR3_W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            ///Bits 0:15 - Capture/Compare value
            #[inline(always)]
            pub fn ccr3(&self) -> CCR3_R {
                CCR3_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - Capture/Compare value
            #[inline(always)]
            #[must_use]
            pub fn ccr3(&mut self) -> CCR3_W<CH3CVR_SPEC> {
                CCR3_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///capture/compare register 3
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`ch3cvr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ch3cvr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct CH3CVR_SPEC;
        impl crate::RegisterSpec for CH3CVR_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`ch3cvr::R`](R) reader structure
        impl crate::Readable for CH3CVR_SPEC {}
        ///`write(|w| ..)` method takes [`ch3cvr::W`](W) writer structure
        impl crate::Writable for CH3CVR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets CH3CVR to value 0
        impl crate::Resettable for CH3CVR_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///CH4CVR (rw) register accessor: capture/compare register 4
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`ch4cvr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ch4cvr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@ch4cvr`]
    ///module
    pub type CH4CVR = crate::Reg<ch4cvr::CH4CVR_SPEC>;
    ///capture/compare register 4
    pub mod ch4cvr {
        ///Register `CH4CVR` reader
        pub type R = crate::R<CH4CVR_SPEC>;
        ///Register `CH4CVR` writer
        pub type W = crate::W<CH4CVR_SPEC>;
        ///Field `CCR4` reader - Capture/Compare value
        pub type CCR4_R = crate::FieldReader<u16>;
        ///Field `CCR4` writer - Capture/Compare value
        pub type CCR4_W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            ///Bits 0:15 - Capture/Compare value
            #[inline(always)]
            pub fn ccr4(&self) -> CCR4_R {
                CCR4_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - Capture/Compare value
            #[inline(always)]
            #[must_use]
            pub fn ccr4(&mut self) -> CCR4_W<CH4CVR_SPEC> {
                CCR4_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///capture/compare register 4
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`ch4cvr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ch4cvr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct CH4CVR_SPEC;
        impl crate::RegisterSpec for CH4CVR_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`ch4cvr::R`](R) reader structure
        impl crate::Readable for CH4CVR_SPEC {}
        ///`write(|w| ..)` method takes [`ch4cvr::W`](W) writer structure
        impl crate::Writable for CH4CVR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets CH4CVR to value 0
        impl crate::Resettable for CH4CVR_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///BDTR (rw) register accessor: break and dead-time register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`bdtr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`bdtr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@bdtr`]
    ///module
    pub type BDTR = crate::Reg<bdtr::BDTR_SPEC>;
    ///break and dead-time register
    pub mod bdtr {
        ///Register `BDTR` reader
        pub type R = crate::R<BDTR_SPEC>;
        ///Register `BDTR` writer
        pub type W = crate::W<BDTR_SPEC>;
        ///Field `DTG` reader - Dead-time generator setup
        pub type DTG_R = crate::FieldReader;
        ///Field `DTG` writer - Dead-time generator setup
        pub type DTG_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        ///Field `LOCK` reader - Lock configuration
        pub type LOCK_R = crate::FieldReader;
        ///Field `LOCK` writer - Lock configuration
        pub type LOCK_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `OSSI` reader - Off-state selection for Idle mode
        pub type OSSI_R = crate::BitReader;
        ///Field `OSSI` writer - Off-state selection for Idle mode
        pub type OSSI_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `OSSR` reader - Off-state selection for Run mode
        pub type OSSR_R = crate::BitReader;
        ///Field `OSSR` writer - Off-state selection for Run mode
        pub type OSSR_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `BKE` reader - Break enable
        pub type BKE_R = crate::BitReader;
        ///Field `BKE` writer - Break enable
        pub type BKE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `BKP` reader - Break polarity
        pub type BKP_R = crate::BitReader;
        ///Field `BKP` writer - Break polarity
        pub type BKP_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `AOE` reader - Automatic output enable
        pub type AOE_R = crate::BitReader;
        ///Field `AOE` writer - Automatic output enable
        pub type AOE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `MOE` reader - Main output enable
        pub type MOE_R = crate::BitReader;
        ///Field `MOE` writer - Main output enable
        pub type MOE_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bits 0:7 - Dead-time generator setup
            #[inline(always)]
            pub fn dtg(&self) -> DTG_R {
                DTG_R::new((self.bits & 0xff) as u8)
            }
            ///Bits 8:9 - Lock configuration
            #[inline(always)]
            pub fn lock(&self) -> LOCK_R {
                LOCK_R::new(((self.bits >> 8) & 3) as u8)
            }
            ///Bit 10 - Off-state selection for Idle mode
            #[inline(always)]
            pub fn ossi(&self) -> OSSI_R {
                OSSI_R::new(((self.bits >> 10) & 1) != 0)
            }
            ///Bit 11 - Off-state selection for Run mode
            #[inline(always)]
            pub fn ossr(&self) -> OSSR_R {
                OSSR_R::new(((self.bits >> 11) & 1) != 0)
            }
            ///Bit 12 - Break enable
            #[inline(always)]
            pub fn bke(&self) -> BKE_R {
                BKE_R::new(((self.bits >> 12) & 1) != 0)
            }
            ///Bit 13 - Break polarity
            #[inline(always)]
            pub fn bkp(&self) -> BKP_R {
                BKP_R::new(((self.bits >> 13) & 1) != 0)
            }
            ///Bit 14 - Automatic output enable
            #[inline(always)]
            pub fn aoe(&self) -> AOE_R {
                AOE_R::new(((self.bits >> 14) & 1) != 0)
            }
            ///Bit 15 - Main output enable
            #[inline(always)]
            pub fn moe(&self) -> MOE_R {
                MOE_R::new(((self.bits >> 15) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:7 - Dead-time generator setup
            #[inline(always)]
            #[must_use]
            pub fn dtg(&mut self) -> DTG_W<BDTR_SPEC> {
                DTG_W::new(self, 0)
            }
            ///Bits 8:9 - Lock configuration
            #[inline(always)]
            #[must_use]
            pub fn lock(&mut self) -> LOCK_W<BDTR_SPEC> {
                LOCK_W::new(self, 8)
            }
            ///Bit 10 - Off-state selection for Idle mode
            #[inline(always)]
            #[must_use]
            pub fn ossi(&mut self) -> OSSI_W<BDTR_SPEC> {
                OSSI_W::new(self, 10)
            }
            ///Bit 11 - Off-state selection for Run mode
            #[inline(always)]
            #[must_use]
            pub fn ossr(&mut self) -> OSSR_W<BDTR_SPEC> {
                OSSR_W::new(self, 11)
            }
            ///Bit 12 - Break enable
            #[inline(always)]
            #[must_use]
            pub fn bke(&mut self) -> BKE_W<BDTR_SPEC> {
                BKE_W::new(self, 12)
            }
            ///Bit 13 - Break polarity
            #[inline(always)]
            #[must_use]
            pub fn bkp(&mut self) -> BKP_W<BDTR_SPEC> {
                BKP_W::new(self, 13)
            }
            ///Bit 14 - Automatic output enable
            #[inline(always)]
            #[must_use]
            pub fn aoe(&mut self) -> AOE_W<BDTR_SPEC> {
                AOE_W::new(self, 14)
            }
            ///Bit 15 - Main output enable
            #[inline(always)]
            #[must_use]
            pub fn moe(&mut self) -> MOE_W<BDTR_SPEC> {
                MOE_W::new(self, 15)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///break and dead-time register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`bdtr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`bdtr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct BDTR_SPEC;
        impl crate::RegisterSpec for BDTR_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`bdtr::R`](R) reader structure
        impl crate::Readable for BDTR_SPEC {}
        ///`write(|w| ..)` method takes [`bdtr::W`](W) writer structure
        impl crate::Writable for BDTR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets BDTR to value 0
        impl crate::Resettable for BDTR_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///DMACFGR (rw) register accessor: DMA control register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`dmacfgr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dmacfgr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@dmacfgr`]
    ///module
    pub type DMACFGR = crate::Reg<dmacfgr::DMACFGR_SPEC>;
    ///DMA control register
    pub mod dmacfgr {
        ///Register `DMACFGR` reader
        pub type R = crate::R<DMACFGR_SPEC>;
        ///Register `DMACFGR` writer
        pub type W = crate::W<DMACFGR_SPEC>;
        ///Field `DBA` reader - DMA base address
        pub type DBA_R = crate::FieldReader;
        ///Field `DBA` writer - DMA base address
        pub type DBA_W<'a, REG> = crate::FieldWriter<'a, REG, 5>;
        ///Field `DBL` reader - DMA burst length
        pub type DBL_R = crate::FieldReader;
        ///Field `DBL` writer - DMA burst length
        pub type DBL_W<'a, REG> = crate::FieldWriter<'a, REG, 5>;
        impl R {
            ///Bits 0:4 - DMA base address
            #[inline(always)]
            pub fn dba(&self) -> DBA_R {
                DBA_R::new((self.bits & 0x1f) as u8)
            }
            ///Bits 8:12 - DMA burst length
            #[inline(always)]
            pub fn dbl(&self) -> DBL_R {
                DBL_R::new(((self.bits >> 8) & 0x1f) as u8)
            }
        }
        impl W {
            ///Bits 0:4 - DMA base address
            #[inline(always)]
            #[must_use]
            pub fn dba(&mut self) -> DBA_W<DMACFGR_SPEC> {
                DBA_W::new(self, 0)
            }
            ///Bits 8:12 - DMA burst length
            #[inline(always)]
            #[must_use]
            pub fn dbl(&mut self) -> DBL_W<DMACFGR_SPEC> {
                DBL_W::new(self, 8)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///DMA control register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`dmacfgr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dmacfgr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct DMACFGR_SPEC;
        impl crate::RegisterSpec for DMACFGR_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`dmacfgr::R`](R) reader structure
        impl crate::Readable for DMACFGR_SPEC {}
        ///`write(|w| ..)` method takes [`dmacfgr::W`](W) writer structure
        impl crate::Writable for DMACFGR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets DMACFGR to value 0
        impl crate::Resettable for DMACFGR_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///DMAADR (rw) register accessor: DMA address for full transfer
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`dmaadr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dmaadr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@dmaadr`]
    ///module
    pub type DMAADR = crate::Reg<dmaadr::DMAADR_SPEC>;
    ///DMA address for full transfer
    pub mod dmaadr {
        ///Register `DMAADR` reader
        pub type R = crate::R<DMAADR_SPEC>;
        ///Register `DMAADR` writer
        pub type W = crate::W<DMAADR_SPEC>;
        ///Field `DMAB` reader - DMA register for burst accesses
        pub type DMAB_R = crate::FieldReader<u32>;
        ///Field `DMAB` writer - DMA register for burst accesses
        pub type DMAB_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - DMA register for burst accesses
            #[inline(always)]
            pub fn dmab(&self) -> DMAB_R {
                DMAB_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - DMA register for burst accesses
            #[inline(always)]
            #[must_use]
            pub fn dmab(&mut self) -> DMAB_W<DMAADR_SPEC> {
                DMAB_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///DMA address for full transfer
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`dmaadr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dmaadr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct DMAADR_SPEC;
        impl crate::RegisterSpec for DMAADR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`dmaadr::R`](R) reader structure
        impl crate::Readable for DMAADR_SPEC {}
        ///`write(|w| ..)` method takes [`dmaadr::W`](W) writer structure
        impl crate::Writable for DMAADR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets DMAADR to value 0
        impl crate::Resettable for DMAADR_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
}
///General purpose timer
pub struct TIM2 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for TIM2 {}
impl TIM2 {
    ///Pointer to the register block
    pub const PTR: *const tim2::RegisterBlock = 0x4000_0000 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const tim2::RegisterBlock {
        Self::PTR
    }
    /// Steal an instance of this peripheral
    ///
    /// # Safety
    ///
    /// Ensure that the new instance of the peripheral cannot be used in a way
    /// that may race with any existing instances, for example by only
    /// accessing read-only or write-only registers, or by consuming the
    /// original peripheral and using critical sections to coordinate
    /// access between multiple new instances.
    ///
    /// Additionally, other software such as HALs may rely on only one
    /// peripheral instance existing to ensure memory safety; ensure
    /// no stolen instances are passed to such software.
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for TIM2 {
    type Target = tim2::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for TIM2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("TIM2").finish()
    }
}
///General purpose timer
pub mod tim2 {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        ctlr1: CTLR1,
        _reserved1: [u8; 0x02],
        ctlr2: CTLR2,
        _reserved2: [u8; 0x02],
        smcfgr: SMCFGR,
        _reserved3: [u8; 0x02],
        dmaintenr: DMAINTENR,
        _reserved4: [u8; 0x02],
        intfr: INTFR,
        _reserved5: [u8; 0x02],
        swevgr: SWEVGR,
        _reserved6: [u8; 0x02],
        _reserved_6_chctlr1: [u8; 0x02],
        _reserved7: [u8; 0x02],
        _reserved_7_chctlr2: [u8; 0x02],
        _reserved8: [u8; 0x02],
        ccer: CCER,
        _reserved9: [u8; 0x02],
        cnt: CNT,
        _reserved10: [u8; 0x02],
        psc: PSC,
        _reserved11: [u8; 0x02],
        atrlr: ATRLR,
        _reserved12: [u8; 0x06],
        ch1cvr: CH1CVR,
        _reserved13: [u8; 0x02],
        ch2cvr: CH2CVR,
        _reserved14: [u8; 0x02],
        ch3cvr: CH3CVR,
        _reserved15: [u8; 0x02],
        ch4cvr: CH4CVR,
        _reserved16: [u8; 0x06],
        dmacfgr: DMACFGR,
        _reserved17: [u8; 0x02],
        dmaadr: DMAADR,
    }
    impl RegisterBlock {
        ///0x00 - control register 1
        #[inline(always)]
        pub const fn ctlr1(&self) -> &CTLR1 {
            &self.ctlr1
        }
        ///0x04 - control register 2
        #[inline(always)]
        pub const fn ctlr2(&self) -> &CTLR2 {
            &self.ctlr2
        }
        ///0x08 - slave mode control register
        #[inline(always)]
        pub const fn smcfgr(&self) -> &SMCFGR {
            &self.smcfgr
        }
        ///0x0c - DMA/Interrupt enable register
        #[inline(always)]
        pub const fn dmaintenr(&self) -> &DMAINTENR {
            &self.dmaintenr
        }
        ///0x10 - status register
        #[inline(always)]
        pub const fn intfr(&self) -> &INTFR {
            &self.intfr
        }
        ///0x14 - event generation register
        #[inline(always)]
        pub const fn swevgr(&self) -> &SWEVGR {
            &self.swevgr
        }
        ///0x18 - capture/compare mode register 1 (input mode)
        #[inline(always)]
        pub const fn chctlr1_input(&self) -> &CHCTLR1_INPUT {
            unsafe { &*(self as *const Self).cast::<u8>().add(24).cast() }
        }
        ///0x18 - capture/compare mode register 1 (output mode)
        #[inline(always)]
        pub const fn chctlr1_output(&self) -> &CHCTLR1_OUTPUT {
            unsafe { &*(self as *const Self).cast::<u8>().add(24).cast() }
        }
        ///0x1c - capture/compare mode register 2 (input mode)
        #[inline(always)]
        pub const fn chctlr2_input(&self) -> &CHCTLR2_INPUT {
            unsafe { &*(self as *const Self).cast::<u8>().add(28).cast() }
        }
        ///0x1c - capture/compare mode register 2 (output mode)
        #[inline(always)]
        pub const fn chctlr2_output(&self) -> &CHCTLR2_OUTPUT {
            unsafe { &*(self as *const Self).cast::<u8>().add(28).cast() }
        }
        ///0x20 - capture/compare enable register
        #[inline(always)]
        pub const fn ccer(&self) -> &CCER {
            &self.ccer
        }
        ///0x24 - counter
        #[inline(always)]
        pub const fn cnt(&self) -> &CNT {
            &self.cnt
        }
        ///0x28 - prescaler
        #[inline(always)]
        pub const fn psc(&self) -> &PSC {
            &self.psc
        }
        ///0x2c - auto-reload register
        #[inline(always)]
        pub const fn atrlr(&self) -> &ATRLR {
            &self.atrlr
        }
        ///0x34 - capture/compare register 1
        #[inline(always)]
        pub const fn ch1cvr(&self) -> &CH1CVR {
            &self.ch1cvr
        }
        ///0x38 - capture/compare register 2
        #[inline(always)]
        pub const fn ch2cvr(&self) -> &CH2CVR {
            &self.ch2cvr
        }
        ///0x3c - capture/compare register 3
        #[inline(always)]
        pub const fn ch3cvr(&self) -> &CH3CVR {
            &self.ch3cvr
        }
        ///0x40 - capture/compare register 4
        #[inline(always)]
        pub const fn ch4cvr(&self) -> &CH4CVR {
            &self.ch4cvr
        }
        ///0x48 - DMA control register
        #[inline(always)]
        pub const fn dmacfgr(&self) -> &DMACFGR {
            &self.dmacfgr
        }
        ///0x4c - DMA address for full transfer
        #[inline(always)]
        pub const fn dmaadr(&self) -> &DMAADR {
            &self.dmaadr
        }
    }
    ///CTLR1 (rw) register accessor: control register 1
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`ctlr1::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ctlr1::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@ctlr1`]
    ///module
    pub type CTLR1 = crate::Reg<ctlr1::CTLR1_SPEC>;
    ///control register 1
    pub mod ctlr1 {
        ///Register `CTLR1` reader
        pub type R = crate::R<CTLR1_SPEC>;
        ///Register `CTLR1` writer
        pub type W = crate::W<CTLR1_SPEC>;
        ///Field `CEN` reader - Counter enable
        pub type CEN_R = crate::BitReader;
        ///Field `CEN` writer - Counter enable
        pub type CEN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UDIS` reader - Update disable
        pub type UDIS_R = crate::BitReader;
        ///Field `UDIS` writer - Update disable
        pub type UDIS_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `URS` reader - Update request source
        pub type URS_R = crate::BitReader;
        ///Field `URS` writer - Update request source
        pub type URS_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `OPM` reader - One-pulse mode
        pub type OPM_R = crate::BitReader;
        ///Field `OPM` writer - One-pulse mode
        pub type OPM_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `DIR` reader - Direction
        pub type DIR_R = crate::BitReader;
        ///Field `DIR` writer - Direction
        pub type DIR_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CMS` reader - Center-aligned mode selection
        pub type CMS_R = crate::FieldReader;
        ///Field `CMS` writer - Center-aligned mode selection
        pub type CMS_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `ARPE` reader - Auto-reload preload enable
        pub type ARPE_R = crate::BitReader;
        ///Field `ARPE` writer - Auto-reload preload enable
        pub type ARPE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CKD` reader - Clock division
        pub type CKD_R = crate::FieldReader;
        ///Field `CKD` writer - Clock division
        pub type CKD_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `TMR_CAP_OV_EN` reader - Auto-reload preload enable
        pub type TMR_CAP_OV_EN_R = crate::BitReader;
        ///Field `TMR_CAP_OV_EN` writer - Auto-reload preload enable
        pub type TMR_CAP_OV_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TMR_CAP_LVL_EN` reader - Directive function enable
        pub type TMR_CAP_LVL_EN_R = crate::BitReader;
        ///Field `TMR_CAP_LVL_EN` writer - Directive function enable
        pub type TMR_CAP_LVL_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - Counter enable
            #[inline(always)]
            pub fn cen(&self) -> CEN_R {
                CEN_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Update disable
            #[inline(always)]
            pub fn udis(&self) -> UDIS_R {
                UDIS_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - Update request source
            #[inline(always)]
            pub fn urs(&self) -> URS_R {
                URS_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - One-pulse mode
            #[inline(always)]
            pub fn opm(&self) -> OPM_R {
                OPM_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - Direction
            #[inline(always)]
            pub fn dir(&self) -> DIR_R {
                DIR_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bits 5:6 - Center-aligned mode selection
            #[inline(always)]
            pub fn cms(&self) -> CMS_R {
                CMS_R::new(((self.bits >> 5) & 3) as u8)
            }
            ///Bit 7 - Auto-reload preload enable
            #[inline(always)]
            pub fn arpe(&self) -> ARPE_R {
                ARPE_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bits 8:9 - Clock division
            #[inline(always)]
            pub fn ckd(&self) -> CKD_R {
                CKD_R::new(((self.bits >> 8) & 3) as u8)
            }
            ///Bit 14 - Auto-reload preload enable
            #[inline(always)]
            pub fn tmr_cap_ov_en(&self) -> TMR_CAP_OV_EN_R {
                TMR_CAP_OV_EN_R::new(((self.bits >> 14) & 1) != 0)
            }
            ///Bit 15 - Directive function enable
            #[inline(always)]
            pub fn tmr_cap_lvl_en(&self) -> TMR_CAP_LVL_EN_R {
                TMR_CAP_LVL_EN_R::new(((self.bits >> 15) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - Counter enable
            #[inline(always)]
            #[must_use]
            pub fn cen(&mut self) -> CEN_W<CTLR1_SPEC> {
                CEN_W::new(self, 0)
            }
            ///Bit 1 - Update disable
            #[inline(always)]
            #[must_use]
            pub fn udis(&mut self) -> UDIS_W<CTLR1_SPEC> {
                UDIS_W::new(self, 1)
            }
            ///Bit 2 - Update request source
            #[inline(always)]
            #[must_use]
            pub fn urs(&mut self) -> URS_W<CTLR1_SPEC> {
                URS_W::new(self, 2)
            }
            ///Bit 3 - One-pulse mode
            #[inline(always)]
            #[must_use]
            pub fn opm(&mut self) -> OPM_W<CTLR1_SPEC> {
                OPM_W::new(self, 3)
            }
            ///Bit 4 - Direction
            #[inline(always)]
            #[must_use]
            pub fn dir(&mut self) -> DIR_W<CTLR1_SPEC> {
                DIR_W::new(self, 4)
            }
            ///Bits 5:6 - Center-aligned mode selection
            #[inline(always)]
            #[must_use]
            pub fn cms(&mut self) -> CMS_W<CTLR1_SPEC> {
                CMS_W::new(self, 5)
            }
            ///Bit 7 - Auto-reload preload enable
            #[inline(always)]
            #[must_use]
            pub fn arpe(&mut self) -> ARPE_W<CTLR1_SPEC> {
                ARPE_W::new(self, 7)
            }
            ///Bits 8:9 - Clock division
            #[inline(always)]
            #[must_use]
            pub fn ckd(&mut self) -> CKD_W<CTLR1_SPEC> {
                CKD_W::new(self, 8)
            }
            ///Bit 14 - Auto-reload preload enable
            #[inline(always)]
            #[must_use]
            pub fn tmr_cap_ov_en(&mut self) -> TMR_CAP_OV_EN_W<CTLR1_SPEC> {
                TMR_CAP_OV_EN_W::new(self, 14)
            }
            ///Bit 15 - Directive function enable
            #[inline(always)]
            #[must_use]
            pub fn tmr_cap_lvl_en(&mut self) -> TMR_CAP_LVL_EN_W<CTLR1_SPEC> {
                TMR_CAP_LVL_EN_W::new(self, 15)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///control register 1
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`ctlr1::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ctlr1::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct CTLR1_SPEC;
        impl crate::RegisterSpec for CTLR1_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`ctlr1::R`](R) reader structure
        impl crate::Readable for CTLR1_SPEC {}
        ///`write(|w| ..)` method takes [`ctlr1::W`](W) writer structure
        impl crate::Writable for CTLR1_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets CTLR1 to value 0
        impl crate::Resettable for CTLR1_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///CTLR2 (rw) register accessor: control register 2
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`ctlr2::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ctlr2::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@ctlr2`]
    ///module
    pub type CTLR2 = crate::Reg<ctlr2::CTLR2_SPEC>;
    ///control register 2
    pub mod ctlr2 {
        ///Register `CTLR2` reader
        pub type R = crate::R<CTLR2_SPEC>;
        ///Register `CTLR2` writer
        pub type W = crate::W<CTLR2_SPEC>;
        ///Field `CCDS` reader - Capture/compare DMA selection
        pub type CCDS_R = crate::BitReader;
        ///Field `CCDS` writer - Capture/compare DMA selection
        pub type CCDS_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `MMS` reader - Master mode selection
        pub type MMS_R = crate::FieldReader;
        ///Field `MMS` writer - Master mode selection
        pub type MMS_W<'a, REG> = crate::FieldWriter<'a, REG, 3>;
        ///Field `TI1S` reader - TI1 selection
        pub type TI1S_R = crate::BitReader;
        ///Field `TI1S` writer - TI1 selection
        pub type TI1S_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 3 - Capture/compare DMA selection
            #[inline(always)]
            pub fn ccds(&self) -> CCDS_R {
                CCDS_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bits 4:6 - Master mode selection
            #[inline(always)]
            pub fn mms(&self) -> MMS_R {
                MMS_R::new(((self.bits >> 4) & 7) as u8)
            }
            ///Bit 7 - TI1 selection
            #[inline(always)]
            pub fn ti1s(&self) -> TI1S_R {
                TI1S_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 3 - Capture/compare DMA selection
            #[inline(always)]
            #[must_use]
            pub fn ccds(&mut self) -> CCDS_W<CTLR2_SPEC> {
                CCDS_W::new(self, 3)
            }
            ///Bits 4:6 - Master mode selection
            #[inline(always)]
            #[must_use]
            pub fn mms(&mut self) -> MMS_W<CTLR2_SPEC> {
                MMS_W::new(self, 4)
            }
            ///Bit 7 - TI1 selection
            #[inline(always)]
            #[must_use]
            pub fn ti1s(&mut self) -> TI1S_W<CTLR2_SPEC> {
                TI1S_W::new(self, 7)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///control register 2
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`ctlr2::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ctlr2::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct CTLR2_SPEC;
        impl crate::RegisterSpec for CTLR2_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`ctlr2::R`](R) reader structure
        impl crate::Readable for CTLR2_SPEC {}
        ///`write(|w| ..)` method takes [`ctlr2::W`](W) writer structure
        impl crate::Writable for CTLR2_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets CTLR2 to value 0
        impl crate::Resettable for CTLR2_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///SMCFGR (rw) register accessor: slave mode control register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`smcfgr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`smcfgr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@smcfgr`]
    ///module
    pub type SMCFGR = crate::Reg<smcfgr::SMCFGR_SPEC>;
    ///slave mode control register
    pub mod smcfgr {
        ///Register `SMCFGR` reader
        pub type R = crate::R<SMCFGR_SPEC>;
        ///Register `SMCFGR` writer
        pub type W = crate::W<SMCFGR_SPEC>;
        ///Field `SMS` reader - Slave mode selection
        pub type SMS_R = crate::FieldReader;
        ///Field `SMS` writer - Slave mode selection
        pub type SMS_W<'a, REG> = crate::FieldWriter<'a, REG, 3>;
        ///Field `TS` reader - Trigger selection
        pub type TS_R = crate::FieldReader;
        ///Field `TS` writer - Trigger selection
        pub type TS_W<'a, REG> = crate::FieldWriter<'a, REG, 3>;
        ///Field `MSM` reader - Master/Slave mode
        pub type MSM_R = crate::BitReader;
        ///Field `MSM` writer - Master/Slave mode
        pub type MSM_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `ETF` reader - External trigger filter
        pub type ETF_R = crate::FieldReader;
        ///Field `ETF` writer - External trigger filter
        pub type ETF_W<'a, REG> = crate::FieldWriter<'a, REG, 4>;
        ///Field `ETPS` reader - External trigger prescaler
        pub type ETPS_R = crate::FieldReader;
        ///Field `ETPS` writer - External trigger prescaler
        pub type ETPS_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `ECE` reader - External clock enable
        pub type ECE_R = crate::BitReader;
        ///Field `ECE` writer - External clock enable
        pub type ECE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `ETP` reader - External trigger polarity
        pub type ETP_R = crate::BitReader;
        ///Field `ETP` writer - External trigger polarity
        pub type ETP_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bits 0:2 - Slave mode selection
            #[inline(always)]
            pub fn sms(&self) -> SMS_R {
                SMS_R::new((self.bits & 7) as u8)
            }
            ///Bits 4:6 - Trigger selection
            #[inline(always)]
            pub fn ts(&self) -> TS_R {
                TS_R::new(((self.bits >> 4) & 7) as u8)
            }
            ///Bit 7 - Master/Slave mode
            #[inline(always)]
            pub fn msm(&self) -> MSM_R {
                MSM_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bits 8:11 - External trigger filter
            #[inline(always)]
            pub fn etf(&self) -> ETF_R {
                ETF_R::new(((self.bits >> 8) & 0x0f) as u8)
            }
            ///Bits 12:13 - External trigger prescaler
            #[inline(always)]
            pub fn etps(&self) -> ETPS_R {
                ETPS_R::new(((self.bits >> 12) & 3) as u8)
            }
            ///Bit 14 - External clock enable
            #[inline(always)]
            pub fn ece(&self) -> ECE_R {
                ECE_R::new(((self.bits >> 14) & 1) != 0)
            }
            ///Bit 15 - External trigger polarity
            #[inline(always)]
            pub fn etp(&self) -> ETP_R {
                ETP_R::new(((self.bits >> 15) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:2 - Slave mode selection
            #[inline(always)]
            #[must_use]
            pub fn sms(&mut self) -> SMS_W<SMCFGR_SPEC> {
                SMS_W::new(self, 0)
            }
            ///Bits 4:6 - Trigger selection
            #[inline(always)]
            #[must_use]
            pub fn ts(&mut self) -> TS_W<SMCFGR_SPEC> {
                TS_W::new(self, 4)
            }
            ///Bit 7 - Master/Slave mode
            #[inline(always)]
            #[must_use]
            pub fn msm(&mut self) -> MSM_W<SMCFGR_SPEC> {
                MSM_W::new(self, 7)
            }
            ///Bits 8:11 - External trigger filter
            #[inline(always)]
            #[must_use]
            pub fn etf(&mut self) -> ETF_W<SMCFGR_SPEC> {
                ETF_W::new(self, 8)
            }
            ///Bits 12:13 - External trigger prescaler
            #[inline(always)]
            #[must_use]
            pub fn etps(&mut self) -> ETPS_W<SMCFGR_SPEC> {
                ETPS_W::new(self, 12)
            }
            ///Bit 14 - External clock enable
            #[inline(always)]
            #[must_use]
            pub fn ece(&mut self) -> ECE_W<SMCFGR_SPEC> {
                ECE_W::new(self, 14)
            }
            ///Bit 15 - External trigger polarity
            #[inline(always)]
            #[must_use]
            pub fn etp(&mut self) -> ETP_W<SMCFGR_SPEC> {
                ETP_W::new(self, 15)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///slave mode control register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`smcfgr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`smcfgr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct SMCFGR_SPEC;
        impl crate::RegisterSpec for SMCFGR_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`smcfgr::R`](R) reader structure
        impl crate::Readable for SMCFGR_SPEC {}
        ///`write(|w| ..)` method takes [`smcfgr::W`](W) writer structure
        impl crate::Writable for SMCFGR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets SMCFGR to value 0
        impl crate::Resettable for SMCFGR_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///DMAINTENR (rw) register accessor: DMA/Interrupt enable register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`dmaintenr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dmaintenr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@dmaintenr`]
    ///module
    pub type DMAINTENR = crate::Reg<dmaintenr::DMAINTENR_SPEC>;
    ///DMA/Interrupt enable register
    pub mod dmaintenr {
        ///Register `DMAINTENR` reader
        pub type R = crate::R<DMAINTENR_SPEC>;
        ///Register `DMAINTENR` writer
        pub type W = crate::W<DMAINTENR_SPEC>;
        ///Field `UIE` reader - Update interrupt enable
        pub type UIE_R = crate::BitReader;
        ///Field `UIE` writer - Update interrupt enable
        pub type UIE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CC1IE` reader - Capture/Compare 1 interrupt enable
        pub type CC1IE_R = crate::BitReader;
        ///Field `CC1IE` writer - Capture/Compare 1 interrupt enable
        pub type CC1IE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CC2IE` reader - Capture/Compare 2 interrupt enable
        pub type CC2IE_R = crate::BitReader;
        ///Field `CC2IE` writer - Capture/Compare 2 interrupt enable
        pub type CC2IE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CC3IE` reader - Capture/Compare 3 interrupt enable
        pub type CC3IE_R = crate::BitReader;
        ///Field `CC3IE` writer - Capture/Compare 3 interrupt enable
        pub type CC3IE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CC4IE` reader - Capture/Compare 4 interrupt enable
        pub type CC4IE_R = crate::BitReader;
        ///Field `CC4IE` writer - Capture/Compare 4 interrupt enable
        pub type CC4IE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TIE` reader - Trigger interrupt enable
        pub type TIE_R = crate::BitReader;
        ///Field `TIE` writer - Trigger interrupt enable
        pub type TIE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UDE` reader - Update DMA request enable
        pub type UDE_R = crate::BitReader;
        ///Field `UDE` writer - Update DMA request enable
        pub type UDE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CC1DE` reader - Capture/Compare 1 DMA request enable
        pub type CC1DE_R = crate::BitReader;
        ///Field `CC1DE` writer - Capture/Compare 1 DMA request enable
        pub type CC1DE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CC2DE` reader - Capture/Compare 2 DMA request enable
        pub type CC2DE_R = crate::BitReader;
        ///Field `CC2DE` writer - Capture/Compare 2 DMA request enable
        pub type CC2DE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CC3DE` reader - Capture/Compare 3 DMA request enable
        pub type CC3DE_R = crate::BitReader;
        ///Field `CC3DE` writer - Capture/Compare 3 DMA request enable
        pub type CC3DE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CC4DE` reader - Capture/Compare 4 DMA request enable
        pub type CC4DE_R = crate::BitReader;
        ///Field `CC4DE` writer - Capture/Compare 4 DMA request enable
        pub type CC4DE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TDE` reader - Trigger DMA request enable
        pub type TDE_R = crate::BitReader;
        ///Field `TDE` writer - Trigger DMA request enable
        pub type TDE_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - Update interrupt enable
            #[inline(always)]
            pub fn uie(&self) -> UIE_R {
                UIE_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Capture/Compare 1 interrupt enable
            #[inline(always)]
            pub fn cc1ie(&self) -> CC1IE_R {
                CC1IE_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - Capture/Compare 2 interrupt enable
            #[inline(always)]
            pub fn cc2ie(&self) -> CC2IE_R {
                CC2IE_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - Capture/Compare 3 interrupt enable
            #[inline(always)]
            pub fn cc3ie(&self) -> CC3IE_R {
                CC3IE_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - Capture/Compare 4 interrupt enable
            #[inline(always)]
            pub fn cc4ie(&self) -> CC4IE_R {
                CC4IE_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 6 - Trigger interrupt enable
            #[inline(always)]
            pub fn tie(&self) -> TIE_R {
                TIE_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 8 - Update DMA request enable
            #[inline(always)]
            pub fn ude(&self) -> UDE_R {
                UDE_R::new(((self.bits >> 8) & 1) != 0)
            }
            ///Bit 9 - Capture/Compare 1 DMA request enable
            #[inline(always)]
            pub fn cc1de(&self) -> CC1DE_R {
                CC1DE_R::new(((self.bits >> 9) & 1) != 0)
            }
            ///Bit 10 - Capture/Compare 2 DMA request enable
            #[inline(always)]
            pub fn cc2de(&self) -> CC2DE_R {
                CC2DE_R::new(((self.bits >> 10) & 1) != 0)
            }
            ///Bit 11 - Capture/Compare 3 DMA request enable
            #[inline(always)]
            pub fn cc3de(&self) -> CC3DE_R {
                CC3DE_R::new(((self.bits >> 11) & 1) != 0)
            }
            ///Bit 12 - Capture/Compare 4 DMA request enable
            #[inline(always)]
            pub fn cc4de(&self) -> CC4DE_R {
                CC4DE_R::new(((self.bits >> 12) & 1) != 0)
            }
            ///Bit 14 - Trigger DMA request enable
            #[inline(always)]
            pub fn tde(&self) -> TDE_R {
                TDE_R::new(((self.bits >> 14) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - Update interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn uie(&mut self) -> UIE_W<DMAINTENR_SPEC> {
                UIE_W::new(self, 0)
            }
            ///Bit 1 - Capture/Compare 1 interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn cc1ie(&mut self) -> CC1IE_W<DMAINTENR_SPEC> {
                CC1IE_W::new(self, 1)
            }
            ///Bit 2 - Capture/Compare 2 interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn cc2ie(&mut self) -> CC2IE_W<DMAINTENR_SPEC> {
                CC2IE_W::new(self, 2)
            }
            ///Bit 3 - Capture/Compare 3 interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn cc3ie(&mut self) -> CC3IE_W<DMAINTENR_SPEC> {
                CC3IE_W::new(self, 3)
            }
            ///Bit 4 - Capture/Compare 4 interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn cc4ie(&mut self) -> CC4IE_W<DMAINTENR_SPEC> {
                CC4IE_W::new(self, 4)
            }
            ///Bit 6 - Trigger interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn tie(&mut self) -> TIE_W<DMAINTENR_SPEC> {
                TIE_W::new(self, 6)
            }
            ///Bit 8 - Update DMA request enable
            #[inline(always)]
            #[must_use]
            pub fn ude(&mut self) -> UDE_W<DMAINTENR_SPEC> {
                UDE_W::new(self, 8)
            }
            ///Bit 9 - Capture/Compare 1 DMA request enable
            #[inline(always)]
            #[must_use]
            pub fn cc1de(&mut self) -> CC1DE_W<DMAINTENR_SPEC> {
                CC1DE_W::new(self, 9)
            }
            ///Bit 10 - Capture/Compare 2 DMA request enable
            #[inline(always)]
            #[must_use]
            pub fn cc2de(&mut self) -> CC2DE_W<DMAINTENR_SPEC> {
                CC2DE_W::new(self, 10)
            }
            ///Bit 11 - Capture/Compare 3 DMA request enable
            #[inline(always)]
            #[must_use]
            pub fn cc3de(&mut self) -> CC3DE_W<DMAINTENR_SPEC> {
                CC3DE_W::new(self, 11)
            }
            ///Bit 12 - Capture/Compare 4 DMA request enable
            #[inline(always)]
            #[must_use]
            pub fn cc4de(&mut self) -> CC4DE_W<DMAINTENR_SPEC> {
                CC4DE_W::new(self, 12)
            }
            ///Bit 14 - Trigger DMA request enable
            #[inline(always)]
            #[must_use]
            pub fn tde(&mut self) -> TDE_W<DMAINTENR_SPEC> {
                TDE_W::new(self, 14)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///DMA/Interrupt enable register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`dmaintenr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dmaintenr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct DMAINTENR_SPEC;
        impl crate::RegisterSpec for DMAINTENR_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`dmaintenr::R`](R) reader structure
        impl crate::Readable for DMAINTENR_SPEC {}
        ///`write(|w| ..)` method takes [`dmaintenr::W`](W) writer structure
        impl crate::Writable for DMAINTENR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets DMAINTENR to value 0
        impl crate::Resettable for DMAINTENR_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///INTFR (rw) register accessor: status register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`intfr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`intfr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@intfr`]
    ///module
    pub type INTFR = crate::Reg<intfr::INTFR_SPEC>;
    ///status register
    pub mod intfr {
        ///Register `INTFR` reader
        pub type R = crate::R<INTFR_SPEC>;
        ///Register `INTFR` writer
        pub type W = crate::W<INTFR_SPEC>;
        ///Field `UIF` reader - Update interrupt flag
        pub type UIF_R = crate::BitReader;
        ///Field `UIF` writer - Update interrupt flag
        pub type UIF_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CC1IF` reader - Capture/compare 1 interrupt flag
        pub type CC1IF_R = crate::BitReader;
        ///Field `CC1IF` writer - Capture/compare 1 interrupt flag
        pub type CC1IF_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CC2IF` reader - Capture/Compare 2 interrupt flag
        pub type CC2IF_R = crate::BitReader;
        ///Field `CC2IF` writer - Capture/Compare 2 interrupt flag
        pub type CC2IF_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CC3IF` reader - Capture/Compare 3 interrupt flag
        pub type CC3IF_R = crate::BitReader;
        ///Field `CC3IF` writer - Capture/Compare 3 interrupt flag
        pub type CC3IF_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CC4IF` reader - Capture/Compare 4 interrupt flag
        pub type CC4IF_R = crate::BitReader;
        ///Field `CC4IF` writer - Capture/Compare 4 interrupt flag
        pub type CC4IF_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TIF` reader - Trigger interrupt flag
        pub type TIF_R = crate::BitReader;
        ///Field `TIF` writer - Trigger interrupt flag
        pub type TIF_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CC1OF` reader - Capture/Compare 1 overcapture flag
        pub type CC1OF_R = crate::BitReader;
        ///Field `CC1OF` writer - Capture/Compare 1 overcapture flag
        pub type CC1OF_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CC2OF` reader - Capture/compare 2 overcapture flag
        pub type CC2OF_R = crate::BitReader;
        ///Field `CC2OF` writer - Capture/compare 2 overcapture flag
        pub type CC2OF_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CC3OF` reader - Capture/Compare 3 overcapture flag
        pub type CC3OF_R = crate::BitReader;
        ///Field `CC3OF` writer - Capture/Compare 3 overcapture flag
        pub type CC3OF_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CC4OF` reader - Capture/Compare 4 overcapture flag
        pub type CC4OF_R = crate::BitReader;
        ///Field `CC4OF` writer - Capture/Compare 4 overcapture flag
        pub type CC4OF_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - Update interrupt flag
            #[inline(always)]
            pub fn uif(&self) -> UIF_R {
                UIF_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Capture/compare 1 interrupt flag
            #[inline(always)]
            pub fn cc1if(&self) -> CC1IF_R {
                CC1IF_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - Capture/Compare 2 interrupt flag
            #[inline(always)]
            pub fn cc2if(&self) -> CC2IF_R {
                CC2IF_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - Capture/Compare 3 interrupt flag
            #[inline(always)]
            pub fn cc3if(&self) -> CC3IF_R {
                CC3IF_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - Capture/Compare 4 interrupt flag
            #[inline(always)]
            pub fn cc4if(&self) -> CC4IF_R {
                CC4IF_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 6 - Trigger interrupt flag
            #[inline(always)]
            pub fn tif(&self) -> TIF_R {
                TIF_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 9 - Capture/Compare 1 overcapture flag
            #[inline(always)]
            pub fn cc1of(&self) -> CC1OF_R {
                CC1OF_R::new(((self.bits >> 9) & 1) != 0)
            }
            ///Bit 10 - Capture/compare 2 overcapture flag
            #[inline(always)]
            pub fn cc2of(&self) -> CC2OF_R {
                CC2OF_R::new(((self.bits >> 10) & 1) != 0)
            }
            ///Bit 11 - Capture/Compare 3 overcapture flag
            #[inline(always)]
            pub fn cc3of(&self) -> CC3OF_R {
                CC3OF_R::new(((self.bits >> 11) & 1) != 0)
            }
            ///Bit 12 - Capture/Compare 4 overcapture flag
            #[inline(always)]
            pub fn cc4of(&self) -> CC4OF_R {
                CC4OF_R::new(((self.bits >> 12) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - Update interrupt flag
            #[inline(always)]
            #[must_use]
            pub fn uif(&mut self) -> UIF_W<INTFR_SPEC> {
                UIF_W::new(self, 0)
            }
            ///Bit 1 - Capture/compare 1 interrupt flag
            #[inline(always)]
            #[must_use]
            pub fn cc1if(&mut self) -> CC1IF_W<INTFR_SPEC> {
                CC1IF_W::new(self, 1)
            }
            ///Bit 2 - Capture/Compare 2 interrupt flag
            #[inline(always)]
            #[must_use]
            pub fn cc2if(&mut self) -> CC2IF_W<INTFR_SPEC> {
                CC2IF_W::new(self, 2)
            }
            ///Bit 3 - Capture/Compare 3 interrupt flag
            #[inline(always)]
            #[must_use]
            pub fn cc3if(&mut self) -> CC3IF_W<INTFR_SPEC> {
                CC3IF_W::new(self, 3)
            }
            ///Bit 4 - Capture/Compare 4 interrupt flag
            #[inline(always)]
            #[must_use]
            pub fn cc4if(&mut self) -> CC4IF_W<INTFR_SPEC> {
                CC4IF_W::new(self, 4)
            }
            ///Bit 6 - Trigger interrupt flag
            #[inline(always)]
            #[must_use]
            pub fn tif(&mut self) -> TIF_W<INTFR_SPEC> {
                TIF_W::new(self, 6)
            }
            ///Bit 9 - Capture/Compare 1 overcapture flag
            #[inline(always)]
            #[must_use]
            pub fn cc1of(&mut self) -> CC1OF_W<INTFR_SPEC> {
                CC1OF_W::new(self, 9)
            }
            ///Bit 10 - Capture/compare 2 overcapture flag
            #[inline(always)]
            #[must_use]
            pub fn cc2of(&mut self) -> CC2OF_W<INTFR_SPEC> {
                CC2OF_W::new(self, 10)
            }
            ///Bit 11 - Capture/Compare 3 overcapture flag
            #[inline(always)]
            #[must_use]
            pub fn cc3of(&mut self) -> CC3OF_W<INTFR_SPEC> {
                CC3OF_W::new(self, 11)
            }
            ///Bit 12 - Capture/Compare 4 overcapture flag
            #[inline(always)]
            #[must_use]
            pub fn cc4of(&mut self) -> CC4OF_W<INTFR_SPEC> {
                CC4OF_W::new(self, 12)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///status register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`intfr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`intfr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct INTFR_SPEC;
        impl crate::RegisterSpec for INTFR_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`intfr::R`](R) reader structure
        impl crate::Readable for INTFR_SPEC {}
        ///`write(|w| ..)` method takes [`intfr::W`](W) writer structure
        impl crate::Writable for INTFR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets INTFR to value 0
        impl crate::Resettable for INTFR_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///SWEVGR (w) register accessor: event generation register
    ///
    ///You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`swevgr::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@swevgr`]
    ///module
    pub type SWEVGR = crate::Reg<swevgr::SWEVGR_SPEC>;
    ///event generation register
    pub mod swevgr {
        ///Register `SWEVGR` writer
        pub type W = crate::W<SWEVGR_SPEC>;
        ///Field `UG` writer - Update generation
        pub type UG_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CC1G` writer - Capture/compare 1 generation
        pub type CC1G_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CC2G` writer - Capture/compare 2 generation
        pub type CC2G_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CC3G` writer - Capture/compare 3 generation
        pub type CC3G_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CC4G` writer - Capture/compare 4 generation
        pub type CC4G_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TG` writer - Trigger generation
        pub type TG_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl W {
            ///Bit 0 - Update generation
            #[inline(always)]
            #[must_use]
            pub fn ug(&mut self) -> UG_W<SWEVGR_SPEC> {
                UG_W::new(self, 0)
            }
            ///Bit 1 - Capture/compare 1 generation
            #[inline(always)]
            #[must_use]
            pub fn cc1g(&mut self) -> CC1G_W<SWEVGR_SPEC> {
                CC1G_W::new(self, 1)
            }
            ///Bit 2 - Capture/compare 2 generation
            #[inline(always)]
            #[must_use]
            pub fn cc2g(&mut self) -> CC2G_W<SWEVGR_SPEC> {
                CC2G_W::new(self, 2)
            }
            ///Bit 3 - Capture/compare 3 generation
            #[inline(always)]
            #[must_use]
            pub fn cc3g(&mut self) -> CC3G_W<SWEVGR_SPEC> {
                CC3G_W::new(self, 3)
            }
            ///Bit 4 - Capture/compare 4 generation
            #[inline(always)]
            #[must_use]
            pub fn cc4g(&mut self) -> CC4G_W<SWEVGR_SPEC> {
                CC4G_W::new(self, 4)
            }
            ///Bit 6 - Trigger generation
            #[inline(always)]
            #[must_use]
            pub fn tg(&mut self) -> TG_W<SWEVGR_SPEC> {
                TG_W::new(self, 6)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///event generation register
        ///
        ///You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`swevgr::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct SWEVGR_SPEC;
        impl crate::RegisterSpec for SWEVGR_SPEC {
            type Ux = u16;
        }
        ///`write(|w| ..)` method takes [`swevgr::W`](W) writer structure
        impl crate::Writable for SWEVGR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets SWEVGR to value 0
        impl crate::Resettable for SWEVGR_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///CHCTLR1_Output (rw) register accessor: capture/compare mode register 1 (output mode)
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`chctlr1_output::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`chctlr1_output::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@chctlr1_output`]
    ///module
    pub type CHCTLR1_OUTPUT = crate::Reg<chctlr1_output::CHCTLR1_OUTPUT_SPEC>;
    ///capture/compare mode register 1 (output mode)
    pub mod chctlr1_output {
        ///Register `CHCTLR1_Output` reader
        pub type R = crate::R<CHCTLR1_OUTPUT_SPEC>;
        ///Register `CHCTLR1_Output` writer
        pub type W = crate::W<CHCTLR1_OUTPUT_SPEC>;
        ///Field `CC1S` reader - Capture/Compare 1 selection
        pub type CC1S_R = crate::FieldReader;
        ///Field `CC1S` writer - Capture/Compare 1 selection
        pub type CC1S_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `OC1FE` reader - Output compare 1 fast enable
        pub type OC1FE_R = crate::BitReader;
        ///Field `OC1FE` writer - Output compare 1 fast enable
        pub type OC1FE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `OC1PE` reader - Output compare 1 preload enable
        pub type OC1PE_R = crate::BitReader;
        ///Field `OC1PE` writer - Output compare 1 preload enable
        pub type OC1PE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `OC1M` reader - Output compare 1 mode
        pub type OC1M_R = crate::FieldReader;
        ///Field `OC1M` writer - Output compare 1 mode
        pub type OC1M_W<'a, REG> = crate::FieldWriter<'a, REG, 3>;
        ///Field `OC1CE` reader - Output compare 1 clear enable
        pub type OC1CE_R = crate::BitReader;
        ///Field `OC1CE` writer - Output compare 1 clear enable
        pub type OC1CE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CC2S` reader - Capture/Compare 2 selection
        pub type CC2S_R = crate::FieldReader;
        ///Field `CC2S` writer - Capture/Compare 2 selection
        pub type CC2S_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `OC2FE` reader - Output compare 2 fast enable
        pub type OC2FE_R = crate::BitReader;
        ///Field `OC2FE` writer - Output compare 2 fast enable
        pub type OC2FE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `OC2PE` reader - Output compare 2 preload enable
        pub type OC2PE_R = crate::BitReader;
        ///Field `OC2PE` writer - Output compare 2 preload enable
        pub type OC2PE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `OC2M` reader - Output compare 2 mode
        pub type OC2M_R = crate::FieldReader;
        ///Field `OC2M` writer - Output compare 2 mode
        pub type OC2M_W<'a, REG> = crate::FieldWriter<'a, REG, 3>;
        ///Field `OC2CE` reader - Output compare 2 clear enable
        pub type OC2CE_R = crate::BitReader;
        ///Field `OC2CE` writer - Output compare 2 clear enable
        pub type OC2CE_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bits 0:1 - Capture/Compare 1 selection
            #[inline(always)]
            pub fn cc1s(&self) -> CC1S_R {
                CC1S_R::new((self.bits & 3) as u8)
            }
            ///Bit 2 - Output compare 1 fast enable
            #[inline(always)]
            pub fn oc1fe(&self) -> OC1FE_R {
                OC1FE_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - Output compare 1 preload enable
            #[inline(always)]
            pub fn oc1pe(&self) -> OC1PE_R {
                OC1PE_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bits 4:6 - Output compare 1 mode
            #[inline(always)]
            pub fn oc1m(&self) -> OC1M_R {
                OC1M_R::new(((self.bits >> 4) & 7) as u8)
            }
            ///Bit 7 - Output compare 1 clear enable
            #[inline(always)]
            pub fn oc1ce(&self) -> OC1CE_R {
                OC1CE_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bits 8:9 - Capture/Compare 2 selection
            #[inline(always)]
            pub fn cc2s(&self) -> CC2S_R {
                CC2S_R::new(((self.bits >> 8) & 3) as u8)
            }
            ///Bit 10 - Output compare 2 fast enable
            #[inline(always)]
            pub fn oc2fe(&self) -> OC2FE_R {
                OC2FE_R::new(((self.bits >> 10) & 1) != 0)
            }
            ///Bit 11 - Output compare 2 preload enable
            #[inline(always)]
            pub fn oc2pe(&self) -> OC2PE_R {
                OC2PE_R::new(((self.bits >> 11) & 1) != 0)
            }
            ///Bits 12:14 - Output compare 2 mode
            #[inline(always)]
            pub fn oc2m(&self) -> OC2M_R {
                OC2M_R::new(((self.bits >> 12) & 7) as u8)
            }
            ///Bit 15 - Output compare 2 clear enable
            #[inline(always)]
            pub fn oc2ce(&self) -> OC2CE_R {
                OC2CE_R::new(((self.bits >> 15) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:1 - Capture/Compare 1 selection
            #[inline(always)]
            #[must_use]
            pub fn cc1s(&mut self) -> CC1S_W<CHCTLR1_OUTPUT_SPEC> {
                CC1S_W::new(self, 0)
            }
            ///Bit 2 - Output compare 1 fast enable
            #[inline(always)]
            #[must_use]
            pub fn oc1fe(&mut self) -> OC1FE_W<CHCTLR1_OUTPUT_SPEC> {
                OC1FE_W::new(self, 2)
            }
            ///Bit 3 - Output compare 1 preload enable
            #[inline(always)]
            #[must_use]
            pub fn oc1pe(&mut self) -> OC1PE_W<CHCTLR1_OUTPUT_SPEC> {
                OC1PE_W::new(self, 3)
            }
            ///Bits 4:6 - Output compare 1 mode
            #[inline(always)]
            #[must_use]
            pub fn oc1m(&mut self) -> OC1M_W<CHCTLR1_OUTPUT_SPEC> {
                OC1M_W::new(self, 4)
            }
            ///Bit 7 - Output compare 1 clear enable
            #[inline(always)]
            #[must_use]
            pub fn oc1ce(&mut self) -> OC1CE_W<CHCTLR1_OUTPUT_SPEC> {
                OC1CE_W::new(self, 7)
            }
            ///Bits 8:9 - Capture/Compare 2 selection
            #[inline(always)]
            #[must_use]
            pub fn cc2s(&mut self) -> CC2S_W<CHCTLR1_OUTPUT_SPEC> {
                CC2S_W::new(self, 8)
            }
            ///Bit 10 - Output compare 2 fast enable
            #[inline(always)]
            #[must_use]
            pub fn oc2fe(&mut self) -> OC2FE_W<CHCTLR1_OUTPUT_SPEC> {
                OC2FE_W::new(self, 10)
            }
            ///Bit 11 - Output compare 2 preload enable
            #[inline(always)]
            #[must_use]
            pub fn oc2pe(&mut self) -> OC2PE_W<CHCTLR1_OUTPUT_SPEC> {
                OC2PE_W::new(self, 11)
            }
            ///Bits 12:14 - Output compare 2 mode
            #[inline(always)]
            #[must_use]
            pub fn oc2m(&mut self) -> OC2M_W<CHCTLR1_OUTPUT_SPEC> {
                OC2M_W::new(self, 12)
            }
            ///Bit 15 - Output compare 2 clear enable
            #[inline(always)]
            #[must_use]
            pub fn oc2ce(&mut self) -> OC2CE_W<CHCTLR1_OUTPUT_SPEC> {
                OC2CE_W::new(self, 15)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///capture/compare mode register 1 (output mode)
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`chctlr1_output::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`chctlr1_output::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct CHCTLR1_OUTPUT_SPEC;
        impl crate::RegisterSpec for CHCTLR1_OUTPUT_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`chctlr1_output::R`](R) reader structure
        impl crate::Readable for CHCTLR1_OUTPUT_SPEC {}
        ///`write(|w| ..)` method takes [`chctlr1_output::W`](W) writer structure
        impl crate::Writable for CHCTLR1_OUTPUT_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets CHCTLR1_Output to value 0
        impl crate::Resettable for CHCTLR1_OUTPUT_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///CHCTLR1_Input (rw) register accessor: capture/compare mode register 1 (input mode)
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`chctlr1_input::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`chctlr1_input::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@chctlr1_input`]
    ///module
    pub type CHCTLR1_INPUT = crate::Reg<chctlr1_input::CHCTLR1_INPUT_SPEC>;
    ///capture/compare mode register 1 (input mode)
    pub mod chctlr1_input {
        ///Register `CHCTLR1_Input` reader
        pub type R = crate::R<CHCTLR1_INPUT_SPEC>;
        ///Register `CHCTLR1_Input` writer
        pub type W = crate::W<CHCTLR1_INPUT_SPEC>;
        ///Field `CC1S` reader - Capture/Compare 1 selection
        pub type CC1S_R = crate::FieldReader;
        ///Field `CC1S` writer - Capture/Compare 1 selection
        pub type CC1S_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `IC1PSC` reader - Input capture 1 prescaler
        pub type IC1PSC_R = crate::FieldReader;
        ///Field `IC1PSC` writer - Input capture 1 prescaler
        pub type IC1PSC_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `IC1F` reader - Input capture 1 filter
        pub type IC1F_R = crate::FieldReader;
        ///Field `IC1F` writer - Input capture 1 filter
        pub type IC1F_W<'a, REG> = crate::FieldWriter<'a, REG, 4>;
        ///Field `CC2S` reader - Capture/compare 2 selection
        pub type CC2S_R = crate::FieldReader;
        ///Field `CC2S` writer - Capture/compare 2 selection
        pub type CC2S_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `IC2PSC` reader - Input capture 2 prescaler
        pub type IC2PSC_R = crate::FieldReader;
        ///Field `IC2PSC` writer - Input capture 2 prescaler
        pub type IC2PSC_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `IC2F` reader - Input capture 2 filter
        pub type IC2F_R = crate::FieldReader;
        ///Field `IC2F` writer - Input capture 2 filter
        pub type IC2F_W<'a, REG> = crate::FieldWriter<'a, REG, 4>;
        impl R {
            ///Bits 0:1 - Capture/Compare 1 selection
            #[inline(always)]
            pub fn cc1s(&self) -> CC1S_R {
                CC1S_R::new((self.bits & 3) as u8)
            }
            ///Bits 2:3 - Input capture 1 prescaler
            #[inline(always)]
            pub fn ic1psc(&self) -> IC1PSC_R {
                IC1PSC_R::new(((self.bits >> 2) & 3) as u8)
            }
            ///Bits 4:7 - Input capture 1 filter
            #[inline(always)]
            pub fn ic1f(&self) -> IC1F_R {
                IC1F_R::new(((self.bits >> 4) & 0x0f) as u8)
            }
            ///Bits 8:9 - Capture/compare 2 selection
            #[inline(always)]
            pub fn cc2s(&self) -> CC2S_R {
                CC2S_R::new(((self.bits >> 8) & 3) as u8)
            }
            ///Bits 10:11 - Input capture 2 prescaler
            #[inline(always)]
            pub fn ic2psc(&self) -> IC2PSC_R {
                IC2PSC_R::new(((self.bits >> 10) & 3) as u8)
            }
            ///Bits 12:15 - Input capture 2 filter
            #[inline(always)]
            pub fn ic2f(&self) -> IC2F_R {
                IC2F_R::new(((self.bits >> 12) & 0x0f) as u8)
            }
        }
        impl W {
            ///Bits 0:1 - Capture/Compare 1 selection
            #[inline(always)]
            #[must_use]
            pub fn cc1s(&mut self) -> CC1S_W<CHCTLR1_INPUT_SPEC> {
                CC1S_W::new(self, 0)
            }
            ///Bits 2:3 - Input capture 1 prescaler
            #[inline(always)]
            #[must_use]
            pub fn ic1psc(&mut self) -> IC1PSC_W<CHCTLR1_INPUT_SPEC> {
                IC1PSC_W::new(self, 2)
            }
            ///Bits 4:7 - Input capture 1 filter
            #[inline(always)]
            #[must_use]
            pub fn ic1f(&mut self) -> IC1F_W<CHCTLR1_INPUT_SPEC> {
                IC1F_W::new(self, 4)
            }
            ///Bits 8:9 - Capture/compare 2 selection
            #[inline(always)]
            #[must_use]
            pub fn cc2s(&mut self) -> CC2S_W<CHCTLR1_INPUT_SPEC> {
                CC2S_W::new(self, 8)
            }
            ///Bits 10:11 - Input capture 2 prescaler
            #[inline(always)]
            #[must_use]
            pub fn ic2psc(&mut self) -> IC2PSC_W<CHCTLR1_INPUT_SPEC> {
                IC2PSC_W::new(self, 10)
            }
            ///Bits 12:15 - Input capture 2 filter
            #[inline(always)]
            #[must_use]
            pub fn ic2f(&mut self) -> IC2F_W<CHCTLR1_INPUT_SPEC> {
                IC2F_W::new(self, 12)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///capture/compare mode register 1 (input mode)
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`chctlr1_input::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`chctlr1_input::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct CHCTLR1_INPUT_SPEC;
        impl crate::RegisterSpec for CHCTLR1_INPUT_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`chctlr1_input::R`](R) reader structure
        impl crate::Readable for CHCTLR1_INPUT_SPEC {}
        ///`write(|w| ..)` method takes [`chctlr1_input::W`](W) writer structure
        impl crate::Writable for CHCTLR1_INPUT_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets CHCTLR1_Input to value 0
        impl crate::Resettable for CHCTLR1_INPUT_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///CHCTLR2_Output (rw) register accessor: capture/compare mode register 2 (output mode)
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`chctlr2_output::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`chctlr2_output::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@chctlr2_output`]
    ///module
    pub type CHCTLR2_OUTPUT = crate::Reg<chctlr2_output::CHCTLR2_OUTPUT_SPEC>;
    ///capture/compare mode register 2 (output mode)
    pub mod chctlr2_output {
        ///Register `CHCTLR2_Output` reader
        pub type R = crate::R<CHCTLR2_OUTPUT_SPEC>;
        ///Register `CHCTLR2_Output` writer
        pub type W = crate::W<CHCTLR2_OUTPUT_SPEC>;
        ///Field `CC3S` reader - Capture/Compare 3 selection
        pub type CC3S_R = crate::FieldReader;
        ///Field `CC3S` writer - Capture/Compare 3 selection
        pub type CC3S_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `OC3FE` reader - Output compare 3 fast enable
        pub type OC3FE_R = crate::BitReader;
        ///Field `OC3FE` writer - Output compare 3 fast enable
        pub type OC3FE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `OC3PE` reader - Output compare 3 preload enable
        pub type OC3PE_R = crate::BitReader;
        ///Field `OC3PE` writer - Output compare 3 preload enable
        pub type OC3PE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `OC3M` reader - Output compare 3 mode
        pub type OC3M_R = crate::FieldReader;
        ///Field `OC3M` writer - Output compare 3 mode
        pub type OC3M_W<'a, REG> = crate::FieldWriter<'a, REG, 3>;
        ///Field `OC3CE` reader - Output compare 3 clear enable
        pub type OC3CE_R = crate::BitReader;
        ///Field `OC3CE` writer - Output compare 3 clear enable
        pub type OC3CE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CC4S` reader - Capture/Compare 4 selection
        pub type CC4S_R = crate::FieldReader;
        ///Field `CC4S` writer - Capture/Compare 4 selection
        pub type CC4S_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `OC4FE` reader - Output compare 4 fast enable
        pub type OC4FE_R = crate::BitReader;
        ///Field `OC4FE` writer - Output compare 4 fast enable
        pub type OC4FE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `OC4PE` reader - Output compare 4 preload enable
        pub type OC4PE_R = crate::BitReader;
        ///Field `OC4PE` writer - Output compare 4 preload enable
        pub type OC4PE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `OC4M` reader - Output compare 4 mode
        pub type OC4M_R = crate::FieldReader;
        ///Field `OC4M` writer - Output compare 4 mode
        pub type OC4M_W<'a, REG> = crate::FieldWriter<'a, REG, 3>;
        ///Field `OC4CE` reader - Output compare 4 clear enable
        pub type OC4CE_R = crate::BitReader;
        ///Field `OC4CE` writer - Output compare 4 clear enable
        pub type OC4CE_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bits 0:1 - Capture/Compare 3 selection
            #[inline(always)]
            pub fn cc3s(&self) -> CC3S_R {
                CC3S_R::new((self.bits & 3) as u8)
            }
            ///Bit 2 - Output compare 3 fast enable
            #[inline(always)]
            pub fn oc3fe(&self) -> OC3FE_R {
                OC3FE_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - Output compare 3 preload enable
            #[inline(always)]
            pub fn oc3pe(&self) -> OC3PE_R {
                OC3PE_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bits 4:6 - Output compare 3 mode
            #[inline(always)]
            pub fn oc3m(&self) -> OC3M_R {
                OC3M_R::new(((self.bits >> 4) & 7) as u8)
            }
            ///Bit 7 - Output compare 3 clear enable
            #[inline(always)]
            pub fn oc3ce(&self) -> OC3CE_R {
                OC3CE_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bits 8:9 - Capture/Compare 4 selection
            #[inline(always)]
            pub fn cc4s(&self) -> CC4S_R {
                CC4S_R::new(((self.bits >> 8) & 3) as u8)
            }
            ///Bit 10 - Output compare 4 fast enable
            #[inline(always)]
            pub fn oc4fe(&self) -> OC4FE_R {
                OC4FE_R::new(((self.bits >> 10) & 1) != 0)
            }
            ///Bit 11 - Output compare 4 preload enable
            #[inline(always)]
            pub fn oc4pe(&self) -> OC4PE_R {
                OC4PE_R::new(((self.bits >> 11) & 1) != 0)
            }
            ///Bits 12:14 - Output compare 4 mode
            #[inline(always)]
            pub fn oc4m(&self) -> OC4M_R {
                OC4M_R::new(((self.bits >> 12) & 7) as u8)
            }
            ///Bit 15 - Output compare 4 clear enable
            #[inline(always)]
            pub fn oc4ce(&self) -> OC4CE_R {
                OC4CE_R::new(((self.bits >> 15) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:1 - Capture/Compare 3 selection
            #[inline(always)]
            #[must_use]
            pub fn cc3s(&mut self) -> CC3S_W<CHCTLR2_OUTPUT_SPEC> {
                CC3S_W::new(self, 0)
            }
            ///Bit 2 - Output compare 3 fast enable
            #[inline(always)]
            #[must_use]
            pub fn oc3fe(&mut self) -> OC3FE_W<CHCTLR2_OUTPUT_SPEC> {
                OC3FE_W::new(self, 2)
            }
            ///Bit 3 - Output compare 3 preload enable
            #[inline(always)]
            #[must_use]
            pub fn oc3pe(&mut self) -> OC3PE_W<CHCTLR2_OUTPUT_SPEC> {
                OC3PE_W::new(self, 3)
            }
            ///Bits 4:6 - Output compare 3 mode
            #[inline(always)]
            #[must_use]
            pub fn oc3m(&mut self) -> OC3M_W<CHCTLR2_OUTPUT_SPEC> {
                OC3M_W::new(self, 4)
            }
            ///Bit 7 - Output compare 3 clear enable
            #[inline(always)]
            #[must_use]
            pub fn oc3ce(&mut self) -> OC3CE_W<CHCTLR2_OUTPUT_SPEC> {
                OC3CE_W::new(self, 7)
            }
            ///Bits 8:9 - Capture/Compare 4 selection
            #[inline(always)]
            #[must_use]
            pub fn cc4s(&mut self) -> CC4S_W<CHCTLR2_OUTPUT_SPEC> {
                CC4S_W::new(self, 8)
            }
            ///Bit 10 - Output compare 4 fast enable
            #[inline(always)]
            #[must_use]
            pub fn oc4fe(&mut self) -> OC4FE_W<CHCTLR2_OUTPUT_SPEC> {
                OC4FE_W::new(self, 10)
            }
            ///Bit 11 - Output compare 4 preload enable
            #[inline(always)]
            #[must_use]
            pub fn oc4pe(&mut self) -> OC4PE_W<CHCTLR2_OUTPUT_SPEC> {
                OC4PE_W::new(self, 11)
            }
            ///Bits 12:14 - Output compare 4 mode
            #[inline(always)]
            #[must_use]
            pub fn oc4m(&mut self) -> OC4M_W<CHCTLR2_OUTPUT_SPEC> {
                OC4M_W::new(self, 12)
            }
            ///Bit 15 - Output compare 4 clear enable
            #[inline(always)]
            #[must_use]
            pub fn oc4ce(&mut self) -> OC4CE_W<CHCTLR2_OUTPUT_SPEC> {
                OC4CE_W::new(self, 15)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///capture/compare mode register 2 (output mode)
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`chctlr2_output::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`chctlr2_output::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct CHCTLR2_OUTPUT_SPEC;
        impl crate::RegisterSpec for CHCTLR2_OUTPUT_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`chctlr2_output::R`](R) reader structure
        impl crate::Readable for CHCTLR2_OUTPUT_SPEC {}
        ///`write(|w| ..)` method takes [`chctlr2_output::W`](W) writer structure
        impl crate::Writable for CHCTLR2_OUTPUT_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets CHCTLR2_Output to value 0
        impl crate::Resettable for CHCTLR2_OUTPUT_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///CHCTLR2_Input (rw) register accessor: capture/compare mode register 2 (input mode)
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`chctlr2_input::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`chctlr2_input::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@chctlr2_input`]
    ///module
    pub type CHCTLR2_INPUT = crate::Reg<chctlr2_input::CHCTLR2_INPUT_SPEC>;
    ///capture/compare mode register 2 (input mode)
    pub mod chctlr2_input {
        ///Register `CHCTLR2_Input` reader
        pub type R = crate::R<CHCTLR2_INPUT_SPEC>;
        ///Register `CHCTLR2_Input` writer
        pub type W = crate::W<CHCTLR2_INPUT_SPEC>;
        ///Field `CC3S` reader - Capture/Compare 3 selection
        pub type CC3S_R = crate::FieldReader;
        ///Field `CC3S` writer - Capture/Compare 3 selection
        pub type CC3S_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `IC3PSC` reader - Input capture 3 prescaler
        pub type IC3PSC_R = crate::FieldReader;
        ///Field `IC3PSC` writer - Input capture 3 prescaler
        pub type IC3PSC_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `IC3F` reader - Input capture 3 filter
        pub type IC3F_R = crate::FieldReader;
        ///Field `IC3F` writer - Input capture 3 filter
        pub type IC3F_W<'a, REG> = crate::FieldWriter<'a, REG, 4>;
        ///Field `CC4S` reader - Capture/Compare 4 selection
        pub type CC4S_R = crate::FieldReader;
        ///Field `CC4S` writer - Capture/Compare 4 selection
        pub type CC4S_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `IC4PSC` reader - Input capture 4 prescaler
        pub type IC4PSC_R = crate::FieldReader;
        ///Field `IC4PSC` writer - Input capture 4 prescaler
        pub type IC4PSC_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `IC4F` reader - Input capture 4 filter
        pub type IC4F_R = crate::FieldReader;
        ///Field `IC4F` writer - Input capture 4 filter
        pub type IC4F_W<'a, REG> = crate::FieldWriter<'a, REG, 4>;
        impl R {
            ///Bits 0:1 - Capture/Compare 3 selection
            #[inline(always)]
            pub fn cc3s(&self) -> CC3S_R {
                CC3S_R::new((self.bits & 3) as u8)
            }
            ///Bits 2:3 - Input capture 3 prescaler
            #[inline(always)]
            pub fn ic3psc(&self) -> IC3PSC_R {
                IC3PSC_R::new(((self.bits >> 2) & 3) as u8)
            }
            ///Bits 4:7 - Input capture 3 filter
            #[inline(always)]
            pub fn ic3f(&self) -> IC3F_R {
                IC3F_R::new(((self.bits >> 4) & 0x0f) as u8)
            }
            ///Bits 8:9 - Capture/Compare 4 selection
            #[inline(always)]
            pub fn cc4s(&self) -> CC4S_R {
                CC4S_R::new(((self.bits >> 8) & 3) as u8)
            }
            ///Bits 10:11 - Input capture 4 prescaler
            #[inline(always)]
            pub fn ic4psc(&self) -> IC4PSC_R {
                IC4PSC_R::new(((self.bits >> 10) & 3) as u8)
            }
            ///Bits 12:15 - Input capture 4 filter
            #[inline(always)]
            pub fn ic4f(&self) -> IC4F_R {
                IC4F_R::new(((self.bits >> 12) & 0x0f) as u8)
            }
        }
        impl W {
            ///Bits 0:1 - Capture/Compare 3 selection
            #[inline(always)]
            #[must_use]
            pub fn cc3s(&mut self) -> CC3S_W<CHCTLR2_INPUT_SPEC> {
                CC3S_W::new(self, 0)
            }
            ///Bits 2:3 - Input capture 3 prescaler
            #[inline(always)]
            #[must_use]
            pub fn ic3psc(&mut self) -> IC3PSC_W<CHCTLR2_INPUT_SPEC> {
                IC3PSC_W::new(self, 2)
            }
            ///Bits 4:7 - Input capture 3 filter
            #[inline(always)]
            #[must_use]
            pub fn ic3f(&mut self) -> IC3F_W<CHCTLR2_INPUT_SPEC> {
                IC3F_W::new(self, 4)
            }
            ///Bits 8:9 - Capture/Compare 4 selection
            #[inline(always)]
            #[must_use]
            pub fn cc4s(&mut self) -> CC4S_W<CHCTLR2_INPUT_SPEC> {
                CC4S_W::new(self, 8)
            }
            ///Bits 10:11 - Input capture 4 prescaler
            #[inline(always)]
            #[must_use]
            pub fn ic4psc(&mut self) -> IC4PSC_W<CHCTLR2_INPUT_SPEC> {
                IC4PSC_W::new(self, 10)
            }
            ///Bits 12:15 - Input capture 4 filter
            #[inline(always)]
            #[must_use]
            pub fn ic4f(&mut self) -> IC4F_W<CHCTLR2_INPUT_SPEC> {
                IC4F_W::new(self, 12)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///capture/compare mode register 2 (input mode)
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`chctlr2_input::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`chctlr2_input::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct CHCTLR2_INPUT_SPEC;
        impl crate::RegisterSpec for CHCTLR2_INPUT_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`chctlr2_input::R`](R) reader structure
        impl crate::Readable for CHCTLR2_INPUT_SPEC {}
        ///`write(|w| ..)` method takes [`chctlr2_input::W`](W) writer structure
        impl crate::Writable for CHCTLR2_INPUT_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets CHCTLR2_Input to value 0
        impl crate::Resettable for CHCTLR2_INPUT_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///CCER (rw) register accessor: capture/compare enable register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`ccer::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ccer::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@ccer`]
    ///module
    pub type CCER = crate::Reg<ccer::CCER_SPEC>;
    ///capture/compare enable register
    pub mod ccer {
        ///Register `CCER` reader
        pub type R = crate::R<CCER_SPEC>;
        ///Register `CCER` writer
        pub type W = crate::W<CCER_SPEC>;
        ///Field `CC1E` reader - Capture/Compare 1 output enable
        pub type CC1E_R = crate::BitReader;
        ///Field `CC1E` writer - Capture/Compare 1 output enable
        pub type CC1E_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CC1P` reader - Capture/Compare 1 output Polarity
        pub type CC1P_R = crate::BitReader;
        ///Field `CC1P` writer - Capture/Compare 1 output Polarity
        pub type CC1P_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CC2E` reader - Capture/Compare 2 output enable
        pub type CC2E_R = crate::BitReader;
        ///Field `CC2E` writer - Capture/Compare 2 output enable
        pub type CC2E_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CC2P` reader - Capture/Compare 2 output Polarity
        pub type CC2P_R = crate::BitReader;
        ///Field `CC2P` writer - Capture/Compare 2 output Polarity
        pub type CC2P_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CC3E` reader - Capture/Compare 3 output enable
        pub type CC3E_R = crate::BitReader;
        ///Field `CC3E` writer - Capture/Compare 3 output enable
        pub type CC3E_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CC3P` reader - Capture/Compare 3 output Polarity
        pub type CC3P_R = crate::BitReader;
        ///Field `CC3P` writer - Capture/Compare 3 output Polarity
        pub type CC3P_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CC4E` reader - Capture/Compare 4 output enable
        pub type CC4E_R = crate::BitReader;
        ///Field `CC4E` writer - Capture/Compare 4 output enable
        pub type CC4E_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CC4P` reader - Capture/Compare 3 output Polarity
        pub type CC4P_R = crate::BitReader;
        ///Field `CC4P` writer - Capture/Compare 3 output Polarity
        pub type CC4P_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - Capture/Compare 1 output enable
            #[inline(always)]
            pub fn cc1e(&self) -> CC1E_R {
                CC1E_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Capture/Compare 1 output Polarity
            #[inline(always)]
            pub fn cc1p(&self) -> CC1P_R {
                CC1P_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 4 - Capture/Compare 2 output enable
            #[inline(always)]
            pub fn cc2e(&self) -> CC2E_R {
                CC2E_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - Capture/Compare 2 output Polarity
            #[inline(always)]
            pub fn cc2p(&self) -> CC2P_R {
                CC2P_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 8 - Capture/Compare 3 output enable
            #[inline(always)]
            pub fn cc3e(&self) -> CC3E_R {
                CC3E_R::new(((self.bits >> 8) & 1) != 0)
            }
            ///Bit 9 - Capture/Compare 3 output Polarity
            #[inline(always)]
            pub fn cc3p(&self) -> CC3P_R {
                CC3P_R::new(((self.bits >> 9) & 1) != 0)
            }
            ///Bit 12 - Capture/Compare 4 output enable
            #[inline(always)]
            pub fn cc4e(&self) -> CC4E_R {
                CC4E_R::new(((self.bits >> 12) & 1) != 0)
            }
            ///Bit 13 - Capture/Compare 3 output Polarity
            #[inline(always)]
            pub fn cc4p(&self) -> CC4P_R {
                CC4P_R::new(((self.bits >> 13) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - Capture/Compare 1 output enable
            #[inline(always)]
            #[must_use]
            pub fn cc1e(&mut self) -> CC1E_W<CCER_SPEC> {
                CC1E_W::new(self, 0)
            }
            ///Bit 1 - Capture/Compare 1 output Polarity
            #[inline(always)]
            #[must_use]
            pub fn cc1p(&mut self) -> CC1P_W<CCER_SPEC> {
                CC1P_W::new(self, 1)
            }
            ///Bit 4 - Capture/Compare 2 output enable
            #[inline(always)]
            #[must_use]
            pub fn cc2e(&mut self) -> CC2E_W<CCER_SPEC> {
                CC2E_W::new(self, 4)
            }
            ///Bit 5 - Capture/Compare 2 output Polarity
            #[inline(always)]
            #[must_use]
            pub fn cc2p(&mut self) -> CC2P_W<CCER_SPEC> {
                CC2P_W::new(self, 5)
            }
            ///Bit 8 - Capture/Compare 3 output enable
            #[inline(always)]
            #[must_use]
            pub fn cc3e(&mut self) -> CC3E_W<CCER_SPEC> {
                CC3E_W::new(self, 8)
            }
            ///Bit 9 - Capture/Compare 3 output Polarity
            #[inline(always)]
            #[must_use]
            pub fn cc3p(&mut self) -> CC3P_W<CCER_SPEC> {
                CC3P_W::new(self, 9)
            }
            ///Bit 12 - Capture/Compare 4 output enable
            #[inline(always)]
            #[must_use]
            pub fn cc4e(&mut self) -> CC4E_W<CCER_SPEC> {
                CC4E_W::new(self, 12)
            }
            ///Bit 13 - Capture/Compare 3 output Polarity
            #[inline(always)]
            #[must_use]
            pub fn cc4p(&mut self) -> CC4P_W<CCER_SPEC> {
                CC4P_W::new(self, 13)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///capture/compare enable register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`ccer::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ccer::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct CCER_SPEC;
        impl crate::RegisterSpec for CCER_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`ccer::R`](R) reader structure
        impl crate::Readable for CCER_SPEC {}
        ///`write(|w| ..)` method takes [`ccer::W`](W) writer structure
        impl crate::Writable for CCER_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets CCER to value 0
        impl crate::Resettable for CCER_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///CNT (rw) register accessor: counter
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`cnt::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cnt::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@cnt`]
    ///module
    pub type CNT = crate::Reg<cnt::CNT_SPEC>;
    ///counter
    pub mod cnt {
        ///Register `CNT` reader
        pub type R = crate::R<CNT_SPEC>;
        ///Register `CNT` writer
        pub type W = crate::W<CNT_SPEC>;
        ///Field `CNT` reader - counter value
        pub type CNT_R = crate::FieldReader<u16>;
        ///Field `CNT` writer - counter value
        pub type CNT_W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            ///Bits 0:15 - counter value
            #[inline(always)]
            pub fn cnt(&self) -> CNT_R {
                CNT_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - counter value
            #[inline(always)]
            #[must_use]
            pub fn cnt(&mut self) -> CNT_W<CNT_SPEC> {
                CNT_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///counter
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`cnt::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cnt::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct CNT_SPEC;
        impl crate::RegisterSpec for CNT_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`cnt::R`](R) reader structure
        impl crate::Readable for CNT_SPEC {}
        ///`write(|w| ..)` method takes [`cnt::W`](W) writer structure
        impl crate::Writable for CNT_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets CNT to value 0
        impl crate::Resettable for CNT_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///PSC (rw) register accessor: prescaler
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`psc::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`psc::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@psc`]
    ///module
    pub type PSC = crate::Reg<psc::PSC_SPEC>;
    ///prescaler
    pub mod psc {
        ///Register `PSC` reader
        pub type R = crate::R<PSC_SPEC>;
        ///Register `PSC` writer
        pub type W = crate::W<PSC_SPEC>;
        ///Field `PSC` reader - Prescaler value
        pub type PSC_R = crate::FieldReader<u16>;
        ///Field `PSC` writer - Prescaler value
        pub type PSC_W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            ///Bits 0:15 - Prescaler value
            #[inline(always)]
            pub fn psc(&self) -> PSC_R {
                PSC_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - Prescaler value
            #[inline(always)]
            #[must_use]
            pub fn psc(&mut self) -> PSC_W<PSC_SPEC> {
                PSC_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///prescaler
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`psc::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`psc::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct PSC_SPEC;
        impl crate::RegisterSpec for PSC_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`psc::R`](R) reader structure
        impl crate::Readable for PSC_SPEC {}
        ///`write(|w| ..)` method takes [`psc::W`](W) writer structure
        impl crate::Writable for PSC_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets PSC to value 0
        impl crate::Resettable for PSC_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///ATRLR (rw) register accessor: auto-reload register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`atrlr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`atrlr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@atrlr`]
    ///module
    pub type ATRLR = crate::Reg<atrlr::ATRLR_SPEC>;
    ///auto-reload register
    pub mod atrlr {
        ///Register `ATRLR` reader
        pub type R = crate::R<ATRLR_SPEC>;
        ///Register `ATRLR` writer
        pub type W = crate::W<ATRLR_SPEC>;
        ///Field `ARR` reader - Auto-reload value
        pub type ARR_R = crate::FieldReader<u16>;
        ///Field `ARR` writer - Auto-reload value
        pub type ARR_W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            ///Bits 0:15 - Auto-reload value
            #[inline(always)]
            pub fn arr(&self) -> ARR_R {
                ARR_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - Auto-reload value
            #[inline(always)]
            #[must_use]
            pub fn arr(&mut self) -> ARR_W<ATRLR_SPEC> {
                ARR_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///auto-reload register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`atrlr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`atrlr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct ATRLR_SPEC;
        impl crate::RegisterSpec for ATRLR_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`atrlr::R`](R) reader structure
        impl crate::Readable for ATRLR_SPEC {}
        ///`write(|w| ..)` method takes [`atrlr::W`](W) writer structure
        impl crate::Writable for ATRLR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets ATRLR to value 0
        impl crate::Resettable for ATRLR_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///CH1CVR (rw) register accessor: capture/compare register 1
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`ch1cvr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ch1cvr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@ch1cvr`]
    ///module
    pub type CH1CVR = crate::Reg<ch1cvr::CH1CVR_SPEC>;
    ///capture/compare register 1
    pub mod ch1cvr {
        ///Register `CH1CVR` reader
        pub type R = crate::R<CH1CVR_SPEC>;
        ///Register `CH1CVR` writer
        pub type W = crate::W<CH1CVR_SPEC>;
        ///Field `CCR1` reader - Capture/Compare 1 value
        pub type CCR1_R = crate::FieldReader<u16>;
        ///Field `CCR1` writer - Capture/Compare 1 value
        pub type CCR1_W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            ///Bits 0:15 - Capture/Compare 1 value
            #[inline(always)]
            pub fn ccr1(&self) -> CCR1_R {
                CCR1_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - Capture/Compare 1 value
            #[inline(always)]
            #[must_use]
            pub fn ccr1(&mut self) -> CCR1_W<CH1CVR_SPEC> {
                CCR1_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///capture/compare register 1
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`ch1cvr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ch1cvr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct CH1CVR_SPEC;
        impl crate::RegisterSpec for CH1CVR_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`ch1cvr::R`](R) reader structure
        impl crate::Readable for CH1CVR_SPEC {}
        ///`write(|w| ..)` method takes [`ch1cvr::W`](W) writer structure
        impl crate::Writable for CH1CVR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets CH1CVR to value 0
        impl crate::Resettable for CH1CVR_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///CH2CVR (rw) register accessor: capture/compare register 2
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`ch2cvr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ch2cvr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@ch2cvr`]
    ///module
    pub type CH2CVR = crate::Reg<ch2cvr::CH2CVR_SPEC>;
    ///capture/compare register 2
    pub mod ch2cvr {
        ///Register `CH2CVR` reader
        pub type R = crate::R<CH2CVR_SPEC>;
        ///Register `CH2CVR` writer
        pub type W = crate::W<CH2CVR_SPEC>;
        ///Field `CCR2` reader - Capture/Compare 2 value
        pub type CCR2_R = crate::FieldReader<u16>;
        ///Field `CCR2` writer - Capture/Compare 2 value
        pub type CCR2_W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            ///Bits 0:15 - Capture/Compare 2 value
            #[inline(always)]
            pub fn ccr2(&self) -> CCR2_R {
                CCR2_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - Capture/Compare 2 value
            #[inline(always)]
            #[must_use]
            pub fn ccr2(&mut self) -> CCR2_W<CH2CVR_SPEC> {
                CCR2_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///capture/compare register 2
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`ch2cvr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ch2cvr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct CH2CVR_SPEC;
        impl crate::RegisterSpec for CH2CVR_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`ch2cvr::R`](R) reader structure
        impl crate::Readable for CH2CVR_SPEC {}
        ///`write(|w| ..)` method takes [`ch2cvr::W`](W) writer structure
        impl crate::Writable for CH2CVR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets CH2CVR to value 0
        impl crate::Resettable for CH2CVR_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///CH3CVR (rw) register accessor: capture/compare register 3
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`ch3cvr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ch3cvr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@ch3cvr`]
    ///module
    pub type CH3CVR = crate::Reg<ch3cvr::CH3CVR_SPEC>;
    ///capture/compare register 3
    pub mod ch3cvr {
        ///Register `CH3CVR` reader
        pub type R = crate::R<CH3CVR_SPEC>;
        ///Register `CH3CVR` writer
        pub type W = crate::W<CH3CVR_SPEC>;
        ///Field `CCR3` reader - Capture/Compare value
        pub type CCR3_R = crate::FieldReader<u16>;
        ///Field `CCR3` writer - Capture/Compare value
        pub type CCR3_W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            ///Bits 0:15 - Capture/Compare value
            #[inline(always)]
            pub fn ccr3(&self) -> CCR3_R {
                CCR3_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - Capture/Compare value
            #[inline(always)]
            #[must_use]
            pub fn ccr3(&mut self) -> CCR3_W<CH3CVR_SPEC> {
                CCR3_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///capture/compare register 3
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`ch3cvr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ch3cvr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct CH3CVR_SPEC;
        impl crate::RegisterSpec for CH3CVR_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`ch3cvr::R`](R) reader structure
        impl crate::Readable for CH3CVR_SPEC {}
        ///`write(|w| ..)` method takes [`ch3cvr::W`](W) writer structure
        impl crate::Writable for CH3CVR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets CH3CVR to value 0
        impl crate::Resettable for CH3CVR_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///CH4CVR (rw) register accessor: capture/compare register 4
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`ch4cvr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ch4cvr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@ch4cvr`]
    ///module
    pub type CH4CVR = crate::Reg<ch4cvr::CH4CVR_SPEC>;
    ///capture/compare register 4
    pub mod ch4cvr {
        ///Register `CH4CVR` reader
        pub type R = crate::R<CH4CVR_SPEC>;
        ///Register `CH4CVR` writer
        pub type W = crate::W<CH4CVR_SPEC>;
        ///Field `CCR4` reader - Capture/Compare value
        pub type CCR4_R = crate::FieldReader<u16>;
        ///Field `CCR4` writer - Capture/Compare value
        pub type CCR4_W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            ///Bits 0:15 - Capture/Compare value
            #[inline(always)]
            pub fn ccr4(&self) -> CCR4_R {
                CCR4_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - Capture/Compare value
            #[inline(always)]
            #[must_use]
            pub fn ccr4(&mut self) -> CCR4_W<CH4CVR_SPEC> {
                CCR4_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///capture/compare register 4
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`ch4cvr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ch4cvr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct CH4CVR_SPEC;
        impl crate::RegisterSpec for CH4CVR_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`ch4cvr::R`](R) reader structure
        impl crate::Readable for CH4CVR_SPEC {}
        ///`write(|w| ..)` method takes [`ch4cvr::W`](W) writer structure
        impl crate::Writable for CH4CVR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets CH4CVR to value 0
        impl crate::Resettable for CH4CVR_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///DMACFGR (rw) register accessor: DMA control register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`dmacfgr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dmacfgr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@dmacfgr`]
    ///module
    pub type DMACFGR = crate::Reg<dmacfgr::DMACFGR_SPEC>;
    ///DMA control register
    pub mod dmacfgr {
        ///Register `DMACFGR` reader
        pub type R = crate::R<DMACFGR_SPEC>;
        ///Register `DMACFGR` writer
        pub type W = crate::W<DMACFGR_SPEC>;
        ///Field `DBA` reader - DMA base address
        pub type DBA_R = crate::FieldReader;
        ///Field `DBA` writer - DMA base address
        pub type DBA_W<'a, REG> = crate::FieldWriter<'a, REG, 5>;
        ///Field `DBL` reader - DMA burst length
        pub type DBL_R = crate::FieldReader;
        ///Field `DBL` writer - DMA burst length
        pub type DBL_W<'a, REG> = crate::FieldWriter<'a, REG, 5>;
        impl R {
            ///Bits 0:4 - DMA base address
            #[inline(always)]
            pub fn dba(&self) -> DBA_R {
                DBA_R::new((self.bits & 0x1f) as u8)
            }
            ///Bits 8:12 - DMA burst length
            #[inline(always)]
            pub fn dbl(&self) -> DBL_R {
                DBL_R::new(((self.bits >> 8) & 0x1f) as u8)
            }
        }
        impl W {
            ///Bits 0:4 - DMA base address
            #[inline(always)]
            #[must_use]
            pub fn dba(&mut self) -> DBA_W<DMACFGR_SPEC> {
                DBA_W::new(self, 0)
            }
            ///Bits 8:12 - DMA burst length
            #[inline(always)]
            #[must_use]
            pub fn dbl(&mut self) -> DBL_W<DMACFGR_SPEC> {
                DBL_W::new(self, 8)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///DMA control register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`dmacfgr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dmacfgr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct DMACFGR_SPEC;
        impl crate::RegisterSpec for DMACFGR_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`dmacfgr::R`](R) reader structure
        impl crate::Readable for DMACFGR_SPEC {}
        ///`write(|w| ..)` method takes [`dmacfgr::W`](W) writer structure
        impl crate::Writable for DMACFGR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets DMACFGR to value 0
        impl crate::Resettable for DMACFGR_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///DMAADR (rw) register accessor: DMA address for full transfer
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`dmaadr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dmaadr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@dmaadr`]
    ///module
    pub type DMAADR = crate::Reg<dmaadr::DMAADR_SPEC>;
    ///DMA address for full transfer
    pub mod dmaadr {
        ///Register `DMAADR` reader
        pub type R = crate::R<DMAADR_SPEC>;
        ///Register `DMAADR` writer
        pub type W = crate::W<DMAADR_SPEC>;
        ///Field `DMAB` reader - DMA register for burst accesses
        pub type DMAB_R = crate::FieldReader<u32>;
        ///Field `DMAB` writer - DMA register for burst accesses
        pub type DMAB_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - DMA register for burst accesses
            #[inline(always)]
            pub fn dmab(&self) -> DMAB_R {
                DMAB_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - DMA register for burst accesses
            #[inline(always)]
            #[must_use]
            pub fn dmab(&mut self) -> DMAB_W<DMAADR_SPEC> {
                DMAB_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///DMA address for full transfer
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`dmaadr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dmaadr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct DMAADR_SPEC;
        impl crate::RegisterSpec for DMAADR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`dmaadr::R`](R) reader structure
        impl crate::Readable for DMAADR_SPEC {}
        ///`write(|w| ..)` method takes [`dmaadr::W`](W) writer structure
        impl crate::Writable for DMAADR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets DMAADR to value 0
        impl crate::Resettable for DMAADR_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
}
///General purpose timer
pub struct TIM3 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for TIM3 {}
impl TIM3 {
    ///Pointer to the register block
    pub const PTR: *const tim2::RegisterBlock = 0x4000_0400 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const tim2::RegisterBlock {
        Self::PTR
    }
    /// Steal an instance of this peripheral
    ///
    /// # Safety
    ///
    /// Ensure that the new instance of the peripheral cannot be used in a way
    /// that may race with any existing instances, for example by only
    /// accessing read-only or write-only registers, or by consuming the
    /// original peripheral and using critical sections to coordinate
    /// access between multiple new instances.
    ///
    /// Additionally, other software such as HALs may rely on only one
    /// peripheral instance existing to ensure memory safety; ensure
    /// no stolen instances are passed to such software.
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for TIM3 {
    type Target = tim2::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for TIM3 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("TIM3").finish()
    }
}
///General purpose timer
pub use self::tim2 as tim3;
///Timer4
pub struct TIM4 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for TIM4 {}
impl TIM4 {
    ///Pointer to the register block
    pub const PTR: *const tim4::RegisterBlock = 0x4000_0800 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const tim4::RegisterBlock {
        Self::PTR
    }
    /// Steal an instance of this peripheral
    ///
    /// # Safety
    ///
    /// Ensure that the new instance of the peripheral cannot be used in a way
    /// that may race with any existing instances, for example by only
    /// accessing read-only or write-only registers, or by consuming the
    /// original peripheral and using critical sections to coordinate
    /// access between multiple new instances.
    ///
    /// Additionally, other software such as HALs may rely on only one
    /// peripheral instance existing to ensure memory safety; ensure
    /// no stolen instances are passed to such software.
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for TIM4 {
    type Target = tim4::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for TIM4 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("TIM4").finish()
    }
}
///Timer4
pub mod tim4 {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        ctlr1: CTLR1,
        _reserved1: [u8; 0x02],
        ctlr2: CTLR2,
        _reserved2: [u8; 0x02],
        smcfgr: SMCFGR,
        _reserved3: [u8; 0x02],
        dmaintenr: DMAINTENR,
        _reserved4: [u8; 0x02],
        intfr: INTFR,
        _reserved5: [u8; 0x02],
        swevgr: SWEVGR,
        _reserved6: [u8; 0x02],
        _reserved_6_chctlr1: [u8; 0x02],
        _reserved7: [u8; 0x02],
        _reserved_7_chctlr2: [u8; 0x02],
        _reserved8: [u8; 0x02],
        ccer: CCER,
        _reserved9: [u8; 0x02],
        cnt: CNT,
        psc: PSC,
        _reserved11: [u8; 0x02],
        atrlr: ATRLR,
        _reserved12: [u8; 0x04],
        ch1cvr: CH1CVR,
        ch2cvr: CH2CVR,
        ch3cvr: CH3CVR,
        ch4cvr: CH4CVR,
        _reserved16: [u8; 0x04],
        dmacfgr: DMACFGR,
        _reserved17: [u8; 0x02],
        dmaadr: DMAADR,
    }
    impl RegisterBlock {
        ///0x00 - control register 1
        #[inline(always)]
        pub const fn ctlr1(&self) -> &CTLR1 {
            &self.ctlr1
        }
        ///0x04 - control register 2
        #[inline(always)]
        pub const fn ctlr2(&self) -> &CTLR2 {
            &self.ctlr2
        }
        ///0x08 - slave mode control register
        #[inline(always)]
        pub const fn smcfgr(&self) -> &SMCFGR {
            &self.smcfgr
        }
        ///0x0c - DMA/Interrupt enable register
        #[inline(always)]
        pub const fn dmaintenr(&self) -> &DMAINTENR {
            &self.dmaintenr
        }
        ///0x10 - status register
        #[inline(always)]
        pub const fn intfr(&self) -> &INTFR {
            &self.intfr
        }
        ///0x14 - event generation register
        #[inline(always)]
        pub const fn swevgr(&self) -> &SWEVGR {
            &self.swevgr
        }
        ///0x18 - capture/compare mode register 1 (input mode)
        #[inline(always)]
        pub const fn chctlr1_input(&self) -> &CHCTLR1_INPUT {
            unsafe { &*(self as *const Self).cast::<u8>().add(24).cast() }
        }
        ///0x18 - capture/compare mode register 1 (output mode)
        #[inline(always)]
        pub const fn chctlr1_output(&self) -> &CHCTLR1_OUTPUT {
            unsafe { &*(self as *const Self).cast::<u8>().add(24).cast() }
        }
        ///0x1c - capture/compare mode register 2 (input mode)
        #[inline(always)]
        pub const fn chctlr2_input(&self) -> &CHCTLR2_INPUT {
            unsafe { &*(self as *const Self).cast::<u8>().add(28).cast() }
        }
        ///0x1c - capture/compare mode register 2 (output mode)
        #[inline(always)]
        pub const fn chctlr2_output(&self) -> &CHCTLR2_OUTPUT {
            unsafe { &*(self as *const Self).cast::<u8>().add(28).cast() }
        }
        ///0x20 - capture/compare enable register
        #[inline(always)]
        pub const fn ccer(&self) -> &CCER {
            &self.ccer
        }
        ///0x24 - counter
        #[inline(always)]
        pub const fn cnt(&self) -> &CNT {
            &self.cnt
        }
        ///0x28 - prescaler
        #[inline(always)]
        pub const fn psc(&self) -> &PSC {
            &self.psc
        }
        ///0x2c - auto-reload register
        #[inline(always)]
        pub const fn atrlr(&self) -> &ATRLR {
            &self.atrlr
        }
        ///0x34 - capture/compare register 1
        #[inline(always)]
        pub const fn ch1cvr(&self) -> &CH1CVR {
            &self.ch1cvr
        }
        ///0x38 - capture/compare register 2
        #[inline(always)]
        pub const fn ch2cvr(&self) -> &CH2CVR {
            &self.ch2cvr
        }
        ///0x3c - capture/compare register 3
        #[inline(always)]
        pub const fn ch3cvr(&self) -> &CH3CVR {
            &self.ch3cvr
        }
        ///0x40 - capture/compare register 4
        #[inline(always)]
        pub const fn ch4cvr(&self) -> &CH4CVR {
            &self.ch4cvr
        }
        ///0x48 - DMA control register
        #[inline(always)]
        pub const fn dmacfgr(&self) -> &DMACFGR {
            &self.dmacfgr
        }
        ///0x4c - DMA address for full transfer
        #[inline(always)]
        pub const fn dmaadr(&self) -> &DMAADR {
            &self.dmaadr
        }
    }
    ///CTLR1 (rw) register accessor: control register 1
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`ctlr1::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ctlr1::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@ctlr1`]
    ///module
    pub type CTLR1 = crate::Reg<ctlr1::CTLR1_SPEC>;
    ///control register 1
    pub mod ctlr1 {
        ///Register `CTLR1` reader
        pub type R = crate::R<CTLR1_SPEC>;
        ///Register `CTLR1` writer
        pub type W = crate::W<CTLR1_SPEC>;
        ///Field `CEN` reader - Counter enable
        pub type CEN_R = crate::BitReader;
        ///Field `CEN` writer - Counter enable
        pub type CEN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UDIS` reader - Update disable
        pub type UDIS_R = crate::BitReader;
        ///Field `UDIS` writer - Update disable
        pub type UDIS_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `URS` reader - Update request source
        pub type URS_R = crate::BitReader;
        ///Field `URS` writer - Update request source
        pub type URS_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `OPM` reader - One-pulse mode
        pub type OPM_R = crate::BitReader;
        ///Field `OPM` writer - One-pulse mode
        pub type OPM_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `DIR` reader - Direction
        pub type DIR_R = crate::BitReader;
        ///Field `DIR` writer - Direction
        pub type DIR_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CMS` reader - Center-aligned mode selection
        pub type CMS_R = crate::FieldReader;
        ///Field `CMS` writer - Center-aligned mode selection
        pub type CMS_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `ARPE` reader - Auto-reload preload enable
        pub type ARPE_R = crate::BitReader;
        ///Field `ARPE` writer - Auto-reload preload enable
        pub type ARPE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CKD` reader - Clock division
        pub type CKD_R = crate::FieldReader;
        ///Field `CKD` writer - Clock division
        pub type CKD_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `TMR_CAP_OV_EN` reader - Auto-reload preload enable
        pub type TMR_CAP_OV_EN_R = crate::BitReader;
        ///Field `TMR_CAP_OV_EN` writer - Auto-reload preload enable
        pub type TMR_CAP_OV_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TMR_CAP_LVL_EN` reader - Directive function enable
        pub type TMR_CAP_LVL_EN_R = crate::BitReader;
        ///Field `TMR_CAP_LVL_EN` writer - Directive function enable
        pub type TMR_CAP_LVL_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - Counter enable
            #[inline(always)]
            pub fn cen(&self) -> CEN_R {
                CEN_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Update disable
            #[inline(always)]
            pub fn udis(&self) -> UDIS_R {
                UDIS_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - Update request source
            #[inline(always)]
            pub fn urs(&self) -> URS_R {
                URS_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - One-pulse mode
            #[inline(always)]
            pub fn opm(&self) -> OPM_R {
                OPM_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - Direction
            #[inline(always)]
            pub fn dir(&self) -> DIR_R {
                DIR_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bits 5:6 - Center-aligned mode selection
            #[inline(always)]
            pub fn cms(&self) -> CMS_R {
                CMS_R::new(((self.bits >> 5) & 3) as u8)
            }
            ///Bit 7 - Auto-reload preload enable
            #[inline(always)]
            pub fn arpe(&self) -> ARPE_R {
                ARPE_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bits 8:9 - Clock division
            #[inline(always)]
            pub fn ckd(&self) -> CKD_R {
                CKD_R::new(((self.bits >> 8) & 3) as u8)
            }
            ///Bit 14 - Auto-reload preload enable
            #[inline(always)]
            pub fn tmr_cap_ov_en(&self) -> TMR_CAP_OV_EN_R {
                TMR_CAP_OV_EN_R::new(((self.bits >> 14) & 1) != 0)
            }
            ///Bit 15 - Directive function enable
            #[inline(always)]
            pub fn tmr_cap_lvl_en(&self) -> TMR_CAP_LVL_EN_R {
                TMR_CAP_LVL_EN_R::new(((self.bits >> 15) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - Counter enable
            #[inline(always)]
            #[must_use]
            pub fn cen(&mut self) -> CEN_W<CTLR1_SPEC> {
                CEN_W::new(self, 0)
            }
            ///Bit 1 - Update disable
            #[inline(always)]
            #[must_use]
            pub fn udis(&mut self) -> UDIS_W<CTLR1_SPEC> {
                UDIS_W::new(self, 1)
            }
            ///Bit 2 - Update request source
            #[inline(always)]
            #[must_use]
            pub fn urs(&mut self) -> URS_W<CTLR1_SPEC> {
                URS_W::new(self, 2)
            }
            ///Bit 3 - One-pulse mode
            #[inline(always)]
            #[must_use]
            pub fn opm(&mut self) -> OPM_W<CTLR1_SPEC> {
                OPM_W::new(self, 3)
            }
            ///Bit 4 - Direction
            #[inline(always)]
            #[must_use]
            pub fn dir(&mut self) -> DIR_W<CTLR1_SPEC> {
                DIR_W::new(self, 4)
            }
            ///Bits 5:6 - Center-aligned mode selection
            #[inline(always)]
            #[must_use]
            pub fn cms(&mut self) -> CMS_W<CTLR1_SPEC> {
                CMS_W::new(self, 5)
            }
            ///Bit 7 - Auto-reload preload enable
            #[inline(always)]
            #[must_use]
            pub fn arpe(&mut self) -> ARPE_W<CTLR1_SPEC> {
                ARPE_W::new(self, 7)
            }
            ///Bits 8:9 - Clock division
            #[inline(always)]
            #[must_use]
            pub fn ckd(&mut self) -> CKD_W<CTLR1_SPEC> {
                CKD_W::new(self, 8)
            }
            ///Bit 14 - Auto-reload preload enable
            #[inline(always)]
            #[must_use]
            pub fn tmr_cap_ov_en(&mut self) -> TMR_CAP_OV_EN_W<CTLR1_SPEC> {
                TMR_CAP_OV_EN_W::new(self, 14)
            }
            ///Bit 15 - Directive function enable
            #[inline(always)]
            #[must_use]
            pub fn tmr_cap_lvl_en(&mut self) -> TMR_CAP_LVL_EN_W<CTLR1_SPEC> {
                TMR_CAP_LVL_EN_W::new(self, 15)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///control register 1
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`ctlr1::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ctlr1::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct CTLR1_SPEC;
        impl crate::RegisterSpec for CTLR1_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`ctlr1::R`](R) reader structure
        impl crate::Readable for CTLR1_SPEC {}
        ///`write(|w| ..)` method takes [`ctlr1::W`](W) writer structure
        impl crate::Writable for CTLR1_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets CTLR1 to value 0
        impl crate::Resettable for CTLR1_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///CTLR2 (rw) register accessor: control register 2
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`ctlr2::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ctlr2::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@ctlr2`]
    ///module
    pub type CTLR2 = crate::Reg<ctlr2::CTLR2_SPEC>;
    ///control register 2
    pub mod ctlr2 {
        ///Register `CTLR2` reader
        pub type R = crate::R<CTLR2_SPEC>;
        ///Register `CTLR2` writer
        pub type W = crate::W<CTLR2_SPEC>;
        ///Field `CCDS` reader - Capture/compare DMA selection
        pub type CCDS_R = crate::BitReader;
        ///Field `CCDS` writer - Capture/compare DMA selection
        pub type CCDS_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `MMS` reader - Master mode selection
        pub type MMS_R = crate::FieldReader;
        ///Field `MMS` writer - Master mode selection
        pub type MMS_W<'a, REG> = crate::FieldWriter<'a, REG, 3>;
        ///Field `TI1S` reader - TI1 selection
        pub type TI1S_R = crate::BitReader;
        ///Field `TI1S` writer - TI1 selection
        pub type TI1S_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 3 - Capture/compare DMA selection
            #[inline(always)]
            pub fn ccds(&self) -> CCDS_R {
                CCDS_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bits 4:6 - Master mode selection
            #[inline(always)]
            pub fn mms(&self) -> MMS_R {
                MMS_R::new(((self.bits >> 4) & 7) as u8)
            }
            ///Bit 7 - TI1 selection
            #[inline(always)]
            pub fn ti1s(&self) -> TI1S_R {
                TI1S_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 3 - Capture/compare DMA selection
            #[inline(always)]
            #[must_use]
            pub fn ccds(&mut self) -> CCDS_W<CTLR2_SPEC> {
                CCDS_W::new(self, 3)
            }
            ///Bits 4:6 - Master mode selection
            #[inline(always)]
            #[must_use]
            pub fn mms(&mut self) -> MMS_W<CTLR2_SPEC> {
                MMS_W::new(self, 4)
            }
            ///Bit 7 - TI1 selection
            #[inline(always)]
            #[must_use]
            pub fn ti1s(&mut self) -> TI1S_W<CTLR2_SPEC> {
                TI1S_W::new(self, 7)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///control register 2
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`ctlr2::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ctlr2::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct CTLR2_SPEC;
        impl crate::RegisterSpec for CTLR2_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`ctlr2::R`](R) reader structure
        impl crate::Readable for CTLR2_SPEC {}
        ///`write(|w| ..)` method takes [`ctlr2::W`](W) writer structure
        impl crate::Writable for CTLR2_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets CTLR2 to value 0
        impl crate::Resettable for CTLR2_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///SMCFGR (rw) register accessor: slave mode control register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`smcfgr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`smcfgr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@smcfgr`]
    ///module
    pub type SMCFGR = crate::Reg<smcfgr::SMCFGR_SPEC>;
    ///slave mode control register
    pub mod smcfgr {
        ///Register `SMCFGR` reader
        pub type R = crate::R<SMCFGR_SPEC>;
        ///Register `SMCFGR` writer
        pub type W = crate::W<SMCFGR_SPEC>;
        ///Field `SMS` reader - Slave mode selection
        pub type SMS_R = crate::FieldReader;
        ///Field `SMS` writer - Slave mode selection
        pub type SMS_W<'a, REG> = crate::FieldWriter<'a, REG, 3>;
        ///Field `TS` reader - Trigger selection
        pub type TS_R = crate::FieldReader;
        ///Field `TS` writer - Trigger selection
        pub type TS_W<'a, REG> = crate::FieldWriter<'a, REG, 3>;
        ///Field `MSM` reader - Master/Slave mode
        pub type MSM_R = crate::BitReader;
        ///Field `MSM` writer - Master/Slave mode
        pub type MSM_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `ETF` reader - External trigger filter
        pub type ETF_R = crate::FieldReader;
        ///Field `ETF` writer - External trigger filter
        pub type ETF_W<'a, REG> = crate::FieldWriter<'a, REG, 4>;
        ///Field `ETPS` reader - External trigger prescaler
        pub type ETPS_R = crate::FieldReader;
        ///Field `ETPS` writer - External trigger prescaler
        pub type ETPS_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `ECE` reader - External clock enable
        pub type ECE_R = crate::BitReader;
        ///Field `ECE` writer - External clock enable
        pub type ECE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `ETP` reader - External trigger polarity
        pub type ETP_R = crate::BitReader;
        ///Field `ETP` writer - External trigger polarity
        pub type ETP_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bits 0:2 - Slave mode selection
            #[inline(always)]
            pub fn sms(&self) -> SMS_R {
                SMS_R::new((self.bits & 7) as u8)
            }
            ///Bits 4:6 - Trigger selection
            #[inline(always)]
            pub fn ts(&self) -> TS_R {
                TS_R::new(((self.bits >> 4) & 7) as u8)
            }
            ///Bit 7 - Master/Slave mode
            #[inline(always)]
            pub fn msm(&self) -> MSM_R {
                MSM_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bits 8:11 - External trigger filter
            #[inline(always)]
            pub fn etf(&self) -> ETF_R {
                ETF_R::new(((self.bits >> 8) & 0x0f) as u8)
            }
            ///Bits 12:13 - External trigger prescaler
            #[inline(always)]
            pub fn etps(&self) -> ETPS_R {
                ETPS_R::new(((self.bits >> 12) & 3) as u8)
            }
            ///Bit 14 - External clock enable
            #[inline(always)]
            pub fn ece(&self) -> ECE_R {
                ECE_R::new(((self.bits >> 14) & 1) != 0)
            }
            ///Bit 15 - External trigger polarity
            #[inline(always)]
            pub fn etp(&self) -> ETP_R {
                ETP_R::new(((self.bits >> 15) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:2 - Slave mode selection
            #[inline(always)]
            #[must_use]
            pub fn sms(&mut self) -> SMS_W<SMCFGR_SPEC> {
                SMS_W::new(self, 0)
            }
            ///Bits 4:6 - Trigger selection
            #[inline(always)]
            #[must_use]
            pub fn ts(&mut self) -> TS_W<SMCFGR_SPEC> {
                TS_W::new(self, 4)
            }
            ///Bit 7 - Master/Slave mode
            #[inline(always)]
            #[must_use]
            pub fn msm(&mut self) -> MSM_W<SMCFGR_SPEC> {
                MSM_W::new(self, 7)
            }
            ///Bits 8:11 - External trigger filter
            #[inline(always)]
            #[must_use]
            pub fn etf(&mut self) -> ETF_W<SMCFGR_SPEC> {
                ETF_W::new(self, 8)
            }
            ///Bits 12:13 - External trigger prescaler
            #[inline(always)]
            #[must_use]
            pub fn etps(&mut self) -> ETPS_W<SMCFGR_SPEC> {
                ETPS_W::new(self, 12)
            }
            ///Bit 14 - External clock enable
            #[inline(always)]
            #[must_use]
            pub fn ece(&mut self) -> ECE_W<SMCFGR_SPEC> {
                ECE_W::new(self, 14)
            }
            ///Bit 15 - External trigger polarity
            #[inline(always)]
            #[must_use]
            pub fn etp(&mut self) -> ETP_W<SMCFGR_SPEC> {
                ETP_W::new(self, 15)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///slave mode control register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`smcfgr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`smcfgr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct SMCFGR_SPEC;
        impl crate::RegisterSpec for SMCFGR_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`smcfgr::R`](R) reader structure
        impl crate::Readable for SMCFGR_SPEC {}
        ///`write(|w| ..)` method takes [`smcfgr::W`](W) writer structure
        impl crate::Writable for SMCFGR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets SMCFGR to value 0
        impl crate::Resettable for SMCFGR_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///DMAINTENR (rw) register accessor: DMA/Interrupt enable register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`dmaintenr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dmaintenr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@dmaintenr`]
    ///module
    pub type DMAINTENR = crate::Reg<dmaintenr::DMAINTENR_SPEC>;
    ///DMA/Interrupt enable register
    pub mod dmaintenr {
        ///Register `DMAINTENR` reader
        pub type R = crate::R<DMAINTENR_SPEC>;
        ///Register `DMAINTENR` writer
        pub type W = crate::W<DMAINTENR_SPEC>;
        ///Field `UIE` reader - Update interrupt enable
        pub type UIE_R = crate::BitReader;
        ///Field `UIE` writer - Update interrupt enable
        pub type UIE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CC1IE` reader - Capture/Compare 1 interrupt enable
        pub type CC1IE_R = crate::BitReader;
        ///Field `CC1IE` writer - Capture/Compare 1 interrupt enable
        pub type CC1IE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CC2IE` reader - Capture/Compare 2 interrupt enable
        pub type CC2IE_R = crate::BitReader;
        ///Field `CC2IE` writer - Capture/Compare 2 interrupt enable
        pub type CC2IE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CC3IE` reader - Capture/Compare 3 interrupt enable
        pub type CC3IE_R = crate::BitReader;
        ///Field `CC3IE` writer - Capture/Compare 3 interrupt enable
        pub type CC3IE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CC4IE` reader - Capture/Compare 4 interrupt enable
        pub type CC4IE_R = crate::BitReader;
        ///Field `CC4IE` writer - Capture/Compare 4 interrupt enable
        pub type CC4IE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TIE` reader - Trigger interrupt enable
        pub type TIE_R = crate::BitReader;
        ///Field `TIE` writer - Trigger interrupt enable
        pub type TIE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UDE` reader - Update DMA request enable
        pub type UDE_R = crate::BitReader;
        ///Field `UDE` writer - Update DMA request enable
        pub type UDE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CC1DE` reader - Capture/Compare 1 DMA request enable
        pub type CC1DE_R = crate::BitReader;
        ///Field `CC1DE` writer - Capture/Compare 1 DMA request enable
        pub type CC1DE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CC2DE` reader - Capture/Compare 2 DMA request enable
        pub type CC2DE_R = crate::BitReader;
        ///Field `CC2DE` writer - Capture/Compare 2 DMA request enable
        pub type CC2DE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CC3DE` reader - Capture/Compare 3 DMA request enable
        pub type CC3DE_R = crate::BitReader;
        ///Field `CC3DE` writer - Capture/Compare 3 DMA request enable
        pub type CC3DE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CC4DE` reader - Capture/Compare 4 DMA request enable
        pub type CC4DE_R = crate::BitReader;
        ///Field `CC4DE` writer - Capture/Compare 4 DMA request enable
        pub type CC4DE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TDE` reader - Trigger DMA request enable
        pub type TDE_R = crate::BitReader;
        ///Field `TDE` writer - Trigger DMA request enable
        pub type TDE_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - Update interrupt enable
            #[inline(always)]
            pub fn uie(&self) -> UIE_R {
                UIE_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Capture/Compare 1 interrupt enable
            #[inline(always)]
            pub fn cc1ie(&self) -> CC1IE_R {
                CC1IE_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - Capture/Compare 2 interrupt enable
            #[inline(always)]
            pub fn cc2ie(&self) -> CC2IE_R {
                CC2IE_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - Capture/Compare 3 interrupt enable
            #[inline(always)]
            pub fn cc3ie(&self) -> CC3IE_R {
                CC3IE_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - Capture/Compare 4 interrupt enable
            #[inline(always)]
            pub fn cc4ie(&self) -> CC4IE_R {
                CC4IE_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 6 - Trigger interrupt enable
            #[inline(always)]
            pub fn tie(&self) -> TIE_R {
                TIE_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 8 - Update DMA request enable
            #[inline(always)]
            pub fn ude(&self) -> UDE_R {
                UDE_R::new(((self.bits >> 8) & 1) != 0)
            }
            ///Bit 9 - Capture/Compare 1 DMA request enable
            #[inline(always)]
            pub fn cc1de(&self) -> CC1DE_R {
                CC1DE_R::new(((self.bits >> 9) & 1) != 0)
            }
            ///Bit 10 - Capture/Compare 2 DMA request enable
            #[inline(always)]
            pub fn cc2de(&self) -> CC2DE_R {
                CC2DE_R::new(((self.bits >> 10) & 1) != 0)
            }
            ///Bit 11 - Capture/Compare 3 DMA request enable
            #[inline(always)]
            pub fn cc3de(&self) -> CC3DE_R {
                CC3DE_R::new(((self.bits >> 11) & 1) != 0)
            }
            ///Bit 12 - Capture/Compare 4 DMA request enable
            #[inline(always)]
            pub fn cc4de(&self) -> CC4DE_R {
                CC4DE_R::new(((self.bits >> 12) & 1) != 0)
            }
            ///Bit 14 - Trigger DMA request enable
            #[inline(always)]
            pub fn tde(&self) -> TDE_R {
                TDE_R::new(((self.bits >> 14) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - Update interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn uie(&mut self) -> UIE_W<DMAINTENR_SPEC> {
                UIE_W::new(self, 0)
            }
            ///Bit 1 - Capture/Compare 1 interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn cc1ie(&mut self) -> CC1IE_W<DMAINTENR_SPEC> {
                CC1IE_W::new(self, 1)
            }
            ///Bit 2 - Capture/Compare 2 interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn cc2ie(&mut self) -> CC2IE_W<DMAINTENR_SPEC> {
                CC2IE_W::new(self, 2)
            }
            ///Bit 3 - Capture/Compare 3 interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn cc3ie(&mut self) -> CC3IE_W<DMAINTENR_SPEC> {
                CC3IE_W::new(self, 3)
            }
            ///Bit 4 - Capture/Compare 4 interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn cc4ie(&mut self) -> CC4IE_W<DMAINTENR_SPEC> {
                CC4IE_W::new(self, 4)
            }
            ///Bit 6 - Trigger interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn tie(&mut self) -> TIE_W<DMAINTENR_SPEC> {
                TIE_W::new(self, 6)
            }
            ///Bit 8 - Update DMA request enable
            #[inline(always)]
            #[must_use]
            pub fn ude(&mut self) -> UDE_W<DMAINTENR_SPEC> {
                UDE_W::new(self, 8)
            }
            ///Bit 9 - Capture/Compare 1 DMA request enable
            #[inline(always)]
            #[must_use]
            pub fn cc1de(&mut self) -> CC1DE_W<DMAINTENR_SPEC> {
                CC1DE_W::new(self, 9)
            }
            ///Bit 10 - Capture/Compare 2 DMA request enable
            #[inline(always)]
            #[must_use]
            pub fn cc2de(&mut self) -> CC2DE_W<DMAINTENR_SPEC> {
                CC2DE_W::new(self, 10)
            }
            ///Bit 11 - Capture/Compare 3 DMA request enable
            #[inline(always)]
            #[must_use]
            pub fn cc3de(&mut self) -> CC3DE_W<DMAINTENR_SPEC> {
                CC3DE_W::new(self, 11)
            }
            ///Bit 12 - Capture/Compare 4 DMA request enable
            #[inline(always)]
            #[must_use]
            pub fn cc4de(&mut self) -> CC4DE_W<DMAINTENR_SPEC> {
                CC4DE_W::new(self, 12)
            }
            ///Bit 14 - Trigger DMA request enable
            #[inline(always)]
            #[must_use]
            pub fn tde(&mut self) -> TDE_W<DMAINTENR_SPEC> {
                TDE_W::new(self, 14)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///DMA/Interrupt enable register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`dmaintenr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dmaintenr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct DMAINTENR_SPEC;
        impl crate::RegisterSpec for DMAINTENR_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`dmaintenr::R`](R) reader structure
        impl crate::Readable for DMAINTENR_SPEC {}
        ///`write(|w| ..)` method takes [`dmaintenr::W`](W) writer structure
        impl crate::Writable for DMAINTENR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets DMAINTENR to value 0
        impl crate::Resettable for DMAINTENR_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///INTFR (rw) register accessor: status register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`intfr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`intfr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@intfr`]
    ///module
    pub type INTFR = crate::Reg<intfr::INTFR_SPEC>;
    ///status register
    pub mod intfr {
        ///Register `INTFR` reader
        pub type R = crate::R<INTFR_SPEC>;
        ///Register `INTFR` writer
        pub type W = crate::W<INTFR_SPEC>;
        ///Field `UIF` reader - Update interrupt flag
        pub type UIF_R = crate::BitReader;
        ///Field `UIF` writer - Update interrupt flag
        pub type UIF_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CC1IF` reader - Capture/compare 1 interrupt flag
        pub type CC1IF_R = crate::BitReader;
        ///Field `CC1IF` writer - Capture/compare 1 interrupt flag
        pub type CC1IF_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CC2IF` reader - Capture/Compare 2 interrupt flag
        pub type CC2IF_R = crate::BitReader;
        ///Field `CC2IF` writer - Capture/Compare 2 interrupt flag
        pub type CC2IF_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CC3IF` reader - Capture/Compare 3 interrupt flag
        pub type CC3IF_R = crate::BitReader;
        ///Field `CC3IF` writer - Capture/Compare 3 interrupt flag
        pub type CC3IF_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CC4IF` reader - Capture/Compare 4 interrupt flag
        pub type CC4IF_R = crate::BitReader;
        ///Field `CC4IF` writer - Capture/Compare 4 interrupt flag
        pub type CC4IF_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TIF` reader - Trigger interrupt flag
        pub type TIF_R = crate::BitReader;
        ///Field `TIF` writer - Trigger interrupt flag
        pub type TIF_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CC1OF` reader - Capture/Compare 1 overcapture flag
        pub type CC1OF_R = crate::BitReader;
        ///Field `CC1OF` writer - Capture/Compare 1 overcapture flag
        pub type CC1OF_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CC2OF` reader - Capture/compare 2 overcapture flag
        pub type CC2OF_R = crate::BitReader;
        ///Field `CC2OF` writer - Capture/compare 2 overcapture flag
        pub type CC2OF_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CC3OF` reader - Capture/Compare 3 overcapture flag
        pub type CC3OF_R = crate::BitReader;
        ///Field `CC3OF` writer - Capture/Compare 3 overcapture flag
        pub type CC3OF_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CC4OF` reader - Capture/Compare 4 overcapture flag
        pub type CC4OF_R = crate::BitReader;
        ///Field `CC4OF` writer - Capture/Compare 4 overcapture flag
        pub type CC4OF_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - Update interrupt flag
            #[inline(always)]
            pub fn uif(&self) -> UIF_R {
                UIF_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Capture/compare 1 interrupt flag
            #[inline(always)]
            pub fn cc1if(&self) -> CC1IF_R {
                CC1IF_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - Capture/Compare 2 interrupt flag
            #[inline(always)]
            pub fn cc2if(&self) -> CC2IF_R {
                CC2IF_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - Capture/Compare 3 interrupt flag
            #[inline(always)]
            pub fn cc3if(&self) -> CC3IF_R {
                CC3IF_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - Capture/Compare 4 interrupt flag
            #[inline(always)]
            pub fn cc4if(&self) -> CC4IF_R {
                CC4IF_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 6 - Trigger interrupt flag
            #[inline(always)]
            pub fn tif(&self) -> TIF_R {
                TIF_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 9 - Capture/Compare 1 overcapture flag
            #[inline(always)]
            pub fn cc1of(&self) -> CC1OF_R {
                CC1OF_R::new(((self.bits >> 9) & 1) != 0)
            }
            ///Bit 10 - Capture/compare 2 overcapture flag
            #[inline(always)]
            pub fn cc2of(&self) -> CC2OF_R {
                CC2OF_R::new(((self.bits >> 10) & 1) != 0)
            }
            ///Bit 11 - Capture/Compare 3 overcapture flag
            #[inline(always)]
            pub fn cc3of(&self) -> CC3OF_R {
                CC3OF_R::new(((self.bits >> 11) & 1) != 0)
            }
            ///Bit 12 - Capture/Compare 4 overcapture flag
            #[inline(always)]
            pub fn cc4of(&self) -> CC4OF_R {
                CC4OF_R::new(((self.bits >> 12) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - Update interrupt flag
            #[inline(always)]
            #[must_use]
            pub fn uif(&mut self) -> UIF_W<INTFR_SPEC> {
                UIF_W::new(self, 0)
            }
            ///Bit 1 - Capture/compare 1 interrupt flag
            #[inline(always)]
            #[must_use]
            pub fn cc1if(&mut self) -> CC1IF_W<INTFR_SPEC> {
                CC1IF_W::new(self, 1)
            }
            ///Bit 2 - Capture/Compare 2 interrupt flag
            #[inline(always)]
            #[must_use]
            pub fn cc2if(&mut self) -> CC2IF_W<INTFR_SPEC> {
                CC2IF_W::new(self, 2)
            }
            ///Bit 3 - Capture/Compare 3 interrupt flag
            #[inline(always)]
            #[must_use]
            pub fn cc3if(&mut self) -> CC3IF_W<INTFR_SPEC> {
                CC3IF_W::new(self, 3)
            }
            ///Bit 4 - Capture/Compare 4 interrupt flag
            #[inline(always)]
            #[must_use]
            pub fn cc4if(&mut self) -> CC4IF_W<INTFR_SPEC> {
                CC4IF_W::new(self, 4)
            }
            ///Bit 6 - Trigger interrupt flag
            #[inline(always)]
            #[must_use]
            pub fn tif(&mut self) -> TIF_W<INTFR_SPEC> {
                TIF_W::new(self, 6)
            }
            ///Bit 9 - Capture/Compare 1 overcapture flag
            #[inline(always)]
            #[must_use]
            pub fn cc1of(&mut self) -> CC1OF_W<INTFR_SPEC> {
                CC1OF_W::new(self, 9)
            }
            ///Bit 10 - Capture/compare 2 overcapture flag
            #[inline(always)]
            #[must_use]
            pub fn cc2of(&mut self) -> CC2OF_W<INTFR_SPEC> {
                CC2OF_W::new(self, 10)
            }
            ///Bit 11 - Capture/Compare 3 overcapture flag
            #[inline(always)]
            #[must_use]
            pub fn cc3of(&mut self) -> CC3OF_W<INTFR_SPEC> {
                CC3OF_W::new(self, 11)
            }
            ///Bit 12 - Capture/Compare 4 overcapture flag
            #[inline(always)]
            #[must_use]
            pub fn cc4of(&mut self) -> CC4OF_W<INTFR_SPEC> {
                CC4OF_W::new(self, 12)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///status register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`intfr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`intfr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct INTFR_SPEC;
        impl crate::RegisterSpec for INTFR_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`intfr::R`](R) reader structure
        impl crate::Readable for INTFR_SPEC {}
        ///`write(|w| ..)` method takes [`intfr::W`](W) writer structure
        impl crate::Writable for INTFR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets INTFR to value 0
        impl crate::Resettable for INTFR_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///SWEVGR (w) register accessor: event generation register
    ///
    ///You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`swevgr::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@swevgr`]
    ///module
    pub type SWEVGR = crate::Reg<swevgr::SWEVGR_SPEC>;
    ///event generation register
    pub mod swevgr {
        ///Register `SWEVGR` writer
        pub type W = crate::W<SWEVGR_SPEC>;
        ///Field `UG` writer - Update generation
        pub type UG_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CC1G` writer - Capture/compare 1 generation
        pub type CC1G_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CC2G` writer - Capture/compare 2 generation
        pub type CC2G_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CC3G` writer - Capture/compare 3 generation
        pub type CC3G_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CC4G` writer - Capture/compare 4 generation
        pub type CC4G_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TG` writer - Trigger generation
        pub type TG_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl W {
            ///Bit 0 - Update generation
            #[inline(always)]
            #[must_use]
            pub fn ug(&mut self) -> UG_W<SWEVGR_SPEC> {
                UG_W::new(self, 0)
            }
            ///Bit 1 - Capture/compare 1 generation
            #[inline(always)]
            #[must_use]
            pub fn cc1g(&mut self) -> CC1G_W<SWEVGR_SPEC> {
                CC1G_W::new(self, 1)
            }
            ///Bit 2 - Capture/compare 2 generation
            #[inline(always)]
            #[must_use]
            pub fn cc2g(&mut self) -> CC2G_W<SWEVGR_SPEC> {
                CC2G_W::new(self, 2)
            }
            ///Bit 3 - Capture/compare 3 generation
            #[inline(always)]
            #[must_use]
            pub fn cc3g(&mut self) -> CC3G_W<SWEVGR_SPEC> {
                CC3G_W::new(self, 3)
            }
            ///Bit 4 - Capture/compare 4 generation
            #[inline(always)]
            #[must_use]
            pub fn cc4g(&mut self) -> CC4G_W<SWEVGR_SPEC> {
                CC4G_W::new(self, 4)
            }
            ///Bit 6 - Trigger generation
            #[inline(always)]
            #[must_use]
            pub fn tg(&mut self) -> TG_W<SWEVGR_SPEC> {
                TG_W::new(self, 6)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///event generation register
        ///
        ///You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`swevgr::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct SWEVGR_SPEC;
        impl crate::RegisterSpec for SWEVGR_SPEC {
            type Ux = u16;
        }
        ///`write(|w| ..)` method takes [`swevgr::W`](W) writer structure
        impl crate::Writable for SWEVGR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets SWEVGR to value 0
        impl crate::Resettable for SWEVGR_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///CHCTLR1_Output (rw) register accessor: capture/compare mode register 1 (output mode)
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`chctlr1_output::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`chctlr1_output::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@chctlr1_output`]
    ///module
    pub type CHCTLR1_OUTPUT = crate::Reg<chctlr1_output::CHCTLR1_OUTPUT_SPEC>;
    ///capture/compare mode register 1 (output mode)
    pub mod chctlr1_output {
        ///Register `CHCTLR1_Output` reader
        pub type R = crate::R<CHCTLR1_OUTPUT_SPEC>;
        ///Register `CHCTLR1_Output` writer
        pub type W = crate::W<CHCTLR1_OUTPUT_SPEC>;
        ///Field `CC1S` reader - Capture/Compare 1 selection
        pub type CC1S_R = crate::FieldReader;
        ///Field `CC1S` writer - Capture/Compare 1 selection
        pub type CC1S_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `OC1FE` reader - Output compare 1 fast enable
        pub type OC1FE_R = crate::BitReader;
        ///Field `OC1FE` writer - Output compare 1 fast enable
        pub type OC1FE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `OC1PE` reader - Output compare 1 preload enable
        pub type OC1PE_R = crate::BitReader;
        ///Field `OC1PE` writer - Output compare 1 preload enable
        pub type OC1PE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `OC1M` reader - Output compare 1 mode
        pub type OC1M_R = crate::FieldReader;
        ///Field `OC1M` writer - Output compare 1 mode
        pub type OC1M_W<'a, REG> = crate::FieldWriter<'a, REG, 3>;
        ///Field `OC1CE` reader - Output compare 1 clear enable
        pub type OC1CE_R = crate::BitReader;
        ///Field `OC1CE` writer - Output compare 1 clear enable
        pub type OC1CE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CC2S` reader - Capture/Compare 2 selection
        pub type CC2S_R = crate::FieldReader;
        ///Field `CC2S` writer - Capture/Compare 2 selection
        pub type CC2S_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `OC2FE` reader - Output compare 2 fast enable
        pub type OC2FE_R = crate::BitReader;
        ///Field `OC2FE` writer - Output compare 2 fast enable
        pub type OC2FE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `OC2PE` reader - Output compare 2 preload enable
        pub type OC2PE_R = crate::BitReader;
        ///Field `OC2PE` writer - Output compare 2 preload enable
        pub type OC2PE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `OC2M` reader - Output compare 2 mode
        pub type OC2M_R = crate::FieldReader;
        ///Field `OC2M` writer - Output compare 2 mode
        pub type OC2M_W<'a, REG> = crate::FieldWriter<'a, REG, 3>;
        ///Field `OC2CE` reader - Output compare 2 clear enable
        pub type OC2CE_R = crate::BitReader;
        ///Field `OC2CE` writer - Output compare 2 clear enable
        pub type OC2CE_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bits 0:1 - Capture/Compare 1 selection
            #[inline(always)]
            pub fn cc1s(&self) -> CC1S_R {
                CC1S_R::new((self.bits & 3) as u8)
            }
            ///Bit 2 - Output compare 1 fast enable
            #[inline(always)]
            pub fn oc1fe(&self) -> OC1FE_R {
                OC1FE_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - Output compare 1 preload enable
            #[inline(always)]
            pub fn oc1pe(&self) -> OC1PE_R {
                OC1PE_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bits 4:6 - Output compare 1 mode
            #[inline(always)]
            pub fn oc1m(&self) -> OC1M_R {
                OC1M_R::new(((self.bits >> 4) & 7) as u8)
            }
            ///Bit 7 - Output compare 1 clear enable
            #[inline(always)]
            pub fn oc1ce(&self) -> OC1CE_R {
                OC1CE_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bits 8:9 - Capture/Compare 2 selection
            #[inline(always)]
            pub fn cc2s(&self) -> CC2S_R {
                CC2S_R::new(((self.bits >> 8) & 3) as u8)
            }
            ///Bit 10 - Output compare 2 fast enable
            #[inline(always)]
            pub fn oc2fe(&self) -> OC2FE_R {
                OC2FE_R::new(((self.bits >> 10) & 1) != 0)
            }
            ///Bit 11 - Output compare 2 preload enable
            #[inline(always)]
            pub fn oc2pe(&self) -> OC2PE_R {
                OC2PE_R::new(((self.bits >> 11) & 1) != 0)
            }
            ///Bits 12:14 - Output compare 2 mode
            #[inline(always)]
            pub fn oc2m(&self) -> OC2M_R {
                OC2M_R::new(((self.bits >> 12) & 7) as u8)
            }
            ///Bit 15 - Output compare 2 clear enable
            #[inline(always)]
            pub fn oc2ce(&self) -> OC2CE_R {
                OC2CE_R::new(((self.bits >> 15) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:1 - Capture/Compare 1 selection
            #[inline(always)]
            #[must_use]
            pub fn cc1s(&mut self) -> CC1S_W<CHCTLR1_OUTPUT_SPEC> {
                CC1S_W::new(self, 0)
            }
            ///Bit 2 - Output compare 1 fast enable
            #[inline(always)]
            #[must_use]
            pub fn oc1fe(&mut self) -> OC1FE_W<CHCTLR1_OUTPUT_SPEC> {
                OC1FE_W::new(self, 2)
            }
            ///Bit 3 - Output compare 1 preload enable
            #[inline(always)]
            #[must_use]
            pub fn oc1pe(&mut self) -> OC1PE_W<CHCTLR1_OUTPUT_SPEC> {
                OC1PE_W::new(self, 3)
            }
            ///Bits 4:6 - Output compare 1 mode
            #[inline(always)]
            #[must_use]
            pub fn oc1m(&mut self) -> OC1M_W<CHCTLR1_OUTPUT_SPEC> {
                OC1M_W::new(self, 4)
            }
            ///Bit 7 - Output compare 1 clear enable
            #[inline(always)]
            #[must_use]
            pub fn oc1ce(&mut self) -> OC1CE_W<CHCTLR1_OUTPUT_SPEC> {
                OC1CE_W::new(self, 7)
            }
            ///Bits 8:9 - Capture/Compare 2 selection
            #[inline(always)]
            #[must_use]
            pub fn cc2s(&mut self) -> CC2S_W<CHCTLR1_OUTPUT_SPEC> {
                CC2S_W::new(self, 8)
            }
            ///Bit 10 - Output compare 2 fast enable
            #[inline(always)]
            #[must_use]
            pub fn oc2fe(&mut self) -> OC2FE_W<CHCTLR1_OUTPUT_SPEC> {
                OC2FE_W::new(self, 10)
            }
            ///Bit 11 - Output compare 2 preload enable
            #[inline(always)]
            #[must_use]
            pub fn oc2pe(&mut self) -> OC2PE_W<CHCTLR1_OUTPUT_SPEC> {
                OC2PE_W::new(self, 11)
            }
            ///Bits 12:14 - Output compare 2 mode
            #[inline(always)]
            #[must_use]
            pub fn oc2m(&mut self) -> OC2M_W<CHCTLR1_OUTPUT_SPEC> {
                OC2M_W::new(self, 12)
            }
            ///Bit 15 - Output compare 2 clear enable
            #[inline(always)]
            #[must_use]
            pub fn oc2ce(&mut self) -> OC2CE_W<CHCTLR1_OUTPUT_SPEC> {
                OC2CE_W::new(self, 15)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///capture/compare mode register 1 (output mode)
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`chctlr1_output::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`chctlr1_output::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct CHCTLR1_OUTPUT_SPEC;
        impl crate::RegisterSpec for CHCTLR1_OUTPUT_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`chctlr1_output::R`](R) reader structure
        impl crate::Readable for CHCTLR1_OUTPUT_SPEC {}
        ///`write(|w| ..)` method takes [`chctlr1_output::W`](W) writer structure
        impl crate::Writable for CHCTLR1_OUTPUT_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets CHCTLR1_Output to value 0
        impl crate::Resettable for CHCTLR1_OUTPUT_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///CHCTLR1_Input (rw) register accessor: capture/compare mode register 1 (input mode)
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`chctlr1_input::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`chctlr1_input::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@chctlr1_input`]
    ///module
    pub type CHCTLR1_INPUT = crate::Reg<chctlr1_input::CHCTLR1_INPUT_SPEC>;
    ///capture/compare mode register 1 (input mode)
    pub mod chctlr1_input {
        ///Register `CHCTLR1_Input` reader
        pub type R = crate::R<CHCTLR1_INPUT_SPEC>;
        ///Register `CHCTLR1_Input` writer
        pub type W = crate::W<CHCTLR1_INPUT_SPEC>;
        ///Field `CC1S` reader - Capture/Compare 1 selection
        pub type CC1S_R = crate::FieldReader;
        ///Field `CC1S` writer - Capture/Compare 1 selection
        pub type CC1S_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `IC1PSC` reader - Input capture 1 prescaler
        pub type IC1PSC_R = crate::FieldReader;
        ///Field `IC1PSC` writer - Input capture 1 prescaler
        pub type IC1PSC_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `IC1F` reader - Input capture 1 filter
        pub type IC1F_R = crate::FieldReader;
        ///Field `IC1F` writer - Input capture 1 filter
        pub type IC1F_W<'a, REG> = crate::FieldWriter<'a, REG, 4>;
        ///Field `CC2S` reader - Capture/compare 2 selection
        pub type CC2S_R = crate::FieldReader;
        ///Field `CC2S` writer - Capture/compare 2 selection
        pub type CC2S_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `IC2PSC` reader - Input capture 2 prescaler
        pub type IC2PSC_R = crate::FieldReader;
        ///Field `IC2PSC` writer - Input capture 2 prescaler
        pub type IC2PSC_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `IC2F` reader - Input capture 2 filter
        pub type IC2F_R = crate::FieldReader;
        ///Field `IC2F` writer - Input capture 2 filter
        pub type IC2F_W<'a, REG> = crate::FieldWriter<'a, REG, 4>;
        impl R {
            ///Bits 0:1 - Capture/Compare 1 selection
            #[inline(always)]
            pub fn cc1s(&self) -> CC1S_R {
                CC1S_R::new((self.bits & 3) as u8)
            }
            ///Bits 2:3 - Input capture 1 prescaler
            #[inline(always)]
            pub fn ic1psc(&self) -> IC1PSC_R {
                IC1PSC_R::new(((self.bits >> 2) & 3) as u8)
            }
            ///Bits 4:7 - Input capture 1 filter
            #[inline(always)]
            pub fn ic1f(&self) -> IC1F_R {
                IC1F_R::new(((self.bits >> 4) & 0x0f) as u8)
            }
            ///Bits 8:9 - Capture/compare 2 selection
            #[inline(always)]
            pub fn cc2s(&self) -> CC2S_R {
                CC2S_R::new(((self.bits >> 8) & 3) as u8)
            }
            ///Bits 10:11 - Input capture 2 prescaler
            #[inline(always)]
            pub fn ic2psc(&self) -> IC2PSC_R {
                IC2PSC_R::new(((self.bits >> 10) & 3) as u8)
            }
            ///Bits 12:15 - Input capture 2 filter
            #[inline(always)]
            pub fn ic2f(&self) -> IC2F_R {
                IC2F_R::new(((self.bits >> 12) & 0x0f) as u8)
            }
        }
        impl W {
            ///Bits 0:1 - Capture/Compare 1 selection
            #[inline(always)]
            #[must_use]
            pub fn cc1s(&mut self) -> CC1S_W<CHCTLR1_INPUT_SPEC> {
                CC1S_W::new(self, 0)
            }
            ///Bits 2:3 - Input capture 1 prescaler
            #[inline(always)]
            #[must_use]
            pub fn ic1psc(&mut self) -> IC1PSC_W<CHCTLR1_INPUT_SPEC> {
                IC1PSC_W::new(self, 2)
            }
            ///Bits 4:7 - Input capture 1 filter
            #[inline(always)]
            #[must_use]
            pub fn ic1f(&mut self) -> IC1F_W<CHCTLR1_INPUT_SPEC> {
                IC1F_W::new(self, 4)
            }
            ///Bits 8:9 - Capture/compare 2 selection
            #[inline(always)]
            #[must_use]
            pub fn cc2s(&mut self) -> CC2S_W<CHCTLR1_INPUT_SPEC> {
                CC2S_W::new(self, 8)
            }
            ///Bits 10:11 - Input capture 2 prescaler
            #[inline(always)]
            #[must_use]
            pub fn ic2psc(&mut self) -> IC2PSC_W<CHCTLR1_INPUT_SPEC> {
                IC2PSC_W::new(self, 10)
            }
            ///Bits 12:15 - Input capture 2 filter
            #[inline(always)]
            #[must_use]
            pub fn ic2f(&mut self) -> IC2F_W<CHCTLR1_INPUT_SPEC> {
                IC2F_W::new(self, 12)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///capture/compare mode register 1 (input mode)
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`chctlr1_input::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`chctlr1_input::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct CHCTLR1_INPUT_SPEC;
        impl crate::RegisterSpec for CHCTLR1_INPUT_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`chctlr1_input::R`](R) reader structure
        impl crate::Readable for CHCTLR1_INPUT_SPEC {}
        ///`write(|w| ..)` method takes [`chctlr1_input::W`](W) writer structure
        impl crate::Writable for CHCTLR1_INPUT_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets CHCTLR1_Input to value 0
        impl crate::Resettable for CHCTLR1_INPUT_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///CHCTLR2_Output (rw) register accessor: capture/compare mode register 2 (output mode)
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`chctlr2_output::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`chctlr2_output::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@chctlr2_output`]
    ///module
    pub type CHCTLR2_OUTPUT = crate::Reg<chctlr2_output::CHCTLR2_OUTPUT_SPEC>;
    ///capture/compare mode register 2 (output mode)
    pub mod chctlr2_output {
        ///Register `CHCTLR2_Output` reader
        pub type R = crate::R<CHCTLR2_OUTPUT_SPEC>;
        ///Register `CHCTLR2_Output` writer
        pub type W = crate::W<CHCTLR2_OUTPUT_SPEC>;
        ///Field `CC3S` reader - Capture/Compare 3 selection
        pub type CC3S_R = crate::FieldReader;
        ///Field `CC3S` writer - Capture/Compare 3 selection
        pub type CC3S_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `OC3FE` reader - Output compare 3 fast enable
        pub type OC3FE_R = crate::BitReader;
        ///Field `OC3FE` writer - Output compare 3 fast enable
        pub type OC3FE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `OC3PE` reader - Output compare 3 preload enable
        pub type OC3PE_R = crate::BitReader;
        ///Field `OC3PE` writer - Output compare 3 preload enable
        pub type OC3PE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `OC3M` reader - Output compare 3 mode
        pub type OC3M_R = crate::FieldReader;
        ///Field `OC3M` writer - Output compare 3 mode
        pub type OC3M_W<'a, REG> = crate::FieldWriter<'a, REG, 3>;
        ///Field `OC3CE` reader - Output compare 3 clear enable
        pub type OC3CE_R = crate::BitReader;
        ///Field `OC3CE` writer - Output compare 3 clear enable
        pub type OC3CE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CC4S` reader - Capture/Compare 4 selection
        pub type CC4S_R = crate::FieldReader;
        ///Field `CC4S` writer - Capture/Compare 4 selection
        pub type CC4S_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `OC4FE` reader - Output compare 4 fast enable
        pub type OC4FE_R = crate::BitReader;
        ///Field `OC4FE` writer - Output compare 4 fast enable
        pub type OC4FE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `OC4PE` reader - Output compare 4 preload enable
        pub type OC4PE_R = crate::BitReader;
        ///Field `OC4PE` writer - Output compare 4 preload enable
        pub type OC4PE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `OC4M` reader - Output compare 4 mode
        pub type OC4M_R = crate::FieldReader;
        ///Field `OC4M` writer - Output compare 4 mode
        pub type OC4M_W<'a, REG> = crate::FieldWriter<'a, REG, 3>;
        ///Field `OC4CE` reader - Output compare 4 clear enable
        pub type OC4CE_R = crate::BitReader;
        ///Field `OC4CE` writer - Output compare 4 clear enable
        pub type OC4CE_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bits 0:1 - Capture/Compare 3 selection
            #[inline(always)]
            pub fn cc3s(&self) -> CC3S_R {
                CC3S_R::new((self.bits & 3) as u8)
            }
            ///Bit 2 - Output compare 3 fast enable
            #[inline(always)]
            pub fn oc3fe(&self) -> OC3FE_R {
                OC3FE_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - Output compare 3 preload enable
            #[inline(always)]
            pub fn oc3pe(&self) -> OC3PE_R {
                OC3PE_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bits 4:6 - Output compare 3 mode
            #[inline(always)]
            pub fn oc3m(&self) -> OC3M_R {
                OC3M_R::new(((self.bits >> 4) & 7) as u8)
            }
            ///Bit 7 - Output compare 3 clear enable
            #[inline(always)]
            pub fn oc3ce(&self) -> OC3CE_R {
                OC3CE_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bits 8:9 - Capture/Compare 4 selection
            #[inline(always)]
            pub fn cc4s(&self) -> CC4S_R {
                CC4S_R::new(((self.bits >> 8) & 3) as u8)
            }
            ///Bit 10 - Output compare 4 fast enable
            #[inline(always)]
            pub fn oc4fe(&self) -> OC4FE_R {
                OC4FE_R::new(((self.bits >> 10) & 1) != 0)
            }
            ///Bit 11 - Output compare 4 preload enable
            #[inline(always)]
            pub fn oc4pe(&self) -> OC4PE_R {
                OC4PE_R::new(((self.bits >> 11) & 1) != 0)
            }
            ///Bits 12:14 - Output compare 4 mode
            #[inline(always)]
            pub fn oc4m(&self) -> OC4M_R {
                OC4M_R::new(((self.bits >> 12) & 7) as u8)
            }
            ///Bit 15 - Output compare 4 clear enable
            #[inline(always)]
            pub fn oc4ce(&self) -> OC4CE_R {
                OC4CE_R::new(((self.bits >> 15) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:1 - Capture/Compare 3 selection
            #[inline(always)]
            #[must_use]
            pub fn cc3s(&mut self) -> CC3S_W<CHCTLR2_OUTPUT_SPEC> {
                CC3S_W::new(self, 0)
            }
            ///Bit 2 - Output compare 3 fast enable
            #[inline(always)]
            #[must_use]
            pub fn oc3fe(&mut self) -> OC3FE_W<CHCTLR2_OUTPUT_SPEC> {
                OC3FE_W::new(self, 2)
            }
            ///Bit 3 - Output compare 3 preload enable
            #[inline(always)]
            #[must_use]
            pub fn oc3pe(&mut self) -> OC3PE_W<CHCTLR2_OUTPUT_SPEC> {
                OC3PE_W::new(self, 3)
            }
            ///Bits 4:6 - Output compare 3 mode
            #[inline(always)]
            #[must_use]
            pub fn oc3m(&mut self) -> OC3M_W<CHCTLR2_OUTPUT_SPEC> {
                OC3M_W::new(self, 4)
            }
            ///Bit 7 - Output compare 3 clear enable
            #[inline(always)]
            #[must_use]
            pub fn oc3ce(&mut self) -> OC3CE_W<CHCTLR2_OUTPUT_SPEC> {
                OC3CE_W::new(self, 7)
            }
            ///Bits 8:9 - Capture/Compare 4 selection
            #[inline(always)]
            #[must_use]
            pub fn cc4s(&mut self) -> CC4S_W<CHCTLR2_OUTPUT_SPEC> {
                CC4S_W::new(self, 8)
            }
            ///Bit 10 - Output compare 4 fast enable
            #[inline(always)]
            #[must_use]
            pub fn oc4fe(&mut self) -> OC4FE_W<CHCTLR2_OUTPUT_SPEC> {
                OC4FE_W::new(self, 10)
            }
            ///Bit 11 - Output compare 4 preload enable
            #[inline(always)]
            #[must_use]
            pub fn oc4pe(&mut self) -> OC4PE_W<CHCTLR2_OUTPUT_SPEC> {
                OC4PE_W::new(self, 11)
            }
            ///Bits 12:14 - Output compare 4 mode
            #[inline(always)]
            #[must_use]
            pub fn oc4m(&mut self) -> OC4M_W<CHCTLR2_OUTPUT_SPEC> {
                OC4M_W::new(self, 12)
            }
            ///Bit 15 - Output compare 4 clear enable
            #[inline(always)]
            #[must_use]
            pub fn oc4ce(&mut self) -> OC4CE_W<CHCTLR2_OUTPUT_SPEC> {
                OC4CE_W::new(self, 15)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///capture/compare mode register 2 (output mode)
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`chctlr2_output::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`chctlr2_output::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct CHCTLR2_OUTPUT_SPEC;
        impl crate::RegisterSpec for CHCTLR2_OUTPUT_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`chctlr2_output::R`](R) reader structure
        impl crate::Readable for CHCTLR2_OUTPUT_SPEC {}
        ///`write(|w| ..)` method takes [`chctlr2_output::W`](W) writer structure
        impl crate::Writable for CHCTLR2_OUTPUT_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets CHCTLR2_Output to value 0
        impl crate::Resettable for CHCTLR2_OUTPUT_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///CHCTLR2_Input (rw) register accessor: capture/compare mode register 2 (input mode)
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`chctlr2_input::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`chctlr2_input::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@chctlr2_input`]
    ///module
    pub type CHCTLR2_INPUT = crate::Reg<chctlr2_input::CHCTLR2_INPUT_SPEC>;
    ///capture/compare mode register 2 (input mode)
    pub mod chctlr2_input {
        ///Register `CHCTLR2_Input` reader
        pub type R = crate::R<CHCTLR2_INPUT_SPEC>;
        ///Register `CHCTLR2_Input` writer
        pub type W = crate::W<CHCTLR2_INPUT_SPEC>;
        ///Field `CC3S` reader - Capture/Compare 3 selection
        pub type CC3S_R = crate::FieldReader;
        ///Field `CC3S` writer - Capture/Compare 3 selection
        pub type CC3S_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `IC3PSC` reader - Input capture 3 prescaler
        pub type IC3PSC_R = crate::FieldReader;
        ///Field `IC3PSC` writer - Input capture 3 prescaler
        pub type IC3PSC_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `IC3F` reader - Input capture 3 filter
        pub type IC3F_R = crate::FieldReader;
        ///Field `IC3F` writer - Input capture 3 filter
        pub type IC3F_W<'a, REG> = crate::FieldWriter<'a, REG, 4>;
        ///Field `CC4S` reader - Capture/Compare 4 selection
        pub type CC4S_R = crate::FieldReader;
        ///Field `CC4S` writer - Capture/Compare 4 selection
        pub type CC4S_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `IC4PSC` reader - Input capture 4 prescaler
        pub type IC4PSC_R = crate::FieldReader;
        ///Field `IC4PSC` writer - Input capture 4 prescaler
        pub type IC4PSC_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `IC4F` reader - Input capture 4 filter
        pub type IC4F_R = crate::FieldReader;
        ///Field `IC4F` writer - Input capture 4 filter
        pub type IC4F_W<'a, REG> = crate::FieldWriter<'a, REG, 4>;
        impl R {
            ///Bits 0:1 - Capture/Compare 3 selection
            #[inline(always)]
            pub fn cc3s(&self) -> CC3S_R {
                CC3S_R::new((self.bits & 3) as u8)
            }
            ///Bits 2:3 - Input capture 3 prescaler
            #[inline(always)]
            pub fn ic3psc(&self) -> IC3PSC_R {
                IC3PSC_R::new(((self.bits >> 2) & 3) as u8)
            }
            ///Bits 4:7 - Input capture 3 filter
            #[inline(always)]
            pub fn ic3f(&self) -> IC3F_R {
                IC3F_R::new(((self.bits >> 4) & 0x0f) as u8)
            }
            ///Bits 8:9 - Capture/Compare 4 selection
            #[inline(always)]
            pub fn cc4s(&self) -> CC4S_R {
                CC4S_R::new(((self.bits >> 8) & 3) as u8)
            }
            ///Bits 10:11 - Input capture 4 prescaler
            #[inline(always)]
            pub fn ic4psc(&self) -> IC4PSC_R {
                IC4PSC_R::new(((self.bits >> 10) & 3) as u8)
            }
            ///Bits 12:15 - Input capture 4 filter
            #[inline(always)]
            pub fn ic4f(&self) -> IC4F_R {
                IC4F_R::new(((self.bits >> 12) & 0x0f) as u8)
            }
        }
        impl W {
            ///Bits 0:1 - Capture/Compare 3 selection
            #[inline(always)]
            #[must_use]
            pub fn cc3s(&mut self) -> CC3S_W<CHCTLR2_INPUT_SPEC> {
                CC3S_W::new(self, 0)
            }
            ///Bits 2:3 - Input capture 3 prescaler
            #[inline(always)]
            #[must_use]
            pub fn ic3psc(&mut self) -> IC3PSC_W<CHCTLR2_INPUT_SPEC> {
                IC3PSC_W::new(self, 2)
            }
            ///Bits 4:7 - Input capture 3 filter
            #[inline(always)]
            #[must_use]
            pub fn ic3f(&mut self) -> IC3F_W<CHCTLR2_INPUT_SPEC> {
                IC3F_W::new(self, 4)
            }
            ///Bits 8:9 - Capture/Compare 4 selection
            #[inline(always)]
            #[must_use]
            pub fn cc4s(&mut self) -> CC4S_W<CHCTLR2_INPUT_SPEC> {
                CC4S_W::new(self, 8)
            }
            ///Bits 10:11 - Input capture 4 prescaler
            #[inline(always)]
            #[must_use]
            pub fn ic4psc(&mut self) -> IC4PSC_W<CHCTLR2_INPUT_SPEC> {
                IC4PSC_W::new(self, 10)
            }
            ///Bits 12:15 - Input capture 4 filter
            #[inline(always)]
            #[must_use]
            pub fn ic4f(&mut self) -> IC4F_W<CHCTLR2_INPUT_SPEC> {
                IC4F_W::new(self, 12)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///capture/compare mode register 2 (input mode)
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`chctlr2_input::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`chctlr2_input::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct CHCTLR2_INPUT_SPEC;
        impl crate::RegisterSpec for CHCTLR2_INPUT_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`chctlr2_input::R`](R) reader structure
        impl crate::Readable for CHCTLR2_INPUT_SPEC {}
        ///`write(|w| ..)` method takes [`chctlr2_input::W`](W) writer structure
        impl crate::Writable for CHCTLR2_INPUT_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets CHCTLR2_Input to value 0
        impl crate::Resettable for CHCTLR2_INPUT_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///CCER (rw) register accessor: capture/compare enable register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`ccer::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ccer::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@ccer`]
    ///module
    pub type CCER = crate::Reg<ccer::CCER_SPEC>;
    ///capture/compare enable register
    pub mod ccer {
        ///Register `CCER` reader
        pub type R = crate::R<CCER_SPEC>;
        ///Register `CCER` writer
        pub type W = crate::W<CCER_SPEC>;
        ///Field `CC1E` reader - Capture/Compare 1 output enable
        pub type CC1E_R = crate::BitReader;
        ///Field `CC1E` writer - Capture/Compare 1 output enable
        pub type CC1E_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CC1P` reader - Capture/Compare 1 output Polarity
        pub type CC1P_R = crate::BitReader;
        ///Field `CC1P` writer - Capture/Compare 1 output Polarity
        pub type CC1P_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CC2E` reader - Capture/Compare 2 output enable
        pub type CC2E_R = crate::BitReader;
        ///Field `CC2E` writer - Capture/Compare 2 output enable
        pub type CC2E_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CC2P` reader - Capture/Compare 2 output Polarity
        pub type CC2P_R = crate::BitReader;
        ///Field `CC2P` writer - Capture/Compare 2 output Polarity
        pub type CC2P_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CC3E` reader - Capture/Compare 3 output enable
        pub type CC3E_R = crate::BitReader;
        ///Field `CC3E` writer - Capture/Compare 3 output enable
        pub type CC3E_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CC3P` reader - Capture/Compare 3 output Polarity
        pub type CC3P_R = crate::BitReader;
        ///Field `CC3P` writer - Capture/Compare 3 output Polarity
        pub type CC3P_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CC4E` reader - Capture/Compare 4 output enable
        pub type CC4E_R = crate::BitReader;
        ///Field `CC4E` writer - Capture/Compare 4 output enable
        pub type CC4E_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CC4P` reader - Capture/Compare 3 output Polarity
        pub type CC4P_R = crate::BitReader;
        ///Field `CC4P` writer - Capture/Compare 3 output Polarity
        pub type CC4P_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - Capture/Compare 1 output enable
            #[inline(always)]
            pub fn cc1e(&self) -> CC1E_R {
                CC1E_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Capture/Compare 1 output Polarity
            #[inline(always)]
            pub fn cc1p(&self) -> CC1P_R {
                CC1P_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 4 - Capture/Compare 2 output enable
            #[inline(always)]
            pub fn cc2e(&self) -> CC2E_R {
                CC2E_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - Capture/Compare 2 output Polarity
            #[inline(always)]
            pub fn cc2p(&self) -> CC2P_R {
                CC2P_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 8 - Capture/Compare 3 output enable
            #[inline(always)]
            pub fn cc3e(&self) -> CC3E_R {
                CC3E_R::new(((self.bits >> 8) & 1) != 0)
            }
            ///Bit 9 - Capture/Compare 3 output Polarity
            #[inline(always)]
            pub fn cc3p(&self) -> CC3P_R {
                CC3P_R::new(((self.bits >> 9) & 1) != 0)
            }
            ///Bit 12 - Capture/Compare 4 output enable
            #[inline(always)]
            pub fn cc4e(&self) -> CC4E_R {
                CC4E_R::new(((self.bits >> 12) & 1) != 0)
            }
            ///Bit 13 - Capture/Compare 3 output Polarity
            #[inline(always)]
            pub fn cc4p(&self) -> CC4P_R {
                CC4P_R::new(((self.bits >> 13) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - Capture/Compare 1 output enable
            #[inline(always)]
            #[must_use]
            pub fn cc1e(&mut self) -> CC1E_W<CCER_SPEC> {
                CC1E_W::new(self, 0)
            }
            ///Bit 1 - Capture/Compare 1 output Polarity
            #[inline(always)]
            #[must_use]
            pub fn cc1p(&mut self) -> CC1P_W<CCER_SPEC> {
                CC1P_W::new(self, 1)
            }
            ///Bit 4 - Capture/Compare 2 output enable
            #[inline(always)]
            #[must_use]
            pub fn cc2e(&mut self) -> CC2E_W<CCER_SPEC> {
                CC2E_W::new(self, 4)
            }
            ///Bit 5 - Capture/Compare 2 output Polarity
            #[inline(always)]
            #[must_use]
            pub fn cc2p(&mut self) -> CC2P_W<CCER_SPEC> {
                CC2P_W::new(self, 5)
            }
            ///Bit 8 - Capture/Compare 3 output enable
            #[inline(always)]
            #[must_use]
            pub fn cc3e(&mut self) -> CC3E_W<CCER_SPEC> {
                CC3E_W::new(self, 8)
            }
            ///Bit 9 - Capture/Compare 3 output Polarity
            #[inline(always)]
            #[must_use]
            pub fn cc3p(&mut self) -> CC3P_W<CCER_SPEC> {
                CC3P_W::new(self, 9)
            }
            ///Bit 12 - Capture/Compare 4 output enable
            #[inline(always)]
            #[must_use]
            pub fn cc4e(&mut self) -> CC4E_W<CCER_SPEC> {
                CC4E_W::new(self, 12)
            }
            ///Bit 13 - Capture/Compare 3 output Polarity
            #[inline(always)]
            #[must_use]
            pub fn cc4p(&mut self) -> CC4P_W<CCER_SPEC> {
                CC4P_W::new(self, 13)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///capture/compare enable register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`ccer::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ccer::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct CCER_SPEC;
        impl crate::RegisterSpec for CCER_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`ccer::R`](R) reader structure
        impl crate::Readable for CCER_SPEC {}
        ///`write(|w| ..)` method takes [`ccer::W`](W) writer structure
        impl crate::Writable for CCER_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets CCER to value 0
        impl crate::Resettable for CCER_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///CNT (rw) register accessor: counter
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`cnt::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cnt::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@cnt`]
    ///module
    pub type CNT = crate::Reg<cnt::CNT_SPEC>;
    ///counter
    pub mod cnt {
        ///Register `CNT` reader
        pub type R = crate::R<CNT_SPEC>;
        ///Register `CNT` writer
        pub type W = crate::W<CNT_SPEC>;
        ///Field `CNT` reader - counter value
        pub type CNT_R = crate::FieldReader<u32>;
        ///Field `CNT` writer - counter value
        pub type CNT_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - counter value
            #[inline(always)]
            pub fn cnt(&self) -> CNT_R {
                CNT_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - counter value
            #[inline(always)]
            #[must_use]
            pub fn cnt(&mut self) -> CNT_W<CNT_SPEC> {
                CNT_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///counter
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`cnt::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cnt::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct CNT_SPEC;
        impl crate::RegisterSpec for CNT_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`cnt::R`](R) reader structure
        impl crate::Readable for CNT_SPEC {}
        ///`write(|w| ..)` method takes [`cnt::W`](W) writer structure
        impl crate::Writable for CNT_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets CNT to value 0
        impl crate::Resettable for CNT_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///PSC (rw) register accessor: prescaler
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`psc::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`psc::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@psc`]
    ///module
    pub type PSC = crate::Reg<psc::PSC_SPEC>;
    ///prescaler
    pub mod psc {
        ///Register `PSC` reader
        pub type R = crate::R<PSC_SPEC>;
        ///Register `PSC` writer
        pub type W = crate::W<PSC_SPEC>;
        ///Field `PSC` reader - Prescaler value
        pub type PSC_R = crate::FieldReader<u16>;
        ///Field `PSC` writer - Prescaler value
        pub type PSC_W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            ///Bits 0:15 - Prescaler value
            #[inline(always)]
            pub fn psc(&self) -> PSC_R {
                PSC_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - Prescaler value
            #[inline(always)]
            #[must_use]
            pub fn psc(&mut self) -> PSC_W<PSC_SPEC> {
                PSC_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///prescaler
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`psc::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`psc::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct PSC_SPEC;
        impl crate::RegisterSpec for PSC_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`psc::R`](R) reader structure
        impl crate::Readable for PSC_SPEC {}
        ///`write(|w| ..)` method takes [`psc::W`](W) writer structure
        impl crate::Writable for PSC_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets PSC to value 0
        impl crate::Resettable for PSC_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///ATRLR (rw) register accessor: auto-reload register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`atrlr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`atrlr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@atrlr`]
    ///module
    pub type ATRLR = crate::Reg<atrlr::ATRLR_SPEC>;
    ///auto-reload register
    pub mod atrlr {
        ///Register `ATRLR` reader
        pub type R = crate::R<ATRLR_SPEC>;
        ///Register `ATRLR` writer
        pub type W = crate::W<ATRLR_SPEC>;
        ///Field `ARR` reader - Auto-reload value
        pub type ARR_R = crate::FieldReader<u32>;
        ///Field `ARR` writer - Auto-reload value
        pub type ARR_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - Auto-reload value
            #[inline(always)]
            pub fn arr(&self) -> ARR_R {
                ARR_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - Auto-reload value
            #[inline(always)]
            #[must_use]
            pub fn arr(&mut self) -> ARR_W<ATRLR_SPEC> {
                ARR_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///auto-reload register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`atrlr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`atrlr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct ATRLR_SPEC;
        impl crate::RegisterSpec for ATRLR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`atrlr::R`](R) reader structure
        impl crate::Readable for ATRLR_SPEC {}
        ///`write(|w| ..)` method takes [`atrlr::W`](W) writer structure
        impl crate::Writable for ATRLR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets ATRLR to value 0
        impl crate::Resettable for ATRLR_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///CH1CVR (rw) register accessor: capture/compare register 1
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`ch1cvr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ch1cvr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@ch1cvr`]
    ///module
    pub type CH1CVR = crate::Reg<ch1cvr::CH1CVR_SPEC>;
    ///capture/compare register 1
    pub mod ch1cvr {
        ///Register `CH1CVR` reader
        pub type R = crate::R<CH1CVR_SPEC>;
        ///Register `CH1CVR` writer
        pub type W = crate::W<CH1CVR_SPEC>;
        ///Field `CCR1` reader - Capture/Compare 1 value
        pub type CCR1_R = crate::FieldReader<u32>;
        ///Field `CCR1` writer - Capture/Compare 1 value
        pub type CCR1_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - Capture/Compare 1 value
            #[inline(always)]
            pub fn ccr1(&self) -> CCR1_R {
                CCR1_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - Capture/Compare 1 value
            #[inline(always)]
            #[must_use]
            pub fn ccr1(&mut self) -> CCR1_W<CH1CVR_SPEC> {
                CCR1_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///capture/compare register 1
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`ch1cvr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ch1cvr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct CH1CVR_SPEC;
        impl crate::RegisterSpec for CH1CVR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`ch1cvr::R`](R) reader structure
        impl crate::Readable for CH1CVR_SPEC {}
        ///`write(|w| ..)` method takes [`ch1cvr::W`](W) writer structure
        impl crate::Writable for CH1CVR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets CH1CVR to value 0
        impl crate::Resettable for CH1CVR_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///CH2CVR (rw) register accessor: capture/compare register 2
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`ch2cvr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ch2cvr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@ch2cvr`]
    ///module
    pub type CH2CVR = crate::Reg<ch2cvr::CH2CVR_SPEC>;
    ///capture/compare register 2
    pub mod ch2cvr {
        ///Register `CH2CVR` reader
        pub type R = crate::R<CH2CVR_SPEC>;
        ///Register `CH2CVR` writer
        pub type W = crate::W<CH2CVR_SPEC>;
        ///Field `CCR2` reader - Capture/Compare 2 value
        pub type CCR2_R = crate::FieldReader<u32>;
        ///Field `CCR2` writer - Capture/Compare 2 value
        pub type CCR2_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - Capture/Compare 2 value
            #[inline(always)]
            pub fn ccr2(&self) -> CCR2_R {
                CCR2_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - Capture/Compare 2 value
            #[inline(always)]
            #[must_use]
            pub fn ccr2(&mut self) -> CCR2_W<CH2CVR_SPEC> {
                CCR2_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///capture/compare register 2
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`ch2cvr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ch2cvr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct CH2CVR_SPEC;
        impl crate::RegisterSpec for CH2CVR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`ch2cvr::R`](R) reader structure
        impl crate::Readable for CH2CVR_SPEC {}
        ///`write(|w| ..)` method takes [`ch2cvr::W`](W) writer structure
        impl crate::Writable for CH2CVR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets CH2CVR to value 0
        impl crate::Resettable for CH2CVR_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///CH3CVR (rw) register accessor: capture/compare register 3
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`ch3cvr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ch3cvr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@ch3cvr`]
    ///module
    pub type CH3CVR = crate::Reg<ch3cvr::CH3CVR_SPEC>;
    ///capture/compare register 3
    pub mod ch3cvr {
        ///Register `CH3CVR` reader
        pub type R = crate::R<CH3CVR_SPEC>;
        ///Register `CH3CVR` writer
        pub type W = crate::W<CH3CVR_SPEC>;
        ///Field `CCR3` reader - Capture/Compare value
        pub type CCR3_R = crate::FieldReader<u32>;
        ///Field `CCR3` writer - Capture/Compare value
        pub type CCR3_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - Capture/Compare value
            #[inline(always)]
            pub fn ccr3(&self) -> CCR3_R {
                CCR3_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - Capture/Compare value
            #[inline(always)]
            #[must_use]
            pub fn ccr3(&mut self) -> CCR3_W<CH3CVR_SPEC> {
                CCR3_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///capture/compare register 3
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`ch3cvr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ch3cvr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct CH3CVR_SPEC;
        impl crate::RegisterSpec for CH3CVR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`ch3cvr::R`](R) reader structure
        impl crate::Readable for CH3CVR_SPEC {}
        ///`write(|w| ..)` method takes [`ch3cvr::W`](W) writer structure
        impl crate::Writable for CH3CVR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets CH3CVR to value 0
        impl crate::Resettable for CH3CVR_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///CH4CVR (rw) register accessor: capture/compare register 4
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`ch4cvr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ch4cvr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@ch4cvr`]
    ///module
    pub type CH4CVR = crate::Reg<ch4cvr::CH4CVR_SPEC>;
    ///capture/compare register 4
    pub mod ch4cvr {
        ///Register `CH4CVR` reader
        pub type R = crate::R<CH4CVR_SPEC>;
        ///Register `CH4CVR` writer
        pub type W = crate::W<CH4CVR_SPEC>;
        ///Field `CCR4` reader - Capture/Compare value
        pub type CCR4_R = crate::FieldReader<u32>;
        ///Field `CCR4` writer - Capture/Compare value
        pub type CCR4_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - Capture/Compare value
            #[inline(always)]
            pub fn ccr4(&self) -> CCR4_R {
                CCR4_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - Capture/Compare value
            #[inline(always)]
            #[must_use]
            pub fn ccr4(&mut self) -> CCR4_W<CH4CVR_SPEC> {
                CCR4_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///capture/compare register 4
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`ch4cvr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ch4cvr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct CH4CVR_SPEC;
        impl crate::RegisterSpec for CH4CVR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`ch4cvr::R`](R) reader structure
        impl crate::Readable for CH4CVR_SPEC {}
        ///`write(|w| ..)` method takes [`ch4cvr::W`](W) writer structure
        impl crate::Writable for CH4CVR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets CH4CVR to value 0
        impl crate::Resettable for CH4CVR_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///DMACFGR (rw) register accessor: DMA control register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`dmacfgr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dmacfgr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@dmacfgr`]
    ///module
    pub type DMACFGR = crate::Reg<dmacfgr::DMACFGR_SPEC>;
    ///DMA control register
    pub mod dmacfgr {
        ///Register `DMACFGR` reader
        pub type R = crate::R<DMACFGR_SPEC>;
        ///Register `DMACFGR` writer
        pub type W = crate::W<DMACFGR_SPEC>;
        ///Field `DBA` reader - DMA base address
        pub type DBA_R = crate::FieldReader;
        ///Field `DBA` writer - DMA base address
        pub type DBA_W<'a, REG> = crate::FieldWriter<'a, REG, 5>;
        ///Field `DBL` reader - DMA burst length
        pub type DBL_R = crate::FieldReader;
        ///Field `DBL` writer - DMA burst length
        pub type DBL_W<'a, REG> = crate::FieldWriter<'a, REG, 5>;
        impl R {
            ///Bits 0:4 - DMA base address
            #[inline(always)]
            pub fn dba(&self) -> DBA_R {
                DBA_R::new((self.bits & 0x1f) as u8)
            }
            ///Bits 8:12 - DMA burst length
            #[inline(always)]
            pub fn dbl(&self) -> DBL_R {
                DBL_R::new(((self.bits >> 8) & 0x1f) as u8)
            }
        }
        impl W {
            ///Bits 0:4 - DMA base address
            #[inline(always)]
            #[must_use]
            pub fn dba(&mut self) -> DBA_W<DMACFGR_SPEC> {
                DBA_W::new(self, 0)
            }
            ///Bits 8:12 - DMA burst length
            #[inline(always)]
            #[must_use]
            pub fn dbl(&mut self) -> DBL_W<DMACFGR_SPEC> {
                DBL_W::new(self, 8)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///DMA control register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`dmacfgr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dmacfgr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct DMACFGR_SPEC;
        impl crate::RegisterSpec for DMACFGR_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`dmacfgr::R`](R) reader structure
        impl crate::Readable for DMACFGR_SPEC {}
        ///`write(|w| ..)` method takes [`dmacfgr::W`](W) writer structure
        impl crate::Writable for DMACFGR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets DMACFGR to value 0
        impl crate::Resettable for DMACFGR_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///DMAADR (rw) register accessor: DMA address for full transfer
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`dmaadr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dmaadr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@dmaadr`]
    ///module
    pub type DMAADR = crate::Reg<dmaadr::DMAADR_SPEC>;
    ///DMA address for full transfer
    pub mod dmaadr {
        ///Register `DMAADR` reader
        pub type R = crate::R<DMAADR_SPEC>;
        ///Register `DMAADR` writer
        pub type W = crate::W<DMAADR_SPEC>;
        ///Field `DMAB` reader - DMA register for burst accesses
        pub type DMAB_R = crate::FieldReader<u32>;
        ///Field `DMAB` writer - DMA register for burst accesses
        pub type DMAB_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - DMA register for burst accesses
            #[inline(always)]
            pub fn dmab(&self) -> DMAB_R {
                DMAB_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - DMA register for burst accesses
            #[inline(always)]
            #[must_use]
            pub fn dmab(&mut self) -> DMAB_W<DMAADR_SPEC> {
                DMAB_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///DMA address for full transfer
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`dmaadr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dmaadr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct DMAADR_SPEC;
        impl crate::RegisterSpec for DMAADR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`dmaadr::R`](R) reader structure
        impl crate::Readable for DMAADR_SPEC {}
        ///`write(|w| ..)` method takes [`dmaadr::W`](W) writer structure
        impl crate::Writable for DMAADR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets DMAADR to value 0
        impl crate::Resettable for DMAADR_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
}
///Inter integrated circuit
pub struct I2C1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for I2C1 {}
impl I2C1 {
    ///Pointer to the register block
    pub const PTR: *const i2c1::RegisterBlock = 0x4000_5400 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const i2c1::RegisterBlock {
        Self::PTR
    }
    /// Steal an instance of this peripheral
    ///
    /// # Safety
    ///
    /// Ensure that the new instance of the peripheral cannot be used in a way
    /// that may race with any existing instances, for example by only
    /// accessing read-only or write-only registers, or by consuming the
    /// original peripheral and using critical sections to coordinate
    /// access between multiple new instances.
    ///
    /// Additionally, other software such as HALs may rely on only one
    /// peripheral instance existing to ensure memory safety; ensure
    /// no stolen instances are passed to such software.
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for I2C1 {
    type Target = i2c1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for I2C1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("I2C1").finish()
    }
}
///Inter integrated circuit
pub mod i2c1 {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        ctlr1: CTLR1,
        _reserved1: [u8; 0x02],
        ctlr2: CTLR2,
        _reserved2: [u8; 0x02],
        oaddr1: OADDR1,
        _reserved3: [u8; 0x02],
        oaddr2: OADDR2,
        _reserved4: [u8; 0x02],
        datar: DATAR,
        _reserved5: [u8; 0x02],
        star1: STAR1,
        star2: STAR2,
        _reserved7: [u8; 0x02],
        ckcfgr: CKCFGR,
        _reserved8: [u8; 0x02],
        rtr: RTR,
    }
    impl RegisterBlock {
        ///0x00 - Control register 1
        #[inline(always)]
        pub const fn ctlr1(&self) -> &CTLR1 {
            &self.ctlr1
        }
        ///0x04 - Control register 2
        #[inline(always)]
        pub const fn ctlr2(&self) -> &CTLR2 {
            &self.ctlr2
        }
        ///0x08 - Own address register 1
        #[inline(always)]
        pub const fn oaddr1(&self) -> &OADDR1 {
            &self.oaddr1
        }
        ///0x0c - Own address register 2
        #[inline(always)]
        pub const fn oaddr2(&self) -> &OADDR2 {
            &self.oaddr2
        }
        ///0x10 - Data register
        #[inline(always)]
        pub const fn datar(&self) -> &DATAR {
            &self.datar
        }
        ///0x14 - Status register 1
        #[inline(always)]
        pub const fn star1(&self) -> &STAR1 {
            &self.star1
        }
        ///0x18 - Status register 2
        #[inline(always)]
        pub const fn star2(&self) -> &STAR2 {
            &self.star2
        }
        ///0x1c - Clock control register
        #[inline(always)]
        pub const fn ckcfgr(&self) -> &CKCFGR {
            &self.ckcfgr
        }
        ///0x20 - Raise time register
        #[inline(always)]
        pub const fn rtr(&self) -> &RTR {
            &self.rtr
        }
    }
    ///CTLR1 (rw) register accessor: Control register 1
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`ctlr1::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ctlr1::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@ctlr1`]
    ///module
    pub type CTLR1 = crate::Reg<ctlr1::CTLR1_SPEC>;
    ///Control register 1
    pub mod ctlr1 {
        ///Register `CTLR1` reader
        pub type R = crate::R<CTLR1_SPEC>;
        ///Register `CTLR1` writer
        pub type W = crate::W<CTLR1_SPEC>;
        ///Field `PE` reader - Peripheral enable
        pub type PE_R = crate::BitReader;
        ///Field `PE` writer - Peripheral enable
        pub type PE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `SMBUS` reader - SMBus mode
        pub type SMBUS_R = crate::BitReader;
        ///Field `SMBUS` writer - SMBus mode
        pub type SMBUS_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `SMBTYPE` reader - SMBus type
        pub type SMBTYPE_R = crate::BitReader;
        ///Field `SMBTYPE` writer - SMBus type
        pub type SMBTYPE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `ENARP` reader - ARP enable
        pub type ENARP_R = crate::BitReader;
        ///Field `ENARP` writer - ARP enable
        pub type ENARP_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `ENPEC` reader - PEC enable
        pub type ENPEC_R = crate::BitReader;
        ///Field `ENPEC` writer - PEC enable
        pub type ENPEC_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `ENGC` reader - General call enable
        pub type ENGC_R = crate::BitReader;
        ///Field `ENGC` writer - General call enable
        pub type ENGC_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `NOSTRETCH` reader - Clock stretching disable (Slave mode)
        pub type NOSTRETCH_R = crate::BitReader;
        ///Field `NOSTRETCH` writer - Clock stretching disable (Slave mode)
        pub type NOSTRETCH_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `START` reader - Start generation
        pub type START_R = crate::BitReader;
        ///Field `START` writer - Start generation
        pub type START_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `STOP` reader - Stop generation
        pub type STOP_R = crate::BitReader;
        ///Field `STOP` writer - Stop generation
        pub type STOP_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `ACK` reader - Acknowledge enable
        pub type ACK_R = crate::BitReader;
        ///Field `ACK` writer - Acknowledge enable
        pub type ACK_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `POS` reader - Acknowledge/PEC Position (for data reception)
        pub type POS_R = crate::BitReader;
        ///Field `POS` writer - Acknowledge/PEC Position (for data reception)
        pub type POS_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PEC` reader - Packet error checking
        pub type PEC_R = crate::BitReader;
        ///Field `PEC` writer - Packet error checking
        pub type PEC_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `ALERT` reader - SMBus alert
        pub type ALERT_R = crate::BitReader;
        ///Field `ALERT` writer - SMBus alert
        pub type ALERT_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `SWRST` reader - Software reset
        pub type SWRST_R = crate::BitReader;
        ///Field `SWRST` writer - Software reset
        pub type SWRST_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - Peripheral enable
            #[inline(always)]
            pub fn pe(&self) -> PE_R {
                PE_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - SMBus mode
            #[inline(always)]
            pub fn smbus(&self) -> SMBUS_R {
                SMBUS_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 3 - SMBus type
            #[inline(always)]
            pub fn smbtype(&self) -> SMBTYPE_R {
                SMBTYPE_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - ARP enable
            #[inline(always)]
            pub fn enarp(&self) -> ENARP_R {
                ENARP_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - PEC enable
            #[inline(always)]
            pub fn enpec(&self) -> ENPEC_R {
                ENPEC_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - General call enable
            #[inline(always)]
            pub fn engc(&self) -> ENGC_R {
                ENGC_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - Clock stretching disable (Slave mode)
            #[inline(always)]
            pub fn nostretch(&self) -> NOSTRETCH_R {
                NOSTRETCH_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bit 8 - Start generation
            #[inline(always)]
            pub fn start(&self) -> START_R {
                START_R::new(((self.bits >> 8) & 1) != 0)
            }
            ///Bit 9 - Stop generation
            #[inline(always)]
            pub fn stop(&self) -> STOP_R {
                STOP_R::new(((self.bits >> 9) & 1) != 0)
            }
            ///Bit 10 - Acknowledge enable
            #[inline(always)]
            pub fn ack(&self) -> ACK_R {
                ACK_R::new(((self.bits >> 10) & 1) != 0)
            }
            ///Bit 11 - Acknowledge/PEC Position (for data reception)
            #[inline(always)]
            pub fn pos(&self) -> POS_R {
                POS_R::new(((self.bits >> 11) & 1) != 0)
            }
            ///Bit 12 - Packet error checking
            #[inline(always)]
            pub fn pec(&self) -> PEC_R {
                PEC_R::new(((self.bits >> 12) & 1) != 0)
            }
            ///Bit 13 - SMBus alert
            #[inline(always)]
            pub fn alert(&self) -> ALERT_R {
                ALERT_R::new(((self.bits >> 13) & 1) != 0)
            }
            ///Bit 15 - Software reset
            #[inline(always)]
            pub fn swrst(&self) -> SWRST_R {
                SWRST_R::new(((self.bits >> 15) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - Peripheral enable
            #[inline(always)]
            #[must_use]
            pub fn pe(&mut self) -> PE_W<CTLR1_SPEC> {
                PE_W::new(self, 0)
            }
            ///Bit 1 - SMBus mode
            #[inline(always)]
            #[must_use]
            pub fn smbus(&mut self) -> SMBUS_W<CTLR1_SPEC> {
                SMBUS_W::new(self, 1)
            }
            ///Bit 3 - SMBus type
            #[inline(always)]
            #[must_use]
            pub fn smbtype(&mut self) -> SMBTYPE_W<CTLR1_SPEC> {
                SMBTYPE_W::new(self, 3)
            }
            ///Bit 4 - ARP enable
            #[inline(always)]
            #[must_use]
            pub fn enarp(&mut self) -> ENARP_W<CTLR1_SPEC> {
                ENARP_W::new(self, 4)
            }
            ///Bit 5 - PEC enable
            #[inline(always)]
            #[must_use]
            pub fn enpec(&mut self) -> ENPEC_W<CTLR1_SPEC> {
                ENPEC_W::new(self, 5)
            }
            ///Bit 6 - General call enable
            #[inline(always)]
            #[must_use]
            pub fn engc(&mut self) -> ENGC_W<CTLR1_SPEC> {
                ENGC_W::new(self, 6)
            }
            ///Bit 7 - Clock stretching disable (Slave mode)
            #[inline(always)]
            #[must_use]
            pub fn nostretch(&mut self) -> NOSTRETCH_W<CTLR1_SPEC> {
                NOSTRETCH_W::new(self, 7)
            }
            ///Bit 8 - Start generation
            #[inline(always)]
            #[must_use]
            pub fn start(&mut self) -> START_W<CTLR1_SPEC> {
                START_W::new(self, 8)
            }
            ///Bit 9 - Stop generation
            #[inline(always)]
            #[must_use]
            pub fn stop(&mut self) -> STOP_W<CTLR1_SPEC> {
                STOP_W::new(self, 9)
            }
            ///Bit 10 - Acknowledge enable
            #[inline(always)]
            #[must_use]
            pub fn ack(&mut self) -> ACK_W<CTLR1_SPEC> {
                ACK_W::new(self, 10)
            }
            ///Bit 11 - Acknowledge/PEC Position (for data reception)
            #[inline(always)]
            #[must_use]
            pub fn pos(&mut self) -> POS_W<CTLR1_SPEC> {
                POS_W::new(self, 11)
            }
            ///Bit 12 - Packet error checking
            #[inline(always)]
            #[must_use]
            pub fn pec(&mut self) -> PEC_W<CTLR1_SPEC> {
                PEC_W::new(self, 12)
            }
            ///Bit 13 - SMBus alert
            #[inline(always)]
            #[must_use]
            pub fn alert(&mut self) -> ALERT_W<CTLR1_SPEC> {
                ALERT_W::new(self, 13)
            }
            ///Bit 15 - Software reset
            #[inline(always)]
            #[must_use]
            pub fn swrst(&mut self) -> SWRST_W<CTLR1_SPEC> {
                SWRST_W::new(self, 15)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Control register 1
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`ctlr1::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ctlr1::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct CTLR1_SPEC;
        impl crate::RegisterSpec for CTLR1_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`ctlr1::R`](R) reader structure
        impl crate::Readable for CTLR1_SPEC {}
        ///`write(|w| ..)` method takes [`ctlr1::W`](W) writer structure
        impl crate::Writable for CTLR1_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets CTLR1 to value 0
        impl crate::Resettable for CTLR1_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///CTLR2 (rw) register accessor: Control register 2
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`ctlr2::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ctlr2::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@ctlr2`]
    ///module
    pub type CTLR2 = crate::Reg<ctlr2::CTLR2_SPEC>;
    ///Control register 2
    pub mod ctlr2 {
        ///Register `CTLR2` reader
        pub type R = crate::R<CTLR2_SPEC>;
        ///Register `CTLR2` writer
        pub type W = crate::W<CTLR2_SPEC>;
        ///Field `FREQ` reader - Peripheral clock frequency
        pub type FREQ_R = crate::FieldReader;
        ///Field `FREQ` writer - Peripheral clock frequency
        pub type FREQ_W<'a, REG> = crate::FieldWriter<'a, REG, 6>;
        ///Field `ITERREN` reader - Error interrupt enable
        pub type ITERREN_R = crate::BitReader;
        ///Field `ITERREN` writer - Error interrupt enable
        pub type ITERREN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `ITEVTEN` reader - Event interrupt enable
        pub type ITEVTEN_R = crate::BitReader;
        ///Field `ITEVTEN` writer - Event interrupt enable
        pub type ITEVTEN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `ITBUFEN` reader - Buffer interrupt enable
        pub type ITBUFEN_R = crate::BitReader;
        ///Field `ITBUFEN` writer - Buffer interrupt enable
        pub type ITBUFEN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `DMAEN` reader - DMA requests enable
        pub type DMAEN_R = crate::BitReader;
        ///Field `DMAEN` writer - DMA requests enable
        pub type DMAEN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `LAST` reader - DMA last transfer
        pub type LAST_R = crate::BitReader;
        ///Field `LAST` writer - DMA last transfer
        pub type LAST_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bits 0:5 - Peripheral clock frequency
            #[inline(always)]
            pub fn freq(&self) -> FREQ_R {
                FREQ_R::new((self.bits & 0x3f) as u8)
            }
            ///Bit 8 - Error interrupt enable
            #[inline(always)]
            pub fn iterren(&self) -> ITERREN_R {
                ITERREN_R::new(((self.bits >> 8) & 1) != 0)
            }
            ///Bit 9 - Event interrupt enable
            #[inline(always)]
            pub fn itevten(&self) -> ITEVTEN_R {
                ITEVTEN_R::new(((self.bits >> 9) & 1) != 0)
            }
            ///Bit 10 - Buffer interrupt enable
            #[inline(always)]
            pub fn itbufen(&self) -> ITBUFEN_R {
                ITBUFEN_R::new(((self.bits >> 10) & 1) != 0)
            }
            ///Bit 11 - DMA requests enable
            #[inline(always)]
            pub fn dmaen(&self) -> DMAEN_R {
                DMAEN_R::new(((self.bits >> 11) & 1) != 0)
            }
            ///Bit 12 - DMA last transfer
            #[inline(always)]
            pub fn last(&self) -> LAST_R {
                LAST_R::new(((self.bits >> 12) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:5 - Peripheral clock frequency
            #[inline(always)]
            #[must_use]
            pub fn freq(&mut self) -> FREQ_W<CTLR2_SPEC> {
                FREQ_W::new(self, 0)
            }
            ///Bit 8 - Error interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn iterren(&mut self) -> ITERREN_W<CTLR2_SPEC> {
                ITERREN_W::new(self, 8)
            }
            ///Bit 9 - Event interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn itevten(&mut self) -> ITEVTEN_W<CTLR2_SPEC> {
                ITEVTEN_W::new(self, 9)
            }
            ///Bit 10 - Buffer interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn itbufen(&mut self) -> ITBUFEN_W<CTLR2_SPEC> {
                ITBUFEN_W::new(self, 10)
            }
            ///Bit 11 - DMA requests enable
            #[inline(always)]
            #[must_use]
            pub fn dmaen(&mut self) -> DMAEN_W<CTLR2_SPEC> {
                DMAEN_W::new(self, 11)
            }
            ///Bit 12 - DMA last transfer
            #[inline(always)]
            #[must_use]
            pub fn last(&mut self) -> LAST_W<CTLR2_SPEC> {
                LAST_W::new(self, 12)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Control register 2
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`ctlr2::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ctlr2::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct CTLR2_SPEC;
        impl crate::RegisterSpec for CTLR2_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`ctlr2::R`](R) reader structure
        impl crate::Readable for CTLR2_SPEC {}
        ///`write(|w| ..)` method takes [`ctlr2::W`](W) writer structure
        impl crate::Writable for CTLR2_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets CTLR2 to value 0
        impl crate::Resettable for CTLR2_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///OADDR1 (rw) register accessor: Own address register 1
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`oaddr1::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`oaddr1::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@oaddr1`]
    ///module
    pub type OADDR1 = crate::Reg<oaddr1::OADDR1_SPEC>;
    ///Own address register 1
    pub mod oaddr1 {
        ///Register `OADDR1` reader
        pub type R = crate::R<OADDR1_SPEC>;
        ///Register `OADDR1` writer
        pub type W = crate::W<OADDR1_SPEC>;
        ///Field `ADD0` reader - Interface address
        pub type ADD0_R = crate::BitReader;
        ///Field `ADD0` writer - Interface address
        pub type ADD0_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `ADD7_1` reader - Interface address
        pub type ADD7_1_R = crate::FieldReader;
        ///Field `ADD7_1` writer - Interface address
        pub type ADD7_1_W<'a, REG> = crate::FieldWriter<'a, REG, 7>;
        ///Field `ADD9_8` reader - Interface address
        pub type ADD9_8_R = crate::FieldReader;
        ///Field `ADD9_8` writer - Interface address
        pub type ADD9_8_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `ADDMODE` reader - Addressing mode (slave mode)
        pub type ADDMODE_R = crate::BitReader;
        ///Field `ADDMODE` writer - Addressing mode (slave mode)
        pub type ADDMODE_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - Interface address
            #[inline(always)]
            pub fn add0(&self) -> ADD0_R {
                ADD0_R::new((self.bits & 1) != 0)
            }
            ///Bits 1:7 - Interface address
            #[inline(always)]
            pub fn add7_1(&self) -> ADD7_1_R {
                ADD7_1_R::new(((self.bits >> 1) & 0x7f) as u8)
            }
            ///Bits 8:9 - Interface address
            #[inline(always)]
            pub fn add9_8(&self) -> ADD9_8_R {
                ADD9_8_R::new(((self.bits >> 8) & 3) as u8)
            }
            ///Bit 15 - Addressing mode (slave mode)
            #[inline(always)]
            pub fn addmode(&self) -> ADDMODE_R {
                ADDMODE_R::new(((self.bits >> 15) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - Interface address
            #[inline(always)]
            #[must_use]
            pub fn add0(&mut self) -> ADD0_W<OADDR1_SPEC> {
                ADD0_W::new(self, 0)
            }
            ///Bits 1:7 - Interface address
            #[inline(always)]
            #[must_use]
            pub fn add7_1(&mut self) -> ADD7_1_W<OADDR1_SPEC> {
                ADD7_1_W::new(self, 1)
            }
            ///Bits 8:9 - Interface address
            #[inline(always)]
            #[must_use]
            pub fn add9_8(&mut self) -> ADD9_8_W<OADDR1_SPEC> {
                ADD9_8_W::new(self, 8)
            }
            ///Bit 15 - Addressing mode (slave mode)
            #[inline(always)]
            #[must_use]
            pub fn addmode(&mut self) -> ADDMODE_W<OADDR1_SPEC> {
                ADDMODE_W::new(self, 15)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Own address register 1
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`oaddr1::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`oaddr1::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct OADDR1_SPEC;
        impl crate::RegisterSpec for OADDR1_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`oaddr1::R`](R) reader structure
        impl crate::Readable for OADDR1_SPEC {}
        ///`write(|w| ..)` method takes [`oaddr1::W`](W) writer structure
        impl crate::Writable for OADDR1_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets OADDR1 to value 0
        impl crate::Resettable for OADDR1_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///OADDR2 (rw) register accessor: Own address register 2
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`oaddr2::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`oaddr2::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@oaddr2`]
    ///module
    pub type OADDR2 = crate::Reg<oaddr2::OADDR2_SPEC>;
    ///Own address register 2
    pub mod oaddr2 {
        ///Register `OADDR2` reader
        pub type R = crate::R<OADDR2_SPEC>;
        ///Register `OADDR2` writer
        pub type W = crate::W<OADDR2_SPEC>;
        ///Field `ENDUAL` reader - Dual addressing mode enable
        pub type ENDUAL_R = crate::BitReader;
        ///Field `ENDUAL` writer - Dual addressing mode enable
        pub type ENDUAL_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `ADD2` reader - Interface address
        pub type ADD2_R = crate::FieldReader;
        ///Field `ADD2` writer - Interface address
        pub type ADD2_W<'a, REG> = crate::FieldWriter<'a, REG, 7>;
        impl R {
            ///Bit 0 - Dual addressing mode enable
            #[inline(always)]
            pub fn endual(&self) -> ENDUAL_R {
                ENDUAL_R::new((self.bits & 1) != 0)
            }
            ///Bits 1:7 - Interface address
            #[inline(always)]
            pub fn add2(&self) -> ADD2_R {
                ADD2_R::new(((self.bits >> 1) & 0x7f) as u8)
            }
        }
        impl W {
            ///Bit 0 - Dual addressing mode enable
            #[inline(always)]
            #[must_use]
            pub fn endual(&mut self) -> ENDUAL_W<OADDR2_SPEC> {
                ENDUAL_W::new(self, 0)
            }
            ///Bits 1:7 - Interface address
            #[inline(always)]
            #[must_use]
            pub fn add2(&mut self) -> ADD2_W<OADDR2_SPEC> {
                ADD2_W::new(self, 1)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Own address register 2
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`oaddr2::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`oaddr2::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct OADDR2_SPEC;
        impl crate::RegisterSpec for OADDR2_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`oaddr2::R`](R) reader structure
        impl crate::Readable for OADDR2_SPEC {}
        ///`write(|w| ..)` method takes [`oaddr2::W`](W) writer structure
        impl crate::Writable for OADDR2_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets OADDR2 to value 0
        impl crate::Resettable for OADDR2_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///DATAR (rw) register accessor: Data register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`datar::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`datar::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@datar`]
    ///module
    pub type DATAR = crate::Reg<datar::DATAR_SPEC>;
    ///Data register
    pub mod datar {
        ///Register `DATAR` reader
        pub type R = crate::R<DATAR_SPEC>;
        ///Register `DATAR` writer
        pub type W = crate::W<DATAR_SPEC>;
        ///Field `DR` reader - 8-bit data register
        pub type DR_R = crate::FieldReader;
        ///Field `DR` writer - 8-bit data register
        pub type DR_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            ///Bits 0:7 - 8-bit data register
            #[inline(always)]
            pub fn dr(&self) -> DR_R {
                DR_R::new((self.bits & 0xff) as u8)
            }
        }
        impl W {
            ///Bits 0:7 - 8-bit data register
            #[inline(always)]
            #[must_use]
            pub fn dr(&mut self) -> DR_W<DATAR_SPEC> {
                DR_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Data register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`datar::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`datar::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct DATAR_SPEC;
        impl crate::RegisterSpec for DATAR_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`datar::R`](R) reader structure
        impl crate::Readable for DATAR_SPEC {}
        ///`write(|w| ..)` method takes [`datar::W`](W) writer structure
        impl crate::Writable for DATAR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets DATAR to value 0
        impl crate::Resettable for DATAR_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///STAR1 (rw) register accessor: Status register 1
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`star1::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`star1::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@star1`]
    ///module
    pub type STAR1 = crate::Reg<star1::STAR1_SPEC>;
    ///Status register 1
    pub mod star1 {
        ///Register `STAR1` reader
        pub type R = crate::R<STAR1_SPEC>;
        ///Register `STAR1` writer
        pub type W = crate::W<STAR1_SPEC>;
        ///Field `SB` reader - Start bit (Master mode)
        pub type SB_R = crate::BitReader;
        ///Field `ADDR` reader - Address sent (master mode)/matched (slave mode)
        pub type ADDR_R = crate::BitReader;
        ///Field `BTF` reader - Byte transfer finished
        pub type BTF_R = crate::BitReader;
        ///Field `ADD10` reader - 10-bit header sent (Master mode)
        pub type ADD10_R = crate::BitReader;
        ///Field `STOPF` reader - Stop detection (slave mode)
        pub type STOPF_R = crate::BitReader;
        ///Field `RxNE` reader - Data register not empty (receivers)
        pub type RX_NE_R = crate::BitReader;
        ///Field `TxE` reader - Data register empty (transmitters)
        pub type TX_E_R = crate::BitReader;
        ///Field `BERR` reader - Bus error
        pub type BERR_R = crate::BitReader;
        ///Field `BERR` writer - Bus error
        pub type BERR_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `ARLO` reader - Arbitration lost (master mode)
        pub type ARLO_R = crate::BitReader;
        ///Field `ARLO` writer - Arbitration lost (master mode)
        pub type ARLO_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `AF` reader - Acknowledge failure
        pub type AF_R = crate::BitReader;
        ///Field `AF` writer - Acknowledge failure
        pub type AF_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `OVR` reader - Overrun/Underrun
        pub type OVR_R = crate::BitReader;
        ///Field `OVR` writer - Overrun/Underrun
        pub type OVR_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PECERR` reader - PEC Error in reception
        pub type PECERR_R = crate::BitReader;
        ///Field `PECERR` writer - PEC Error in reception
        pub type PECERR_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TIMEOUT` reader - Timeout or Tlow error
        pub type TIMEOUT_R = crate::BitReader;
        ///Field `TIMEOUT` writer - Timeout or Tlow error
        pub type TIMEOUT_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `SMBALERT` reader - SMBus alert
        pub type SMBALERT_R = crate::BitReader;
        ///Field `SMBALERT` writer - SMBus alert
        pub type SMBALERT_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - Start bit (Master mode)
            #[inline(always)]
            pub fn sb(&self) -> SB_R {
                SB_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Address sent (master mode)/matched (slave mode)
            #[inline(always)]
            pub fn addr(&self) -> ADDR_R {
                ADDR_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - Byte transfer finished
            #[inline(always)]
            pub fn btf(&self) -> BTF_R {
                BTF_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - 10-bit header sent (Master mode)
            #[inline(always)]
            pub fn add10(&self) -> ADD10_R {
                ADD10_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - Stop detection (slave mode)
            #[inline(always)]
            pub fn stopf(&self) -> STOPF_R {
                STOPF_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 6 - Data register not empty (receivers)
            #[inline(always)]
            pub fn rx_ne(&self) -> RX_NE_R {
                RX_NE_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - Data register empty (transmitters)
            #[inline(always)]
            pub fn tx_e(&self) -> TX_E_R {
                TX_E_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bit 8 - Bus error
            #[inline(always)]
            pub fn berr(&self) -> BERR_R {
                BERR_R::new(((self.bits >> 8) & 1) != 0)
            }
            ///Bit 9 - Arbitration lost (master mode)
            #[inline(always)]
            pub fn arlo(&self) -> ARLO_R {
                ARLO_R::new(((self.bits >> 9) & 1) != 0)
            }
            ///Bit 10 - Acknowledge failure
            #[inline(always)]
            pub fn af(&self) -> AF_R {
                AF_R::new(((self.bits >> 10) & 1) != 0)
            }
            ///Bit 11 - Overrun/Underrun
            #[inline(always)]
            pub fn ovr(&self) -> OVR_R {
                OVR_R::new(((self.bits >> 11) & 1) != 0)
            }
            ///Bit 12 - PEC Error in reception
            #[inline(always)]
            pub fn pecerr(&self) -> PECERR_R {
                PECERR_R::new(((self.bits >> 12) & 1) != 0)
            }
            ///Bit 14 - Timeout or Tlow error
            #[inline(always)]
            pub fn timeout(&self) -> TIMEOUT_R {
                TIMEOUT_R::new(((self.bits >> 14) & 1) != 0)
            }
            ///Bit 15 - SMBus alert
            #[inline(always)]
            pub fn smbalert(&self) -> SMBALERT_R {
                SMBALERT_R::new(((self.bits >> 15) & 1) != 0)
            }
        }
        impl W {
            ///Bit 8 - Bus error
            #[inline(always)]
            #[must_use]
            pub fn berr(&mut self) -> BERR_W<STAR1_SPEC> {
                BERR_W::new(self, 8)
            }
            ///Bit 9 - Arbitration lost (master mode)
            #[inline(always)]
            #[must_use]
            pub fn arlo(&mut self) -> ARLO_W<STAR1_SPEC> {
                ARLO_W::new(self, 9)
            }
            ///Bit 10 - Acknowledge failure
            #[inline(always)]
            #[must_use]
            pub fn af(&mut self) -> AF_W<STAR1_SPEC> {
                AF_W::new(self, 10)
            }
            ///Bit 11 - Overrun/Underrun
            #[inline(always)]
            #[must_use]
            pub fn ovr(&mut self) -> OVR_W<STAR1_SPEC> {
                OVR_W::new(self, 11)
            }
            ///Bit 12 - PEC Error in reception
            #[inline(always)]
            #[must_use]
            pub fn pecerr(&mut self) -> PECERR_W<STAR1_SPEC> {
                PECERR_W::new(self, 12)
            }
            ///Bit 14 - Timeout or Tlow error
            #[inline(always)]
            #[must_use]
            pub fn timeout(&mut self) -> TIMEOUT_W<STAR1_SPEC> {
                TIMEOUT_W::new(self, 14)
            }
            ///Bit 15 - SMBus alert
            #[inline(always)]
            #[must_use]
            pub fn smbalert(&mut self) -> SMBALERT_W<STAR1_SPEC> {
                SMBALERT_W::new(self, 15)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Status register 1
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`star1::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`star1::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct STAR1_SPEC;
        impl crate::RegisterSpec for STAR1_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`star1::R`](R) reader structure
        impl crate::Readable for STAR1_SPEC {}
        ///`write(|w| ..)` method takes [`star1::W`](W) writer structure
        impl crate::Writable for STAR1_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets STAR1 to value 0
        impl crate::Resettable for STAR1_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///STAR2 (r) register accessor: Status register 2
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`star2::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@star2`]
    ///module
    pub type STAR2 = crate::Reg<star2::STAR2_SPEC>;
    ///Status register 2
    pub mod star2 {
        ///Register `STAR2` reader
        pub type R = crate::R<STAR2_SPEC>;
        ///Field `MSL` reader - Master/slave
        pub type MSL_R = crate::BitReader;
        ///Field `BUSY` reader - Bus busy
        pub type BUSY_R = crate::BitReader;
        ///Field `TRA` reader - Transmitter/receiver
        pub type TRA_R = crate::BitReader;
        ///Field `GENCALL` reader - General call address (Slave mode)
        pub type GENCALL_R = crate::BitReader;
        ///Field `SMBDEFAULT` reader - SMBus device default address (Slave mode)
        pub type SMBDEFAULT_R = crate::BitReader;
        ///Field `SMBHOST` reader - SMBus host header (Slave mode)
        pub type SMBHOST_R = crate::BitReader;
        ///Field `DUALF` reader - Dual flag (Slave mode)
        pub type DUALF_R = crate::BitReader;
        ///Field `PEC` reader - acket error checking register
        pub type PEC_R = crate::FieldReader;
        impl R {
            ///Bit 0 - Master/slave
            #[inline(always)]
            pub fn msl(&self) -> MSL_R {
                MSL_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Bus busy
            #[inline(always)]
            pub fn busy(&self) -> BUSY_R {
                BUSY_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - Transmitter/receiver
            #[inline(always)]
            pub fn tra(&self) -> TRA_R {
                TRA_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 4 - General call address (Slave mode)
            #[inline(always)]
            pub fn gencall(&self) -> GENCALL_R {
                GENCALL_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - SMBus device default address (Slave mode)
            #[inline(always)]
            pub fn smbdefault(&self) -> SMBDEFAULT_R {
                SMBDEFAULT_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - SMBus host header (Slave mode)
            #[inline(always)]
            pub fn smbhost(&self) -> SMBHOST_R {
                SMBHOST_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - Dual flag (Slave mode)
            #[inline(always)]
            pub fn dualf(&self) -> DUALF_R {
                DUALF_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bits 8:15 - acket error checking register
            #[inline(always)]
            pub fn pec(&self) -> PEC_R {
                PEC_R::new(((self.bits >> 8) & 0xff) as u8)
            }
        }
        ///Status register 2
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`star2::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct STAR2_SPEC;
        impl crate::RegisterSpec for STAR2_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`star2::R`](R) reader structure
        impl crate::Readable for STAR2_SPEC {}
        ///`reset()` method sets STAR2 to value 0
        impl crate::Resettable for STAR2_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///CKCFGR (rw) register accessor: Clock control register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`ckcfgr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ckcfgr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@ckcfgr`]
    ///module
    pub type CKCFGR = crate::Reg<ckcfgr::CKCFGR_SPEC>;
    ///Clock control register
    pub mod ckcfgr {
        ///Register `CKCFGR` reader
        pub type R = crate::R<CKCFGR_SPEC>;
        ///Register `CKCFGR` writer
        pub type W = crate::W<CKCFGR_SPEC>;
        ///Field `CCR` reader - Clock control register in Fast/Standard mode (Master mode)
        pub type CCR_R = crate::FieldReader<u16>;
        ///Field `CCR` writer - Clock control register in Fast/Standard mode (Master mode)
        pub type CCR_W<'a, REG> = crate::FieldWriter<'a, REG, 12, u16>;
        ///Field `DUTY` reader - Fast mode duty cycle
        pub type DUTY_R = crate::BitReader;
        ///Field `DUTY` writer - Fast mode duty cycle
        pub type DUTY_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `F_S` reader - I2C master mode selection
        pub type F_S_R = crate::BitReader;
        ///Field `F_S` writer - I2C master mode selection
        pub type F_S_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bits 0:11 - Clock control register in Fast/Standard mode (Master mode)
            #[inline(always)]
            pub fn ccr(&self) -> CCR_R {
                CCR_R::new(self.bits & 0x0fff)
            }
            ///Bit 14 - Fast mode duty cycle
            #[inline(always)]
            pub fn duty(&self) -> DUTY_R {
                DUTY_R::new(((self.bits >> 14) & 1) != 0)
            }
            ///Bit 15 - I2C master mode selection
            #[inline(always)]
            pub fn f_s(&self) -> F_S_R {
                F_S_R::new(((self.bits >> 15) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:11 - Clock control register in Fast/Standard mode (Master mode)
            #[inline(always)]
            #[must_use]
            pub fn ccr(&mut self) -> CCR_W<CKCFGR_SPEC> {
                CCR_W::new(self, 0)
            }
            ///Bit 14 - Fast mode duty cycle
            #[inline(always)]
            #[must_use]
            pub fn duty(&mut self) -> DUTY_W<CKCFGR_SPEC> {
                DUTY_W::new(self, 14)
            }
            ///Bit 15 - I2C master mode selection
            #[inline(always)]
            #[must_use]
            pub fn f_s(&mut self) -> F_S_W<CKCFGR_SPEC> {
                F_S_W::new(self, 15)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Clock control register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`ckcfgr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ckcfgr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct CKCFGR_SPEC;
        impl crate::RegisterSpec for CKCFGR_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`ckcfgr::R`](R) reader structure
        impl crate::Readable for CKCFGR_SPEC {}
        ///`write(|w| ..)` method takes [`ckcfgr::W`](W) writer structure
        impl crate::Writable for CKCFGR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets CKCFGR to value 0
        impl crate::Resettable for CKCFGR_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///RTR (rw) register accessor: Raise time register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`rtr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`rtr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@rtr`]
    ///module
    pub type RTR = crate::Reg<rtr::RTR_SPEC>;
    ///Raise time register
    pub mod rtr {
        ///Register `RTR` reader
        pub type R = crate::R<RTR_SPEC>;
        ///Register `RTR` writer
        pub type W = crate::W<RTR_SPEC>;
        ///Field `TRISE` reader - Maximum rise time in Fast/Standard mode (Master mode)
        pub type TRISE_R = crate::FieldReader;
        ///Field `TRISE` writer - Maximum rise time in Fast/Standard mode (Master mode)
        pub type TRISE_W<'a, REG> = crate::FieldWriter<'a, REG, 6>;
        impl R {
            ///Bits 0:5 - Maximum rise time in Fast/Standard mode (Master mode)
            #[inline(always)]
            pub fn trise(&self) -> TRISE_R {
                TRISE_R::new((self.bits & 0x3f) as u8)
            }
        }
        impl W {
            ///Bits 0:5 - Maximum rise time in Fast/Standard mode (Master mode)
            #[inline(always)]
            #[must_use]
            pub fn trise(&mut self) -> TRISE_W<RTR_SPEC> {
                TRISE_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Raise time register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`rtr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`rtr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct RTR_SPEC;
        impl crate::RegisterSpec for RTR_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`rtr::R`](R) reader structure
        impl crate::Readable for RTR_SPEC {}
        ///`write(|w| ..)` method takes [`rtr::W`](W) writer structure
        impl crate::Writable for RTR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets RTR to value 0x02
        impl crate::Resettable for RTR_SPEC {
            const RESET_VALUE: u16 = 0x02;
        }
    }
}
///Inter integrated circuit
pub struct I2C2 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for I2C2 {}
impl I2C2 {
    ///Pointer to the register block
    pub const PTR: *const i2c1::RegisterBlock = 0x4000_5800 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const i2c1::RegisterBlock {
        Self::PTR
    }
    /// Steal an instance of this peripheral
    ///
    /// # Safety
    ///
    /// Ensure that the new instance of the peripheral cannot be used in a way
    /// that may race with any existing instances, for example by only
    /// accessing read-only or write-only registers, or by consuming the
    /// original peripheral and using critical sections to coordinate
    /// access between multiple new instances.
    ///
    /// Additionally, other software such as HALs may rely on only one
    /// peripheral instance existing to ensure memory safety; ensure
    /// no stolen instances are passed to such software.
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for I2C2 {
    type Target = i2c1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for I2C2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("I2C2").finish()
    }
}
///Inter integrated circuit
pub use self::i2c1 as i2c2;
///Serial peripheral interface
pub struct SPI1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for SPI1 {}
impl SPI1 {
    ///Pointer to the register block
    pub const PTR: *const spi1::RegisterBlock = 0x4001_3000 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const spi1::RegisterBlock {
        Self::PTR
    }
    /// Steal an instance of this peripheral
    ///
    /// # Safety
    ///
    /// Ensure that the new instance of the peripheral cannot be used in a way
    /// that may race with any existing instances, for example by only
    /// accessing read-only or write-only registers, or by consuming the
    /// original peripheral and using critical sections to coordinate
    /// access between multiple new instances.
    ///
    /// Additionally, other software such as HALs may rely on only one
    /// peripheral instance existing to ensure memory safety; ensure
    /// no stolen instances are passed to such software.
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for SPI1 {
    type Target = spi1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for SPI1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("SPI1").finish()
    }
}
///Serial peripheral interface
pub mod spi1 {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        ctlr1: CTLR1,
        _reserved1: [u8; 0x02],
        ctlr2: CTLR2,
        _reserved2: [u8; 0x02],
        statr: STATR,
        _reserved3: [u8; 0x02],
        datar: DATAR,
        _reserved4: [u8; 0x02],
        crcr: CRCR,
        _reserved5: [u8; 0x02],
        rcrcr: RCRCR,
        _reserved6: [u8; 0x02],
        tcrcr: TCRCR,
        _reserved7: [u8; 0x0a],
        hscr: HSCR,
    }
    impl RegisterBlock {
        ///0x00 - control register 1
        #[inline(always)]
        pub const fn ctlr1(&self) -> &CTLR1 {
            &self.ctlr1
        }
        ///0x04 - control register 2
        #[inline(always)]
        pub const fn ctlr2(&self) -> &CTLR2 {
            &self.ctlr2
        }
        ///0x08 - status register
        #[inline(always)]
        pub const fn statr(&self) -> &STATR {
            &self.statr
        }
        ///0x0c - data register
        #[inline(always)]
        pub const fn datar(&self) -> &DATAR {
            &self.datar
        }
        ///0x10 - CRCR polynomial register
        #[inline(always)]
        pub const fn crcr(&self) -> &CRCR {
            &self.crcr
        }
        ///0x14 - RX CRC register
        #[inline(always)]
        pub const fn rcrcr(&self) -> &RCRCR {
            &self.rcrcr
        }
        ///0x18 - send CRC register
        #[inline(always)]
        pub const fn tcrcr(&self) -> &TCRCR {
            &self.tcrcr
        }
        ///0x24 - high speed control register
        #[inline(always)]
        pub const fn hscr(&self) -> &HSCR {
            &self.hscr
        }
    }
    ///CTLR1 (rw) register accessor: control register 1
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`ctlr1::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ctlr1::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@ctlr1`]
    ///module
    pub type CTLR1 = crate::Reg<ctlr1::CTLR1_SPEC>;
    ///control register 1
    pub mod ctlr1 {
        ///Register `CTLR1` reader
        pub type R = crate::R<CTLR1_SPEC>;
        ///Register `CTLR1` writer
        pub type W = crate::W<CTLR1_SPEC>;
        ///Field `CPHA` reader - Clock phase
        pub type CPHA_R = crate::BitReader;
        ///Field `CPHA` writer - Clock phase
        pub type CPHA_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CPOL` reader - Clock polarity
        pub type CPOL_R = crate::BitReader;
        ///Field `CPOL` writer - Clock polarity
        pub type CPOL_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `MSTR` reader - Master selection
        pub type MSTR_R = crate::BitReader;
        ///Field `MSTR` writer - Master selection
        pub type MSTR_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `BR` reader - Baud rate control
        pub type BR_R = crate::FieldReader;
        ///Field `BR` writer - Baud rate control
        pub type BR_W<'a, REG> = crate::FieldWriter<'a, REG, 3>;
        ///Field `SPE` reader - SPI enable
        pub type SPE_R = crate::BitReader;
        ///Field `SPE` writer - SPI enable
        pub type SPE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `LSBFIRST` reader - Frame format
        pub type LSBFIRST_R = crate::BitReader;
        ///Field `LSBFIRST` writer - Frame format
        pub type LSBFIRST_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `SSI` reader - Internal slave select
        pub type SSI_R = crate::BitReader;
        ///Field `SSI` writer - Internal slave select
        pub type SSI_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `SSM` reader - Software slave management
        pub type SSM_R = crate::BitReader;
        ///Field `SSM` writer - Software slave management
        pub type SSM_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `RXONLY` reader - Receive only
        pub type RXONLY_R = crate::BitReader;
        ///Field `RXONLY` writer - Receive only
        pub type RXONLY_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `DFF` reader - Data frame format
        pub type DFF_R = crate::BitReader;
        ///Field `DFF` writer - Data frame format
        pub type DFF_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CRCNEXT` reader - CRC transfer next
        pub type CRCNEXT_R = crate::BitReader;
        ///Field `CRCNEXT` writer - CRC transfer next
        pub type CRCNEXT_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CRCEN` reader - Hardware CRC calculation enable
        pub type CRCEN_R = crate::BitReader;
        ///Field `CRCEN` writer - Hardware CRC calculation enable
        pub type CRCEN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `BIDIOE` reader - Output enable in bidirectional mode
        pub type BIDIOE_R = crate::BitReader;
        ///Field `BIDIOE` writer - Output enable in bidirectional mode
        pub type BIDIOE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `BIDIMODE` reader - Bidirectional data mode enable
        pub type BIDIMODE_R = crate::BitReader;
        ///Field `BIDIMODE` writer - Bidirectional data mode enable
        pub type BIDIMODE_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - Clock phase
            #[inline(always)]
            pub fn cpha(&self) -> CPHA_R {
                CPHA_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Clock polarity
            #[inline(always)]
            pub fn cpol(&self) -> CPOL_R {
                CPOL_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - Master selection
            #[inline(always)]
            pub fn mstr(&self) -> MSTR_R {
                MSTR_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bits 3:5 - Baud rate control
            #[inline(always)]
            pub fn br(&self) -> BR_R {
                BR_R::new(((self.bits >> 3) & 7) as u8)
            }
            ///Bit 6 - SPI enable
            #[inline(always)]
            pub fn spe(&self) -> SPE_R {
                SPE_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - Frame format
            #[inline(always)]
            pub fn lsbfirst(&self) -> LSBFIRST_R {
                LSBFIRST_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bit 8 - Internal slave select
            #[inline(always)]
            pub fn ssi(&self) -> SSI_R {
                SSI_R::new(((self.bits >> 8) & 1) != 0)
            }
            ///Bit 9 - Software slave management
            #[inline(always)]
            pub fn ssm(&self) -> SSM_R {
                SSM_R::new(((self.bits >> 9) & 1) != 0)
            }
            ///Bit 10 - Receive only
            #[inline(always)]
            pub fn rxonly(&self) -> RXONLY_R {
                RXONLY_R::new(((self.bits >> 10) & 1) != 0)
            }
            ///Bit 11 - Data frame format
            #[inline(always)]
            pub fn dff(&self) -> DFF_R {
                DFF_R::new(((self.bits >> 11) & 1) != 0)
            }
            ///Bit 12 - CRC transfer next
            #[inline(always)]
            pub fn crcnext(&self) -> CRCNEXT_R {
                CRCNEXT_R::new(((self.bits >> 12) & 1) != 0)
            }
            ///Bit 13 - Hardware CRC calculation enable
            #[inline(always)]
            pub fn crcen(&self) -> CRCEN_R {
                CRCEN_R::new(((self.bits >> 13) & 1) != 0)
            }
            ///Bit 14 - Output enable in bidirectional mode
            #[inline(always)]
            pub fn bidioe(&self) -> BIDIOE_R {
                BIDIOE_R::new(((self.bits >> 14) & 1) != 0)
            }
            ///Bit 15 - Bidirectional data mode enable
            #[inline(always)]
            pub fn bidimode(&self) -> BIDIMODE_R {
                BIDIMODE_R::new(((self.bits >> 15) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - Clock phase
            #[inline(always)]
            #[must_use]
            pub fn cpha(&mut self) -> CPHA_W<CTLR1_SPEC> {
                CPHA_W::new(self, 0)
            }
            ///Bit 1 - Clock polarity
            #[inline(always)]
            #[must_use]
            pub fn cpol(&mut self) -> CPOL_W<CTLR1_SPEC> {
                CPOL_W::new(self, 1)
            }
            ///Bit 2 - Master selection
            #[inline(always)]
            #[must_use]
            pub fn mstr(&mut self) -> MSTR_W<CTLR1_SPEC> {
                MSTR_W::new(self, 2)
            }
            ///Bits 3:5 - Baud rate control
            #[inline(always)]
            #[must_use]
            pub fn br(&mut self) -> BR_W<CTLR1_SPEC> {
                BR_W::new(self, 3)
            }
            ///Bit 6 - SPI enable
            #[inline(always)]
            #[must_use]
            pub fn spe(&mut self) -> SPE_W<CTLR1_SPEC> {
                SPE_W::new(self, 6)
            }
            ///Bit 7 - Frame format
            #[inline(always)]
            #[must_use]
            pub fn lsbfirst(&mut self) -> LSBFIRST_W<CTLR1_SPEC> {
                LSBFIRST_W::new(self, 7)
            }
            ///Bit 8 - Internal slave select
            #[inline(always)]
            #[must_use]
            pub fn ssi(&mut self) -> SSI_W<CTLR1_SPEC> {
                SSI_W::new(self, 8)
            }
            ///Bit 9 - Software slave management
            #[inline(always)]
            #[must_use]
            pub fn ssm(&mut self) -> SSM_W<CTLR1_SPEC> {
                SSM_W::new(self, 9)
            }
            ///Bit 10 - Receive only
            #[inline(always)]
            #[must_use]
            pub fn rxonly(&mut self) -> RXONLY_W<CTLR1_SPEC> {
                RXONLY_W::new(self, 10)
            }
            ///Bit 11 - Data frame format
            #[inline(always)]
            #[must_use]
            pub fn dff(&mut self) -> DFF_W<CTLR1_SPEC> {
                DFF_W::new(self, 11)
            }
            ///Bit 12 - CRC transfer next
            #[inline(always)]
            #[must_use]
            pub fn crcnext(&mut self) -> CRCNEXT_W<CTLR1_SPEC> {
                CRCNEXT_W::new(self, 12)
            }
            ///Bit 13 - Hardware CRC calculation enable
            #[inline(always)]
            #[must_use]
            pub fn crcen(&mut self) -> CRCEN_W<CTLR1_SPEC> {
                CRCEN_W::new(self, 13)
            }
            ///Bit 14 - Output enable in bidirectional mode
            #[inline(always)]
            #[must_use]
            pub fn bidioe(&mut self) -> BIDIOE_W<CTLR1_SPEC> {
                BIDIOE_W::new(self, 14)
            }
            ///Bit 15 - Bidirectional data mode enable
            #[inline(always)]
            #[must_use]
            pub fn bidimode(&mut self) -> BIDIMODE_W<CTLR1_SPEC> {
                BIDIMODE_W::new(self, 15)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///control register 1
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`ctlr1::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ctlr1::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct CTLR1_SPEC;
        impl crate::RegisterSpec for CTLR1_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`ctlr1::R`](R) reader structure
        impl crate::Readable for CTLR1_SPEC {}
        ///`write(|w| ..)` method takes [`ctlr1::W`](W) writer structure
        impl crate::Writable for CTLR1_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets CTLR1 to value 0
        impl crate::Resettable for CTLR1_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///CTLR2 (rw) register accessor: control register 2
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`ctlr2::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ctlr2::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@ctlr2`]
    ///module
    pub type CTLR2 = crate::Reg<ctlr2::CTLR2_SPEC>;
    ///control register 2
    pub mod ctlr2 {
        ///Register `CTLR2` reader
        pub type R = crate::R<CTLR2_SPEC>;
        ///Register `CTLR2` writer
        pub type W = crate::W<CTLR2_SPEC>;
        ///Field `RXDMAEN` reader - Rx buffer DMA enable
        pub type RXDMAEN_R = crate::BitReader;
        ///Field `RXDMAEN` writer - Rx buffer DMA enable
        pub type RXDMAEN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TXDMAEN` reader - Tx buffer DMA enable
        pub type TXDMAEN_R = crate::BitReader;
        ///Field `TXDMAEN` writer - Tx buffer DMA enable
        pub type TXDMAEN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `SSOE` reader - SS output enable
        pub type SSOE_R = crate::BitReader;
        ///Field `SSOE` writer - SS output enable
        pub type SSOE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `ERRIE` reader - Error interrupt enable
        pub type ERRIE_R = crate::BitReader;
        ///Field `ERRIE` writer - Error interrupt enable
        pub type ERRIE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `RXNEIE` reader - RX buffer not empty interrupt enable
        pub type RXNEIE_R = crate::BitReader;
        ///Field `RXNEIE` writer - RX buffer not empty interrupt enable
        pub type RXNEIE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TXEIE` reader - Tx buffer empty interrupt enable
        pub type TXEIE_R = crate::BitReader;
        ///Field `TXEIE` writer - Tx buffer empty interrupt enable
        pub type TXEIE_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - Rx buffer DMA enable
            #[inline(always)]
            pub fn rxdmaen(&self) -> RXDMAEN_R {
                RXDMAEN_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Tx buffer DMA enable
            #[inline(always)]
            pub fn txdmaen(&self) -> TXDMAEN_R {
                TXDMAEN_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - SS output enable
            #[inline(always)]
            pub fn ssoe(&self) -> SSOE_R {
                SSOE_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 5 - Error interrupt enable
            #[inline(always)]
            pub fn errie(&self) -> ERRIE_R {
                ERRIE_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - RX buffer not empty interrupt enable
            #[inline(always)]
            pub fn rxneie(&self) -> RXNEIE_R {
                RXNEIE_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - Tx buffer empty interrupt enable
            #[inline(always)]
            pub fn txeie(&self) -> TXEIE_R {
                TXEIE_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - Rx buffer DMA enable
            #[inline(always)]
            #[must_use]
            pub fn rxdmaen(&mut self) -> RXDMAEN_W<CTLR2_SPEC> {
                RXDMAEN_W::new(self, 0)
            }
            ///Bit 1 - Tx buffer DMA enable
            #[inline(always)]
            #[must_use]
            pub fn txdmaen(&mut self) -> TXDMAEN_W<CTLR2_SPEC> {
                TXDMAEN_W::new(self, 1)
            }
            ///Bit 2 - SS output enable
            #[inline(always)]
            #[must_use]
            pub fn ssoe(&mut self) -> SSOE_W<CTLR2_SPEC> {
                SSOE_W::new(self, 2)
            }
            ///Bit 5 - Error interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn errie(&mut self) -> ERRIE_W<CTLR2_SPEC> {
                ERRIE_W::new(self, 5)
            }
            ///Bit 6 - RX buffer not empty interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn rxneie(&mut self) -> RXNEIE_W<CTLR2_SPEC> {
                RXNEIE_W::new(self, 6)
            }
            ///Bit 7 - Tx buffer empty interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn txeie(&mut self) -> TXEIE_W<CTLR2_SPEC> {
                TXEIE_W::new(self, 7)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///control register 2
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`ctlr2::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ctlr2::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct CTLR2_SPEC;
        impl crate::RegisterSpec for CTLR2_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`ctlr2::R`](R) reader structure
        impl crate::Readable for CTLR2_SPEC {}
        ///`write(|w| ..)` method takes [`ctlr2::W`](W) writer structure
        impl crate::Writable for CTLR2_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets CTLR2 to value 0
        impl crate::Resettable for CTLR2_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///STATR (rw) register accessor: status register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`statr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`statr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@statr`]
    ///module
    pub type STATR = crate::Reg<statr::STATR_SPEC>;
    ///status register
    pub mod statr {
        ///Register `STATR` reader
        pub type R = crate::R<STATR_SPEC>;
        ///Register `STATR` writer
        pub type W = crate::W<STATR_SPEC>;
        ///Field `RXNE` reader - Receive buffer not empty
        pub type RXNE_R = crate::BitReader;
        ///Field `TXE` reader - Transmit buffer empty
        pub type TXE_R = crate::BitReader;
        ///Field `CRCERR` reader - CRC error flag
        pub type CRCERR_R = crate::BitReader;
        ///Field `CRCERR` writer - CRC error flag
        pub type CRCERR_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `MODF` reader - Mode fault
        pub type MODF_R = crate::BitReader;
        ///Field `OVR` reader - Overrun flag
        pub type OVR_R = crate::BitReader;
        ///Field `OVR` writer - Overrun flag
        pub type OVR_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `BSY` reader - Busy flag
        pub type BSY_R = crate::BitReader;
        impl R {
            ///Bit 0 - Receive buffer not empty
            #[inline(always)]
            pub fn rxne(&self) -> RXNE_R {
                RXNE_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Transmit buffer empty
            #[inline(always)]
            pub fn txe(&self) -> TXE_R {
                TXE_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 4 - CRC error flag
            #[inline(always)]
            pub fn crcerr(&self) -> CRCERR_R {
                CRCERR_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - Mode fault
            #[inline(always)]
            pub fn modf(&self) -> MODF_R {
                MODF_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - Overrun flag
            #[inline(always)]
            pub fn ovr(&self) -> OVR_R {
                OVR_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - Busy flag
            #[inline(always)]
            pub fn bsy(&self) -> BSY_R {
                BSY_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 4 - CRC error flag
            #[inline(always)]
            #[must_use]
            pub fn crcerr(&mut self) -> CRCERR_W<STATR_SPEC> {
                CRCERR_W::new(self, 4)
            }
            ///Bit 6 - Overrun flag
            #[inline(always)]
            #[must_use]
            pub fn ovr(&mut self) -> OVR_W<STATR_SPEC> {
                OVR_W::new(self, 6)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///status register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`statr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`statr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct STATR_SPEC;
        impl crate::RegisterSpec for STATR_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`statr::R`](R) reader structure
        impl crate::Readable for STATR_SPEC {}
        ///`write(|w| ..)` method takes [`statr::W`](W) writer structure
        impl crate::Writable for STATR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets STATR to value 0x02
        impl crate::Resettable for STATR_SPEC {
            const RESET_VALUE: u16 = 0x02;
        }
    }
    ///DATAR (rw) register accessor: data register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`datar::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`datar::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@datar`]
    ///module
    pub type DATAR = crate::Reg<datar::DATAR_SPEC>;
    ///data register
    pub mod datar {
        ///Register `DATAR` reader
        pub type R = crate::R<DATAR_SPEC>;
        ///Register `DATAR` writer
        pub type W = crate::W<DATAR_SPEC>;
        ///Field `DR` reader - Data register
        pub type DR_R = crate::FieldReader<u16>;
        ///Field `DR` writer - Data register
        pub type DR_W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            ///Bits 0:15 - Data register
            #[inline(always)]
            pub fn dr(&self) -> DR_R {
                DR_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - Data register
            #[inline(always)]
            #[must_use]
            pub fn dr(&mut self) -> DR_W<DATAR_SPEC> {
                DR_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///data register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`datar::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`datar::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct DATAR_SPEC;
        impl crate::RegisterSpec for DATAR_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`datar::R`](R) reader structure
        impl crate::Readable for DATAR_SPEC {}
        ///`write(|w| ..)` method takes [`datar::W`](W) writer structure
        impl crate::Writable for DATAR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets DATAR to value 0
        impl crate::Resettable for DATAR_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///CRCR (rw) register accessor: CRCR polynomial register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`crcr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`crcr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@crcr`]
    ///module
    pub type CRCR = crate::Reg<crcr::CRCR_SPEC>;
    ///CRCR polynomial register
    pub mod crcr {
        ///Register `CRCR` reader
        pub type R = crate::R<CRCR_SPEC>;
        ///Register `CRCR` writer
        pub type W = crate::W<CRCR_SPEC>;
        ///Field `CRCPOLY` reader - CRC polynomial register
        pub type CRCPOLY_R = crate::FieldReader<u16>;
        ///Field `CRCPOLY` writer - CRC polynomial register
        pub type CRCPOLY_W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            ///Bits 0:15 - CRC polynomial register
            #[inline(always)]
            pub fn crcpoly(&self) -> CRCPOLY_R {
                CRCPOLY_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - CRC polynomial register
            #[inline(always)]
            #[must_use]
            pub fn crcpoly(&mut self) -> CRCPOLY_W<CRCR_SPEC> {
                CRCPOLY_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///CRCR polynomial register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`crcr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`crcr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct CRCR_SPEC;
        impl crate::RegisterSpec for CRCR_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`crcr::R`](R) reader structure
        impl crate::Readable for CRCR_SPEC {}
        ///`write(|w| ..)` method takes [`crcr::W`](W) writer structure
        impl crate::Writable for CRCR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets CRCR to value 0x07
        impl crate::Resettable for CRCR_SPEC {
            const RESET_VALUE: u16 = 0x07;
        }
    }
    ///RCRCR (r) register accessor: RX CRC register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`rcrcr::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@rcrcr`]
    ///module
    pub type RCRCR = crate::Reg<rcrcr::RCRCR_SPEC>;
    ///RX CRC register
    pub mod rcrcr {
        ///Register `RCRCR` reader
        pub type R = crate::R<RCRCR_SPEC>;
        ///Field `RXCRC` reader - Rx CRC register
        pub type RXCRC_R = crate::FieldReader<u16>;
        impl R {
            ///Bits 0:15 - Rx CRC register
            #[inline(always)]
            pub fn rxcrc(&self) -> RXCRC_R {
                RXCRC_R::new(self.bits)
            }
        }
        ///RX CRC register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`rcrcr::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct RCRCR_SPEC;
        impl crate::RegisterSpec for RCRCR_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`rcrcr::R`](R) reader structure
        impl crate::Readable for RCRCR_SPEC {}
        ///`reset()` method sets RCRCR to value 0
        impl crate::Resettable for RCRCR_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///TCRCR (r) register accessor: send CRC register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`tcrcr::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@tcrcr`]
    ///module
    pub type TCRCR = crate::Reg<tcrcr::TCRCR_SPEC>;
    ///send CRC register
    pub mod tcrcr {
        ///Register `TCRCR` reader
        pub type R = crate::R<TCRCR_SPEC>;
        ///Field `TXCRC` reader - Tx CRC register
        pub type TXCRC_R = crate::FieldReader<u16>;
        impl R {
            ///Bits 0:15 - Tx CRC register
            #[inline(always)]
            pub fn txcrc(&self) -> TXCRC_R {
                TXCRC_R::new(self.bits)
            }
        }
        ///send CRC register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`tcrcr::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct TCRCR_SPEC;
        impl crate::RegisterSpec for TCRCR_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`tcrcr::R`](R) reader structure
        impl crate::Readable for TCRCR_SPEC {}
        ///`reset()` method sets TCRCR to value 0
        impl crate::Resettable for TCRCR_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///HSCR (rw) register accessor: high speed control register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`hscr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`hscr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@hscr`]
    ///module
    pub type HSCR = crate::Reg<hscr::HSCR_SPEC>;
    ///high speed control register
    pub mod hscr {
        ///Register `HSCR` reader
        pub type R = crate::R<HSCR_SPEC>;
        ///Register `HSCR` writer
        pub type W = crate::W<HSCR_SPEC>;
        ///Field `HSRXEN` reader - High speed mode read enable
        pub type HSRXEN_R = crate::BitReader;
        ///Field `HSRXEN` writer - High speed mode read enable
        pub type HSRXEN_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - High speed mode read enable
            #[inline(always)]
            pub fn hsrxen(&self) -> HSRXEN_R {
                HSRXEN_R::new((self.bits & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - High speed mode read enable
            #[inline(always)]
            #[must_use]
            pub fn hsrxen(&mut self) -> HSRXEN_W<HSCR_SPEC> {
                HSRXEN_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///high speed control register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`hscr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`hscr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct HSCR_SPEC;
        impl crate::RegisterSpec for HSCR_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`hscr::R`](R) reader structure
        impl crate::Readable for HSCR_SPEC {}
        ///`write(|w| ..)` method takes [`hscr::W`](W) writer structure
        impl crate::Writable for HSCR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets HSCR to value 0
        impl crate::Resettable for HSCR_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
}
///Serial peripheral interface
pub struct SPI2 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for SPI2 {}
impl SPI2 {
    ///Pointer to the register block
    pub const PTR: *const spi1::RegisterBlock = 0x4000_3800 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const spi1::RegisterBlock {
        Self::PTR
    }
    /// Steal an instance of this peripheral
    ///
    /// # Safety
    ///
    /// Ensure that the new instance of the peripheral cannot be used in a way
    /// that may race with any existing instances, for example by only
    /// accessing read-only or write-only registers, or by consuming the
    /// original peripheral and using critical sections to coordinate
    /// access between multiple new instances.
    ///
    /// Additionally, other software such as HALs may rely on only one
    /// peripheral instance existing to ensure memory safety; ensure
    /// no stolen instances are passed to such software.
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for SPI2 {
    type Target = spi1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for SPI2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("SPI2").finish()
    }
}
///Serial peripheral interface
pub use self::spi1 as spi2;
///Universal synchronous asynchronous receiver transmitter
pub struct USART1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for USART1 {}
impl USART1 {
    ///Pointer to the register block
    pub const PTR: *const usart1::RegisterBlock = 0x4001_3800 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const usart1::RegisterBlock {
        Self::PTR
    }
    /// Steal an instance of this peripheral
    ///
    /// # Safety
    ///
    /// Ensure that the new instance of the peripheral cannot be used in a way
    /// that may race with any existing instances, for example by only
    /// accessing read-only or write-only registers, or by consuming the
    /// original peripheral and using critical sections to coordinate
    /// access between multiple new instances.
    ///
    /// Additionally, other software such as HALs may rely on only one
    /// peripheral instance existing to ensure memory safety; ensure
    /// no stolen instances are passed to such software.
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for USART1 {
    type Target = usart1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for USART1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("USART1").finish()
    }
}
///Universal synchronous asynchronous receiver transmitter
pub mod usart1 {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        statr: STATR,
        datar: DATAR,
        brr: BRR,
        ctlr1: CTLR1,
        ctlr2: CTLR2,
        ctlr3: CTLR3,
        gpr: GPR,
    }
    impl RegisterBlock {
        ///0x00 - Status register
        #[inline(always)]
        pub const fn statr(&self) -> &STATR {
            &self.statr
        }
        ///0x04 - Data register
        #[inline(always)]
        pub const fn datar(&self) -> &DATAR {
            &self.datar
        }
        ///0x08 - Baud rate register
        #[inline(always)]
        pub const fn brr(&self) -> &BRR {
            &self.brr
        }
        ///0x0c - Control register 1
        #[inline(always)]
        pub const fn ctlr1(&self) -> &CTLR1 {
            &self.ctlr1
        }
        ///0x10 - Control register 2
        #[inline(always)]
        pub const fn ctlr2(&self) -> &CTLR2 {
            &self.ctlr2
        }
        ///0x14 - Control register 3
        #[inline(always)]
        pub const fn ctlr3(&self) -> &CTLR3 {
            &self.ctlr3
        }
        ///0x18 - Guard time and prescaler register
        #[inline(always)]
        pub const fn gpr(&self) -> &GPR {
            &self.gpr
        }
    }
    ///STATR (rw) register accessor: Status register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`statr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`statr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@statr`]
    ///module
    pub type STATR = crate::Reg<statr::STATR_SPEC>;
    ///Status register
    pub mod statr {
        ///Register `STATR` reader
        pub type R = crate::R<STATR_SPEC>;
        ///Register `STATR` writer
        pub type W = crate::W<STATR_SPEC>;
        ///Field `PE` reader - Parity error
        pub type PE_R = crate::BitReader;
        ///Field `FE` reader - Framing error
        pub type FE_R = crate::BitReader;
        ///Field `NE` reader - Noise error flag
        pub type NE_R = crate::BitReader;
        ///Field `ORE` reader - Overrun error
        pub type ORE_R = crate::BitReader;
        ///Field `IDLE` reader - IDLE line detected
        pub type IDLE_R = crate::BitReader;
        ///Field `RXNE` reader - Read data register not empty
        pub type RXNE_R = crate::BitReader;
        ///Field `RXNE` writer - Read data register not empty
        pub type RXNE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TC` reader - Transmission complete
        pub type TC_R = crate::BitReader;
        ///Field `TC` writer - Transmission complete
        pub type TC_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TXE` reader - Transmit data register empty
        pub type TXE_R = crate::BitReader;
        ///Field `LBD` reader - LIN break detection flag
        pub type LBD_R = crate::BitReader;
        ///Field `LBD` writer - LIN break detection flag
        pub type LBD_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CTS` reader - CTS flag
        pub type CTS_R = crate::BitReader;
        ///Field `CTS` writer - CTS flag
        pub type CTS_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `RX_BUSY` reader - Receive data busy status
        pub type RX_BUSY_R = crate::BitReader;
        impl R {
            ///Bit 0 - Parity error
            #[inline(always)]
            pub fn pe(&self) -> PE_R {
                PE_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Framing error
            #[inline(always)]
            pub fn fe(&self) -> FE_R {
                FE_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - Noise error flag
            #[inline(always)]
            pub fn ne(&self) -> NE_R {
                NE_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - Overrun error
            #[inline(always)]
            pub fn ore(&self) -> ORE_R {
                ORE_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - IDLE line detected
            #[inline(always)]
            pub fn idle(&self) -> IDLE_R {
                IDLE_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - Read data register not empty
            #[inline(always)]
            pub fn rxne(&self) -> RXNE_R {
                RXNE_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - Transmission complete
            #[inline(always)]
            pub fn tc(&self) -> TC_R {
                TC_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - Transmit data register empty
            #[inline(always)]
            pub fn txe(&self) -> TXE_R {
                TXE_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bit 8 - LIN break detection flag
            #[inline(always)]
            pub fn lbd(&self) -> LBD_R {
                LBD_R::new(((self.bits >> 8) & 1) != 0)
            }
            ///Bit 9 - CTS flag
            #[inline(always)]
            pub fn cts(&self) -> CTS_R {
                CTS_R::new(((self.bits >> 9) & 1) != 0)
            }
            ///Bit 10 - Receive data busy status
            #[inline(always)]
            pub fn rx_busy(&self) -> RX_BUSY_R {
                RX_BUSY_R::new(((self.bits >> 10) & 1) != 0)
            }
        }
        impl W {
            ///Bit 5 - Read data register not empty
            #[inline(always)]
            #[must_use]
            pub fn rxne(&mut self) -> RXNE_W<STATR_SPEC> {
                RXNE_W::new(self, 5)
            }
            ///Bit 6 - Transmission complete
            #[inline(always)]
            #[must_use]
            pub fn tc(&mut self) -> TC_W<STATR_SPEC> {
                TC_W::new(self, 6)
            }
            ///Bit 8 - LIN break detection flag
            #[inline(always)]
            #[must_use]
            pub fn lbd(&mut self) -> LBD_W<STATR_SPEC> {
                LBD_W::new(self, 8)
            }
            ///Bit 9 - CTS flag
            #[inline(always)]
            #[must_use]
            pub fn cts(&mut self) -> CTS_W<STATR_SPEC> {
                CTS_W::new(self, 9)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Status register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`statr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`statr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct STATR_SPEC;
        impl crate::RegisterSpec for STATR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`statr::R`](R) reader structure
        impl crate::Readable for STATR_SPEC {}
        ///`write(|w| ..)` method takes [`statr::W`](W) writer structure
        impl crate::Writable for STATR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets STATR to value 0xc0
        impl crate::Resettable for STATR_SPEC {
            const RESET_VALUE: u32 = 0xc0;
        }
    }
    ///DATAR (rw) register accessor: Data register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`datar::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`datar::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@datar`]
    ///module
    pub type DATAR = crate::Reg<datar::DATAR_SPEC>;
    ///Data register
    pub mod datar {
        ///Register `DATAR` reader
        pub type R = crate::R<DATAR_SPEC>;
        ///Register `DATAR` writer
        pub type W = crate::W<DATAR_SPEC>;
        ///Field `DR` reader - Data value
        pub type DR_R = crate::FieldReader<u16>;
        ///Field `DR` writer - Data value
        pub type DR_W<'a, REG> = crate::FieldWriter<'a, REG, 9, u16>;
        impl R {
            ///Bits 0:8 - Data value
            #[inline(always)]
            pub fn dr(&self) -> DR_R {
                DR_R::new((self.bits & 0x01ff) as u16)
            }
        }
        impl W {
            ///Bits 0:8 - Data value
            #[inline(always)]
            #[must_use]
            pub fn dr(&mut self) -> DR_W<DATAR_SPEC> {
                DR_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Data register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`datar::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`datar::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct DATAR_SPEC;
        impl crate::RegisterSpec for DATAR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`datar::R`](R) reader structure
        impl crate::Readable for DATAR_SPEC {}
        ///`write(|w| ..)` method takes [`datar::W`](W) writer structure
        impl crate::Writable for DATAR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets DATAR to value 0
        impl crate::Resettable for DATAR_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///BRR (rw) register accessor: Baud rate register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`brr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`brr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@brr`]
    ///module
    pub type BRR = crate::Reg<brr::BRR_SPEC>;
    ///Baud rate register
    pub mod brr {
        ///Register `BRR` reader
        pub type R = crate::R<BRR_SPEC>;
        ///Register `BRR` writer
        pub type W = crate::W<BRR_SPEC>;
        ///Field `DIV_Fraction` reader - fraction of USARTDIV
        pub type DIV_FRACTION_R = crate::FieldReader;
        ///Field `DIV_Fraction` writer - fraction of USARTDIV
        pub type DIV_FRACTION_W<'a, REG> = crate::FieldWriter<'a, REG, 4>;
        ///Field `DIV_Mantissa` reader - mantissa of USARTDIV
        pub type DIV_MANTISSA_R = crate::FieldReader<u16>;
        ///Field `DIV_Mantissa` writer - mantissa of USARTDIV
        pub type DIV_MANTISSA_W<'a, REG> = crate::FieldWriter<'a, REG, 12, u16>;
        impl R {
            ///Bits 0:3 - fraction of USARTDIV
            #[inline(always)]
            pub fn div_fraction(&self) -> DIV_FRACTION_R {
                DIV_FRACTION_R::new((self.bits & 0x0f) as u8)
            }
            ///Bits 4:15 - mantissa of USARTDIV
            #[inline(always)]
            pub fn div_mantissa(&self) -> DIV_MANTISSA_R {
                DIV_MANTISSA_R::new(((self.bits >> 4) & 0x0fff) as u16)
            }
        }
        impl W {
            ///Bits 0:3 - fraction of USARTDIV
            #[inline(always)]
            #[must_use]
            pub fn div_fraction(&mut self) -> DIV_FRACTION_W<BRR_SPEC> {
                DIV_FRACTION_W::new(self, 0)
            }
            ///Bits 4:15 - mantissa of USARTDIV
            #[inline(always)]
            #[must_use]
            pub fn div_mantissa(&mut self) -> DIV_MANTISSA_W<BRR_SPEC> {
                DIV_MANTISSA_W::new(self, 4)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Baud rate register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`brr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`brr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct BRR_SPEC;
        impl crate::RegisterSpec for BRR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`brr::R`](R) reader structure
        impl crate::Readable for BRR_SPEC {}
        ///`write(|w| ..)` method takes [`brr::W`](W) writer structure
        impl crate::Writable for BRR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets BRR to value 0
        impl crate::Resettable for BRR_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///CTLR1 (rw) register accessor: Control register 1
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`ctlr1::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ctlr1::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@ctlr1`]
    ///module
    pub type CTLR1 = crate::Reg<ctlr1::CTLR1_SPEC>;
    ///Control register 1
    pub mod ctlr1 {
        ///Register `CTLR1` reader
        pub type R = crate::R<CTLR1_SPEC>;
        ///Register `CTLR1` writer
        pub type W = crate::W<CTLR1_SPEC>;
        ///Field `SBK` reader - Send break
        pub type SBK_R = crate::BitReader;
        ///Field `SBK` writer - Send break
        pub type SBK_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `RWU` reader - Receiver wakeup
        pub type RWU_R = crate::BitReader;
        ///Field `RWU` writer - Receiver wakeup
        pub type RWU_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `RE` reader - Receiver enable
        pub type RE_R = crate::BitReader;
        ///Field `RE` writer - Receiver enable
        pub type RE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TE` reader - Transmitter enable
        pub type TE_R = crate::BitReader;
        ///Field `TE` writer - Transmitter enable
        pub type TE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `IDLEIE` reader - IDLE interrupt enable
        pub type IDLEIE_R = crate::BitReader;
        ///Field `IDLEIE` writer - IDLE interrupt enable
        pub type IDLEIE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `RXNEIE` reader - RXNE interrupt enable
        pub type RXNEIE_R = crate::BitReader;
        ///Field `RXNEIE` writer - RXNE interrupt enable
        pub type RXNEIE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TCIE` reader - Transmission complete interrupt enable
        pub type TCIE_R = crate::BitReader;
        ///Field `TCIE` writer - Transmission complete interrupt enable
        pub type TCIE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TXEIE` reader - TXE interrupt enable
        pub type TXEIE_R = crate::BitReader;
        ///Field `TXEIE` writer - TXE interrupt enable
        pub type TXEIE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PEIE` reader - PE interrupt enable
        pub type PEIE_R = crate::BitReader;
        ///Field `PEIE` writer - PE interrupt enable
        pub type PEIE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PS` reader - Parity selection
        pub type PS_R = crate::BitReader;
        ///Field `PS` writer - Parity selection
        pub type PS_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PCE` reader - Parity control enable
        pub type PCE_R = crate::BitReader;
        ///Field `PCE` writer - Parity control enable
        pub type PCE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `WAKE` reader - Wakeup method
        pub type WAKE_R = crate::BitReader;
        ///Field `WAKE` writer - Wakeup method
        pub type WAKE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `M` reader - Word length
        pub type M_R = crate::BitReader;
        ///Field `M` writer - Word length
        pub type M_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UE` reader - USART enable
        pub type UE_R = crate::BitReader;
        ///Field `UE` writer - USART enable
        pub type UE_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - Send break
            #[inline(always)]
            pub fn sbk(&self) -> SBK_R {
                SBK_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Receiver wakeup
            #[inline(always)]
            pub fn rwu(&self) -> RWU_R {
                RWU_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - Receiver enable
            #[inline(always)]
            pub fn re(&self) -> RE_R {
                RE_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - Transmitter enable
            #[inline(always)]
            pub fn te(&self) -> TE_R {
                TE_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - IDLE interrupt enable
            #[inline(always)]
            pub fn idleie(&self) -> IDLEIE_R {
                IDLEIE_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - RXNE interrupt enable
            #[inline(always)]
            pub fn rxneie(&self) -> RXNEIE_R {
                RXNEIE_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - Transmission complete interrupt enable
            #[inline(always)]
            pub fn tcie(&self) -> TCIE_R {
                TCIE_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - TXE interrupt enable
            #[inline(always)]
            pub fn txeie(&self) -> TXEIE_R {
                TXEIE_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bit 8 - PE interrupt enable
            #[inline(always)]
            pub fn peie(&self) -> PEIE_R {
                PEIE_R::new(((self.bits >> 8) & 1) != 0)
            }
            ///Bit 9 - Parity selection
            #[inline(always)]
            pub fn ps(&self) -> PS_R {
                PS_R::new(((self.bits >> 9) & 1) != 0)
            }
            ///Bit 10 - Parity control enable
            #[inline(always)]
            pub fn pce(&self) -> PCE_R {
                PCE_R::new(((self.bits >> 10) & 1) != 0)
            }
            ///Bit 11 - Wakeup method
            #[inline(always)]
            pub fn wake(&self) -> WAKE_R {
                WAKE_R::new(((self.bits >> 11) & 1) != 0)
            }
            ///Bit 12 - Word length
            #[inline(always)]
            pub fn m(&self) -> M_R {
                M_R::new(((self.bits >> 12) & 1) != 0)
            }
            ///Bit 13 - USART enable
            #[inline(always)]
            pub fn ue(&self) -> UE_R {
                UE_R::new(((self.bits >> 13) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - Send break
            #[inline(always)]
            #[must_use]
            pub fn sbk(&mut self) -> SBK_W<CTLR1_SPEC> {
                SBK_W::new(self, 0)
            }
            ///Bit 1 - Receiver wakeup
            #[inline(always)]
            #[must_use]
            pub fn rwu(&mut self) -> RWU_W<CTLR1_SPEC> {
                RWU_W::new(self, 1)
            }
            ///Bit 2 - Receiver enable
            #[inline(always)]
            #[must_use]
            pub fn re(&mut self) -> RE_W<CTLR1_SPEC> {
                RE_W::new(self, 2)
            }
            ///Bit 3 - Transmitter enable
            #[inline(always)]
            #[must_use]
            pub fn te(&mut self) -> TE_W<CTLR1_SPEC> {
                TE_W::new(self, 3)
            }
            ///Bit 4 - IDLE interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn idleie(&mut self) -> IDLEIE_W<CTLR1_SPEC> {
                IDLEIE_W::new(self, 4)
            }
            ///Bit 5 - RXNE interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn rxneie(&mut self) -> RXNEIE_W<CTLR1_SPEC> {
                RXNEIE_W::new(self, 5)
            }
            ///Bit 6 - Transmission complete interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn tcie(&mut self) -> TCIE_W<CTLR1_SPEC> {
                TCIE_W::new(self, 6)
            }
            ///Bit 7 - TXE interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn txeie(&mut self) -> TXEIE_W<CTLR1_SPEC> {
                TXEIE_W::new(self, 7)
            }
            ///Bit 8 - PE interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn peie(&mut self) -> PEIE_W<CTLR1_SPEC> {
                PEIE_W::new(self, 8)
            }
            ///Bit 9 - Parity selection
            #[inline(always)]
            #[must_use]
            pub fn ps(&mut self) -> PS_W<CTLR1_SPEC> {
                PS_W::new(self, 9)
            }
            ///Bit 10 - Parity control enable
            #[inline(always)]
            #[must_use]
            pub fn pce(&mut self) -> PCE_W<CTLR1_SPEC> {
                PCE_W::new(self, 10)
            }
            ///Bit 11 - Wakeup method
            #[inline(always)]
            #[must_use]
            pub fn wake(&mut self) -> WAKE_W<CTLR1_SPEC> {
                WAKE_W::new(self, 11)
            }
            ///Bit 12 - Word length
            #[inline(always)]
            #[must_use]
            pub fn m(&mut self) -> M_W<CTLR1_SPEC> {
                M_W::new(self, 12)
            }
            ///Bit 13 - USART enable
            #[inline(always)]
            #[must_use]
            pub fn ue(&mut self) -> UE_W<CTLR1_SPEC> {
                UE_W::new(self, 13)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Control register 1
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`ctlr1::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ctlr1::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct CTLR1_SPEC;
        impl crate::RegisterSpec for CTLR1_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`ctlr1::R`](R) reader structure
        impl crate::Readable for CTLR1_SPEC {}
        ///`write(|w| ..)` method takes [`ctlr1::W`](W) writer structure
        impl crate::Writable for CTLR1_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets CTLR1 to value 0
        impl crate::Resettable for CTLR1_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///CTLR2 (rw) register accessor: Control register 2
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`ctlr2::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ctlr2::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@ctlr2`]
    ///module
    pub type CTLR2 = crate::Reg<ctlr2::CTLR2_SPEC>;
    ///Control register 2
    pub mod ctlr2 {
        ///Register `CTLR2` reader
        pub type R = crate::R<CTLR2_SPEC>;
        ///Register `CTLR2` writer
        pub type W = crate::W<CTLR2_SPEC>;
        ///Field `ADD` reader - Address of the USART node
        pub type ADD_R = crate::FieldReader;
        ///Field `ADD` writer - Address of the USART node
        pub type ADD_W<'a, REG> = crate::FieldWriter<'a, REG, 4>;
        ///Field `LBDL` reader - lin break detection length
        pub type LBDL_R = crate::BitReader;
        ///Field `LBDL` writer - lin break detection length
        pub type LBDL_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `LBDIE` reader - LIN break detection interrupt enable
        pub type LBDIE_R = crate::BitReader;
        ///Field `LBDIE` writer - LIN break detection interrupt enable
        pub type LBDIE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `LBCL` reader - Last bit clock pulse
        pub type LBCL_R = crate::BitReader;
        ///Field `LBCL` writer - Last bit clock pulse
        pub type LBCL_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CPHA` reader - Clock phase
        pub type CPHA_R = crate::BitReader;
        ///Field `CPHA` writer - Clock phase
        pub type CPHA_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CPOL` reader - Clock polarity
        pub type CPOL_R = crate::BitReader;
        ///Field `CPOL` writer - Clock polarity
        pub type CPOL_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CLKEN` reader - Clock enable
        pub type CLKEN_R = crate::BitReader;
        ///Field `CLKEN` writer - Clock enable
        pub type CLKEN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `STOP` reader - STOP bits
        pub type STOP_R = crate::FieldReader;
        ///Field `STOP` writer - STOP bits
        pub type STOP_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `LINEN` reader - LIN mode enable
        pub type LINEN_R = crate::BitReader;
        ///Field `LINEN` writer - LIN mode enable
        pub type LINEN_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bits 0:3 - Address of the USART node
            #[inline(always)]
            pub fn add(&self) -> ADD_R {
                ADD_R::new((self.bits & 0x0f) as u8)
            }
            ///Bit 5 - lin break detection length
            #[inline(always)]
            pub fn lbdl(&self) -> LBDL_R {
                LBDL_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - LIN break detection interrupt enable
            #[inline(always)]
            pub fn lbdie(&self) -> LBDIE_R {
                LBDIE_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 8 - Last bit clock pulse
            #[inline(always)]
            pub fn lbcl(&self) -> LBCL_R {
                LBCL_R::new(((self.bits >> 8) & 1) != 0)
            }
            ///Bit 9 - Clock phase
            #[inline(always)]
            pub fn cpha(&self) -> CPHA_R {
                CPHA_R::new(((self.bits >> 9) & 1) != 0)
            }
            ///Bit 10 - Clock polarity
            #[inline(always)]
            pub fn cpol(&self) -> CPOL_R {
                CPOL_R::new(((self.bits >> 10) & 1) != 0)
            }
            ///Bit 11 - Clock enable
            #[inline(always)]
            pub fn clken(&self) -> CLKEN_R {
                CLKEN_R::new(((self.bits >> 11) & 1) != 0)
            }
            ///Bits 12:13 - STOP bits
            #[inline(always)]
            pub fn stop(&self) -> STOP_R {
                STOP_R::new(((self.bits >> 12) & 3) as u8)
            }
            ///Bit 14 - LIN mode enable
            #[inline(always)]
            pub fn linen(&self) -> LINEN_R {
                LINEN_R::new(((self.bits >> 14) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:3 - Address of the USART node
            #[inline(always)]
            #[must_use]
            pub fn add(&mut self) -> ADD_W<CTLR2_SPEC> {
                ADD_W::new(self, 0)
            }
            ///Bit 5 - lin break detection length
            #[inline(always)]
            #[must_use]
            pub fn lbdl(&mut self) -> LBDL_W<CTLR2_SPEC> {
                LBDL_W::new(self, 5)
            }
            ///Bit 6 - LIN break detection interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn lbdie(&mut self) -> LBDIE_W<CTLR2_SPEC> {
                LBDIE_W::new(self, 6)
            }
            ///Bit 8 - Last bit clock pulse
            #[inline(always)]
            #[must_use]
            pub fn lbcl(&mut self) -> LBCL_W<CTLR2_SPEC> {
                LBCL_W::new(self, 8)
            }
            ///Bit 9 - Clock phase
            #[inline(always)]
            #[must_use]
            pub fn cpha(&mut self) -> CPHA_W<CTLR2_SPEC> {
                CPHA_W::new(self, 9)
            }
            ///Bit 10 - Clock polarity
            #[inline(always)]
            #[must_use]
            pub fn cpol(&mut self) -> CPOL_W<CTLR2_SPEC> {
                CPOL_W::new(self, 10)
            }
            ///Bit 11 - Clock enable
            #[inline(always)]
            #[must_use]
            pub fn clken(&mut self) -> CLKEN_W<CTLR2_SPEC> {
                CLKEN_W::new(self, 11)
            }
            ///Bits 12:13 - STOP bits
            #[inline(always)]
            #[must_use]
            pub fn stop(&mut self) -> STOP_W<CTLR2_SPEC> {
                STOP_W::new(self, 12)
            }
            ///Bit 14 - LIN mode enable
            #[inline(always)]
            #[must_use]
            pub fn linen(&mut self) -> LINEN_W<CTLR2_SPEC> {
                LINEN_W::new(self, 14)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Control register 2
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`ctlr2::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ctlr2::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct CTLR2_SPEC;
        impl crate::RegisterSpec for CTLR2_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`ctlr2::R`](R) reader structure
        impl crate::Readable for CTLR2_SPEC {}
        ///`write(|w| ..)` method takes [`ctlr2::W`](W) writer structure
        impl crate::Writable for CTLR2_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets CTLR2 to value 0
        impl crate::Resettable for CTLR2_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///CTLR3 (rw) register accessor: Control register 3
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`ctlr3::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ctlr3::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@ctlr3`]
    ///module
    pub type CTLR3 = crate::Reg<ctlr3::CTLR3_SPEC>;
    ///Control register 3
    pub mod ctlr3 {
        ///Register `CTLR3` reader
        pub type R = crate::R<CTLR3_SPEC>;
        ///Register `CTLR3` writer
        pub type W = crate::W<CTLR3_SPEC>;
        ///Field `EIE` reader - Error interrupt enable
        pub type EIE_R = crate::BitReader;
        ///Field `EIE` writer - Error interrupt enable
        pub type EIE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `IREN` reader - IrDA mode enable
        pub type IREN_R = crate::BitReader;
        ///Field `IREN` writer - IrDA mode enable
        pub type IREN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `IRLP` reader - IrDA low-power
        pub type IRLP_R = crate::BitReader;
        ///Field `IRLP` writer - IrDA low-power
        pub type IRLP_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `HDSEL` reader - Half-duplex selection
        pub type HDSEL_R = crate::BitReader;
        ///Field `HDSEL` writer - Half-duplex selection
        pub type HDSEL_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `NACK` reader - Smartcard NACK enable
        pub type NACK_R = crate::BitReader;
        ///Field `NACK` writer - Smartcard NACK enable
        pub type NACK_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `SCEN` reader - Smartcard mode enable
        pub type SCEN_R = crate::BitReader;
        ///Field `SCEN` writer - Smartcard mode enable
        pub type SCEN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `DMAR` reader - DMA enable receiver
        pub type DMAR_R = crate::BitReader;
        ///Field `DMAR` writer - DMA enable receiver
        pub type DMAR_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `DMAT` reader - DMA enable transmitter
        pub type DMAT_R = crate::BitReader;
        ///Field `DMAT` writer - DMA enable transmitter
        pub type DMAT_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `RTSE` reader - RTS enable
        pub type RTSE_R = crate::BitReader;
        ///Field `RTSE` writer - RTS enable
        pub type RTSE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CTSE` reader - CTS enable
        pub type CTSE_R = crate::BitReader;
        ///Field `CTSE` writer - CTS enable
        pub type CTSE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CTSIE` reader - CTS interrupt enable
        pub type CTSIE_R = crate::BitReader;
        ///Field `CTSIE` writer - CTS interrupt enable
        pub type CTSIE_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - Error interrupt enable
            #[inline(always)]
            pub fn eie(&self) -> EIE_R {
                EIE_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - IrDA mode enable
            #[inline(always)]
            pub fn iren(&self) -> IREN_R {
                IREN_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - IrDA low-power
            #[inline(always)]
            pub fn irlp(&self) -> IRLP_R {
                IRLP_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - Half-duplex selection
            #[inline(always)]
            pub fn hdsel(&self) -> HDSEL_R {
                HDSEL_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - Smartcard NACK enable
            #[inline(always)]
            pub fn nack(&self) -> NACK_R {
                NACK_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - Smartcard mode enable
            #[inline(always)]
            pub fn scen(&self) -> SCEN_R {
                SCEN_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - DMA enable receiver
            #[inline(always)]
            pub fn dmar(&self) -> DMAR_R {
                DMAR_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - DMA enable transmitter
            #[inline(always)]
            pub fn dmat(&self) -> DMAT_R {
                DMAT_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bit 8 - RTS enable
            #[inline(always)]
            pub fn rtse(&self) -> RTSE_R {
                RTSE_R::new(((self.bits >> 8) & 1) != 0)
            }
            ///Bit 9 - CTS enable
            #[inline(always)]
            pub fn ctse(&self) -> CTSE_R {
                CTSE_R::new(((self.bits >> 9) & 1) != 0)
            }
            ///Bit 10 - CTS interrupt enable
            #[inline(always)]
            pub fn ctsie(&self) -> CTSIE_R {
                CTSIE_R::new(((self.bits >> 10) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - Error interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn eie(&mut self) -> EIE_W<CTLR3_SPEC> {
                EIE_W::new(self, 0)
            }
            ///Bit 1 - IrDA mode enable
            #[inline(always)]
            #[must_use]
            pub fn iren(&mut self) -> IREN_W<CTLR3_SPEC> {
                IREN_W::new(self, 1)
            }
            ///Bit 2 - IrDA low-power
            #[inline(always)]
            #[must_use]
            pub fn irlp(&mut self) -> IRLP_W<CTLR3_SPEC> {
                IRLP_W::new(self, 2)
            }
            ///Bit 3 - Half-duplex selection
            #[inline(always)]
            #[must_use]
            pub fn hdsel(&mut self) -> HDSEL_W<CTLR3_SPEC> {
                HDSEL_W::new(self, 3)
            }
            ///Bit 4 - Smartcard NACK enable
            #[inline(always)]
            #[must_use]
            pub fn nack(&mut self) -> NACK_W<CTLR3_SPEC> {
                NACK_W::new(self, 4)
            }
            ///Bit 5 - Smartcard mode enable
            #[inline(always)]
            #[must_use]
            pub fn scen(&mut self) -> SCEN_W<CTLR3_SPEC> {
                SCEN_W::new(self, 5)
            }
            ///Bit 6 - DMA enable receiver
            #[inline(always)]
            #[must_use]
            pub fn dmar(&mut self) -> DMAR_W<CTLR3_SPEC> {
                DMAR_W::new(self, 6)
            }
            ///Bit 7 - DMA enable transmitter
            #[inline(always)]
            #[must_use]
            pub fn dmat(&mut self) -> DMAT_W<CTLR3_SPEC> {
                DMAT_W::new(self, 7)
            }
            ///Bit 8 - RTS enable
            #[inline(always)]
            #[must_use]
            pub fn rtse(&mut self) -> RTSE_W<CTLR3_SPEC> {
                RTSE_W::new(self, 8)
            }
            ///Bit 9 - CTS enable
            #[inline(always)]
            #[must_use]
            pub fn ctse(&mut self) -> CTSE_W<CTLR3_SPEC> {
                CTSE_W::new(self, 9)
            }
            ///Bit 10 - CTS interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn ctsie(&mut self) -> CTSIE_W<CTLR3_SPEC> {
                CTSIE_W::new(self, 10)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Control register 3
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`ctlr3::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ctlr3::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct CTLR3_SPEC;
        impl crate::RegisterSpec for CTLR3_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`ctlr3::R`](R) reader structure
        impl crate::Readable for CTLR3_SPEC {}
        ///`write(|w| ..)` method takes [`ctlr3::W`](W) writer structure
        impl crate::Writable for CTLR3_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets CTLR3 to value 0
        impl crate::Resettable for CTLR3_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///GPR (rw) register accessor: Guard time and prescaler register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`gpr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`gpr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@gpr`]
    ///module
    pub type GPR = crate::Reg<gpr::GPR_SPEC>;
    ///Guard time and prescaler register
    pub mod gpr {
        ///Register `GPR` reader
        pub type R = crate::R<GPR_SPEC>;
        ///Register `GPR` writer
        pub type W = crate::W<GPR_SPEC>;
        ///Field `PSC` reader - Prescaler value
        pub type PSC_R = crate::FieldReader;
        ///Field `PSC` writer - Prescaler value
        pub type PSC_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        ///Field `GT` reader - Guard time value
        pub type GT_R = crate::FieldReader;
        ///Field `GT` writer - Guard time value
        pub type GT_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            ///Bits 0:7 - Prescaler value
            #[inline(always)]
            pub fn psc(&self) -> PSC_R {
                PSC_R::new((self.bits & 0xff) as u8)
            }
            ///Bits 8:15 - Guard time value
            #[inline(always)]
            pub fn gt(&self) -> GT_R {
                GT_R::new(((self.bits >> 8) & 0xff) as u8)
            }
        }
        impl W {
            ///Bits 0:7 - Prescaler value
            #[inline(always)]
            #[must_use]
            pub fn psc(&mut self) -> PSC_W<GPR_SPEC> {
                PSC_W::new(self, 0)
            }
            ///Bits 8:15 - Guard time value
            #[inline(always)]
            #[must_use]
            pub fn gt(&mut self) -> GT_W<GPR_SPEC> {
                GT_W::new(self, 8)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Guard time and prescaler register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`gpr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`gpr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct GPR_SPEC;
        impl crate::RegisterSpec for GPR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`gpr::R`](R) reader structure
        impl crate::Readable for GPR_SPEC {}
        ///`write(|w| ..)` method takes [`gpr::W`](W) writer structure
        impl crate::Writable for GPR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets GPR to value 0
        impl crate::Resettable for GPR_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
}
///Universal synchronous asynchronous receiver transmitter
pub struct USART2 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for USART2 {}
impl USART2 {
    ///Pointer to the register block
    pub const PTR: *const usart1::RegisterBlock = 0x4000_4400 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const usart1::RegisterBlock {
        Self::PTR
    }
    /// Steal an instance of this peripheral
    ///
    /// # Safety
    ///
    /// Ensure that the new instance of the peripheral cannot be used in a way
    /// that may race with any existing instances, for example by only
    /// accessing read-only or write-only registers, or by consuming the
    /// original peripheral and using critical sections to coordinate
    /// access between multiple new instances.
    ///
    /// Additionally, other software such as HALs may rely on only one
    /// peripheral instance existing to ensure memory safety; ensure
    /// no stolen instances are passed to such software.
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for USART2 {
    type Target = usart1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for USART2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("USART2").finish()
    }
}
///Universal synchronous asynchronous receiver transmitter
pub use self::usart1 as usart2;
///Universal synchronous asynchronous receiver transmitter
pub struct USART3 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for USART3 {}
impl USART3 {
    ///Pointer to the register block
    pub const PTR: *const usart1::RegisterBlock = 0x4000_4800 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const usart1::RegisterBlock {
        Self::PTR
    }
    /// Steal an instance of this peripheral
    ///
    /// # Safety
    ///
    /// Ensure that the new instance of the peripheral cannot be used in a way
    /// that may race with any existing instances, for example by only
    /// accessing read-only or write-only registers, or by consuming the
    /// original peripheral and using critical sections to coordinate
    /// access between multiple new instances.
    ///
    /// Additionally, other software such as HALs may rely on only one
    /// peripheral instance existing to ensure memory safety; ensure
    /// no stolen instances are passed to such software.
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for USART3 {
    type Target = usart1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for USART3 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("USART3").finish()
    }
}
///Universal synchronous asynchronous receiver transmitter
pub use self::usart1 as usart3;
///Universal synchronous asynchronous receiver transmitter
pub struct UART4 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for UART4 {}
impl UART4 {
    ///Pointer to the register block
    pub const PTR: *const usart1::RegisterBlock = 0x4000_4c00 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const usart1::RegisterBlock {
        Self::PTR
    }
    /// Steal an instance of this peripheral
    ///
    /// # Safety
    ///
    /// Ensure that the new instance of the peripheral cannot be used in a way
    /// that may race with any existing instances, for example by only
    /// accessing read-only or write-only registers, or by consuming the
    /// original peripheral and using critical sections to coordinate
    /// access between multiple new instances.
    ///
    /// Additionally, other software such as HALs may rely on only one
    /// peripheral instance existing to ensure memory safety; ensure
    /// no stolen instances are passed to such software.
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for UART4 {
    type Target = usart1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for UART4 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("UART4").finish()
    }
}
///Universal synchronous asynchronous receiver transmitter
pub use self::usart1 as uart4;
///Analog to digital converter_TOUCHKEY detection
pub struct ADC__TKEY {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for ADC__TKEY {}
impl ADC__TKEY {
    ///Pointer to the register block
    pub const PTR: *const adc__tkey::RegisterBlock = 0x4001_2400 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const adc__tkey::RegisterBlock {
        Self::PTR
    }
    /// Steal an instance of this peripheral
    ///
    /// # Safety
    ///
    /// Ensure that the new instance of the peripheral cannot be used in a way
    /// that may race with any existing instances, for example by only
    /// accessing read-only or write-only registers, or by consuming the
    /// original peripheral and using critical sections to coordinate
    /// access between multiple new instances.
    ///
    /// Additionally, other software such as HALs may rely on only one
    /// peripheral instance existing to ensure memory safety; ensure
    /// no stolen instances are passed to such software.
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for ADC__TKEY {
    type Target = adc__tkey::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for ADC__TKEY {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("ADC__TKEY").finish()
    }
}
///Analog to digital converter_TOUCHKEY detection
pub mod adc__tkey {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        statr: STATR,
        ctlr1: CTLR1,
        ctlr2: CTLR2,
        samptr1_charge1: SAMPTR1_CHARGE1,
        samptr2_charge2: SAMPTR2_CHARGE2,
        iofr1: IOFR1,
        iofr2: IOFR2,
        iofr3: IOFR3,
        iofr4: IOFR4,
        wdhtr: WDHTR,
        wdltr: WDLTR,
        rsqr1: RSQR1,
        rsqr2: RSQR2,
        rsqr3: RSQR3,
        isqr: ISQR,
        idatar1_chgoffset: IDATAR1_CHGOFFSET,
        idatar2: IDATAR2,
        idatar3: IDATAR3,
        idatar4: IDATAR4,
        rdatar_dr_act_dcg: RDATAR_DR_ACT_DCG,
        cfg: CFG,
    }
    impl RegisterBlock {
        ///0x00 - status register
        #[inline(always)]
        pub const fn statr(&self) -> &STATR {
            &self.statr
        }
        ///0x04 - control register 1
        #[inline(always)]
        pub const fn ctlr1(&self) -> &CTLR1 {
            &self.ctlr1
        }
        ///0x08 - control register 2
        #[inline(always)]
        pub const fn ctlr2(&self) -> &CTLR2 {
            &self.ctlr2
        }
        ///0x0c - sample time register 1
        #[inline(always)]
        pub const fn samptr1_charge1(&self) -> &SAMPTR1_CHARGE1 {
            &self.samptr1_charge1
        }
        ///0x10 - sample time register 2
        #[inline(always)]
        pub const fn samptr2_charge2(&self) -> &SAMPTR2_CHARGE2 {
            &self.samptr2_charge2
        }
        ///0x14 - injected channel data offset register x
        #[inline(always)]
        pub const fn iofr1(&self) -> &IOFR1 {
            &self.iofr1
        }
        ///0x18 - injected channel data offset register x
        #[inline(always)]
        pub const fn iofr2(&self) -> &IOFR2 {
            &self.iofr2
        }
        ///0x1c - injected channel data offset register x
        #[inline(always)]
        pub const fn iofr3(&self) -> &IOFR3 {
            &self.iofr3
        }
        ///0x20 - injected channel data offset register x
        #[inline(always)]
        pub const fn iofr4(&self) -> &IOFR4 {
            &self.iofr4
        }
        ///0x24 - watchdog higher threshold register
        #[inline(always)]
        pub const fn wdhtr(&self) -> &WDHTR {
            &self.wdhtr
        }
        ///0x28 - watchdog lower threshold register
        #[inline(always)]
        pub const fn wdltr(&self) -> &WDLTR {
            &self.wdltr
        }
        ///0x2c - regular sequence register 1
        #[inline(always)]
        pub const fn rsqr1(&self) -> &RSQR1 {
            &self.rsqr1
        }
        ///0x30 - regular sequence register 2
        #[inline(always)]
        pub const fn rsqr2(&self) -> &RSQR2 {
            &self.rsqr2
        }
        ///0x34 - regular sequence register 3
        #[inline(always)]
        pub const fn rsqr3(&self) -> &RSQR3 {
            &self.rsqr3
        }
        ///0x38 - injected sequence register
        #[inline(always)]
        pub const fn isqr(&self) -> &ISQR {
            &self.isqr
        }
        ///0x3c - injected data register 1
        #[inline(always)]
        pub const fn idatar1_chgoffset(&self) -> &IDATAR1_CHGOFFSET {
            &self.idatar1_chgoffset
        }
        ///0x40 - injected data register 2
        #[inline(always)]
        pub const fn idatar2(&self) -> &IDATAR2 {
            &self.idatar2
        }
        ///0x44 - injected data register 3
        #[inline(always)]
        pub const fn idatar3(&self) -> &IDATAR3 {
            &self.idatar3
        }
        ///0x48 - injected data register 4
        #[inline(always)]
        pub const fn idatar4(&self) -> &IDATAR4 {
            &self.idatar4
        }
        ///0x4c - regular data register_start and discharge time register
        #[inline(always)]
        pub const fn rdatar_dr_act_dcg(&self) -> &RDATAR_DR_ACT_DCG {
            &self.rdatar_dr_act_dcg
        }
        ///0x50 - ADC configuration register
        #[inline(always)]
        pub const fn cfg(&self) -> &CFG {
            &self.cfg
        }
    }
    ///STATR (rw) register accessor: status register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`statr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`statr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@statr`]
    ///module
    pub type STATR = crate::Reg<statr::STATR_SPEC>;
    ///status register
    pub mod statr {
        ///Register `STATR` reader
        pub type R = crate::R<STATR_SPEC>;
        ///Register `STATR` writer
        pub type W = crate::W<STATR_SPEC>;
        ///Field `AWD` reader - Analog watchdog flag
        pub type AWD_R = crate::BitReader;
        ///Field `AWD` writer - Analog watchdog flag
        pub type AWD_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `EOC` reader - Regular channel end of conversion
        pub type EOC_R = crate::BitReader;
        ///Field `EOC` writer - Regular channel end of conversion
        pub type EOC_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `JEOC` reader - Injected channel end of conversion
        pub type JEOC_R = crate::BitReader;
        ///Field `JEOC` writer - Injected channel end of conversion
        pub type JEOC_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `JSTRT` reader - Injected channel start flag
        pub type JSTRT_R = crate::BitReader;
        ///Field `JSTRT` writer - Injected channel start flag
        pub type JSTRT_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `STRT` reader - Regular channel start flag
        pub type STRT_R = crate::BitReader;
        ///Field `STRT` writer - Regular channel start flag
        pub type STRT_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - Analog watchdog flag
            #[inline(always)]
            pub fn awd(&self) -> AWD_R {
                AWD_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Regular channel end of conversion
            #[inline(always)]
            pub fn eoc(&self) -> EOC_R {
                EOC_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - Injected channel end of conversion
            #[inline(always)]
            pub fn jeoc(&self) -> JEOC_R {
                JEOC_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - Injected channel start flag
            #[inline(always)]
            pub fn jstrt(&self) -> JSTRT_R {
                JSTRT_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - Regular channel start flag
            #[inline(always)]
            pub fn strt(&self) -> STRT_R {
                STRT_R::new(((self.bits >> 4) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - Analog watchdog flag
            #[inline(always)]
            #[must_use]
            pub fn awd(&mut self) -> AWD_W<STATR_SPEC> {
                AWD_W::new(self, 0)
            }
            ///Bit 1 - Regular channel end of conversion
            #[inline(always)]
            #[must_use]
            pub fn eoc(&mut self) -> EOC_W<STATR_SPEC> {
                EOC_W::new(self, 1)
            }
            ///Bit 2 - Injected channel end of conversion
            #[inline(always)]
            #[must_use]
            pub fn jeoc(&mut self) -> JEOC_W<STATR_SPEC> {
                JEOC_W::new(self, 2)
            }
            ///Bit 3 - Injected channel start flag
            #[inline(always)]
            #[must_use]
            pub fn jstrt(&mut self) -> JSTRT_W<STATR_SPEC> {
                JSTRT_W::new(self, 3)
            }
            ///Bit 4 - Regular channel start flag
            #[inline(always)]
            #[must_use]
            pub fn strt(&mut self) -> STRT_W<STATR_SPEC> {
                STRT_W::new(self, 4)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///status register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`statr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`statr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct STATR_SPEC;
        impl crate::RegisterSpec for STATR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`statr::R`](R) reader structure
        impl crate::Readable for STATR_SPEC {}
        ///`write(|w| ..)` method takes [`statr::W`](W) writer structure
        impl crate::Writable for STATR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets STATR to value 0
        impl crate::Resettable for STATR_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///CTLR1 (rw) register accessor: control register 1
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`ctlr1::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ctlr1::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@ctlr1`]
    ///module
    pub type CTLR1 = crate::Reg<ctlr1::CTLR1_SPEC>;
    ///control register 1
    pub mod ctlr1 {
        ///Register `CTLR1` reader
        pub type R = crate::R<CTLR1_SPEC>;
        ///Register `CTLR1` writer
        pub type W = crate::W<CTLR1_SPEC>;
        ///Field `AWDCH` reader - Analog watchdog channel select bits
        pub type AWDCH_R = crate::FieldReader;
        ///Field `AWDCH` writer - Analog watchdog channel select bits
        pub type AWDCH_W<'a, REG> = crate::FieldWriter<'a, REG, 5>;
        ///Field `EOCIE` reader - Interrupt enable for EOC
        pub type EOCIE_R = crate::BitReader;
        ///Field `EOCIE` writer - Interrupt enable for EOC
        pub type EOCIE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `AWDIE` reader - Analog watchdog interrupt enable
        pub type AWDIE_R = crate::BitReader;
        ///Field `AWDIE` writer - Analog watchdog interrupt enable
        pub type AWDIE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `JEOCIE` reader - Interrupt enable for injected channels
        pub type JEOCIE_R = crate::BitReader;
        ///Field `JEOCIE` writer - Interrupt enable for injected channels
        pub type JEOCIE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `SCAN` reader - Scan mode enable
        pub type SCAN_R = crate::BitReader;
        ///Field `SCAN` writer - Scan mode enable
        pub type SCAN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `AWDSGL` reader - Enable the watchdog on a single channel in scan mode
        pub type AWDSGL_R = crate::BitReader;
        ///Field `AWDSGL` writer - Enable the watchdog on a single channel in scan mode
        pub type AWDSGL_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `JAUTO` reader - Automatic injected group conversion
        pub type JAUTO_R = crate::BitReader;
        ///Field `JAUTO` writer - Automatic injected group conversion
        pub type JAUTO_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `RDISCEN` reader - Discontinuous mode on regular channels
        pub type RDISCEN_R = crate::BitReader;
        ///Field `RDISCEN` writer - Discontinuous mode on regular channels
        pub type RDISCEN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `JDISCEN` reader - Discontinuous mode on injected channels
        pub type JDISCEN_R = crate::BitReader;
        ///Field `JDISCEN` writer - Discontinuous mode on injected channels
        pub type JDISCEN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `DISCNUM` reader - Discontinuous mode channel count
        pub type DISCNUM_R = crate::FieldReader;
        ///Field `DISCNUM` writer - Discontinuous mode channel count
        pub type DISCNUM_W<'a, REG> = crate::FieldWriter<'a, REG, 3>;
        ///Field `CAL_MOD` reader - ADC calibration mode control
        pub type CAL_MOD_R = crate::BitReader;
        ///Field `CAL_MOD` writer - ADC calibration mode control
        pub type CAL_MOD_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `JAWDEN` reader - Analog watchdog enable on injected channels
        pub type JAWDEN_R = crate::BitReader;
        ///Field `JAWDEN` writer - Analog watchdog enable on injected channels
        pub type JAWDEN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `AWDEN` reader - Analog watchdog enable on regular channels
        pub type AWDEN_R = crate::BitReader;
        ///Field `AWDEN` writer - Analog watchdog enable on regular channels
        pub type AWDEN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TKENABLE` reader - TKEY enable, including TKEY_F and TKEY_V
        pub type TKENABLE_R = crate::BitReader;
        ///Field `TKENABLE` writer - TKEY enable, including TKEY_F and TKEY_V
        pub type TKENABLE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TKITUNE` reader - TKEY_I enable
        pub type TKITUNE_R = crate::BitReader;
        ///Field `TKITUNE` writer - TKEY_I enable
        pub type TKITUNE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `BUFEN` reader - TKEY_BUF_Enable
        pub type BUFEN_R = crate::BitReader;
        ///Field `BUFEN` writer - TKEY_BUF_Enable
        pub type BUFEN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PGA` reader - ADC_PGA
        pub type PGA_R = crate::FieldReader;
        ///Field `PGA` writer - ADC_PGA
        pub type PGA_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        impl R {
            ///Bits 0:4 - Analog watchdog channel select bits
            #[inline(always)]
            pub fn awdch(&self) -> AWDCH_R {
                AWDCH_R::new((self.bits & 0x1f) as u8)
            }
            ///Bit 5 - Interrupt enable for EOC
            #[inline(always)]
            pub fn eocie(&self) -> EOCIE_R {
                EOCIE_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - Analog watchdog interrupt enable
            #[inline(always)]
            pub fn awdie(&self) -> AWDIE_R {
                AWDIE_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - Interrupt enable for injected channels
            #[inline(always)]
            pub fn jeocie(&self) -> JEOCIE_R {
                JEOCIE_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bit 8 - Scan mode enable
            #[inline(always)]
            pub fn scan(&self) -> SCAN_R {
                SCAN_R::new(((self.bits >> 8) & 1) != 0)
            }
            ///Bit 9 - Enable the watchdog on a single channel in scan mode
            #[inline(always)]
            pub fn awdsgl(&self) -> AWDSGL_R {
                AWDSGL_R::new(((self.bits >> 9) & 1) != 0)
            }
            ///Bit 10 - Automatic injected group conversion
            #[inline(always)]
            pub fn jauto(&self) -> JAUTO_R {
                JAUTO_R::new(((self.bits >> 10) & 1) != 0)
            }
            ///Bit 11 - Discontinuous mode on regular channels
            #[inline(always)]
            pub fn rdiscen(&self) -> RDISCEN_R {
                RDISCEN_R::new(((self.bits >> 11) & 1) != 0)
            }
            ///Bit 12 - Discontinuous mode on injected channels
            #[inline(always)]
            pub fn jdiscen(&self) -> JDISCEN_R {
                JDISCEN_R::new(((self.bits >> 12) & 1) != 0)
            }
            ///Bits 13:15 - Discontinuous mode channel count
            #[inline(always)]
            pub fn discnum(&self) -> DISCNUM_R {
                DISCNUM_R::new(((self.bits >> 13) & 7) as u8)
            }
            ///Bit 21 - ADC calibration mode control
            #[inline(always)]
            pub fn cal_mod(&self) -> CAL_MOD_R {
                CAL_MOD_R::new(((self.bits >> 21) & 1) != 0)
            }
            ///Bit 22 - Analog watchdog enable on injected channels
            #[inline(always)]
            pub fn jawden(&self) -> JAWDEN_R {
                JAWDEN_R::new(((self.bits >> 22) & 1) != 0)
            }
            ///Bit 23 - Analog watchdog enable on regular channels
            #[inline(always)]
            pub fn awden(&self) -> AWDEN_R {
                AWDEN_R::new(((self.bits >> 23) & 1) != 0)
            }
            ///Bit 24 - TKEY enable, including TKEY_F and TKEY_V
            #[inline(always)]
            pub fn tkenable(&self) -> TKENABLE_R {
                TKENABLE_R::new(((self.bits >> 24) & 1) != 0)
            }
            ///Bit 25 - TKEY_I enable
            #[inline(always)]
            pub fn tkitune(&self) -> TKITUNE_R {
                TKITUNE_R::new(((self.bits >> 25) & 1) != 0)
            }
            ///Bit 26 - TKEY_BUF_Enable
            #[inline(always)]
            pub fn bufen(&self) -> BUFEN_R {
                BUFEN_R::new(((self.bits >> 26) & 1) != 0)
            }
            ///Bits 27:28 - ADC_PGA
            #[inline(always)]
            pub fn pga(&self) -> PGA_R {
                PGA_R::new(((self.bits >> 27) & 3) as u8)
            }
        }
        impl W {
            ///Bits 0:4 - Analog watchdog channel select bits
            #[inline(always)]
            #[must_use]
            pub fn awdch(&mut self) -> AWDCH_W<CTLR1_SPEC> {
                AWDCH_W::new(self, 0)
            }
            ///Bit 5 - Interrupt enable for EOC
            #[inline(always)]
            #[must_use]
            pub fn eocie(&mut self) -> EOCIE_W<CTLR1_SPEC> {
                EOCIE_W::new(self, 5)
            }
            ///Bit 6 - Analog watchdog interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn awdie(&mut self) -> AWDIE_W<CTLR1_SPEC> {
                AWDIE_W::new(self, 6)
            }
            ///Bit 7 - Interrupt enable for injected channels
            #[inline(always)]
            #[must_use]
            pub fn jeocie(&mut self) -> JEOCIE_W<CTLR1_SPEC> {
                JEOCIE_W::new(self, 7)
            }
            ///Bit 8 - Scan mode enable
            #[inline(always)]
            #[must_use]
            pub fn scan(&mut self) -> SCAN_W<CTLR1_SPEC> {
                SCAN_W::new(self, 8)
            }
            ///Bit 9 - Enable the watchdog on a single channel in scan mode
            #[inline(always)]
            #[must_use]
            pub fn awdsgl(&mut self) -> AWDSGL_W<CTLR1_SPEC> {
                AWDSGL_W::new(self, 9)
            }
            ///Bit 10 - Automatic injected group conversion
            #[inline(always)]
            #[must_use]
            pub fn jauto(&mut self) -> JAUTO_W<CTLR1_SPEC> {
                JAUTO_W::new(self, 10)
            }
            ///Bit 11 - Discontinuous mode on regular channels
            #[inline(always)]
            #[must_use]
            pub fn rdiscen(&mut self) -> RDISCEN_W<CTLR1_SPEC> {
                RDISCEN_W::new(self, 11)
            }
            ///Bit 12 - Discontinuous mode on injected channels
            #[inline(always)]
            #[must_use]
            pub fn jdiscen(&mut self) -> JDISCEN_W<CTLR1_SPEC> {
                JDISCEN_W::new(self, 12)
            }
            ///Bits 13:15 - Discontinuous mode channel count
            #[inline(always)]
            #[must_use]
            pub fn discnum(&mut self) -> DISCNUM_W<CTLR1_SPEC> {
                DISCNUM_W::new(self, 13)
            }
            ///Bit 21 - ADC calibration mode control
            #[inline(always)]
            #[must_use]
            pub fn cal_mod(&mut self) -> CAL_MOD_W<CTLR1_SPEC> {
                CAL_MOD_W::new(self, 21)
            }
            ///Bit 22 - Analog watchdog enable on injected channels
            #[inline(always)]
            #[must_use]
            pub fn jawden(&mut self) -> JAWDEN_W<CTLR1_SPEC> {
                JAWDEN_W::new(self, 22)
            }
            ///Bit 23 - Analog watchdog enable on regular channels
            #[inline(always)]
            #[must_use]
            pub fn awden(&mut self) -> AWDEN_W<CTLR1_SPEC> {
                AWDEN_W::new(self, 23)
            }
            ///Bit 24 - TKEY enable, including TKEY_F and TKEY_V
            #[inline(always)]
            #[must_use]
            pub fn tkenable(&mut self) -> TKENABLE_W<CTLR1_SPEC> {
                TKENABLE_W::new(self, 24)
            }
            ///Bit 25 - TKEY_I enable
            #[inline(always)]
            #[must_use]
            pub fn tkitune(&mut self) -> TKITUNE_W<CTLR1_SPEC> {
                TKITUNE_W::new(self, 25)
            }
            ///Bit 26 - TKEY_BUF_Enable
            #[inline(always)]
            #[must_use]
            pub fn bufen(&mut self) -> BUFEN_W<CTLR1_SPEC> {
                BUFEN_W::new(self, 26)
            }
            ///Bits 27:28 - ADC_PGA
            #[inline(always)]
            #[must_use]
            pub fn pga(&mut self) -> PGA_W<CTLR1_SPEC> {
                PGA_W::new(self, 27)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///control register 1
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`ctlr1::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ctlr1::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct CTLR1_SPEC;
        impl crate::RegisterSpec for CTLR1_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`ctlr1::R`](R) reader structure
        impl crate::Readable for CTLR1_SPEC {}
        ///`write(|w| ..)` method takes [`ctlr1::W`](W) writer structure
        impl crate::Writable for CTLR1_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets CTLR1 to value 0
        impl crate::Resettable for CTLR1_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///CTLR2 (rw) register accessor: control register 2
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`ctlr2::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ctlr2::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@ctlr2`]
    ///module
    pub type CTLR2 = crate::Reg<ctlr2::CTLR2_SPEC>;
    ///control register 2
    pub mod ctlr2 {
        ///Register `CTLR2` reader
        pub type R = crate::R<CTLR2_SPEC>;
        ///Register `CTLR2` writer
        pub type W = crate::W<CTLR2_SPEC>;
        ///Field `ADON` reader - A/D converter ON / OFF
        pub type ADON_R = crate::BitReader;
        ///Field `ADON` writer - A/D converter ON / OFF
        pub type ADON_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CONT` reader - Continuous conversion
        pub type CONT_R = crate::BitReader;
        ///Field `CONT` writer - Continuous conversion
        pub type CONT_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CAL` reader - A/D calibration
        pub type CAL_R = crate::BitReader;
        ///Field `CAL` writer - A/D calibration
        pub type CAL_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `RSTCAL` reader - Reset calibration
        pub type RSTCAL_R = crate::BitReader;
        ///Field `RSTCAL` writer - Reset calibration
        pub type RSTCAL_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `DMA` reader - Direct memory access mode
        pub type DMA_R = crate::BitReader;
        ///Field `DMA` writer - Direct memory access mode
        pub type DMA_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `ALIGN` reader - Data alignment
        pub type ALIGN_R = crate::BitReader;
        ///Field `ALIGN` writer - Data alignment
        pub type ALIGN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `JEXTSEL` reader - External event select for injected group
        pub type JEXTSEL_R = crate::FieldReader;
        ///Field `JEXTSEL` writer - External event select for injected group
        pub type JEXTSEL_W<'a, REG> = crate::FieldWriter<'a, REG, 3>;
        ///Field `JEXTTRIG` reader - External trigger conversion mode for injected channels
        pub type JEXTTRIG_R = crate::BitReader;
        ///Field `JEXTTRIG` writer - External trigger conversion mode for injected channels
        pub type JEXTTRIG_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `EXTSEL` reader - External event select for regular group
        pub type EXTSEL_R = crate::FieldReader;
        ///Field `EXTSEL` writer - External event select for regular group
        pub type EXTSEL_W<'a, REG> = crate::FieldWriter<'a, REG, 3>;
        ///Field `EXTTRIG` reader - External trigger conversion mode for regular channels
        pub type EXTTRIG_R = crate::BitReader;
        ///Field `EXTTRIG` writer - External trigger conversion mode for regular channels
        pub type EXTTRIG_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `JSWSTART` reader - Start conversion of injected channels
        pub type JSWSTART_R = crate::BitReader;
        ///Field `JSWSTART` writer - Start conversion of injected channels
        pub type JSWSTART_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `RSWSTART` reader - Start conversion of regular channels
        pub type RSWSTART_R = crate::BitReader;
        ///Field `RSWSTART` writer - Start conversion of regular channels
        pub type RSWSTART_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TSVREFE` reader - Temperature sensor and VREFINT enable
        pub type TSVREFE_R = crate::BitReader;
        ///Field `TSVREFE` writer - Temperature sensor and VREFINT enable
        pub type TSVREFE_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - A/D converter ON / OFF
            #[inline(always)]
            pub fn adon(&self) -> ADON_R {
                ADON_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Continuous conversion
            #[inline(always)]
            pub fn cont(&self) -> CONT_R {
                CONT_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - A/D calibration
            #[inline(always)]
            pub fn cal(&self) -> CAL_R {
                CAL_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - Reset calibration
            #[inline(always)]
            pub fn rstcal(&self) -> RSTCAL_R {
                RSTCAL_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 8 - Direct memory access mode
            #[inline(always)]
            pub fn dma(&self) -> DMA_R {
                DMA_R::new(((self.bits >> 8) & 1) != 0)
            }
            ///Bit 11 - Data alignment
            #[inline(always)]
            pub fn align(&self) -> ALIGN_R {
                ALIGN_R::new(((self.bits >> 11) & 1) != 0)
            }
            ///Bits 12:14 - External event select for injected group
            #[inline(always)]
            pub fn jextsel(&self) -> JEXTSEL_R {
                JEXTSEL_R::new(((self.bits >> 12) & 7) as u8)
            }
            ///Bit 15 - External trigger conversion mode for injected channels
            #[inline(always)]
            pub fn jexttrig(&self) -> JEXTTRIG_R {
                JEXTTRIG_R::new(((self.bits >> 15) & 1) != 0)
            }
            ///Bits 17:19 - External event select for regular group
            #[inline(always)]
            pub fn extsel(&self) -> EXTSEL_R {
                EXTSEL_R::new(((self.bits >> 17) & 7) as u8)
            }
            ///Bit 20 - External trigger conversion mode for regular channels
            #[inline(always)]
            pub fn exttrig(&self) -> EXTTRIG_R {
                EXTTRIG_R::new(((self.bits >> 20) & 1) != 0)
            }
            ///Bit 21 - Start conversion of injected channels
            #[inline(always)]
            pub fn jswstart(&self) -> JSWSTART_R {
                JSWSTART_R::new(((self.bits >> 21) & 1) != 0)
            }
            ///Bit 22 - Start conversion of regular channels
            #[inline(always)]
            pub fn rswstart(&self) -> RSWSTART_R {
                RSWSTART_R::new(((self.bits >> 22) & 1) != 0)
            }
            ///Bit 23 - Temperature sensor and VREFINT enable
            #[inline(always)]
            pub fn tsvrefe(&self) -> TSVREFE_R {
                TSVREFE_R::new(((self.bits >> 23) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - A/D converter ON / OFF
            #[inline(always)]
            #[must_use]
            pub fn adon(&mut self) -> ADON_W<CTLR2_SPEC> {
                ADON_W::new(self, 0)
            }
            ///Bit 1 - Continuous conversion
            #[inline(always)]
            #[must_use]
            pub fn cont(&mut self) -> CONT_W<CTLR2_SPEC> {
                CONT_W::new(self, 1)
            }
            ///Bit 2 - A/D calibration
            #[inline(always)]
            #[must_use]
            pub fn cal(&mut self) -> CAL_W<CTLR2_SPEC> {
                CAL_W::new(self, 2)
            }
            ///Bit 3 - Reset calibration
            #[inline(always)]
            #[must_use]
            pub fn rstcal(&mut self) -> RSTCAL_W<CTLR2_SPEC> {
                RSTCAL_W::new(self, 3)
            }
            ///Bit 8 - Direct memory access mode
            #[inline(always)]
            #[must_use]
            pub fn dma(&mut self) -> DMA_W<CTLR2_SPEC> {
                DMA_W::new(self, 8)
            }
            ///Bit 11 - Data alignment
            #[inline(always)]
            #[must_use]
            pub fn align(&mut self) -> ALIGN_W<CTLR2_SPEC> {
                ALIGN_W::new(self, 11)
            }
            ///Bits 12:14 - External event select for injected group
            #[inline(always)]
            #[must_use]
            pub fn jextsel(&mut self) -> JEXTSEL_W<CTLR2_SPEC> {
                JEXTSEL_W::new(self, 12)
            }
            ///Bit 15 - External trigger conversion mode for injected channels
            #[inline(always)]
            #[must_use]
            pub fn jexttrig(&mut self) -> JEXTTRIG_W<CTLR2_SPEC> {
                JEXTTRIG_W::new(self, 15)
            }
            ///Bits 17:19 - External event select for regular group
            #[inline(always)]
            #[must_use]
            pub fn extsel(&mut self) -> EXTSEL_W<CTLR2_SPEC> {
                EXTSEL_W::new(self, 17)
            }
            ///Bit 20 - External trigger conversion mode for regular channels
            #[inline(always)]
            #[must_use]
            pub fn exttrig(&mut self) -> EXTTRIG_W<CTLR2_SPEC> {
                EXTTRIG_W::new(self, 20)
            }
            ///Bit 21 - Start conversion of injected channels
            #[inline(always)]
            #[must_use]
            pub fn jswstart(&mut self) -> JSWSTART_W<CTLR2_SPEC> {
                JSWSTART_W::new(self, 21)
            }
            ///Bit 22 - Start conversion of regular channels
            #[inline(always)]
            #[must_use]
            pub fn rswstart(&mut self) -> RSWSTART_W<CTLR2_SPEC> {
                RSWSTART_W::new(self, 22)
            }
            ///Bit 23 - Temperature sensor and VREFINT enable
            #[inline(always)]
            #[must_use]
            pub fn tsvrefe(&mut self) -> TSVREFE_W<CTLR2_SPEC> {
                TSVREFE_W::new(self, 23)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///control register 2
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`ctlr2::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ctlr2::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct CTLR2_SPEC;
        impl crate::RegisterSpec for CTLR2_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`ctlr2::R`](R) reader structure
        impl crate::Readable for CTLR2_SPEC {}
        ///`write(|w| ..)` method takes [`ctlr2::W`](W) writer structure
        impl crate::Writable for CTLR2_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets CTLR2 to value 0
        impl crate::Resettable for CTLR2_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///SAMPTR1_CHARGE1 (rw) register accessor: sample time register 1
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`samptr1_charge1::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`samptr1_charge1::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@samptr1_charge1`]
    ///module
    pub type SAMPTR1_CHARGE1 = crate::Reg<samptr1_charge1::SAMPTR1_CHARGE1_SPEC>;
    ///sample time register 1
    pub mod samptr1_charge1 {
        ///Register `SAMPTR1_CHARGE1` reader
        pub type R = crate::R<SAMPTR1_CHARGE1_SPEC>;
        ///Register `SAMPTR1_CHARGE1` writer
        pub type W = crate::W<SAMPTR1_CHARGE1_SPEC>;
        ///Field `SMP16_TKCG16` reader - Channel 16 sample time selection
        pub type SMP16_TKCG16_R = crate::FieldReader;
        ///Field `SMP16_TKCG16` writer - Channel 16 sample time selection
        pub type SMP16_TKCG16_W<'a, REG> = crate::FieldWriter<'a, REG, 3>;
        ///Field `SMP17_TKCG17` reader - Channel 17 sample time selection
        pub type SMP17_TKCG17_R = crate::FieldReader;
        ///Field `SMP17_TKCG17` writer - Channel 17 sample time selection
        pub type SMP17_TKCG17_W<'a, REG> = crate::FieldWriter<'a, REG, 3>;
        impl R {
            ///Bits 18:20 - Channel 16 sample time selection
            #[inline(always)]
            pub fn smp16_tkcg16(&self) -> SMP16_TKCG16_R {
                SMP16_TKCG16_R::new(((self.bits >> 18) & 7) as u8)
            }
            ///Bits 21:23 - Channel 17 sample time selection
            #[inline(always)]
            pub fn smp17_tkcg17(&self) -> SMP17_TKCG17_R {
                SMP17_TKCG17_R::new(((self.bits >> 21) & 7) as u8)
            }
        }
        impl W {
            ///Bits 18:20 - Channel 16 sample time selection
            #[inline(always)]
            #[must_use]
            pub fn smp16_tkcg16(&mut self) -> SMP16_TKCG16_W<SAMPTR1_CHARGE1_SPEC> {
                SMP16_TKCG16_W::new(self, 18)
            }
            ///Bits 21:23 - Channel 17 sample time selection
            #[inline(always)]
            #[must_use]
            pub fn smp17_tkcg17(&mut self) -> SMP17_TKCG17_W<SAMPTR1_CHARGE1_SPEC> {
                SMP17_TKCG17_W::new(self, 21)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///sample time register 1
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`samptr1_charge1::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`samptr1_charge1::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct SAMPTR1_CHARGE1_SPEC;
        impl crate::RegisterSpec for SAMPTR1_CHARGE1_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`samptr1_charge1::R`](R) reader structure
        impl crate::Readable for SAMPTR1_CHARGE1_SPEC {}
        ///`write(|w| ..)` method takes [`samptr1_charge1::W`](W) writer structure
        impl crate::Writable for SAMPTR1_CHARGE1_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets SAMPTR1_CHARGE1 to value 0
        impl crate::Resettable for SAMPTR1_CHARGE1_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///SAMPTR2_CHARGE2 (rw) register accessor: sample time register 2
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`samptr2_charge2::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`samptr2_charge2::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@samptr2_charge2`]
    ///module
    pub type SAMPTR2_CHARGE2 = crate::Reg<samptr2_charge2::SAMPTR2_CHARGE2_SPEC>;
    ///sample time register 2
    pub mod samptr2_charge2 {
        ///Register `SAMPTR2_CHARGE2` reader
        pub type R = crate::R<SAMPTR2_CHARGE2_SPEC>;
        ///Register `SAMPTR2_CHARGE2` writer
        pub type W = crate::W<SAMPTR2_CHARGE2_SPEC>;
        ///Field `SMP0_TKCG0` reader - Channel 0 sample time selection
        pub type SMP0_TKCG0_R = crate::FieldReader;
        ///Field `SMP0_TKCG0` writer - Channel 0 sample time selection
        pub type SMP0_TKCG0_W<'a, REG> = crate::FieldWriter<'a, REG, 3>;
        ///Field `SMP1_TKCG1` reader - Channel 1 sample time selection
        pub type SMP1_TKCG1_R = crate::FieldReader;
        ///Field `SMP1_TKCG1` writer - Channel 1 sample time selection
        pub type SMP1_TKCG1_W<'a, REG> = crate::FieldWriter<'a, REG, 3>;
        ///Field `SMP2_TKCG2` reader - Channel 2 sample time selection
        pub type SMP2_TKCG2_R = crate::FieldReader;
        ///Field `SMP2_TKCG2` writer - Channel 2 sample time selection
        pub type SMP2_TKCG2_W<'a, REG> = crate::FieldWriter<'a, REG, 3>;
        ///Field `SMP3_TKCG3` reader - Channel 3 sample time selection
        pub type SMP3_TKCG3_R = crate::FieldReader;
        ///Field `SMP3_TKCG3` writer - Channel 3 sample time selection
        pub type SMP3_TKCG3_W<'a, REG> = crate::FieldWriter<'a, REG, 3>;
        ///Field `SMP4_TKCG4` reader - Channel 4 sample time selection
        pub type SMP4_TKCG4_R = crate::FieldReader;
        ///Field `SMP4_TKCG4` writer - Channel 4 sample time selection
        pub type SMP4_TKCG4_W<'a, REG> = crate::FieldWriter<'a, REG, 3>;
        ///Field `SMP5_TKCG5` reader - Channel 5 sample time selection
        pub type SMP5_TKCG5_R = crate::FieldReader;
        ///Field `SMP5_TKCG5` writer - Channel 5 sample time selection
        pub type SMP5_TKCG5_W<'a, REG> = crate::FieldWriter<'a, REG, 3>;
        ///Field `SMP6_TKCG6` reader - Channel 6 sample time selection
        pub type SMP6_TKCG6_R = crate::FieldReader;
        ///Field `SMP6_TKCG6` writer - Channel 6 sample time selection
        pub type SMP6_TKCG6_W<'a, REG> = crate::FieldWriter<'a, REG, 3>;
        ///Field `SMP7_TKCG7` reader - Channel 7 sample time selection
        pub type SMP7_TKCG7_R = crate::FieldReader;
        ///Field `SMP7_TKCG7` writer - Channel 7 sample time selection
        pub type SMP7_TKCG7_W<'a, REG> = crate::FieldWriter<'a, REG, 3>;
        ///Field `SMP8_TKCG8` reader - Channel 8 sample time selection
        pub type SMP8_TKCG8_R = crate::FieldReader;
        ///Field `SMP8_TKCG8` writer - Channel 8 sample time selection
        pub type SMP8_TKCG8_W<'a, REG> = crate::FieldWriter<'a, REG, 3>;
        ///Field `SMP9_TKCG9` reader - Channel 9 sample time selection
        pub type SMP9_TKCG9_R = crate::FieldReader;
        ///Field `SMP9_TKCG9` writer - Channel 9 sample time selection
        pub type SMP9_TKCG9_W<'a, REG> = crate::FieldWriter<'a, REG, 3>;
        impl R {
            ///Bits 0:2 - Channel 0 sample time selection
            #[inline(always)]
            pub fn smp0_tkcg0(&self) -> SMP0_TKCG0_R {
                SMP0_TKCG0_R::new((self.bits & 7) as u8)
            }
            ///Bits 3:5 - Channel 1 sample time selection
            #[inline(always)]
            pub fn smp1_tkcg1(&self) -> SMP1_TKCG1_R {
                SMP1_TKCG1_R::new(((self.bits >> 3) & 7) as u8)
            }
            ///Bits 6:8 - Channel 2 sample time selection
            #[inline(always)]
            pub fn smp2_tkcg2(&self) -> SMP2_TKCG2_R {
                SMP2_TKCG2_R::new(((self.bits >> 6) & 7) as u8)
            }
            ///Bits 9:11 - Channel 3 sample time selection
            #[inline(always)]
            pub fn smp3_tkcg3(&self) -> SMP3_TKCG3_R {
                SMP3_TKCG3_R::new(((self.bits >> 9) & 7) as u8)
            }
            ///Bits 12:14 - Channel 4 sample time selection
            #[inline(always)]
            pub fn smp4_tkcg4(&self) -> SMP4_TKCG4_R {
                SMP4_TKCG4_R::new(((self.bits >> 12) & 7) as u8)
            }
            ///Bits 15:17 - Channel 5 sample time selection
            #[inline(always)]
            pub fn smp5_tkcg5(&self) -> SMP5_TKCG5_R {
                SMP5_TKCG5_R::new(((self.bits >> 15) & 7) as u8)
            }
            ///Bits 18:20 - Channel 6 sample time selection
            #[inline(always)]
            pub fn smp6_tkcg6(&self) -> SMP6_TKCG6_R {
                SMP6_TKCG6_R::new(((self.bits >> 18) & 7) as u8)
            }
            ///Bits 21:23 - Channel 7 sample time selection
            #[inline(always)]
            pub fn smp7_tkcg7(&self) -> SMP7_TKCG7_R {
                SMP7_TKCG7_R::new(((self.bits >> 21) & 7) as u8)
            }
            ///Bits 24:26 - Channel 8 sample time selection
            #[inline(always)]
            pub fn smp8_tkcg8(&self) -> SMP8_TKCG8_R {
                SMP8_TKCG8_R::new(((self.bits >> 24) & 7) as u8)
            }
            ///Bits 27:29 - Channel 9 sample time selection
            #[inline(always)]
            pub fn smp9_tkcg9(&self) -> SMP9_TKCG9_R {
                SMP9_TKCG9_R::new(((self.bits >> 27) & 7) as u8)
            }
        }
        impl W {
            ///Bits 0:2 - Channel 0 sample time selection
            #[inline(always)]
            #[must_use]
            pub fn smp0_tkcg0(&mut self) -> SMP0_TKCG0_W<SAMPTR2_CHARGE2_SPEC> {
                SMP0_TKCG0_W::new(self, 0)
            }
            ///Bits 3:5 - Channel 1 sample time selection
            #[inline(always)]
            #[must_use]
            pub fn smp1_tkcg1(&mut self) -> SMP1_TKCG1_W<SAMPTR2_CHARGE2_SPEC> {
                SMP1_TKCG1_W::new(self, 3)
            }
            ///Bits 6:8 - Channel 2 sample time selection
            #[inline(always)]
            #[must_use]
            pub fn smp2_tkcg2(&mut self) -> SMP2_TKCG2_W<SAMPTR2_CHARGE2_SPEC> {
                SMP2_TKCG2_W::new(self, 6)
            }
            ///Bits 9:11 - Channel 3 sample time selection
            #[inline(always)]
            #[must_use]
            pub fn smp3_tkcg3(&mut self) -> SMP3_TKCG3_W<SAMPTR2_CHARGE2_SPEC> {
                SMP3_TKCG3_W::new(self, 9)
            }
            ///Bits 12:14 - Channel 4 sample time selection
            #[inline(always)]
            #[must_use]
            pub fn smp4_tkcg4(&mut self) -> SMP4_TKCG4_W<SAMPTR2_CHARGE2_SPEC> {
                SMP4_TKCG4_W::new(self, 12)
            }
            ///Bits 15:17 - Channel 5 sample time selection
            #[inline(always)]
            #[must_use]
            pub fn smp5_tkcg5(&mut self) -> SMP5_TKCG5_W<SAMPTR2_CHARGE2_SPEC> {
                SMP5_TKCG5_W::new(self, 15)
            }
            ///Bits 18:20 - Channel 6 sample time selection
            #[inline(always)]
            #[must_use]
            pub fn smp6_tkcg6(&mut self) -> SMP6_TKCG6_W<SAMPTR2_CHARGE2_SPEC> {
                SMP6_TKCG6_W::new(self, 18)
            }
            ///Bits 21:23 - Channel 7 sample time selection
            #[inline(always)]
            #[must_use]
            pub fn smp7_tkcg7(&mut self) -> SMP7_TKCG7_W<SAMPTR2_CHARGE2_SPEC> {
                SMP7_TKCG7_W::new(self, 21)
            }
            ///Bits 24:26 - Channel 8 sample time selection
            #[inline(always)]
            #[must_use]
            pub fn smp8_tkcg8(&mut self) -> SMP8_TKCG8_W<SAMPTR2_CHARGE2_SPEC> {
                SMP8_TKCG8_W::new(self, 24)
            }
            ///Bits 27:29 - Channel 9 sample time selection
            #[inline(always)]
            #[must_use]
            pub fn smp9_tkcg9(&mut self) -> SMP9_TKCG9_W<SAMPTR2_CHARGE2_SPEC> {
                SMP9_TKCG9_W::new(self, 27)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///sample time register 2
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`samptr2_charge2::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`samptr2_charge2::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct SAMPTR2_CHARGE2_SPEC;
        impl crate::RegisterSpec for SAMPTR2_CHARGE2_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`samptr2_charge2::R`](R) reader structure
        impl crate::Readable for SAMPTR2_CHARGE2_SPEC {}
        ///`write(|w| ..)` method takes [`samptr2_charge2::W`](W) writer structure
        impl crate::Writable for SAMPTR2_CHARGE2_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets SAMPTR2_CHARGE2 to value 0
        impl crate::Resettable for SAMPTR2_CHARGE2_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IOFR1 (rw) register accessor: injected channel data offset register x
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iofr1::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iofr1::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iofr1`]
    ///module
    pub type IOFR1 = crate::Reg<iofr1::IOFR1_SPEC>;
    ///injected channel data offset register x
    pub mod iofr1 {
        ///Register `IOFR1` reader
        pub type R = crate::R<IOFR1_SPEC>;
        ///Register `IOFR1` writer
        pub type W = crate::W<IOFR1_SPEC>;
        ///Field `JOFFSET1` reader - Data offset for injected channel x
        pub type JOFFSET1_R = crate::FieldReader<u16>;
        ///Field `JOFFSET1` writer - Data offset for injected channel x
        pub type JOFFSET1_W<'a, REG> = crate::FieldWriter<'a, REG, 12, u16>;
        impl R {
            ///Bits 0:11 - Data offset for injected channel x
            #[inline(always)]
            pub fn joffset1(&self) -> JOFFSET1_R {
                JOFFSET1_R::new((self.bits & 0x0fff) as u16)
            }
        }
        impl W {
            ///Bits 0:11 - Data offset for injected channel x
            #[inline(always)]
            #[must_use]
            pub fn joffset1(&mut self) -> JOFFSET1_W<IOFR1_SPEC> {
                JOFFSET1_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///injected channel data offset register x
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iofr1::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iofr1::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IOFR1_SPEC;
        impl crate::RegisterSpec for IOFR1_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iofr1::R`](R) reader structure
        impl crate::Readable for IOFR1_SPEC {}
        ///`write(|w| ..)` method takes [`iofr1::W`](W) writer structure
        impl crate::Writable for IOFR1_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IOFR1 to value 0
        impl crate::Resettable for IOFR1_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IOFR2 (rw) register accessor: injected channel data offset register x
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iofr2::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iofr2::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iofr2`]
    ///module
    pub type IOFR2 = crate::Reg<iofr2::IOFR2_SPEC>;
    ///injected channel data offset register x
    pub mod iofr2 {
        ///Register `IOFR2` reader
        pub type R = crate::R<IOFR2_SPEC>;
        ///Register `IOFR2` writer
        pub type W = crate::W<IOFR2_SPEC>;
        ///Field `JOFFSET2` reader - Data offset for injected channel x
        pub type JOFFSET2_R = crate::FieldReader<u16>;
        ///Field `JOFFSET2` writer - Data offset for injected channel x
        pub type JOFFSET2_W<'a, REG> = crate::FieldWriter<'a, REG, 12, u16>;
        impl R {
            ///Bits 0:11 - Data offset for injected channel x
            #[inline(always)]
            pub fn joffset2(&self) -> JOFFSET2_R {
                JOFFSET2_R::new((self.bits & 0x0fff) as u16)
            }
        }
        impl W {
            ///Bits 0:11 - Data offset for injected channel x
            #[inline(always)]
            #[must_use]
            pub fn joffset2(&mut self) -> JOFFSET2_W<IOFR2_SPEC> {
                JOFFSET2_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///injected channel data offset register x
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iofr2::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iofr2::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IOFR2_SPEC;
        impl crate::RegisterSpec for IOFR2_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iofr2::R`](R) reader structure
        impl crate::Readable for IOFR2_SPEC {}
        ///`write(|w| ..)` method takes [`iofr2::W`](W) writer structure
        impl crate::Writable for IOFR2_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IOFR2 to value 0
        impl crate::Resettable for IOFR2_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IOFR3 (rw) register accessor: injected channel data offset register x
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iofr3::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iofr3::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iofr3`]
    ///module
    pub type IOFR3 = crate::Reg<iofr3::IOFR3_SPEC>;
    ///injected channel data offset register x
    pub mod iofr3 {
        ///Register `IOFR3` reader
        pub type R = crate::R<IOFR3_SPEC>;
        ///Register `IOFR3` writer
        pub type W = crate::W<IOFR3_SPEC>;
        ///Field `JOFFSET3` reader - Data offset for injected channel x
        pub type JOFFSET3_R = crate::FieldReader<u16>;
        ///Field `JOFFSET3` writer - Data offset for injected channel x
        pub type JOFFSET3_W<'a, REG> = crate::FieldWriter<'a, REG, 12, u16>;
        impl R {
            ///Bits 0:11 - Data offset for injected channel x
            #[inline(always)]
            pub fn joffset3(&self) -> JOFFSET3_R {
                JOFFSET3_R::new((self.bits & 0x0fff) as u16)
            }
        }
        impl W {
            ///Bits 0:11 - Data offset for injected channel x
            #[inline(always)]
            #[must_use]
            pub fn joffset3(&mut self) -> JOFFSET3_W<IOFR3_SPEC> {
                JOFFSET3_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///injected channel data offset register x
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iofr3::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iofr3::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IOFR3_SPEC;
        impl crate::RegisterSpec for IOFR3_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iofr3::R`](R) reader structure
        impl crate::Readable for IOFR3_SPEC {}
        ///`write(|w| ..)` method takes [`iofr3::W`](W) writer structure
        impl crate::Writable for IOFR3_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IOFR3 to value 0
        impl crate::Resettable for IOFR3_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IOFR4 (rw) register accessor: injected channel data offset register x
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iofr4::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iofr4::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iofr4`]
    ///module
    pub type IOFR4 = crate::Reg<iofr4::IOFR4_SPEC>;
    ///injected channel data offset register x
    pub mod iofr4 {
        ///Register `IOFR4` reader
        pub type R = crate::R<IOFR4_SPEC>;
        ///Register `IOFR4` writer
        pub type W = crate::W<IOFR4_SPEC>;
        ///Field `JOFFSET4` reader - Data offset for injected channel x
        pub type JOFFSET4_R = crate::FieldReader<u16>;
        ///Field `JOFFSET4` writer - Data offset for injected channel x
        pub type JOFFSET4_W<'a, REG> = crate::FieldWriter<'a, REG, 12, u16>;
        impl R {
            ///Bits 0:11 - Data offset for injected channel x
            #[inline(always)]
            pub fn joffset4(&self) -> JOFFSET4_R {
                JOFFSET4_R::new((self.bits & 0x0fff) as u16)
            }
        }
        impl W {
            ///Bits 0:11 - Data offset for injected channel x
            #[inline(always)]
            #[must_use]
            pub fn joffset4(&mut self) -> JOFFSET4_W<IOFR4_SPEC> {
                JOFFSET4_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///injected channel data offset register x
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iofr4::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iofr4::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IOFR4_SPEC;
        impl crate::RegisterSpec for IOFR4_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iofr4::R`](R) reader structure
        impl crate::Readable for IOFR4_SPEC {}
        ///`write(|w| ..)` method takes [`iofr4::W`](W) writer structure
        impl crate::Writable for IOFR4_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IOFR4 to value 0
        impl crate::Resettable for IOFR4_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///WDHTR (rw) register accessor: watchdog higher threshold register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`wdhtr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`wdhtr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@wdhtr`]
    ///module
    pub type WDHTR = crate::Reg<wdhtr::WDHTR_SPEC>;
    ///watchdog higher threshold register
    pub mod wdhtr {
        ///Register `WDHTR` reader
        pub type R = crate::R<WDHTR_SPEC>;
        ///Register `WDHTR` writer
        pub type W = crate::W<WDHTR_SPEC>;
        ///Field `HT` reader - Analog watchdog higher threshold
        pub type HT_R = crate::FieldReader<u16>;
        ///Field `HT` writer - Analog watchdog higher threshold
        pub type HT_W<'a, REG> = crate::FieldWriter<'a, REG, 12, u16>;
        impl R {
            ///Bits 0:11 - Analog watchdog higher threshold
            #[inline(always)]
            pub fn ht(&self) -> HT_R {
                HT_R::new((self.bits & 0x0fff) as u16)
            }
        }
        impl W {
            ///Bits 0:11 - Analog watchdog higher threshold
            #[inline(always)]
            #[must_use]
            pub fn ht(&mut self) -> HT_W<WDHTR_SPEC> {
                HT_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///watchdog higher threshold register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`wdhtr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`wdhtr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct WDHTR_SPEC;
        impl crate::RegisterSpec for WDHTR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`wdhtr::R`](R) reader structure
        impl crate::Readable for WDHTR_SPEC {}
        ///`write(|w| ..)` method takes [`wdhtr::W`](W) writer structure
        impl crate::Writable for WDHTR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets WDHTR to value 0
        impl crate::Resettable for WDHTR_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///WDLTR (rw) register accessor: watchdog lower threshold register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`wdltr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`wdltr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@wdltr`]
    ///module
    pub type WDLTR = crate::Reg<wdltr::WDLTR_SPEC>;
    ///watchdog lower threshold register
    pub mod wdltr {
        ///Register `WDLTR` reader
        pub type R = crate::R<WDLTR_SPEC>;
        ///Register `WDLTR` writer
        pub type W = crate::W<WDLTR_SPEC>;
        ///Field `LT` reader - Analog watchdog lower threshold
        pub type LT_R = crate::FieldReader<u16>;
        ///Field `LT` writer - Analog watchdog lower threshold
        pub type LT_W<'a, REG> = crate::FieldWriter<'a, REG, 12, u16>;
        impl R {
            ///Bits 0:11 - Analog watchdog lower threshold
            #[inline(always)]
            pub fn lt(&self) -> LT_R {
                LT_R::new((self.bits & 0x0fff) as u16)
            }
        }
        impl W {
            ///Bits 0:11 - Analog watchdog lower threshold
            #[inline(always)]
            #[must_use]
            pub fn lt(&mut self) -> LT_W<WDLTR_SPEC> {
                LT_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///watchdog lower threshold register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`wdltr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`wdltr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct WDLTR_SPEC;
        impl crate::RegisterSpec for WDLTR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`wdltr::R`](R) reader structure
        impl crate::Readable for WDLTR_SPEC {}
        ///`write(|w| ..)` method takes [`wdltr::W`](W) writer structure
        impl crate::Writable for WDLTR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets WDLTR to value 0
        impl crate::Resettable for WDLTR_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///RSQR1 (rw) register accessor: regular sequence register 1
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`rsqr1::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`rsqr1::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@rsqr1`]
    ///module
    pub type RSQR1 = crate::Reg<rsqr1::RSQR1_SPEC>;
    ///regular sequence register 1
    pub mod rsqr1 {
        ///Register `RSQR1` reader
        pub type R = crate::R<RSQR1_SPEC>;
        ///Register `RSQR1` writer
        pub type W = crate::W<RSQR1_SPEC>;
        ///Field `SQ13` reader - 13th conversion in regular sequence
        pub type SQ13_R = crate::FieldReader;
        ///Field `SQ13` writer - 13th conversion in regular sequence
        pub type SQ13_W<'a, REG> = crate::FieldWriter<'a, REG, 5>;
        ///Field `SQ14` reader - 14th conversion in regular sequence
        pub type SQ14_R = crate::FieldReader;
        ///Field `SQ14` writer - 14th conversion in regular sequence
        pub type SQ14_W<'a, REG> = crate::FieldWriter<'a, REG, 5>;
        ///Field `SQ15` reader - 15th conversion in regular sequence
        pub type SQ15_R = crate::FieldReader;
        ///Field `SQ15` writer - 15th conversion in regular sequence
        pub type SQ15_W<'a, REG> = crate::FieldWriter<'a, REG, 5>;
        ///Field `SQ16` reader - 16th conversion in regular sequence
        pub type SQ16_R = crate::FieldReader;
        ///Field `SQ16` writer - 16th conversion in regular sequence
        pub type SQ16_W<'a, REG> = crate::FieldWriter<'a, REG, 5>;
        ///Field `L` reader - Regular channel sequence length
        pub type L_R = crate::FieldReader;
        ///Field `L` writer - Regular channel sequence length
        pub type L_W<'a, REG> = crate::FieldWriter<'a, REG, 4>;
        impl R {
            ///Bits 0:4 - 13th conversion in regular sequence
            #[inline(always)]
            pub fn sq13(&self) -> SQ13_R {
                SQ13_R::new((self.bits & 0x1f) as u8)
            }
            ///Bits 5:9 - 14th conversion in regular sequence
            #[inline(always)]
            pub fn sq14(&self) -> SQ14_R {
                SQ14_R::new(((self.bits >> 5) & 0x1f) as u8)
            }
            ///Bits 10:14 - 15th conversion in regular sequence
            #[inline(always)]
            pub fn sq15(&self) -> SQ15_R {
                SQ15_R::new(((self.bits >> 10) & 0x1f) as u8)
            }
            ///Bits 15:19 - 16th conversion in regular sequence
            #[inline(always)]
            pub fn sq16(&self) -> SQ16_R {
                SQ16_R::new(((self.bits >> 15) & 0x1f) as u8)
            }
            ///Bits 20:23 - Regular channel sequence length
            #[inline(always)]
            pub fn l(&self) -> L_R {
                L_R::new(((self.bits >> 20) & 0x0f) as u8)
            }
        }
        impl W {
            ///Bits 0:4 - 13th conversion in regular sequence
            #[inline(always)]
            #[must_use]
            pub fn sq13(&mut self) -> SQ13_W<RSQR1_SPEC> {
                SQ13_W::new(self, 0)
            }
            ///Bits 5:9 - 14th conversion in regular sequence
            #[inline(always)]
            #[must_use]
            pub fn sq14(&mut self) -> SQ14_W<RSQR1_SPEC> {
                SQ14_W::new(self, 5)
            }
            ///Bits 10:14 - 15th conversion in regular sequence
            #[inline(always)]
            #[must_use]
            pub fn sq15(&mut self) -> SQ15_W<RSQR1_SPEC> {
                SQ15_W::new(self, 10)
            }
            ///Bits 15:19 - 16th conversion in regular sequence
            #[inline(always)]
            #[must_use]
            pub fn sq16(&mut self) -> SQ16_W<RSQR1_SPEC> {
                SQ16_W::new(self, 15)
            }
            ///Bits 20:23 - Regular channel sequence length
            #[inline(always)]
            #[must_use]
            pub fn l(&mut self) -> L_W<RSQR1_SPEC> {
                L_W::new(self, 20)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///regular sequence register 1
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`rsqr1::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`rsqr1::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct RSQR1_SPEC;
        impl crate::RegisterSpec for RSQR1_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`rsqr1::R`](R) reader structure
        impl crate::Readable for RSQR1_SPEC {}
        ///`write(|w| ..)` method takes [`rsqr1::W`](W) writer structure
        impl crate::Writable for RSQR1_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets RSQR1 to value 0
        impl crate::Resettable for RSQR1_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///RSQR2 (rw) register accessor: regular sequence register 2
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`rsqr2::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`rsqr2::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@rsqr2`]
    ///module
    pub type RSQR2 = crate::Reg<rsqr2::RSQR2_SPEC>;
    ///regular sequence register 2
    pub mod rsqr2 {
        ///Register `RSQR2` reader
        pub type R = crate::R<RSQR2_SPEC>;
        ///Register `RSQR2` writer
        pub type W = crate::W<RSQR2_SPEC>;
        ///Field `SQ7` reader - 7th conversion in regular sequence
        pub type SQ7_R = crate::FieldReader;
        ///Field `SQ7` writer - 7th conversion in regular sequence
        pub type SQ7_W<'a, REG> = crate::FieldWriter<'a, REG, 5>;
        ///Field `SQ8` reader - 8th conversion in regular sequence
        pub type SQ8_R = crate::FieldReader;
        ///Field `SQ8` writer - 8th conversion in regular sequence
        pub type SQ8_W<'a, REG> = crate::FieldWriter<'a, REG, 5>;
        ///Field `SQ9` reader - 9th conversion in regular sequence
        pub type SQ9_R = crate::FieldReader;
        ///Field `SQ9` writer - 9th conversion in regular sequence
        pub type SQ9_W<'a, REG> = crate::FieldWriter<'a, REG, 5>;
        ///Field `SQ10` reader - 10th conversion in regular sequence
        pub type SQ10_R = crate::FieldReader;
        ///Field `SQ10` writer - 10th conversion in regular sequence
        pub type SQ10_W<'a, REG> = crate::FieldWriter<'a, REG, 5>;
        ///Field `SQ11` reader - 11th conversion in regular sequence
        pub type SQ11_R = crate::FieldReader;
        ///Field `SQ11` writer - 11th conversion in regular sequence
        pub type SQ11_W<'a, REG> = crate::FieldWriter<'a, REG, 5>;
        ///Field `SQ12` reader - 12th conversion in regular sequence
        pub type SQ12_R = crate::FieldReader;
        ///Field `SQ12` writer - 12th conversion in regular sequence
        pub type SQ12_W<'a, REG> = crate::FieldWriter<'a, REG, 5>;
        impl R {
            ///Bits 0:4 - 7th conversion in regular sequence
            #[inline(always)]
            pub fn sq7(&self) -> SQ7_R {
                SQ7_R::new((self.bits & 0x1f) as u8)
            }
            ///Bits 5:9 - 8th conversion in regular sequence
            #[inline(always)]
            pub fn sq8(&self) -> SQ8_R {
                SQ8_R::new(((self.bits >> 5) & 0x1f) as u8)
            }
            ///Bits 10:14 - 9th conversion in regular sequence
            #[inline(always)]
            pub fn sq9(&self) -> SQ9_R {
                SQ9_R::new(((self.bits >> 10) & 0x1f) as u8)
            }
            ///Bits 15:19 - 10th conversion in regular sequence
            #[inline(always)]
            pub fn sq10(&self) -> SQ10_R {
                SQ10_R::new(((self.bits >> 15) & 0x1f) as u8)
            }
            ///Bits 20:24 - 11th conversion in regular sequence
            #[inline(always)]
            pub fn sq11(&self) -> SQ11_R {
                SQ11_R::new(((self.bits >> 20) & 0x1f) as u8)
            }
            ///Bits 25:29 - 12th conversion in regular sequence
            #[inline(always)]
            pub fn sq12(&self) -> SQ12_R {
                SQ12_R::new(((self.bits >> 25) & 0x1f) as u8)
            }
        }
        impl W {
            ///Bits 0:4 - 7th conversion in regular sequence
            #[inline(always)]
            #[must_use]
            pub fn sq7(&mut self) -> SQ7_W<RSQR2_SPEC> {
                SQ7_W::new(self, 0)
            }
            ///Bits 5:9 - 8th conversion in regular sequence
            #[inline(always)]
            #[must_use]
            pub fn sq8(&mut self) -> SQ8_W<RSQR2_SPEC> {
                SQ8_W::new(self, 5)
            }
            ///Bits 10:14 - 9th conversion in regular sequence
            #[inline(always)]
            #[must_use]
            pub fn sq9(&mut self) -> SQ9_W<RSQR2_SPEC> {
                SQ9_W::new(self, 10)
            }
            ///Bits 15:19 - 10th conversion in regular sequence
            #[inline(always)]
            #[must_use]
            pub fn sq10(&mut self) -> SQ10_W<RSQR2_SPEC> {
                SQ10_W::new(self, 15)
            }
            ///Bits 20:24 - 11th conversion in regular sequence
            #[inline(always)]
            #[must_use]
            pub fn sq11(&mut self) -> SQ11_W<RSQR2_SPEC> {
                SQ11_W::new(self, 20)
            }
            ///Bits 25:29 - 12th conversion in regular sequence
            #[inline(always)]
            #[must_use]
            pub fn sq12(&mut self) -> SQ12_W<RSQR2_SPEC> {
                SQ12_W::new(self, 25)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///regular sequence register 2
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`rsqr2::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`rsqr2::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct RSQR2_SPEC;
        impl crate::RegisterSpec for RSQR2_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`rsqr2::R`](R) reader structure
        impl crate::Readable for RSQR2_SPEC {}
        ///`write(|w| ..)` method takes [`rsqr2::W`](W) writer structure
        impl crate::Writable for RSQR2_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets RSQR2 to value 0
        impl crate::Resettable for RSQR2_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///RSQR3 (rw) register accessor: regular sequence register 3
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`rsqr3::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`rsqr3::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@rsqr3`]
    ///module
    pub type RSQR3 = crate::Reg<rsqr3::RSQR3_SPEC>;
    ///regular sequence register 3
    pub mod rsqr3 {
        ///Register `RSQR3` reader
        pub type R = crate::R<RSQR3_SPEC>;
        ///Register `RSQR3` writer
        pub type W = crate::W<RSQR3_SPEC>;
        ///Field `SQ1` reader - 1st conversion in regular sequence
        pub type SQ1_R = crate::FieldReader;
        ///Field `SQ1` writer - 1st conversion in regular sequence
        pub type SQ1_W<'a, REG> = crate::FieldWriter<'a, REG, 5>;
        ///Field `SQ2` reader - 2nd conversion in regular sequence
        pub type SQ2_R = crate::FieldReader;
        ///Field `SQ2` writer - 2nd conversion in regular sequence
        pub type SQ2_W<'a, REG> = crate::FieldWriter<'a, REG, 5>;
        ///Field `SQ3` reader - 3rd conversion in regular sequence
        pub type SQ3_R = crate::FieldReader;
        ///Field `SQ3` writer - 3rd conversion in regular sequence
        pub type SQ3_W<'a, REG> = crate::FieldWriter<'a, REG, 5>;
        ///Field `SQ4` reader - 4th conversion in regular sequence
        pub type SQ4_R = crate::FieldReader;
        ///Field `SQ4` writer - 4th conversion in regular sequence
        pub type SQ4_W<'a, REG> = crate::FieldWriter<'a, REG, 5>;
        ///Field `SQ5` reader - 5th conversion in regular sequence
        pub type SQ5_R = crate::FieldReader;
        ///Field `SQ5` writer - 5th conversion in regular sequence
        pub type SQ5_W<'a, REG> = crate::FieldWriter<'a, REG, 5>;
        ///Field `SQ6` reader - 6th conversion in regular sequence
        pub type SQ6_R = crate::FieldReader;
        ///Field `SQ6` writer - 6th conversion in regular sequence
        pub type SQ6_W<'a, REG> = crate::FieldWriter<'a, REG, 5>;
        impl R {
            ///Bits 0:4 - 1st conversion in regular sequence
            #[inline(always)]
            pub fn sq1(&self) -> SQ1_R {
                SQ1_R::new((self.bits & 0x1f) as u8)
            }
            ///Bits 5:9 - 2nd conversion in regular sequence
            #[inline(always)]
            pub fn sq2(&self) -> SQ2_R {
                SQ2_R::new(((self.bits >> 5) & 0x1f) as u8)
            }
            ///Bits 10:14 - 3rd conversion in regular sequence
            #[inline(always)]
            pub fn sq3(&self) -> SQ3_R {
                SQ3_R::new(((self.bits >> 10) & 0x1f) as u8)
            }
            ///Bits 15:19 - 4th conversion in regular sequence
            #[inline(always)]
            pub fn sq4(&self) -> SQ4_R {
                SQ4_R::new(((self.bits >> 15) & 0x1f) as u8)
            }
            ///Bits 20:24 - 5th conversion in regular sequence
            #[inline(always)]
            pub fn sq5(&self) -> SQ5_R {
                SQ5_R::new(((self.bits >> 20) & 0x1f) as u8)
            }
            ///Bits 25:29 - 6th conversion in regular sequence
            #[inline(always)]
            pub fn sq6(&self) -> SQ6_R {
                SQ6_R::new(((self.bits >> 25) & 0x1f) as u8)
            }
        }
        impl W {
            ///Bits 0:4 - 1st conversion in regular sequence
            #[inline(always)]
            #[must_use]
            pub fn sq1(&mut self) -> SQ1_W<RSQR3_SPEC> {
                SQ1_W::new(self, 0)
            }
            ///Bits 5:9 - 2nd conversion in regular sequence
            #[inline(always)]
            #[must_use]
            pub fn sq2(&mut self) -> SQ2_W<RSQR3_SPEC> {
                SQ2_W::new(self, 5)
            }
            ///Bits 10:14 - 3rd conversion in regular sequence
            #[inline(always)]
            #[must_use]
            pub fn sq3(&mut self) -> SQ3_W<RSQR3_SPEC> {
                SQ3_W::new(self, 10)
            }
            ///Bits 15:19 - 4th conversion in regular sequence
            #[inline(always)]
            #[must_use]
            pub fn sq4(&mut self) -> SQ4_W<RSQR3_SPEC> {
                SQ4_W::new(self, 15)
            }
            ///Bits 20:24 - 5th conversion in regular sequence
            #[inline(always)]
            #[must_use]
            pub fn sq5(&mut self) -> SQ5_W<RSQR3_SPEC> {
                SQ5_W::new(self, 20)
            }
            ///Bits 25:29 - 6th conversion in regular sequence
            #[inline(always)]
            #[must_use]
            pub fn sq6(&mut self) -> SQ6_W<RSQR3_SPEC> {
                SQ6_W::new(self, 25)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///regular sequence register 3
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`rsqr3::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`rsqr3::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct RSQR3_SPEC;
        impl crate::RegisterSpec for RSQR3_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`rsqr3::R`](R) reader structure
        impl crate::Readable for RSQR3_SPEC {}
        ///`write(|w| ..)` method takes [`rsqr3::W`](W) writer structure
        impl crate::Writable for RSQR3_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets RSQR3 to value 0
        impl crate::Resettable for RSQR3_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///ISQR (rw) register accessor: injected sequence register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`isqr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`isqr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@isqr`]
    ///module
    pub type ISQR = crate::Reg<isqr::ISQR_SPEC>;
    ///injected sequence register
    pub mod isqr {
        ///Register `ISQR` reader
        pub type R = crate::R<ISQR_SPEC>;
        ///Register `ISQR` writer
        pub type W = crate::W<ISQR_SPEC>;
        ///Field `JSQ1` reader - 1st conversion in injected sequence
        pub type JSQ1_R = crate::FieldReader;
        ///Field `JSQ1` writer - 1st conversion in injected sequence
        pub type JSQ1_W<'a, REG> = crate::FieldWriter<'a, REG, 5>;
        ///Field `JSQ2` reader - 2nd conversion in injected sequence
        pub type JSQ2_R = crate::FieldReader;
        ///Field `JSQ2` writer - 2nd conversion in injected sequence
        pub type JSQ2_W<'a, REG> = crate::FieldWriter<'a, REG, 5>;
        ///Field `JSQ3` reader - 3rd conversion in injected sequence
        pub type JSQ3_R = crate::FieldReader;
        ///Field `JSQ3` writer - 3rd conversion in injected sequence
        pub type JSQ3_W<'a, REG> = crate::FieldWriter<'a, REG, 5>;
        ///Field `JSQ4` reader - 4th conversion in injected sequence
        pub type JSQ4_R = crate::FieldReader;
        ///Field `JSQ4` writer - 4th conversion in injected sequence
        pub type JSQ4_W<'a, REG> = crate::FieldWriter<'a, REG, 5>;
        ///Field `JL` reader - Injected sequence length
        pub type JL_R = crate::FieldReader;
        ///Field `JL` writer - Injected sequence length
        pub type JL_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        impl R {
            ///Bits 0:4 - 1st conversion in injected sequence
            #[inline(always)]
            pub fn jsq1(&self) -> JSQ1_R {
                JSQ1_R::new((self.bits & 0x1f) as u8)
            }
            ///Bits 5:9 - 2nd conversion in injected sequence
            #[inline(always)]
            pub fn jsq2(&self) -> JSQ2_R {
                JSQ2_R::new(((self.bits >> 5) & 0x1f) as u8)
            }
            ///Bits 10:14 - 3rd conversion in injected sequence
            #[inline(always)]
            pub fn jsq3(&self) -> JSQ3_R {
                JSQ3_R::new(((self.bits >> 10) & 0x1f) as u8)
            }
            ///Bits 15:19 - 4th conversion in injected sequence
            #[inline(always)]
            pub fn jsq4(&self) -> JSQ4_R {
                JSQ4_R::new(((self.bits >> 15) & 0x1f) as u8)
            }
            ///Bits 20:21 - Injected sequence length
            #[inline(always)]
            pub fn jl(&self) -> JL_R {
                JL_R::new(((self.bits >> 20) & 3) as u8)
            }
        }
        impl W {
            ///Bits 0:4 - 1st conversion in injected sequence
            #[inline(always)]
            #[must_use]
            pub fn jsq1(&mut self) -> JSQ1_W<ISQR_SPEC> {
                JSQ1_W::new(self, 0)
            }
            ///Bits 5:9 - 2nd conversion in injected sequence
            #[inline(always)]
            #[must_use]
            pub fn jsq2(&mut self) -> JSQ2_W<ISQR_SPEC> {
                JSQ2_W::new(self, 5)
            }
            ///Bits 10:14 - 3rd conversion in injected sequence
            #[inline(always)]
            #[must_use]
            pub fn jsq3(&mut self) -> JSQ3_W<ISQR_SPEC> {
                JSQ3_W::new(self, 10)
            }
            ///Bits 15:19 - 4th conversion in injected sequence
            #[inline(always)]
            #[must_use]
            pub fn jsq4(&mut self) -> JSQ4_W<ISQR_SPEC> {
                JSQ4_W::new(self, 15)
            }
            ///Bits 20:21 - Injected sequence length
            #[inline(always)]
            #[must_use]
            pub fn jl(&mut self) -> JL_W<ISQR_SPEC> {
                JL_W::new(self, 20)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///injected sequence register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`isqr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`isqr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct ISQR_SPEC;
        impl crate::RegisterSpec for ISQR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`isqr::R`](R) reader structure
        impl crate::Readable for ISQR_SPEC {}
        ///`write(|w| ..)` method takes [`isqr::W`](W) writer structure
        impl crate::Writable for ISQR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets ISQR to value 0
        impl crate::Resettable for ISQR_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IDATAR1_CHGOFFSET (r) register accessor: injected data register 1
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`idatar1_chgoffset::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@idatar1_chgoffset`]
    ///module
    pub type IDATAR1_CHGOFFSET = crate::Reg<idatar1_chgoffset::IDATAR1_CHGOFFSET_SPEC>;
    ///injected data register 1
    pub mod idatar1_chgoffset {
        ///Register `IDATAR1_CHGOFFSET` reader
        pub type R = crate::R<IDATAR1_CHGOFFSET_SPEC>;
        ///Field `IDATA0_7_TKCGOFFSET` reader - Injected data_Touch key charge data offset for injected channel x
        pub type IDATA0_7_TKCGOFFSET_R = crate::FieldReader;
        ///Field `IDATA8_15` reader - Injected data
        pub type IDATA8_15_R = crate::FieldReader;
        impl R {
            ///Bits 0:7 - Injected data_Touch key charge data offset for injected channel x
            #[inline(always)]
            pub fn idata0_7_tkcgoffset(&self) -> IDATA0_7_TKCGOFFSET_R {
                IDATA0_7_TKCGOFFSET_R::new((self.bits & 0xff) as u8)
            }
            ///Bits 8:15 - Injected data
            #[inline(always)]
            pub fn idata8_15(&self) -> IDATA8_15_R {
                IDATA8_15_R::new(((self.bits >> 8) & 0xff) as u8)
            }
        }
        ///injected data register 1
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`idatar1_chgoffset::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IDATAR1_CHGOFFSET_SPEC;
        impl crate::RegisterSpec for IDATAR1_CHGOFFSET_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`idatar1_chgoffset::R`](R) reader structure
        impl crate::Readable for IDATAR1_CHGOFFSET_SPEC {}
        ///`reset()` method sets IDATAR1_CHGOFFSET to value 0
        impl crate::Resettable for IDATAR1_CHGOFFSET_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IDATAR2 (r) register accessor: injected data register 2
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`idatar2::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@idatar2`]
    ///module
    pub type IDATAR2 = crate::Reg<idatar2::IDATAR2_SPEC>;
    ///injected data register 2
    pub mod idatar2 {
        ///Register `IDATAR2` reader
        pub type R = crate::R<IDATAR2_SPEC>;
        ///Field `JDATA` reader - Injected data
        pub type JDATA_R = crate::FieldReader<u16>;
        impl R {
            ///Bits 0:15 - Injected data
            #[inline(always)]
            pub fn jdata(&self) -> JDATA_R {
                JDATA_R::new((self.bits & 0xffff) as u16)
            }
        }
        ///injected data register 2
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`idatar2::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IDATAR2_SPEC;
        impl crate::RegisterSpec for IDATAR2_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`idatar2::R`](R) reader structure
        impl crate::Readable for IDATAR2_SPEC {}
        ///`reset()` method sets IDATAR2 to value 0
        impl crate::Resettable for IDATAR2_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IDATAR3 (r) register accessor: injected data register 3
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`idatar3::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@idatar3`]
    ///module
    pub type IDATAR3 = crate::Reg<idatar3::IDATAR3_SPEC>;
    ///injected data register 3
    pub mod idatar3 {
        ///Register `IDATAR3` reader
        pub type R = crate::R<IDATAR3_SPEC>;
        ///Field `JDATA` reader - Injected data
        pub type JDATA_R = crate::FieldReader<u16>;
        impl R {
            ///Bits 0:15 - Injected data
            #[inline(always)]
            pub fn jdata(&self) -> JDATA_R {
                JDATA_R::new((self.bits & 0xffff) as u16)
            }
        }
        ///injected data register 3
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`idatar3::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IDATAR3_SPEC;
        impl crate::RegisterSpec for IDATAR3_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`idatar3::R`](R) reader structure
        impl crate::Readable for IDATAR3_SPEC {}
        ///`reset()` method sets IDATAR3 to value 0
        impl crate::Resettable for IDATAR3_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IDATAR4 (r) register accessor: injected data register 4
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`idatar4::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@idatar4`]
    ///module
    pub type IDATAR4 = crate::Reg<idatar4::IDATAR4_SPEC>;
    ///injected data register 4
    pub mod idatar4 {
        ///Register `IDATAR4` reader
        pub type R = crate::R<IDATAR4_SPEC>;
        ///Field `JDATA` reader - Injected data
        pub type JDATA_R = crate::FieldReader<u16>;
        impl R {
            ///Bits 0:15 - Injected data
            #[inline(always)]
            pub fn jdata(&self) -> JDATA_R {
                JDATA_R::new((self.bits & 0xffff) as u16)
            }
        }
        ///injected data register 4
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`idatar4::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IDATAR4_SPEC;
        impl crate::RegisterSpec for IDATAR4_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`idatar4::R`](R) reader structure
        impl crate::Readable for IDATAR4_SPEC {}
        ///`reset()` method sets IDATAR4 to value 0
        impl crate::Resettable for IDATAR4_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///RDATAR_DR_ACT_DCG (rw) register accessor: regular data register_start and discharge time register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`rdatar_dr_act_dcg::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`rdatar_dr_act_dcg::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@rdatar_dr_act_dcg`]
    ///module
    pub type RDATAR_DR_ACT_DCG = crate::Reg<rdatar_dr_act_dcg::RDATAR_DR_ACT_DCG_SPEC>;
    ///regular data register_start and discharge time register
    pub mod rdatar_dr_act_dcg {
        ///Register `RDATAR_DR_ACT_DCG` reader
        pub type R = crate::R<RDATAR_DR_ACT_DCG_SPEC>;
        ///Register `RDATAR_DR_ACT_DCG` writer
        pub type W = crate::W<RDATAR_DR_ACT_DCG_SPEC>;
        ///Field `DATA0_7_TKACT_DCG` reader - Regular data_Touch key start and discharge time register
        pub type DATA0_7_TKACT_DCG_R = crate::FieldReader;
        ///Field `DATA0_7_TKACT_DCG` writer - Regular data_Touch key start and discharge time register
        pub type DATA0_7_TKACT_DCG_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        ///Field `DATA8_15` reader - Regular data
        pub type DATA8_15_R = crate::FieldReader;
        ///Field `DATA8_15` writer - Regular data
        pub type DATA8_15_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            ///Bits 0:7 - Regular data_Touch key start and discharge time register
            #[inline(always)]
            pub fn data0_7_tkact_dcg(&self) -> DATA0_7_TKACT_DCG_R {
                DATA0_7_TKACT_DCG_R::new((self.bits & 0xff) as u8)
            }
            ///Bits 8:15 - Regular data
            #[inline(always)]
            pub fn data8_15(&self) -> DATA8_15_R {
                DATA8_15_R::new(((self.bits >> 8) & 0xff) as u8)
            }
        }
        impl W {
            ///Bits 0:7 - Regular data_Touch key start and discharge time register
            #[inline(always)]
            #[must_use]
            pub fn data0_7_tkact_dcg(&mut self) -> DATA0_7_TKACT_DCG_W<RDATAR_DR_ACT_DCG_SPEC> {
                DATA0_7_TKACT_DCG_W::new(self, 0)
            }
            ///Bits 8:15 - Regular data
            #[inline(always)]
            #[must_use]
            pub fn data8_15(&mut self) -> DATA8_15_W<RDATAR_DR_ACT_DCG_SPEC> {
                DATA8_15_W::new(self, 8)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///regular data register_start and discharge time register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`rdatar_dr_act_dcg::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`rdatar_dr_act_dcg::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct RDATAR_DR_ACT_DCG_SPEC;
        impl crate::RegisterSpec for RDATAR_DR_ACT_DCG_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`rdatar_dr_act_dcg::R`](R) reader structure
        impl crate::Readable for RDATAR_DR_ACT_DCG_SPEC {}
        ///`write(|w| ..)` method takes [`rdatar_dr_act_dcg::W`](W) writer structure
        impl crate::Writable for RDATAR_DR_ACT_DCG_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets RDATAR_DR_ACT_DCG to value 0
        impl crate::Resettable for RDATAR_DR_ACT_DCG_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///CFG (rw) register accessor: ADC configuration register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`cfg::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cfg::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    pub type CFG = crate::Reg<cfg::CFG_SPEC>;
    ///ADC configuration register
    pub mod cfg {
        ///Register `CFG` reader
        pub type R = crate::R<CFG_SPEC>;
        ///Register `CFG` writer
        pub type W = crate::W<CFG_SPEC>;
        ///Field `ADC_BUFTRIM` reader - ADC buffer misalignment control
        pub type ADC_BUFTRIM_R = crate::FieldReader;
        ///Field `ADC_BUFTRIM` writer - ADC buffer misalignment control
        pub type ADC_BUFTRIM_W<'a, REG> = crate::FieldWriter<'a, REG, 4>;
        ///Field `ADC_LP` reader - ADC low-power mode control
        pub type ADC_LP_R = crate::BitReader;
        ///Field `ADC_LP` writer - ADC low-power mode control
        pub type ADC_LP_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FIFO_EN` reader - ADC FIFO enable
        pub type FIFO_EN_R = crate::BitReader;
        ///Field `FIFO_EN` writer - ADC FIFO enable
        pub type FIFO_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `ADC_DUTY_EN` reader - ADC clock duty control
        pub type ADC_DUTY_EN_R = crate::BitReader;
        ///Field `ADC_DUTY_EN` writer - ADC clock duty control
        pub type ADC_DUTY_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TKEY_DRV_EN` reader - TOUCHKEY shielded enable
        pub type TKEY_DRV_EN_R = crate::BitReader;
        ///Field `TKEY_DRV_EN` writer - TOUCHKEY shielded enable
        pub type TKEY_DRV_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TKEY_DRV_OUTEN` reader - TOUCHKEY shielded each channel enable
        pub type TKEY_DRV_OUTEN_R = crate::FieldReader<u16>;
        ///Field `TKEY_DRV_OUTEN` writer - TOUCHKEY shielded each channel enable
        pub type TKEY_DRV_OUTEN_W<'a, REG> = crate::FieldWriter<'a, REG, 10, u16>;
        ///Field `TKEY_SEL` reader - TOUCHKEY bias current
        pub type TKEY_SEL_R = crate::FieldReader;
        ///Field `TKEY_SEL` writer - TOUCHKEY bias current
        pub type TKEY_SEL_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `TKEY_WAKE_EN` reader - TOUCHKEY Wake-up enable
        pub type TKEY_WAKE_EN_R = crate::FieldReader<u16>;
        ///Field `TKEY_WAKE_EN` writer - TOUCHKEY Wake-up enable
        pub type TKEY_WAKE_EN_W<'a, REG> = crate::FieldWriter<'a, REG, 10, u16>;
        impl R {
            ///Bits 0:3 - ADC buffer misalignment control
            #[inline(always)]
            pub fn adc_buftrim(&self) -> ADC_BUFTRIM_R {
                ADC_BUFTRIM_R::new((self.bits & 0x0f) as u8)
            }
            ///Bit 5 - ADC low-power mode control
            #[inline(always)]
            pub fn adc_lp(&self) -> ADC_LP_R {
                ADC_LP_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - ADC FIFO enable
            #[inline(always)]
            pub fn fifo_en(&self) -> FIFO_EN_R {
                FIFO_EN_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - ADC clock duty control
            #[inline(always)]
            pub fn adc_duty_en(&self) -> ADC_DUTY_EN_R {
                ADC_DUTY_EN_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bit 8 - TOUCHKEY shielded enable
            #[inline(always)]
            pub fn tkey_drv_en(&self) -> TKEY_DRV_EN_R {
                TKEY_DRV_EN_R::new(((self.bits >> 8) & 1) != 0)
            }
            ///Bits 9:18 - TOUCHKEY shielded each channel enable
            #[inline(always)]
            pub fn tkey_drv_outen(&self) -> TKEY_DRV_OUTEN_R {
                TKEY_DRV_OUTEN_R::new(((self.bits >> 9) & 0x03ff) as u16)
            }
            ///Bits 19:20 - TOUCHKEY bias current
            #[inline(always)]
            pub fn tkey_sel(&self) -> TKEY_SEL_R {
                TKEY_SEL_R::new(((self.bits >> 19) & 3) as u8)
            }
            ///Bits 21:30 - TOUCHKEY Wake-up enable
            #[inline(always)]
            pub fn tkey_wake_en(&self) -> TKEY_WAKE_EN_R {
                TKEY_WAKE_EN_R::new(((self.bits >> 21) & 0x03ff) as u16)
            }
        }
        impl W {
            ///Bits 0:3 - ADC buffer misalignment control
            #[inline(always)]
            #[must_use]
            pub fn adc_buftrim(&mut self) -> ADC_BUFTRIM_W<CFG_SPEC> {
                ADC_BUFTRIM_W::new(self, 0)
            }
            ///Bit 5 - ADC low-power mode control
            #[inline(always)]
            #[must_use]
            pub fn adc_lp(&mut self) -> ADC_LP_W<CFG_SPEC> {
                ADC_LP_W::new(self, 5)
            }
            ///Bit 6 - ADC FIFO enable
            #[inline(always)]
            #[must_use]
            pub fn fifo_en(&mut self) -> FIFO_EN_W<CFG_SPEC> {
                FIFO_EN_W::new(self, 6)
            }
            ///Bit 7 - ADC clock duty control
            #[inline(always)]
            #[must_use]
            pub fn adc_duty_en(&mut self) -> ADC_DUTY_EN_W<CFG_SPEC> {
                ADC_DUTY_EN_W::new(self, 7)
            }
            ///Bit 8 - TOUCHKEY shielded enable
            #[inline(always)]
            #[must_use]
            pub fn tkey_drv_en(&mut self) -> TKEY_DRV_EN_W<CFG_SPEC> {
                TKEY_DRV_EN_W::new(self, 8)
            }
            ///Bits 9:18 - TOUCHKEY shielded each channel enable
            #[inline(always)]
            #[must_use]
            pub fn tkey_drv_outen(&mut self) -> TKEY_DRV_OUTEN_W<CFG_SPEC> {
                TKEY_DRV_OUTEN_W::new(self, 9)
            }
            ///Bits 19:20 - TOUCHKEY bias current
            #[inline(always)]
            #[must_use]
            pub fn tkey_sel(&mut self) -> TKEY_SEL_W<CFG_SPEC> {
                TKEY_SEL_W::new(self, 19)
            }
            ///Bits 21:30 - TOUCHKEY Wake-up enable
            #[inline(always)]
            #[must_use]
            pub fn tkey_wake_en(&mut self) -> TKEY_WAKE_EN_W<CFG_SPEC> {
                TKEY_WAKE_EN_W::new(self, 21)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///ADC configuration register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`cfg::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cfg::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct CFG_SPEC;
        impl crate::RegisterSpec for CFG_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`cfg::R`](R) reader structure
        impl crate::Readable for CFG_SPEC {}
        ///`write(|w| ..)` method takes [`cfg::W`](W) writer structure
        impl crate::Writable for CFG_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets CFG to value 0
        impl crate::Resettable for CFG_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
}
///Debug support
pub struct DBG {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for DBG {}
impl DBG {
    ///Pointer to the register block
    pub const PTR: *const dbg::RegisterBlock = 0xe000_d000 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const dbg::RegisterBlock {
        Self::PTR
    }
    /// Steal an instance of this peripheral
    ///
    /// # Safety
    ///
    /// Ensure that the new instance of the peripheral cannot be used in a way
    /// that may race with any existing instances, for example by only
    /// accessing read-only or write-only registers, or by consuming the
    /// original peripheral and using critical sections to coordinate
    /// access between multiple new instances.
    ///
    /// Additionally, other software such as HALs may rely on only one
    /// peripheral instance existing to ensure memory safety; ensure
    /// no stolen instances are passed to such software.
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for DBG {
    type Target = dbg::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for DBG {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("DBG").finish()
    }
}
///Debug support
pub mod dbg {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        cr: CR,
    }
    impl RegisterBlock {
        ///0x00 - DBGMCU_CR
        #[inline(always)]
        pub const fn cr(&self) -> &CR {
            &self.cr
        }
    }
    ///CR (rw) register accessor: DBGMCU_CR
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`cr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@cr`]
    ///module
    pub type CR = crate::Reg<cr::CR_SPEC>;
    ///DBGMCU_CR
    pub mod cr {
        ///Register `CR` reader
        pub type R = crate::R<CR_SPEC>;
        ///Register `CR` writer
        pub type W = crate::W<CR_SPEC>;
        ///Field `SLEEP` reader - SLEEP
        pub type SLEEP_R = crate::BitReader;
        ///Field `SLEEP` writer - SLEEP
        pub type SLEEP_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `STOP` reader - STOP
        pub type STOP_R = crate::BitReader;
        ///Field `STOP` writer - STOP
        pub type STOP_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `STANDBY` reader - STANDBY
        pub type STANDBY_R = crate::BitReader;
        ///Field `STANDBY` writer - STANDBY
        pub type STANDBY_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `IWDG_STOP` reader - IWDG_STOP
        pub type IWDG_STOP_R = crate::BitReader;
        ///Field `IWDG_STOP` writer - IWDG_STOP
        pub type IWDG_STOP_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `WWDG_STOP` reader - WWDG_STOP
        pub type WWDG_STOP_R = crate::BitReader;
        ///Field `WWDG_STOP` writer - WWDG_STOP
        pub type WWDG_STOP_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `I2C1_SMBUS_TIMEOUT` reader - I2C1_SMBUS_TIMEOUT
        pub type I2C1_SMBUS_TIMEOUT_R = crate::BitReader;
        ///Field `I2C1_SMBUS_TIMEOUT` writer - I2C1_SMBUS_TIMEOUT
        pub type I2C1_SMBUS_TIMEOUT_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `I2C2_SMBUS_TIMEOUT` reader - I2C2_SMBUS_TIMEOUT
        pub type I2C2_SMBUS_TIMEOUT_R = crate::BitReader;
        ///Field `I2C2_SMBUS_TIMEOUT` writer - I2C2_SMBUS_TIMEOUT
        pub type I2C2_SMBUS_TIMEOUT_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TIM1_STOP` reader - TIM1_STOP
        pub type TIM1_STOP_R = crate::BitReader;
        ///Field `TIM1_STOP` writer - TIM1_STOP
        pub type TIM1_STOP_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TIM2_STOP` reader - TIM2_STOP
        pub type TIM2_STOP_R = crate::BitReader;
        ///Field `TIM2_STOP` writer - TIM2_STOP
        pub type TIM2_STOP_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TIM3_STOP` reader - TIM3_STOP
        pub type TIM3_STOP_R = crate::BitReader;
        ///Field `TIM3_STOP` writer - TIM3_STOP
        pub type TIM3_STOP_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TIM4_STOP` reader - TIM4_STOP
        pub type TIM4_STOP_R = crate::BitReader;
        ///Field `TIM4_STOP` writer - TIM4_STOP
        pub type TIM4_STOP_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CAN_STOP` reader - CAN_STOP
        pub type CAN_STOP_R = crate::BitReader;
        ///Field `CAN_STOP` writer - CAN_STOP
        pub type CAN_STOP_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - SLEEP
            #[inline(always)]
            pub fn sleep(&self) -> SLEEP_R {
                SLEEP_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - STOP
            #[inline(always)]
            pub fn stop(&self) -> STOP_R {
                STOP_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - STANDBY
            #[inline(always)]
            pub fn standby(&self) -> STANDBY_R {
                STANDBY_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 8 - IWDG_STOP
            #[inline(always)]
            pub fn iwdg_stop(&self) -> IWDG_STOP_R {
                IWDG_STOP_R::new(((self.bits >> 8) & 1) != 0)
            }
            ///Bit 9 - WWDG_STOP
            #[inline(always)]
            pub fn wwdg_stop(&self) -> WWDG_STOP_R {
                WWDG_STOP_R::new(((self.bits >> 9) & 1) != 0)
            }
            ///Bit 10 - I2C1_SMBUS_TIMEOUT
            #[inline(always)]
            pub fn i2c1_smbus_timeout(&self) -> I2C1_SMBUS_TIMEOUT_R {
                I2C1_SMBUS_TIMEOUT_R::new(((self.bits >> 10) & 1) != 0)
            }
            ///Bit 11 - I2C2_SMBUS_TIMEOUT
            #[inline(always)]
            pub fn i2c2_smbus_timeout(&self) -> I2C2_SMBUS_TIMEOUT_R {
                I2C2_SMBUS_TIMEOUT_R::new(((self.bits >> 11) & 1) != 0)
            }
            ///Bit 12 - TIM1_STOP
            #[inline(always)]
            pub fn tim1_stop(&self) -> TIM1_STOP_R {
                TIM1_STOP_R::new(((self.bits >> 12) & 1) != 0)
            }
            ///Bit 13 - TIM2_STOP
            #[inline(always)]
            pub fn tim2_stop(&self) -> TIM2_STOP_R {
                TIM2_STOP_R::new(((self.bits >> 13) & 1) != 0)
            }
            ///Bit 14 - TIM3_STOP
            #[inline(always)]
            pub fn tim3_stop(&self) -> TIM3_STOP_R {
                TIM3_STOP_R::new(((self.bits >> 14) & 1) != 0)
            }
            ///Bit 15 - TIM4_STOP
            #[inline(always)]
            pub fn tim4_stop(&self) -> TIM4_STOP_R {
                TIM4_STOP_R::new(((self.bits >> 15) & 1) != 0)
            }
            ///Bit 20 - CAN_STOP
            #[inline(always)]
            pub fn can_stop(&self) -> CAN_STOP_R {
                CAN_STOP_R::new(((self.bits >> 20) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - SLEEP
            #[inline(always)]
            #[must_use]
            pub fn sleep(&mut self) -> SLEEP_W<CR_SPEC> {
                SLEEP_W::new(self, 0)
            }
            ///Bit 1 - STOP
            #[inline(always)]
            #[must_use]
            pub fn stop(&mut self) -> STOP_W<CR_SPEC> {
                STOP_W::new(self, 1)
            }
            ///Bit 2 - STANDBY
            #[inline(always)]
            #[must_use]
            pub fn standby(&mut self) -> STANDBY_W<CR_SPEC> {
                STANDBY_W::new(self, 2)
            }
            ///Bit 8 - IWDG_STOP
            #[inline(always)]
            #[must_use]
            pub fn iwdg_stop(&mut self) -> IWDG_STOP_W<CR_SPEC> {
                IWDG_STOP_W::new(self, 8)
            }
            ///Bit 9 - WWDG_STOP
            #[inline(always)]
            #[must_use]
            pub fn wwdg_stop(&mut self) -> WWDG_STOP_W<CR_SPEC> {
                WWDG_STOP_W::new(self, 9)
            }
            ///Bit 10 - I2C1_SMBUS_TIMEOUT
            #[inline(always)]
            #[must_use]
            pub fn i2c1_smbus_timeout(&mut self) -> I2C1_SMBUS_TIMEOUT_W<CR_SPEC> {
                I2C1_SMBUS_TIMEOUT_W::new(self, 10)
            }
            ///Bit 11 - I2C2_SMBUS_TIMEOUT
            #[inline(always)]
            #[must_use]
            pub fn i2c2_smbus_timeout(&mut self) -> I2C2_SMBUS_TIMEOUT_W<CR_SPEC> {
                I2C2_SMBUS_TIMEOUT_W::new(self, 11)
            }
            ///Bit 12 - TIM1_STOP
            #[inline(always)]
            #[must_use]
            pub fn tim1_stop(&mut self) -> TIM1_STOP_W<CR_SPEC> {
                TIM1_STOP_W::new(self, 12)
            }
            ///Bit 13 - TIM2_STOP
            #[inline(always)]
            #[must_use]
            pub fn tim2_stop(&mut self) -> TIM2_STOP_W<CR_SPEC> {
                TIM2_STOP_W::new(self, 13)
            }
            ///Bit 14 - TIM3_STOP
            #[inline(always)]
            #[must_use]
            pub fn tim3_stop(&mut self) -> TIM3_STOP_W<CR_SPEC> {
                TIM3_STOP_W::new(self, 14)
            }
            ///Bit 15 - TIM4_STOP
            #[inline(always)]
            #[must_use]
            pub fn tim4_stop(&mut self) -> TIM4_STOP_W<CR_SPEC> {
                TIM4_STOP_W::new(self, 15)
            }
            ///Bit 20 - CAN_STOP
            #[inline(always)]
            #[must_use]
            pub fn can_stop(&mut self) -> CAN_STOP_W<CR_SPEC> {
                CAN_STOP_W::new(self, 20)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///DBGMCU_CR
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`cr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct CR_SPEC;
        impl crate::RegisterSpec for CR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`cr::R`](R) reader structure
        impl crate::Readable for CR_SPEC {}
        ///`write(|w| ..)` method takes [`cr::W`](W) writer structure
        impl crate::Writable for CR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets CR to value 0
        impl crate::Resettable for CR_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
}
///CRC calculation unit
pub struct CRC {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for CRC {}
impl CRC {
    ///Pointer to the register block
    pub const PTR: *const crc::RegisterBlock = 0x4002_3000 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const crc::RegisterBlock {
        Self::PTR
    }
    /// Steal an instance of this peripheral
    ///
    /// # Safety
    ///
    /// Ensure that the new instance of the peripheral cannot be used in a way
    /// that may race with any existing instances, for example by only
    /// accessing read-only or write-only registers, or by consuming the
    /// original peripheral and using critical sections to coordinate
    /// access between multiple new instances.
    ///
    /// Additionally, other software such as HALs may rely on only one
    /// peripheral instance existing to ensure memory safety; ensure
    /// no stolen instances are passed to such software.
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for CRC {
    type Target = crc::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for CRC {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("CRC").finish()
    }
}
///CRC calculation unit
pub mod crc {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        datar: DATAR,
        idatar: IDATAR,
        _reserved2: [u8; 0x03],
        ctlr: CTLR,
    }
    impl RegisterBlock {
        ///0x00 - Data register
        #[inline(always)]
        pub const fn datar(&self) -> &DATAR {
            &self.datar
        }
        ///0x04 - Independent Data register
        #[inline(always)]
        pub const fn idatar(&self) -> &IDATAR {
            &self.idatar
        }
        ///0x08 - Control register
        #[inline(always)]
        pub const fn ctlr(&self) -> &CTLR {
            &self.ctlr
        }
    }
    ///DATAR (rw) register accessor: Data register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`datar::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`datar::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@datar`]
    ///module
    pub type DATAR = crate::Reg<datar::DATAR_SPEC>;
    ///Data register
    pub mod datar {
        ///Register `DATAR` reader
        pub type R = crate::R<DATAR_SPEC>;
        ///Register `DATAR` writer
        pub type W = crate::W<DATAR_SPEC>;
        ///Field `DR` reader - Data Register
        pub type DR_R = crate::FieldReader<u32>;
        ///Field `DR` writer - Data Register
        pub type DR_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - Data Register
            #[inline(always)]
            pub fn dr(&self) -> DR_R {
                DR_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - Data Register
            #[inline(always)]
            #[must_use]
            pub fn dr(&mut self) -> DR_W<DATAR_SPEC> {
                DR_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Data register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`datar::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`datar::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct DATAR_SPEC;
        impl crate::RegisterSpec for DATAR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`datar::R`](R) reader structure
        impl crate::Readable for DATAR_SPEC {}
        ///`write(|w| ..)` method takes [`datar::W`](W) writer structure
        impl crate::Writable for DATAR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets DATAR to value 0xffff_ffff
        impl crate::Resettable for DATAR_SPEC {
            const RESET_VALUE: u32 = 0xffff_ffff;
        }
    }
    ///IDATAR (rw) register accessor: Independent Data register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`idatar::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`idatar::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@idatar`]
    ///module
    pub type IDATAR = crate::Reg<idatar::IDATAR_SPEC>;
    ///Independent Data register
    pub mod idatar {
        ///Register `IDATAR` reader
        pub type R = crate::R<IDATAR_SPEC>;
        ///Register `IDATAR` writer
        pub type W = crate::W<IDATAR_SPEC>;
        ///Field `IDR` reader - Independent Data register
        pub type IDR_R = crate::FieldReader;
        ///Field `IDR` writer - Independent Data register
        pub type IDR_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            ///Bits 0:7 - Independent Data register
            #[inline(always)]
            pub fn idr(&self) -> IDR_R {
                IDR_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:7 - Independent Data register
            #[inline(always)]
            #[must_use]
            pub fn idr(&mut self) -> IDR_W<IDATAR_SPEC> {
                IDR_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Independent Data register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`idatar::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`idatar::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IDATAR_SPEC;
        impl crate::RegisterSpec for IDATAR_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`idatar::R`](R) reader structure
        impl crate::Readable for IDATAR_SPEC {}
        ///`write(|w| ..)` method takes [`idatar::W`](W) writer structure
        impl crate::Writable for IDATAR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets IDATAR to value 0
        impl crate::Resettable for IDATAR_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///CTLR (w) register accessor: Control register
    ///
    ///You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ctlr::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@ctlr`]
    ///module
    pub type CTLR = crate::Reg<ctlr::CTLR_SPEC>;
    ///Control register
    pub mod ctlr {
        ///Register `CTLR` writer
        pub type W = crate::W<CTLR_SPEC>;
        ///Field `RESET` writer - Reset bit
        pub type RESET_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl W {
            ///Bit 0 - Reset bit
            #[inline(always)]
            #[must_use]
            pub fn reset(&mut self) -> RESET_W<CTLR_SPEC> {
                RESET_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Control register
        ///
        ///You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ctlr::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct CTLR_SPEC;
        impl crate::RegisterSpec for CTLR_SPEC {
            type Ux = u32;
        }
        ///`write(|w| ..)` method takes [`ctlr::W`](W) writer structure
        impl crate::Writable for CTLR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets CTLR to value 0
        impl crate::Resettable for CTLR_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
}
///FLASH
pub struct FLASH {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for FLASH {}
impl FLASH {
    ///Pointer to the register block
    pub const PTR: *const flash::RegisterBlock = 0x4002_2000 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const flash::RegisterBlock {
        Self::PTR
    }
    /// Steal an instance of this peripheral
    ///
    /// # Safety
    ///
    /// Ensure that the new instance of the peripheral cannot be used in a way
    /// that may race with any existing instances, for example by only
    /// accessing read-only or write-only registers, or by consuming the
    /// original peripheral and using critical sections to coordinate
    /// access between multiple new instances.
    ///
    /// Additionally, other software such as HALs may rely on only one
    /// peripheral instance existing to ensure memory safety; ensure
    /// no stolen instances are passed to such software.
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for FLASH {
    type Target = flash::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for FLASH {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("FLASH").finish()
    }
}
///FLASH
pub mod flash {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        actlr: ACTLR,
        keyr: KEYR,
        obkeyr: OBKEYR,
        statr: STATR,
        ctlr: CTLR,
        addr: ADDR,
        _reserved6: [u8; 0x04],
        obr: OBR,
        wpr: WPR,
        modekeyr: MODEKEYR,
    }
    impl RegisterBlock {
        ///0x00 - Access control register
        #[inline(always)]
        pub const fn actlr(&self) -> &ACTLR {
            &self.actlr
        }
        ///0x04 - Flash key register
        #[inline(always)]
        pub const fn keyr(&self) -> &KEYR {
            &self.keyr
        }
        ///0x08 - Flash option key register
        #[inline(always)]
        pub const fn obkeyr(&self) -> &OBKEYR {
            &self.obkeyr
        }
        ///0x0c - Status register
        #[inline(always)]
        pub const fn statr(&self) -> &STATR {
            &self.statr
        }
        ///0x10 - Control register
        #[inline(always)]
        pub const fn ctlr(&self) -> &CTLR {
            &self.ctlr
        }
        ///0x14 - Flash address register
        #[inline(always)]
        pub const fn addr(&self) -> &ADDR {
            &self.addr
        }
        ///0x1c - Option byte register
        #[inline(always)]
        pub const fn obr(&self) -> &OBR {
            &self.obr
        }
        ///0x20 - Write protection register
        #[inline(always)]
        pub const fn wpr(&self) -> &WPR {
            &self.wpr
        }
        ///0x24 - Mode select register
        #[inline(always)]
        pub const fn modekeyr(&self) -> &MODEKEYR {
            &self.modekeyr
        }
    }
    ///ACTLR (rw) register accessor: Access control register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`actlr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`actlr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@actlr`]
    ///module
    pub type ACTLR = crate::Reg<actlr::ACTLR_SPEC>;
    ///Access control register
    pub mod actlr {
        ///Register `ACTLR` reader
        pub type R = crate::R<ACTLR_SPEC>;
        ///Register `ACTLR` writer
        pub type W = crate::W<ACTLR_SPEC>;
        ///Field `LATENCY` reader - FLASH standby condition
        pub type LATENCY_R = crate::FieldReader;
        ///Field `LATENCY` writer - FLASH standby condition
        pub type LATENCY_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        impl R {
            ///Bits 0:1 - FLASH standby condition
            #[inline(always)]
            pub fn latency(&self) -> LATENCY_R {
                LATENCY_R::new((self.bits & 3) as u8)
            }
        }
        impl W {
            ///Bits 0:1 - FLASH standby condition
            #[inline(always)]
            #[must_use]
            pub fn latency(&mut self) -> LATENCY_W<ACTLR_SPEC> {
                LATENCY_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Access control register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`actlr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`actlr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct ACTLR_SPEC;
        impl crate::RegisterSpec for ACTLR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`actlr::R`](R) reader structure
        impl crate::Readable for ACTLR_SPEC {}
        ///`write(|w| ..)` method takes [`actlr::W`](W) writer structure
        impl crate::Writable for ACTLR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets ACTLR to value 0
        impl crate::Resettable for ACTLR_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///KEYR (w) register accessor: Flash key register
    ///
    ///You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`keyr::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@keyr`]
    ///module
    pub type KEYR = crate::Reg<keyr::KEYR_SPEC>;
    ///Flash key register
    pub mod keyr {
        ///Register `KEYR` writer
        pub type W = crate::W<KEYR_SPEC>;
        ///Field `KEYR` writer - FPEC key
        pub type KEYR_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl W {
            ///Bits 0:31 - FPEC key
            #[inline(always)]
            #[must_use]
            pub fn keyr(&mut self) -> KEYR_W<KEYR_SPEC> {
                KEYR_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Flash key register
        ///
        ///You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`keyr::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct KEYR_SPEC;
        impl crate::RegisterSpec for KEYR_SPEC {
            type Ux = u32;
        }
        ///`write(|w| ..)` method takes [`keyr::W`](W) writer structure
        impl crate::Writable for KEYR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets KEYR to value 0x03ff_fffc
        impl crate::Resettable for KEYR_SPEC {
            const RESET_VALUE: u32 = 0x03ff_fffc;
        }
    }
    ///OBKEYR (w) register accessor: Flash option key register
    ///
    ///You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`obkeyr::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@obkeyr`]
    ///module
    pub type OBKEYR = crate::Reg<obkeyr::OBKEYR_SPEC>;
    ///Flash option key register
    pub mod obkeyr {
        ///Register `OBKEYR` writer
        pub type W = crate::W<OBKEYR_SPEC>;
        ///Field `OBTKEY` writer - Option byte key
        pub type OBTKEY_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl W {
            ///Bits 0:31 - Option byte key
            #[inline(always)]
            #[must_use]
            pub fn obtkey(&mut self) -> OBTKEY_W<OBKEYR_SPEC> {
                OBTKEY_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Flash option key register
        ///
        ///You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`obkeyr::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct OBKEYR_SPEC;
        impl crate::RegisterSpec for OBKEYR_SPEC {
            type Ux = u32;
        }
        ///`write(|w| ..)` method takes [`obkeyr::W`](W) writer structure
        impl crate::Writable for OBKEYR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets OBKEYR to value 0
        impl crate::Resettable for OBKEYR_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///STATR (rw) register accessor: Status register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`statr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`statr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@statr`]
    ///module
    pub type STATR = crate::Reg<statr::STATR_SPEC>;
    ///Status register
    pub mod statr {
        ///Register `STATR` reader
        pub type R = crate::R<STATR_SPEC>;
        ///Register `STATR` writer
        pub type W = crate::W<STATR_SPEC>;
        ///Field `BSY` reader - Busy
        pub type BSY_R = crate::BitReader;
        ///Field `WRPRTERR` reader - Write protection error
        pub type WRPRTERR_R = crate::BitReader;
        ///Field `WRPRTERR` writer - Write protection error
        pub type WRPRTERR_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `EOP` reader - End of operation
        pub type EOP_R = crate::BitReader;
        ///Field `EOP` writer - End of operation
        pub type EOP_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FWAKE_FLAG` reader - Wake-Up flag
        pub type FWAKE_FLAG_R = crate::BitReader;
        ///Field `FWAKE_FLAG` writer - Wake-Up flag
        pub type FWAKE_FLAG_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TURBO` reader - TURBO
        pub type TURBO_R = crate::BitReader;
        impl R {
            ///Bit 0 - Busy
            #[inline(always)]
            pub fn bsy(&self) -> BSY_R {
                BSY_R::new((self.bits & 1) != 0)
            }
            ///Bit 4 - Write protection error
            #[inline(always)]
            pub fn wrprterr(&self) -> WRPRTERR_R {
                WRPRTERR_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - End of operation
            #[inline(always)]
            pub fn eop(&self) -> EOP_R {
                EOP_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - Wake-Up flag
            #[inline(always)]
            pub fn fwake_flag(&self) -> FWAKE_FLAG_R {
                FWAKE_FLAG_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - TURBO
            #[inline(always)]
            pub fn turbo(&self) -> TURBO_R {
                TURBO_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 4 - Write protection error
            #[inline(always)]
            #[must_use]
            pub fn wrprterr(&mut self) -> WRPRTERR_W<STATR_SPEC> {
                WRPRTERR_W::new(self, 4)
            }
            ///Bit 5 - End of operation
            #[inline(always)]
            #[must_use]
            pub fn eop(&mut self) -> EOP_W<STATR_SPEC> {
                EOP_W::new(self, 5)
            }
            ///Bit 6 - Wake-Up flag
            #[inline(always)]
            #[must_use]
            pub fn fwake_flag(&mut self) -> FWAKE_FLAG_W<STATR_SPEC> {
                FWAKE_FLAG_W::new(self, 6)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Status register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`statr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`statr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct STATR_SPEC;
        impl crate::RegisterSpec for STATR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`statr::R`](R) reader structure
        impl crate::Readable for STATR_SPEC {}
        ///`write(|w| ..)` method takes [`statr::W`](W) writer structure
        impl crate::Writable for STATR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets STATR to value 0xc000
        impl crate::Resettable for STATR_SPEC {
            const RESET_VALUE: u32 = 0xc000;
        }
    }
    ///CTLR (rw) register accessor: Control register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`ctlr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ctlr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@ctlr`]
    ///module
    pub type CTLR = crate::Reg<ctlr::CTLR_SPEC>;
    ///Control register
    pub mod ctlr {
        ///Register `CTLR` reader
        pub type R = crate::R<CTLR_SPEC>;
        ///Register `CTLR` writer
        pub type W = crate::W<CTLR_SPEC>;
        ///Field `PER` reader - Page Erase
        pub type PER_R = crate::BitReader;
        ///Field `PER` writer - Page Erase
        pub type PER_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `MER` reader - Mass Erase
        pub type MER_R = crate::BitReader;
        ///Field `MER` writer - Mass Erase
        pub type MER_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `OBPG` reader - Option byte programming
        pub type OBPG_R = crate::BitReader;
        ///Field `OBPG` writer - Option byte programming
        pub type OBPG_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `OBER` reader - Option byte erase
        pub type OBER_R = crate::BitReader;
        ///Field `OBER` writer - Option byte erase
        pub type OBER_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `STRT` reader - Start
        pub type STRT_R = crate::BitReader;
        ///Field `STRT` writer - Start
        pub type STRT_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `LOCK` reader - Lock
        pub type LOCK_R = crate::BitReader;
        ///Field `LOCK` writer - Lock
        pub type LOCK_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `OBWRE` reader - Option bytes write enable
        pub type OBWRE_R = crate::BitReader;
        ///Field `OBWRE` writer - Option bytes write enable
        pub type OBWRE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `ERRIE` reader - Error interrupt enable
        pub type ERRIE_R = crate::BitReader;
        ///Field `ERRIE` writer - Error interrupt enable
        pub type ERRIE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `EOPIE` reader - End of operation interrupt enable
        pub type EOPIE_R = crate::BitReader;
        ///Field `EOPIE` writer - End of operation interrupt enable
        pub type EOPIE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FWAKEIE` reader - wake-up interrupt enable
        pub type FWAKEIE_R = crate::BitReader;
        ///Field `FWAKEIE` writer - wake-up interrupt enable
        pub type FWAKEIE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FLOCK` reader - Fast programmable lock
        pub type FLOCK_R = crate::BitReader;
        ///Field `FLOCK` writer - Fast programmable lock
        pub type FLOCK_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PTPG` reader - Fast programming
        pub type PTPG_R = crate::BitReader;
        ///Field `PTPG` writer - Fast programming
        pub type PTPG_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PTER` reader - Fast erase
        pub type PTER_R = crate::BitReader;
        ///Field `PTER` writer - Fast erase
        pub type PTER_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `BUFLOAD` reader - Data buffer
        pub type BUFLOAD_R = crate::BitReader;
        ///Field `BUFLOAD` writer - Data buffer
        pub type BUFLOAD_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `BUFRST` reader - BUF reset
        pub type BUFRST_R = crate::BitReader;
        ///Field `BUFRST` writer - BUF reset
        pub type BUFRST_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `BER32` reader - Block Erase 32K
        pub type BER32_R = crate::BitReader;
        ///Field `BER32` writer - Block Erase 32K
        pub type BER32_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 1 - Page Erase
            #[inline(always)]
            pub fn per(&self) -> PER_R {
                PER_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - Mass Erase
            #[inline(always)]
            pub fn mer(&self) -> MER_R {
                MER_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 4 - Option byte programming
            #[inline(always)]
            pub fn obpg(&self) -> OBPG_R {
                OBPG_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - Option byte erase
            #[inline(always)]
            pub fn ober(&self) -> OBER_R {
                OBER_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - Start
            #[inline(always)]
            pub fn strt(&self) -> STRT_R {
                STRT_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - Lock
            #[inline(always)]
            pub fn lock(&self) -> LOCK_R {
                LOCK_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bit 9 - Option bytes write enable
            #[inline(always)]
            pub fn obwre(&self) -> OBWRE_R {
                OBWRE_R::new(((self.bits >> 9) & 1) != 0)
            }
            ///Bit 10 - Error interrupt enable
            #[inline(always)]
            pub fn errie(&self) -> ERRIE_R {
                ERRIE_R::new(((self.bits >> 10) & 1) != 0)
            }
            ///Bit 12 - End of operation interrupt enable
            #[inline(always)]
            pub fn eopie(&self) -> EOPIE_R {
                EOPIE_R::new(((self.bits >> 12) & 1) != 0)
            }
            ///Bit 13 - wake-up interrupt enable
            #[inline(always)]
            pub fn fwakeie(&self) -> FWAKEIE_R {
                FWAKEIE_R::new(((self.bits >> 13) & 1) != 0)
            }
            ///Bit 15 - Fast programmable lock
            #[inline(always)]
            pub fn flock(&self) -> FLOCK_R {
                FLOCK_R::new(((self.bits >> 15) & 1) != 0)
            }
            ///Bit 16 - Fast programming
            #[inline(always)]
            pub fn ptpg(&self) -> PTPG_R {
                PTPG_R::new(((self.bits >> 16) & 1) != 0)
            }
            ///Bit 17 - Fast erase
            #[inline(always)]
            pub fn pter(&self) -> PTER_R {
                PTER_R::new(((self.bits >> 17) & 1) != 0)
            }
            ///Bit 18 - Data buffer
            #[inline(always)]
            pub fn bufload(&self) -> BUFLOAD_R {
                BUFLOAD_R::new(((self.bits >> 18) & 1) != 0)
            }
            ///Bit 19 - BUF reset
            #[inline(always)]
            pub fn bufrst(&self) -> BUFRST_R {
                BUFRST_R::new(((self.bits >> 19) & 1) != 0)
            }
            ///Bit 23 - Block Erase 32K
            #[inline(always)]
            pub fn ber32(&self) -> BER32_R {
                BER32_R::new(((self.bits >> 23) & 1) != 0)
            }
        }
        impl W {
            ///Bit 1 - Page Erase
            #[inline(always)]
            #[must_use]
            pub fn per(&mut self) -> PER_W<CTLR_SPEC> {
                PER_W::new(self, 1)
            }
            ///Bit 2 - Mass Erase
            #[inline(always)]
            #[must_use]
            pub fn mer(&mut self) -> MER_W<CTLR_SPEC> {
                MER_W::new(self, 2)
            }
            ///Bit 4 - Option byte programming
            #[inline(always)]
            #[must_use]
            pub fn obpg(&mut self) -> OBPG_W<CTLR_SPEC> {
                OBPG_W::new(self, 4)
            }
            ///Bit 5 - Option byte erase
            #[inline(always)]
            #[must_use]
            pub fn ober(&mut self) -> OBER_W<CTLR_SPEC> {
                OBER_W::new(self, 5)
            }
            ///Bit 6 - Start
            #[inline(always)]
            #[must_use]
            pub fn strt(&mut self) -> STRT_W<CTLR_SPEC> {
                STRT_W::new(self, 6)
            }
            ///Bit 7 - Lock
            #[inline(always)]
            #[must_use]
            pub fn lock(&mut self) -> LOCK_W<CTLR_SPEC> {
                LOCK_W::new(self, 7)
            }
            ///Bit 9 - Option bytes write enable
            #[inline(always)]
            #[must_use]
            pub fn obwre(&mut self) -> OBWRE_W<CTLR_SPEC> {
                OBWRE_W::new(self, 9)
            }
            ///Bit 10 - Error interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn errie(&mut self) -> ERRIE_W<CTLR_SPEC> {
                ERRIE_W::new(self, 10)
            }
            ///Bit 12 - End of operation interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn eopie(&mut self) -> EOPIE_W<CTLR_SPEC> {
                EOPIE_W::new(self, 12)
            }
            ///Bit 13 - wake-up interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn fwakeie(&mut self) -> FWAKEIE_W<CTLR_SPEC> {
                FWAKEIE_W::new(self, 13)
            }
            ///Bit 15 - Fast programmable lock
            #[inline(always)]
            #[must_use]
            pub fn flock(&mut self) -> FLOCK_W<CTLR_SPEC> {
                FLOCK_W::new(self, 15)
            }
            ///Bit 16 - Fast programming
            #[inline(always)]
            #[must_use]
            pub fn ptpg(&mut self) -> PTPG_W<CTLR_SPEC> {
                PTPG_W::new(self, 16)
            }
            ///Bit 17 - Fast erase
            #[inline(always)]
            #[must_use]
            pub fn pter(&mut self) -> PTER_W<CTLR_SPEC> {
                PTER_W::new(self, 17)
            }
            ///Bit 18 - Data buffer
            #[inline(always)]
            #[must_use]
            pub fn bufload(&mut self) -> BUFLOAD_W<CTLR_SPEC> {
                BUFLOAD_W::new(self, 18)
            }
            ///Bit 19 - BUF reset
            #[inline(always)]
            #[must_use]
            pub fn bufrst(&mut self) -> BUFRST_W<CTLR_SPEC> {
                BUFRST_W::new(self, 19)
            }
            ///Bit 23 - Block Erase 32K
            #[inline(always)]
            #[must_use]
            pub fn ber32(&mut self) -> BER32_W<CTLR_SPEC> {
                BER32_W::new(self, 23)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Control register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`ctlr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ctlr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct CTLR_SPEC;
        impl crate::RegisterSpec for CTLR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`ctlr::R`](R) reader structure
        impl crate::Readable for CTLR_SPEC {}
        ///`write(|w| ..)` method takes [`ctlr::W`](W) writer structure
        impl crate::Writable for CTLR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets CTLR to value 0x8080
        impl crate::Resettable for CTLR_SPEC {
            const RESET_VALUE: u32 = 0x8080;
        }
    }
    ///ADDR (w) register accessor: Flash address register
    ///
    ///You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`addr::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@addr`]
    ///module
    pub type ADDR = crate::Reg<addr::ADDR_SPEC>;
    ///Flash address register
    pub mod addr {
        ///Register `ADDR` writer
        pub type W = crate::W<ADDR_SPEC>;
        ///Field `FAR` writer - Flash Address
        pub type FAR_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl W {
            ///Bits 0:31 - Flash Address
            #[inline(always)]
            #[must_use]
            pub fn far(&mut self) -> FAR_W<ADDR_SPEC> {
                FAR_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Flash address register
        ///
        ///You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`addr::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct ADDR_SPEC;
        impl crate::RegisterSpec for ADDR_SPEC {
            type Ux = u32;
        }
        ///`write(|w| ..)` method takes [`addr::W`](W) writer structure
        impl crate::Writable for ADDR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets ADDR to value 0
        impl crate::Resettable for ADDR_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///OBR (r) register accessor: Option byte register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`obr::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@obr`]
    ///module
    pub type OBR = crate::Reg<obr::OBR_SPEC>;
    ///Option byte register
    pub mod obr {
        ///Register `OBR` reader
        pub type R = crate::R<OBR_SPEC>;
        ///Field `OBERR` reader - Option byte error
        pub type OBERR_R = crate::BitReader;
        ///Field `RDPRT` reader - Read protection
        pub type RDPRT_R = crate::BitReader;
        ///Field `IWDG_SW` reader - IWDG_SW
        pub type IWDG_SW_R = crate::BitReader;
        ///Field `STOP_RST` reader - STOP_RST
        pub type STOP_RST_R = crate::BitReader;
        ///Field `STANDY_RST` reader - STANDY_RST
        pub type STANDY_RST_R = crate::BitReader;
        ///Field `CFGCANM` reader - Configure the offline recovery time
        pub type CFGCANM_R = crate::BitReader;
        ///Field `FIX_11` reader - Fixed to 11
        pub type FIX_11_R = crate::FieldReader;
        ///Field `DATA0` reader - Data byte 0
        pub type DATA0_R = crate::FieldReader;
        ///Field `DATA1` reader - Data byte 1
        pub type DATA1_R = crate::FieldReader;
        impl R {
            ///Bit 0 - Option byte error
            #[inline(always)]
            pub fn oberr(&self) -> OBERR_R {
                OBERR_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Read protection
            #[inline(always)]
            pub fn rdprt(&self) -> RDPRT_R {
                RDPRT_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - IWDG_SW
            #[inline(always)]
            pub fn iwdg_sw(&self) -> IWDG_SW_R {
                IWDG_SW_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - STOP_RST
            #[inline(always)]
            pub fn stop_rst(&self) -> STOP_RST_R {
                STOP_RST_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - STANDY_RST
            #[inline(always)]
            pub fn standy_rst(&self) -> STANDY_RST_R {
                STANDY_RST_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 7 - Configure the offline recovery time
            #[inline(always)]
            pub fn cfgcanm(&self) -> CFGCANM_R {
                CFGCANM_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bits 8:9 - Fixed to 11
            #[inline(always)]
            pub fn fix_11(&self) -> FIX_11_R {
                FIX_11_R::new(((self.bits >> 8) & 3) as u8)
            }
            ///Bits 10:17 - Data byte 0
            #[inline(always)]
            pub fn data0(&self) -> DATA0_R {
                DATA0_R::new(((self.bits >> 10) & 0xff) as u8)
            }
            ///Bits 18:25 - Data byte 1
            #[inline(always)]
            pub fn data1(&self) -> DATA1_R {
                DATA1_R::new(((self.bits >> 18) & 0xff) as u8)
            }
        }
        ///Option byte register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`obr::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct OBR_SPEC;
        impl crate::RegisterSpec for OBR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`obr::R`](R) reader structure
        impl crate::Readable for OBR_SPEC {}
        ///`reset()` method sets OBR to value 0x03ff_fffc
        impl crate::Resettable for OBR_SPEC {
            const RESET_VALUE: u32 = 0x03ff_fffc;
        }
    }
    ///WPR (r) register accessor: Write protection register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`wpr::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@wpr`]
    ///module
    pub type WPR = crate::Reg<wpr::WPR_SPEC>;
    ///Write protection register
    pub mod wpr {
        ///Register `WPR` reader
        pub type R = crate::R<WPR_SPEC>;
        ///Field `WRP` reader - Write protect
        pub type WRP_R = crate::FieldReader<u32>;
        impl R {
            ///Bits 0:31 - Write protect
            #[inline(always)]
            pub fn wrp(&self) -> WRP_R {
                WRP_R::new(self.bits)
            }
        }
        ///Write protection register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`wpr::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct WPR_SPEC;
        impl crate::RegisterSpec for WPR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`wpr::R`](R) reader structure
        impl crate::Readable for WPR_SPEC {}
        ///`reset()` method sets WPR to value 0
        impl crate::Resettable for WPR_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///MODEKEYR (w) register accessor: Mode select register
    ///
    ///You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`modekeyr::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@modekeyr`]
    ///module
    pub type MODEKEYR = crate::Reg<modekeyr::MODEKEYR_SPEC>;
    ///Mode select register
    pub mod modekeyr {
        ///Register `MODEKEYR` writer
        pub type W = crate::W<MODEKEYR_SPEC>;
        ///Field `MODEKEYR` writer - Mode select
        pub type MODEKEYR_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl W {
            ///Bits 0:31 - Mode select
            #[inline(always)]
            #[must_use]
            pub fn modekeyr(&mut self) -> MODEKEYR_W<MODEKEYR_SPEC> {
                MODEKEYR_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Mode select register
        ///
        ///You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`modekeyr::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct MODEKEYR_SPEC;
        impl crate::RegisterSpec for MODEKEYR_SPEC {
            type Ux = u32;
        }
        ///`write(|w| ..)` method takes [`modekeyr::W`](W) writer structure
        impl crate::Writable for MODEKEYR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets MODEKEYR to value 0x0ffe
        impl crate::Resettable for MODEKEYR_SPEC {
            const RESET_VALUE: u32 = 0x0ffe;
        }
    }
}
///Programmable Fast Interrupt Controller
pub struct PFIC {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for PFIC {}
impl PFIC {
    ///Pointer to the register block
    pub const PTR: *const pfic::RegisterBlock = 0xe000_e000 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const pfic::RegisterBlock {
        Self::PTR
    }
    /// Steal an instance of this peripheral
    ///
    /// # Safety
    ///
    /// Ensure that the new instance of the peripheral cannot be used in a way
    /// that may race with any existing instances, for example by only
    /// accessing read-only or write-only registers, or by consuming the
    /// original peripheral and using critical sections to coordinate
    /// access between multiple new instances.
    ///
    /// Additionally, other software such as HALs may rely on only one
    /// peripheral instance existing to ensure memory safety; ensure
    /// no stolen instances are passed to such software.
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for PFIC {
    type Target = pfic::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for PFIC {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("PFIC").finish()
    }
}
///Programmable Fast Interrupt Controller
pub mod pfic {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        isr1: ISR1,
        isr2: ISR2,
        isr3: ISR3,
        _reserved3: [u8; 0x14],
        ipr1: IPR1,
        ipr2: IPR2,
        ipr3: IPR3,
        _reserved6: [u8; 0x14],
        ithresdr: ITHRESDR,
        _reserved7: [u8; 0x04],
        cfgr: CFGR,
        gisr: GISR,
        vtfidr: VTFIDR,
        _reserved10: [u8; 0x0c],
        vtfaddrr0: VTFADDRR0,
        vtfaddrr1: VTFADDRR1,
        vtfaddrr2: VTFADDRR2,
        vtfaddrr3: VTFADDRR3,
        _reserved14: [u8; 0x90],
        ienr1: IENR1,
        ienr2: IENR2,
        ienr3: IENR3,
        _reserved17: [u8; 0x74],
        irer1: IRER1,
        irer2: IRER2,
        irer3: IRER3,
        _reserved20: [u8; 0x74],
        ipsr1: IPSR1,
        ipsr2: IPSR2,
        ipsr3: IPSR3,
        _reserved23: [u8; 0x74],
        iprr1: IPRR1,
        iprr2: IPRR2,
        iprr3: IPRR3,
        _reserved26: [u8; 0x74],
        iactr1: IACTR1,
        iactr2: IACTR2,
        iactr3: IACTR3,
        _reserved29: [u8; 0xf4],
        iprior0: IPRIOR0,
        iprior1: IPRIOR1,
        iprior2: IPRIOR2,
        iprior3: IPRIOR3,
        iprior4: IPRIOR4,
        iprior5: IPRIOR5,
        iprior6: IPRIOR6,
        iprior7: IPRIOR7,
        iprior8: IPRIOR8,
        iprior9: IPRIOR9,
        iprior10: IPRIOR10,
        iprior11: IPRIOR11,
        iprior12: IPRIOR12,
        iprior13: IPRIOR13,
        iprior14: IPRIOR14,
        iprior15: IPRIOR15,
        iprior16: IPRIOR16,
        iprior17: IPRIOR17,
        iprior18: IPRIOR18,
        iprior19: IPRIOR19,
        iprior20: IPRIOR20,
        iprior21: IPRIOR21,
        iprior22: IPRIOR22,
        iprior23: IPRIOR23,
        iprior24: IPRIOR24,
        iprior25: IPRIOR25,
        iprior26: IPRIOR26,
        iprior27: IPRIOR27,
        iprior28: IPRIOR28,
        iprior29: IPRIOR29,
        iprior30: IPRIOR30,
        iprior31: IPRIOR31,
        iprior32: IPRIOR32,
        iprior33: IPRIOR33,
        iprior34: IPRIOR34,
        iprior35: IPRIOR35,
        iprior36: IPRIOR36,
        iprior37: IPRIOR37,
        iprior38: IPRIOR38,
        iprior39: IPRIOR39,
        iprior40: IPRIOR40,
        iprior41: IPRIOR41,
        iprior42: IPRIOR42,
        iprior43: IPRIOR43,
        iprior44: IPRIOR44,
        iprior45: IPRIOR45,
        iprior46: IPRIOR46,
        iprior47: IPRIOR47,
        iprior48: IPRIOR48,
        iprior49: IPRIOR49,
        iprior50: IPRIOR50,
        iprior51: IPRIOR51,
        iprior52: IPRIOR52,
        iprior53: IPRIOR53,
        iprior54: IPRIOR54,
        iprior55: IPRIOR55,
        iprior56: IPRIOR56,
        iprior57: IPRIOR57,
        iprior58: IPRIOR58,
        iprior59: IPRIOR59,
        iprior60: IPRIOR60,
        iprior61: IPRIOR61,
        iprior62: IPRIOR62,
        iprior63: IPRIOR63,
        iprior64: IPRIOR64,
        iprior65: IPRIOR65,
        iprior66: IPRIOR66,
        iprior67: IPRIOR67,
        iprior68: IPRIOR68,
        _reserved98: [u8; 0x08cb],
        sctlr: SCTLR,
        _reserved99: [u8; 0x02ec],
        stk_ctlr: STK_CTLR,
        stk_sr: STK_SR,
        stk_cntl: STK_CNTL,
        stk_cnth: STK_CNTH,
        stk_cmplr: STK_CMPLR,
        stk_cmphr: STK_CMPHR,
    }
    impl RegisterBlock {
        ///0x00 - Interrupt Status Register
        #[inline(always)]
        pub const fn isr1(&self) -> &ISR1 {
            &self.isr1
        }
        ///0x04 - Interrupt Status Register
        #[inline(always)]
        pub const fn isr2(&self) -> &ISR2 {
            &self.isr2
        }
        ///0x08 - Interrupt Status Register
        #[inline(always)]
        pub const fn isr3(&self) -> &ISR3 {
            &self.isr3
        }
        ///0x20 - Interrupt Pending Register
        #[inline(always)]
        pub const fn ipr1(&self) -> &IPR1 {
            &self.ipr1
        }
        ///0x24 - Interrupt Pending Register
        #[inline(always)]
        pub const fn ipr2(&self) -> &IPR2 {
            &self.ipr2
        }
        ///0x28 - Interrupt Pending Register
        #[inline(always)]
        pub const fn ipr3(&self) -> &IPR3 {
            &self.ipr3
        }
        ///0x40 - Interrupt Priority Register
        #[inline(always)]
        pub const fn ithresdr(&self) -> &ITHRESDR {
            &self.ithresdr
        }
        ///0x48 - Interrupt Config Register
        #[inline(always)]
        pub const fn cfgr(&self) -> &CFGR {
            &self.cfgr
        }
        ///0x4c - Interrupt Global Register
        #[inline(always)]
        pub const fn gisr(&self) -> &GISR {
            &self.gisr
        }
        ///0x50 - ID Config Register
        #[inline(always)]
        pub const fn vtfidr(&self) -> &VTFIDR {
            &self.vtfidr
        }
        ///0x60 - Interrupt 0 address Register
        #[inline(always)]
        pub const fn vtfaddrr0(&self) -> &VTFADDRR0 {
            &self.vtfaddrr0
        }
        ///0x64 - Interrupt 1 address Register
        #[inline(always)]
        pub const fn vtfaddrr1(&self) -> &VTFADDRR1 {
            &self.vtfaddrr1
        }
        ///0x68 - Interrupt 2 address Register
        #[inline(always)]
        pub const fn vtfaddrr2(&self) -> &VTFADDRR2 {
            &self.vtfaddrr2
        }
        ///0x6c - Interrupt 3 address Register
        #[inline(always)]
        pub const fn vtfaddrr3(&self) -> &VTFADDRR3 {
            &self.vtfaddrr3
        }
        ///0x100 - Interrupt Setting Register
        #[inline(always)]
        pub const fn ienr1(&self) -> &IENR1 {
            &self.ienr1
        }
        ///0x104 - Interrupt Setting Register
        #[inline(always)]
        pub const fn ienr2(&self) -> &IENR2 {
            &self.ienr2
        }
        ///0x108 - Interrupt Setting Register
        #[inline(always)]
        pub const fn ienr3(&self) -> &IENR3 {
            &self.ienr3
        }
        ///0x180 - Interrupt Clear Register
        #[inline(always)]
        pub const fn irer1(&self) -> &IRER1 {
            &self.irer1
        }
        ///0x184 - Interrupt Clear Register
        #[inline(always)]
        pub const fn irer2(&self) -> &IRER2 {
            &self.irer2
        }
        ///0x188 - Interrupt Clear Register
        #[inline(always)]
        pub const fn irer3(&self) -> &IRER3 {
            &self.irer3
        }
        ///0x200 - Interrupt Pending Register
        #[inline(always)]
        pub const fn ipsr1(&self) -> &IPSR1 {
            &self.ipsr1
        }
        ///0x204 - Interrupt Pending Register
        #[inline(always)]
        pub const fn ipsr2(&self) -> &IPSR2 {
            &self.ipsr2
        }
        ///0x208 - Interrupt Pending Register
        #[inline(always)]
        pub const fn ipsr3(&self) -> &IPSR3 {
            &self.ipsr3
        }
        ///0x280 - Interrupt Pending Clear Register
        #[inline(always)]
        pub const fn iprr1(&self) -> &IPRR1 {
            &self.iprr1
        }
        ///0x284 - Interrupt Pending Clear Register
        #[inline(always)]
        pub const fn iprr2(&self) -> &IPRR2 {
            &self.iprr2
        }
        ///0x288 - Interrupt Pending Clear Register
        #[inline(always)]
        pub const fn iprr3(&self) -> &IPRR3 {
            &self.iprr3
        }
        ///0x300 - Interrupt ACTIVE Register
        #[inline(always)]
        pub const fn iactr1(&self) -> &IACTR1 {
            &self.iactr1
        }
        ///0x304 - Interrupt ACTIVE Register
        #[inline(always)]
        pub const fn iactr2(&self) -> &IACTR2 {
            &self.iactr2
        }
        ///0x308 - Interrupt ACTIVE Register
        #[inline(always)]
        pub const fn iactr3(&self) -> &IACTR3 {
            &self.iactr3
        }
        ///0x400 - Interrupt Priority Register
        #[inline(always)]
        pub const fn iprior0(&self) -> &IPRIOR0 {
            &self.iprior0
        }
        ///0x401 - Interrupt Priority Register
        #[inline(always)]
        pub const fn iprior1(&self) -> &IPRIOR1 {
            &self.iprior1
        }
        ///0x402 - Interrupt Priority Register
        #[inline(always)]
        pub const fn iprior2(&self) -> &IPRIOR2 {
            &self.iprior2
        }
        ///0x403 - Interrupt Priority Register
        #[inline(always)]
        pub const fn iprior3(&self) -> &IPRIOR3 {
            &self.iprior3
        }
        ///0x404 - Interrupt Priority Register
        #[inline(always)]
        pub const fn iprior4(&self) -> &IPRIOR4 {
            &self.iprior4
        }
        ///0x405 - Interrupt Priority Register
        #[inline(always)]
        pub const fn iprior5(&self) -> &IPRIOR5 {
            &self.iprior5
        }
        ///0x406 - Interrupt Priority Register
        #[inline(always)]
        pub const fn iprior6(&self) -> &IPRIOR6 {
            &self.iprior6
        }
        ///0x407 - Interrupt Priority Register
        #[inline(always)]
        pub const fn iprior7(&self) -> &IPRIOR7 {
            &self.iprior7
        }
        ///0x408 - Interrupt Priority Register
        #[inline(always)]
        pub const fn iprior8(&self) -> &IPRIOR8 {
            &self.iprior8
        }
        ///0x409 - Interrupt Priority Register
        #[inline(always)]
        pub const fn iprior9(&self) -> &IPRIOR9 {
            &self.iprior9
        }
        ///0x40a - Interrupt Priority Register
        #[inline(always)]
        pub const fn iprior10(&self) -> &IPRIOR10 {
            &self.iprior10
        }
        ///0x40b - Interrupt Priority Register
        #[inline(always)]
        pub const fn iprior11(&self) -> &IPRIOR11 {
            &self.iprior11
        }
        ///0x40c - Interrupt Priority Register
        #[inline(always)]
        pub const fn iprior12(&self) -> &IPRIOR12 {
            &self.iprior12
        }
        ///0x40d - Interrupt Priority Register
        #[inline(always)]
        pub const fn iprior13(&self) -> &IPRIOR13 {
            &self.iprior13
        }
        ///0x40e - Interrupt Priority Register
        #[inline(always)]
        pub const fn iprior14(&self) -> &IPRIOR14 {
            &self.iprior14
        }
        ///0x40f - Interrupt Priority Register
        #[inline(always)]
        pub const fn iprior15(&self) -> &IPRIOR15 {
            &self.iprior15
        }
        ///0x410 - Interrupt Priority Register
        #[inline(always)]
        pub const fn iprior16(&self) -> &IPRIOR16 {
            &self.iprior16
        }
        ///0x411 - Interrupt Priority Register
        #[inline(always)]
        pub const fn iprior17(&self) -> &IPRIOR17 {
            &self.iprior17
        }
        ///0x412 - Interrupt Priority Register
        #[inline(always)]
        pub const fn iprior18(&self) -> &IPRIOR18 {
            &self.iprior18
        }
        ///0x413 - Interrupt Priority Register
        #[inline(always)]
        pub const fn iprior19(&self) -> &IPRIOR19 {
            &self.iprior19
        }
        ///0x414 - Interrupt Priority Register
        #[inline(always)]
        pub const fn iprior20(&self) -> &IPRIOR20 {
            &self.iprior20
        }
        ///0x415 - Interrupt Priority Register
        #[inline(always)]
        pub const fn iprior21(&self) -> &IPRIOR21 {
            &self.iprior21
        }
        ///0x416 - Interrupt Priority Register
        #[inline(always)]
        pub const fn iprior22(&self) -> &IPRIOR22 {
            &self.iprior22
        }
        ///0x417 - Interrupt Priority Register
        #[inline(always)]
        pub const fn iprior23(&self) -> &IPRIOR23 {
            &self.iprior23
        }
        ///0x418 - Interrupt Priority Register
        #[inline(always)]
        pub const fn iprior24(&self) -> &IPRIOR24 {
            &self.iprior24
        }
        ///0x419 - Interrupt Priority Register
        #[inline(always)]
        pub const fn iprior25(&self) -> &IPRIOR25 {
            &self.iprior25
        }
        ///0x41a - Interrupt Priority Register
        #[inline(always)]
        pub const fn iprior26(&self) -> &IPRIOR26 {
            &self.iprior26
        }
        ///0x41b - Interrupt Priority Register
        #[inline(always)]
        pub const fn iprior27(&self) -> &IPRIOR27 {
            &self.iprior27
        }
        ///0x41c - Interrupt Priority Register
        #[inline(always)]
        pub const fn iprior28(&self) -> &IPRIOR28 {
            &self.iprior28
        }
        ///0x41d - Interrupt Priority Register
        #[inline(always)]
        pub const fn iprior29(&self) -> &IPRIOR29 {
            &self.iprior29
        }
        ///0x41e - Interrupt Priority Register
        #[inline(always)]
        pub const fn iprior30(&self) -> &IPRIOR30 {
            &self.iprior30
        }
        ///0x41f - Interrupt Priority Register
        #[inline(always)]
        pub const fn iprior31(&self) -> &IPRIOR31 {
            &self.iprior31
        }
        ///0x420 - Interrupt Priority Register
        #[inline(always)]
        pub const fn iprior32(&self) -> &IPRIOR32 {
            &self.iprior32
        }
        ///0x421 - Interrupt Priority Register
        #[inline(always)]
        pub const fn iprior33(&self) -> &IPRIOR33 {
            &self.iprior33
        }
        ///0x422 - Interrupt Priority Register
        #[inline(always)]
        pub const fn iprior34(&self) -> &IPRIOR34 {
            &self.iprior34
        }
        ///0x423 - Interrupt Priority Register
        #[inline(always)]
        pub const fn iprior35(&self) -> &IPRIOR35 {
            &self.iprior35
        }
        ///0x424 - Interrupt Priority Register
        #[inline(always)]
        pub const fn iprior36(&self) -> &IPRIOR36 {
            &self.iprior36
        }
        ///0x425 - Interrupt Priority Register
        #[inline(always)]
        pub const fn iprior37(&self) -> &IPRIOR37 {
            &self.iprior37
        }
        ///0x426 - Interrupt Priority Register
        #[inline(always)]
        pub const fn iprior38(&self) -> &IPRIOR38 {
            &self.iprior38
        }
        ///0x427 - Interrupt Priority Register
        #[inline(always)]
        pub const fn iprior39(&self) -> &IPRIOR39 {
            &self.iprior39
        }
        ///0x428 - Interrupt Priority Register
        #[inline(always)]
        pub const fn iprior40(&self) -> &IPRIOR40 {
            &self.iprior40
        }
        ///0x429 - Interrupt Priority Register
        #[inline(always)]
        pub const fn iprior41(&self) -> &IPRIOR41 {
            &self.iprior41
        }
        ///0x42a - Interrupt Priority Register
        #[inline(always)]
        pub const fn iprior42(&self) -> &IPRIOR42 {
            &self.iprior42
        }
        ///0x42b - Interrupt Priority Register
        #[inline(always)]
        pub const fn iprior43(&self) -> &IPRIOR43 {
            &self.iprior43
        }
        ///0x42c - Interrupt Priority Register
        #[inline(always)]
        pub const fn iprior44(&self) -> &IPRIOR44 {
            &self.iprior44
        }
        ///0x42d - Interrupt Priority Register
        #[inline(always)]
        pub const fn iprior45(&self) -> &IPRIOR45 {
            &self.iprior45
        }
        ///0x42e - Interrupt Priority Register
        #[inline(always)]
        pub const fn iprior46(&self) -> &IPRIOR46 {
            &self.iprior46
        }
        ///0x42f - Interrupt Priority Register
        #[inline(always)]
        pub const fn iprior47(&self) -> &IPRIOR47 {
            &self.iprior47
        }
        ///0x430 - Interrupt Priority Register
        #[inline(always)]
        pub const fn iprior48(&self) -> &IPRIOR48 {
            &self.iprior48
        }
        ///0x431 - Interrupt Priority Register
        #[inline(always)]
        pub const fn iprior49(&self) -> &IPRIOR49 {
            &self.iprior49
        }
        ///0x432 - Interrupt Priority Register
        #[inline(always)]
        pub const fn iprior50(&self) -> &IPRIOR50 {
            &self.iprior50
        }
        ///0x433 - Interrupt Priority Register
        #[inline(always)]
        pub const fn iprior51(&self) -> &IPRIOR51 {
            &self.iprior51
        }
        ///0x434 - Interrupt Priority Register
        #[inline(always)]
        pub const fn iprior52(&self) -> &IPRIOR52 {
            &self.iprior52
        }
        ///0x435 - Interrupt Priority Register
        #[inline(always)]
        pub const fn iprior53(&self) -> &IPRIOR53 {
            &self.iprior53
        }
        ///0x436 - Interrupt Priority Register
        #[inline(always)]
        pub const fn iprior54(&self) -> &IPRIOR54 {
            &self.iprior54
        }
        ///0x437 - Interrupt Priority Register
        #[inline(always)]
        pub const fn iprior55(&self) -> &IPRIOR55 {
            &self.iprior55
        }
        ///0x438 - Interrupt Priority Register
        #[inline(always)]
        pub const fn iprior56(&self) -> &IPRIOR56 {
            &self.iprior56
        }
        ///0x439 - Interrupt Priority Register
        #[inline(always)]
        pub const fn iprior57(&self) -> &IPRIOR57 {
            &self.iprior57
        }
        ///0x43a - Interrupt Priority Register
        #[inline(always)]
        pub const fn iprior58(&self) -> &IPRIOR58 {
            &self.iprior58
        }
        ///0x43b - Interrupt Priority Register
        #[inline(always)]
        pub const fn iprior59(&self) -> &IPRIOR59 {
            &self.iprior59
        }
        ///0x43c - Interrupt Priority Register
        #[inline(always)]
        pub const fn iprior60(&self) -> &IPRIOR60 {
            &self.iprior60
        }
        ///0x43d - Interrupt Priority Register
        #[inline(always)]
        pub const fn iprior61(&self) -> &IPRIOR61 {
            &self.iprior61
        }
        ///0x43e - Interrupt Priority Register
        #[inline(always)]
        pub const fn iprior62(&self) -> &IPRIOR62 {
            &self.iprior62
        }
        ///0x43f - Interrupt Priority Register
        #[inline(always)]
        pub const fn iprior63(&self) -> &IPRIOR63 {
            &self.iprior63
        }
        ///0x440 - Interrupt Priority Register
        #[inline(always)]
        pub const fn iprior64(&self) -> &IPRIOR64 {
            &self.iprior64
        }
        ///0x441 - Interrupt Priority Register
        #[inline(always)]
        pub const fn iprior65(&self) -> &IPRIOR65 {
            &self.iprior65
        }
        ///0x442 - Interrupt Priority Register
        #[inline(always)]
        pub const fn iprior66(&self) -> &IPRIOR66 {
            &self.iprior66
        }
        ///0x443 - Interrupt Priority Register
        #[inline(always)]
        pub const fn iprior67(&self) -> &IPRIOR67 {
            &self.iprior67
        }
        ///0x444 - Interrupt Priority Register
        #[inline(always)]
        pub const fn iprior68(&self) -> &IPRIOR68 {
            &self.iprior68
        }
        ///0xd10 - System Control Register
        #[inline(always)]
        pub const fn sctlr(&self) -> &SCTLR {
            &self.sctlr
        }
        ///0x1000 - System counter control register
        #[inline(always)]
        pub const fn stk_ctlr(&self) -> &STK_CTLR {
            &self.stk_ctlr
        }
        ///0x1004 - System START
        #[inline(always)]
        pub const fn stk_sr(&self) -> &STK_SR {
            &self.stk_sr
        }
        ///0x1008 - System counter low register
        #[inline(always)]
        pub const fn stk_cntl(&self) -> &STK_CNTL {
            &self.stk_cntl
        }
        ///0x100c - System counter high register
        #[inline(always)]
        pub const fn stk_cnth(&self) -> &STK_CNTH {
            &self.stk_cnth
        }
        ///0x1010 - System compare low register
        #[inline(always)]
        pub const fn stk_cmplr(&self) -> &STK_CMPLR {
            &self.stk_cmplr
        }
        ///0x1014 - System compare high register
        #[inline(always)]
        pub const fn stk_cmphr(&self) -> &STK_CMPHR {
            &self.stk_cmphr
        }
    }
    ///ISR1 (r) register accessor: Interrupt Status Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`isr1::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@isr1`]
    ///module
    pub type ISR1 = crate::Reg<isr1::ISR1_SPEC>;
    ///Interrupt Status Register
    pub mod isr1 {
        ///Register `ISR1` reader
        pub type R = crate::R<ISR1_SPEC>;
        ///Field `INTENSTA2_3` reader - Interrupt ID Status
        pub type INTENSTA2_3_R = crate::FieldReader;
        ///Field `INTENSTA12` reader - Interrupt ID Status
        pub type INTENSTA12_R = crate::BitReader;
        ///Field `INTENSTA14` reader - Interrupt ID Status
        pub type INTENSTA14_R = crate::BitReader;
        ///Field `INTENSTA16_31` reader - Interrupt ID Status
        pub type INTENSTA16_31_R = crate::FieldReader<u16>;
        impl R {
            ///Bits 2:3 - Interrupt ID Status
            #[inline(always)]
            pub fn intensta2_3(&self) -> INTENSTA2_3_R {
                INTENSTA2_3_R::new(((self.bits >> 2) & 3) as u8)
            }
            ///Bit 12 - Interrupt ID Status
            #[inline(always)]
            pub fn intensta12(&self) -> INTENSTA12_R {
                INTENSTA12_R::new(((self.bits >> 12) & 1) != 0)
            }
            ///Bit 14 - Interrupt ID Status
            #[inline(always)]
            pub fn intensta14(&self) -> INTENSTA14_R {
                INTENSTA14_R::new(((self.bits >> 14) & 1) != 0)
            }
            ///Bits 16:31 - Interrupt ID Status
            #[inline(always)]
            pub fn intensta16_31(&self) -> INTENSTA16_31_R {
                INTENSTA16_31_R::new(((self.bits >> 16) & 0xffff) as u16)
            }
        }
        ///Interrupt Status Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`isr1::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct ISR1_SPEC;
        impl crate::RegisterSpec for ISR1_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`isr1::R`](R) reader structure
        impl crate::Readable for ISR1_SPEC {}
        ///`reset()` method sets ISR1 to value 0x0c
        impl crate::Resettable for ISR1_SPEC {
            const RESET_VALUE: u32 = 0x0c;
        }
    }
    ///ISR2 (r) register accessor: Interrupt Status Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`isr2::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@isr2`]
    ///module
    pub type ISR2 = crate::Reg<isr2::ISR2_SPEC>;
    ///Interrupt Status Register
    pub mod isr2 {
        ///Register `ISR2` reader
        pub type R = crate::R<ISR2_SPEC>;
        ///Field `INTENSTA` reader - Interrupt ID Status
        pub type INTENSTA_R = crate::FieldReader<u32>;
        impl R {
            ///Bits 0:31 - Interrupt ID Status
            #[inline(always)]
            pub fn intensta(&self) -> INTENSTA_R {
                INTENSTA_R::new(self.bits)
            }
        }
        ///Interrupt Status Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`isr2::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct ISR2_SPEC;
        impl crate::RegisterSpec for ISR2_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`isr2::R`](R) reader structure
        impl crate::Readable for ISR2_SPEC {}
        ///`reset()` method sets ISR2 to value 0
        impl crate::Resettable for ISR2_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///ISR3 (r) register accessor: Interrupt Status Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`isr3::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@isr3`]
    ///module
    pub type ISR3 = crate::Reg<isr3::ISR3_SPEC>;
    ///Interrupt Status Register
    pub mod isr3 {
        ///Register `ISR3` reader
        pub type R = crate::R<ISR3_SPEC>;
        ///Field `INTENSTA` reader - Interrupt ID Status
        pub type INTENSTA_R = crate::FieldReader<u32>;
        impl R {
            ///Bits 0:31 - Interrupt ID Status
            #[inline(always)]
            pub fn intensta(&self) -> INTENSTA_R {
                INTENSTA_R::new(self.bits)
            }
        }
        ///Interrupt Status Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`isr3::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct ISR3_SPEC;
        impl crate::RegisterSpec for ISR3_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`isr3::R`](R) reader structure
        impl crate::Readable for ISR3_SPEC {}
        ///`reset()` method sets ISR3 to value 0
        impl crate::Resettable for ISR3_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPR1 (r) register accessor: Interrupt Pending Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`ipr1::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@ipr1`]
    ///module
    pub type IPR1 = crate::Reg<ipr1::IPR1_SPEC>;
    ///Interrupt Pending Register
    pub mod ipr1 {
        ///Register `IPR1` reader
        pub type R = crate::R<IPR1_SPEC>;
        ///Field `PENDSTA2_3` reader - PENDSTA
        pub type PENDSTA2_3_R = crate::FieldReader;
        ///Field `PENDSTA12` reader - PENDSTA
        pub type PENDSTA12_R = crate::BitReader;
        ///Field `PENDSTA14` reader - PENDSTA
        pub type PENDSTA14_R = crate::BitReader;
        ///Field `PENDSTA16_31` reader - PENDSTA
        pub type PENDSTA16_31_R = crate::FieldReader<u16>;
        impl R {
            ///Bits 2:3 - PENDSTA
            #[inline(always)]
            pub fn pendsta2_3(&self) -> PENDSTA2_3_R {
                PENDSTA2_3_R::new(((self.bits >> 2) & 3) as u8)
            }
            ///Bit 12 - PENDSTA
            #[inline(always)]
            pub fn pendsta12(&self) -> PENDSTA12_R {
                PENDSTA12_R::new(((self.bits >> 12) & 1) != 0)
            }
            ///Bit 14 - PENDSTA
            #[inline(always)]
            pub fn pendsta14(&self) -> PENDSTA14_R {
                PENDSTA14_R::new(((self.bits >> 14) & 1) != 0)
            }
            ///Bits 16:31 - PENDSTA
            #[inline(always)]
            pub fn pendsta16_31(&self) -> PENDSTA16_31_R {
                PENDSTA16_31_R::new(((self.bits >> 16) & 0xffff) as u16)
            }
        }
        ///Interrupt Pending Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`ipr1::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPR1_SPEC;
        impl crate::RegisterSpec for IPR1_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`ipr1::R`](R) reader structure
        impl crate::Readable for IPR1_SPEC {}
        ///`reset()` method sets IPR1 to value 0
        impl crate::Resettable for IPR1_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPR2 (r) register accessor: Interrupt Pending Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`ipr2::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@ipr2`]
    ///module
    pub type IPR2 = crate::Reg<ipr2::IPR2_SPEC>;
    ///Interrupt Pending Register
    pub mod ipr2 {
        ///Register `IPR2` reader
        pub type R = crate::R<IPR2_SPEC>;
        ///Field `PENDSTA` reader - PENDSTA
        pub type PENDSTA_R = crate::FieldReader<u32>;
        impl R {
            ///Bits 0:31 - PENDSTA
            #[inline(always)]
            pub fn pendsta(&self) -> PENDSTA_R {
                PENDSTA_R::new(self.bits)
            }
        }
        ///Interrupt Pending Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`ipr2::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPR2_SPEC;
        impl crate::RegisterSpec for IPR2_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`ipr2::R`](R) reader structure
        impl crate::Readable for IPR2_SPEC {}
        ///`reset()` method sets IPR2 to value 0
        impl crate::Resettable for IPR2_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPR3 (r) register accessor: Interrupt Pending Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`ipr3::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@ipr3`]
    ///module
    pub type IPR3 = crate::Reg<ipr3::IPR3_SPEC>;
    ///Interrupt Pending Register
    pub mod ipr3 {
        ///Register `IPR3` reader
        pub type R = crate::R<IPR3_SPEC>;
        ///Field `PENDSTA` reader - PENDSTA
        pub type PENDSTA_R = crate::FieldReader<u32>;
        impl R {
            ///Bits 0:31 - PENDSTA
            #[inline(always)]
            pub fn pendsta(&self) -> PENDSTA_R {
                PENDSTA_R::new(self.bits)
            }
        }
        ///Interrupt Pending Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`ipr3::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPR3_SPEC;
        impl crate::RegisterSpec for IPR3_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`ipr3::R`](R) reader structure
        impl crate::Readable for IPR3_SPEC {}
        ///`reset()` method sets IPR3 to value 0
        impl crate::Resettable for IPR3_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///ITHRESDR (rw) register accessor: Interrupt Priority Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`ithresdr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ithresdr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@ithresdr`]
    ///module
    pub type ITHRESDR = crate::Reg<ithresdr::ITHRESDR_SPEC>;
    ///Interrupt Priority Register
    pub mod ithresdr {
        ///Register `ITHRESDR` reader
        pub type R = crate::R<ITHRESDR_SPEC>;
        ///Register `ITHRESDR` writer
        pub type W = crate::W<ITHRESDR_SPEC>;
        ///Field `THRESHOLD` reader - THRESHOLD
        pub type THRESHOLD_R = crate::FieldReader;
        ///Field `THRESHOLD` writer - THRESHOLD
        pub type THRESHOLD_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            ///Bits 0:7 - THRESHOLD
            #[inline(always)]
            pub fn threshold(&self) -> THRESHOLD_R {
                THRESHOLD_R::new((self.bits & 0xff) as u8)
            }
        }
        impl W {
            ///Bits 0:7 - THRESHOLD
            #[inline(always)]
            #[must_use]
            pub fn threshold(&mut self) -> THRESHOLD_W<ITHRESDR_SPEC> {
                THRESHOLD_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`ithresdr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ithresdr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct ITHRESDR_SPEC;
        impl crate::RegisterSpec for ITHRESDR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`ithresdr::R`](R) reader structure
        impl crate::Readable for ITHRESDR_SPEC {}
        ///`write(|w| ..)` method takes [`ithresdr::W`](W) writer structure
        impl crate::Writable for ITHRESDR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets ITHRESDR to value 0
        impl crate::Resettable for ITHRESDR_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///CFGR (w) register accessor: Interrupt Config Register
    ///
    ///You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cfgr::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@cfgr`]
    ///module
    pub type CFGR = crate::Reg<cfgr::CFGR_SPEC>;
    ///Interrupt Config Register
    pub mod cfgr {
        ///Register `CFGR` writer
        pub type W = crate::W<CFGR_SPEC>;
        ///Field `RSTSYS` writer - RESETSYS
        pub type RSTSYS_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `KEYCODE` writer - KEYCODE
        pub type KEYCODE_W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl W {
            ///Bit 7 - RESETSYS
            #[inline(always)]
            #[must_use]
            pub fn rstsys(&mut self) -> RSTSYS_W<CFGR_SPEC> {
                RSTSYS_W::new(self, 7)
            }
            ///Bits 16:31 - KEYCODE
            #[inline(always)]
            #[must_use]
            pub fn keycode(&mut self) -> KEYCODE_W<CFGR_SPEC> {
                KEYCODE_W::new(self, 16)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Config Register
        ///
        ///You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cfgr::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct CFGR_SPEC;
        impl crate::RegisterSpec for CFGR_SPEC {
            type Ux = u32;
        }
        ///`write(|w| ..)` method takes [`cfgr::W`](W) writer structure
        impl crate::Writable for CFGR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets CFGR to value 0
        impl crate::Resettable for CFGR_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///GISR (r) register accessor: Interrupt Global Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`gisr::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@gisr`]
    ///module
    pub type GISR = crate::Reg<gisr::GISR_SPEC>;
    ///Interrupt Global Register
    pub mod gisr {
        ///Register `GISR` reader
        pub type R = crate::R<GISR_SPEC>;
        ///Field `NESTSTA` reader - NESTSTA
        pub type NESTSTA_R = crate::FieldReader;
        ///Field `GACTSTA` reader - GACTSTA
        pub type GACTSTA_R = crate::BitReader;
        ///Field `GPENDSTA` reader - GPENDSTA
        pub type GPENDSTA_R = crate::BitReader;
        impl R {
            ///Bits 0:7 - NESTSTA
            #[inline(always)]
            pub fn neststa(&self) -> NESTSTA_R {
                NESTSTA_R::new((self.bits & 0xff) as u8)
            }
            ///Bit 8 - GACTSTA
            #[inline(always)]
            pub fn gactsta(&self) -> GACTSTA_R {
                GACTSTA_R::new(((self.bits >> 8) & 1) != 0)
            }
            ///Bit 9 - GPENDSTA
            #[inline(always)]
            pub fn gpendsta(&self) -> GPENDSTA_R {
                GPENDSTA_R::new(((self.bits >> 9) & 1) != 0)
            }
        }
        ///Interrupt Global Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`gisr::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct GISR_SPEC;
        impl crate::RegisterSpec for GISR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`gisr::R`](R) reader structure
        impl crate::Readable for GISR_SPEC {}
        ///`reset()` method sets GISR to value 0
        impl crate::Resettable for GISR_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///VTFIDR (rw) register accessor: ID Config Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`vtfidr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`vtfidr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@vtfidr`]
    ///module
    pub type VTFIDR = crate::Reg<vtfidr::VTFIDR_SPEC>;
    ///ID Config Register
    pub mod vtfidr {
        ///Register `VTFIDR` reader
        pub type R = crate::R<VTFIDR_SPEC>;
        ///Register `VTFIDR` writer
        pub type W = crate::W<VTFIDR_SPEC>;
        ///Field `VTFID0` reader - VTFID0
        pub type VTFID0_R = crate::FieldReader;
        ///Field `VTFID0` writer - VTFID0
        pub type VTFID0_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        ///Field `VTFID1` reader - VTFID1
        pub type VTFID1_R = crate::FieldReader;
        ///Field `VTFID1` writer - VTFID1
        pub type VTFID1_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        ///Field `VTFID2` reader - VTFID2
        pub type VTFID2_R = crate::FieldReader;
        ///Field `VTFID2` writer - VTFID2
        pub type VTFID2_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        ///Field `VTFID3` reader - VTFID3
        pub type VTFID3_R = crate::FieldReader;
        ///Field `VTFID3` writer - VTFID3
        pub type VTFID3_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            ///Bits 0:7 - VTFID0
            #[inline(always)]
            pub fn vtfid0(&self) -> VTFID0_R {
                VTFID0_R::new((self.bits & 0xff) as u8)
            }
            ///Bits 8:15 - VTFID1
            #[inline(always)]
            pub fn vtfid1(&self) -> VTFID1_R {
                VTFID1_R::new(((self.bits >> 8) & 0xff) as u8)
            }
            ///Bits 16:23 - VTFID2
            #[inline(always)]
            pub fn vtfid2(&self) -> VTFID2_R {
                VTFID2_R::new(((self.bits >> 16) & 0xff) as u8)
            }
            ///Bits 24:31 - VTFID3
            #[inline(always)]
            pub fn vtfid3(&self) -> VTFID3_R {
                VTFID3_R::new(((self.bits >> 24) & 0xff) as u8)
            }
        }
        impl W {
            ///Bits 0:7 - VTFID0
            #[inline(always)]
            #[must_use]
            pub fn vtfid0(&mut self) -> VTFID0_W<VTFIDR_SPEC> {
                VTFID0_W::new(self, 0)
            }
            ///Bits 8:15 - VTFID1
            #[inline(always)]
            #[must_use]
            pub fn vtfid1(&mut self) -> VTFID1_W<VTFIDR_SPEC> {
                VTFID1_W::new(self, 8)
            }
            ///Bits 16:23 - VTFID2
            #[inline(always)]
            #[must_use]
            pub fn vtfid2(&mut self) -> VTFID2_W<VTFIDR_SPEC> {
                VTFID2_W::new(self, 16)
            }
            ///Bits 24:31 - VTFID3
            #[inline(always)]
            #[must_use]
            pub fn vtfid3(&mut self) -> VTFID3_W<VTFIDR_SPEC> {
                VTFID3_W::new(self, 24)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///ID Config Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`vtfidr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`vtfidr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct VTFIDR_SPEC;
        impl crate::RegisterSpec for VTFIDR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`vtfidr::R`](R) reader structure
        impl crate::Readable for VTFIDR_SPEC {}
        ///`write(|w| ..)` method takes [`vtfidr::W`](W) writer structure
        impl crate::Writable for VTFIDR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets VTFIDR to value 0
        impl crate::Resettable for VTFIDR_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///VTFADDRR0 (rw) register accessor: Interrupt 0 address Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`vtfaddrr0::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`vtfaddrr0::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@vtfaddrr0`]
    ///module
    pub type VTFADDRR0 = crate::Reg<vtfaddrr0::VTFADDRR0_SPEC>;
    ///Interrupt 0 address Register
    pub mod vtfaddrr0 {
        ///Register `VTFADDRR0` reader
        pub type R = crate::R<VTFADDRR0_SPEC>;
        ///Register `VTFADDRR0` writer
        pub type W = crate::W<VTFADDRR0_SPEC>;
        ///Field `VTF0EN` reader - VTF0EN
        pub type VTF0EN_R = crate::BitReader;
        ///Field `VTF0EN` writer - VTF0EN
        pub type VTF0EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `ADDR0` reader - ADDR0
        pub type ADDR0_R = crate::FieldReader<u32>;
        ///Field `ADDR0` writer - ADDR0
        pub type ADDR0_W<'a, REG> = crate::FieldWriter<'a, REG, 31, u32>;
        impl R {
            ///Bit 0 - VTF0EN
            #[inline(always)]
            pub fn vtf0en(&self) -> VTF0EN_R {
                VTF0EN_R::new((self.bits & 1) != 0)
            }
            ///Bits 1:31 - ADDR0
            #[inline(always)]
            pub fn addr0(&self) -> ADDR0_R {
                ADDR0_R::new((self.bits >> 1) & 0x7fff_ffff)
            }
        }
        impl W {
            ///Bit 0 - VTF0EN
            #[inline(always)]
            #[must_use]
            pub fn vtf0en(&mut self) -> VTF0EN_W<VTFADDRR0_SPEC> {
                VTF0EN_W::new(self, 0)
            }
            ///Bits 1:31 - ADDR0
            #[inline(always)]
            #[must_use]
            pub fn addr0(&mut self) -> ADDR0_W<VTFADDRR0_SPEC> {
                ADDR0_W::new(self, 1)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt 0 address Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`vtfaddrr0::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`vtfaddrr0::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct VTFADDRR0_SPEC;
        impl crate::RegisterSpec for VTFADDRR0_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`vtfaddrr0::R`](R) reader structure
        impl crate::Readable for VTFADDRR0_SPEC {}
        ///`write(|w| ..)` method takes [`vtfaddrr0::W`](W) writer structure
        impl crate::Writable for VTFADDRR0_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets VTFADDRR0 to value 0
        impl crate::Resettable for VTFADDRR0_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///VTFADDRR1 (rw) register accessor: Interrupt 1 address Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`vtfaddrr1::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`vtfaddrr1::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@vtfaddrr1`]
    ///module
    pub type VTFADDRR1 = crate::Reg<vtfaddrr1::VTFADDRR1_SPEC>;
    ///Interrupt 1 address Register
    pub mod vtfaddrr1 {
        ///Register `VTFADDRR1` reader
        pub type R = crate::R<VTFADDRR1_SPEC>;
        ///Register `VTFADDRR1` writer
        pub type W = crate::W<VTFADDRR1_SPEC>;
        ///Field `VTF1EN` reader - VTF1EN
        pub type VTF1EN_R = crate::BitReader;
        ///Field `VTF1EN` writer - VTF1EN
        pub type VTF1EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `ADDR1` reader - ADDR1
        pub type ADDR1_R = crate::FieldReader<u32>;
        ///Field `ADDR1` writer - ADDR1
        pub type ADDR1_W<'a, REG> = crate::FieldWriter<'a, REG, 31, u32>;
        impl R {
            ///Bit 0 - VTF1EN
            #[inline(always)]
            pub fn vtf1en(&self) -> VTF1EN_R {
                VTF1EN_R::new((self.bits & 1) != 0)
            }
            ///Bits 1:31 - ADDR1
            #[inline(always)]
            pub fn addr1(&self) -> ADDR1_R {
                ADDR1_R::new((self.bits >> 1) & 0x7fff_ffff)
            }
        }
        impl W {
            ///Bit 0 - VTF1EN
            #[inline(always)]
            #[must_use]
            pub fn vtf1en(&mut self) -> VTF1EN_W<VTFADDRR1_SPEC> {
                VTF1EN_W::new(self, 0)
            }
            ///Bits 1:31 - ADDR1
            #[inline(always)]
            #[must_use]
            pub fn addr1(&mut self) -> ADDR1_W<VTFADDRR1_SPEC> {
                ADDR1_W::new(self, 1)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt 1 address Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`vtfaddrr1::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`vtfaddrr1::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct VTFADDRR1_SPEC;
        impl crate::RegisterSpec for VTFADDRR1_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`vtfaddrr1::R`](R) reader structure
        impl crate::Readable for VTFADDRR1_SPEC {}
        ///`write(|w| ..)` method takes [`vtfaddrr1::W`](W) writer structure
        impl crate::Writable for VTFADDRR1_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets VTFADDRR1 to value 0
        impl crate::Resettable for VTFADDRR1_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///VTFADDRR2 (rw) register accessor: Interrupt 2 address Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`vtfaddrr2::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`vtfaddrr2::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@vtfaddrr2`]
    ///module
    pub type VTFADDRR2 = crate::Reg<vtfaddrr2::VTFADDRR2_SPEC>;
    ///Interrupt 2 address Register
    pub mod vtfaddrr2 {
        ///Register `VTFADDRR2` reader
        pub type R = crate::R<VTFADDRR2_SPEC>;
        ///Register `VTFADDRR2` writer
        pub type W = crate::W<VTFADDRR2_SPEC>;
        ///Field `VTF2EN` reader - VTF2EN
        pub type VTF2EN_R = crate::BitReader;
        ///Field `VTF2EN` writer - VTF2EN
        pub type VTF2EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `ADDR2` reader - ADDR2
        pub type ADDR2_R = crate::FieldReader<u32>;
        ///Field `ADDR2` writer - ADDR2
        pub type ADDR2_W<'a, REG> = crate::FieldWriter<'a, REG, 31, u32>;
        impl R {
            ///Bit 0 - VTF2EN
            #[inline(always)]
            pub fn vtf2en(&self) -> VTF2EN_R {
                VTF2EN_R::new((self.bits & 1) != 0)
            }
            ///Bits 1:31 - ADDR2
            #[inline(always)]
            pub fn addr2(&self) -> ADDR2_R {
                ADDR2_R::new((self.bits >> 1) & 0x7fff_ffff)
            }
        }
        impl W {
            ///Bit 0 - VTF2EN
            #[inline(always)]
            #[must_use]
            pub fn vtf2en(&mut self) -> VTF2EN_W<VTFADDRR2_SPEC> {
                VTF2EN_W::new(self, 0)
            }
            ///Bits 1:31 - ADDR2
            #[inline(always)]
            #[must_use]
            pub fn addr2(&mut self) -> ADDR2_W<VTFADDRR2_SPEC> {
                ADDR2_W::new(self, 1)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt 2 address Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`vtfaddrr2::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`vtfaddrr2::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct VTFADDRR2_SPEC;
        impl crate::RegisterSpec for VTFADDRR2_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`vtfaddrr2::R`](R) reader structure
        impl crate::Readable for VTFADDRR2_SPEC {}
        ///`write(|w| ..)` method takes [`vtfaddrr2::W`](W) writer structure
        impl crate::Writable for VTFADDRR2_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets VTFADDRR2 to value 0
        impl crate::Resettable for VTFADDRR2_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///VTFADDRR3 (rw) register accessor: Interrupt 3 address Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`vtfaddrr3::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`vtfaddrr3::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@vtfaddrr3`]
    ///module
    pub type VTFADDRR3 = crate::Reg<vtfaddrr3::VTFADDRR3_SPEC>;
    ///Interrupt 3 address Register
    pub mod vtfaddrr3 {
        ///Register `VTFADDRR3` reader
        pub type R = crate::R<VTFADDRR3_SPEC>;
        ///Register `VTFADDRR3` writer
        pub type W = crate::W<VTFADDRR3_SPEC>;
        ///Field `VTF3EN` reader - VTF3EN
        pub type VTF3EN_R = crate::BitReader;
        ///Field `VTF3EN` writer - VTF3EN
        pub type VTF3EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `ADDR3` reader - ADDR3
        pub type ADDR3_R = crate::FieldReader<u32>;
        ///Field `ADDR3` writer - ADDR3
        pub type ADDR3_W<'a, REG> = crate::FieldWriter<'a, REG, 31, u32>;
        impl R {
            ///Bit 0 - VTF3EN
            #[inline(always)]
            pub fn vtf3en(&self) -> VTF3EN_R {
                VTF3EN_R::new((self.bits & 1) != 0)
            }
            ///Bits 1:31 - ADDR3
            #[inline(always)]
            pub fn addr3(&self) -> ADDR3_R {
                ADDR3_R::new((self.bits >> 1) & 0x7fff_ffff)
            }
        }
        impl W {
            ///Bit 0 - VTF3EN
            #[inline(always)]
            #[must_use]
            pub fn vtf3en(&mut self) -> VTF3EN_W<VTFADDRR3_SPEC> {
                VTF3EN_W::new(self, 0)
            }
            ///Bits 1:31 - ADDR3
            #[inline(always)]
            #[must_use]
            pub fn addr3(&mut self) -> ADDR3_W<VTFADDRR3_SPEC> {
                ADDR3_W::new(self, 1)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt 3 address Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`vtfaddrr3::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`vtfaddrr3::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct VTFADDRR3_SPEC;
        impl crate::RegisterSpec for VTFADDRR3_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`vtfaddrr3::R`](R) reader structure
        impl crate::Readable for VTFADDRR3_SPEC {}
        ///`write(|w| ..)` method takes [`vtfaddrr3::W`](W) writer structure
        impl crate::Writable for VTFADDRR3_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets VTFADDRR3 to value 0
        impl crate::Resettable for VTFADDRR3_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IENR1 (w) register accessor: Interrupt Setting Register
    ///
    ///You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ienr1::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@ienr1`]
    ///module
    pub type IENR1 = crate::Reg<ienr1::IENR1_SPEC>;
    ///Interrupt Setting Register
    pub mod ienr1 {
        ///Register `IENR1` writer
        pub type W = crate::W<IENR1_SPEC>;
        ///Field `INTEN12` writer - INTEN12
        pub type INTEN12_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `INTEN14` writer - INTEN14
        pub type INTEN14_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `INTEN16_31` writer - INTEN16_31
        pub type INTEN16_31_W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl W {
            ///Bit 12 - INTEN12
            #[inline(always)]
            #[must_use]
            pub fn inten12(&mut self) -> INTEN12_W<IENR1_SPEC> {
                INTEN12_W::new(self, 12)
            }
            ///Bit 14 - INTEN14
            #[inline(always)]
            #[must_use]
            pub fn inten14(&mut self) -> INTEN14_W<IENR1_SPEC> {
                INTEN14_W::new(self, 14)
            }
            ///Bits 16:31 - INTEN16_31
            #[inline(always)]
            #[must_use]
            pub fn inten16_31(&mut self) -> INTEN16_31_W<IENR1_SPEC> {
                INTEN16_31_W::new(self, 16)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Setting Register
        ///
        ///You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ienr1::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IENR1_SPEC;
        impl crate::RegisterSpec for IENR1_SPEC {
            type Ux = u32;
        }
        ///`write(|w| ..)` method takes [`ienr1::W`](W) writer structure
        impl crate::Writable for IENR1_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IENR1 to value 0
        impl crate::Resettable for IENR1_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IENR2 (w) register accessor: Interrupt Setting Register
    ///
    ///You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ienr2::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@ienr2`]
    ///module
    pub type IENR2 = crate::Reg<ienr2::IENR2_SPEC>;
    ///Interrupt Setting Register
    pub mod ienr2 {
        ///Register `IENR2` writer
        pub type W = crate::W<IENR2_SPEC>;
        ///Field `INTEN` writer - INTEN
        pub type INTEN_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl W {
            ///Bits 0:31 - INTEN
            #[inline(always)]
            #[must_use]
            pub fn inten(&mut self) -> INTEN_W<IENR2_SPEC> {
                INTEN_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Setting Register
        ///
        ///You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ienr2::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IENR2_SPEC;
        impl crate::RegisterSpec for IENR2_SPEC {
            type Ux = u32;
        }
        ///`write(|w| ..)` method takes [`ienr2::W`](W) writer structure
        impl crate::Writable for IENR2_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IENR2 to value 0
        impl crate::Resettable for IENR2_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IENR3 (w) register accessor: Interrupt Setting Register
    ///
    ///You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ienr3::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@ienr3`]
    ///module
    pub type IENR3 = crate::Reg<ienr3::IENR3_SPEC>;
    ///Interrupt Setting Register
    pub mod ienr3 {
        ///Register `IENR3` writer
        pub type W = crate::W<IENR3_SPEC>;
        ///Field `INTEN` writer - INTEN
        pub type INTEN_W<'a, REG> = crate::FieldWriter<'a, REG, 5>;
        impl W {
            ///Bits 0:4 - INTEN
            #[inline(always)]
            #[must_use]
            pub fn inten(&mut self) -> INTEN_W<IENR3_SPEC> {
                INTEN_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Setting Register
        ///
        ///You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ienr3::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IENR3_SPEC;
        impl crate::RegisterSpec for IENR3_SPEC {
            type Ux = u32;
        }
        ///`write(|w| ..)` method takes [`ienr3::W`](W) writer structure
        impl crate::Writable for IENR3_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IENR3 to value 0
        impl crate::Resettable for IENR3_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IRER1 (w) register accessor: Interrupt Clear Register
    ///
    ///You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`irer1::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@irer1`]
    ///module
    pub type IRER1 = crate::Reg<irer1::IRER1_SPEC>;
    ///Interrupt Clear Register
    pub mod irer1 {
        ///Register `IRER1` writer
        pub type W = crate::W<IRER1_SPEC>;
        ///Field `INTRSET12` writer - INTRSET
        pub type INTRSET12_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `INTRSET14` writer - INTRSET
        pub type INTRSET14_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `INTRSET16_31` writer - INTRSET
        pub type INTRSET16_31_W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl W {
            ///Bit 12 - INTRSET
            #[inline(always)]
            #[must_use]
            pub fn intrset12(&mut self) -> INTRSET12_W<IRER1_SPEC> {
                INTRSET12_W::new(self, 12)
            }
            ///Bit 14 - INTRSET
            #[inline(always)]
            #[must_use]
            pub fn intrset14(&mut self) -> INTRSET14_W<IRER1_SPEC> {
                INTRSET14_W::new(self, 14)
            }
            ///Bits 16:31 - INTRSET
            #[inline(always)]
            #[must_use]
            pub fn intrset16_31(&mut self) -> INTRSET16_31_W<IRER1_SPEC> {
                INTRSET16_31_W::new(self, 16)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Clear Register
        ///
        ///You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`irer1::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IRER1_SPEC;
        impl crate::RegisterSpec for IRER1_SPEC {
            type Ux = u32;
        }
        ///`write(|w| ..)` method takes [`irer1::W`](W) writer structure
        impl crate::Writable for IRER1_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IRER1 to value 0
        impl crate::Resettable for IRER1_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IRER2 (w) register accessor: Interrupt Clear Register
    ///
    ///You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`irer2::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@irer2`]
    ///module
    pub type IRER2 = crate::Reg<irer2::IRER2_SPEC>;
    ///Interrupt Clear Register
    pub mod irer2 {
        ///Register `IRER2` writer
        pub type W = crate::W<IRER2_SPEC>;
        ///Field `INTRSET` writer - INTRSET
        pub type INTRSET_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl W {
            ///Bits 0:31 - INTRSET
            #[inline(always)]
            #[must_use]
            pub fn intrset(&mut self) -> INTRSET_W<IRER2_SPEC> {
                INTRSET_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Clear Register
        ///
        ///You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`irer2::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IRER2_SPEC;
        impl crate::RegisterSpec for IRER2_SPEC {
            type Ux = u32;
        }
        ///`write(|w| ..)` method takes [`irer2::W`](W) writer structure
        impl crate::Writable for IRER2_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IRER2 to value 0
        impl crate::Resettable for IRER2_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IRER3 (w) register accessor: Interrupt Clear Register
    ///
    ///You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`irer3::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@irer3`]
    ///module
    pub type IRER3 = crate::Reg<irer3::IRER3_SPEC>;
    ///Interrupt Clear Register
    pub mod irer3 {
        ///Register `IRER3` writer
        pub type W = crate::W<IRER3_SPEC>;
        ///Field `INTRSET` writer - INTRSET
        pub type INTRSET_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl W {
            ///Bits 0:31 - INTRSET
            #[inline(always)]
            #[must_use]
            pub fn intrset(&mut self) -> INTRSET_W<IRER3_SPEC> {
                INTRSET_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Clear Register
        ///
        ///You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`irer3::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IRER3_SPEC;
        impl crate::RegisterSpec for IRER3_SPEC {
            type Ux = u32;
        }
        ///`write(|w| ..)` method takes [`irer3::W`](W) writer structure
        impl crate::Writable for IRER3_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IRER3 to value 0
        impl crate::Resettable for IRER3_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPSR1 (w) register accessor: Interrupt Pending Register
    ///
    ///You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ipsr1::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@ipsr1`]
    ///module
    pub type IPSR1 = crate::Reg<ipsr1::IPSR1_SPEC>;
    ///Interrupt Pending Register
    pub mod ipsr1 {
        ///Register `IPSR1` writer
        pub type W = crate::W<IPSR1_SPEC>;
        ///Field `PENDSET2_3` writer - PENDSET
        pub type PENDSET2_3_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `PENDSET12` writer - PENDSET
        pub type PENDSET12_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PENDSET14` writer - PENDSET
        pub type PENDSET14_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PENDSET16_31` writer - PENDSET
        pub type PENDSET16_31_W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl W {
            ///Bits 2:3 - PENDSET
            #[inline(always)]
            #[must_use]
            pub fn pendset2_3(&mut self) -> PENDSET2_3_W<IPSR1_SPEC> {
                PENDSET2_3_W::new(self, 2)
            }
            ///Bit 12 - PENDSET
            #[inline(always)]
            #[must_use]
            pub fn pendset12(&mut self) -> PENDSET12_W<IPSR1_SPEC> {
                PENDSET12_W::new(self, 12)
            }
            ///Bit 14 - PENDSET
            #[inline(always)]
            #[must_use]
            pub fn pendset14(&mut self) -> PENDSET14_W<IPSR1_SPEC> {
                PENDSET14_W::new(self, 14)
            }
            ///Bits 16:31 - PENDSET
            #[inline(always)]
            #[must_use]
            pub fn pendset16_31(&mut self) -> PENDSET16_31_W<IPSR1_SPEC> {
                PENDSET16_31_W::new(self, 16)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Pending Register
        ///
        ///You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ipsr1::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPSR1_SPEC;
        impl crate::RegisterSpec for IPSR1_SPEC {
            type Ux = u32;
        }
        ///`write(|w| ..)` method takes [`ipsr1::W`](W) writer structure
        impl crate::Writable for IPSR1_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPSR1 to value 0
        impl crate::Resettable for IPSR1_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPSR2 (w) register accessor: Interrupt Pending Register
    ///
    ///You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ipsr2::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@ipsr2`]
    ///module
    pub type IPSR2 = crate::Reg<ipsr2::IPSR2_SPEC>;
    ///Interrupt Pending Register
    pub mod ipsr2 {
        ///Register `IPSR2` writer
        pub type W = crate::W<IPSR2_SPEC>;
        ///Field `PENDSET` writer - PENDSET
        pub type PENDSET_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl W {
            ///Bits 0:31 - PENDSET
            #[inline(always)]
            #[must_use]
            pub fn pendset(&mut self) -> PENDSET_W<IPSR2_SPEC> {
                PENDSET_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Pending Register
        ///
        ///You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ipsr2::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPSR2_SPEC;
        impl crate::RegisterSpec for IPSR2_SPEC {
            type Ux = u32;
        }
        ///`write(|w| ..)` method takes [`ipsr2::W`](W) writer structure
        impl crate::Writable for IPSR2_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPSR2 to value 0
        impl crate::Resettable for IPSR2_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPSR3 (w) register accessor: Interrupt Pending Register
    ///
    ///You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ipsr3::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@ipsr3`]
    ///module
    pub type IPSR3 = crate::Reg<ipsr3::IPSR3_SPEC>;
    ///Interrupt Pending Register
    pub mod ipsr3 {
        ///Register `IPSR3` writer
        pub type W = crate::W<IPSR3_SPEC>;
        ///Field `PENDSET` writer - PENDSET
        pub type PENDSET_W<'a, REG> = crate::FieldWriter<'a, REG, 5>;
        impl W {
            ///Bits 0:4 - PENDSET
            #[inline(always)]
            #[must_use]
            pub fn pendset(&mut self) -> PENDSET_W<IPSR3_SPEC> {
                PENDSET_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Pending Register
        ///
        ///You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ipsr3::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPSR3_SPEC;
        impl crate::RegisterSpec for IPSR3_SPEC {
            type Ux = u32;
        }
        ///`write(|w| ..)` method takes [`ipsr3::W`](W) writer structure
        impl crate::Writable for IPSR3_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPSR3 to value 0
        impl crate::Resettable for IPSR3_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRR1 (w) register accessor: Interrupt Pending Clear Register
    ///
    ///You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprr1::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprr1`]
    ///module
    pub type IPRR1 = crate::Reg<iprr1::IPRR1_SPEC>;
    ///Interrupt Pending Clear Register
    pub mod iprr1 {
        ///Register `IPRR1` writer
        pub type W = crate::W<IPRR1_SPEC>;
        ///Field `PENDRST2_3` writer - PENDRESET
        pub type PENDRST2_3_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `PENDRST12` writer - PENDRESET
        pub type PENDRST12_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PENDRST14` writer - PENDRESET
        pub type PENDRST14_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PENDRST16_31` writer - PENDRESET
        pub type PENDRST16_31_W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl W {
            ///Bits 2:3 - PENDRESET
            #[inline(always)]
            #[must_use]
            pub fn pendrst2_3(&mut self) -> PENDRST2_3_W<IPRR1_SPEC> {
                PENDRST2_3_W::new(self, 2)
            }
            ///Bit 12 - PENDRESET
            #[inline(always)]
            #[must_use]
            pub fn pendrst12(&mut self) -> PENDRST12_W<IPRR1_SPEC> {
                PENDRST12_W::new(self, 12)
            }
            ///Bit 14 - PENDRESET
            #[inline(always)]
            #[must_use]
            pub fn pendrst14(&mut self) -> PENDRST14_W<IPRR1_SPEC> {
                PENDRST14_W::new(self, 14)
            }
            ///Bits 16:31 - PENDRESET
            #[inline(always)]
            #[must_use]
            pub fn pendrst16_31(&mut self) -> PENDRST16_31_W<IPRR1_SPEC> {
                PENDRST16_31_W::new(self, 16)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Pending Clear Register
        ///
        ///You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprr1::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRR1_SPEC;
        impl crate::RegisterSpec for IPRR1_SPEC {
            type Ux = u32;
        }
        ///`write(|w| ..)` method takes [`iprr1::W`](W) writer structure
        impl crate::Writable for IPRR1_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRR1 to value 0
        impl crate::Resettable for IPRR1_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRR2 (w) register accessor: Interrupt Pending Clear Register
    ///
    ///You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprr2::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprr2`]
    ///module
    pub type IPRR2 = crate::Reg<iprr2::IPRR2_SPEC>;
    ///Interrupt Pending Clear Register
    pub mod iprr2 {
        ///Register `IPRR2` writer
        pub type W = crate::W<IPRR2_SPEC>;
        ///Field `PENDRST` writer - PENDRESET
        pub type PENDRST_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl W {
            ///Bits 0:31 - PENDRESET
            #[inline(always)]
            #[must_use]
            pub fn pendrst(&mut self) -> PENDRST_W<IPRR2_SPEC> {
                PENDRST_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Pending Clear Register
        ///
        ///You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprr2::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRR2_SPEC;
        impl crate::RegisterSpec for IPRR2_SPEC {
            type Ux = u32;
        }
        ///`write(|w| ..)` method takes [`iprr2::W`](W) writer structure
        impl crate::Writable for IPRR2_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRR2 to value 0
        impl crate::Resettable for IPRR2_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRR3 (w) register accessor: Interrupt Pending Clear Register
    ///
    ///You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprr3::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprr3`]
    ///module
    pub type IPRR3 = crate::Reg<iprr3::IPRR3_SPEC>;
    ///Interrupt Pending Clear Register
    pub mod iprr3 {
        ///Register `IPRR3` writer
        pub type W = crate::W<IPRR3_SPEC>;
        ///Field `PENDRST` writer - PENDRESET
        pub type PENDRST_W<'a, REG> = crate::FieldWriter<'a, REG, 5>;
        impl W {
            ///Bits 0:4 - PENDRESET
            #[inline(always)]
            #[must_use]
            pub fn pendrst(&mut self) -> PENDRST_W<IPRR3_SPEC> {
                PENDRST_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Pending Clear Register
        ///
        ///You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprr3::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRR3_SPEC;
        impl crate::RegisterSpec for IPRR3_SPEC {
            type Ux = u32;
        }
        ///`write(|w| ..)` method takes [`iprr3::W`](W) writer structure
        impl crate::Writable for IPRR3_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRR3 to value 0
        impl crate::Resettable for IPRR3_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IACTR1 (w) register accessor: Interrupt ACTIVE Register
    ///
    ///You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iactr1::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iactr1`]
    ///module
    pub type IACTR1 = crate::Reg<iactr1::IACTR1_SPEC>;
    ///Interrupt ACTIVE Register
    pub mod iactr1 {
        ///Register `IACTR1` writer
        pub type W = crate::W<IACTR1_SPEC>;
        ///Field `IACTS2_3` writer - IACTS
        pub type IACTS2_3_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `IACTS12` writer - IACTS
        pub type IACTS12_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `IACTS14` writer - IACTS
        pub type IACTS14_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `IACTS16_31` writer - IACTS
        pub type IACTS16_31_W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl W {
            ///Bits 2:3 - IACTS
            #[inline(always)]
            #[must_use]
            pub fn iacts2_3(&mut self) -> IACTS2_3_W<IACTR1_SPEC> {
                IACTS2_3_W::new(self, 2)
            }
            ///Bit 12 - IACTS
            #[inline(always)]
            #[must_use]
            pub fn iacts12(&mut self) -> IACTS12_W<IACTR1_SPEC> {
                IACTS12_W::new(self, 12)
            }
            ///Bit 14 - IACTS
            #[inline(always)]
            #[must_use]
            pub fn iacts14(&mut self) -> IACTS14_W<IACTR1_SPEC> {
                IACTS14_W::new(self, 14)
            }
            ///Bits 16:31 - IACTS
            #[inline(always)]
            #[must_use]
            pub fn iacts16_31(&mut self) -> IACTS16_31_W<IACTR1_SPEC> {
                IACTS16_31_W::new(self, 16)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt ACTIVE Register
        ///
        ///You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iactr1::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IACTR1_SPEC;
        impl crate::RegisterSpec for IACTR1_SPEC {
            type Ux = u32;
        }
        ///`write(|w| ..)` method takes [`iactr1::W`](W) writer structure
        impl crate::Writable for IACTR1_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IACTR1 to value 0
        impl crate::Resettable for IACTR1_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IACTR2 (w) register accessor: Interrupt ACTIVE Register
    ///
    ///You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iactr2::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iactr2`]
    ///module
    pub type IACTR2 = crate::Reg<iactr2::IACTR2_SPEC>;
    ///Interrupt ACTIVE Register
    pub mod iactr2 {
        ///Register `IACTR2` writer
        pub type W = crate::W<IACTR2_SPEC>;
        ///Field `IACTS` writer - IACTS
        pub type IACTS_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl W {
            ///Bits 0:31 - IACTS
            #[inline(always)]
            #[must_use]
            pub fn iacts(&mut self) -> IACTS_W<IACTR2_SPEC> {
                IACTS_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt ACTIVE Register
        ///
        ///You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iactr2::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IACTR2_SPEC;
        impl crate::RegisterSpec for IACTR2_SPEC {
            type Ux = u32;
        }
        ///`write(|w| ..)` method takes [`iactr2::W`](W) writer structure
        impl crate::Writable for IACTR2_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IACTR2 to value 0
        impl crate::Resettable for IACTR2_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IACTR3 (w) register accessor: Interrupt ACTIVE Register
    ///
    ///You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iactr3::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iactr3`]
    ///module
    pub type IACTR3 = crate::Reg<iactr3::IACTR3_SPEC>;
    ///Interrupt ACTIVE Register
    pub mod iactr3 {
        ///Register `IACTR3` writer
        pub type W = crate::W<IACTR3_SPEC>;
        ///Field `IACTS` writer - IACTS
        pub type IACTS_W<'a, REG> = crate::FieldWriter<'a, REG, 5>;
        impl W {
            ///Bits 0:4 - IACTS
            #[inline(always)]
            #[must_use]
            pub fn iacts(&mut self) -> IACTS_W<IACTR3_SPEC> {
                IACTS_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt ACTIVE Register
        ///
        ///You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iactr3::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IACTR3_SPEC;
        impl crate::RegisterSpec for IACTR3_SPEC {
            type Ux = u32;
        }
        ///`write(|w| ..)` method takes [`iactr3::W`](W) writer structure
        impl crate::Writable for IACTR3_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IACTR3 to value 0
        impl crate::Resettable for IACTR3_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR0 (rw) register accessor: Interrupt Priority Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior0::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior0::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior0`]
    ///module
    pub type IPRIOR0 = crate::Reg<iprior0::IPRIOR0_SPEC>;
    ///Interrupt Priority Register
    pub mod iprior0 {
        ///Register `IPRIOR0` reader
        pub type R = crate::R<IPRIOR0_SPEC>;
        ///Register `IPRIOR0` writer
        pub type W = crate::W<IPRIOR0_SPEC>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<IPRIOR0_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                core::fmt::Debug::fmt(&self.read(), f)
            }
        }
        impl W {
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior0::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior0::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR0_SPEC;
        impl crate::RegisterSpec for IPRIOR0_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`iprior0::R`](R) reader structure
        impl crate::Readable for IPRIOR0_SPEC {}
        ///`write(|w| ..)` method takes [`iprior0::W`](W) writer structure
        impl crate::Writable for IPRIOR0_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets IPRIOR0 to value 0
        impl crate::Resettable for IPRIOR0_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///IPRIOR1 (rw) register accessor: Interrupt Priority Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior1::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior1::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior1`]
    ///module
    pub type IPRIOR1 = crate::Reg<iprior1::IPRIOR1_SPEC>;
    ///Interrupt Priority Register
    pub mod iprior1 {
        ///Register `IPRIOR1` reader
        pub type R = crate::R<IPRIOR1_SPEC>;
        ///Register `IPRIOR1` writer
        pub type W = crate::W<IPRIOR1_SPEC>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<IPRIOR1_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                core::fmt::Debug::fmt(&self.read(), f)
            }
        }
        impl W {
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior1::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior1::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR1_SPEC;
        impl crate::RegisterSpec for IPRIOR1_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`iprior1::R`](R) reader structure
        impl crate::Readable for IPRIOR1_SPEC {}
        ///`write(|w| ..)` method takes [`iprior1::W`](W) writer structure
        impl crate::Writable for IPRIOR1_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets IPRIOR1 to value 0
        impl crate::Resettable for IPRIOR1_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///IPRIOR2 (rw) register accessor: Interrupt Priority Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior2::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior2::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior2`]
    ///module
    pub type IPRIOR2 = crate::Reg<iprior2::IPRIOR2_SPEC>;
    ///Interrupt Priority Register
    pub mod iprior2 {
        ///Register `IPRIOR2` reader
        pub type R = crate::R<IPRIOR2_SPEC>;
        ///Register `IPRIOR2` writer
        pub type W = crate::W<IPRIOR2_SPEC>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<IPRIOR2_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                core::fmt::Debug::fmt(&self.read(), f)
            }
        }
        impl W {
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior2::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior2::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR2_SPEC;
        impl crate::RegisterSpec for IPRIOR2_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`iprior2::R`](R) reader structure
        impl crate::Readable for IPRIOR2_SPEC {}
        ///`write(|w| ..)` method takes [`iprior2::W`](W) writer structure
        impl crate::Writable for IPRIOR2_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets IPRIOR2 to value 0
        impl crate::Resettable for IPRIOR2_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///IPRIOR3 (rw) register accessor: Interrupt Priority Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior3::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior3::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior3`]
    ///module
    pub type IPRIOR3 = crate::Reg<iprior3::IPRIOR3_SPEC>;
    ///Interrupt Priority Register
    pub mod iprior3 {
        ///Register `IPRIOR3` reader
        pub type R = crate::R<IPRIOR3_SPEC>;
        ///Register `IPRIOR3` writer
        pub type W = crate::W<IPRIOR3_SPEC>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<IPRIOR3_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                core::fmt::Debug::fmt(&self.read(), f)
            }
        }
        impl W {
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior3::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior3::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR3_SPEC;
        impl crate::RegisterSpec for IPRIOR3_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`iprior3::R`](R) reader structure
        impl crate::Readable for IPRIOR3_SPEC {}
        ///`write(|w| ..)` method takes [`iprior3::W`](W) writer structure
        impl crate::Writable for IPRIOR3_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets IPRIOR3 to value 0
        impl crate::Resettable for IPRIOR3_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///IPRIOR4 (rw) register accessor: Interrupt Priority Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior4::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior4::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior4`]
    ///module
    pub type IPRIOR4 = crate::Reg<iprior4::IPRIOR4_SPEC>;
    ///Interrupt Priority Register
    pub mod iprior4 {
        ///Register `IPRIOR4` reader
        pub type R = crate::R<IPRIOR4_SPEC>;
        ///Register `IPRIOR4` writer
        pub type W = crate::W<IPRIOR4_SPEC>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<IPRIOR4_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                core::fmt::Debug::fmt(&self.read(), f)
            }
        }
        impl W {
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior4::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior4::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR4_SPEC;
        impl crate::RegisterSpec for IPRIOR4_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`iprior4::R`](R) reader structure
        impl crate::Readable for IPRIOR4_SPEC {}
        ///`write(|w| ..)` method takes [`iprior4::W`](W) writer structure
        impl crate::Writable for IPRIOR4_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets IPRIOR4 to value 0
        impl crate::Resettable for IPRIOR4_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///IPRIOR5 (rw) register accessor: Interrupt Priority Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior5::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior5::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior5`]
    ///module
    pub type IPRIOR5 = crate::Reg<iprior5::IPRIOR5_SPEC>;
    ///Interrupt Priority Register
    pub mod iprior5 {
        ///Register `IPRIOR5` reader
        pub type R = crate::R<IPRIOR5_SPEC>;
        ///Register `IPRIOR5` writer
        pub type W = crate::W<IPRIOR5_SPEC>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<IPRIOR5_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                core::fmt::Debug::fmt(&self.read(), f)
            }
        }
        impl W {
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior5::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior5::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR5_SPEC;
        impl crate::RegisterSpec for IPRIOR5_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`iprior5::R`](R) reader structure
        impl crate::Readable for IPRIOR5_SPEC {}
        ///`write(|w| ..)` method takes [`iprior5::W`](W) writer structure
        impl crate::Writable for IPRIOR5_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets IPRIOR5 to value 0
        impl crate::Resettable for IPRIOR5_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///IPRIOR6 (rw) register accessor: Interrupt Priority Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior6::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior6::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior6`]
    ///module
    pub type IPRIOR6 = crate::Reg<iprior6::IPRIOR6_SPEC>;
    ///Interrupt Priority Register
    pub mod iprior6 {
        ///Register `IPRIOR6` reader
        pub type R = crate::R<IPRIOR6_SPEC>;
        ///Register `IPRIOR6` writer
        pub type W = crate::W<IPRIOR6_SPEC>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<IPRIOR6_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                core::fmt::Debug::fmt(&self.read(), f)
            }
        }
        impl W {
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior6::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior6::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR6_SPEC;
        impl crate::RegisterSpec for IPRIOR6_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`iprior6::R`](R) reader structure
        impl crate::Readable for IPRIOR6_SPEC {}
        ///`write(|w| ..)` method takes [`iprior6::W`](W) writer structure
        impl crate::Writable for IPRIOR6_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets IPRIOR6 to value 0
        impl crate::Resettable for IPRIOR6_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///IPRIOR7 (rw) register accessor: Interrupt Priority Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior7::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior7::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior7`]
    ///module
    pub type IPRIOR7 = crate::Reg<iprior7::IPRIOR7_SPEC>;
    ///Interrupt Priority Register
    pub mod iprior7 {
        ///Register `IPRIOR7` reader
        pub type R = crate::R<IPRIOR7_SPEC>;
        ///Register `IPRIOR7` writer
        pub type W = crate::W<IPRIOR7_SPEC>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<IPRIOR7_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                core::fmt::Debug::fmt(&self.read(), f)
            }
        }
        impl W {
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior7::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior7::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR7_SPEC;
        impl crate::RegisterSpec for IPRIOR7_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`iprior7::R`](R) reader structure
        impl crate::Readable for IPRIOR7_SPEC {}
        ///`write(|w| ..)` method takes [`iprior7::W`](W) writer structure
        impl crate::Writable for IPRIOR7_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets IPRIOR7 to value 0
        impl crate::Resettable for IPRIOR7_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///IPRIOR8 (rw) register accessor: Interrupt Priority Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior8::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior8::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior8`]
    ///module
    pub type IPRIOR8 = crate::Reg<iprior8::IPRIOR8_SPEC>;
    ///Interrupt Priority Register
    pub mod iprior8 {
        ///Register `IPRIOR8` reader
        pub type R = crate::R<IPRIOR8_SPEC>;
        ///Register `IPRIOR8` writer
        pub type W = crate::W<IPRIOR8_SPEC>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<IPRIOR8_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                core::fmt::Debug::fmt(&self.read(), f)
            }
        }
        impl W {
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior8::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior8::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR8_SPEC;
        impl crate::RegisterSpec for IPRIOR8_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`iprior8::R`](R) reader structure
        impl crate::Readable for IPRIOR8_SPEC {}
        ///`write(|w| ..)` method takes [`iprior8::W`](W) writer structure
        impl crate::Writable for IPRIOR8_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets IPRIOR8 to value 0
        impl crate::Resettable for IPRIOR8_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///IPRIOR9 (rw) register accessor: Interrupt Priority Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior9::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior9::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior9`]
    ///module
    pub type IPRIOR9 = crate::Reg<iprior9::IPRIOR9_SPEC>;
    ///Interrupt Priority Register
    pub mod iprior9 {
        ///Register `IPRIOR9` reader
        pub type R = crate::R<IPRIOR9_SPEC>;
        ///Register `IPRIOR9` writer
        pub type W = crate::W<IPRIOR9_SPEC>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<IPRIOR9_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                core::fmt::Debug::fmt(&self.read(), f)
            }
        }
        impl W {
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior9::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior9::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR9_SPEC;
        impl crate::RegisterSpec for IPRIOR9_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`iprior9::R`](R) reader structure
        impl crate::Readable for IPRIOR9_SPEC {}
        ///`write(|w| ..)` method takes [`iprior9::W`](W) writer structure
        impl crate::Writable for IPRIOR9_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets IPRIOR9 to value 0
        impl crate::Resettable for IPRIOR9_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///IPRIOR10 (rw) register accessor: Interrupt Priority Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior10::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior10::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior10`]
    ///module
    pub type IPRIOR10 = crate::Reg<iprior10::IPRIOR10_SPEC>;
    ///Interrupt Priority Register
    pub mod iprior10 {
        ///Register `IPRIOR10` reader
        pub type R = crate::R<IPRIOR10_SPEC>;
        ///Register `IPRIOR10` writer
        pub type W = crate::W<IPRIOR10_SPEC>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<IPRIOR10_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                core::fmt::Debug::fmt(&self.read(), f)
            }
        }
        impl W {
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior10::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior10::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR10_SPEC;
        impl crate::RegisterSpec for IPRIOR10_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`iprior10::R`](R) reader structure
        impl crate::Readable for IPRIOR10_SPEC {}
        ///`write(|w| ..)` method takes [`iprior10::W`](W) writer structure
        impl crate::Writable for IPRIOR10_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets IPRIOR10 to value 0
        impl crate::Resettable for IPRIOR10_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///IPRIOR11 (rw) register accessor: Interrupt Priority Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior11::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior11::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior11`]
    ///module
    pub type IPRIOR11 = crate::Reg<iprior11::IPRIOR11_SPEC>;
    ///Interrupt Priority Register
    pub mod iprior11 {
        ///Register `IPRIOR11` reader
        pub type R = crate::R<IPRIOR11_SPEC>;
        ///Register `IPRIOR11` writer
        pub type W = crate::W<IPRIOR11_SPEC>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<IPRIOR11_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                core::fmt::Debug::fmt(&self.read(), f)
            }
        }
        impl W {
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior11::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior11::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR11_SPEC;
        impl crate::RegisterSpec for IPRIOR11_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`iprior11::R`](R) reader structure
        impl crate::Readable for IPRIOR11_SPEC {}
        ///`write(|w| ..)` method takes [`iprior11::W`](W) writer structure
        impl crate::Writable for IPRIOR11_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets IPRIOR11 to value 0
        impl crate::Resettable for IPRIOR11_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///IPRIOR12 (rw) register accessor: Interrupt Priority Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior12::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior12::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior12`]
    ///module
    pub type IPRIOR12 = crate::Reg<iprior12::IPRIOR12_SPEC>;
    ///Interrupt Priority Register
    pub mod iprior12 {
        ///Register `IPRIOR12` reader
        pub type R = crate::R<IPRIOR12_SPEC>;
        ///Register `IPRIOR12` writer
        pub type W = crate::W<IPRIOR12_SPEC>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<IPRIOR12_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                core::fmt::Debug::fmt(&self.read(), f)
            }
        }
        impl W {
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior12::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior12::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR12_SPEC;
        impl crate::RegisterSpec for IPRIOR12_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`iprior12::R`](R) reader structure
        impl crate::Readable for IPRIOR12_SPEC {}
        ///`write(|w| ..)` method takes [`iprior12::W`](W) writer structure
        impl crate::Writable for IPRIOR12_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets IPRIOR12 to value 0
        impl crate::Resettable for IPRIOR12_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///IPRIOR13 (rw) register accessor: Interrupt Priority Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior13::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior13::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior13`]
    ///module
    pub type IPRIOR13 = crate::Reg<iprior13::IPRIOR13_SPEC>;
    ///Interrupt Priority Register
    pub mod iprior13 {
        ///Register `IPRIOR13` reader
        pub type R = crate::R<IPRIOR13_SPEC>;
        ///Register `IPRIOR13` writer
        pub type W = crate::W<IPRIOR13_SPEC>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<IPRIOR13_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                core::fmt::Debug::fmt(&self.read(), f)
            }
        }
        impl W {
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior13::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior13::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR13_SPEC;
        impl crate::RegisterSpec for IPRIOR13_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`iprior13::R`](R) reader structure
        impl crate::Readable for IPRIOR13_SPEC {}
        ///`write(|w| ..)` method takes [`iprior13::W`](W) writer structure
        impl crate::Writable for IPRIOR13_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets IPRIOR13 to value 0
        impl crate::Resettable for IPRIOR13_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///IPRIOR14 (rw) register accessor: Interrupt Priority Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior14::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior14::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior14`]
    ///module
    pub type IPRIOR14 = crate::Reg<iprior14::IPRIOR14_SPEC>;
    ///Interrupt Priority Register
    pub mod iprior14 {
        ///Register `IPRIOR14` reader
        pub type R = crate::R<IPRIOR14_SPEC>;
        ///Register `IPRIOR14` writer
        pub type W = crate::W<IPRIOR14_SPEC>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<IPRIOR14_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                core::fmt::Debug::fmt(&self.read(), f)
            }
        }
        impl W {
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior14::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior14::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR14_SPEC;
        impl crate::RegisterSpec for IPRIOR14_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`iprior14::R`](R) reader structure
        impl crate::Readable for IPRIOR14_SPEC {}
        ///`write(|w| ..)` method takes [`iprior14::W`](W) writer structure
        impl crate::Writable for IPRIOR14_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets IPRIOR14 to value 0
        impl crate::Resettable for IPRIOR14_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///IPRIOR15 (rw) register accessor: Interrupt Priority Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior15::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior15::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior15`]
    ///module
    pub type IPRIOR15 = crate::Reg<iprior15::IPRIOR15_SPEC>;
    ///Interrupt Priority Register
    pub mod iprior15 {
        ///Register `IPRIOR15` reader
        pub type R = crate::R<IPRIOR15_SPEC>;
        ///Register `IPRIOR15` writer
        pub type W = crate::W<IPRIOR15_SPEC>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<IPRIOR15_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                core::fmt::Debug::fmt(&self.read(), f)
            }
        }
        impl W {
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior15::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior15::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR15_SPEC;
        impl crate::RegisterSpec for IPRIOR15_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`iprior15::R`](R) reader structure
        impl crate::Readable for IPRIOR15_SPEC {}
        ///`write(|w| ..)` method takes [`iprior15::W`](W) writer structure
        impl crate::Writable for IPRIOR15_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets IPRIOR15 to value 0
        impl crate::Resettable for IPRIOR15_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///IPRIOR16 (rw) register accessor: Interrupt Priority Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior16::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior16::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior16`]
    ///module
    pub type IPRIOR16 = crate::Reg<iprior16::IPRIOR16_SPEC>;
    ///Interrupt Priority Register
    pub mod iprior16 {
        ///Register `IPRIOR16` reader
        pub type R = crate::R<IPRIOR16_SPEC>;
        ///Register `IPRIOR16` writer
        pub type W = crate::W<IPRIOR16_SPEC>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<IPRIOR16_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                core::fmt::Debug::fmt(&self.read(), f)
            }
        }
        impl W {
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior16::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior16::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR16_SPEC;
        impl crate::RegisterSpec for IPRIOR16_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`iprior16::R`](R) reader structure
        impl crate::Readable for IPRIOR16_SPEC {}
        ///`write(|w| ..)` method takes [`iprior16::W`](W) writer structure
        impl crate::Writable for IPRIOR16_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets IPRIOR16 to value 0
        impl crate::Resettable for IPRIOR16_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///IPRIOR17 (rw) register accessor: Interrupt Priority Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior17::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior17::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior17`]
    ///module
    pub type IPRIOR17 = crate::Reg<iprior17::IPRIOR17_SPEC>;
    ///Interrupt Priority Register
    pub mod iprior17 {
        ///Register `IPRIOR17` reader
        pub type R = crate::R<IPRIOR17_SPEC>;
        ///Register `IPRIOR17` writer
        pub type W = crate::W<IPRIOR17_SPEC>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<IPRIOR17_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                core::fmt::Debug::fmt(&self.read(), f)
            }
        }
        impl W {
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior17::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior17::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR17_SPEC;
        impl crate::RegisterSpec for IPRIOR17_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`iprior17::R`](R) reader structure
        impl crate::Readable for IPRIOR17_SPEC {}
        ///`write(|w| ..)` method takes [`iprior17::W`](W) writer structure
        impl crate::Writable for IPRIOR17_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets IPRIOR17 to value 0
        impl crate::Resettable for IPRIOR17_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///IPRIOR18 (rw) register accessor: Interrupt Priority Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior18::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior18::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior18`]
    ///module
    pub type IPRIOR18 = crate::Reg<iprior18::IPRIOR18_SPEC>;
    ///Interrupt Priority Register
    pub mod iprior18 {
        ///Register `IPRIOR18` reader
        pub type R = crate::R<IPRIOR18_SPEC>;
        ///Register `IPRIOR18` writer
        pub type W = crate::W<IPRIOR18_SPEC>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<IPRIOR18_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                core::fmt::Debug::fmt(&self.read(), f)
            }
        }
        impl W {
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior18::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior18::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR18_SPEC;
        impl crate::RegisterSpec for IPRIOR18_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`iprior18::R`](R) reader structure
        impl crate::Readable for IPRIOR18_SPEC {}
        ///`write(|w| ..)` method takes [`iprior18::W`](W) writer structure
        impl crate::Writable for IPRIOR18_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets IPRIOR18 to value 0
        impl crate::Resettable for IPRIOR18_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///IPRIOR19 (rw) register accessor: Interrupt Priority Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior19::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior19::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior19`]
    ///module
    pub type IPRIOR19 = crate::Reg<iprior19::IPRIOR19_SPEC>;
    ///Interrupt Priority Register
    pub mod iprior19 {
        ///Register `IPRIOR19` reader
        pub type R = crate::R<IPRIOR19_SPEC>;
        ///Register `IPRIOR19` writer
        pub type W = crate::W<IPRIOR19_SPEC>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<IPRIOR19_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                core::fmt::Debug::fmt(&self.read(), f)
            }
        }
        impl W {
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior19::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior19::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR19_SPEC;
        impl crate::RegisterSpec for IPRIOR19_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`iprior19::R`](R) reader structure
        impl crate::Readable for IPRIOR19_SPEC {}
        ///`write(|w| ..)` method takes [`iprior19::W`](W) writer structure
        impl crate::Writable for IPRIOR19_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets IPRIOR19 to value 0
        impl crate::Resettable for IPRIOR19_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///IPRIOR20 (rw) register accessor: Interrupt Priority Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior20::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior20::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior20`]
    ///module
    pub type IPRIOR20 = crate::Reg<iprior20::IPRIOR20_SPEC>;
    ///Interrupt Priority Register
    pub mod iprior20 {
        ///Register `IPRIOR20` reader
        pub type R = crate::R<IPRIOR20_SPEC>;
        ///Register `IPRIOR20` writer
        pub type W = crate::W<IPRIOR20_SPEC>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<IPRIOR20_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                core::fmt::Debug::fmt(&self.read(), f)
            }
        }
        impl W {
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior20::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior20::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR20_SPEC;
        impl crate::RegisterSpec for IPRIOR20_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`iprior20::R`](R) reader structure
        impl crate::Readable for IPRIOR20_SPEC {}
        ///`write(|w| ..)` method takes [`iprior20::W`](W) writer structure
        impl crate::Writable for IPRIOR20_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets IPRIOR20 to value 0
        impl crate::Resettable for IPRIOR20_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///IPRIOR21 (rw) register accessor: Interrupt Priority Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior21::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior21::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior21`]
    ///module
    pub type IPRIOR21 = crate::Reg<iprior21::IPRIOR21_SPEC>;
    ///Interrupt Priority Register
    pub mod iprior21 {
        ///Register `IPRIOR21` reader
        pub type R = crate::R<IPRIOR21_SPEC>;
        ///Register `IPRIOR21` writer
        pub type W = crate::W<IPRIOR21_SPEC>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<IPRIOR21_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                core::fmt::Debug::fmt(&self.read(), f)
            }
        }
        impl W {
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior21::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior21::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR21_SPEC;
        impl crate::RegisterSpec for IPRIOR21_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`iprior21::R`](R) reader structure
        impl crate::Readable for IPRIOR21_SPEC {}
        ///`write(|w| ..)` method takes [`iprior21::W`](W) writer structure
        impl crate::Writable for IPRIOR21_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets IPRIOR21 to value 0
        impl crate::Resettable for IPRIOR21_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///IPRIOR22 (rw) register accessor: Interrupt Priority Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior22::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior22::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior22`]
    ///module
    pub type IPRIOR22 = crate::Reg<iprior22::IPRIOR22_SPEC>;
    ///Interrupt Priority Register
    pub mod iprior22 {
        ///Register `IPRIOR22` reader
        pub type R = crate::R<IPRIOR22_SPEC>;
        ///Register `IPRIOR22` writer
        pub type W = crate::W<IPRIOR22_SPEC>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<IPRIOR22_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                core::fmt::Debug::fmt(&self.read(), f)
            }
        }
        impl W {
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior22::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior22::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR22_SPEC;
        impl crate::RegisterSpec for IPRIOR22_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`iprior22::R`](R) reader structure
        impl crate::Readable for IPRIOR22_SPEC {}
        ///`write(|w| ..)` method takes [`iprior22::W`](W) writer structure
        impl crate::Writable for IPRIOR22_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets IPRIOR22 to value 0
        impl crate::Resettable for IPRIOR22_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///IPRIOR23 (rw) register accessor: Interrupt Priority Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior23::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior23::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior23`]
    ///module
    pub type IPRIOR23 = crate::Reg<iprior23::IPRIOR23_SPEC>;
    ///Interrupt Priority Register
    pub mod iprior23 {
        ///Register `IPRIOR23` reader
        pub type R = crate::R<IPRIOR23_SPEC>;
        ///Register `IPRIOR23` writer
        pub type W = crate::W<IPRIOR23_SPEC>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<IPRIOR23_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                core::fmt::Debug::fmt(&self.read(), f)
            }
        }
        impl W {
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior23::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior23::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR23_SPEC;
        impl crate::RegisterSpec for IPRIOR23_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`iprior23::R`](R) reader structure
        impl crate::Readable for IPRIOR23_SPEC {}
        ///`write(|w| ..)` method takes [`iprior23::W`](W) writer structure
        impl crate::Writable for IPRIOR23_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets IPRIOR23 to value 0
        impl crate::Resettable for IPRIOR23_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///IPRIOR24 (rw) register accessor: Interrupt Priority Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior24::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior24::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior24`]
    ///module
    pub type IPRIOR24 = crate::Reg<iprior24::IPRIOR24_SPEC>;
    ///Interrupt Priority Register
    pub mod iprior24 {
        ///Register `IPRIOR24` reader
        pub type R = crate::R<IPRIOR24_SPEC>;
        ///Register `IPRIOR24` writer
        pub type W = crate::W<IPRIOR24_SPEC>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<IPRIOR24_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                core::fmt::Debug::fmt(&self.read(), f)
            }
        }
        impl W {
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior24::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior24::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR24_SPEC;
        impl crate::RegisterSpec for IPRIOR24_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`iprior24::R`](R) reader structure
        impl crate::Readable for IPRIOR24_SPEC {}
        ///`write(|w| ..)` method takes [`iprior24::W`](W) writer structure
        impl crate::Writable for IPRIOR24_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets IPRIOR24 to value 0
        impl crate::Resettable for IPRIOR24_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///IPRIOR25 (rw) register accessor: Interrupt Priority Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior25::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior25::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior25`]
    ///module
    pub type IPRIOR25 = crate::Reg<iprior25::IPRIOR25_SPEC>;
    ///Interrupt Priority Register
    pub mod iprior25 {
        ///Register `IPRIOR25` reader
        pub type R = crate::R<IPRIOR25_SPEC>;
        ///Register `IPRIOR25` writer
        pub type W = crate::W<IPRIOR25_SPEC>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<IPRIOR25_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                core::fmt::Debug::fmt(&self.read(), f)
            }
        }
        impl W {
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior25::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior25::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR25_SPEC;
        impl crate::RegisterSpec for IPRIOR25_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`iprior25::R`](R) reader structure
        impl crate::Readable for IPRIOR25_SPEC {}
        ///`write(|w| ..)` method takes [`iprior25::W`](W) writer structure
        impl crate::Writable for IPRIOR25_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets IPRIOR25 to value 0
        impl crate::Resettable for IPRIOR25_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///IPRIOR26 (rw) register accessor: Interrupt Priority Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior26::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior26::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior26`]
    ///module
    pub type IPRIOR26 = crate::Reg<iprior26::IPRIOR26_SPEC>;
    ///Interrupt Priority Register
    pub mod iprior26 {
        ///Register `IPRIOR26` reader
        pub type R = crate::R<IPRIOR26_SPEC>;
        ///Register `IPRIOR26` writer
        pub type W = crate::W<IPRIOR26_SPEC>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<IPRIOR26_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                core::fmt::Debug::fmt(&self.read(), f)
            }
        }
        impl W {
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior26::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior26::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR26_SPEC;
        impl crate::RegisterSpec for IPRIOR26_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`iprior26::R`](R) reader structure
        impl crate::Readable for IPRIOR26_SPEC {}
        ///`write(|w| ..)` method takes [`iprior26::W`](W) writer structure
        impl crate::Writable for IPRIOR26_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets IPRIOR26 to value 0
        impl crate::Resettable for IPRIOR26_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///IPRIOR27 (rw) register accessor: Interrupt Priority Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior27::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior27::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior27`]
    ///module
    pub type IPRIOR27 = crate::Reg<iprior27::IPRIOR27_SPEC>;
    ///Interrupt Priority Register
    pub mod iprior27 {
        ///Register `IPRIOR27` reader
        pub type R = crate::R<IPRIOR27_SPEC>;
        ///Register `IPRIOR27` writer
        pub type W = crate::W<IPRIOR27_SPEC>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<IPRIOR27_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                core::fmt::Debug::fmt(&self.read(), f)
            }
        }
        impl W {
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior27::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior27::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR27_SPEC;
        impl crate::RegisterSpec for IPRIOR27_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`iprior27::R`](R) reader structure
        impl crate::Readable for IPRIOR27_SPEC {}
        ///`write(|w| ..)` method takes [`iprior27::W`](W) writer structure
        impl crate::Writable for IPRIOR27_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets IPRIOR27 to value 0
        impl crate::Resettable for IPRIOR27_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///IPRIOR28 (rw) register accessor: Interrupt Priority Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior28::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior28::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior28`]
    ///module
    pub type IPRIOR28 = crate::Reg<iprior28::IPRIOR28_SPEC>;
    ///Interrupt Priority Register
    pub mod iprior28 {
        ///Register `IPRIOR28` reader
        pub type R = crate::R<IPRIOR28_SPEC>;
        ///Register `IPRIOR28` writer
        pub type W = crate::W<IPRIOR28_SPEC>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<IPRIOR28_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                core::fmt::Debug::fmt(&self.read(), f)
            }
        }
        impl W {
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior28::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior28::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR28_SPEC;
        impl crate::RegisterSpec for IPRIOR28_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`iprior28::R`](R) reader structure
        impl crate::Readable for IPRIOR28_SPEC {}
        ///`write(|w| ..)` method takes [`iprior28::W`](W) writer structure
        impl crate::Writable for IPRIOR28_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets IPRIOR28 to value 0
        impl crate::Resettable for IPRIOR28_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///IPRIOR29 (rw) register accessor: Interrupt Priority Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior29::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior29::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior29`]
    ///module
    pub type IPRIOR29 = crate::Reg<iprior29::IPRIOR29_SPEC>;
    ///Interrupt Priority Register
    pub mod iprior29 {
        ///Register `IPRIOR29` reader
        pub type R = crate::R<IPRIOR29_SPEC>;
        ///Register `IPRIOR29` writer
        pub type W = crate::W<IPRIOR29_SPEC>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<IPRIOR29_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                core::fmt::Debug::fmt(&self.read(), f)
            }
        }
        impl W {
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior29::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior29::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR29_SPEC;
        impl crate::RegisterSpec for IPRIOR29_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`iprior29::R`](R) reader structure
        impl crate::Readable for IPRIOR29_SPEC {}
        ///`write(|w| ..)` method takes [`iprior29::W`](W) writer structure
        impl crate::Writable for IPRIOR29_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets IPRIOR29 to value 0
        impl crate::Resettable for IPRIOR29_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///IPRIOR30 (rw) register accessor: Interrupt Priority Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior30::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior30::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior30`]
    ///module
    pub type IPRIOR30 = crate::Reg<iprior30::IPRIOR30_SPEC>;
    ///Interrupt Priority Register
    pub mod iprior30 {
        ///Register `IPRIOR30` reader
        pub type R = crate::R<IPRIOR30_SPEC>;
        ///Register `IPRIOR30` writer
        pub type W = crate::W<IPRIOR30_SPEC>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<IPRIOR30_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                core::fmt::Debug::fmt(&self.read(), f)
            }
        }
        impl W {
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior30::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior30::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR30_SPEC;
        impl crate::RegisterSpec for IPRIOR30_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`iprior30::R`](R) reader structure
        impl crate::Readable for IPRIOR30_SPEC {}
        ///`write(|w| ..)` method takes [`iprior30::W`](W) writer structure
        impl crate::Writable for IPRIOR30_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets IPRIOR30 to value 0
        impl crate::Resettable for IPRIOR30_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///IPRIOR31 (rw) register accessor: Interrupt Priority Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior31::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior31::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior31`]
    ///module
    pub type IPRIOR31 = crate::Reg<iprior31::IPRIOR31_SPEC>;
    ///Interrupt Priority Register
    pub mod iprior31 {
        ///Register `IPRIOR31` reader
        pub type R = crate::R<IPRIOR31_SPEC>;
        ///Register `IPRIOR31` writer
        pub type W = crate::W<IPRIOR31_SPEC>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<IPRIOR31_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                core::fmt::Debug::fmt(&self.read(), f)
            }
        }
        impl W {
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior31::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior31::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR31_SPEC;
        impl crate::RegisterSpec for IPRIOR31_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`iprior31::R`](R) reader structure
        impl crate::Readable for IPRIOR31_SPEC {}
        ///`write(|w| ..)` method takes [`iprior31::W`](W) writer structure
        impl crate::Writable for IPRIOR31_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets IPRIOR31 to value 0
        impl crate::Resettable for IPRIOR31_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///IPRIOR32 (rw) register accessor: Interrupt Priority Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior32::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior32::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior32`]
    ///module
    pub type IPRIOR32 = crate::Reg<iprior32::IPRIOR32_SPEC>;
    ///Interrupt Priority Register
    pub mod iprior32 {
        ///Register `IPRIOR32` reader
        pub type R = crate::R<IPRIOR32_SPEC>;
        ///Register `IPRIOR32` writer
        pub type W = crate::W<IPRIOR32_SPEC>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<IPRIOR32_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                core::fmt::Debug::fmt(&self.read(), f)
            }
        }
        impl W {
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior32::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior32::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR32_SPEC;
        impl crate::RegisterSpec for IPRIOR32_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`iprior32::R`](R) reader structure
        impl crate::Readable for IPRIOR32_SPEC {}
        ///`write(|w| ..)` method takes [`iprior32::W`](W) writer structure
        impl crate::Writable for IPRIOR32_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets IPRIOR32 to value 0
        impl crate::Resettable for IPRIOR32_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///IPRIOR33 (rw) register accessor: Interrupt Priority Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior33::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior33::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior33`]
    ///module
    pub type IPRIOR33 = crate::Reg<iprior33::IPRIOR33_SPEC>;
    ///Interrupt Priority Register
    pub mod iprior33 {
        ///Register `IPRIOR33` reader
        pub type R = crate::R<IPRIOR33_SPEC>;
        ///Register `IPRIOR33` writer
        pub type W = crate::W<IPRIOR33_SPEC>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<IPRIOR33_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                core::fmt::Debug::fmt(&self.read(), f)
            }
        }
        impl W {
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior33::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior33::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR33_SPEC;
        impl crate::RegisterSpec for IPRIOR33_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`iprior33::R`](R) reader structure
        impl crate::Readable for IPRIOR33_SPEC {}
        ///`write(|w| ..)` method takes [`iprior33::W`](W) writer structure
        impl crate::Writable for IPRIOR33_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets IPRIOR33 to value 0
        impl crate::Resettable for IPRIOR33_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///IPRIOR34 (rw) register accessor: Interrupt Priority Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior34::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior34::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior34`]
    ///module
    pub type IPRIOR34 = crate::Reg<iprior34::IPRIOR34_SPEC>;
    ///Interrupt Priority Register
    pub mod iprior34 {
        ///Register `IPRIOR34` reader
        pub type R = crate::R<IPRIOR34_SPEC>;
        ///Register `IPRIOR34` writer
        pub type W = crate::W<IPRIOR34_SPEC>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<IPRIOR34_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                core::fmt::Debug::fmt(&self.read(), f)
            }
        }
        impl W {
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior34::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior34::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR34_SPEC;
        impl crate::RegisterSpec for IPRIOR34_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`iprior34::R`](R) reader structure
        impl crate::Readable for IPRIOR34_SPEC {}
        ///`write(|w| ..)` method takes [`iprior34::W`](W) writer structure
        impl crate::Writable for IPRIOR34_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets IPRIOR34 to value 0
        impl crate::Resettable for IPRIOR34_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///IPRIOR35 (rw) register accessor: Interrupt Priority Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior35::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior35::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior35`]
    ///module
    pub type IPRIOR35 = crate::Reg<iprior35::IPRIOR35_SPEC>;
    ///Interrupt Priority Register
    pub mod iprior35 {
        ///Register `IPRIOR35` reader
        pub type R = crate::R<IPRIOR35_SPEC>;
        ///Register `IPRIOR35` writer
        pub type W = crate::W<IPRIOR35_SPEC>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<IPRIOR35_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                core::fmt::Debug::fmt(&self.read(), f)
            }
        }
        impl W {
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior35::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior35::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR35_SPEC;
        impl crate::RegisterSpec for IPRIOR35_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`iprior35::R`](R) reader structure
        impl crate::Readable for IPRIOR35_SPEC {}
        ///`write(|w| ..)` method takes [`iprior35::W`](W) writer structure
        impl crate::Writable for IPRIOR35_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets IPRIOR35 to value 0
        impl crate::Resettable for IPRIOR35_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///IPRIOR36 (rw) register accessor: Interrupt Priority Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior36::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior36::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior36`]
    ///module
    pub type IPRIOR36 = crate::Reg<iprior36::IPRIOR36_SPEC>;
    ///Interrupt Priority Register
    pub mod iprior36 {
        ///Register `IPRIOR36` reader
        pub type R = crate::R<IPRIOR36_SPEC>;
        ///Register `IPRIOR36` writer
        pub type W = crate::W<IPRIOR36_SPEC>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<IPRIOR36_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                core::fmt::Debug::fmt(&self.read(), f)
            }
        }
        impl W {
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior36::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior36::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR36_SPEC;
        impl crate::RegisterSpec for IPRIOR36_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`iprior36::R`](R) reader structure
        impl crate::Readable for IPRIOR36_SPEC {}
        ///`write(|w| ..)` method takes [`iprior36::W`](W) writer structure
        impl crate::Writable for IPRIOR36_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets IPRIOR36 to value 0
        impl crate::Resettable for IPRIOR36_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///IPRIOR37 (rw) register accessor: Interrupt Priority Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior37::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior37::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior37`]
    ///module
    pub type IPRIOR37 = crate::Reg<iprior37::IPRIOR37_SPEC>;
    ///Interrupt Priority Register
    pub mod iprior37 {
        ///Register `IPRIOR37` reader
        pub type R = crate::R<IPRIOR37_SPEC>;
        ///Register `IPRIOR37` writer
        pub type W = crate::W<IPRIOR37_SPEC>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<IPRIOR37_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                core::fmt::Debug::fmt(&self.read(), f)
            }
        }
        impl W {
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior37::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior37::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR37_SPEC;
        impl crate::RegisterSpec for IPRIOR37_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`iprior37::R`](R) reader structure
        impl crate::Readable for IPRIOR37_SPEC {}
        ///`write(|w| ..)` method takes [`iprior37::W`](W) writer structure
        impl crate::Writable for IPRIOR37_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets IPRIOR37 to value 0
        impl crate::Resettable for IPRIOR37_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///IPRIOR38 (rw) register accessor: Interrupt Priority Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior38::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior38::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior38`]
    ///module
    pub type IPRIOR38 = crate::Reg<iprior38::IPRIOR38_SPEC>;
    ///Interrupt Priority Register
    pub mod iprior38 {
        ///Register `IPRIOR38` reader
        pub type R = crate::R<IPRIOR38_SPEC>;
        ///Register `IPRIOR38` writer
        pub type W = crate::W<IPRIOR38_SPEC>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<IPRIOR38_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                core::fmt::Debug::fmt(&self.read(), f)
            }
        }
        impl W {
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior38::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior38::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR38_SPEC;
        impl crate::RegisterSpec for IPRIOR38_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`iprior38::R`](R) reader structure
        impl crate::Readable for IPRIOR38_SPEC {}
        ///`write(|w| ..)` method takes [`iprior38::W`](W) writer structure
        impl crate::Writable for IPRIOR38_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets IPRIOR38 to value 0
        impl crate::Resettable for IPRIOR38_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///IPRIOR39 (rw) register accessor: Interrupt Priority Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior39::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior39::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior39`]
    ///module
    pub type IPRIOR39 = crate::Reg<iprior39::IPRIOR39_SPEC>;
    ///Interrupt Priority Register
    pub mod iprior39 {
        ///Register `IPRIOR39` reader
        pub type R = crate::R<IPRIOR39_SPEC>;
        ///Register `IPRIOR39` writer
        pub type W = crate::W<IPRIOR39_SPEC>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<IPRIOR39_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                core::fmt::Debug::fmt(&self.read(), f)
            }
        }
        impl W {
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior39::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior39::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR39_SPEC;
        impl crate::RegisterSpec for IPRIOR39_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`iprior39::R`](R) reader structure
        impl crate::Readable for IPRIOR39_SPEC {}
        ///`write(|w| ..)` method takes [`iprior39::W`](W) writer structure
        impl crate::Writable for IPRIOR39_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets IPRIOR39 to value 0
        impl crate::Resettable for IPRIOR39_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///IPRIOR40 (rw) register accessor: Interrupt Priority Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior40::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior40::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior40`]
    ///module
    pub type IPRIOR40 = crate::Reg<iprior40::IPRIOR40_SPEC>;
    ///Interrupt Priority Register
    pub mod iprior40 {
        ///Register `IPRIOR40` reader
        pub type R = crate::R<IPRIOR40_SPEC>;
        ///Register `IPRIOR40` writer
        pub type W = crate::W<IPRIOR40_SPEC>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<IPRIOR40_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                core::fmt::Debug::fmt(&self.read(), f)
            }
        }
        impl W {
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior40::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior40::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR40_SPEC;
        impl crate::RegisterSpec for IPRIOR40_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`iprior40::R`](R) reader structure
        impl crate::Readable for IPRIOR40_SPEC {}
        ///`write(|w| ..)` method takes [`iprior40::W`](W) writer structure
        impl crate::Writable for IPRIOR40_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets IPRIOR40 to value 0
        impl crate::Resettable for IPRIOR40_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///IPRIOR41 (rw) register accessor: Interrupt Priority Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior41::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior41::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior41`]
    ///module
    pub type IPRIOR41 = crate::Reg<iprior41::IPRIOR41_SPEC>;
    ///Interrupt Priority Register
    pub mod iprior41 {
        ///Register `IPRIOR41` reader
        pub type R = crate::R<IPRIOR41_SPEC>;
        ///Register `IPRIOR41` writer
        pub type W = crate::W<IPRIOR41_SPEC>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<IPRIOR41_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                core::fmt::Debug::fmt(&self.read(), f)
            }
        }
        impl W {
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior41::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior41::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR41_SPEC;
        impl crate::RegisterSpec for IPRIOR41_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`iprior41::R`](R) reader structure
        impl crate::Readable for IPRIOR41_SPEC {}
        ///`write(|w| ..)` method takes [`iprior41::W`](W) writer structure
        impl crate::Writable for IPRIOR41_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets IPRIOR41 to value 0
        impl crate::Resettable for IPRIOR41_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///IPRIOR42 (rw) register accessor: Interrupt Priority Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior42::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior42::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior42`]
    ///module
    pub type IPRIOR42 = crate::Reg<iprior42::IPRIOR42_SPEC>;
    ///Interrupt Priority Register
    pub mod iprior42 {
        ///Register `IPRIOR42` reader
        pub type R = crate::R<IPRIOR42_SPEC>;
        ///Register `IPRIOR42` writer
        pub type W = crate::W<IPRIOR42_SPEC>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<IPRIOR42_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                core::fmt::Debug::fmt(&self.read(), f)
            }
        }
        impl W {
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior42::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior42::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR42_SPEC;
        impl crate::RegisterSpec for IPRIOR42_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`iprior42::R`](R) reader structure
        impl crate::Readable for IPRIOR42_SPEC {}
        ///`write(|w| ..)` method takes [`iprior42::W`](W) writer structure
        impl crate::Writable for IPRIOR42_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets IPRIOR42 to value 0
        impl crate::Resettable for IPRIOR42_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///IPRIOR43 (rw) register accessor: Interrupt Priority Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior43::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior43::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior43`]
    ///module
    pub type IPRIOR43 = crate::Reg<iprior43::IPRIOR43_SPEC>;
    ///Interrupt Priority Register
    pub mod iprior43 {
        ///Register `IPRIOR43` reader
        pub type R = crate::R<IPRIOR43_SPEC>;
        ///Register `IPRIOR43` writer
        pub type W = crate::W<IPRIOR43_SPEC>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<IPRIOR43_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                core::fmt::Debug::fmt(&self.read(), f)
            }
        }
        impl W {
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior43::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior43::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR43_SPEC;
        impl crate::RegisterSpec for IPRIOR43_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`iprior43::R`](R) reader structure
        impl crate::Readable for IPRIOR43_SPEC {}
        ///`write(|w| ..)` method takes [`iprior43::W`](W) writer structure
        impl crate::Writable for IPRIOR43_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets IPRIOR43 to value 0
        impl crate::Resettable for IPRIOR43_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///IPRIOR44 (rw) register accessor: Interrupt Priority Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior44::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior44::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior44`]
    ///module
    pub type IPRIOR44 = crate::Reg<iprior44::IPRIOR44_SPEC>;
    ///Interrupt Priority Register
    pub mod iprior44 {
        ///Register `IPRIOR44` reader
        pub type R = crate::R<IPRIOR44_SPEC>;
        ///Register `IPRIOR44` writer
        pub type W = crate::W<IPRIOR44_SPEC>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<IPRIOR44_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                core::fmt::Debug::fmt(&self.read(), f)
            }
        }
        impl W {
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior44::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior44::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR44_SPEC;
        impl crate::RegisterSpec for IPRIOR44_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`iprior44::R`](R) reader structure
        impl crate::Readable for IPRIOR44_SPEC {}
        ///`write(|w| ..)` method takes [`iprior44::W`](W) writer structure
        impl crate::Writable for IPRIOR44_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets IPRIOR44 to value 0
        impl crate::Resettable for IPRIOR44_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///IPRIOR45 (rw) register accessor: Interrupt Priority Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior45::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior45::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior45`]
    ///module
    pub type IPRIOR45 = crate::Reg<iprior45::IPRIOR45_SPEC>;
    ///Interrupt Priority Register
    pub mod iprior45 {
        ///Register `IPRIOR45` reader
        pub type R = crate::R<IPRIOR45_SPEC>;
        ///Register `IPRIOR45` writer
        pub type W = crate::W<IPRIOR45_SPEC>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<IPRIOR45_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                core::fmt::Debug::fmt(&self.read(), f)
            }
        }
        impl W {
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior45::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior45::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR45_SPEC;
        impl crate::RegisterSpec for IPRIOR45_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`iprior45::R`](R) reader structure
        impl crate::Readable for IPRIOR45_SPEC {}
        ///`write(|w| ..)` method takes [`iprior45::W`](W) writer structure
        impl crate::Writable for IPRIOR45_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets IPRIOR45 to value 0
        impl crate::Resettable for IPRIOR45_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///IPRIOR46 (rw) register accessor: Interrupt Priority Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior46::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior46::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior46`]
    ///module
    pub type IPRIOR46 = crate::Reg<iprior46::IPRIOR46_SPEC>;
    ///Interrupt Priority Register
    pub mod iprior46 {
        ///Register `IPRIOR46` reader
        pub type R = crate::R<IPRIOR46_SPEC>;
        ///Register `IPRIOR46` writer
        pub type W = crate::W<IPRIOR46_SPEC>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<IPRIOR46_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                core::fmt::Debug::fmt(&self.read(), f)
            }
        }
        impl W {
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior46::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior46::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR46_SPEC;
        impl crate::RegisterSpec for IPRIOR46_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`iprior46::R`](R) reader structure
        impl crate::Readable for IPRIOR46_SPEC {}
        ///`write(|w| ..)` method takes [`iprior46::W`](W) writer structure
        impl crate::Writable for IPRIOR46_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets IPRIOR46 to value 0
        impl crate::Resettable for IPRIOR46_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///IPRIOR47 (rw) register accessor: Interrupt Priority Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior47::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior47::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior47`]
    ///module
    pub type IPRIOR47 = crate::Reg<iprior47::IPRIOR47_SPEC>;
    ///Interrupt Priority Register
    pub mod iprior47 {
        ///Register `IPRIOR47` reader
        pub type R = crate::R<IPRIOR47_SPEC>;
        ///Register `IPRIOR47` writer
        pub type W = crate::W<IPRIOR47_SPEC>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<IPRIOR47_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                core::fmt::Debug::fmt(&self.read(), f)
            }
        }
        impl W {
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior47::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior47::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR47_SPEC;
        impl crate::RegisterSpec for IPRIOR47_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`iprior47::R`](R) reader structure
        impl crate::Readable for IPRIOR47_SPEC {}
        ///`write(|w| ..)` method takes [`iprior47::W`](W) writer structure
        impl crate::Writable for IPRIOR47_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets IPRIOR47 to value 0
        impl crate::Resettable for IPRIOR47_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///IPRIOR48 (rw) register accessor: Interrupt Priority Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior48::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior48::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior48`]
    ///module
    pub type IPRIOR48 = crate::Reg<iprior48::IPRIOR48_SPEC>;
    ///Interrupt Priority Register
    pub mod iprior48 {
        ///Register `IPRIOR48` reader
        pub type R = crate::R<IPRIOR48_SPEC>;
        ///Register `IPRIOR48` writer
        pub type W = crate::W<IPRIOR48_SPEC>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<IPRIOR48_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                core::fmt::Debug::fmt(&self.read(), f)
            }
        }
        impl W {
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior48::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior48::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR48_SPEC;
        impl crate::RegisterSpec for IPRIOR48_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`iprior48::R`](R) reader structure
        impl crate::Readable for IPRIOR48_SPEC {}
        ///`write(|w| ..)` method takes [`iprior48::W`](W) writer structure
        impl crate::Writable for IPRIOR48_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets IPRIOR48 to value 0
        impl crate::Resettable for IPRIOR48_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///IPRIOR49 (rw) register accessor: Interrupt Priority Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior49::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior49::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior49`]
    ///module
    pub type IPRIOR49 = crate::Reg<iprior49::IPRIOR49_SPEC>;
    ///Interrupt Priority Register
    pub mod iprior49 {
        ///Register `IPRIOR49` reader
        pub type R = crate::R<IPRIOR49_SPEC>;
        ///Register `IPRIOR49` writer
        pub type W = crate::W<IPRIOR49_SPEC>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<IPRIOR49_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                core::fmt::Debug::fmt(&self.read(), f)
            }
        }
        impl W {
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior49::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior49::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR49_SPEC;
        impl crate::RegisterSpec for IPRIOR49_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`iprior49::R`](R) reader structure
        impl crate::Readable for IPRIOR49_SPEC {}
        ///`write(|w| ..)` method takes [`iprior49::W`](W) writer structure
        impl crate::Writable for IPRIOR49_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets IPRIOR49 to value 0
        impl crate::Resettable for IPRIOR49_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///IPRIOR50 (rw) register accessor: Interrupt Priority Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior50::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior50::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior50`]
    ///module
    pub type IPRIOR50 = crate::Reg<iprior50::IPRIOR50_SPEC>;
    ///Interrupt Priority Register
    pub mod iprior50 {
        ///Register `IPRIOR50` reader
        pub type R = crate::R<IPRIOR50_SPEC>;
        ///Register `IPRIOR50` writer
        pub type W = crate::W<IPRIOR50_SPEC>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<IPRIOR50_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                core::fmt::Debug::fmt(&self.read(), f)
            }
        }
        impl W {
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior50::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior50::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR50_SPEC;
        impl crate::RegisterSpec for IPRIOR50_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`iprior50::R`](R) reader structure
        impl crate::Readable for IPRIOR50_SPEC {}
        ///`write(|w| ..)` method takes [`iprior50::W`](W) writer structure
        impl crate::Writable for IPRIOR50_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets IPRIOR50 to value 0
        impl crate::Resettable for IPRIOR50_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///IPRIOR51 (rw) register accessor: Interrupt Priority Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior51::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior51::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior51`]
    ///module
    pub type IPRIOR51 = crate::Reg<iprior51::IPRIOR51_SPEC>;
    ///Interrupt Priority Register
    pub mod iprior51 {
        ///Register `IPRIOR51` reader
        pub type R = crate::R<IPRIOR51_SPEC>;
        ///Register `IPRIOR51` writer
        pub type W = crate::W<IPRIOR51_SPEC>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<IPRIOR51_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                core::fmt::Debug::fmt(&self.read(), f)
            }
        }
        impl W {
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior51::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior51::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR51_SPEC;
        impl crate::RegisterSpec for IPRIOR51_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`iprior51::R`](R) reader structure
        impl crate::Readable for IPRIOR51_SPEC {}
        ///`write(|w| ..)` method takes [`iprior51::W`](W) writer structure
        impl crate::Writable for IPRIOR51_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets IPRIOR51 to value 0
        impl crate::Resettable for IPRIOR51_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///IPRIOR52 (rw) register accessor: Interrupt Priority Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior52::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior52::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior52`]
    ///module
    pub type IPRIOR52 = crate::Reg<iprior52::IPRIOR52_SPEC>;
    ///Interrupt Priority Register
    pub mod iprior52 {
        ///Register `IPRIOR52` reader
        pub type R = crate::R<IPRIOR52_SPEC>;
        ///Register `IPRIOR52` writer
        pub type W = crate::W<IPRIOR52_SPEC>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<IPRIOR52_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                core::fmt::Debug::fmt(&self.read(), f)
            }
        }
        impl W {
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior52::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior52::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR52_SPEC;
        impl crate::RegisterSpec for IPRIOR52_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`iprior52::R`](R) reader structure
        impl crate::Readable for IPRIOR52_SPEC {}
        ///`write(|w| ..)` method takes [`iprior52::W`](W) writer structure
        impl crate::Writable for IPRIOR52_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets IPRIOR52 to value 0
        impl crate::Resettable for IPRIOR52_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///IPRIOR53 (rw) register accessor: Interrupt Priority Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior53::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior53::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior53`]
    ///module
    pub type IPRIOR53 = crate::Reg<iprior53::IPRIOR53_SPEC>;
    ///Interrupt Priority Register
    pub mod iprior53 {
        ///Register `IPRIOR53` reader
        pub type R = crate::R<IPRIOR53_SPEC>;
        ///Register `IPRIOR53` writer
        pub type W = crate::W<IPRIOR53_SPEC>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<IPRIOR53_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                core::fmt::Debug::fmt(&self.read(), f)
            }
        }
        impl W {
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior53::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior53::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR53_SPEC;
        impl crate::RegisterSpec for IPRIOR53_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`iprior53::R`](R) reader structure
        impl crate::Readable for IPRIOR53_SPEC {}
        ///`write(|w| ..)` method takes [`iprior53::W`](W) writer structure
        impl crate::Writable for IPRIOR53_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets IPRIOR53 to value 0
        impl crate::Resettable for IPRIOR53_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///IPRIOR54 (rw) register accessor: Interrupt Priority Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior54::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior54::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior54`]
    ///module
    pub type IPRIOR54 = crate::Reg<iprior54::IPRIOR54_SPEC>;
    ///Interrupt Priority Register
    pub mod iprior54 {
        ///Register `IPRIOR54` reader
        pub type R = crate::R<IPRIOR54_SPEC>;
        ///Register `IPRIOR54` writer
        pub type W = crate::W<IPRIOR54_SPEC>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<IPRIOR54_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                core::fmt::Debug::fmt(&self.read(), f)
            }
        }
        impl W {
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior54::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior54::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR54_SPEC;
        impl crate::RegisterSpec for IPRIOR54_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`iprior54::R`](R) reader structure
        impl crate::Readable for IPRIOR54_SPEC {}
        ///`write(|w| ..)` method takes [`iprior54::W`](W) writer structure
        impl crate::Writable for IPRIOR54_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets IPRIOR54 to value 0
        impl crate::Resettable for IPRIOR54_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///IPRIOR55 (rw) register accessor: Interrupt Priority Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior55::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior55::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior55`]
    ///module
    pub type IPRIOR55 = crate::Reg<iprior55::IPRIOR55_SPEC>;
    ///Interrupt Priority Register
    pub mod iprior55 {
        ///Register `IPRIOR55` reader
        pub type R = crate::R<IPRIOR55_SPEC>;
        ///Register `IPRIOR55` writer
        pub type W = crate::W<IPRIOR55_SPEC>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<IPRIOR55_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                core::fmt::Debug::fmt(&self.read(), f)
            }
        }
        impl W {
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior55::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior55::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR55_SPEC;
        impl crate::RegisterSpec for IPRIOR55_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`iprior55::R`](R) reader structure
        impl crate::Readable for IPRIOR55_SPEC {}
        ///`write(|w| ..)` method takes [`iprior55::W`](W) writer structure
        impl crate::Writable for IPRIOR55_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets IPRIOR55 to value 0
        impl crate::Resettable for IPRIOR55_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///IPRIOR56 (rw) register accessor: Interrupt Priority Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior56::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior56::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior56`]
    ///module
    pub type IPRIOR56 = crate::Reg<iprior56::IPRIOR56_SPEC>;
    ///Interrupt Priority Register
    pub mod iprior56 {
        ///Register `IPRIOR56` reader
        pub type R = crate::R<IPRIOR56_SPEC>;
        ///Register `IPRIOR56` writer
        pub type W = crate::W<IPRIOR56_SPEC>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<IPRIOR56_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                core::fmt::Debug::fmt(&self.read(), f)
            }
        }
        impl W {
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior56::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior56::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR56_SPEC;
        impl crate::RegisterSpec for IPRIOR56_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`iprior56::R`](R) reader structure
        impl crate::Readable for IPRIOR56_SPEC {}
        ///`write(|w| ..)` method takes [`iprior56::W`](W) writer structure
        impl crate::Writable for IPRIOR56_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets IPRIOR56 to value 0
        impl crate::Resettable for IPRIOR56_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///IPRIOR57 (rw) register accessor: Interrupt Priority Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior57::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior57::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior57`]
    ///module
    pub type IPRIOR57 = crate::Reg<iprior57::IPRIOR57_SPEC>;
    ///Interrupt Priority Register
    pub mod iprior57 {
        ///Register `IPRIOR57` reader
        pub type R = crate::R<IPRIOR57_SPEC>;
        ///Register `IPRIOR57` writer
        pub type W = crate::W<IPRIOR57_SPEC>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<IPRIOR57_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                core::fmt::Debug::fmt(&self.read(), f)
            }
        }
        impl W {
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior57::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior57::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR57_SPEC;
        impl crate::RegisterSpec for IPRIOR57_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`iprior57::R`](R) reader structure
        impl crate::Readable for IPRIOR57_SPEC {}
        ///`write(|w| ..)` method takes [`iprior57::W`](W) writer structure
        impl crate::Writable for IPRIOR57_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets IPRIOR57 to value 0
        impl crate::Resettable for IPRIOR57_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///IPRIOR58 (rw) register accessor: Interrupt Priority Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior58::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior58::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior58`]
    ///module
    pub type IPRIOR58 = crate::Reg<iprior58::IPRIOR58_SPEC>;
    ///Interrupt Priority Register
    pub mod iprior58 {
        ///Register `IPRIOR58` reader
        pub type R = crate::R<IPRIOR58_SPEC>;
        ///Register `IPRIOR58` writer
        pub type W = crate::W<IPRIOR58_SPEC>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<IPRIOR58_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                core::fmt::Debug::fmt(&self.read(), f)
            }
        }
        impl W {
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior58::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior58::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR58_SPEC;
        impl crate::RegisterSpec for IPRIOR58_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`iprior58::R`](R) reader structure
        impl crate::Readable for IPRIOR58_SPEC {}
        ///`write(|w| ..)` method takes [`iprior58::W`](W) writer structure
        impl crate::Writable for IPRIOR58_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets IPRIOR58 to value 0
        impl crate::Resettable for IPRIOR58_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///IPRIOR59 (rw) register accessor: Interrupt Priority Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior59::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior59::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior59`]
    ///module
    pub type IPRIOR59 = crate::Reg<iprior59::IPRIOR59_SPEC>;
    ///Interrupt Priority Register
    pub mod iprior59 {
        ///Register `IPRIOR59` reader
        pub type R = crate::R<IPRIOR59_SPEC>;
        ///Register `IPRIOR59` writer
        pub type W = crate::W<IPRIOR59_SPEC>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<IPRIOR59_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                core::fmt::Debug::fmt(&self.read(), f)
            }
        }
        impl W {
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior59::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior59::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR59_SPEC;
        impl crate::RegisterSpec for IPRIOR59_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`iprior59::R`](R) reader structure
        impl crate::Readable for IPRIOR59_SPEC {}
        ///`write(|w| ..)` method takes [`iprior59::W`](W) writer structure
        impl crate::Writable for IPRIOR59_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets IPRIOR59 to value 0
        impl crate::Resettable for IPRIOR59_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///IPRIOR60 (rw) register accessor: Interrupt Priority Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior60::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior60::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior60`]
    ///module
    pub type IPRIOR60 = crate::Reg<iprior60::IPRIOR60_SPEC>;
    ///Interrupt Priority Register
    pub mod iprior60 {
        ///Register `IPRIOR60` reader
        pub type R = crate::R<IPRIOR60_SPEC>;
        ///Register `IPRIOR60` writer
        pub type W = crate::W<IPRIOR60_SPEC>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<IPRIOR60_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                core::fmt::Debug::fmt(&self.read(), f)
            }
        }
        impl W {
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior60::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior60::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR60_SPEC;
        impl crate::RegisterSpec for IPRIOR60_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`iprior60::R`](R) reader structure
        impl crate::Readable for IPRIOR60_SPEC {}
        ///`write(|w| ..)` method takes [`iprior60::W`](W) writer structure
        impl crate::Writable for IPRIOR60_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets IPRIOR60 to value 0
        impl crate::Resettable for IPRIOR60_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///IPRIOR61 (rw) register accessor: Interrupt Priority Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior61::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior61::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior61`]
    ///module
    pub type IPRIOR61 = crate::Reg<iprior61::IPRIOR61_SPEC>;
    ///Interrupt Priority Register
    pub mod iprior61 {
        ///Register `IPRIOR61` reader
        pub type R = crate::R<IPRIOR61_SPEC>;
        ///Register `IPRIOR61` writer
        pub type W = crate::W<IPRIOR61_SPEC>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<IPRIOR61_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                core::fmt::Debug::fmt(&self.read(), f)
            }
        }
        impl W {
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior61::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior61::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR61_SPEC;
        impl crate::RegisterSpec for IPRIOR61_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`iprior61::R`](R) reader structure
        impl crate::Readable for IPRIOR61_SPEC {}
        ///`write(|w| ..)` method takes [`iprior61::W`](W) writer structure
        impl crate::Writable for IPRIOR61_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets IPRIOR61 to value 0
        impl crate::Resettable for IPRIOR61_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///IPRIOR62 (rw) register accessor: Interrupt Priority Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior62::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior62::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior62`]
    ///module
    pub type IPRIOR62 = crate::Reg<iprior62::IPRIOR62_SPEC>;
    ///Interrupt Priority Register
    pub mod iprior62 {
        ///Register `IPRIOR62` reader
        pub type R = crate::R<IPRIOR62_SPEC>;
        ///Register `IPRIOR62` writer
        pub type W = crate::W<IPRIOR62_SPEC>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<IPRIOR62_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                core::fmt::Debug::fmt(&self.read(), f)
            }
        }
        impl W {
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior62::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior62::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR62_SPEC;
        impl crate::RegisterSpec for IPRIOR62_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`iprior62::R`](R) reader structure
        impl crate::Readable for IPRIOR62_SPEC {}
        ///`write(|w| ..)` method takes [`iprior62::W`](W) writer structure
        impl crate::Writable for IPRIOR62_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets IPRIOR62 to value 0
        impl crate::Resettable for IPRIOR62_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///IPRIOR63 (rw) register accessor: Interrupt Priority Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior63::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior63::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior63`]
    ///module
    pub type IPRIOR63 = crate::Reg<iprior63::IPRIOR63_SPEC>;
    ///Interrupt Priority Register
    pub mod iprior63 {
        ///Register `IPRIOR63` reader
        pub type R = crate::R<IPRIOR63_SPEC>;
        ///Register `IPRIOR63` writer
        pub type W = crate::W<IPRIOR63_SPEC>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<IPRIOR63_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                core::fmt::Debug::fmt(&self.read(), f)
            }
        }
        impl W {
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior63::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior63::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR63_SPEC;
        impl crate::RegisterSpec for IPRIOR63_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`iprior63::R`](R) reader structure
        impl crate::Readable for IPRIOR63_SPEC {}
        ///`write(|w| ..)` method takes [`iprior63::W`](W) writer structure
        impl crate::Writable for IPRIOR63_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets IPRIOR63 to value 0
        impl crate::Resettable for IPRIOR63_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///IPRIOR64 (rw) register accessor: Interrupt Priority Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior64::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior64::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior64`]
    ///module
    pub type IPRIOR64 = crate::Reg<iprior64::IPRIOR64_SPEC>;
    ///Interrupt Priority Register
    pub mod iprior64 {
        ///Register `IPRIOR64` reader
        pub type R = crate::R<IPRIOR64_SPEC>;
        ///Register `IPRIOR64` writer
        pub type W = crate::W<IPRIOR64_SPEC>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<IPRIOR64_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                core::fmt::Debug::fmt(&self.read(), f)
            }
        }
        impl W {
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior64::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior64::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR64_SPEC;
        impl crate::RegisterSpec for IPRIOR64_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`iprior64::R`](R) reader structure
        impl crate::Readable for IPRIOR64_SPEC {}
        ///`write(|w| ..)` method takes [`iprior64::W`](W) writer structure
        impl crate::Writable for IPRIOR64_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets IPRIOR64 to value 0
        impl crate::Resettable for IPRIOR64_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///IPRIOR65 (rw) register accessor: Interrupt Priority Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior65::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior65::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior65`]
    ///module
    pub type IPRIOR65 = crate::Reg<iprior65::IPRIOR65_SPEC>;
    ///Interrupt Priority Register
    pub mod iprior65 {
        ///Register `IPRIOR65` reader
        pub type R = crate::R<IPRIOR65_SPEC>;
        ///Register `IPRIOR65` writer
        pub type W = crate::W<IPRIOR65_SPEC>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<IPRIOR65_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                core::fmt::Debug::fmt(&self.read(), f)
            }
        }
        impl W {
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior65::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior65::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR65_SPEC;
        impl crate::RegisterSpec for IPRIOR65_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`iprior65::R`](R) reader structure
        impl crate::Readable for IPRIOR65_SPEC {}
        ///`write(|w| ..)` method takes [`iprior65::W`](W) writer structure
        impl crate::Writable for IPRIOR65_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets IPRIOR65 to value 0
        impl crate::Resettable for IPRIOR65_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///IPRIOR66 (rw) register accessor: Interrupt Priority Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior66::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior66::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior66`]
    ///module
    pub type IPRIOR66 = crate::Reg<iprior66::IPRIOR66_SPEC>;
    ///Interrupt Priority Register
    pub mod iprior66 {
        ///Register `IPRIOR66` reader
        pub type R = crate::R<IPRIOR66_SPEC>;
        ///Register `IPRIOR66` writer
        pub type W = crate::W<IPRIOR66_SPEC>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<IPRIOR66_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                core::fmt::Debug::fmt(&self.read(), f)
            }
        }
        impl W {
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior66::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior66::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR66_SPEC;
        impl crate::RegisterSpec for IPRIOR66_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`iprior66::R`](R) reader structure
        impl crate::Readable for IPRIOR66_SPEC {}
        ///`write(|w| ..)` method takes [`iprior66::W`](W) writer structure
        impl crate::Writable for IPRIOR66_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets IPRIOR66 to value 0
        impl crate::Resettable for IPRIOR66_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///IPRIOR67 (rw) register accessor: Interrupt Priority Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior67::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior67::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior67`]
    ///module
    pub type IPRIOR67 = crate::Reg<iprior67::IPRIOR67_SPEC>;
    ///Interrupt Priority Register
    pub mod iprior67 {
        ///Register `IPRIOR67` reader
        pub type R = crate::R<IPRIOR67_SPEC>;
        ///Register `IPRIOR67` writer
        pub type W = crate::W<IPRIOR67_SPEC>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<IPRIOR67_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                core::fmt::Debug::fmt(&self.read(), f)
            }
        }
        impl W {
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior67::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior67::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR67_SPEC;
        impl crate::RegisterSpec for IPRIOR67_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`iprior67::R`](R) reader structure
        impl crate::Readable for IPRIOR67_SPEC {}
        ///`write(|w| ..)` method takes [`iprior67::W`](W) writer structure
        impl crate::Writable for IPRIOR67_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets IPRIOR67 to value 0
        impl crate::Resettable for IPRIOR67_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///IPRIOR68 (rw) register accessor: Interrupt Priority Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior68::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior68::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior68`]
    ///module
    pub type IPRIOR68 = crate::Reg<iprior68::IPRIOR68_SPEC>;
    ///Interrupt Priority Register
    pub mod iprior68 {
        ///Register `IPRIOR68` reader
        pub type R = crate::R<IPRIOR68_SPEC>;
        ///Register `IPRIOR68` writer
        pub type W = crate::W<IPRIOR68_SPEC>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<IPRIOR68_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                core::fmt::Debug::fmt(&self.read(), f)
            }
        }
        impl W {
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior68::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior68::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR68_SPEC;
        impl crate::RegisterSpec for IPRIOR68_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`iprior68::R`](R) reader structure
        impl crate::Readable for IPRIOR68_SPEC {}
        ///`write(|w| ..)` method takes [`iprior68::W`](W) writer structure
        impl crate::Writable for IPRIOR68_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets IPRIOR68 to value 0
        impl crate::Resettable for IPRIOR68_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///SCTLR (rw) register accessor: System Control Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`sctlr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`sctlr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@sctlr`]
    ///module
    pub type SCTLR = crate::Reg<sctlr::SCTLR_SPEC>;
    ///System Control Register
    pub mod sctlr {
        ///Register `SCTLR` reader
        pub type R = crate::R<SCTLR_SPEC>;
        ///Register `SCTLR` writer
        pub type W = crate::W<SCTLR_SPEC>;
        ///Field `SLEEPONEXIT` reader - SLEEPONEXIT
        pub type SLEEPONEXIT_R = crate::BitReader;
        ///Field `SLEEPONEXIT` writer - SLEEPONEXIT
        pub type SLEEPONEXIT_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `SLEEPDEEP` reader - SLEEPDEEP
        pub type SLEEPDEEP_R = crate::BitReader;
        ///Field `SLEEPDEEP` writer - SLEEPDEEP
        pub type SLEEPDEEP_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `WFITOWFE` reader - WFITOWFE
        pub type WFITOWFE_R = crate::BitReader;
        ///Field `WFITOWFE` writer - WFITOWFE
        pub type WFITOWFE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `SEVONPEND` reader - SEVONPEND
        pub type SEVONPEND_R = crate::BitReader;
        ///Field `SEVONPEND` writer - SEVONPEND
        pub type SEVONPEND_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `SETEVENT` reader - SETEVENT
        pub type SETEVENT_R = crate::BitReader;
        ///Field `SETEVENT` writer - SETEVENT
        pub type SETEVENT_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `SYSRESET` reader - SYSRESET
        pub type SYSRESET_R = crate::BitReader;
        ///Field `SYSRESET` writer - SYSRESET
        pub type SYSRESET_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 1 - SLEEPONEXIT
            #[inline(always)]
            pub fn sleeponexit(&self) -> SLEEPONEXIT_R {
                SLEEPONEXIT_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - SLEEPDEEP
            #[inline(always)]
            pub fn sleepdeep(&self) -> SLEEPDEEP_R {
                SLEEPDEEP_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - WFITOWFE
            #[inline(always)]
            pub fn wfitowfe(&self) -> WFITOWFE_R {
                WFITOWFE_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - SEVONPEND
            #[inline(always)]
            pub fn sevonpend(&self) -> SEVONPEND_R {
                SEVONPEND_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - SETEVENT
            #[inline(always)]
            pub fn setevent(&self) -> SETEVENT_R {
                SETEVENT_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 31 - SYSRESET
            #[inline(always)]
            pub fn sysreset(&self) -> SYSRESET_R {
                SYSRESET_R::new(((self.bits >> 31) & 1) != 0)
            }
        }
        impl W {
            ///Bit 1 - SLEEPONEXIT
            #[inline(always)]
            #[must_use]
            pub fn sleeponexit(&mut self) -> SLEEPONEXIT_W<SCTLR_SPEC> {
                SLEEPONEXIT_W::new(self, 1)
            }
            ///Bit 2 - SLEEPDEEP
            #[inline(always)]
            #[must_use]
            pub fn sleepdeep(&mut self) -> SLEEPDEEP_W<SCTLR_SPEC> {
                SLEEPDEEP_W::new(self, 2)
            }
            ///Bit 3 - WFITOWFE
            #[inline(always)]
            #[must_use]
            pub fn wfitowfe(&mut self) -> WFITOWFE_W<SCTLR_SPEC> {
                WFITOWFE_W::new(self, 3)
            }
            ///Bit 4 - SEVONPEND
            #[inline(always)]
            #[must_use]
            pub fn sevonpend(&mut self) -> SEVONPEND_W<SCTLR_SPEC> {
                SEVONPEND_W::new(self, 4)
            }
            ///Bit 5 - SETEVENT
            #[inline(always)]
            #[must_use]
            pub fn setevent(&mut self) -> SETEVENT_W<SCTLR_SPEC> {
                SETEVENT_W::new(self, 5)
            }
            ///Bit 31 - SYSRESET
            #[inline(always)]
            #[must_use]
            pub fn sysreset(&mut self) -> SYSRESET_W<SCTLR_SPEC> {
                SYSRESET_W::new(self, 31)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///System Control Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`sctlr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`sctlr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct SCTLR_SPEC;
        impl crate::RegisterSpec for SCTLR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`sctlr::R`](R) reader structure
        impl crate::Readable for SCTLR_SPEC {}
        ///`write(|w| ..)` method takes [`sctlr::W`](W) writer structure
        impl crate::Writable for SCTLR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets SCTLR to value 0
        impl crate::Resettable for SCTLR_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///STK_CTLR (rw) register accessor: System counter control register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`stk_ctlr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`stk_ctlr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@stk_ctlr`]
    ///module
    pub type STK_CTLR = crate::Reg<stk_ctlr::STK_CTLR_SPEC>;
    ///System counter control register
    pub mod stk_ctlr {
        ///Register `STK_CTLR` reader
        pub type R = crate::R<STK_CTLR_SPEC>;
        ///Register `STK_CTLR` writer
        pub type W = crate::W<STK_CTLR_SPEC>;
        ///Field `STE` reader - System counter enable
        pub type STE_R = crate::BitReader;
        ///Field `STE` writer - System counter enable
        pub type STE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `STIE` reader - System counter interrupt enable
        pub type STIE_R = crate::BitReader;
        ///Field `STIE` writer - System counter interrupt enable
        pub type STIE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `STCLK` reader - System selects the clock source
        pub type STCLK_R = crate::BitReader;
        ///Field `STCLK` writer - System selects the clock source
        pub type STCLK_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `STRE` reader - System reload register
        pub type STRE_R = crate::BitReader;
        ///Field `STRE` writer - System reload register
        pub type STRE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `MODE` reader - System Mode
        pub type MODE_R = crate::BitReader;
        ///Field `MODE` writer - System Mode
        pub type MODE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `INIT` reader - System Initialization update
        pub type INIT_R = crate::BitReader;
        ///Field `INIT` writer - System Initialization update
        pub type INIT_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `SWIE` reader - System software triggered interrupts enable
        pub type SWIE_R = crate::BitReader;
        ///Field `SWIE` writer - System software triggered interrupts enable
        pub type SWIE_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - System counter enable
            #[inline(always)]
            pub fn ste(&self) -> STE_R {
                STE_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - System counter interrupt enable
            #[inline(always)]
            pub fn stie(&self) -> STIE_R {
                STIE_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - System selects the clock source
            #[inline(always)]
            pub fn stclk(&self) -> STCLK_R {
                STCLK_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - System reload register
            #[inline(always)]
            pub fn stre(&self) -> STRE_R {
                STRE_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - System Mode
            #[inline(always)]
            pub fn mode(&self) -> MODE_R {
                MODE_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - System Initialization update
            #[inline(always)]
            pub fn init(&self) -> INIT_R {
                INIT_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 31 - System software triggered interrupts enable
            #[inline(always)]
            pub fn swie(&self) -> SWIE_R {
                SWIE_R::new(((self.bits >> 31) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - System counter enable
            #[inline(always)]
            #[must_use]
            pub fn ste(&mut self) -> STE_W<STK_CTLR_SPEC> {
                STE_W::new(self, 0)
            }
            ///Bit 1 - System counter interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn stie(&mut self) -> STIE_W<STK_CTLR_SPEC> {
                STIE_W::new(self, 1)
            }
            ///Bit 2 - System selects the clock source
            #[inline(always)]
            #[must_use]
            pub fn stclk(&mut self) -> STCLK_W<STK_CTLR_SPEC> {
                STCLK_W::new(self, 2)
            }
            ///Bit 3 - System reload register
            #[inline(always)]
            #[must_use]
            pub fn stre(&mut self) -> STRE_W<STK_CTLR_SPEC> {
                STRE_W::new(self, 3)
            }
            ///Bit 4 - System Mode
            #[inline(always)]
            #[must_use]
            pub fn mode(&mut self) -> MODE_W<STK_CTLR_SPEC> {
                MODE_W::new(self, 4)
            }
            ///Bit 5 - System Initialization update
            #[inline(always)]
            #[must_use]
            pub fn init(&mut self) -> INIT_W<STK_CTLR_SPEC> {
                INIT_W::new(self, 5)
            }
            ///Bit 31 - System software triggered interrupts enable
            #[inline(always)]
            #[must_use]
            pub fn swie(&mut self) -> SWIE_W<STK_CTLR_SPEC> {
                SWIE_W::new(self, 31)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///System counter control register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`stk_ctlr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`stk_ctlr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct STK_CTLR_SPEC;
        impl crate::RegisterSpec for STK_CTLR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`stk_ctlr::R`](R) reader structure
        impl crate::Readable for STK_CTLR_SPEC {}
        ///`write(|w| ..)` method takes [`stk_ctlr::W`](W) writer structure
        impl crate::Writable for STK_CTLR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets STK_CTLR to value 0
        impl crate::Resettable for STK_CTLR_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///STK_SR (rw) register accessor: System START
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`stk_sr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`stk_sr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@stk_sr`]
    ///module
    pub type STK_SR = crate::Reg<stk_sr::STK_SR_SPEC>;
    ///System START
    pub mod stk_sr {
        ///Register `STK_SR` reader
        pub type R = crate::R<STK_SR_SPEC>;
        ///Register `STK_SR` writer
        pub type W = crate::W<STK_SR_SPEC>;
        ///Field `CNTIF` reader - CNTIF
        pub type CNTIF_R = crate::BitReader;
        ///Field `CNTIF` writer - CNTIF
        pub type CNTIF_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - CNTIF
            #[inline(always)]
            pub fn cntif(&self) -> CNTIF_R {
                CNTIF_R::new((self.bits & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - CNTIF
            #[inline(always)]
            #[must_use]
            pub fn cntif(&mut self) -> CNTIF_W<STK_SR_SPEC> {
                CNTIF_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///System START
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`stk_sr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`stk_sr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct STK_SR_SPEC;
        impl crate::RegisterSpec for STK_SR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`stk_sr::R`](R) reader structure
        impl crate::Readable for STK_SR_SPEC {}
        ///`write(|w| ..)` method takes [`stk_sr::W`](W) writer structure
        impl crate::Writable for STK_SR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets STK_SR to value 0
        impl crate::Resettable for STK_SR_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///STK_CNTL (rw) register accessor: System counter low register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`stk_cntl::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`stk_cntl::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@stk_cntl`]
    ///module
    pub type STK_CNTL = crate::Reg<stk_cntl::STK_CNTL_SPEC>;
    ///System counter low register
    pub mod stk_cntl {
        ///Register `STK_CNTL` reader
        pub type R = crate::R<STK_CNTL_SPEC>;
        ///Register `STK_CNTL` writer
        pub type W = crate::W<STK_CNTL_SPEC>;
        ///Field `CNTL` reader - CNTL
        pub type CNTL_R = crate::FieldReader<u32>;
        ///Field `CNTL` writer - CNTL
        pub type CNTL_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - CNTL
            #[inline(always)]
            pub fn cntl(&self) -> CNTL_R {
                CNTL_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - CNTL
            #[inline(always)]
            #[must_use]
            pub fn cntl(&mut self) -> CNTL_W<STK_CNTL_SPEC> {
                CNTL_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///System counter low register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`stk_cntl::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`stk_cntl::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct STK_CNTL_SPEC;
        impl crate::RegisterSpec for STK_CNTL_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`stk_cntl::R`](R) reader structure
        impl crate::Readable for STK_CNTL_SPEC {}
        ///`write(|w| ..)` method takes [`stk_cntl::W`](W) writer structure
        impl crate::Writable for STK_CNTL_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets STK_CNTL to value 0
        impl crate::Resettable for STK_CNTL_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///STK_CNTH (rw) register accessor: System counter high register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`stk_cnth::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`stk_cnth::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@stk_cnth`]
    ///module
    pub type STK_CNTH = crate::Reg<stk_cnth::STK_CNTH_SPEC>;
    ///System counter high register
    pub mod stk_cnth {
        ///Register `STK_CNTH` reader
        pub type R = crate::R<STK_CNTH_SPEC>;
        ///Register `STK_CNTH` writer
        pub type W = crate::W<STK_CNTH_SPEC>;
        ///Field `CNTH` reader - CNTH
        pub type CNTH_R = crate::FieldReader<u32>;
        ///Field `CNTH` writer - CNTH
        pub type CNTH_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - CNTH
            #[inline(always)]
            pub fn cnth(&self) -> CNTH_R {
                CNTH_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - CNTH
            #[inline(always)]
            #[must_use]
            pub fn cnth(&mut self) -> CNTH_W<STK_CNTH_SPEC> {
                CNTH_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///System counter high register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`stk_cnth::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`stk_cnth::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct STK_CNTH_SPEC;
        impl crate::RegisterSpec for STK_CNTH_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`stk_cnth::R`](R) reader structure
        impl crate::Readable for STK_CNTH_SPEC {}
        ///`write(|w| ..)` method takes [`stk_cnth::W`](W) writer structure
        impl crate::Writable for STK_CNTH_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets STK_CNTH to value 0
        impl crate::Resettable for STK_CNTH_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///STK_CMPLR (rw) register accessor: System compare low register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`stk_cmplr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`stk_cmplr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@stk_cmplr`]
    ///module
    pub type STK_CMPLR = crate::Reg<stk_cmplr::STK_CMPLR_SPEC>;
    ///System compare low register
    pub mod stk_cmplr {
        ///Register `STK_CMPLR` reader
        pub type R = crate::R<STK_CMPLR_SPEC>;
        ///Register `STK_CMPLR` writer
        pub type W = crate::W<STK_CMPLR_SPEC>;
        ///Field `CMPL` reader - CMPL
        pub type CMPL_R = crate::FieldReader<u32>;
        ///Field `CMPL` writer - CMPL
        pub type CMPL_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - CMPL
            #[inline(always)]
            pub fn cmpl(&self) -> CMPL_R {
                CMPL_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - CMPL
            #[inline(always)]
            #[must_use]
            pub fn cmpl(&mut self) -> CMPL_W<STK_CMPLR_SPEC> {
                CMPL_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///System compare low register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`stk_cmplr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`stk_cmplr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct STK_CMPLR_SPEC;
        impl crate::RegisterSpec for STK_CMPLR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`stk_cmplr::R`](R) reader structure
        impl crate::Readable for STK_CMPLR_SPEC {}
        ///`write(|w| ..)` method takes [`stk_cmplr::W`](W) writer structure
        impl crate::Writable for STK_CMPLR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets STK_CMPLR to value 0
        impl crate::Resettable for STK_CMPLR_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///STK_CMPHR (rw) register accessor: System compare high register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`stk_cmphr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`stk_cmphr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@stk_cmphr`]
    ///module
    pub type STK_CMPHR = crate::Reg<stk_cmphr::STK_CMPHR_SPEC>;
    ///System compare high register
    pub mod stk_cmphr {
        ///Register `STK_CMPHR` reader
        pub type R = crate::R<STK_CMPHR_SPEC>;
        ///Register `STK_CMPHR` writer
        pub type W = crate::W<STK_CMPHR_SPEC>;
        ///Field `CMPH` reader - CMPH
        pub type CMPH_R = crate::FieldReader<u32>;
        ///Field `CMPH` writer - CMPH
        pub type CMPH_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - CMPH
            #[inline(always)]
            pub fn cmph(&self) -> CMPH_R {
                CMPH_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - CMPH
            #[inline(always)]
            #[must_use]
            pub fn cmph(&mut self) -> CMPH_W<STK_CMPHR_SPEC> {
                CMPH_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///System compare high register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`stk_cmphr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`stk_cmphr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct STK_CMPHR_SPEC;
        impl crate::RegisterSpec for STK_CMPHR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`stk_cmphr::R`](R) reader structure
        impl crate::Readable for STK_CMPHR_SPEC {}
        ///`write(|w| ..)` method takes [`stk_cmphr::W`](W) writer structure
        impl crate::Writable for STK_CMPHR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets STK_CMPHR to value 0
        impl crate::Resettable for STK_CMPHR_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
}
///Low-power timer
pub struct LPTIM {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for LPTIM {}
impl LPTIM {
    ///Pointer to the register block
    pub const PTR: *const lptim::RegisterBlock = 0x4000_7c00 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const lptim::RegisterBlock {
        Self::PTR
    }
    /// Steal an instance of this peripheral
    ///
    /// # Safety
    ///
    /// Ensure that the new instance of the peripheral cannot be used in a way
    /// that may race with any existing instances, for example by only
    /// accessing read-only or write-only registers, or by consuming the
    /// original peripheral and using critical sections to coordinate
    /// access between multiple new instances.
    ///
    /// Additionally, other software such as HALs may rely on only one
    /// peripheral instance existing to ensure memory safety; ensure
    /// no stolen instances are passed to such software.
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for LPTIM {
    type Target = lptim::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for LPTIM {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("LPTIM").finish()
    }
}
///Low-power timer
pub mod lptim {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        isr: ISR,
        icr: ICR,
        ier: IER,
        cfgr: CFGR,
        cr: CR,
        cmp: CMP,
        arr: ARR,
        cnt: CNT,
    }
    impl RegisterBlock {
        ///0x00 - interrupt status register
        #[inline(always)]
        pub const fn isr(&self) -> &ISR {
            &self.isr
        }
        ///0x04 - interrupt clear register
        #[inline(always)]
        pub const fn icr(&self) -> &ICR {
            &self.icr
        }
        ///0x08 - interrupt enable register
        #[inline(always)]
        pub const fn ier(&self) -> &IER {
            &self.ier
        }
        ///0x0c - configuration register
        #[inline(always)]
        pub const fn cfgr(&self) -> &CFGR {
            &self.cfgr
        }
        ///0x10 - control register
        #[inline(always)]
        pub const fn cr(&self) -> &CR {
            &self.cr
        }
        ///0x14 - compare register
        #[inline(always)]
        pub const fn cmp(&self) -> &CMP {
            &self.cmp
        }
        ///0x18 - aoto-reload register
        #[inline(always)]
        pub const fn arr(&self) -> &ARR {
            &self.arr
        }
        ///0x1c - COUNT register
        #[inline(always)]
        pub const fn cnt(&self) -> &CNT {
            &self.cnt
        }
    }
    ///ISR (r) register accessor: interrupt status register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`isr::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@isr`]
    ///module
    pub type ISR = crate::Reg<isr::ISR_SPEC>;
    ///interrupt status register
    pub mod isr {
        ///Register `ISR` reader
        pub type R = crate::R<ISR_SPEC>;
        ///Field `CMPM` reader - DATA of compare register and LPTIM_CNT match
        pub type CMPM_R = crate::BitReader;
        ///Field `ARRM` reader - DATA of Aoto-reload register and LPTIM_CNT match
        pub type ARRM_R = crate::BitReader;
        ///Field `EXTTRIG` reader - Edge event are triggerd externally
        pub type EXTTRIG_R = crate::BitReader;
        ///Field `CMPOK` reader - compare register data update successfully
        pub type CMPOK_R = crate::BitReader;
        ///Field `ARROK` reader - Aoto-reload register data update successfully
        pub type ARROK_R = crate::BitReader;
        ///Field `UP` reader - count-up
        pub type UP_R = crate::BitReader;
        ///Field `DOWN` reader - count down
        pub type DOWN_R = crate::BitReader;
        ///Field `DIR_SYNC` reader - direction of count
        pub type DIR_SYNC_R = crate::BitReader;
        impl R {
            ///Bit 0 - DATA of compare register and LPTIM_CNT match
            #[inline(always)]
            pub fn cmpm(&self) -> CMPM_R {
                CMPM_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - DATA of Aoto-reload register and LPTIM_CNT match
            #[inline(always)]
            pub fn arrm(&self) -> ARRM_R {
                ARRM_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - Edge event are triggerd externally
            #[inline(always)]
            pub fn exttrig(&self) -> EXTTRIG_R {
                EXTTRIG_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - compare register data update successfully
            #[inline(always)]
            pub fn cmpok(&self) -> CMPOK_R {
                CMPOK_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - Aoto-reload register data update successfully
            #[inline(always)]
            pub fn arrok(&self) -> ARROK_R {
                ARROK_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - count-up
            #[inline(always)]
            pub fn up(&self) -> UP_R {
                UP_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - count down
            #[inline(always)]
            pub fn down(&self) -> DOWN_R {
                DOWN_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - direction of count
            #[inline(always)]
            pub fn dir_sync(&self) -> DIR_SYNC_R {
                DIR_SYNC_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        ///interrupt status register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`isr::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct ISR_SPEC;
        impl crate::RegisterSpec for ISR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`isr::R`](R) reader structure
        impl crate::Readable for ISR_SPEC {}
        ///`reset()` method sets ISR to value 0
        impl crate::Resettable for ISR_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///ICR (w) register accessor: interrupt clear register
    ///
    ///You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`icr::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@icr`]
    ///module
    pub type ICR = crate::Reg<icr::ICR_SPEC>;
    ///interrupt clear register
    pub mod icr {
        ///Register `ICR` writer
        pub type W = crate::W<ICR_SPEC>;
        ///Field `CMPMCF` writer - clear compare register match flag
        pub type CMPMCF_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `ARRMCF` writer - clear Aoto-reload register match flag
        pub type ARRMCF_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `EXTTRIGCF` writer - clear Edge event are triggerd externally flag
        pub type EXTTRIGCF_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CMPOKCF` writer - clear compare register data update flag
        pub type CMPOKCF_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `ARROKCF` writer - clear Aoto-reload register data update flag
        pub type ARROKCF_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UPCF` writer - clear up flag
        pub type UPCF_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `DOWNCF` writer - clear down flag
        pub type DOWNCF_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl W {
            ///Bit 0 - clear compare register match flag
            #[inline(always)]
            #[must_use]
            pub fn cmpmcf(&mut self) -> CMPMCF_W<ICR_SPEC> {
                CMPMCF_W::new(self, 0)
            }
            ///Bit 1 - clear Aoto-reload register match flag
            #[inline(always)]
            #[must_use]
            pub fn arrmcf(&mut self) -> ARRMCF_W<ICR_SPEC> {
                ARRMCF_W::new(self, 1)
            }
            ///Bit 2 - clear Edge event are triggerd externally flag
            #[inline(always)]
            #[must_use]
            pub fn exttrigcf(&mut self) -> EXTTRIGCF_W<ICR_SPEC> {
                EXTTRIGCF_W::new(self, 2)
            }
            ///Bit 3 - clear compare register data update flag
            #[inline(always)]
            #[must_use]
            pub fn cmpokcf(&mut self) -> CMPOKCF_W<ICR_SPEC> {
                CMPOKCF_W::new(self, 3)
            }
            ///Bit 4 - clear Aoto-reload register data update flag
            #[inline(always)]
            #[must_use]
            pub fn arrokcf(&mut self) -> ARROKCF_W<ICR_SPEC> {
                ARROKCF_W::new(self, 4)
            }
            ///Bit 5 - clear up flag
            #[inline(always)]
            #[must_use]
            pub fn upcf(&mut self) -> UPCF_W<ICR_SPEC> {
                UPCF_W::new(self, 5)
            }
            ///Bit 6 - clear down flag
            #[inline(always)]
            #[must_use]
            pub fn downcf(&mut self) -> DOWNCF_W<ICR_SPEC> {
                DOWNCF_W::new(self, 6)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///interrupt clear register
        ///
        ///You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`icr::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct ICR_SPEC;
        impl crate::RegisterSpec for ICR_SPEC {
            type Ux = u32;
        }
        ///`write(|w| ..)` method takes [`icr::W`](W) writer structure
        impl crate::Writable for ICR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets ICR to value 0
        impl crate::Resettable for ICR_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IER (rw) register accessor: interrupt enable register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`ier::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ier::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@ier`]
    ///module
    pub type IER = crate::Reg<ier::IER_SPEC>;
    ///interrupt enable register
    pub mod ier {
        ///Register `IER` reader
        pub type R = crate::R<IER_SPEC>;
        ///Register `IER` writer
        pub type W = crate::W<IER_SPEC>;
        ///Field `CMPMIE` reader - compare register match successfully interrupts enable
        pub type CMPMIE_R = crate::BitReader;
        ///Field `CMPMIE` writer - compare register match successfully interrupts enable
        pub type CMPMIE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `ARRMIE` reader - Aoto-reload register match successfully interrupts enable
        pub type ARRMIE_R = crate::BitReader;
        ///Field `ARRMIE` writer - Aoto-reload register match successfully interrupts enable
        pub type ARRMIE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `EXTTRIGIE` reader - Edge event are triggerd externally successfully interrupts enable
        pub type EXTTRIGIE_R = crate::BitReader;
        ///Field `EXTTRIGIE` writer - Edge event are triggerd externally successfully interrupts enable
        pub type EXTTRIGIE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CMPOKIE` reader - compare register data update successfully interrupts enable
        pub type CMPOKIE_R = crate::BitReader;
        ///Field `CMPOKIE` writer - compare register data update successfully interrupts enable
        pub type CMPOKIE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `ARROKIE` reader - Aoto-reload register data update successfully interrupts enable
        pub type ARROKIE_R = crate::BitReader;
        ///Field `ARROKIE` writer - Aoto-reload register data update successfully interrupts enable
        pub type ARROKIE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UPIE` reader - UP interrupt enable
        pub type UPIE_R = crate::BitReader;
        ///Field `UPIE` writer - UP interrupt enable
        pub type UPIE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `DOWNIE` reader - Down interrupt enable
        pub type DOWNIE_R = crate::BitReader;
        ///Field `DOWNIE` writer - Down interrupt enable
        pub type DOWNIE_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - compare register match successfully interrupts enable
            #[inline(always)]
            pub fn cmpmie(&self) -> CMPMIE_R {
                CMPMIE_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Aoto-reload register match successfully interrupts enable
            #[inline(always)]
            pub fn arrmie(&self) -> ARRMIE_R {
                ARRMIE_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - Edge event are triggerd externally successfully interrupts enable
            #[inline(always)]
            pub fn exttrigie(&self) -> EXTTRIGIE_R {
                EXTTRIGIE_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - compare register data update successfully interrupts enable
            #[inline(always)]
            pub fn cmpokie(&self) -> CMPOKIE_R {
                CMPOKIE_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - Aoto-reload register data update successfully interrupts enable
            #[inline(always)]
            pub fn arrokie(&self) -> ARROKIE_R {
                ARROKIE_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - UP interrupt enable
            #[inline(always)]
            pub fn upie(&self) -> UPIE_R {
                UPIE_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - Down interrupt enable
            #[inline(always)]
            pub fn downie(&self) -> DOWNIE_R {
                DOWNIE_R::new(((self.bits >> 6) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - compare register match successfully interrupts enable
            #[inline(always)]
            #[must_use]
            pub fn cmpmie(&mut self) -> CMPMIE_W<IER_SPEC> {
                CMPMIE_W::new(self, 0)
            }
            ///Bit 1 - Aoto-reload register match successfully interrupts enable
            #[inline(always)]
            #[must_use]
            pub fn arrmie(&mut self) -> ARRMIE_W<IER_SPEC> {
                ARRMIE_W::new(self, 1)
            }
            ///Bit 2 - Edge event are triggerd externally successfully interrupts enable
            #[inline(always)]
            #[must_use]
            pub fn exttrigie(&mut self) -> EXTTRIGIE_W<IER_SPEC> {
                EXTTRIGIE_W::new(self, 2)
            }
            ///Bit 3 - compare register data update successfully interrupts enable
            #[inline(always)]
            #[must_use]
            pub fn cmpokie(&mut self) -> CMPOKIE_W<IER_SPEC> {
                CMPOKIE_W::new(self, 3)
            }
            ///Bit 4 - Aoto-reload register data update successfully interrupts enable
            #[inline(always)]
            #[must_use]
            pub fn arrokie(&mut self) -> ARROKIE_W<IER_SPEC> {
                ARROKIE_W::new(self, 4)
            }
            ///Bit 5 - UP interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn upie(&mut self) -> UPIE_W<IER_SPEC> {
                UPIE_W::new(self, 5)
            }
            ///Bit 6 - Down interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn downie(&mut self) -> DOWNIE_W<IER_SPEC> {
                DOWNIE_W::new(self, 6)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///interrupt enable register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`ier::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ier::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IER_SPEC;
        impl crate::RegisterSpec for IER_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`ier::R`](R) reader structure
        impl crate::Readable for IER_SPEC {}
        ///`write(|w| ..)` method takes [`ier::W`](W) writer structure
        impl crate::Writable for IER_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IER to value 0
        impl crate::Resettable for IER_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///CFGR (rw) register accessor: configuration register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`cfgr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cfgr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@cfgr`]
    ///module
    pub type CFGR = crate::Reg<cfgr::CFGR_SPEC>;
    ///configuration register
    pub mod cfgr {
        ///Register `CFGR` reader
        pub type R = crate::R<CFGR_SPEC>;
        ///Register `CFGR` writer
        pub type W = crate::W<CFGR_SPEC>;
        ///Field `CKSEL` reader - effective edge configuration
        pub type CKSEL_R = crate::BitReader;
        ///Field `CKSEL` writer - effective edge configuration
        pub type CKSEL_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CKPOL` reader - configure effective edges
        pub type CKPOL_R = crate::FieldReader;
        ///Field `CKPOL` writer - configure effective edges
        pub type CKPOL_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `CKFLT` reader - digital filter for ex-clock
        pub type CKFLT_R = crate::FieldReader;
        ///Field `CKFLT` writer - digital filter for ex-clock
        pub type CKFLT_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `TRGFLT` reader - digital filter for flip-flops
        pub type TRGFLT_R = crate::FieldReader;
        ///Field `TRGFLT` writer - digital filter for flip-flops
        pub type TRGFLT_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `PRESC` reader - prescaler configuration
        pub type PRESC_R = crate::FieldReader;
        ///Field `PRESC` writer - prescaler configuration
        pub type PRESC_W<'a, REG> = crate::FieldWriter<'a, REG, 3>;
        ///Field `TRIGSEL` reader - trigger source selection
        pub type TRIGSEL_R = crate::BitReader;
        ///Field `TRIGSEL` writer - trigger source selection
        pub type TRIGSEL_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TRIGEN` reader - trigger configuration
        pub type TRIGEN_R = crate::FieldReader;
        ///Field `TRIGEN` writer - trigger configuration
        pub type TRIGEN_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `TIMOUT` reader - TIMEOUT control
        pub type TIMOUT_R = crate::BitReader;
        ///Field `TIMOUT` writer - TIMEOUT control
        pub type TIMOUT_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `WAVE` reader - PWM
        pub type WAVE_R = crate::BitReader;
        ///Field `WAVE` writer - PWM
        pub type WAVE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `WAVPOL` reader - PWM polarity
        pub type WAVPOL_R = crate::BitReader;
        ///Field `WAVPOL` writer - PWM polarity
        pub type WAVPOL_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PRELOAD` reader - update mode control
        pub type PRELOAD_R = crate::BitReader;
        ///Field `PRELOAD` writer - update mode control
        pub type PRELOAD_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `COUNTMODE` reader - count clock selection
        pub type COUNTMODE_R = crate::BitReader;
        ///Field `COUNTMODE` writer - count clock selection
        pub type COUNTMODE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `ENC` reader - coder mode
        pub type ENC_R = crate::BitReader;
        ///Field `ENC` writer - coder mode
        pub type ENC_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CLKMX_SEL` reader - clock selection
        pub type CLKMX_SEL_R = crate::FieldReader;
        ///Field `CLKMX_SEL` writer - clock selection
        pub type CLKMX_SEL_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `FORCE_PWM` reader - Forcing pwm output
        pub type FORCE_PWM_R = crate::BitReader;
        ///Field `FORCE_PWM` writer - Forcing pwm output
        pub type FORCE_PWM_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - effective edge configuration
            #[inline(always)]
            pub fn cksel(&self) -> CKSEL_R {
                CKSEL_R::new((self.bits & 1) != 0)
            }
            ///Bits 1:2 - configure effective edges
            #[inline(always)]
            pub fn ckpol(&self) -> CKPOL_R {
                CKPOL_R::new(((self.bits >> 1) & 3) as u8)
            }
            ///Bits 3:4 - digital filter for ex-clock
            #[inline(always)]
            pub fn ckflt(&self) -> CKFLT_R {
                CKFLT_R::new(((self.bits >> 3) & 3) as u8)
            }
            ///Bits 6:7 - digital filter for flip-flops
            #[inline(always)]
            pub fn trgflt(&self) -> TRGFLT_R {
                TRGFLT_R::new(((self.bits >> 6) & 3) as u8)
            }
            ///Bits 9:11 - prescaler configuration
            #[inline(always)]
            pub fn presc(&self) -> PRESC_R {
                PRESC_R::new(((self.bits >> 9) & 7) as u8)
            }
            ///Bit 13 - trigger source selection
            #[inline(always)]
            pub fn trigsel(&self) -> TRIGSEL_R {
                TRIGSEL_R::new(((self.bits >> 13) & 1) != 0)
            }
            ///Bits 17:18 - trigger configuration
            #[inline(always)]
            pub fn trigen(&self) -> TRIGEN_R {
                TRIGEN_R::new(((self.bits >> 17) & 3) as u8)
            }
            ///Bit 19 - TIMEOUT control
            #[inline(always)]
            pub fn timout(&self) -> TIMOUT_R {
                TIMOUT_R::new(((self.bits >> 19) & 1) != 0)
            }
            ///Bit 20 - PWM
            #[inline(always)]
            pub fn wave(&self) -> WAVE_R {
                WAVE_R::new(((self.bits >> 20) & 1) != 0)
            }
            ///Bit 21 - PWM polarity
            #[inline(always)]
            pub fn wavpol(&self) -> WAVPOL_R {
                WAVPOL_R::new(((self.bits >> 21) & 1) != 0)
            }
            ///Bit 22 - update mode control
            #[inline(always)]
            pub fn preload(&self) -> PRELOAD_R {
                PRELOAD_R::new(((self.bits >> 22) & 1) != 0)
            }
            ///Bit 23 - count clock selection
            #[inline(always)]
            pub fn countmode(&self) -> COUNTMODE_R {
                COUNTMODE_R::new(((self.bits >> 23) & 1) != 0)
            }
            ///Bit 24 - coder mode
            #[inline(always)]
            pub fn enc(&self) -> ENC_R {
                ENC_R::new(((self.bits >> 24) & 1) != 0)
            }
            ///Bits 25:26 - clock selection
            #[inline(always)]
            pub fn clkmx_sel(&self) -> CLKMX_SEL_R {
                CLKMX_SEL_R::new(((self.bits >> 25) & 3) as u8)
            }
            ///Bit 27 - Forcing pwm output
            #[inline(always)]
            pub fn force_pwm(&self) -> FORCE_PWM_R {
                FORCE_PWM_R::new(((self.bits >> 27) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - effective edge configuration
            #[inline(always)]
            #[must_use]
            pub fn cksel(&mut self) -> CKSEL_W<CFGR_SPEC> {
                CKSEL_W::new(self, 0)
            }
            ///Bits 1:2 - configure effective edges
            #[inline(always)]
            #[must_use]
            pub fn ckpol(&mut self) -> CKPOL_W<CFGR_SPEC> {
                CKPOL_W::new(self, 1)
            }
            ///Bits 3:4 - digital filter for ex-clock
            #[inline(always)]
            #[must_use]
            pub fn ckflt(&mut self) -> CKFLT_W<CFGR_SPEC> {
                CKFLT_W::new(self, 3)
            }
            ///Bits 6:7 - digital filter for flip-flops
            #[inline(always)]
            #[must_use]
            pub fn trgflt(&mut self) -> TRGFLT_W<CFGR_SPEC> {
                TRGFLT_W::new(self, 6)
            }
            ///Bits 9:11 - prescaler configuration
            #[inline(always)]
            #[must_use]
            pub fn presc(&mut self) -> PRESC_W<CFGR_SPEC> {
                PRESC_W::new(self, 9)
            }
            ///Bit 13 - trigger source selection
            #[inline(always)]
            #[must_use]
            pub fn trigsel(&mut self) -> TRIGSEL_W<CFGR_SPEC> {
                TRIGSEL_W::new(self, 13)
            }
            ///Bits 17:18 - trigger configuration
            #[inline(always)]
            #[must_use]
            pub fn trigen(&mut self) -> TRIGEN_W<CFGR_SPEC> {
                TRIGEN_W::new(self, 17)
            }
            ///Bit 19 - TIMEOUT control
            #[inline(always)]
            #[must_use]
            pub fn timout(&mut self) -> TIMOUT_W<CFGR_SPEC> {
                TIMOUT_W::new(self, 19)
            }
            ///Bit 20 - PWM
            #[inline(always)]
            #[must_use]
            pub fn wave(&mut self) -> WAVE_W<CFGR_SPEC> {
                WAVE_W::new(self, 20)
            }
            ///Bit 21 - PWM polarity
            #[inline(always)]
            #[must_use]
            pub fn wavpol(&mut self) -> WAVPOL_W<CFGR_SPEC> {
                WAVPOL_W::new(self, 21)
            }
            ///Bit 22 - update mode control
            #[inline(always)]
            #[must_use]
            pub fn preload(&mut self) -> PRELOAD_W<CFGR_SPEC> {
                PRELOAD_W::new(self, 22)
            }
            ///Bit 23 - count clock selection
            #[inline(always)]
            #[must_use]
            pub fn countmode(&mut self) -> COUNTMODE_W<CFGR_SPEC> {
                COUNTMODE_W::new(self, 23)
            }
            ///Bit 24 - coder mode
            #[inline(always)]
            #[must_use]
            pub fn enc(&mut self) -> ENC_W<CFGR_SPEC> {
                ENC_W::new(self, 24)
            }
            ///Bits 25:26 - clock selection
            #[inline(always)]
            #[must_use]
            pub fn clkmx_sel(&mut self) -> CLKMX_SEL_W<CFGR_SPEC> {
                CLKMX_SEL_W::new(self, 25)
            }
            ///Bit 27 - Forcing pwm output
            #[inline(always)]
            #[must_use]
            pub fn force_pwm(&mut self) -> FORCE_PWM_W<CFGR_SPEC> {
                FORCE_PWM_W::new(self, 27)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///configuration register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`cfgr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cfgr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct CFGR_SPEC;
        impl crate::RegisterSpec for CFGR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`cfgr::R`](R) reader structure
        impl crate::Readable for CFGR_SPEC {}
        ///`write(|w| ..)` method takes [`cfgr::W`](W) writer structure
        impl crate::Writable for CFGR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets CFGR to value 0
        impl crate::Resettable for CFGR_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///CR (rw) register accessor: control register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`cr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@cr`]
    ///module
    pub type CR = crate::Reg<cr::CR_SPEC>;
    ///control register
    pub mod cr {
        ///Register `CR` reader
        pub type R = crate::R<CR_SPEC>;
        ///Register `CR` writer
        pub type W = crate::W<CR_SPEC>;
        ///Field `ENABLE` reader - timer enable
        pub type ENABLE_R = crate::BitReader;
        ///Field `ENABLE` writer - timer enable
        pub type ENABLE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `SNGSTRT` reader - start in one trigger mode
        pub type SNGSTRT_R = crate::BitReader;
        ///Field `SNGSTRT` writer - start in one trigger mode
        pub type SNGSTRT_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CNTSTRT` reader - start in continuous mode
        pub type CNTSTRT_R = crate::BitReader;
        ///Field `CNTSTRT` writer - start in continuous mode
        pub type CNTSTRT_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `OUTEN` reader - pwm output enable
        pub type OUTEN_R = crate::BitReader;
        ///Field `OUTEN` writer - pwm output enable
        pub type OUTEN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `DIR_EXTEN` reader - externally trigger count direction enable
        pub type DIR_EXTEN_R = crate::BitReader;
        ///Field `DIR_EXTEN` writer - externally trigger count direction enable
        pub type DIR_EXTEN_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - timer enable
            #[inline(always)]
            pub fn enable(&self) -> ENABLE_R {
                ENABLE_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - start in one trigger mode
            #[inline(always)]
            pub fn sngstrt(&self) -> SNGSTRT_R {
                SNGSTRT_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - start in continuous mode
            #[inline(always)]
            pub fn cntstrt(&self) -> CNTSTRT_R {
                CNTSTRT_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - pwm output enable
            #[inline(always)]
            pub fn outen(&self) -> OUTEN_R {
                OUTEN_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - externally trigger count direction enable
            #[inline(always)]
            pub fn dir_exten(&self) -> DIR_EXTEN_R {
                DIR_EXTEN_R::new(((self.bits >> 4) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - timer enable
            #[inline(always)]
            #[must_use]
            pub fn enable(&mut self) -> ENABLE_W<CR_SPEC> {
                ENABLE_W::new(self, 0)
            }
            ///Bit 1 - start in one trigger mode
            #[inline(always)]
            #[must_use]
            pub fn sngstrt(&mut self) -> SNGSTRT_W<CR_SPEC> {
                SNGSTRT_W::new(self, 1)
            }
            ///Bit 2 - start in continuous mode
            #[inline(always)]
            #[must_use]
            pub fn cntstrt(&mut self) -> CNTSTRT_W<CR_SPEC> {
                CNTSTRT_W::new(self, 2)
            }
            ///Bit 3 - pwm output enable
            #[inline(always)]
            #[must_use]
            pub fn outen(&mut self) -> OUTEN_W<CR_SPEC> {
                OUTEN_W::new(self, 3)
            }
            ///Bit 4 - externally trigger count direction enable
            #[inline(always)]
            #[must_use]
            pub fn dir_exten(&mut self) -> DIR_EXTEN_W<CR_SPEC> {
                DIR_EXTEN_W::new(self, 4)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///control register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`cr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct CR_SPEC;
        impl crate::RegisterSpec for CR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`cr::R`](R) reader structure
        impl crate::Readable for CR_SPEC {}
        ///`write(|w| ..)` method takes [`cr::W`](W) writer structure
        impl crate::Writable for CR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets CR to value 0
        impl crate::Resettable for CR_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///CMP (rw) register accessor: compare register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`cmp::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cmp::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@cmp`]
    ///module
    pub type CMP = crate::Reg<cmp::CMP_SPEC>;
    ///compare register
    pub mod cmp {
        ///Register `CMP` reader
        pub type R = crate::R<CMP_SPEC>;
        ///Register `CMP` writer
        pub type W = crate::W<CMP_SPEC>;
        ///Field `CMP` reader - compare value
        pub type CMP_R = crate::FieldReader<u16>;
        ///Field `CMP` writer - compare value
        pub type CMP_W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            ///Bits 0:15 - compare value
            #[inline(always)]
            pub fn cmp(&self) -> CMP_R {
                CMP_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            ///Bits 0:15 - compare value
            #[inline(always)]
            #[must_use]
            pub fn cmp(&mut self) -> CMP_W<CMP_SPEC> {
                CMP_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///compare register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`cmp::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cmp::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct CMP_SPEC;
        impl crate::RegisterSpec for CMP_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`cmp::R`](R) reader structure
        impl crate::Readable for CMP_SPEC {}
        ///`write(|w| ..)` method takes [`cmp::W`](W) writer structure
        impl crate::Writable for CMP_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets CMP to value 0
        impl crate::Resettable for CMP_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///ARR (rw) register accessor: aoto-reload register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`arr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`arr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@arr`]
    ///module
    pub type ARR = crate::Reg<arr::ARR_SPEC>;
    ///aoto-reload register
    pub mod arr {
        ///Register `ARR` reader
        pub type R = crate::R<ARR_SPEC>;
        ///Register `ARR` writer
        pub type W = crate::W<ARR_SPEC>;
        ///Field `ARR` reader - aoto-reload count value
        pub type ARR_R = crate::FieldReader<u16>;
        ///Field `ARR` writer - aoto-reload count value
        pub type ARR_W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            ///Bits 0:15 - aoto-reload count value
            #[inline(always)]
            pub fn arr(&self) -> ARR_R {
                ARR_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            ///Bits 0:15 - aoto-reload count value
            #[inline(always)]
            #[must_use]
            pub fn arr(&mut self) -> ARR_W<ARR_SPEC> {
                ARR_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///aoto-reload register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`arr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`arr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct ARR_SPEC;
        impl crate::RegisterSpec for ARR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`arr::R`](R) reader structure
        impl crate::Readable for ARR_SPEC {}
        ///`write(|w| ..)` method takes [`arr::W`](W) writer structure
        impl crate::Writable for ARR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets ARR to value 0
        impl crate::Resettable for ARR_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///CNT (rw) register accessor: COUNT register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`cnt::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cnt::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@cnt`]
    ///module
    pub type CNT = crate::Reg<cnt::CNT_SPEC>;
    ///COUNT register
    pub mod cnt {
        ///Register `CNT` reader
        pub type R = crate::R<CNT_SPEC>;
        ///Register `CNT` writer
        pub type W = crate::W<CNT_SPEC>;
        ///Field `COUNT` reader - Timer count value
        pub type COUNT_R = crate::FieldReader<u16>;
        ///Field `COUNT` writer - Timer count value
        pub type COUNT_W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            ///Bits 0:15 - Timer count value
            #[inline(always)]
            pub fn count(&self) -> COUNT_R {
                COUNT_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            ///Bits 0:15 - Timer count value
            #[inline(always)]
            #[must_use]
            pub fn count(&mut self) -> COUNT_W<CNT_SPEC> {
                COUNT_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///COUNT register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`cnt::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cnt::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct CNT_SPEC;
        impl crate::RegisterSpec for CNT_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`cnt::R`](R) reader structure
        impl crate::Readable for CNT_SPEC {}
        ///`write(|w| ..)` method takes [`cnt::W`](W) writer structure
        impl crate::Writable for CNT_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets CNT to value 0
        impl crate::Resettable for CNT_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
}
///USBPD control register
pub struct USBPD {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for USBPD {}
impl USBPD {
    ///Pointer to the register block
    pub const PTR: *const usbpd::RegisterBlock = 0x4002_7000 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const usbpd::RegisterBlock {
        Self::PTR
    }
    /// Steal an instance of this peripheral
    ///
    /// # Safety
    ///
    /// Ensure that the new instance of the peripheral cannot be used in a way
    /// that may race with any existing instances, for example by only
    /// accessing read-only or write-only registers, or by consuming the
    /// original peripheral and using critical sections to coordinate
    /// access between multiple new instances.
    ///
    /// Additionally, other software such as HALs may rely on only one
    /// peripheral instance existing to ensure memory safety; ensure
    /// no stolen instances are passed to such software.
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for USBPD {
    type Target = usbpd::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for USBPD {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("USBPD").finish()
    }
}
///USBPD control register
pub mod usbpd {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        config: CONFIG,
        bmc_clk_cnt: BMC_CLK_CNT,
        control: CONTROL,
        tx_sel: TX_SEL,
        bmc_tx_sz: BMC_TX_SZ,
        data_buf: DATA_BUF,
        status: STATUS,
        bmc_byte_cnt: BMC_BYTE_CNT,
        port_cc1: PORT_CC1,
        port_cc2: PORT_CC2,
        dma: DMA,
    }
    impl RegisterBlock {
        ///0x00 - PD configuration register
        #[inline(always)]
        pub const fn config(&self) -> &CONFIG {
            &self.config
        }
        ///0x02 - BMC sample clock counter
        #[inline(always)]
        pub const fn bmc_clk_cnt(&self) -> &BMC_CLK_CNT {
            &self.bmc_clk_cnt
        }
        ///0x04 - sent/receive enable register
        #[inline(always)]
        pub const fn control(&self) -> &CONTROL {
            &self.control
        }
        ///0x05 - PD send sop selection register
        #[inline(always)]
        pub const fn tx_sel(&self) -> &TX_SEL {
            &self.tx_sel
        }
        ///0x06 - Total length sent
        #[inline(always)]
        pub const fn bmc_tx_sz(&self) -> &BMC_TX_SZ {
            &self.bmc_tx_sz
        }
        ///0x08 - DMA buffer data register
        #[inline(always)]
        pub const fn data_buf(&self) -> &DATA_BUF {
            &self.data_buf
        }
        ///0x09 - PD interrupt flag register
        #[inline(always)]
        pub const fn status(&self) -> &STATUS {
            &self.status
        }
        ///0x0a - byte count register
        #[inline(always)]
        pub const fn bmc_byte_cnt(&self) -> &BMC_BYTE_CNT {
            &self.bmc_byte_cnt
        }
        ///0x0c - port control register
        #[inline(always)]
        pub const fn port_cc1(&self) -> &PORT_CC1 {
            &self.port_cc1
        }
        ///0x0e - port control register
        #[inline(always)]
        pub const fn port_cc2(&self) -> &PORT_CC2 {
            &self.port_cc2
        }
        ///0x10 - DMA cache start address register
        #[inline(always)]
        pub const fn dma(&self) -> &DMA {
            &self.dma
        }
    }
    ///CONFIG (rw) register accessor: PD configuration register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`config::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`config::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@config`]
    ///module
    pub type CONFIG = crate::Reg<config::CONFIG_SPEC>;
    ///PD configuration register
    pub mod config {
        ///Register `CONFIG` reader
        pub type R = crate::R<CONFIG_SPEC>;
        ///Register `CONFIG` writer
        pub type W = crate::W<CONFIG_SPEC>;
        ///Field `PD_FILT_ED` reader - PD pin input filter enable
        pub type PD_FILT_ED_R = crate::BitReader;
        ///Field `PD_FILT_ED` writer - PD pin input filter enable
        pub type PD_FILT_ED_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PD_ALL_CLR` reader - clear all interrupt enable
        pub type PD_ALL_CLR_R = crate::BitReader;
        ///Field `PD_ALL_CLR` writer - clear all interrupt enable
        pub type PD_ALL_CLR_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CC_SEL` reader - communication port selection
        pub type CC_SEL_R = crate::BitReader;
        ///Field `CC_SEL` writer - communication port selection
        pub type CC_SEL_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PD_DMA_EN` reader - PD_DMA enable
        pub type PD_DMA_EN_R = crate::BitReader;
        ///Field `PD_DMA_EN` writer - PD_DMA enable
        pub type PD_DMA_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PD_RST_EN` reader - reset enable
        pub type PD_RST_EN_R = crate::BitReader;
        ///Field `PD_RST_EN` writer - reset enable
        pub type PD_RST_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `WAKE_POLAR` reader - wake-up level
        pub type WAKE_POLAR_R = crate::BitReader;
        ///Field `WAKE_POLAR` writer - wake-up level
        pub type WAKE_POLAR_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `IE_PD_IO` reader - PD port interrupt enable
        pub type IE_PD_IO_R = crate::BitReader;
        ///Field `IE_PD_IO` writer - PD port interrupt enable
        pub type IE_PD_IO_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `IE_RX_BIT` reader - receive bit interrupt enable
        pub type IE_RX_BIT_R = crate::BitReader;
        ///Field `IE_RX_BIT` writer - receive bit interrupt enable
        pub type IE_RX_BIT_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `IE_RX_BYTE` reader - receive byte interrupt enable
        pub type IE_RX_BYTE_R = crate::BitReader;
        ///Field `IE_RX_BYTE` writer - receive byte interrupt enable
        pub type IE_RX_BYTE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `IE_RX_ACT` reader - receive finished interrupt enable
        pub type IE_RX_ACT_R = crate::BitReader;
        ///Field `IE_RX_ACT` writer - receive finished interrupt enable
        pub type IE_RX_ACT_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `IE_RX_RESET` reader - receive reset interrupt enable
        pub type IE_RX_RESET_R = crate::BitReader;
        ///Field `IE_RX_RESET` writer - receive reset interrupt enable
        pub type IE_RX_RESET_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `IE_TX_END` reader - end of send interrupt enable
        pub type IE_TX_END_R = crate::BitReader;
        ///Field `IE_TX_END` writer - end of send interrupt enable
        pub type IE_TX_END_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - PD pin input filter enable
            #[inline(always)]
            pub fn pd_filt_ed(&self) -> PD_FILT_ED_R {
                PD_FILT_ED_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - clear all interrupt enable
            #[inline(always)]
            pub fn pd_all_clr(&self) -> PD_ALL_CLR_R {
                PD_ALL_CLR_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - communication port selection
            #[inline(always)]
            pub fn cc_sel(&self) -> CC_SEL_R {
                CC_SEL_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - PD_DMA enable
            #[inline(always)]
            pub fn pd_dma_en(&self) -> PD_DMA_EN_R {
                PD_DMA_EN_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - reset enable
            #[inline(always)]
            pub fn pd_rst_en(&self) -> PD_RST_EN_R {
                PD_RST_EN_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - wake-up level
            #[inline(always)]
            pub fn wake_polar(&self) -> WAKE_POLAR_R {
                WAKE_POLAR_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 10 - PD port interrupt enable
            #[inline(always)]
            pub fn ie_pd_io(&self) -> IE_PD_IO_R {
                IE_PD_IO_R::new(((self.bits >> 10) & 1) != 0)
            }
            ///Bit 11 - receive bit interrupt enable
            #[inline(always)]
            pub fn ie_rx_bit(&self) -> IE_RX_BIT_R {
                IE_RX_BIT_R::new(((self.bits >> 11) & 1) != 0)
            }
            ///Bit 12 - receive byte interrupt enable
            #[inline(always)]
            pub fn ie_rx_byte(&self) -> IE_RX_BYTE_R {
                IE_RX_BYTE_R::new(((self.bits >> 12) & 1) != 0)
            }
            ///Bit 13 - receive finished interrupt enable
            #[inline(always)]
            pub fn ie_rx_act(&self) -> IE_RX_ACT_R {
                IE_RX_ACT_R::new(((self.bits >> 13) & 1) != 0)
            }
            ///Bit 14 - receive reset interrupt enable
            #[inline(always)]
            pub fn ie_rx_reset(&self) -> IE_RX_RESET_R {
                IE_RX_RESET_R::new(((self.bits >> 14) & 1) != 0)
            }
            ///Bit 15 - end of send interrupt enable
            #[inline(always)]
            pub fn ie_tx_end(&self) -> IE_TX_END_R {
                IE_TX_END_R::new(((self.bits >> 15) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - PD pin input filter enable
            #[inline(always)]
            #[must_use]
            pub fn pd_filt_ed(&mut self) -> PD_FILT_ED_W<CONFIG_SPEC> {
                PD_FILT_ED_W::new(self, 0)
            }
            ///Bit 1 - clear all interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn pd_all_clr(&mut self) -> PD_ALL_CLR_W<CONFIG_SPEC> {
                PD_ALL_CLR_W::new(self, 1)
            }
            ///Bit 2 - communication port selection
            #[inline(always)]
            #[must_use]
            pub fn cc_sel(&mut self) -> CC_SEL_W<CONFIG_SPEC> {
                CC_SEL_W::new(self, 2)
            }
            ///Bit 3 - PD_DMA enable
            #[inline(always)]
            #[must_use]
            pub fn pd_dma_en(&mut self) -> PD_DMA_EN_W<CONFIG_SPEC> {
                PD_DMA_EN_W::new(self, 3)
            }
            ///Bit 4 - reset enable
            #[inline(always)]
            #[must_use]
            pub fn pd_rst_en(&mut self) -> PD_RST_EN_W<CONFIG_SPEC> {
                PD_RST_EN_W::new(self, 4)
            }
            ///Bit 5 - wake-up level
            #[inline(always)]
            #[must_use]
            pub fn wake_polar(&mut self) -> WAKE_POLAR_W<CONFIG_SPEC> {
                WAKE_POLAR_W::new(self, 5)
            }
            ///Bit 10 - PD port interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn ie_pd_io(&mut self) -> IE_PD_IO_W<CONFIG_SPEC> {
                IE_PD_IO_W::new(self, 10)
            }
            ///Bit 11 - receive bit interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn ie_rx_bit(&mut self) -> IE_RX_BIT_W<CONFIG_SPEC> {
                IE_RX_BIT_W::new(self, 11)
            }
            ///Bit 12 - receive byte interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn ie_rx_byte(&mut self) -> IE_RX_BYTE_W<CONFIG_SPEC> {
                IE_RX_BYTE_W::new(self, 12)
            }
            ///Bit 13 - receive finished interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn ie_rx_act(&mut self) -> IE_RX_ACT_W<CONFIG_SPEC> {
                IE_RX_ACT_W::new(self, 13)
            }
            ///Bit 14 - receive reset interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn ie_rx_reset(&mut self) -> IE_RX_RESET_W<CONFIG_SPEC> {
                IE_RX_RESET_W::new(self, 14)
            }
            ///Bit 15 - end of send interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn ie_tx_end(&mut self) -> IE_TX_END_W<CONFIG_SPEC> {
                IE_TX_END_W::new(self, 15)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///PD configuration register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`config::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`config::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct CONFIG_SPEC;
        impl crate::RegisterSpec for CONFIG_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`config::R`](R) reader structure
        impl crate::Readable for CONFIG_SPEC {}
        ///`write(|w| ..)` method takes [`config::W`](W) writer structure
        impl crate::Writable for CONFIG_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets CONFIG to value 0x02
        impl crate::Resettable for CONFIG_SPEC {
            const RESET_VALUE: u16 = 0x02;
        }
    }
    ///BMC_CLK_CNT (rw) register accessor: BMC sample clock counter
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`bmc_clk_cnt::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`bmc_clk_cnt::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@bmc_clk_cnt`]
    ///module
    pub type BMC_CLK_CNT = crate::Reg<bmc_clk_cnt::BMC_CLK_CNT_SPEC>;
    ///BMC sample clock counter
    pub mod bmc_clk_cnt {
        ///Register `BMC_CLK_CNT` reader
        pub type R = crate::R<BMC_CLK_CNT_SPEC>;
        ///Register `BMC_CLK_CNT` writer
        pub type W = crate::W<BMC_CLK_CNT_SPEC>;
        ///Field `BMC_CLK_CNT` reader - BMC sent/receive sample clock counter
        pub type BMC_CLK_CNT_R = crate::FieldReader<u16>;
        ///Field `BMC_CLK_CNT` writer - BMC sent/receive sample clock counter
        pub type BMC_CLK_CNT_W<'a, REG> = crate::FieldWriter<'a, REG, 9, u16>;
        impl R {
            ///Bits 0:8 - BMC sent/receive sample clock counter
            #[inline(always)]
            pub fn bmc_clk_cnt(&self) -> BMC_CLK_CNT_R {
                BMC_CLK_CNT_R::new(self.bits & 0x01ff)
            }
        }
        impl W {
            ///Bits 0:8 - BMC sent/receive sample clock counter
            #[inline(always)]
            #[must_use]
            pub fn bmc_clk_cnt(&mut self) -> BMC_CLK_CNT_W<BMC_CLK_CNT_SPEC> {
                BMC_CLK_CNT_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///BMC sample clock counter
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`bmc_clk_cnt::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`bmc_clk_cnt::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct BMC_CLK_CNT_SPEC;
        impl crate::RegisterSpec for BMC_CLK_CNT_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`bmc_clk_cnt::R`](R) reader structure
        impl crate::Readable for BMC_CLK_CNT_SPEC {}
        ///`write(|w| ..)` method takes [`bmc_clk_cnt::W`](W) writer structure
        impl crate::Writable for BMC_CLK_CNT_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets BMC_CLK_CNT to value 0
        impl crate::Resettable for BMC_CLK_CNT_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///CONTROL (rw) register accessor: sent/receive enable register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`control::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`control::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@control`]
    ///module
    pub type CONTROL = crate::Reg<control::CONTROL_SPEC>;
    ///sent/receive enable register
    pub mod control {
        ///Register `CONTROL` reader
        pub type R = crate::R<CONTROL_SPEC>;
        ///Register `CONTROL` writer
        pub type W = crate::W<CONTROL_SPEC>;
        ///Field `PD_TX_EN` reader - sent/receive enable
        pub type PD_TX_EN_R = crate::BitReader;
        ///Field `PD_TX_EN` writer - sent/receive enable
        pub type PD_TX_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `BMC_START` reader - BMC send a start signal
        pub type BMC_START_R = crate::BitReader;
        ///Field `BMC_START` writer - BMC send a start signal
        pub type BMC_START_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `DATA_FLAG` reader - data cache valid flag
        pub type DATA_FLAG_R = crate::BitReader;
        ///Field `DATA_FLAG` writer - data cache valid flag
        pub type DATA_FLAG_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TX_BIT_BACK` reader - sent code status of bit
        pub type TX_BIT_BACK_R = crate::BitReader;
        ///Field `TX_BIT_BACK` writer - sent code status of bit
        pub type TX_BIT_BACK_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `BMC_BYTE_HI` reader - sent/receive half bytes status of data
        pub type BMC_BYTE_HI_R = crate::BitReader;
        ///Field `BMC_BYTE_HI` writer - sent/receive half bytes status of data
        pub type BMC_BYTE_HI_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - sent/receive enable
            #[inline(always)]
            pub fn pd_tx_en(&self) -> PD_TX_EN_R {
                PD_TX_EN_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - BMC send a start signal
            #[inline(always)]
            pub fn bmc_start(&self) -> BMC_START_R {
                BMC_START_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 5 - data cache valid flag
            #[inline(always)]
            pub fn data_flag(&self) -> DATA_FLAG_R {
                DATA_FLAG_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - sent code status of bit
            #[inline(always)]
            pub fn tx_bit_back(&self) -> TX_BIT_BACK_R {
                TX_BIT_BACK_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - sent/receive half bytes status of data
            #[inline(always)]
            pub fn bmc_byte_hi(&self) -> BMC_BYTE_HI_R {
                BMC_BYTE_HI_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - sent/receive enable
            #[inline(always)]
            #[must_use]
            pub fn pd_tx_en(&mut self) -> PD_TX_EN_W<CONTROL_SPEC> {
                PD_TX_EN_W::new(self, 0)
            }
            ///Bit 1 - BMC send a start signal
            #[inline(always)]
            #[must_use]
            pub fn bmc_start(&mut self) -> BMC_START_W<CONTROL_SPEC> {
                BMC_START_W::new(self, 1)
            }
            ///Bit 5 - data cache valid flag
            #[inline(always)]
            #[must_use]
            pub fn data_flag(&mut self) -> DATA_FLAG_W<CONTROL_SPEC> {
                DATA_FLAG_W::new(self, 5)
            }
            ///Bit 6 - sent code status of bit
            #[inline(always)]
            #[must_use]
            pub fn tx_bit_back(&mut self) -> TX_BIT_BACK_W<CONTROL_SPEC> {
                TX_BIT_BACK_W::new(self, 6)
            }
            ///Bit 7 - sent/receive half bytes status of data
            #[inline(always)]
            #[must_use]
            pub fn bmc_byte_hi(&mut self) -> BMC_BYTE_HI_W<CONTROL_SPEC> {
                BMC_BYTE_HI_W::new(self, 7)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///sent/receive enable register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`control::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`control::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct CONTROL_SPEC;
        impl crate::RegisterSpec for CONTROL_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`control::R`](R) reader structure
        impl crate::Readable for CONTROL_SPEC {}
        ///`write(|w| ..)` method takes [`control::W`](W) writer structure
        impl crate::Writable for CONTROL_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets CONTROL to value 0
        impl crate::Resettable for CONTROL_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///TX_SEL (rw) register accessor: PD send sop selection register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`tx_sel::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`tx_sel::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@tx_sel`]
    ///module
    pub type TX_SEL = crate::Reg<tx_sel::TX_SEL_SPEC>;
    ///PD send sop selection register
    pub mod tx_sel {
        ///Register `TX_SEL` reader
        pub type R = crate::R<TX_SEL_SPEC>;
        ///Register `TX_SEL` writer
        pub type W = crate::W<TX_SEL_SPEC>;
        ///Field `TX_SEL1` reader - PD send type selection
        pub type TX_SEL1_R = crate::BitReader;
        ///Field `TX_SEL1` writer - PD send type selection
        pub type TX_SEL1_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TX_SEL2` reader - PD send type selection
        pub type TX_SEL2_R = crate::FieldReader;
        ///Field `TX_SEL2` writer - PD send type selection
        pub type TX_SEL2_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `TX_SEL3` reader - PD send type selection
        pub type TX_SEL3_R = crate::FieldReader;
        ///Field `TX_SEL3` writer - PD send type selection
        pub type TX_SEL3_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `TX_SEL4` reader - PD send type selection
        pub type TX_SEL4_R = crate::FieldReader;
        ///Field `TX_SEL4` writer - PD send type selection
        pub type TX_SEL4_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        impl R {
            ///Bit 0 - PD send type selection
            #[inline(always)]
            pub fn tx_sel1(&self) -> TX_SEL1_R {
                TX_SEL1_R::new((self.bits & 1) != 0)
            }
            ///Bits 2:3 - PD send type selection
            #[inline(always)]
            pub fn tx_sel2(&self) -> TX_SEL2_R {
                TX_SEL2_R::new((self.bits >> 2) & 3)
            }
            ///Bits 4:5 - PD send type selection
            #[inline(always)]
            pub fn tx_sel3(&self) -> TX_SEL3_R {
                TX_SEL3_R::new((self.bits >> 4) & 3)
            }
            ///Bits 6:7 - PD send type selection
            #[inline(always)]
            pub fn tx_sel4(&self) -> TX_SEL4_R {
                TX_SEL4_R::new((self.bits >> 6) & 3)
            }
        }
        impl W {
            ///Bit 0 - PD send type selection
            #[inline(always)]
            #[must_use]
            pub fn tx_sel1(&mut self) -> TX_SEL1_W<TX_SEL_SPEC> {
                TX_SEL1_W::new(self, 0)
            }
            ///Bits 2:3 - PD send type selection
            #[inline(always)]
            #[must_use]
            pub fn tx_sel2(&mut self) -> TX_SEL2_W<TX_SEL_SPEC> {
                TX_SEL2_W::new(self, 2)
            }
            ///Bits 4:5 - PD send type selection
            #[inline(always)]
            #[must_use]
            pub fn tx_sel3(&mut self) -> TX_SEL3_W<TX_SEL_SPEC> {
                TX_SEL3_W::new(self, 4)
            }
            ///Bits 6:7 - PD send type selection
            #[inline(always)]
            #[must_use]
            pub fn tx_sel4(&mut self) -> TX_SEL4_W<TX_SEL_SPEC> {
                TX_SEL4_W::new(self, 6)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///PD send sop selection register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`tx_sel::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`tx_sel::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct TX_SEL_SPEC;
        impl crate::RegisterSpec for TX_SEL_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`tx_sel::R`](R) reader structure
        impl crate::Readable for TX_SEL_SPEC {}
        ///`write(|w| ..)` method takes [`tx_sel::W`](W) writer structure
        impl crate::Writable for TX_SEL_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets TX_SEL to value 0
        impl crate::Resettable for TX_SEL_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///BMC_TX_SZ (rw) register accessor: Total length sent
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`bmc_tx_sz::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`bmc_tx_sz::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@bmc_tx_sz`]
    ///module
    pub type BMC_TX_SZ = crate::Reg<bmc_tx_sz::BMC_TX_SZ_SPEC>;
    ///Total length sent
    pub mod bmc_tx_sz {
        ///Register `BMC_TX_SZ` reader
        pub type R = crate::R<BMC_TX_SZ_SPEC>;
        ///Register `BMC_TX_SZ` writer
        pub type W = crate::W<BMC_TX_SZ_SPEC>;
        ///Field `BMC_TX_SZ` reader - Total length sent
        pub type BMC_TX_SZ_R = crate::FieldReader<u16>;
        ///Field `BMC_TX_SZ` writer - Total length sent
        pub type BMC_TX_SZ_W<'a, REG> = crate::FieldWriter<'a, REG, 9, u16>;
        impl R {
            ///Bits 0:8 - Total length sent
            #[inline(always)]
            pub fn bmc_tx_sz(&self) -> BMC_TX_SZ_R {
                BMC_TX_SZ_R::new(self.bits & 0x01ff)
            }
        }
        impl W {
            ///Bits 0:8 - Total length sent
            #[inline(always)]
            #[must_use]
            pub fn bmc_tx_sz(&mut self) -> BMC_TX_SZ_W<BMC_TX_SZ_SPEC> {
                BMC_TX_SZ_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Total length sent
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`bmc_tx_sz::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`bmc_tx_sz::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct BMC_TX_SZ_SPEC;
        impl crate::RegisterSpec for BMC_TX_SZ_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`bmc_tx_sz::R`](R) reader structure
        impl crate::Readable for BMC_TX_SZ_SPEC {}
        ///`write(|w| ..)` method takes [`bmc_tx_sz::W`](W) writer structure
        impl crate::Writable for BMC_TX_SZ_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets BMC_TX_SZ to value 0
        impl crate::Resettable for BMC_TX_SZ_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///DATA_BUF (rw) register accessor: DMA buffer data register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`data_buf::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`data_buf::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@data_buf`]
    ///module
    pub type DATA_BUF = crate::Reg<data_buf::DATA_BUF_SPEC>;
    ///DMA buffer data register
    pub mod data_buf {
        ///Register `DATA_BUF` reader
        pub type R = crate::R<DATA_BUF_SPEC>;
        ///Register `DATA_BUF` writer
        pub type W = crate::W<DATA_BUF_SPEC>;
        ///Field `DATA_BUF` reader - DMA DATA_BUFFER
        pub type DATA_BUF_R = crate::FieldReader;
        ///Field `DATA_BUF` writer - DMA DATA_BUFFER
        pub type DATA_BUF_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            ///Bits 0:7 - DMA DATA_BUFFER
            #[inline(always)]
            pub fn data_buf(&self) -> DATA_BUF_R {
                DATA_BUF_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:7 - DMA DATA_BUFFER
            #[inline(always)]
            #[must_use]
            pub fn data_buf(&mut self) -> DATA_BUF_W<DATA_BUF_SPEC> {
                DATA_BUF_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///DMA buffer data register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`data_buf::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`data_buf::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct DATA_BUF_SPEC;
        impl crate::RegisterSpec for DATA_BUF_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`data_buf::R`](R) reader structure
        impl crate::Readable for DATA_BUF_SPEC {}
        ///`write(|w| ..)` method takes [`data_buf::W`](W) writer structure
        impl crate::Writable for DATA_BUF_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets DATA_BUF to value 0
        impl crate::Resettable for DATA_BUF_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///STATUS (rw) register accessor: PD interrupt flag register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`status::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`status::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@status`]
    ///module
    pub type STATUS = crate::Reg<status::STATUS_SPEC>;
    ///PD interrupt flag register
    pub mod status {
        ///Register `STATUS` reader
        pub type R = crate::R<STATUS_SPEC>;
        ///Register `STATUS` writer
        pub type W = crate::W<STATUS_SPEC>;
        ///Field `BMC_AUX` reader - Indicating the current state
        pub type BMC_AUX_R = crate::FieldReader;
        ///Field `BMC_AUX` writer - Indicating the current state
        pub type BMC_AUX_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `BUF_ERR` reader - BUFFER/DMA error interrupt flag
        pub type BUF_ERR_R = crate::BitReader;
        ///Field `BUF_ERR` writer - BUFFER/DMA error interrupt flag
        pub type BUF_ERR_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `IF_RX_BIT` reader - Receive BIT/5BIT interrupt flag
        pub type IF_RX_BIT_R = crate::BitReader;
        ///Field `IF_RX_BIT` writer - Receive BIT/5BIT interrupt flag
        pub type IF_RX_BIT_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `IF_RX_BYTE` reader - Receive byte/SOP interrupt flag
        pub type IF_RX_BYTE_R = crate::BitReader;
        ///Field `IF_RX_BYTE` writer - Receive byte/SOP interrupt flag
        pub type IF_RX_BYTE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `IF_RX_ACT` reader - Receive completed interrupt flag
        pub type IF_RX_ACT_R = crate::BitReader;
        ///Field `IF_RX_ACT` writer - Receive completed interrupt flag
        pub type IF_RX_ACT_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `IF_RX_RESET` reader - Receive reset interrupt flag
        pub type IF_RX_RESET_R = crate::BitReader;
        ///Field `IF_RX_RESET` writer - Receive reset interrupt flag
        pub type IF_RX_RESET_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `IF_TX_END` reader - Transmission completed interrupt flag
        pub type IF_TX_END_R = crate::BitReader;
        ///Field `IF_TX_END` writer - Transmission completed interrupt flag
        pub type IF_TX_END_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bits 0:1 - Indicating the current state
            #[inline(always)]
            pub fn bmc_aux(&self) -> BMC_AUX_R {
                BMC_AUX_R::new(self.bits & 3)
            }
            ///Bit 2 - BUFFER/DMA error interrupt flag
            #[inline(always)]
            pub fn buf_err(&self) -> BUF_ERR_R {
                BUF_ERR_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - Receive BIT/5BIT interrupt flag
            #[inline(always)]
            pub fn if_rx_bit(&self) -> IF_RX_BIT_R {
                IF_RX_BIT_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - Receive byte/SOP interrupt flag
            #[inline(always)]
            pub fn if_rx_byte(&self) -> IF_RX_BYTE_R {
                IF_RX_BYTE_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - Receive completed interrupt flag
            #[inline(always)]
            pub fn if_rx_act(&self) -> IF_RX_ACT_R {
                IF_RX_ACT_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - Receive reset interrupt flag
            #[inline(always)]
            pub fn if_rx_reset(&self) -> IF_RX_RESET_R {
                IF_RX_RESET_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - Transmission completed interrupt flag
            #[inline(always)]
            pub fn if_tx_end(&self) -> IF_TX_END_R {
                IF_TX_END_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:1 - Indicating the current state
            #[inline(always)]
            #[must_use]
            pub fn bmc_aux(&mut self) -> BMC_AUX_W<STATUS_SPEC> {
                BMC_AUX_W::new(self, 0)
            }
            ///Bit 2 - BUFFER/DMA error interrupt flag
            #[inline(always)]
            #[must_use]
            pub fn buf_err(&mut self) -> BUF_ERR_W<STATUS_SPEC> {
                BUF_ERR_W::new(self, 2)
            }
            ///Bit 3 - Receive BIT/5BIT interrupt flag
            #[inline(always)]
            #[must_use]
            pub fn if_rx_bit(&mut self) -> IF_RX_BIT_W<STATUS_SPEC> {
                IF_RX_BIT_W::new(self, 3)
            }
            ///Bit 4 - Receive byte/SOP interrupt flag
            #[inline(always)]
            #[must_use]
            pub fn if_rx_byte(&mut self) -> IF_RX_BYTE_W<STATUS_SPEC> {
                IF_RX_BYTE_W::new(self, 4)
            }
            ///Bit 5 - Receive completed interrupt flag
            #[inline(always)]
            #[must_use]
            pub fn if_rx_act(&mut self) -> IF_RX_ACT_W<STATUS_SPEC> {
                IF_RX_ACT_W::new(self, 5)
            }
            ///Bit 6 - Receive reset interrupt flag
            #[inline(always)]
            #[must_use]
            pub fn if_rx_reset(&mut self) -> IF_RX_RESET_W<STATUS_SPEC> {
                IF_RX_RESET_W::new(self, 6)
            }
            ///Bit 7 - Transmission completed interrupt flag
            #[inline(always)]
            #[must_use]
            pub fn if_tx_end(&mut self) -> IF_TX_END_W<STATUS_SPEC> {
                IF_TX_END_W::new(self, 7)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///PD interrupt flag register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`status::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`status::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct STATUS_SPEC;
        impl crate::RegisterSpec for STATUS_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`status::R`](R) reader structure
        impl crate::Readable for STATUS_SPEC {}
        ///`write(|w| ..)` method takes [`status::W`](W) writer structure
        impl crate::Writable for STATUS_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets STATUS to value 0
        impl crate::Resettable for STATUS_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///BMC_BYTE_CNT (r) register accessor: byte count register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`bmc_byte_cnt::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@bmc_byte_cnt`]
    ///module
    pub type BMC_BYTE_CNT = crate::Reg<bmc_byte_cnt::BMC_BYTE_CNT_SPEC>;
    ///byte count register
    pub mod bmc_byte_cnt {
        ///Register `BMC_BYTE_CNT` reader
        pub type R = crate::R<BMC_BYTE_CNT_SPEC>;
        ///Field `BMC_BYTE_CNT` reader - BMC_BYTE_CNT
        pub type BMC_BYTE_CNT_R = crate::FieldReader<u16>;
        impl R {
            ///Bits 0:8 - BMC_BYTE_CNT
            #[inline(always)]
            pub fn bmc_byte_cnt(&self) -> BMC_BYTE_CNT_R {
                BMC_BYTE_CNT_R::new(self.bits & 0x01ff)
            }
        }
        ///byte count register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`bmc_byte_cnt::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct BMC_BYTE_CNT_SPEC;
        impl crate::RegisterSpec for BMC_BYTE_CNT_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`bmc_byte_cnt::R`](R) reader structure
        impl crate::Readable for BMC_BYTE_CNT_SPEC {}
        ///`reset()` method sets BMC_BYTE_CNT to value 0
        impl crate::Resettable for BMC_BYTE_CNT_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///PORT_CC1 (rw) register accessor: port control register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`port_cc1::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`port_cc1::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@port_cc1`]
    ///module
    pub type PORT_CC1 = crate::Reg<port_cc1::PORT_CC1_SPEC>;
    ///port control register
    pub mod port_cc1 {
        ///Register `PORT_CC1` reader
        pub type R = crate::R<PORT_CC1_SPEC>;
        ///Register `PORT_CC1` writer
        pub type W = crate::W<PORT_CC1_SPEC>;
        ///Field `PA_CC1_AI` reader - port comparator simulates input
        pub type PA_CC1_AI_R = crate::BitReader;
        ///Field `PA_CC1_AI` writer - port comparator simulates input
        pub type PA_CC1_AI_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CC1_PD` reader - port pull-down resistor enable
        pub type CC1_PD_R = crate::BitReader;
        ///Field `CC1_PD` writer - port pull-down resistor enable
        pub type CC1_PD_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CC1_PU` reader - port pull-up current enable
        pub type CC1_PU_R = crate::BitReader;
        ///Field `CC1_PU` writer - port pull-up current enable
        pub type CC1_PU_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CC1_LVE` reader - port output lower voltage enable
        pub type CC1_LVE_R = crate::BitReader;
        ///Field `CC1_LVE` writer - port output lower voltage enable
        pub type CC1_LVE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CC1_CE` reader - Enable port voltage comparator
        pub type CC1_CE_R = crate::FieldReader;
        ///Field `CC1_CE` writer - Enable port voltage comparator
        pub type CC1_CE_W<'a, REG> = crate::FieldWriter<'a, REG, 3>;
        impl R {
            ///Bit 0 - port comparator simulates input
            #[inline(always)]
            pub fn pa_cc1_ai(&self) -> PA_CC1_AI_R {
                PA_CC1_AI_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - port pull-down resistor enable
            #[inline(always)]
            pub fn cc1_pd(&self) -> CC1_PD_R {
                CC1_PD_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - port pull-up current enable
            #[inline(always)]
            pub fn cc1_pu(&self) -> CC1_PU_R {
                CC1_PU_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 4 - port output lower voltage enable
            #[inline(always)]
            pub fn cc1_lve(&self) -> CC1_LVE_R {
                CC1_LVE_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bits 5:7 - Enable port voltage comparator
            #[inline(always)]
            pub fn cc1_ce(&self) -> CC1_CE_R {
                CC1_CE_R::new(((self.bits >> 5) & 7) as u8)
            }
        }
        impl W {
            ///Bit 0 - port comparator simulates input
            #[inline(always)]
            #[must_use]
            pub fn pa_cc1_ai(&mut self) -> PA_CC1_AI_W<PORT_CC1_SPEC> {
                PA_CC1_AI_W::new(self, 0)
            }
            ///Bit 1 - port pull-down resistor enable
            #[inline(always)]
            #[must_use]
            pub fn cc1_pd(&mut self) -> CC1_PD_W<PORT_CC1_SPEC> {
                CC1_PD_W::new(self, 1)
            }
            ///Bit 2 - port pull-up current enable
            #[inline(always)]
            #[must_use]
            pub fn cc1_pu(&mut self) -> CC1_PU_W<PORT_CC1_SPEC> {
                CC1_PU_W::new(self, 2)
            }
            ///Bit 4 - port output lower voltage enable
            #[inline(always)]
            #[must_use]
            pub fn cc1_lve(&mut self) -> CC1_LVE_W<PORT_CC1_SPEC> {
                CC1_LVE_W::new(self, 4)
            }
            ///Bits 5:7 - Enable port voltage comparator
            #[inline(always)]
            #[must_use]
            pub fn cc1_ce(&mut self) -> CC1_CE_W<PORT_CC1_SPEC> {
                CC1_CE_W::new(self, 5)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///port control register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`port_cc1::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`port_cc1::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct PORT_CC1_SPEC;
        impl crate::RegisterSpec for PORT_CC1_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`port_cc1::R`](R) reader structure
        impl crate::Readable for PORT_CC1_SPEC {}
        ///`write(|w| ..)` method takes [`port_cc1::W`](W) writer structure
        impl crate::Writable for PORT_CC1_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets PORT_CC1 to value 0x03
        impl crate::Resettable for PORT_CC1_SPEC {
            const RESET_VALUE: u16 = 0x03;
        }
    }
    ///PORT_CC2 (rw) register accessor: port control register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`port_cc2::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`port_cc2::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@port_cc2`]
    ///module
    pub type PORT_CC2 = crate::Reg<port_cc2::PORT_CC2_SPEC>;
    ///port control register
    pub mod port_cc2 {
        ///Register `PORT_CC2` reader
        pub type R = crate::R<PORT_CC2_SPEC>;
        ///Register `PORT_CC2` writer
        pub type W = crate::W<PORT_CC2_SPEC>;
        ///Field `PA_CC2_AI` reader - port comparator simulates input
        pub type PA_CC2_AI_R = crate::BitReader;
        ///Field `PA_CC2_AI` writer - port comparator simulates input
        pub type PA_CC2_AI_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CC2_PD` reader - port pull-down resistor enable
        pub type CC2_PD_R = crate::BitReader;
        ///Field `CC2_PD` writer - port pull-down resistor enable
        pub type CC2_PD_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CC2_PU` reader - port pull-up current enable
        pub type CC2_PU_R = crate::BitReader;
        ///Field `CC2_PU` writer - port pull-up current enable
        pub type CC2_PU_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CC2_LVE` reader - port output lower voltage enable
        pub type CC2_LVE_R = crate::BitReader;
        ///Field `CC2_LVE` writer - port output lower voltage enable
        pub type CC2_LVE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CC2_CE` reader - Enable port voltage comparator
        pub type CC2_CE_R = crate::FieldReader;
        ///Field `CC2_CE` writer - Enable port voltage comparator
        pub type CC2_CE_W<'a, REG> = crate::FieldWriter<'a, REG, 3>;
        impl R {
            ///Bit 0 - port comparator simulates input
            #[inline(always)]
            pub fn pa_cc2_ai(&self) -> PA_CC2_AI_R {
                PA_CC2_AI_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - port pull-down resistor enable
            #[inline(always)]
            pub fn cc2_pd(&self) -> CC2_PD_R {
                CC2_PD_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - port pull-up current enable
            #[inline(always)]
            pub fn cc2_pu(&self) -> CC2_PU_R {
                CC2_PU_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 4 - port output lower voltage enable
            #[inline(always)]
            pub fn cc2_lve(&self) -> CC2_LVE_R {
                CC2_LVE_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bits 5:7 - Enable port voltage comparator
            #[inline(always)]
            pub fn cc2_ce(&self) -> CC2_CE_R {
                CC2_CE_R::new(((self.bits >> 5) & 7) as u8)
            }
        }
        impl W {
            ///Bit 0 - port comparator simulates input
            #[inline(always)]
            #[must_use]
            pub fn pa_cc2_ai(&mut self) -> PA_CC2_AI_W<PORT_CC2_SPEC> {
                PA_CC2_AI_W::new(self, 0)
            }
            ///Bit 1 - port pull-down resistor enable
            #[inline(always)]
            #[must_use]
            pub fn cc2_pd(&mut self) -> CC2_PD_W<PORT_CC2_SPEC> {
                CC2_PD_W::new(self, 1)
            }
            ///Bit 2 - port pull-up current enable
            #[inline(always)]
            #[must_use]
            pub fn cc2_pu(&mut self) -> CC2_PU_W<PORT_CC2_SPEC> {
                CC2_PU_W::new(self, 2)
            }
            ///Bit 4 - port output lower voltage enable
            #[inline(always)]
            #[must_use]
            pub fn cc2_lve(&mut self) -> CC2_LVE_W<PORT_CC2_SPEC> {
                CC2_LVE_W::new(self, 4)
            }
            ///Bits 5:7 - Enable port voltage comparator
            #[inline(always)]
            #[must_use]
            pub fn cc2_ce(&mut self) -> CC2_CE_W<PORT_CC2_SPEC> {
                CC2_CE_W::new(self, 5)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///port control register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`port_cc2::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`port_cc2::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct PORT_CC2_SPEC;
        impl crate::RegisterSpec for PORT_CC2_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`port_cc2::R`](R) reader structure
        impl crate::Readable for PORT_CC2_SPEC {}
        ///`write(|w| ..)` method takes [`port_cc2::W`](W) writer structure
        impl crate::Writable for PORT_CC2_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets PORT_CC2 to value 0x03
        impl crate::Resettable for PORT_CC2_SPEC {
            const RESET_VALUE: u16 = 0x03;
        }
    }
    ///DMA (rw) register accessor: DMA cache start address register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`dma::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dma::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@dma`]
    ///module
    pub type DMA = crate::Reg<dma::DMA_SPEC>;
    ///DMA cache start address register
    pub mod dma {
        ///Register `DMA` reader
        pub type R = crate::R<DMA_SPEC>;
        ///Register `DMA` writer
        pub type W = crate::W<DMA_SPEC>;
        ///Field `USBPD_DMA_ADDR` reader - USBPD_DMA cache address
        pub type USBPD_DMA_ADDR_R = crate::FieldReader<u16>;
        ///Field `USBPD_DMA_ADDR` writer - USBPD_DMA cache address
        pub type USBPD_DMA_ADDR_W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            ///Bits 0:15 - USBPD_DMA cache address
            #[inline(always)]
            pub fn usbpd_dma_addr(&self) -> USBPD_DMA_ADDR_R {
                USBPD_DMA_ADDR_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - USBPD_DMA cache address
            #[inline(always)]
            #[must_use]
            pub fn usbpd_dma_addr(&mut self) -> USBPD_DMA_ADDR_W<DMA_SPEC> {
                USBPD_DMA_ADDR_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///DMA cache start address register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`dma::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dma::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct DMA_SPEC;
        impl crate::RegisterSpec for DMA_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`dma::R`](R) reader structure
        impl crate::Readable for DMA_SPEC {}
        ///`write(|w| ..)` method takes [`dma::W`](W) writer structure
        impl crate::Writable for DMA_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets DMA to value 0
        impl crate::Resettable for DMA_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
}
///USB full speed host/equipment control register
pub struct USBFS {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for USBFS {}
impl USBFS {
    ///Pointer to the register block
    pub const PTR: *const usbfs::RegisterBlock = 0x5000_0000 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const usbfs::RegisterBlock {
        Self::PTR
    }
    /// Steal an instance of this peripheral
    ///
    /// # Safety
    ///
    /// Ensure that the new instance of the peripheral cannot be used in a way
    /// that may race with any existing instances, for example by only
    /// accessing read-only or write-only registers, or by consuming the
    /// original peripheral and using critical sections to coordinate
    /// access between multiple new instances.
    ///
    /// Additionally, other software such as HALs may rely on only one
    /// peripheral instance existing to ensure memory safety; ensure
    /// no stolen instances are passed to such software.
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for USBFS {
    type Target = usbfs::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for USBFS {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("USBFS").finish()
    }
}
///USB full speed host/equipment control register
pub mod usbfs {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        usb_ctrl: USB_CTRL,
        udev_ctrl__r8_uhost_ctrl: UDEV_CTRL__R8_UHOST_CTRL,
        usb_int_en: USB_INT_EN,
        usb_dev_ad: USB_DEV_AD,
        _reserved4: [u8; 0x01],
        usb_mis_st: USB_MIS_ST,
        usb_int_fg: USB_INT_FG,
        usb_int_st: USB_INT_ST,
        usb_rx_len: USB_RX_LEN,
        _reserved8: [u8; 0x02],
        uep4_1_mod: UEP4_1_MOD,
        uep2_3_mod__r8_uh_ep_mod: UEP2_3_MOD__R8_UH_EP_MOD,
        uep5_6_mod: UEP5_6_MOD,
        uep7_mod: UEP7_MOD,
        uep0_dma: UEP0_DMA,
        uep1_dma: UEP1_DMA,
        uep2_dma__r16_uh_rx_dma: UEP2_DMA__R16_UH_RX_DMA,
        uep3_dma__r16_uh_tx_dma: UEP3_DMA__R16_UH_TX_DMA,
        uep4_dma: UEP4_DMA,
        uep5_dma: UEP5_DMA,
        uep6_dma: UEP6_DMA,
        uep7_dma: UEP7_DMA,
        uep0_t_len: UEP0_T_LEN,
        uep0_ctrl: UEP0_CTRL,
        uep1_t_len: UEP1_T_LEN,
        uep1_ctrl__r16_uh_setup: UEP1_CTRL__R16_UH_SETUP,
        uep2_t_len: UEP2_T_LEN,
        _reserved_25_uep2_ctrl: [u8; 0x02],
        uep3_t_len__r16_uh_tx_len: UEP3_T_LEN__R16_UH_TX_LEN,
        uep3_ctrl__r8_uh_tx_ctrl: UEP3_CTRL__R8_UH_TX_CTRL,
        uep4_t_len: UEP4_T_LEN,
        uep4_ctrl: UEP4_CTRL,
        uep5_t_len: UEP5_T_LEN,
        uep5_ctrl: UEP5_CTRL,
        uep6_t_len: UEP6_T_LEN,
        uep6_ctrl: UEP6_CTRL,
        uep7_t_len: UEP7_T_LEN,
        uep7_ctrl: UEP7_CTRL,
    }
    impl RegisterBlock {
        ///0x00 - USB base control
        #[inline(always)]
        pub const fn usb_ctrl(&self) -> &USB_CTRL {
            &self.usb_ctrl
        }
        ///0x01 - USB host physical port control register;USB host physical port control register
        #[inline(always)]
        pub const fn udev_ctrl__r8_uhost_ctrl(&self) -> &UDEV_CTRL__R8_UHOST_CTRL {
            &self.udev_ctrl__r8_uhost_ctrl
        }
        ///0x02 - USB interrupt enable
        #[inline(always)]
        pub const fn usb_int_en(&self) -> &USB_INT_EN {
            &self.usb_int_en
        }
        ///0x03 - USB device address
        #[inline(always)]
        pub const fn usb_dev_ad(&self) -> &USB_DEV_AD {
            &self.usb_dev_ad
        }
        ///0x05 - USB miscellaneous status register
        #[inline(always)]
        pub const fn usb_mis_st(&self) -> &USB_MIS_ST {
            &self.usb_mis_st
        }
        ///0x06 - USB miscellaneous status register
        #[inline(always)]
        pub const fn usb_int_fg(&self) -> &USB_INT_FG {
            &self.usb_int_fg
        }
        ///0x07 - USB interrupt status register
        #[inline(always)]
        pub const fn usb_int_st(&self) -> &USB_INT_ST {
            &self.usb_int_st
        }
        ///0x08 - USB miscellaneous status register
        #[inline(always)]
        pub const fn usb_rx_len(&self) -> &USB_RX_LEN {
            &self.usb_rx_len
        }
        ///0x0c - endpoint 4/1 mode
        #[inline(always)]
        pub const fn uep4_1_mod(&self) -> &UEP4_1_MOD {
            &self.uep4_1_mod
        }
        ///0x0d - endpoint 2/3 mode;USB host endpoint mode control register
        #[inline(always)]
        pub const fn uep2_3_mod__r8_uh_ep_mod(&self) -> &UEP2_3_MOD__R8_UH_EP_MOD {
            &self.uep2_3_mod__r8_uh_ep_mod
        }
        ///0x0e - endpoint 5/6 mode
        #[inline(always)]
        pub const fn uep5_6_mod(&self) -> &UEP5_6_MOD {
            &self.uep5_6_mod
        }
        ///0x0f - endpoint 7 mode
        #[inline(always)]
        pub const fn uep7_mod(&self) -> &UEP7_MOD {
            &self.uep7_mod
        }
        ///0x10 - endpoint 0 DMA buffer address
        #[inline(always)]
        pub const fn uep0_dma(&self) -> &UEP0_DMA {
            &self.uep0_dma
        }
        ///0x14 - endpoint 1 DMA buffer address
        #[inline(always)]
        pub const fn uep1_dma(&self) -> &UEP1_DMA {
            &self.uep1_dma
        }
        ///0x18 - endpoint 2 DMA buffer address
        #[inline(always)]
        pub const fn uep2_dma__r16_uh_rx_dma(&self) -> &UEP2_DMA__R16_UH_RX_DMA {
            &self.uep2_dma__r16_uh_rx_dma
        }
        ///0x1c - endpoint 3 DMA buffer address
        #[inline(always)]
        pub const fn uep3_dma__r16_uh_tx_dma(&self) -> &UEP3_DMA__R16_UH_TX_DMA {
            &self.uep3_dma__r16_uh_tx_dma
        }
        ///0x20 - endpoint 4 DMA buffer address
        #[inline(always)]
        pub const fn uep4_dma(&self) -> &UEP4_DMA {
            &self.uep4_dma
        }
        ///0x24 - endpoint 5 DMA buffer address
        #[inline(always)]
        pub const fn uep5_dma(&self) -> &UEP5_DMA {
            &self.uep5_dma
        }
        ///0x28 - endpoint 6 DMA buffer address
        #[inline(always)]
        pub const fn uep6_dma(&self) -> &UEP6_DMA {
            &self.uep6_dma
        }
        ///0x2c - endpoint 7 DMA buffer address
        #[inline(always)]
        pub const fn uep7_dma(&self) -> &UEP7_DMA {
            &self.uep7_dma
        }
        ///0x30 - endpoint send length register
        #[inline(always)]
        pub const fn uep0_t_len(&self) -> &UEP0_T_LEN {
            &self.uep0_t_len
        }
        ///0x32 - endpoint control register
        #[inline(always)]
        pub const fn uep0_ctrl(&self) -> &UEP0_CTRL {
            &self.uep0_ctrl
        }
        ///0x34 - endpoint send length register
        #[inline(always)]
        pub const fn uep1_t_len(&self) -> &UEP1_T_LEN {
            &self.uep1_t_len
        }
        ///0x36 - endpoint control register
        #[inline(always)]
        pub const fn uep1_ctrl__r16_uh_setup(&self) -> &UEP1_CTRL__R16_UH_SETUP {
            &self.uep1_ctrl__r16_uh_setup
        }
        ///0x38 - endpoint send length register
        #[inline(always)]
        pub const fn uep2_t_len(&self) -> &UEP2_T_LEN {
            &self.uep2_t_len
        }
        ///0x3a - endpoint control register
        #[inline(always)]
        pub const fn uep2_ctrl(&self) -> &UEP2_CTRL {
            unsafe { &*(self as *const Self).cast::<u8>().add(58).cast() }
        }
        ///0x3b - USB host receive endpoint control register
        #[inline(always)]
        pub const fn uh_rx_ctrl(&self) -> &UH_RX_CTRL {
            unsafe { &*(self as *const Self).cast::<u8>().add(59).cast() }
        }
        ///0x3c - endpoint send length register
        #[inline(always)]
        pub const fn uep3_t_len__r16_uh_tx_len(&self) -> &UEP3_T_LEN__R16_UH_TX_LEN {
            &self.uep3_t_len__r16_uh_tx_len
        }
        ///0x3e - endpoint control register;USB host send endpoint control register
        #[inline(always)]
        pub const fn uep3_ctrl__r8_uh_tx_ctrl(&self) -> &UEP3_CTRL__R8_UH_TX_CTRL {
            &self.uep3_ctrl__r8_uh_tx_ctrl
        }
        ///0x40 - endpoint send length register
        #[inline(always)]
        pub const fn uep4_t_len(&self) -> &UEP4_T_LEN {
            &self.uep4_t_len
        }
        ///0x42 - endpoint control register
        #[inline(always)]
        pub const fn uep4_ctrl(&self) -> &UEP4_CTRL {
            &self.uep4_ctrl
        }
        ///0x44 - endpoint send length register
        #[inline(always)]
        pub const fn uep5_t_len(&self) -> &UEP5_T_LEN {
            &self.uep5_t_len
        }
        ///0x46 - endpoint control register
        #[inline(always)]
        pub const fn uep5_ctrl(&self) -> &UEP5_CTRL {
            &self.uep5_ctrl
        }
        ///0x48 - endpoint send length register
        #[inline(always)]
        pub const fn uep6_t_len(&self) -> &UEP6_T_LEN {
            &self.uep6_t_len
        }
        ///0x4a - endpoint control register
        #[inline(always)]
        pub const fn uep6_ctrl(&self) -> &UEP6_CTRL {
            &self.uep6_ctrl
        }
        ///0x4c - endpoint send length register
        #[inline(always)]
        pub const fn uep7_t_len(&self) -> &UEP7_T_LEN {
            &self.uep7_t_len
        }
        ///0x4e - endpoint control register
        #[inline(always)]
        pub const fn uep7_ctrl(&self) -> &UEP7_CTRL {
            &self.uep7_ctrl
        }
    }
    ///USB_CTRL (rw) register accessor: USB base control
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`usb_ctrl::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`usb_ctrl::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@usb_ctrl`]
    ///module
    pub type USB_CTRL = crate::Reg<usb_ctrl::USB_CTRL_SPEC>;
    ///USB base control
    pub mod usb_ctrl {
        ///Register `USB_CTRL` reader
        pub type R = crate::R<USB_CTRL_SPEC>;
        ///Register `USB_CTRL` writer
        pub type W = crate::W<USB_CTRL_SPEC>;
        ///Field `UC_DMA_EN` reader - DMA enable and DMA interrupt enable for USB
        pub type UC_DMA_EN_R = crate::BitReader;
        ///Field `UC_DMA_EN` writer - DMA enable and DMA interrupt enable for USB
        pub type UC_DMA_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UC_CLR_ALL` reader - force clear FIFO and count of USB
        pub type UC_CLR_ALL_R = crate::BitReader;
        ///Field `UC_CLR_ALL` writer - force clear FIFO and count of USB
        pub type UC_CLR_ALL_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UC_RESET_SIE` reader - force reset USB SIE, need software clear
        pub type UC_RESET_SIE_R = crate::BitReader;
        ///Field `UC_RESET_SIE` writer - force reset USB SIE, need software clear
        pub type UC_RESET_SIE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UC_INT_BUSY` reader - enable automatic responding busy for device mode or automatic pause for host mode during interrupt flag UIF_TRANSFER valid
        pub type UC_INT_BUSY_R = crate::BitReader;
        ///Field `UC_INT_BUSY` writer - enable automatic responding busy for device mode or automatic pause for host mode during interrupt flag UIF_TRANSFER valid
        pub type UC_INT_BUSY_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `SYS_MODE` reader - Test mode in Host mode
        pub type SYS_MODE_R = crate::FieldReader;
        ///Field `SYS_MODE` writer - Test mode in Host mode
        pub type SYS_MODE_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `UC_LOW_SPEED` reader - USB bus signal transmission rate select bit
        pub type UC_LOW_SPEED_R = crate::BitReader;
        ///Field `UC_LOW_SPEED` writer - USB bus signal transmission rate select bit
        pub type UC_LOW_SPEED_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UC_HOST_MODE` reader - enable USB host mode: 0=device mode, 1=host mode
        pub type UC_HOST_MODE_R = crate::BitReader;
        ///Field `UC_HOST_MODE` writer - enable USB host mode: 0=device mode, 1=host mode
        pub type UC_HOST_MODE_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - DMA enable and DMA interrupt enable for USB
            #[inline(always)]
            pub fn uc_dma_en(&self) -> UC_DMA_EN_R {
                UC_DMA_EN_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - force clear FIFO and count of USB
            #[inline(always)]
            pub fn uc_clr_all(&self) -> UC_CLR_ALL_R {
                UC_CLR_ALL_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - force reset USB SIE, need software clear
            #[inline(always)]
            pub fn uc_reset_sie(&self) -> UC_RESET_SIE_R {
                UC_RESET_SIE_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - enable automatic responding busy for device mode or automatic pause for host mode during interrupt flag UIF_TRANSFER valid
            #[inline(always)]
            pub fn uc_int_busy(&self) -> UC_INT_BUSY_R {
                UC_INT_BUSY_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bits 4:5 - Test mode in Host mode
            #[inline(always)]
            pub fn sys_mode(&self) -> SYS_MODE_R {
                SYS_MODE_R::new((self.bits >> 4) & 3)
            }
            ///Bit 6 - USB bus signal transmission rate select bit
            #[inline(always)]
            pub fn uc_low_speed(&self) -> UC_LOW_SPEED_R {
                UC_LOW_SPEED_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - enable USB host mode: 0=device mode, 1=host mode
            #[inline(always)]
            pub fn uc_host_mode(&self) -> UC_HOST_MODE_R {
                UC_HOST_MODE_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - DMA enable and DMA interrupt enable for USB
            #[inline(always)]
            #[must_use]
            pub fn uc_dma_en(&mut self) -> UC_DMA_EN_W<USB_CTRL_SPEC> {
                UC_DMA_EN_W::new(self, 0)
            }
            ///Bit 1 - force clear FIFO and count of USB
            #[inline(always)]
            #[must_use]
            pub fn uc_clr_all(&mut self) -> UC_CLR_ALL_W<USB_CTRL_SPEC> {
                UC_CLR_ALL_W::new(self, 1)
            }
            ///Bit 2 - force reset USB SIE, need software clear
            #[inline(always)]
            #[must_use]
            pub fn uc_reset_sie(&mut self) -> UC_RESET_SIE_W<USB_CTRL_SPEC> {
                UC_RESET_SIE_W::new(self, 2)
            }
            ///Bit 3 - enable automatic responding busy for device mode or automatic pause for host mode during interrupt flag UIF_TRANSFER valid
            #[inline(always)]
            #[must_use]
            pub fn uc_int_busy(&mut self) -> UC_INT_BUSY_W<USB_CTRL_SPEC> {
                UC_INT_BUSY_W::new(self, 3)
            }
            ///Bits 4:5 - Test mode in Host mode
            #[inline(always)]
            #[must_use]
            pub fn sys_mode(&mut self) -> SYS_MODE_W<USB_CTRL_SPEC> {
                SYS_MODE_W::new(self, 4)
            }
            ///Bit 6 - USB bus signal transmission rate select bit
            #[inline(always)]
            #[must_use]
            pub fn uc_low_speed(&mut self) -> UC_LOW_SPEED_W<USB_CTRL_SPEC> {
                UC_LOW_SPEED_W::new(self, 6)
            }
            ///Bit 7 - enable USB host mode: 0=device mode, 1=host mode
            #[inline(always)]
            #[must_use]
            pub fn uc_host_mode(&mut self) -> UC_HOST_MODE_W<USB_CTRL_SPEC> {
                UC_HOST_MODE_W::new(self, 7)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///USB base control
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`usb_ctrl::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`usb_ctrl::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct USB_CTRL_SPEC;
        impl crate::RegisterSpec for USB_CTRL_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`usb_ctrl::R`](R) reader structure
        impl crate::Readable for USB_CTRL_SPEC {}
        ///`write(|w| ..)` method takes [`usb_ctrl::W`](W) writer structure
        impl crate::Writable for USB_CTRL_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets USB_CTRL to value 0x06
        impl crate::Resettable for USB_CTRL_SPEC {
            const RESET_VALUE: u8 = 0x06;
        }
    }
    ///USB_INT_EN (rw) register accessor: USB interrupt enable
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`usb_int_en::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`usb_int_en::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@usb_int_en`]
    ///module
    pub type USB_INT_EN = crate::Reg<usb_int_en::USB_INT_EN_SPEC>;
    ///USB interrupt enable
    pub mod usb_int_en {
        ///Register `USB_INT_EN` reader
        pub type R = crate::R<USB_INT_EN_SPEC>;
        ///Register `USB_INT_EN` writer
        pub type W = crate::W<USB_INT_EN_SPEC>;
        ///Field `UIE_BUS_RST__RB_UIE_DETECT` reader - enable interrupt for USB bus reset event for USB device mode;enable interrupt for USB device detected event for USB host mode
        pub type UIE_BUS_RST__RB_UIE_DETECT_R = crate::BitReader;
        ///Field `UIE_BUS_RST__RB_UIE_DETECT` writer - enable interrupt for USB bus reset event for USB device mode;enable interrupt for USB device detected event for USB host mode
        pub type UIE_BUS_RST__RB_UIE_DETECT_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UIE_TRANSFER` reader - enable interrupt for USB transfer completion
        pub type UIE_TRANSFER_R = crate::BitReader;
        ///Field `UIE_TRANSFER` writer - enable interrupt for USB transfer completion
        pub type UIE_TRANSFER_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UIE_SUSPEND` reader - enable interrupt for USB suspend or resume event
        pub type UIE_SUSPEND_R = crate::BitReader;
        ///Field `UIE_SUSPEND` writer - enable interrupt for USB suspend or resume event
        pub type UIE_SUSPEND_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UIE_HST_SOF` reader - in USB host mode, SOF is interrupt periodically
        pub type UIE_HST_SOF_R = crate::BitReader;
        ///Field `UIE_HST_SOF` writer - in USB host mode, SOF is interrupt periodically
        pub type UIE_HST_SOF_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UIE_FIFO_OV` reader - enable interrupt for FIFO overflow
        pub type UIE_FIFO_OV_R = crate::BitReader;
        ///Field `UIE_FIFO_OV` writer - enable interrupt for FIFO overflow
        pub type UIE_FIFO_OV_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `MOD_1_WIRE` reader - USB single-line mode enable
        pub type MOD_1_WIRE_R = crate::BitReader;
        ///Field `MOD_1_WIRE` writer - USB single-line mode enable
        pub type MOD_1_WIRE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UIE_DEV_NAK` reader - enable interrupt for NAK responded for USB device mode
        pub type UIE_DEV_NAK_R = crate::BitReader;
        ///Field `UIE_DEV_NAK` writer - enable interrupt for NAK responded for USB device mode
        pub type UIE_DEV_NAK_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UIE_DEV_SOF` reader - enable interrupt for SOF responded for USB device mode
        pub type UIE_DEV_SOF_R = crate::BitReader;
        ///Field `UIE_DEV_SOF` writer - enable interrupt for SOF responded for USB device mode
        pub type UIE_DEV_SOF_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - enable interrupt for USB bus reset event for USB device mode;enable interrupt for USB device detected event for USB host mode
            #[inline(always)]
            pub fn uie_bus_rst__rb_uie_detect(&self) -> UIE_BUS_RST__RB_UIE_DETECT_R {
                UIE_BUS_RST__RB_UIE_DETECT_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - enable interrupt for USB transfer completion
            #[inline(always)]
            pub fn uie_transfer(&self) -> UIE_TRANSFER_R {
                UIE_TRANSFER_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - enable interrupt for USB suspend or resume event
            #[inline(always)]
            pub fn uie_suspend(&self) -> UIE_SUSPEND_R {
                UIE_SUSPEND_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - in USB host mode, SOF is interrupt periodically
            #[inline(always)]
            pub fn uie_hst_sof(&self) -> UIE_HST_SOF_R {
                UIE_HST_SOF_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - enable interrupt for FIFO overflow
            #[inline(always)]
            pub fn uie_fifo_ov(&self) -> UIE_FIFO_OV_R {
                UIE_FIFO_OV_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - USB single-line mode enable
            #[inline(always)]
            pub fn mod_1_wire(&self) -> MOD_1_WIRE_R {
                MOD_1_WIRE_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - enable interrupt for NAK responded for USB device mode
            #[inline(always)]
            pub fn uie_dev_nak(&self) -> UIE_DEV_NAK_R {
                UIE_DEV_NAK_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - enable interrupt for SOF responded for USB device mode
            #[inline(always)]
            pub fn uie_dev_sof(&self) -> UIE_DEV_SOF_R {
                UIE_DEV_SOF_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - enable interrupt for USB bus reset event for USB device mode;enable interrupt for USB device detected event for USB host mode
            #[inline(always)]
            #[must_use]
            pub fn uie_bus_rst__rb_uie_detect(
                &mut self,
            ) -> UIE_BUS_RST__RB_UIE_DETECT_W<USB_INT_EN_SPEC> {
                UIE_BUS_RST__RB_UIE_DETECT_W::new(self, 0)
            }
            ///Bit 1 - enable interrupt for USB transfer completion
            #[inline(always)]
            #[must_use]
            pub fn uie_transfer(&mut self) -> UIE_TRANSFER_W<USB_INT_EN_SPEC> {
                UIE_TRANSFER_W::new(self, 1)
            }
            ///Bit 2 - enable interrupt for USB suspend or resume event
            #[inline(always)]
            #[must_use]
            pub fn uie_suspend(&mut self) -> UIE_SUSPEND_W<USB_INT_EN_SPEC> {
                UIE_SUSPEND_W::new(self, 2)
            }
            ///Bit 3 - in USB host mode, SOF is interrupt periodically
            #[inline(always)]
            #[must_use]
            pub fn uie_hst_sof(&mut self) -> UIE_HST_SOF_W<USB_INT_EN_SPEC> {
                UIE_HST_SOF_W::new(self, 3)
            }
            ///Bit 4 - enable interrupt for FIFO overflow
            #[inline(always)]
            #[must_use]
            pub fn uie_fifo_ov(&mut self) -> UIE_FIFO_OV_W<USB_INT_EN_SPEC> {
                UIE_FIFO_OV_W::new(self, 4)
            }
            ///Bit 5 - USB single-line mode enable
            #[inline(always)]
            #[must_use]
            pub fn mod_1_wire(&mut self) -> MOD_1_WIRE_W<USB_INT_EN_SPEC> {
                MOD_1_WIRE_W::new(self, 5)
            }
            ///Bit 6 - enable interrupt for NAK responded for USB device mode
            #[inline(always)]
            #[must_use]
            pub fn uie_dev_nak(&mut self) -> UIE_DEV_NAK_W<USB_INT_EN_SPEC> {
                UIE_DEV_NAK_W::new(self, 6)
            }
            ///Bit 7 - enable interrupt for SOF responded for USB device mode
            #[inline(always)]
            #[must_use]
            pub fn uie_dev_sof(&mut self) -> UIE_DEV_SOF_W<USB_INT_EN_SPEC> {
                UIE_DEV_SOF_W::new(self, 7)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///USB interrupt enable
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`usb_int_en::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`usb_int_en::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct USB_INT_EN_SPEC;
        impl crate::RegisterSpec for USB_INT_EN_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`usb_int_en::R`](R) reader structure
        impl crate::Readable for USB_INT_EN_SPEC {}
        ///`write(|w| ..)` method takes [`usb_int_en::W`](W) writer structure
        impl crate::Writable for USB_INT_EN_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets USB_INT_EN to value 0
        impl crate::Resettable for USB_INT_EN_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///USB_DEV_AD (rw) register accessor: USB device address
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`usb_dev_ad::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`usb_dev_ad::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@usb_dev_ad`]
    ///module
    pub type USB_DEV_AD = crate::Reg<usb_dev_ad::USB_DEV_AD_SPEC>;
    ///USB device address
    pub mod usb_dev_ad {
        ///Register `USB_DEV_AD` reader
        pub type R = crate::R<USB_DEV_AD_SPEC>;
        ///Register `USB_DEV_AD` writer
        pub type W = crate::W<USB_DEV_AD_SPEC>;
        ///Field `MASK_USB_ADDR` reader - bit mask for USB device address
        pub type MASK_USB_ADDR_R = crate::FieldReader;
        ///Field `MASK_USB_ADDR` writer - bit mask for USB device address
        pub type MASK_USB_ADDR_W<'a, REG> = crate::FieldWriter<'a, REG, 7>;
        ///Field `UDA_GP_BIT` reader - general purpose bit
        pub type UDA_GP_BIT_R = crate::BitReader;
        ///Field `UDA_GP_BIT` writer - general purpose bit
        pub type UDA_GP_BIT_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bits 0:6 - bit mask for USB device address
            #[inline(always)]
            pub fn mask_usb_addr(&self) -> MASK_USB_ADDR_R {
                MASK_USB_ADDR_R::new(self.bits & 0x7f)
            }
            ///Bit 7 - general purpose bit
            #[inline(always)]
            pub fn uda_gp_bit(&self) -> UDA_GP_BIT_R {
                UDA_GP_BIT_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:6 - bit mask for USB device address
            #[inline(always)]
            #[must_use]
            pub fn mask_usb_addr(&mut self) -> MASK_USB_ADDR_W<USB_DEV_AD_SPEC> {
                MASK_USB_ADDR_W::new(self, 0)
            }
            ///Bit 7 - general purpose bit
            #[inline(always)]
            #[must_use]
            pub fn uda_gp_bit(&mut self) -> UDA_GP_BIT_W<USB_DEV_AD_SPEC> {
                UDA_GP_BIT_W::new(self, 7)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///USB device address
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`usb_dev_ad::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`usb_dev_ad::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct USB_DEV_AD_SPEC;
        impl crate::RegisterSpec for USB_DEV_AD_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`usb_dev_ad::R`](R) reader structure
        impl crate::Readable for USB_DEV_AD_SPEC {}
        ///`write(|w| ..)` method takes [`usb_dev_ad::W`](W) writer structure
        impl crate::Writable for USB_DEV_AD_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets USB_DEV_AD to value 0
        impl crate::Resettable for USB_DEV_AD_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///USB_MIS_ST (rw) register accessor: USB miscellaneous status register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`usb_mis_st::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`usb_mis_st::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@usb_mis_st`]
    ///module
    pub type USB_MIS_ST = crate::Reg<usb_mis_st::USB_MIS_ST_SPEC>;
    ///USB miscellaneous status register
    pub mod usb_mis_st {
        ///Register `USB_MIS_ST` reader
        pub type R = crate::R<USB_MIS_ST_SPEC>;
        ///Register `USB_MIS_ST` writer
        pub type W = crate::W<USB_MIS_ST_SPEC>;
        ///Field `UMS_DEV_ATTACH` reader - port connection status
        pub type UMS_DEV_ATTACH_R = crate::BitReader;
        ///Field `UMS_DEV_ATTACH` writer - port connection status
        pub type UMS_DEV_ATTACH_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UMS_DM_LEVEL` reader - judgment speed
        pub type UMS_DM_LEVEL_R = crate::BitReader;
        ///Field `UMS_DM_LEVEL` writer - judgment speed
        pub type UMS_DM_LEVEL_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UMS_SUSPEND` reader - USB hangs up status bits
        pub type UMS_SUSPEND_R = crate::BitReader;
        ///Field `UMS_SUSPEND` writer - USB hangs up status bits
        pub type UMS_SUSPEND_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UMS_BUS_RST` reader - USB bus reset status bit
        pub type UMS_BUS_RST_R = crate::BitReader;
        ///Field `UMS_BUS_RST` writer - USB bus reset status bit
        pub type UMS_BUS_RST_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UMS_R_FIFO_RDY` reader - USB receives FIFO dataready status bit
        pub type UMS_R_FIFO_RDY_R = crate::BitReader;
        ///Field `UMS_R_FIFO_RDY` writer - USB receives FIFO dataready status bit
        pub type UMS_R_FIFO_RDY_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UMS_SIE_FREE` reader - IDLE state bit of the USB protocol processor
        pub type UMS_SIE_FREE_R = crate::BitReader;
        ///Field `UMS_SIE_FREE` writer - IDLE state bit of the USB protocol processor
        pub type UMS_SIE_FREE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UMS_SOF_ACT` reader - SOF package transmission status bit in USB host mode
        pub type UMS_SOF_ACT_R = crate::BitReader;
        ///Field `UMS_SOF_ACT` writer - SOF package transmission status bit in USB host mode
        pub type UMS_SOF_ACT_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UMS_SOF_PRES` reader - SOF package indicates the status bit in USB host mode
        pub type UMS_SOF_PRES_R = crate::BitReader;
        ///Field `UMS_SOF_PRES` writer - SOF package indicates the status bit in USB host mode
        pub type UMS_SOF_PRES_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - port connection status
            #[inline(always)]
            pub fn ums_dev_attach(&self) -> UMS_DEV_ATTACH_R {
                UMS_DEV_ATTACH_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - judgment speed
            #[inline(always)]
            pub fn ums_dm_level(&self) -> UMS_DM_LEVEL_R {
                UMS_DM_LEVEL_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - USB hangs up status bits
            #[inline(always)]
            pub fn ums_suspend(&self) -> UMS_SUSPEND_R {
                UMS_SUSPEND_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - USB bus reset status bit
            #[inline(always)]
            pub fn ums_bus_rst(&self) -> UMS_BUS_RST_R {
                UMS_BUS_RST_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - USB receives FIFO dataready status bit
            #[inline(always)]
            pub fn ums_r_fifo_rdy(&self) -> UMS_R_FIFO_RDY_R {
                UMS_R_FIFO_RDY_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - IDLE state bit of the USB protocol processor
            #[inline(always)]
            pub fn ums_sie_free(&self) -> UMS_SIE_FREE_R {
                UMS_SIE_FREE_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - SOF package transmission status bit in USB host mode
            #[inline(always)]
            pub fn ums_sof_act(&self) -> UMS_SOF_ACT_R {
                UMS_SOF_ACT_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - SOF package indicates the status bit in USB host mode
            #[inline(always)]
            pub fn ums_sof_pres(&self) -> UMS_SOF_PRES_R {
                UMS_SOF_PRES_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - port connection status
            #[inline(always)]
            #[must_use]
            pub fn ums_dev_attach(&mut self) -> UMS_DEV_ATTACH_W<USB_MIS_ST_SPEC> {
                UMS_DEV_ATTACH_W::new(self, 0)
            }
            ///Bit 1 - judgment speed
            #[inline(always)]
            #[must_use]
            pub fn ums_dm_level(&mut self) -> UMS_DM_LEVEL_W<USB_MIS_ST_SPEC> {
                UMS_DM_LEVEL_W::new(self, 1)
            }
            ///Bit 2 - USB hangs up status bits
            #[inline(always)]
            #[must_use]
            pub fn ums_suspend(&mut self) -> UMS_SUSPEND_W<USB_MIS_ST_SPEC> {
                UMS_SUSPEND_W::new(self, 2)
            }
            ///Bit 3 - USB bus reset status bit
            #[inline(always)]
            #[must_use]
            pub fn ums_bus_rst(&mut self) -> UMS_BUS_RST_W<USB_MIS_ST_SPEC> {
                UMS_BUS_RST_W::new(self, 3)
            }
            ///Bit 4 - USB receives FIFO dataready status bit
            #[inline(always)]
            #[must_use]
            pub fn ums_r_fifo_rdy(&mut self) -> UMS_R_FIFO_RDY_W<USB_MIS_ST_SPEC> {
                UMS_R_FIFO_RDY_W::new(self, 4)
            }
            ///Bit 5 - IDLE state bit of the USB protocol processor
            #[inline(always)]
            #[must_use]
            pub fn ums_sie_free(&mut self) -> UMS_SIE_FREE_W<USB_MIS_ST_SPEC> {
                UMS_SIE_FREE_W::new(self, 5)
            }
            ///Bit 6 - SOF package transmission status bit in USB host mode
            #[inline(always)]
            #[must_use]
            pub fn ums_sof_act(&mut self) -> UMS_SOF_ACT_W<USB_MIS_ST_SPEC> {
                UMS_SOF_ACT_W::new(self, 6)
            }
            ///Bit 7 - SOF package indicates the status bit in USB host mode
            #[inline(always)]
            #[must_use]
            pub fn ums_sof_pres(&mut self) -> UMS_SOF_PRES_W<USB_MIS_ST_SPEC> {
                UMS_SOF_PRES_W::new(self, 7)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///USB miscellaneous status register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`usb_mis_st::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`usb_mis_st::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct USB_MIS_ST_SPEC;
        impl crate::RegisterSpec for USB_MIS_ST_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`usb_mis_st::R`](R) reader structure
        impl crate::Readable for USB_MIS_ST_SPEC {}
        ///`write(|w| ..)` method takes [`usb_mis_st::W`](W) writer structure
        impl crate::Writable for USB_MIS_ST_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets USB_MIS_ST to value 0
        impl crate::Resettable for USB_MIS_ST_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///USB_INT_FG (rw) register accessor: USB miscellaneous status register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`usb_int_fg::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`usb_int_fg::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@usb_int_fg`]
    ///module
    pub type USB_INT_FG = crate::Reg<usb_int_fg::USB_INT_FG_SPEC>;
    ///USB miscellaneous status register
    pub mod usb_int_fg {
        ///Register `USB_INT_FG` reader
        pub type R = crate::R<USB_INT_FG_SPEC>;
        ///Register `USB_INT_FG` writer
        pub type W = crate::W<USB_INT_FG_SPEC>;
        ///Field `UIF_DETECT__RB_UIF_BUS_RST` reader - interrupt flag bit
        pub type UIF_DETECT__RB_UIF_BUS_RST_R = crate::BitReader;
        ///Field `UIF_DETECT__RB_UIF_BUS_RST` writer - interrupt flag bit
        pub type UIF_DETECT__RB_UIF_BUS_RST_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UIF_TRANSFER` reader - USB transfer completion interrupt flag
        pub type UIF_TRANSFER_R = crate::BitReader;
        ///Field `UIF_TRANSFER` writer - USB transfer completion interrupt flag
        pub type UIF_TRANSFER_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UIF_SUSPEND` reader - USB bus suspend or wake-up event interrupt flag
        pub type UIF_SUSPEND_R = crate::BitReader;
        ///Field `UIF_SUSPEND` writer - USB bus suspend or wake-up event interrupt flag
        pub type UIF_SUSPEND_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UIF_HST_SOF` reader - SOF timer interrupt flag in USB host mode
        pub type UIF_HST_SOF_R = crate::BitReader;
        ///Field `UIF_HST_SOF` writer - SOF timer interrupt flag in USB host mode
        pub type UIF_HST_SOF_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UIF_FIFO_OV` reader - USB FIFO overflow interrupt flag
        pub type UIF_FIFO_OV_R = crate::BitReader;
        ///Field `UIF_FIFO_OV` writer - USB FIFO overflow interrupt flag
        pub type UIF_FIFO_OV_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `U_SIE_FREE` reader - PID characteristic
        pub type U_SIE_FREE_R = crate::BitReader;
        ///Field `U_SIE_FREE` writer - PID characteristic
        pub type U_SIE_FREE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `U_TOG_OK` reader - synchronization flag matches the status bits
        pub type U_TOG_OK_R = crate::BitReader;
        ///Field `U_TOG_OK` writer - synchronization flag matches the status bits
        pub type U_TOG_OK_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `U_IS_NAK` reader - SOF package indicates the status bit in USB host mode
        pub type U_IS_NAK_R = crate::BitReader;
        ///Field `U_IS_NAK` writer - SOF package indicates the status bit in USB host mode
        pub type U_IS_NAK_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - interrupt flag bit
            #[inline(always)]
            pub fn uif_detect__rb_uif_bus_rst(&self) -> UIF_DETECT__RB_UIF_BUS_RST_R {
                UIF_DETECT__RB_UIF_BUS_RST_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - USB transfer completion interrupt flag
            #[inline(always)]
            pub fn uif_transfer(&self) -> UIF_TRANSFER_R {
                UIF_TRANSFER_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - USB bus suspend or wake-up event interrupt flag
            #[inline(always)]
            pub fn uif_suspend(&self) -> UIF_SUSPEND_R {
                UIF_SUSPEND_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - SOF timer interrupt flag in USB host mode
            #[inline(always)]
            pub fn uif_hst_sof(&self) -> UIF_HST_SOF_R {
                UIF_HST_SOF_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - USB FIFO overflow interrupt flag
            #[inline(always)]
            pub fn uif_fifo_ov(&self) -> UIF_FIFO_OV_R {
                UIF_FIFO_OV_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - PID characteristic
            #[inline(always)]
            pub fn u_sie_free(&self) -> U_SIE_FREE_R {
                U_SIE_FREE_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - synchronization flag matches the status bits
            #[inline(always)]
            pub fn u_tog_ok(&self) -> U_TOG_OK_R {
                U_TOG_OK_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - SOF package indicates the status bit in USB host mode
            #[inline(always)]
            pub fn u_is_nak(&self) -> U_IS_NAK_R {
                U_IS_NAK_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - interrupt flag bit
            #[inline(always)]
            #[must_use]
            pub fn uif_detect__rb_uif_bus_rst(
                &mut self,
            ) -> UIF_DETECT__RB_UIF_BUS_RST_W<USB_INT_FG_SPEC> {
                UIF_DETECT__RB_UIF_BUS_RST_W::new(self, 0)
            }
            ///Bit 1 - USB transfer completion interrupt flag
            #[inline(always)]
            #[must_use]
            pub fn uif_transfer(&mut self) -> UIF_TRANSFER_W<USB_INT_FG_SPEC> {
                UIF_TRANSFER_W::new(self, 1)
            }
            ///Bit 2 - USB bus suspend or wake-up event interrupt flag
            #[inline(always)]
            #[must_use]
            pub fn uif_suspend(&mut self) -> UIF_SUSPEND_W<USB_INT_FG_SPEC> {
                UIF_SUSPEND_W::new(self, 2)
            }
            ///Bit 3 - SOF timer interrupt flag in USB host mode
            #[inline(always)]
            #[must_use]
            pub fn uif_hst_sof(&mut self) -> UIF_HST_SOF_W<USB_INT_FG_SPEC> {
                UIF_HST_SOF_W::new(self, 3)
            }
            ///Bit 4 - USB FIFO overflow interrupt flag
            #[inline(always)]
            #[must_use]
            pub fn uif_fifo_ov(&mut self) -> UIF_FIFO_OV_W<USB_INT_FG_SPEC> {
                UIF_FIFO_OV_W::new(self, 4)
            }
            ///Bit 5 - PID characteristic
            #[inline(always)]
            #[must_use]
            pub fn u_sie_free(&mut self) -> U_SIE_FREE_W<USB_INT_FG_SPEC> {
                U_SIE_FREE_W::new(self, 5)
            }
            ///Bit 6 - synchronization flag matches the status bits
            #[inline(always)]
            #[must_use]
            pub fn u_tog_ok(&mut self) -> U_TOG_OK_W<USB_INT_FG_SPEC> {
                U_TOG_OK_W::new(self, 6)
            }
            ///Bit 7 - SOF package indicates the status bit in USB host mode
            #[inline(always)]
            #[must_use]
            pub fn u_is_nak(&mut self) -> U_IS_NAK_W<USB_INT_FG_SPEC> {
                U_IS_NAK_W::new(self, 7)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///USB miscellaneous status register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`usb_int_fg::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`usb_int_fg::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct USB_INT_FG_SPEC;
        impl crate::RegisterSpec for USB_INT_FG_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`usb_int_fg::R`](R) reader structure
        impl crate::Readable for USB_INT_FG_SPEC {}
        ///`write(|w| ..)` method takes [`usb_int_fg::W`](W) writer structure
        impl crate::Writable for USB_INT_FG_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets USB_INT_FG to value 0
        impl crate::Resettable for USB_INT_FG_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///USB_INT_ST (r) register accessor: USB interrupt status register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`usb_int_st::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@usb_int_st`]
    ///module
    pub type USB_INT_ST = crate::Reg<usb_int_st::USB_INT_ST_SPEC>;
    ///USB interrupt status register
    pub mod usb_int_st {
        ///Register `USB_INT_ST` reader
        pub type R = crate::R<USB_INT_ST_SPEC>;
        ///Field `MASK_UIS_ENDP__MASK_UIS_H_RES` reader - device mode:the endpoint number of current USB transfer transaction ; host mode :PID identifier of the current USB transfer transaction
        pub type MASK_UIS_ENDP__MASK_UIS_H_RES_R = crate::FieldReader;
        ///Field `MASK_UIS_TOKEN` reader - In device mode, the token PID identifier of the current USB transfer transaction
        pub type MASK_UIS_TOKEN_R = crate::FieldReader;
        ///Field `UIS_TOG_OK` reader - Match Status Bits
        pub type UIS_TOG_OK_R = crate::BitReader;
        ///Field `SETUP_ACT` reader - SETUP transaction is completed
        pub type SETUP_ACT_R = crate::BitReader;
        impl R {
            ///Bits 0:3 - device mode:the endpoint number of current USB transfer transaction ; host mode :PID identifier of the current USB transfer transaction
            #[inline(always)]
            pub fn mask_uis_endp__mask_uis_h_res(&self) -> MASK_UIS_ENDP__MASK_UIS_H_RES_R {
                MASK_UIS_ENDP__MASK_UIS_H_RES_R::new(self.bits & 0x0f)
            }
            ///Bits 4:5 - In device mode, the token PID identifier of the current USB transfer transaction
            #[inline(always)]
            pub fn mask_uis_token(&self) -> MASK_UIS_TOKEN_R {
                MASK_UIS_TOKEN_R::new((self.bits >> 4) & 3)
            }
            ///Bit 6 - Match Status Bits
            #[inline(always)]
            pub fn uis_tog_ok(&self) -> UIS_TOG_OK_R {
                UIS_TOG_OK_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - SETUP transaction is completed
            #[inline(always)]
            pub fn setup_act(&self) -> SETUP_ACT_R {
                SETUP_ACT_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        ///USB interrupt status register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`usb_int_st::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct USB_INT_ST_SPEC;
        impl crate::RegisterSpec for USB_INT_ST_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`usb_int_st::R`](R) reader structure
        impl crate::Readable for USB_INT_ST_SPEC {}
        ///`reset()` method sets USB_INT_ST to value 0
        impl crate::Resettable for USB_INT_ST_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///USB_RX_LEN (r) register accessor: USB miscellaneous status register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`usb_rx_len::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@usb_rx_len`]
    ///module
    pub type USB_RX_LEN = crate::Reg<usb_rx_len::USB_RX_LEN_SPEC>;
    ///USB miscellaneous status register
    pub mod usb_rx_len {
        ///Register `USB_RX_LEN` reader
        pub type R = crate::R<USB_RX_LEN_SPEC>;
        ///Field `USB_RX_LEN` reader - current number of data bytes received by the USB endpoint
        pub type USB_RX_LEN_R = crate::FieldReader<u16>;
        impl R {
            ///Bits 0:9 - current number of data bytes received by the USB endpoint
            #[inline(always)]
            pub fn usb_rx_len(&self) -> USB_RX_LEN_R {
                USB_RX_LEN_R::new(self.bits & 0x03ff)
            }
        }
        ///USB miscellaneous status register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`usb_rx_len::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct USB_RX_LEN_SPEC;
        impl crate::RegisterSpec for USB_RX_LEN_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`usb_rx_len::R`](R) reader structure
        impl crate::Readable for USB_RX_LEN_SPEC {}
        ///`reset()` method sets USB_RX_LEN to value 0
        impl crate::Resettable for USB_RX_LEN_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///UDEV_CTRL__R8_UHOST_CTRL (rw) register accessor: USB host physical port control register;USB host physical port control register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`udev_ctrl__r8_uhost_ctrl::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`udev_ctrl__r8_uhost_ctrl::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@udev_ctrl__r8_uhost_ctrl`]
    ///module
    pub type UDEV_CTRL__R8_UHOST_CTRL =
        crate::Reg<udev_ctrl__r8_uhost_ctrl::UDEV_CTRL__R8_UHOST_CTRL_SPEC>;
    ///USB host physical port control register;USB host physical port control register
    pub mod udev_ctrl__r8_uhost_ctrl {
        ///Register `UDEV_CTRL__R8_UHOST_CTRL` reader
        pub type R = crate::R<UDEV_CTRL__R8_UHOST_CTRL_SPEC>;
        ///Register `UDEV_CTRL__R8_UHOST_CTRL` writer
        pub type W = crate::W<UDEV_CTRL__R8_UHOST_CTRL_SPEC>;
        ///Field `UD_PORT_EN` reader - usb host port enable
        pub type UD_PORT_EN_R = crate::BitReader;
        ///Field `UD_PORT_EN` writer - usb host port enable
        pub type UD_PORT_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UD_GP_BIT` reader - common flag bit
        pub type UD_GP_BIT_R = crate::BitReader;
        ///Field `UD_GP_BIT` writer - common flag bit
        pub type UD_GP_BIT_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UD_LOW_SPEED` reader - usb host port low-speed mode enable
        pub type UD_LOW_SPEED_R = crate::BitReader;
        ///Field `UD_LOW_SPEED` writer - usb host port low-speed mode enable
        pub type UD_LOW_SPEED_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UD_DM_PIN` reader - current pin status
        pub type UD_DM_PIN_R = crate::BitReader;
        ///Field `UD_DM_PIN` writer - current pin status
        pub type UD_DM_PIN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UD_DP_PIN` reader - current pin status
        pub type UD_DP_PIN_R = crate::BitReader;
        ///Field `UD_DP_PIN` writer - current pin status
        pub type UD_DP_PIN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UD_PD_DIS` reader - USB host port internal pull-down resistance control
        pub type UD_PD_DIS_R = crate::BitReader;
        ///Field `UD_PD_DIS` writer - USB host port internal pull-down resistance control
        pub type UD_PD_DIS_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - usb host port enable
            #[inline(always)]
            pub fn ud_port_en(&self) -> UD_PORT_EN_R {
                UD_PORT_EN_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - common flag bit
            #[inline(always)]
            pub fn ud_gp_bit(&self) -> UD_GP_BIT_R {
                UD_GP_BIT_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - usb host port low-speed mode enable
            #[inline(always)]
            pub fn ud_low_speed(&self) -> UD_LOW_SPEED_R {
                UD_LOW_SPEED_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 4 - current pin status
            #[inline(always)]
            pub fn ud_dm_pin(&self) -> UD_DM_PIN_R {
                UD_DM_PIN_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - current pin status
            #[inline(always)]
            pub fn ud_dp_pin(&self) -> UD_DP_PIN_R {
                UD_DP_PIN_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 7 - USB host port internal pull-down resistance control
            #[inline(always)]
            pub fn ud_pd_dis(&self) -> UD_PD_DIS_R {
                UD_PD_DIS_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - usb host port enable
            #[inline(always)]
            #[must_use]
            pub fn ud_port_en(&mut self) -> UD_PORT_EN_W<UDEV_CTRL__R8_UHOST_CTRL_SPEC> {
                UD_PORT_EN_W::new(self, 0)
            }
            ///Bit 1 - common flag bit
            #[inline(always)]
            #[must_use]
            pub fn ud_gp_bit(&mut self) -> UD_GP_BIT_W<UDEV_CTRL__R8_UHOST_CTRL_SPEC> {
                UD_GP_BIT_W::new(self, 1)
            }
            ///Bit 2 - usb host port low-speed mode enable
            #[inline(always)]
            #[must_use]
            pub fn ud_low_speed(&mut self) -> UD_LOW_SPEED_W<UDEV_CTRL__R8_UHOST_CTRL_SPEC> {
                UD_LOW_SPEED_W::new(self, 2)
            }
            ///Bit 4 - current pin status
            #[inline(always)]
            #[must_use]
            pub fn ud_dm_pin(&mut self) -> UD_DM_PIN_W<UDEV_CTRL__R8_UHOST_CTRL_SPEC> {
                UD_DM_PIN_W::new(self, 4)
            }
            ///Bit 5 - current pin status
            #[inline(always)]
            #[must_use]
            pub fn ud_dp_pin(&mut self) -> UD_DP_PIN_W<UDEV_CTRL__R8_UHOST_CTRL_SPEC> {
                UD_DP_PIN_W::new(self, 5)
            }
            ///Bit 7 - USB host port internal pull-down resistance control
            #[inline(always)]
            #[must_use]
            pub fn ud_pd_dis(&mut self) -> UD_PD_DIS_W<UDEV_CTRL__R8_UHOST_CTRL_SPEC> {
                UD_PD_DIS_W::new(self, 7)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///USB host physical port control register;USB host physical port control register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`udev_ctrl__r8_uhost_ctrl::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`udev_ctrl__r8_uhost_ctrl::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct UDEV_CTRL__R8_UHOST_CTRL_SPEC;
        impl crate::RegisterSpec for UDEV_CTRL__R8_UHOST_CTRL_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`udev_ctrl__r8_uhost_ctrl::R`](R) reader structure
        impl crate::Readable for UDEV_CTRL__R8_UHOST_CTRL_SPEC {}
        ///`write(|w| ..)` method takes [`udev_ctrl__r8_uhost_ctrl::W`](W) writer structure
        impl crate::Writable for UDEV_CTRL__R8_UHOST_CTRL_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets UDEV_CTRL__R8_UHOST_CTRL to value 0
        impl crate::Resettable for UDEV_CTRL__R8_UHOST_CTRL_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///UEP4_1_MOD (rw) register accessor: endpoint 4/1 mode
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`uep4_1_mod::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep4_1_mod::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@uep4_1_mod`]
    ///module
    pub type UEP4_1_MOD = crate::Reg<uep4_1_mod::UEP4_1_MOD_SPEC>;
    ///endpoint 4/1 mode
    pub mod uep4_1_mod {
        ///Register `UEP4_1_MOD` reader
        pub type R = crate::R<UEP4_1_MOD_SPEC>;
        ///Register `UEP4_1_MOD` writer
        pub type W = crate::W<UEP4_1_MOD_SPEC>;
        ///Field `UEP4_BUF_MOD` reader - buffer mode of USB endpoint 4
        pub type UEP4_BUF_MOD_R = crate::BitReader;
        ///Field `UEP4_BUF_MOD` writer - buffer mode of USB endpoint 4
        pub type UEP4_BUF_MOD_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UEP4_TX_EN` reader - enable USB endpoint 4 transmittal (IN)
        pub type UEP4_TX_EN_R = crate::BitReader;
        ///Field `UEP4_TX_EN` writer - enable USB endpoint 4 transmittal (IN)
        pub type UEP4_TX_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UEP4_RX_EN` reader - enable USB endpoint 4 receiving (OUT)
        pub type UEP4_RX_EN_R = crate::BitReader;
        ///Field `UEP4_RX_EN` writer - enable USB endpoint 4 receiving (OUT)
        pub type UEP4_RX_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UEP1_BUF_MOD` reader - buffer mode of USB endpoint 1
        pub type UEP1_BUF_MOD_R = crate::BitReader;
        ///Field `UEP1_BUF_MOD` writer - buffer mode of USB endpoint 1
        pub type UEP1_BUF_MOD_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UEP1_TX_EN` reader - enable USB endpoint 1 transmittal (IN)
        pub type UEP1_TX_EN_R = crate::BitReader;
        ///Field `UEP1_TX_EN` writer - enable USB endpoint 1 transmittal (IN)
        pub type UEP1_TX_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UEP1_RX_EN` reader - enable USB endpoint 1 receiving (OUT)
        pub type UEP1_RX_EN_R = crate::BitReader;
        ///Field `UEP1_RX_EN` writer - enable USB endpoint 1 receiving (OUT)
        pub type UEP1_RX_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - buffer mode of USB endpoint 4
            #[inline(always)]
            pub fn uep4_buf_mod(&self) -> UEP4_BUF_MOD_R {
                UEP4_BUF_MOD_R::new((self.bits & 1) != 0)
            }
            ///Bit 2 - enable USB endpoint 4 transmittal (IN)
            #[inline(always)]
            pub fn uep4_tx_en(&self) -> UEP4_TX_EN_R {
                UEP4_TX_EN_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - enable USB endpoint 4 receiving (OUT)
            #[inline(always)]
            pub fn uep4_rx_en(&self) -> UEP4_RX_EN_R {
                UEP4_RX_EN_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - buffer mode of USB endpoint 1
            #[inline(always)]
            pub fn uep1_buf_mod(&self) -> UEP1_BUF_MOD_R {
                UEP1_BUF_MOD_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 6 - enable USB endpoint 1 transmittal (IN)
            #[inline(always)]
            pub fn uep1_tx_en(&self) -> UEP1_TX_EN_R {
                UEP1_TX_EN_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - enable USB endpoint 1 receiving (OUT)
            #[inline(always)]
            pub fn uep1_rx_en(&self) -> UEP1_RX_EN_R {
                UEP1_RX_EN_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - buffer mode of USB endpoint 4
            #[inline(always)]
            #[must_use]
            pub fn uep4_buf_mod(&mut self) -> UEP4_BUF_MOD_W<UEP4_1_MOD_SPEC> {
                UEP4_BUF_MOD_W::new(self, 0)
            }
            ///Bit 2 - enable USB endpoint 4 transmittal (IN)
            #[inline(always)]
            #[must_use]
            pub fn uep4_tx_en(&mut self) -> UEP4_TX_EN_W<UEP4_1_MOD_SPEC> {
                UEP4_TX_EN_W::new(self, 2)
            }
            ///Bit 3 - enable USB endpoint 4 receiving (OUT)
            #[inline(always)]
            #[must_use]
            pub fn uep4_rx_en(&mut self) -> UEP4_RX_EN_W<UEP4_1_MOD_SPEC> {
                UEP4_RX_EN_W::new(self, 3)
            }
            ///Bit 4 - buffer mode of USB endpoint 1
            #[inline(always)]
            #[must_use]
            pub fn uep1_buf_mod(&mut self) -> UEP1_BUF_MOD_W<UEP4_1_MOD_SPEC> {
                UEP1_BUF_MOD_W::new(self, 4)
            }
            ///Bit 6 - enable USB endpoint 1 transmittal (IN)
            #[inline(always)]
            #[must_use]
            pub fn uep1_tx_en(&mut self) -> UEP1_TX_EN_W<UEP4_1_MOD_SPEC> {
                UEP1_TX_EN_W::new(self, 6)
            }
            ///Bit 7 - enable USB endpoint 1 receiving (OUT)
            #[inline(always)]
            #[must_use]
            pub fn uep1_rx_en(&mut self) -> UEP1_RX_EN_W<UEP4_1_MOD_SPEC> {
                UEP1_RX_EN_W::new(self, 7)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///endpoint 4/1 mode
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`uep4_1_mod::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep4_1_mod::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct UEP4_1_MOD_SPEC;
        impl crate::RegisterSpec for UEP4_1_MOD_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`uep4_1_mod::R`](R) reader structure
        impl crate::Readable for UEP4_1_MOD_SPEC {}
        ///`write(|w| ..)` method takes [`uep4_1_mod::W`](W) writer structure
        impl crate::Writable for UEP4_1_MOD_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets UEP4_1_MOD to value 0
        impl crate::Resettable for UEP4_1_MOD_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///UEP2_3_MOD__R8_UH_EP_MOD (rw) register accessor: endpoint 2/3 mode;USB host endpoint mode control register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`uep2_3_mod__r8_uh_ep_mod::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep2_3_mod__r8_uh_ep_mod::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@uep2_3_mod__r8_uh_ep_mod`]
    ///module
    pub type UEP2_3_MOD__R8_UH_EP_MOD =
        crate::Reg<uep2_3_mod__r8_uh_ep_mod::UEP2_3_MOD__R8_UH_EP_MOD_SPEC>;
    ///endpoint 2/3 mode;USB host endpoint mode control register
    pub mod uep2_3_mod__r8_uh_ep_mod {
        ///Register `UEP2_3_MOD__R8_UH_EP_MOD` reader
        pub type R = crate::R<UEP2_3_MOD__R8_UH_EP_MOD_SPEC>;
        ///Register `UEP2_3_MOD__R8_UH_EP_MOD` writer
        pub type W = crate::W<UEP2_3_MOD__R8_UH_EP_MOD_SPEC>;
        ///Field `UEP2_BUF_MOD__RB_UH_PORT_EN` reader - buffer mode of USB endpoint 2;endpoint receive the data buffer mode control
        pub type UEP2_BUF_MOD__RB_UH_PORT_EN_R = crate::BitReader;
        ///Field `UEP2_BUF_MOD__RB_UH_PORT_EN` writer - buffer mode of USB endpoint 2;endpoint receive the data buffer mode control
        pub type UEP2_BUF_MOD__RB_UH_PORT_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UEP2_TX_EN__RB_UH_LOW_SPEED` reader - enable USB endpoint 2 transmittal (IN);host endpoint receive enable
        pub type UEP2_TX_EN__RB_UH_LOW_SPEED_R = crate::BitReader;
        ///Field `UEP2_TX_EN__RB_UH_LOW_SPEED` writer - enable USB endpoint 2 transmittal (IN);host endpoint receive enable
        pub type UEP2_TX_EN__RB_UH_LOW_SPEED_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UEP2_RX_EN` reader - enable USB endpoint 2 receiving (OUT)
        pub type UEP2_RX_EN_R = crate::BitReader;
        ///Field `UEP2_RX_EN` writer - enable USB endpoint 2 receiving (OUT)
        pub type UEP2_RX_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UEP3_BUF_MOD__RB_UH_DM_PIN` reader - buffer mode of USB endpoint 3;endpoint send the data buffer mode control
        pub type UEP3_BUF_MOD__RB_UH_DM_PIN_R = crate::BitReader;
        ///Field `UEP3_BUF_MOD__RB_UH_DM_PIN` writer - buffer mode of USB endpoint 3;endpoint send the data buffer mode control
        pub type UEP3_BUF_MOD__RB_UH_DM_PIN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UEP3_TX_EN__RB_UH_EP_TX_EN` reader - enable USB endpoint 3 transmittal (IN);endpoint send enable
        pub type UEP3_TX_EN__RB_UH_EP_TX_EN_R = crate::BitReader;
        ///Field `UEP3_TX_EN__RB_UH_EP_TX_EN` writer - enable USB endpoint 3 transmittal (IN);endpoint send enable
        pub type UEP3_TX_EN__RB_UH_EP_TX_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UEP3_RX_EN` reader - enable USB endpoint 3 receiving (OUT)
        pub type UEP3_RX_EN_R = crate::BitReader;
        ///Field `UEP3_RX_EN` writer - enable USB endpoint 3 receiving (OUT)
        pub type UEP3_RX_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - buffer mode of USB endpoint 2;endpoint receive the data buffer mode control
            #[inline(always)]
            pub fn uep2_buf_mod__rb_uh_port_en(&self) -> UEP2_BUF_MOD__RB_UH_PORT_EN_R {
                UEP2_BUF_MOD__RB_UH_PORT_EN_R::new((self.bits & 1) != 0)
            }
            ///Bit 2 - enable USB endpoint 2 transmittal (IN);host endpoint receive enable
            #[inline(always)]
            pub fn uep2_tx_en__rb_uh_low_speed(&self) -> UEP2_TX_EN__RB_UH_LOW_SPEED_R {
                UEP2_TX_EN__RB_UH_LOW_SPEED_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - enable USB endpoint 2 receiving (OUT)
            #[inline(always)]
            pub fn uep2_rx_en(&self) -> UEP2_RX_EN_R {
                UEP2_RX_EN_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - buffer mode of USB endpoint 3;endpoint send the data buffer mode control
            #[inline(always)]
            pub fn uep3_buf_mod__rb_uh_dm_pin(&self) -> UEP3_BUF_MOD__RB_UH_DM_PIN_R {
                UEP3_BUF_MOD__RB_UH_DM_PIN_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 6 - enable USB endpoint 3 transmittal (IN);endpoint send enable
            #[inline(always)]
            pub fn uep3_tx_en__rb_uh_ep_tx_en(&self) -> UEP3_TX_EN__RB_UH_EP_TX_EN_R {
                UEP3_TX_EN__RB_UH_EP_TX_EN_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - enable USB endpoint 3 receiving (OUT)
            #[inline(always)]
            pub fn uep3_rx_en(&self) -> UEP3_RX_EN_R {
                UEP3_RX_EN_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - buffer mode of USB endpoint 2;endpoint receive the data buffer mode control
            #[inline(always)]
            #[must_use]
            pub fn uep2_buf_mod__rb_uh_port_en(
                &mut self,
            ) -> UEP2_BUF_MOD__RB_UH_PORT_EN_W<UEP2_3_MOD__R8_UH_EP_MOD_SPEC> {
                UEP2_BUF_MOD__RB_UH_PORT_EN_W::new(self, 0)
            }
            ///Bit 2 - enable USB endpoint 2 transmittal (IN);host endpoint receive enable
            #[inline(always)]
            #[must_use]
            pub fn uep2_tx_en__rb_uh_low_speed(
                &mut self,
            ) -> UEP2_TX_EN__RB_UH_LOW_SPEED_W<UEP2_3_MOD__R8_UH_EP_MOD_SPEC> {
                UEP2_TX_EN__RB_UH_LOW_SPEED_W::new(self, 2)
            }
            ///Bit 3 - enable USB endpoint 2 receiving (OUT)
            #[inline(always)]
            #[must_use]
            pub fn uep2_rx_en(&mut self) -> UEP2_RX_EN_W<UEP2_3_MOD__R8_UH_EP_MOD_SPEC> {
                UEP2_RX_EN_W::new(self, 3)
            }
            ///Bit 4 - buffer mode of USB endpoint 3;endpoint send the data buffer mode control
            #[inline(always)]
            #[must_use]
            pub fn uep3_buf_mod__rb_uh_dm_pin(
                &mut self,
            ) -> UEP3_BUF_MOD__RB_UH_DM_PIN_W<UEP2_3_MOD__R8_UH_EP_MOD_SPEC> {
                UEP3_BUF_MOD__RB_UH_DM_PIN_W::new(self, 4)
            }
            ///Bit 6 - enable USB endpoint 3 transmittal (IN);endpoint send enable
            #[inline(always)]
            #[must_use]
            pub fn uep3_tx_en__rb_uh_ep_tx_en(
                &mut self,
            ) -> UEP3_TX_EN__RB_UH_EP_TX_EN_W<UEP2_3_MOD__R8_UH_EP_MOD_SPEC> {
                UEP3_TX_EN__RB_UH_EP_TX_EN_W::new(self, 6)
            }
            ///Bit 7 - enable USB endpoint 3 receiving (OUT)
            #[inline(always)]
            #[must_use]
            pub fn uep3_rx_en(&mut self) -> UEP3_RX_EN_W<UEP2_3_MOD__R8_UH_EP_MOD_SPEC> {
                UEP3_RX_EN_W::new(self, 7)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///endpoint 2/3 mode;USB host endpoint mode control register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`uep2_3_mod__r8_uh_ep_mod::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep2_3_mod__r8_uh_ep_mod::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct UEP2_3_MOD__R8_UH_EP_MOD_SPEC;
        impl crate::RegisterSpec for UEP2_3_MOD__R8_UH_EP_MOD_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`uep2_3_mod__r8_uh_ep_mod::R`](R) reader structure
        impl crate::Readable for UEP2_3_MOD__R8_UH_EP_MOD_SPEC {}
        ///`write(|w| ..)` method takes [`uep2_3_mod__r8_uh_ep_mod::W`](W) writer structure
        impl crate::Writable for UEP2_3_MOD__R8_UH_EP_MOD_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets UEP2_3_MOD__R8_UH_EP_MOD to value 0
        impl crate::Resettable for UEP2_3_MOD__R8_UH_EP_MOD_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///UEP5_6_MOD (rw) register accessor: endpoint 5/6 mode
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`uep5_6_mod::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep5_6_mod::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@uep5_6_mod`]
    ///module
    pub type UEP5_6_MOD = crate::Reg<uep5_6_mod::UEP5_6_MOD_SPEC>;
    ///endpoint 5/6 mode
    pub mod uep5_6_mod {
        ///Register `UEP5_6_MOD` reader
        pub type R = crate::R<UEP5_6_MOD_SPEC>;
        ///Register `UEP5_6_MOD` writer
        pub type W = crate::W<UEP5_6_MOD_SPEC>;
        ///Field `UEP5_BUF_MOD` reader - buffer mode of USB endpoint 5
        pub type UEP5_BUF_MOD_R = crate::BitReader;
        ///Field `UEP5_BUF_MOD` writer - buffer mode of USB endpoint 5
        pub type UEP5_BUF_MOD_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UEP5_TX_EN` reader - enable USB endpoint 5 transmittal (IN)
        pub type UEP5_TX_EN_R = crate::BitReader;
        ///Field `UEP5_TX_EN` writer - enable USB endpoint 5 transmittal (IN)
        pub type UEP5_TX_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UEP5_RX_EN` reader - enable USB endpoint 5 receiving (OUT)
        pub type UEP5_RX_EN_R = crate::BitReader;
        ///Field `UEP5_RX_EN` writer - enable USB endpoint 5 receiving (OUT)
        pub type UEP5_RX_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UEP6_BUF_MOD` reader - buffer mode of USB endpoint 6
        pub type UEP6_BUF_MOD_R = crate::BitReader;
        ///Field `UEP6_BUF_MOD` writer - buffer mode of USB endpoint 6
        pub type UEP6_BUF_MOD_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UEP6_TX_EN` reader - enable USB endpoint 6 transmittal (IN)
        pub type UEP6_TX_EN_R = crate::BitReader;
        ///Field `UEP6_TX_EN` writer - enable USB endpoint 6 transmittal (IN)
        pub type UEP6_TX_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UEP6_RX_EN` reader - enable USB endpoint 6 receiving (OUT)
        pub type UEP6_RX_EN_R = crate::BitReader;
        ///Field `UEP6_RX_EN` writer - enable USB endpoint 6 receiving (OUT)
        pub type UEP6_RX_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - buffer mode of USB endpoint 5
            #[inline(always)]
            pub fn uep5_buf_mod(&self) -> UEP5_BUF_MOD_R {
                UEP5_BUF_MOD_R::new((self.bits & 1) != 0)
            }
            ///Bit 2 - enable USB endpoint 5 transmittal (IN)
            #[inline(always)]
            pub fn uep5_tx_en(&self) -> UEP5_TX_EN_R {
                UEP5_TX_EN_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - enable USB endpoint 5 receiving (OUT)
            #[inline(always)]
            pub fn uep5_rx_en(&self) -> UEP5_RX_EN_R {
                UEP5_RX_EN_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - buffer mode of USB endpoint 6
            #[inline(always)]
            pub fn uep6_buf_mod(&self) -> UEP6_BUF_MOD_R {
                UEP6_BUF_MOD_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 6 - enable USB endpoint 6 transmittal (IN)
            #[inline(always)]
            pub fn uep6_tx_en(&self) -> UEP6_TX_EN_R {
                UEP6_TX_EN_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - enable USB endpoint 6 receiving (OUT)
            #[inline(always)]
            pub fn uep6_rx_en(&self) -> UEP6_RX_EN_R {
                UEP6_RX_EN_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - buffer mode of USB endpoint 5
            #[inline(always)]
            #[must_use]
            pub fn uep5_buf_mod(&mut self) -> UEP5_BUF_MOD_W<UEP5_6_MOD_SPEC> {
                UEP5_BUF_MOD_W::new(self, 0)
            }
            ///Bit 2 - enable USB endpoint 5 transmittal (IN)
            #[inline(always)]
            #[must_use]
            pub fn uep5_tx_en(&mut self) -> UEP5_TX_EN_W<UEP5_6_MOD_SPEC> {
                UEP5_TX_EN_W::new(self, 2)
            }
            ///Bit 3 - enable USB endpoint 5 receiving (OUT)
            #[inline(always)]
            #[must_use]
            pub fn uep5_rx_en(&mut self) -> UEP5_RX_EN_W<UEP5_6_MOD_SPEC> {
                UEP5_RX_EN_W::new(self, 3)
            }
            ///Bit 4 - buffer mode of USB endpoint 6
            #[inline(always)]
            #[must_use]
            pub fn uep6_buf_mod(&mut self) -> UEP6_BUF_MOD_W<UEP5_6_MOD_SPEC> {
                UEP6_BUF_MOD_W::new(self, 4)
            }
            ///Bit 6 - enable USB endpoint 6 transmittal (IN)
            #[inline(always)]
            #[must_use]
            pub fn uep6_tx_en(&mut self) -> UEP6_TX_EN_W<UEP5_6_MOD_SPEC> {
                UEP6_TX_EN_W::new(self, 6)
            }
            ///Bit 7 - enable USB endpoint 6 receiving (OUT)
            #[inline(always)]
            #[must_use]
            pub fn uep6_rx_en(&mut self) -> UEP6_RX_EN_W<UEP5_6_MOD_SPEC> {
                UEP6_RX_EN_W::new(self, 7)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///endpoint 5/6 mode
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`uep5_6_mod::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep5_6_mod::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct UEP5_6_MOD_SPEC;
        impl crate::RegisterSpec for UEP5_6_MOD_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`uep5_6_mod::R`](R) reader structure
        impl crate::Readable for UEP5_6_MOD_SPEC {}
        ///`write(|w| ..)` method takes [`uep5_6_mod::W`](W) writer structure
        impl crate::Writable for UEP5_6_MOD_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets UEP5_6_MOD to value 0
        impl crate::Resettable for UEP5_6_MOD_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///UEP7_MOD (rw) register accessor: endpoint 7 mode
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`uep7_mod::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep7_mod::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@uep7_mod`]
    ///module
    pub type UEP7_MOD = crate::Reg<uep7_mod::UEP7_MOD_SPEC>;
    ///endpoint 7 mode
    pub mod uep7_mod {
        ///Register `UEP7_MOD` reader
        pub type R = crate::R<UEP7_MOD_SPEC>;
        ///Register `UEP7_MOD` writer
        pub type W = crate::W<UEP7_MOD_SPEC>;
        ///Field `UEP7_BUF_MOD` reader - buffer mode of USB endpoint 7
        pub type UEP7_BUF_MOD_R = crate::BitReader;
        ///Field `UEP7_BUF_MOD` writer - buffer mode of USB endpoint 7
        pub type UEP7_BUF_MOD_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UEP7_TX_EN` reader - enable USB endpoint 7 transmittal (IN)
        pub type UEP7_TX_EN_R = crate::BitReader;
        ///Field `UEP7_TX_EN` writer - enable USB endpoint 7 transmittal (IN)
        pub type UEP7_TX_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UEP7_RX_EN` reader - enable USB endpoint 7 receiving (OUT)
        pub type UEP7_RX_EN_R = crate::BitReader;
        ///Field `UEP7_RX_EN` writer - enable USB endpoint 7 receiving (OUT)
        pub type UEP7_RX_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - buffer mode of USB endpoint 7
            #[inline(always)]
            pub fn uep7_buf_mod(&self) -> UEP7_BUF_MOD_R {
                UEP7_BUF_MOD_R::new((self.bits & 1) != 0)
            }
            ///Bit 2 - enable USB endpoint 7 transmittal (IN)
            #[inline(always)]
            pub fn uep7_tx_en(&self) -> UEP7_TX_EN_R {
                UEP7_TX_EN_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - enable USB endpoint 7 receiving (OUT)
            #[inline(always)]
            pub fn uep7_rx_en(&self) -> UEP7_RX_EN_R {
                UEP7_RX_EN_R::new(((self.bits >> 3) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - buffer mode of USB endpoint 7
            #[inline(always)]
            #[must_use]
            pub fn uep7_buf_mod(&mut self) -> UEP7_BUF_MOD_W<UEP7_MOD_SPEC> {
                UEP7_BUF_MOD_W::new(self, 0)
            }
            ///Bit 2 - enable USB endpoint 7 transmittal (IN)
            #[inline(always)]
            #[must_use]
            pub fn uep7_tx_en(&mut self) -> UEP7_TX_EN_W<UEP7_MOD_SPEC> {
                UEP7_TX_EN_W::new(self, 2)
            }
            ///Bit 3 - enable USB endpoint 7 receiving (OUT)
            #[inline(always)]
            #[must_use]
            pub fn uep7_rx_en(&mut self) -> UEP7_RX_EN_W<UEP7_MOD_SPEC> {
                UEP7_RX_EN_W::new(self, 3)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///endpoint 7 mode
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`uep7_mod::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep7_mod::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct UEP7_MOD_SPEC;
        impl crate::RegisterSpec for UEP7_MOD_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`uep7_mod::R`](R) reader structure
        impl crate::Readable for UEP7_MOD_SPEC {}
        ///`write(|w| ..)` method takes [`uep7_mod::W`](W) writer structure
        impl crate::Writable for UEP7_MOD_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets UEP7_MOD to value 0
        impl crate::Resettable for UEP7_MOD_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///UEP0_DMA (rw) register accessor: endpoint 0 DMA buffer address
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`uep0_dma::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep0_dma::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@uep0_dma`]
    ///module
    pub type UEP0_DMA = crate::Reg<uep0_dma::UEP0_DMA_SPEC>;
    ///endpoint 0 DMA buffer address
    pub mod uep0_dma {
        ///Register `UEP0_DMA` reader
        pub type R = crate::R<UEP0_DMA_SPEC>;
        ///Register `UEP0_DMA` writer
        pub type W = crate::W<UEP0_DMA_SPEC>;
        ///Field `UEP0_DMA` reader - endpoint buffer start address
        pub type UEP0_DMA_R = crate::FieldReader<u16>;
        ///Field `UEP0_DMA` writer - endpoint buffer start address
        pub type UEP0_DMA_W<'a, REG> = crate::FieldWriter<'a, REG, 15, u16>;
        impl R {
            ///Bits 0:14 - endpoint buffer start address
            #[inline(always)]
            pub fn uep0_dma(&self) -> UEP0_DMA_R {
                UEP0_DMA_R::new((self.bits & 0x7fff) as u16)
            }
        }
        impl W {
            ///Bits 0:14 - endpoint buffer start address
            #[inline(always)]
            #[must_use]
            pub fn uep0_dma(&mut self) -> UEP0_DMA_W<UEP0_DMA_SPEC> {
                UEP0_DMA_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///endpoint 0 DMA buffer address
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`uep0_dma::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep0_dma::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct UEP0_DMA_SPEC;
        impl crate::RegisterSpec for UEP0_DMA_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`uep0_dma::R`](R) reader structure
        impl crate::Readable for UEP0_DMA_SPEC {}
        ///`write(|w| ..)` method takes [`uep0_dma::W`](W) writer structure
        impl crate::Writable for UEP0_DMA_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets UEP0_DMA to value 0
        impl crate::Resettable for UEP0_DMA_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///UEP1_DMA (rw) register accessor: endpoint 1 DMA buffer address
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`uep1_dma::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep1_dma::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@uep1_dma`]
    ///module
    pub type UEP1_DMA = crate::Reg<uep1_dma::UEP1_DMA_SPEC>;
    ///endpoint 1 DMA buffer address
    pub mod uep1_dma {
        ///Register `UEP1_DMA` reader
        pub type R = crate::R<UEP1_DMA_SPEC>;
        ///Register `UEP1_DMA` writer
        pub type W = crate::W<UEP1_DMA_SPEC>;
        ///Field `UEP1_DMA` reader - endpoint buffer start address
        pub type UEP1_DMA_R = crate::FieldReader<u16>;
        ///Field `UEP1_DMA` writer - endpoint buffer start address
        pub type UEP1_DMA_W<'a, REG> = crate::FieldWriter<'a, REG, 15, u16>;
        impl R {
            ///Bits 0:14 - endpoint buffer start address
            #[inline(always)]
            pub fn uep1_dma(&self) -> UEP1_DMA_R {
                UEP1_DMA_R::new((self.bits & 0x7fff) as u16)
            }
        }
        impl W {
            ///Bits 0:14 - endpoint buffer start address
            #[inline(always)]
            #[must_use]
            pub fn uep1_dma(&mut self) -> UEP1_DMA_W<UEP1_DMA_SPEC> {
                UEP1_DMA_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///endpoint 1 DMA buffer address
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`uep1_dma::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep1_dma::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct UEP1_DMA_SPEC;
        impl crate::RegisterSpec for UEP1_DMA_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`uep1_dma::R`](R) reader structure
        impl crate::Readable for UEP1_DMA_SPEC {}
        ///`write(|w| ..)` method takes [`uep1_dma::W`](W) writer structure
        impl crate::Writable for UEP1_DMA_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets UEP1_DMA to value 0
        impl crate::Resettable for UEP1_DMA_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///UEP2_DMA__R16_UH_RX_DMA (rw) register accessor: endpoint 2 DMA buffer address
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`uep2_dma__r16_uh_rx_dma::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep2_dma__r16_uh_rx_dma::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@uep2_dma__r16_uh_rx_dma`]
    ///module
    pub type UEP2_DMA__R16_UH_RX_DMA =
        crate::Reg<uep2_dma__r16_uh_rx_dma::UEP2_DMA__R16_UH_RX_DMA_SPEC>;
    ///endpoint 2 DMA buffer address
    pub mod uep2_dma__r16_uh_rx_dma {
        ///Register `UEP2_DMA__R16_UH_RX_DMA` reader
        pub type R = crate::R<UEP2_DMA__R16_UH_RX_DMA_SPEC>;
        ///Register `UEP2_DMA__R16_UH_RX_DMA` writer
        pub type W = crate::W<UEP2_DMA__R16_UH_RX_DMA_SPEC>;
        ///Field `UEP2_DMA__R16_UH_RX_DMA` reader - endpoint buffer start address
        pub type UEP2_DMA__R16_UH_RX_DMA_R = crate::FieldReader<u16>;
        ///Field `UEP2_DMA__R16_UH_RX_DMA` writer - endpoint buffer start address
        pub type UEP2_DMA__R16_UH_RX_DMA_W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            ///Bits 0:15 - endpoint buffer start address
            #[inline(always)]
            pub fn uep2_dma__r16_uh_rx_dma(&self) -> UEP2_DMA__R16_UH_RX_DMA_R {
                UEP2_DMA__R16_UH_RX_DMA_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            ///Bits 0:15 - endpoint buffer start address
            #[inline(always)]
            #[must_use]
            pub fn uep2_dma__r16_uh_rx_dma(
                &mut self,
            ) -> UEP2_DMA__R16_UH_RX_DMA_W<UEP2_DMA__R16_UH_RX_DMA_SPEC> {
                UEP2_DMA__R16_UH_RX_DMA_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///endpoint 2 DMA buffer address
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`uep2_dma__r16_uh_rx_dma::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep2_dma__r16_uh_rx_dma::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct UEP2_DMA__R16_UH_RX_DMA_SPEC;
        impl crate::RegisterSpec for UEP2_DMA__R16_UH_RX_DMA_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`uep2_dma__r16_uh_rx_dma::R`](R) reader structure
        impl crate::Readable for UEP2_DMA__R16_UH_RX_DMA_SPEC {}
        ///`write(|w| ..)` method takes [`uep2_dma__r16_uh_rx_dma::W`](W) writer structure
        impl crate::Writable for UEP2_DMA__R16_UH_RX_DMA_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets UEP2_DMA__R16_UH_RX_DMA to value 0
        impl crate::Resettable for UEP2_DMA__R16_UH_RX_DMA_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///UEP3_DMA__R16_UH_TX_DMA (rw) register accessor: endpoint 3 DMA buffer address
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`uep3_dma__r16_uh_tx_dma::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep3_dma__r16_uh_tx_dma::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@uep3_dma__r16_uh_tx_dma`]
    ///module
    pub type UEP3_DMA__R16_UH_TX_DMA =
        crate::Reg<uep3_dma__r16_uh_tx_dma::UEP3_DMA__R16_UH_TX_DMA_SPEC>;
    ///endpoint 3 DMA buffer address
    pub mod uep3_dma__r16_uh_tx_dma {
        ///Register `UEP3_DMA__R16_UH_TX_DMA` reader
        pub type R = crate::R<UEP3_DMA__R16_UH_TX_DMA_SPEC>;
        ///Register `UEP3_DMA__R16_UH_TX_DMA` writer
        pub type W = crate::W<UEP3_DMA__R16_UH_TX_DMA_SPEC>;
        ///Field `UEP3_DMA__R16_UH_TX_DMA` reader - endpoint buffer start address
        pub type UEP3_DMA__R16_UH_TX_DMA_R = crate::FieldReader<u16>;
        ///Field `UEP3_DMA__R16_UH_TX_DMA` writer - endpoint buffer start address
        pub type UEP3_DMA__R16_UH_TX_DMA_W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            ///Bits 0:15 - endpoint buffer start address
            #[inline(always)]
            pub fn uep3_dma__r16_uh_tx_dma(&self) -> UEP3_DMA__R16_UH_TX_DMA_R {
                UEP3_DMA__R16_UH_TX_DMA_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            ///Bits 0:15 - endpoint buffer start address
            #[inline(always)]
            #[must_use]
            pub fn uep3_dma__r16_uh_tx_dma(
                &mut self,
            ) -> UEP3_DMA__R16_UH_TX_DMA_W<UEP3_DMA__R16_UH_TX_DMA_SPEC> {
                UEP3_DMA__R16_UH_TX_DMA_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///endpoint 3 DMA buffer address
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`uep3_dma__r16_uh_tx_dma::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep3_dma__r16_uh_tx_dma::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct UEP3_DMA__R16_UH_TX_DMA_SPEC;
        impl crate::RegisterSpec for UEP3_DMA__R16_UH_TX_DMA_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`uep3_dma__r16_uh_tx_dma::R`](R) reader structure
        impl crate::Readable for UEP3_DMA__R16_UH_TX_DMA_SPEC {}
        ///`write(|w| ..)` method takes [`uep3_dma__r16_uh_tx_dma::W`](W) writer structure
        impl crate::Writable for UEP3_DMA__R16_UH_TX_DMA_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets UEP3_DMA__R16_UH_TX_DMA to value 0
        impl crate::Resettable for UEP3_DMA__R16_UH_TX_DMA_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///UEP4_DMA (rw) register accessor: endpoint 4 DMA buffer address
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`uep4_dma::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep4_dma::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@uep4_dma`]
    ///module
    pub type UEP4_DMA = crate::Reg<uep4_dma::UEP4_DMA_SPEC>;
    ///endpoint 4 DMA buffer address
    pub mod uep4_dma {
        ///Register `UEP4_DMA` reader
        pub type R = crate::R<UEP4_DMA_SPEC>;
        ///Register `UEP4_DMA` writer
        pub type W = crate::W<UEP4_DMA_SPEC>;
        ///Field `UEP4_DMA` reader - endpoint buffer start address
        pub type UEP4_DMA_R = crate::FieldReader<u16>;
        ///Field `UEP4_DMA` writer - endpoint buffer start address
        pub type UEP4_DMA_W<'a, REG> = crate::FieldWriter<'a, REG, 15, u16>;
        impl R {
            ///Bits 0:14 - endpoint buffer start address
            #[inline(always)]
            pub fn uep4_dma(&self) -> UEP4_DMA_R {
                UEP4_DMA_R::new((self.bits & 0x7fff) as u16)
            }
        }
        impl W {
            ///Bits 0:14 - endpoint buffer start address
            #[inline(always)]
            #[must_use]
            pub fn uep4_dma(&mut self) -> UEP4_DMA_W<UEP4_DMA_SPEC> {
                UEP4_DMA_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///endpoint 4 DMA buffer address
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`uep4_dma::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep4_dma::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct UEP4_DMA_SPEC;
        impl crate::RegisterSpec for UEP4_DMA_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`uep4_dma::R`](R) reader structure
        impl crate::Readable for UEP4_DMA_SPEC {}
        ///`write(|w| ..)` method takes [`uep4_dma::W`](W) writer structure
        impl crate::Writable for UEP4_DMA_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets UEP4_DMA to value 0
        impl crate::Resettable for UEP4_DMA_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///UEP5_DMA (rw) register accessor: endpoint 5 DMA buffer address
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`uep5_dma::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep5_dma::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@uep5_dma`]
    ///module
    pub type UEP5_DMA = crate::Reg<uep5_dma::UEP5_DMA_SPEC>;
    ///endpoint 5 DMA buffer address
    pub mod uep5_dma {
        ///Register `UEP5_DMA` reader
        pub type R = crate::R<UEP5_DMA_SPEC>;
        ///Register `UEP5_DMA` writer
        pub type W = crate::W<UEP5_DMA_SPEC>;
        ///Field `UEP5_DMA` reader - endpoint buffer start address
        pub type UEP5_DMA_R = crate::FieldReader<u16>;
        ///Field `UEP5_DMA` writer - endpoint buffer start address
        pub type UEP5_DMA_W<'a, REG> = crate::FieldWriter<'a, REG, 15, u16>;
        impl R {
            ///Bits 0:14 - endpoint buffer start address
            #[inline(always)]
            pub fn uep5_dma(&self) -> UEP5_DMA_R {
                UEP5_DMA_R::new((self.bits & 0x7fff) as u16)
            }
        }
        impl W {
            ///Bits 0:14 - endpoint buffer start address
            #[inline(always)]
            #[must_use]
            pub fn uep5_dma(&mut self) -> UEP5_DMA_W<UEP5_DMA_SPEC> {
                UEP5_DMA_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///endpoint 5 DMA buffer address
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`uep5_dma::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep5_dma::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct UEP5_DMA_SPEC;
        impl crate::RegisterSpec for UEP5_DMA_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`uep5_dma::R`](R) reader structure
        impl crate::Readable for UEP5_DMA_SPEC {}
        ///`write(|w| ..)` method takes [`uep5_dma::W`](W) writer structure
        impl crate::Writable for UEP5_DMA_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets UEP5_DMA to value 0
        impl crate::Resettable for UEP5_DMA_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///UEP6_DMA (rw) register accessor: endpoint 6 DMA buffer address
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`uep6_dma::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep6_dma::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@uep6_dma`]
    ///module
    pub type UEP6_DMA = crate::Reg<uep6_dma::UEP6_DMA_SPEC>;
    ///endpoint 6 DMA buffer address
    pub mod uep6_dma {
        ///Register `UEP6_DMA` reader
        pub type R = crate::R<UEP6_DMA_SPEC>;
        ///Register `UEP6_DMA` writer
        pub type W = crate::W<UEP6_DMA_SPEC>;
        ///Field `UEP6_DMA` reader - endpoint buffer start address
        pub type UEP6_DMA_R = crate::FieldReader<u16>;
        ///Field `UEP6_DMA` writer - endpoint buffer start address
        pub type UEP6_DMA_W<'a, REG> = crate::FieldWriter<'a, REG, 15, u16>;
        impl R {
            ///Bits 0:14 - endpoint buffer start address
            #[inline(always)]
            pub fn uep6_dma(&self) -> UEP6_DMA_R {
                UEP6_DMA_R::new((self.bits & 0x7fff) as u16)
            }
        }
        impl W {
            ///Bits 0:14 - endpoint buffer start address
            #[inline(always)]
            #[must_use]
            pub fn uep6_dma(&mut self) -> UEP6_DMA_W<UEP6_DMA_SPEC> {
                UEP6_DMA_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///endpoint 6 DMA buffer address
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`uep6_dma::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep6_dma::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct UEP6_DMA_SPEC;
        impl crate::RegisterSpec for UEP6_DMA_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`uep6_dma::R`](R) reader structure
        impl crate::Readable for UEP6_DMA_SPEC {}
        ///`write(|w| ..)` method takes [`uep6_dma::W`](W) writer structure
        impl crate::Writable for UEP6_DMA_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets UEP6_DMA to value 0
        impl crate::Resettable for UEP6_DMA_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///UEP7_DMA (rw) register accessor: endpoint 7 DMA buffer address
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`uep7_dma::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep7_dma::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@uep7_dma`]
    ///module
    pub type UEP7_DMA = crate::Reg<uep7_dma::UEP7_DMA_SPEC>;
    ///endpoint 7 DMA buffer address
    pub mod uep7_dma {
        ///Register `UEP7_DMA` reader
        pub type R = crate::R<UEP7_DMA_SPEC>;
        ///Register `UEP7_DMA` writer
        pub type W = crate::W<UEP7_DMA_SPEC>;
        ///Field `UEP7_DMA` reader - endpoint buffer start address
        pub type UEP7_DMA_R = crate::FieldReader<u16>;
        ///Field `UEP7_DMA` writer - endpoint buffer start address
        pub type UEP7_DMA_W<'a, REG> = crate::FieldWriter<'a, REG, 15, u16>;
        impl R {
            ///Bits 0:14 - endpoint buffer start address
            #[inline(always)]
            pub fn uep7_dma(&self) -> UEP7_DMA_R {
                UEP7_DMA_R::new((self.bits & 0x7fff) as u16)
            }
        }
        impl W {
            ///Bits 0:14 - endpoint buffer start address
            #[inline(always)]
            #[must_use]
            pub fn uep7_dma(&mut self) -> UEP7_DMA_W<UEP7_DMA_SPEC> {
                UEP7_DMA_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///endpoint 7 DMA buffer address
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`uep7_dma::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep7_dma::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct UEP7_DMA_SPEC;
        impl crate::RegisterSpec for UEP7_DMA_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`uep7_dma::R`](R) reader structure
        impl crate::Readable for UEP7_DMA_SPEC {}
        ///`write(|w| ..)` method takes [`uep7_dma::W`](W) writer structure
        impl crate::Writable for UEP7_DMA_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets UEP7_DMA to value 0
        impl crate::Resettable for UEP7_DMA_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///UEP0_T_LEN (rw) register accessor: endpoint send length register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`uep0_t_len::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep0_t_len::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@uep0_t_len`]
    ///module
    pub type UEP0_T_LEN = crate::Reg<uep0_t_len::UEP0_T_LEN_SPEC>;
    ///endpoint send length register
    pub mod uep0_t_len {
        ///Register `UEP0_T_LEN` reader
        pub type R = crate::R<UEP0_T_LEN_SPEC>;
        ///Register `UEP0_T_LEN` writer
        pub type W = crate::W<UEP0_T_LEN_SPEC>;
        ///Field `UEP0_T_LEN` reader - set USB endpoint send data bytes
        pub type UEP0_T_LEN_R = crate::FieldReader;
        ///Field `UEP0_T_LEN` writer - set USB endpoint send data bytes
        pub type UEP0_T_LEN_W<'a, REG> = crate::FieldWriter<'a, REG, 7>;
        impl R {
            ///Bits 0:6 - set USB endpoint send data bytes
            #[inline(always)]
            pub fn uep0_t_len(&self) -> UEP0_T_LEN_R {
                UEP0_T_LEN_R::new((self.bits & 0x7f) as u8)
            }
        }
        impl W {
            ///Bits 0:6 - set USB endpoint send data bytes
            #[inline(always)]
            #[must_use]
            pub fn uep0_t_len(&mut self) -> UEP0_T_LEN_W<UEP0_T_LEN_SPEC> {
                UEP0_T_LEN_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///endpoint send length register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`uep0_t_len::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep0_t_len::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct UEP0_T_LEN_SPEC;
        impl crate::RegisterSpec for UEP0_T_LEN_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`uep0_t_len::R`](R) reader structure
        impl crate::Readable for UEP0_T_LEN_SPEC {}
        ///`write(|w| ..)` method takes [`uep0_t_len::W`](W) writer structure
        impl crate::Writable for UEP0_T_LEN_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets UEP0_T_LEN to value 0
        impl crate::Resettable for UEP0_T_LEN_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///UEP1_T_LEN (rw) register accessor: endpoint send length register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`uep1_t_len::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep1_t_len::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@uep1_t_len`]
    ///module
    pub type UEP1_T_LEN = crate::Reg<uep1_t_len::UEP1_T_LEN_SPEC>;
    ///endpoint send length register
    pub mod uep1_t_len {
        ///Register `UEP1_T_LEN` reader
        pub type R = crate::R<UEP1_T_LEN_SPEC>;
        ///Register `UEP1_T_LEN` writer
        pub type W = crate::W<UEP1_T_LEN_SPEC>;
        ///Field `UEP1_T_LEN` reader - set USB endpoint send data bytes
        pub type UEP1_T_LEN_R = crate::FieldReader;
        ///Field `UEP1_T_LEN` writer - set USB endpoint send data bytes
        pub type UEP1_T_LEN_W<'a, REG> = crate::FieldWriter<'a, REG, 7>;
        impl R {
            ///Bits 0:6 - set USB endpoint send data bytes
            #[inline(always)]
            pub fn uep1_t_len(&self) -> UEP1_T_LEN_R {
                UEP1_T_LEN_R::new((self.bits & 0x7f) as u8)
            }
        }
        impl W {
            ///Bits 0:6 - set USB endpoint send data bytes
            #[inline(always)]
            #[must_use]
            pub fn uep1_t_len(&mut self) -> UEP1_T_LEN_W<UEP1_T_LEN_SPEC> {
                UEP1_T_LEN_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///endpoint send length register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`uep1_t_len::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep1_t_len::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct UEP1_T_LEN_SPEC;
        impl crate::RegisterSpec for UEP1_T_LEN_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`uep1_t_len::R`](R) reader structure
        impl crate::Readable for UEP1_T_LEN_SPEC {}
        ///`write(|w| ..)` method takes [`uep1_t_len::W`](W) writer structure
        impl crate::Writable for UEP1_T_LEN_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets UEP1_T_LEN to value 0
        impl crate::Resettable for UEP1_T_LEN_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///UEP2_T_LEN (rw) register accessor: endpoint send length register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`uep2_t_len::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep2_t_len::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@uep2_t_len`]
    ///module
    pub type UEP2_T_LEN = crate::Reg<uep2_t_len::UEP2_T_LEN_SPEC>;
    ///endpoint send length register
    pub mod uep2_t_len {
        ///Register `UEP2_T_LEN` reader
        pub type R = crate::R<UEP2_T_LEN_SPEC>;
        ///Register `UEP2_T_LEN` writer
        pub type W = crate::W<UEP2_T_LEN_SPEC>;
        ///Field `UEP1_T_LEN__MASK_UH_ENDP` reader - set the endpoint number of the target device; set USB endpoint send data bytes
        pub type UEP1_T_LEN__MASK_UH_ENDP_R = crate::FieldReader;
        ///Field `UEP1_T_LEN__MASK_UH_ENDP` writer - set the endpoint number of the target device; set USB endpoint send data bytes
        pub type UEP1_T_LEN__MASK_UH_ENDP_W<'a, REG> = crate::FieldWriter<'a, REG, 4>;
        ///Field `UEP1_T_LEN__MASK_UH_TOKEN` reader - set USB endpoint send data bytes;set the token PID packet flag
        pub type UEP1_T_LEN__MASK_UH_TOKEN_R = crate::FieldReader;
        ///Field `UEP1_T_LEN__MASK_UH_TOKEN` writer - set USB endpoint send data bytes;set the token PID packet flag
        pub type UEP1_T_LEN__MASK_UH_TOKEN_W<'a, REG> = crate::FieldWriter<'a, REG, 3>;
        ///Field `HSOT_PID3__MASK_UH_TOKEN` reader - PID\[3\]
        ///in host mode;set the token PID packet flag
        pub type HSOT_PID3__MASK_UH_TOKEN_R = crate::BitReader;
        ///Field `HSOT_PID3__MASK_UH_TOKEN` writer - PID\[3\]
        ///in host mode;set the token PID packet flag
        pub type HSOT_PID3__MASK_UH_TOKEN_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bits 0:3 - set the endpoint number of the target device; set USB endpoint send data bytes
            #[inline(always)]
            pub fn uep1_t_len__mask_uh_endp(&self) -> UEP1_T_LEN__MASK_UH_ENDP_R {
                UEP1_T_LEN__MASK_UH_ENDP_R::new((self.bits & 0x0f) as u8)
            }
            ///Bits 4:6 - set USB endpoint send data bytes;set the token PID packet flag
            #[inline(always)]
            pub fn uep1_t_len__mask_uh_token(&self) -> UEP1_T_LEN__MASK_UH_TOKEN_R {
                UEP1_T_LEN__MASK_UH_TOKEN_R::new(((self.bits >> 4) & 7) as u8)
            }
            ///Bit 7 - PID\[3\]
            ///in host mode;set the token PID packet flag
            #[inline(always)]
            pub fn hsot_pid3__mask_uh_token(&self) -> HSOT_PID3__MASK_UH_TOKEN_R {
                HSOT_PID3__MASK_UH_TOKEN_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:3 - set the endpoint number of the target device; set USB endpoint send data bytes
            #[inline(always)]
            #[must_use]
            pub fn uep1_t_len__mask_uh_endp(
                &mut self,
            ) -> UEP1_T_LEN__MASK_UH_ENDP_W<UEP2_T_LEN_SPEC> {
                UEP1_T_LEN__MASK_UH_ENDP_W::new(self, 0)
            }
            ///Bits 4:6 - set USB endpoint send data bytes;set the token PID packet flag
            #[inline(always)]
            #[must_use]
            pub fn uep1_t_len__mask_uh_token(
                &mut self,
            ) -> UEP1_T_LEN__MASK_UH_TOKEN_W<UEP2_T_LEN_SPEC> {
                UEP1_T_LEN__MASK_UH_TOKEN_W::new(self, 4)
            }
            ///Bit 7 - PID\[3\]
            ///in host mode;set the token PID packet flag
            #[inline(always)]
            #[must_use]
            pub fn hsot_pid3__mask_uh_token(
                &mut self,
            ) -> HSOT_PID3__MASK_UH_TOKEN_W<UEP2_T_LEN_SPEC> {
                HSOT_PID3__MASK_UH_TOKEN_W::new(self, 7)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///endpoint send length register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`uep2_t_len::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep2_t_len::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct UEP2_T_LEN_SPEC;
        impl crate::RegisterSpec for UEP2_T_LEN_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`uep2_t_len::R`](R) reader structure
        impl crate::Readable for UEP2_T_LEN_SPEC {}
        ///`write(|w| ..)` method takes [`uep2_t_len::W`](W) writer structure
        impl crate::Writable for UEP2_T_LEN_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets UEP2_T_LEN to value 0
        impl crate::Resettable for UEP2_T_LEN_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///UH_RX_CTRL (rw) register accessor: USB host receive endpoint control register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`uh_rx_ctrl::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uh_rx_ctrl::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@uh_rx_ctrl`]
    ///module
    pub type UH_RX_CTRL = crate::Reg<uh_rx_ctrl::UH_RX_CTRL_SPEC>;
    ///USB host receive endpoint control register
    pub mod uh_rx_ctrl {
        ///Register `UH_RX_CTRL` reader
        pub type R = crate::R<UH_RX_CTRL_SPEC>;
        ///Register `UH_RX_CTRL` writer
        pub type W = crate::W<UH_RX_CTRL_SPEC>;
        ///Field `UH_R_RES` reader - host receiver response control for IN transactions
        pub type UH_R_RES_R = crate::BitReader;
        ///Field `UH_R_RES` writer - host receiver response control for IN transactions
        pub type UH_R_RES_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UH_R_TOG` reader - sync trigger bit expected by usb host receiver
        pub type UH_R_TOG_R = crate::BitReader;
        ///Field `UH_R_TOG` writer - sync trigger bit expected by usb host receiver
        pub type UH_R_TOG_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UH_R_AUTO_TOG` reader - sync trigger bit aoto flip enable control
        pub type UH_R_AUTO_TOG_R = crate::BitReader;
        ///Field `UH_R_AUTO_TOG` writer - sync trigger bit aoto flip enable control
        pub type UH_R_AUTO_TOG_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - host receiver response control for IN transactions
            #[inline(always)]
            pub fn uh_r_res(&self) -> UH_R_RES_R {
                UH_R_RES_R::new((self.bits & 1) != 0)
            }
            ///Bit 2 - sync trigger bit expected by usb host receiver
            #[inline(always)]
            pub fn uh_r_tog(&self) -> UH_R_TOG_R {
                UH_R_TOG_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - sync trigger bit aoto flip enable control
            #[inline(always)]
            pub fn uh_r_auto_tog(&self) -> UH_R_AUTO_TOG_R {
                UH_R_AUTO_TOG_R::new(((self.bits >> 3) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - host receiver response control for IN transactions
            #[inline(always)]
            #[must_use]
            pub fn uh_r_res(&mut self) -> UH_R_RES_W<UH_RX_CTRL_SPEC> {
                UH_R_RES_W::new(self, 0)
            }
            ///Bit 2 - sync trigger bit expected by usb host receiver
            #[inline(always)]
            #[must_use]
            pub fn uh_r_tog(&mut self) -> UH_R_TOG_W<UH_RX_CTRL_SPEC> {
                UH_R_TOG_W::new(self, 2)
            }
            ///Bit 3 - sync trigger bit aoto flip enable control
            #[inline(always)]
            #[must_use]
            pub fn uh_r_auto_tog(&mut self) -> UH_R_AUTO_TOG_W<UH_RX_CTRL_SPEC> {
                UH_R_AUTO_TOG_W::new(self, 3)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///USB host receive endpoint control register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`uh_rx_ctrl::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uh_rx_ctrl::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct UH_RX_CTRL_SPEC;
        impl crate::RegisterSpec for UH_RX_CTRL_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`uh_rx_ctrl::R`](R) reader structure
        impl crate::Readable for UH_RX_CTRL_SPEC {}
        ///`write(|w| ..)` method takes [`uh_rx_ctrl::W`](W) writer structure
        impl crate::Writable for UH_RX_CTRL_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets UH_RX_CTRL to value 0
        impl crate::Resettable for UH_RX_CTRL_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///UEP3_T_LEN__R16_UH_TX_LEN (rw) register accessor: endpoint send length register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`uep3_t_len__r16_uh_tx_len::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep3_t_len__r16_uh_tx_len::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@uep3_t_len__r16_uh_tx_len`]
    ///module
    pub type UEP3_T_LEN__R16_UH_TX_LEN =
        crate::Reg<uep3_t_len__r16_uh_tx_len::UEP3_T_LEN__R16_UH_TX_LEN_SPEC>;
    ///endpoint send length register
    pub mod uep3_t_len__r16_uh_tx_len {
        ///Register `UEP3_T_LEN__R16_UH_TX_LEN` reader
        pub type R = crate::R<UEP3_T_LEN__R16_UH_TX_LEN_SPEC>;
        ///Register `UEP3_T_LEN__R16_UH_TX_LEN` writer
        pub type W = crate::W<UEP3_T_LEN__R16_UH_TX_LEN_SPEC>;
        ///Field `UEP3_T_LEN__R8_UH_TX_LEN` reader - set USB endpoint send data bytes
        pub type UEP3_T_LEN__R8_UH_TX_LEN_R = crate::FieldReader<u16>;
        ///Field `UEP3_T_LEN__R8_UH_TX_LEN` writer - set USB endpoint send data bytes
        pub type UEP3_T_LEN__R8_UH_TX_LEN_W<'a, REG> = crate::FieldWriter<'a, REG, 10, u16>;
        ///Field `UH_TX_LEN` reader - set USB endpoint send data bytes
        pub type UH_TX_LEN_R = crate::FieldReader;
        ///Field `UH_TX_LEN` writer - set USB endpoint send data bytes
        pub type UH_TX_LEN_W<'a, REG> = crate::FieldWriter<'a, REG, 6>;
        impl R {
            ///Bits 0:9 - set USB endpoint send data bytes
            #[inline(always)]
            pub fn uep3_t_len__r8_uh_tx_len(&self) -> UEP3_T_LEN__R8_UH_TX_LEN_R {
                UEP3_T_LEN__R8_UH_TX_LEN_R::new(self.bits & 0x03ff)
            }
            ///Bits 10:15 - set USB endpoint send data bytes
            #[inline(always)]
            pub fn uh_tx_len(&self) -> UH_TX_LEN_R {
                UH_TX_LEN_R::new(((self.bits >> 10) & 0x3f) as u8)
            }
        }
        impl W {
            ///Bits 0:9 - set USB endpoint send data bytes
            #[inline(always)]
            #[must_use]
            pub fn uep3_t_len__r8_uh_tx_len(
                &mut self,
            ) -> UEP3_T_LEN__R8_UH_TX_LEN_W<UEP3_T_LEN__R16_UH_TX_LEN_SPEC> {
                UEP3_T_LEN__R8_UH_TX_LEN_W::new(self, 0)
            }
            ///Bits 10:15 - set USB endpoint send data bytes
            #[inline(always)]
            #[must_use]
            pub fn uh_tx_len(&mut self) -> UH_TX_LEN_W<UEP3_T_LEN__R16_UH_TX_LEN_SPEC> {
                UH_TX_LEN_W::new(self, 10)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///endpoint send length register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`uep3_t_len__r16_uh_tx_len::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep3_t_len__r16_uh_tx_len::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct UEP3_T_LEN__R16_UH_TX_LEN_SPEC;
        impl crate::RegisterSpec for UEP3_T_LEN__R16_UH_TX_LEN_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`uep3_t_len__r16_uh_tx_len::R`](R) reader structure
        impl crate::Readable for UEP3_T_LEN__R16_UH_TX_LEN_SPEC {}
        ///`write(|w| ..)` method takes [`uep3_t_len__r16_uh_tx_len::W`](W) writer structure
        impl crate::Writable for UEP3_T_LEN__R16_UH_TX_LEN_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets UEP3_T_LEN__R16_UH_TX_LEN to value 0
        impl crate::Resettable for UEP3_T_LEN__R16_UH_TX_LEN_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///UEP4_T_LEN (rw) register accessor: endpoint send length register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`uep4_t_len::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep4_t_len::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@uep4_t_len`]
    ///module
    pub type UEP4_T_LEN = crate::Reg<uep4_t_len::UEP4_T_LEN_SPEC>;
    ///endpoint send length register
    pub mod uep4_t_len {
        ///Register `UEP4_T_LEN` reader
        pub type R = crate::R<UEP4_T_LEN_SPEC>;
        ///Register `UEP4_T_LEN` writer
        pub type W = crate::W<UEP4_T_LEN_SPEC>;
        ///Field `UEP4_T_LEN` reader - set USB endpoint send data bytes
        pub type UEP4_T_LEN_R = crate::FieldReader;
        ///Field `UEP4_T_LEN` writer - set USB endpoint send data bytes
        pub type UEP4_T_LEN_W<'a, REG> = crate::FieldWriter<'a, REG, 7>;
        impl R {
            ///Bits 0:6 - set USB endpoint send data bytes
            #[inline(always)]
            pub fn uep4_t_len(&self) -> UEP4_T_LEN_R {
                UEP4_T_LEN_R::new((self.bits & 0x7f) as u8)
            }
        }
        impl W {
            ///Bits 0:6 - set USB endpoint send data bytes
            #[inline(always)]
            #[must_use]
            pub fn uep4_t_len(&mut self) -> UEP4_T_LEN_W<UEP4_T_LEN_SPEC> {
                UEP4_T_LEN_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///endpoint send length register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`uep4_t_len::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep4_t_len::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct UEP4_T_LEN_SPEC;
        impl crate::RegisterSpec for UEP4_T_LEN_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`uep4_t_len::R`](R) reader structure
        impl crate::Readable for UEP4_T_LEN_SPEC {}
        ///`write(|w| ..)` method takes [`uep4_t_len::W`](W) writer structure
        impl crate::Writable for UEP4_T_LEN_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets UEP4_T_LEN to value 0
        impl crate::Resettable for UEP4_T_LEN_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///UEP5_T_LEN (rw) register accessor: endpoint send length register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`uep5_t_len::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep5_t_len::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@uep5_t_len`]
    ///module
    pub type UEP5_T_LEN = crate::Reg<uep5_t_len::UEP5_T_LEN_SPEC>;
    ///endpoint send length register
    pub mod uep5_t_len {
        ///Register `UEP5_T_LEN` reader
        pub type R = crate::R<UEP5_T_LEN_SPEC>;
        ///Register `UEP5_T_LEN` writer
        pub type W = crate::W<UEP5_T_LEN_SPEC>;
        ///Field `UEP5_T_LEN` reader - set USB endpoint send data bytes
        pub type UEP5_T_LEN_R = crate::FieldReader;
        ///Field `UEP5_T_LEN` writer - set USB endpoint send data bytes
        pub type UEP5_T_LEN_W<'a, REG> = crate::FieldWriter<'a, REG, 7>;
        impl R {
            ///Bits 0:6 - set USB endpoint send data bytes
            #[inline(always)]
            pub fn uep5_t_len(&self) -> UEP5_T_LEN_R {
                UEP5_T_LEN_R::new((self.bits & 0x7f) as u8)
            }
        }
        impl W {
            ///Bits 0:6 - set USB endpoint send data bytes
            #[inline(always)]
            #[must_use]
            pub fn uep5_t_len(&mut self) -> UEP5_T_LEN_W<UEP5_T_LEN_SPEC> {
                UEP5_T_LEN_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///endpoint send length register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`uep5_t_len::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep5_t_len::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct UEP5_T_LEN_SPEC;
        impl crate::RegisterSpec for UEP5_T_LEN_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`uep5_t_len::R`](R) reader structure
        impl crate::Readable for UEP5_T_LEN_SPEC {}
        ///`write(|w| ..)` method takes [`uep5_t_len::W`](W) writer structure
        impl crate::Writable for UEP5_T_LEN_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets UEP5_T_LEN to value 0
        impl crate::Resettable for UEP5_T_LEN_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///UEP6_T_LEN (rw) register accessor: endpoint send length register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`uep6_t_len::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep6_t_len::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@uep6_t_len`]
    ///module
    pub type UEP6_T_LEN = crate::Reg<uep6_t_len::UEP6_T_LEN_SPEC>;
    ///endpoint send length register
    pub mod uep6_t_len {
        ///Register `UEP6_T_LEN` reader
        pub type R = crate::R<UEP6_T_LEN_SPEC>;
        ///Register `UEP6_T_LEN` writer
        pub type W = crate::W<UEP6_T_LEN_SPEC>;
        ///Field `UEP6_T_LEN` reader - set USB endpoint send data bytes
        pub type UEP6_T_LEN_R = crate::FieldReader;
        ///Field `UEP6_T_LEN` writer - set USB endpoint send data bytes
        pub type UEP6_T_LEN_W<'a, REG> = crate::FieldWriter<'a, REG, 7>;
        impl R {
            ///Bits 0:6 - set USB endpoint send data bytes
            #[inline(always)]
            pub fn uep6_t_len(&self) -> UEP6_T_LEN_R {
                UEP6_T_LEN_R::new((self.bits & 0x7f) as u8)
            }
        }
        impl W {
            ///Bits 0:6 - set USB endpoint send data bytes
            #[inline(always)]
            #[must_use]
            pub fn uep6_t_len(&mut self) -> UEP6_T_LEN_W<UEP6_T_LEN_SPEC> {
                UEP6_T_LEN_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///endpoint send length register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`uep6_t_len::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep6_t_len::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct UEP6_T_LEN_SPEC;
        impl crate::RegisterSpec for UEP6_T_LEN_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`uep6_t_len::R`](R) reader structure
        impl crate::Readable for UEP6_T_LEN_SPEC {}
        ///`write(|w| ..)` method takes [`uep6_t_len::W`](W) writer structure
        impl crate::Writable for UEP6_T_LEN_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets UEP6_T_LEN to value 0
        impl crate::Resettable for UEP6_T_LEN_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///UEP7_T_LEN (rw) register accessor: endpoint send length register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`uep7_t_len::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep7_t_len::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@uep7_t_len`]
    ///module
    pub type UEP7_T_LEN = crate::Reg<uep7_t_len::UEP7_T_LEN_SPEC>;
    ///endpoint send length register
    pub mod uep7_t_len {
        ///Register `UEP7_T_LEN` reader
        pub type R = crate::R<UEP7_T_LEN_SPEC>;
        ///Register `UEP7_T_LEN` writer
        pub type W = crate::W<UEP7_T_LEN_SPEC>;
        ///Field `UEP7_T_LEN` reader - set USB endpoint send data bytes
        pub type UEP7_T_LEN_R = crate::FieldReader;
        ///Field `UEP7_T_LEN` writer - set USB endpoint send data bytes
        pub type UEP7_T_LEN_W<'a, REG> = crate::FieldWriter<'a, REG, 7>;
        impl R {
            ///Bits 0:6 - set USB endpoint send data bytes
            #[inline(always)]
            pub fn uep7_t_len(&self) -> UEP7_T_LEN_R {
                UEP7_T_LEN_R::new((self.bits & 0x7f) as u8)
            }
        }
        impl W {
            ///Bits 0:6 - set USB endpoint send data bytes
            #[inline(always)]
            #[must_use]
            pub fn uep7_t_len(&mut self) -> UEP7_T_LEN_W<UEP7_T_LEN_SPEC> {
                UEP7_T_LEN_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///endpoint send length register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`uep7_t_len::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep7_t_len::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct UEP7_T_LEN_SPEC;
        impl crate::RegisterSpec for UEP7_T_LEN_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`uep7_t_len::R`](R) reader structure
        impl crate::Readable for UEP7_T_LEN_SPEC {}
        ///`write(|w| ..)` method takes [`uep7_t_len::W`](W) writer structure
        impl crate::Writable for UEP7_T_LEN_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets UEP7_T_LEN to value 0
        impl crate::Resettable for UEP7_T_LEN_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///UEP0_CTRL (rw) register accessor: endpoint control register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`uep0_ctrl::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep0_ctrl::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@uep0_ctrl`]
    ///module
    pub type UEP0_CTRL = crate::Reg<uep0_ctrl::UEP0_CTRL_SPEC>;
    ///endpoint control register
    pub mod uep0_ctrl {
        ///Register `UEP0_CTRL` reader
        pub type R = crate::R<UEP0_CTRL_SPEC>;
        ///Register `UEP0_CTRL` writer
        pub type W = crate::W<UEP0_CTRL_SPEC>;
        ///Field `MASK_UEP_T_RES` reader - response control of endpoint's receiver to the IN transaction
        pub type MASK_UEP_T_RES_R = crate::FieldReader;
        ///Field `MASK_UEP_T_RES` writer - response control of endpoint's receiver to the IN transaction
        pub type MASK_UEP_T_RES_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `UEP_T_TOG` reader - synchronization trigger bit for sender of USB endpoint (handling IN transactions)
        pub type UEP_T_TOG_R = crate::BitReader;
        ///Field `UEP_T_TOG` writer - synchronization trigger bit for sender of USB endpoint (handling IN transactions)
        pub type UEP_T_TOG_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UEP_T_AUTO_TOG` reader - sync trigger bit aoto flip enable control
        pub type UEP_T_AUTO_TOG_R = crate::BitReader;
        ///Field `UEP_T_AUTO_TOG` writer - sync trigger bit aoto flip enable control
        pub type UEP_T_AUTO_TOG_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `MASK_UEP_R_RES` reader - response control of endpoint's receiver to the OUT transaction
        pub type MASK_UEP_R_RES_R = crate::FieldReader;
        ///Field `MASK_UEP_R_RES` writer - response control of endpoint's receiver to the OUT transaction
        pub type MASK_UEP_R_RES_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `MASK_UEP_R_TOG` reader - desired synchronization trigger bit for receiver of USB endpoint (handling OUT transactions)
        pub type MASK_UEP_R_TOG_R = crate::BitReader;
        ///Field `MASK_UEP_R_TOG` writer - desired synchronization trigger bit for receiver of USB endpoint (handling OUT transactions)
        pub type MASK_UEP_R_TOG_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UEP_R_AUTO_TOG` reader - sync trigger bit aoto flip enable control
        pub type UEP_R_AUTO_TOG_R = crate::BitReader;
        ///Field `UEP_R_AUTO_TOG` writer - sync trigger bit aoto flip enable control
        pub type UEP_R_AUTO_TOG_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bits 0:1 - response control of endpoint's receiver to the IN transaction
            #[inline(always)]
            pub fn mask_uep_t_res(&self) -> MASK_UEP_T_RES_R {
                MASK_UEP_T_RES_R::new((self.bits & 3) as u8)
            }
            ///Bit 2 - synchronization trigger bit for sender of USB endpoint (handling IN transactions)
            #[inline(always)]
            pub fn uep_t_tog(&self) -> UEP_T_TOG_R {
                UEP_T_TOG_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - sync trigger bit aoto flip enable control
            #[inline(always)]
            pub fn uep_t_auto_tog(&self) -> UEP_T_AUTO_TOG_R {
                UEP_T_AUTO_TOG_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bits 8:9 - response control of endpoint's receiver to the OUT transaction
            #[inline(always)]
            pub fn mask_uep_r_res(&self) -> MASK_UEP_R_RES_R {
                MASK_UEP_R_RES_R::new(((self.bits >> 8) & 3) as u8)
            }
            ///Bit 10 - desired synchronization trigger bit for receiver of USB endpoint (handling OUT transactions)
            #[inline(always)]
            pub fn mask_uep_r_tog(&self) -> MASK_UEP_R_TOG_R {
                MASK_UEP_R_TOG_R::new(((self.bits >> 10) & 1) != 0)
            }
            ///Bit 11 - sync trigger bit aoto flip enable control
            #[inline(always)]
            pub fn uep_r_auto_tog(&self) -> UEP_R_AUTO_TOG_R {
                UEP_R_AUTO_TOG_R::new(((self.bits >> 11) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:1 - response control of endpoint's receiver to the IN transaction
            #[inline(always)]
            #[must_use]
            pub fn mask_uep_t_res(&mut self) -> MASK_UEP_T_RES_W<UEP0_CTRL_SPEC> {
                MASK_UEP_T_RES_W::new(self, 0)
            }
            ///Bit 2 - synchronization trigger bit for sender of USB endpoint (handling IN transactions)
            #[inline(always)]
            #[must_use]
            pub fn uep_t_tog(&mut self) -> UEP_T_TOG_W<UEP0_CTRL_SPEC> {
                UEP_T_TOG_W::new(self, 2)
            }
            ///Bit 3 - sync trigger bit aoto flip enable control
            #[inline(always)]
            #[must_use]
            pub fn uep_t_auto_tog(&mut self) -> UEP_T_AUTO_TOG_W<UEP0_CTRL_SPEC> {
                UEP_T_AUTO_TOG_W::new(self, 3)
            }
            ///Bits 8:9 - response control of endpoint's receiver to the OUT transaction
            #[inline(always)]
            #[must_use]
            pub fn mask_uep_r_res(&mut self) -> MASK_UEP_R_RES_W<UEP0_CTRL_SPEC> {
                MASK_UEP_R_RES_W::new(self, 8)
            }
            ///Bit 10 - desired synchronization trigger bit for receiver of USB endpoint (handling OUT transactions)
            #[inline(always)]
            #[must_use]
            pub fn mask_uep_r_tog(&mut self) -> MASK_UEP_R_TOG_W<UEP0_CTRL_SPEC> {
                MASK_UEP_R_TOG_W::new(self, 10)
            }
            ///Bit 11 - sync trigger bit aoto flip enable control
            #[inline(always)]
            #[must_use]
            pub fn uep_r_auto_tog(&mut self) -> UEP_R_AUTO_TOG_W<UEP0_CTRL_SPEC> {
                UEP_R_AUTO_TOG_W::new(self, 11)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///endpoint control register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`uep0_ctrl::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep0_ctrl::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct UEP0_CTRL_SPEC;
        impl crate::RegisterSpec for UEP0_CTRL_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`uep0_ctrl::R`](R) reader structure
        impl crate::Readable for UEP0_CTRL_SPEC {}
        ///`write(|w| ..)` method takes [`uep0_ctrl::W`](W) writer structure
        impl crate::Writable for UEP0_CTRL_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets UEP0_CTRL to value 0
        impl crate::Resettable for UEP0_CTRL_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///UEP1_CTRL__R16_UH_SETUP (rw) register accessor: endpoint control register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`uep1_ctrl__r16_uh_setup::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep1_ctrl__r16_uh_setup::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@uep1_ctrl__r16_uh_setup`]
    ///module
    pub type UEP1_CTRL__R16_UH_SETUP =
        crate::Reg<uep1_ctrl__r16_uh_setup::UEP1_CTRL__R16_UH_SETUP_SPEC>;
    ///endpoint control register
    pub mod uep1_ctrl__r16_uh_setup {
        ///Register `UEP1_CTRL__R16_UH_SETUP` reader
        pub type R = crate::R<UEP1_CTRL__R16_UH_SETUP_SPEC>;
        ///Register `UEP1_CTRL__R16_UH_SETUP` writer
        pub type W = crate::W<UEP1_CTRL__R16_UH_SETUP_SPEC>;
        ///Field `MASK_UEP_T_RES` reader - response control of endpoint's receiver to the IN transaction
        pub type MASK_UEP_T_RES_R = crate::FieldReader;
        ///Field `MASK_UEP_T_RES` writer - response control of endpoint's receiver to the IN transaction
        pub type MASK_UEP_T_RES_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `UEP_T_TOG__RB_UH_SOF_EN` reader - synchronization trigger bit for sender of USB endpoint (handling IN transactions);aoto generate SOF packet enable
        pub type UEP_T_TOG__RB_UH_SOF_EN_R = crate::BitReader;
        ///Field `UEP_T_TOG__RB_UH_SOF_EN` writer - synchronization trigger bit for sender of USB endpoint (handling IN transactions);aoto generate SOF packet enable
        pub type UEP_T_TOG__RB_UH_SOF_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UEP_T_AUTO_TOG` reader - sync trigger bit aoto flip enable control
        pub type UEP_T_AUTO_TOG_R = crate::BitReader;
        ///Field `UEP_T_AUTO_TOG` writer - sync trigger bit aoto flip enable control
        pub type UEP_T_AUTO_TOG_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `MASK_UEP_R_RES` reader - response control of endpoint's receiver to the OUT transaction
        pub type MASK_UEP_R_RES_R = crate::FieldReader;
        ///Field `MASK_UEP_R_RES` writer - response control of endpoint's receiver to the OUT transaction
        pub type MASK_UEP_R_RES_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `MASK_UEP_R_TOG__RB_UH_PRE_PID_EN` reader - desired synchronization trigger bit for receiver of USB endpoint (handling OUT transactions);low-speed lead packet PRE PID enable
        pub type MASK_UEP_R_TOG__RB_UH_PRE_PID_EN_R = crate::BitReader;
        ///Field `MASK_UEP_R_TOG__RB_UH_PRE_PID_EN` writer - desired synchronization trigger bit for receiver of USB endpoint (handling OUT transactions);low-speed lead packet PRE PID enable
        pub type MASK_UEP_R_TOG__RB_UH_PRE_PID_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UEP_R_AUTO_TOG` reader - sync trigger bit aoto flip enable control
        pub type UEP_R_AUTO_TOG_R = crate::BitReader;
        ///Field `UEP_R_AUTO_TOG` writer - sync trigger bit aoto flip enable control
        pub type UEP_R_AUTO_TOG_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bits 0:1 - response control of endpoint's receiver to the IN transaction
            #[inline(always)]
            pub fn mask_uep_t_res(&self) -> MASK_UEP_T_RES_R {
                MASK_UEP_T_RES_R::new((self.bits & 3) as u8)
            }
            ///Bit 2 - synchronization trigger bit for sender of USB endpoint (handling IN transactions);aoto generate SOF packet enable
            #[inline(always)]
            pub fn uep_t_tog__rb_uh_sof_en(&self) -> UEP_T_TOG__RB_UH_SOF_EN_R {
                UEP_T_TOG__RB_UH_SOF_EN_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - sync trigger bit aoto flip enable control
            #[inline(always)]
            pub fn uep_t_auto_tog(&self) -> UEP_T_AUTO_TOG_R {
                UEP_T_AUTO_TOG_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bits 8:9 - response control of endpoint's receiver to the OUT transaction
            #[inline(always)]
            pub fn mask_uep_r_res(&self) -> MASK_UEP_R_RES_R {
                MASK_UEP_R_RES_R::new(((self.bits >> 8) & 3) as u8)
            }
            ///Bit 10 - desired synchronization trigger bit for receiver of USB endpoint (handling OUT transactions);low-speed lead packet PRE PID enable
            #[inline(always)]
            pub fn mask_uep_r_tog__rb_uh_pre_pid_en(&self) -> MASK_UEP_R_TOG__RB_UH_PRE_PID_EN_R {
                MASK_UEP_R_TOG__RB_UH_PRE_PID_EN_R::new(((self.bits >> 10) & 1) != 0)
            }
            ///Bit 11 - sync trigger bit aoto flip enable control
            #[inline(always)]
            pub fn uep_r_auto_tog(&self) -> UEP_R_AUTO_TOG_R {
                UEP_R_AUTO_TOG_R::new(((self.bits >> 11) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:1 - response control of endpoint's receiver to the IN transaction
            #[inline(always)]
            #[must_use]
            pub fn mask_uep_t_res(&mut self) -> MASK_UEP_T_RES_W<UEP1_CTRL__R16_UH_SETUP_SPEC> {
                MASK_UEP_T_RES_W::new(self, 0)
            }
            ///Bit 2 - synchronization trigger bit for sender of USB endpoint (handling IN transactions);aoto generate SOF packet enable
            #[inline(always)]
            #[must_use]
            pub fn uep_t_tog__rb_uh_sof_en(
                &mut self,
            ) -> UEP_T_TOG__RB_UH_SOF_EN_W<UEP1_CTRL__R16_UH_SETUP_SPEC> {
                UEP_T_TOG__RB_UH_SOF_EN_W::new(self, 2)
            }
            ///Bit 3 - sync trigger bit aoto flip enable control
            #[inline(always)]
            #[must_use]
            pub fn uep_t_auto_tog(&mut self) -> UEP_T_AUTO_TOG_W<UEP1_CTRL__R16_UH_SETUP_SPEC> {
                UEP_T_AUTO_TOG_W::new(self, 3)
            }
            ///Bits 8:9 - response control of endpoint's receiver to the OUT transaction
            #[inline(always)]
            #[must_use]
            pub fn mask_uep_r_res(&mut self) -> MASK_UEP_R_RES_W<UEP1_CTRL__R16_UH_SETUP_SPEC> {
                MASK_UEP_R_RES_W::new(self, 8)
            }
            ///Bit 10 - desired synchronization trigger bit for receiver of USB endpoint (handling OUT transactions);low-speed lead packet PRE PID enable
            #[inline(always)]
            #[must_use]
            pub fn mask_uep_r_tog__rb_uh_pre_pid_en(
                &mut self,
            ) -> MASK_UEP_R_TOG__RB_UH_PRE_PID_EN_W<UEP1_CTRL__R16_UH_SETUP_SPEC> {
                MASK_UEP_R_TOG__RB_UH_PRE_PID_EN_W::new(self, 10)
            }
            ///Bit 11 - sync trigger bit aoto flip enable control
            #[inline(always)]
            #[must_use]
            pub fn uep_r_auto_tog(&mut self) -> UEP_R_AUTO_TOG_W<UEP1_CTRL__R16_UH_SETUP_SPEC> {
                UEP_R_AUTO_TOG_W::new(self, 11)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///endpoint control register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`uep1_ctrl__r16_uh_setup::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep1_ctrl__r16_uh_setup::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct UEP1_CTRL__R16_UH_SETUP_SPEC;
        impl crate::RegisterSpec for UEP1_CTRL__R16_UH_SETUP_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`uep1_ctrl__r16_uh_setup::R`](R) reader structure
        impl crate::Readable for UEP1_CTRL__R16_UH_SETUP_SPEC {}
        ///`write(|w| ..)` method takes [`uep1_ctrl__r16_uh_setup::W`](W) writer structure
        impl crate::Writable for UEP1_CTRL__R16_UH_SETUP_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets UEP1_CTRL__R16_UH_SETUP to value 0
        impl crate::Resettable for UEP1_CTRL__R16_UH_SETUP_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///UEP2_CTRL (rw) register accessor: endpoint control register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`uep2_ctrl::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep2_ctrl::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@uep2_ctrl`]
    ///module
    pub type UEP2_CTRL = crate::Reg<uep2_ctrl::UEP2_CTRL_SPEC>;
    ///endpoint control register
    pub mod uep2_ctrl {
        ///Register `UEP2_CTRL` reader
        pub type R = crate::R<UEP2_CTRL_SPEC>;
        ///Register `UEP2_CTRL` writer
        pub type W = crate::W<UEP2_CTRL_SPEC>;
        ///Field `MASK_UEP_T_RES` reader - response control of endpoint's receiver to the IN transaction
        pub type MASK_UEP_T_RES_R = crate::FieldReader;
        ///Field `MASK_UEP_T_RES` writer - response control of endpoint's receiver to the IN transaction
        pub type MASK_UEP_T_RES_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `UEP_T_TOG` reader - synchronization trigger bit for sender of USB endpoint (handling IN transactions)
        pub type UEP_T_TOG_R = crate::BitReader;
        ///Field `UEP_T_TOG` writer - synchronization trigger bit for sender of USB endpoint (handling IN transactions)
        pub type UEP_T_TOG_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UEP_T_AUTO_TOG` reader - sync trigger bit aoto flip enable control
        pub type UEP_T_AUTO_TOG_R = crate::BitReader;
        ///Field `UEP_T_AUTO_TOG` writer - sync trigger bit aoto flip enable control
        pub type UEP_T_AUTO_TOG_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `MASK_UEP_R_RES` reader - response control of endpoint's receiver to the OUT transaction
        pub type MASK_UEP_R_RES_R = crate::FieldReader;
        ///Field `MASK_UEP_R_RES` writer - response control of endpoint's receiver to the OUT transaction
        pub type MASK_UEP_R_RES_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `MASK_UEP_R_TOG` reader - desired synchronization trigger bit for receiver of USB endpoint (handling OUT transactions)
        pub type MASK_UEP_R_TOG_R = crate::BitReader;
        ///Field `MASK_UEP_R_TOG` writer - desired synchronization trigger bit for receiver of USB endpoint (handling OUT transactions)
        pub type MASK_UEP_R_TOG_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UEP_R_AUTO_TOG` reader - sync trigger bit aoto flip enable control
        pub type UEP_R_AUTO_TOG_R = crate::BitReader;
        ///Field `UEP_R_AUTO_TOG` writer - sync trigger bit aoto flip enable control
        pub type UEP_R_AUTO_TOG_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bits 0:1 - response control of endpoint's receiver to the IN transaction
            #[inline(always)]
            pub fn mask_uep_t_res(&self) -> MASK_UEP_T_RES_R {
                MASK_UEP_T_RES_R::new((self.bits & 3) as u8)
            }
            ///Bit 2 - synchronization trigger bit for sender of USB endpoint (handling IN transactions)
            #[inline(always)]
            pub fn uep_t_tog(&self) -> UEP_T_TOG_R {
                UEP_T_TOG_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - sync trigger bit aoto flip enable control
            #[inline(always)]
            pub fn uep_t_auto_tog(&self) -> UEP_T_AUTO_TOG_R {
                UEP_T_AUTO_TOG_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bits 8:9 - response control of endpoint's receiver to the OUT transaction
            #[inline(always)]
            pub fn mask_uep_r_res(&self) -> MASK_UEP_R_RES_R {
                MASK_UEP_R_RES_R::new(((self.bits >> 8) & 3) as u8)
            }
            ///Bit 10 - desired synchronization trigger bit for receiver of USB endpoint (handling OUT transactions)
            #[inline(always)]
            pub fn mask_uep_r_tog(&self) -> MASK_UEP_R_TOG_R {
                MASK_UEP_R_TOG_R::new(((self.bits >> 10) & 1) != 0)
            }
            ///Bit 11 - sync trigger bit aoto flip enable control
            #[inline(always)]
            pub fn uep_r_auto_tog(&self) -> UEP_R_AUTO_TOG_R {
                UEP_R_AUTO_TOG_R::new(((self.bits >> 11) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:1 - response control of endpoint's receiver to the IN transaction
            #[inline(always)]
            #[must_use]
            pub fn mask_uep_t_res(&mut self) -> MASK_UEP_T_RES_W<UEP2_CTRL_SPEC> {
                MASK_UEP_T_RES_W::new(self, 0)
            }
            ///Bit 2 - synchronization trigger bit for sender of USB endpoint (handling IN transactions)
            #[inline(always)]
            #[must_use]
            pub fn uep_t_tog(&mut self) -> UEP_T_TOG_W<UEP2_CTRL_SPEC> {
                UEP_T_TOG_W::new(self, 2)
            }
            ///Bit 3 - sync trigger bit aoto flip enable control
            #[inline(always)]
            #[must_use]
            pub fn uep_t_auto_tog(&mut self) -> UEP_T_AUTO_TOG_W<UEP2_CTRL_SPEC> {
                UEP_T_AUTO_TOG_W::new(self, 3)
            }
            ///Bits 8:9 - response control of endpoint's receiver to the OUT transaction
            #[inline(always)]
            #[must_use]
            pub fn mask_uep_r_res(&mut self) -> MASK_UEP_R_RES_W<UEP2_CTRL_SPEC> {
                MASK_UEP_R_RES_W::new(self, 8)
            }
            ///Bit 10 - desired synchronization trigger bit for receiver of USB endpoint (handling OUT transactions)
            #[inline(always)]
            #[must_use]
            pub fn mask_uep_r_tog(&mut self) -> MASK_UEP_R_TOG_W<UEP2_CTRL_SPEC> {
                MASK_UEP_R_TOG_W::new(self, 10)
            }
            ///Bit 11 - sync trigger bit aoto flip enable control
            #[inline(always)]
            #[must_use]
            pub fn uep_r_auto_tog(&mut self) -> UEP_R_AUTO_TOG_W<UEP2_CTRL_SPEC> {
                UEP_R_AUTO_TOG_W::new(self, 11)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///endpoint control register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`uep2_ctrl::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep2_ctrl::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct UEP2_CTRL_SPEC;
        impl crate::RegisterSpec for UEP2_CTRL_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`uep2_ctrl::R`](R) reader structure
        impl crate::Readable for UEP2_CTRL_SPEC {}
        ///`write(|w| ..)` method takes [`uep2_ctrl::W`](W) writer structure
        impl crate::Writable for UEP2_CTRL_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets UEP2_CTRL to value 0
        impl crate::Resettable for UEP2_CTRL_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///UEP3_CTRL__R8_UH_TX_CTRL (rw) register accessor: endpoint control register;USB host send endpoint control register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`uep3_ctrl__r8_uh_tx_ctrl::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep3_ctrl__r8_uh_tx_ctrl::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@uep3_ctrl__r8_uh_tx_ctrl`]
    ///module
    pub type UEP3_CTRL__R8_UH_TX_CTRL =
        crate::Reg<uep3_ctrl__r8_uh_tx_ctrl::UEP3_CTRL__R8_UH_TX_CTRL_SPEC>;
    ///endpoint control register;USB host send endpoint control register
    pub mod uep3_ctrl__r8_uh_tx_ctrl {
        ///Register `UEP3_CTRL__R8_UH_TX_CTRL` reader
        pub type R = crate::R<UEP3_CTRL__R8_UH_TX_CTRL_SPEC>;
        ///Register `UEP3_CTRL__R8_UH_TX_CTRL` writer
        pub type W = crate::W<UEP3_CTRL__R8_UH_TX_CTRL_SPEC>;
        ///Field `MASK_UEP_T_RES__RB_UH_T_RES` reader - response control of endpoint's receiver to the IN transaction; host send response control for OUT/SETUP transactions
        pub type MASK_UEP_T_RES__RB_UH_T_RES_R = crate::BitReader;
        ///Field `MASK_UEP_T_RES__RB_UH_T_RES` writer - response control of endpoint's receiver to the IN transaction; host send response control for OUT/SETUP transactions
        pub type MASK_UEP_T_RES__RB_UH_T_RES_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `MASK_UEP_T_RES` reader - response control of endpoint's receiver to the IN transaction
        pub type MASK_UEP_T_RES_R = crate::BitReader;
        ///Field `MASK_UEP_T_RES` writer - response control of endpoint's receiver to the IN transaction
        pub type MASK_UEP_T_RES_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UEP_T_TOG__RB_UH_T_TOG` reader - synchronization trigger bit for sender of USB endpoint (handling IN transactions)
        pub type UEP_T_TOG__RB_UH_T_TOG_R = crate::BitReader;
        ///Field `UEP_T_TOG__RB_UH_T_TOG` writer - synchronization trigger bit for sender of USB endpoint (handling IN transactions)
        pub type UEP_T_TOG__RB_UH_T_TOG_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UEP_T_AUTO_TOG__RB_UH_T_AUTO_TOG` reader - sync trigger bit aoto flip enable control
        pub type UEP_T_AUTO_TOG__RB_UH_T_AUTO_TOG_R = crate::BitReader;
        ///Field `UEP_T_AUTO_TOG__RB_UH_T_AUTO_TOG` writer - sync trigger bit aoto flip enable control
        pub type UEP_T_AUTO_TOG__RB_UH_T_AUTO_TOG_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `MASK_UEP_R_RES` reader - response control of endpoint's receiver to the OUT transaction
        pub type MASK_UEP_R_RES_R = crate::FieldReader;
        ///Field `MASK_UEP_R_RES` writer - response control of endpoint's receiver to the OUT transaction
        pub type MASK_UEP_R_RES_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `MASK_UEP_R_TOG` reader - desired synchronization trigger bit for receiver of USB endpoint (handling OUT transactions)
        pub type MASK_UEP_R_TOG_R = crate::BitReader;
        ///Field `MASK_UEP_R_TOG` writer - desired synchronization trigger bit for receiver of USB endpoint (handling OUT transactions)
        pub type MASK_UEP_R_TOG_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UEP_R_AUTO_TOG` reader - sync trigger bit aoto flip enable control
        pub type UEP_R_AUTO_TOG_R = crate::BitReader;
        ///Field `UEP_R_AUTO_TOG` writer - sync trigger bit aoto flip enable control
        pub type UEP_R_AUTO_TOG_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - response control of endpoint's receiver to the IN transaction; host send response control for OUT/SETUP transactions
            #[inline(always)]
            pub fn mask_uep_t_res__rb_uh_t_res(&self) -> MASK_UEP_T_RES__RB_UH_T_RES_R {
                MASK_UEP_T_RES__RB_UH_T_RES_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - response control of endpoint's receiver to the IN transaction
            #[inline(always)]
            pub fn mask_uep_t_res(&self) -> MASK_UEP_T_RES_R {
                MASK_UEP_T_RES_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - synchronization trigger bit for sender of USB endpoint (handling IN transactions)
            #[inline(always)]
            pub fn uep_t_tog__rb_uh_t_tog(&self) -> UEP_T_TOG__RB_UH_T_TOG_R {
                UEP_T_TOG__RB_UH_T_TOG_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - sync trigger bit aoto flip enable control
            #[inline(always)]
            pub fn uep_t_auto_tog__rb_uh_t_auto_tog(&self) -> UEP_T_AUTO_TOG__RB_UH_T_AUTO_TOG_R {
                UEP_T_AUTO_TOG__RB_UH_T_AUTO_TOG_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bits 8:9 - response control of endpoint's receiver to the OUT transaction
            #[inline(always)]
            pub fn mask_uep_r_res(&self) -> MASK_UEP_R_RES_R {
                MASK_UEP_R_RES_R::new(((self.bits >> 8) & 3) as u8)
            }
            ///Bit 10 - desired synchronization trigger bit for receiver of USB endpoint (handling OUT transactions)
            #[inline(always)]
            pub fn mask_uep_r_tog(&self) -> MASK_UEP_R_TOG_R {
                MASK_UEP_R_TOG_R::new(((self.bits >> 10) & 1) != 0)
            }
            ///Bit 11 - sync trigger bit aoto flip enable control
            #[inline(always)]
            pub fn uep_r_auto_tog(&self) -> UEP_R_AUTO_TOG_R {
                UEP_R_AUTO_TOG_R::new(((self.bits >> 11) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - response control of endpoint's receiver to the IN transaction; host send response control for OUT/SETUP transactions
            #[inline(always)]
            #[must_use]
            pub fn mask_uep_t_res__rb_uh_t_res(
                &mut self,
            ) -> MASK_UEP_T_RES__RB_UH_T_RES_W<UEP3_CTRL__R8_UH_TX_CTRL_SPEC> {
                MASK_UEP_T_RES__RB_UH_T_RES_W::new(self, 0)
            }
            ///Bit 1 - response control of endpoint's receiver to the IN transaction
            #[inline(always)]
            #[must_use]
            pub fn mask_uep_t_res(&mut self) -> MASK_UEP_T_RES_W<UEP3_CTRL__R8_UH_TX_CTRL_SPEC> {
                MASK_UEP_T_RES_W::new(self, 1)
            }
            ///Bit 2 - synchronization trigger bit for sender of USB endpoint (handling IN transactions)
            #[inline(always)]
            #[must_use]
            pub fn uep_t_tog__rb_uh_t_tog(
                &mut self,
            ) -> UEP_T_TOG__RB_UH_T_TOG_W<UEP3_CTRL__R8_UH_TX_CTRL_SPEC> {
                UEP_T_TOG__RB_UH_T_TOG_W::new(self, 2)
            }
            ///Bit 3 - sync trigger bit aoto flip enable control
            #[inline(always)]
            #[must_use]
            pub fn uep_t_auto_tog__rb_uh_t_auto_tog(
                &mut self,
            ) -> UEP_T_AUTO_TOG__RB_UH_T_AUTO_TOG_W<UEP3_CTRL__R8_UH_TX_CTRL_SPEC> {
                UEP_T_AUTO_TOG__RB_UH_T_AUTO_TOG_W::new(self, 3)
            }
            ///Bits 8:9 - response control of endpoint's receiver to the OUT transaction
            #[inline(always)]
            #[must_use]
            pub fn mask_uep_r_res(&mut self) -> MASK_UEP_R_RES_W<UEP3_CTRL__R8_UH_TX_CTRL_SPEC> {
                MASK_UEP_R_RES_W::new(self, 8)
            }
            ///Bit 10 - desired synchronization trigger bit for receiver of USB endpoint (handling OUT transactions)
            #[inline(always)]
            #[must_use]
            pub fn mask_uep_r_tog(&mut self) -> MASK_UEP_R_TOG_W<UEP3_CTRL__R8_UH_TX_CTRL_SPEC> {
                MASK_UEP_R_TOG_W::new(self, 10)
            }
            ///Bit 11 - sync trigger bit aoto flip enable control
            #[inline(always)]
            #[must_use]
            pub fn uep_r_auto_tog(&mut self) -> UEP_R_AUTO_TOG_W<UEP3_CTRL__R8_UH_TX_CTRL_SPEC> {
                UEP_R_AUTO_TOG_W::new(self, 11)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///endpoint control register;USB host send endpoint control register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`uep3_ctrl__r8_uh_tx_ctrl::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep3_ctrl__r8_uh_tx_ctrl::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct UEP3_CTRL__R8_UH_TX_CTRL_SPEC;
        impl crate::RegisterSpec for UEP3_CTRL__R8_UH_TX_CTRL_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`uep3_ctrl__r8_uh_tx_ctrl::R`](R) reader structure
        impl crate::Readable for UEP3_CTRL__R8_UH_TX_CTRL_SPEC {}
        ///`write(|w| ..)` method takes [`uep3_ctrl__r8_uh_tx_ctrl::W`](W) writer structure
        impl crate::Writable for UEP3_CTRL__R8_UH_TX_CTRL_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets UEP3_CTRL__R8_UH_TX_CTRL to value 0
        impl crate::Resettable for UEP3_CTRL__R8_UH_TX_CTRL_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///UEP4_CTRL (rw) register accessor: endpoint control register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`uep4_ctrl::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep4_ctrl::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@uep4_ctrl`]
    ///module
    pub type UEP4_CTRL = crate::Reg<uep4_ctrl::UEP4_CTRL_SPEC>;
    ///endpoint control register
    pub mod uep4_ctrl {
        ///Register `UEP4_CTRL` reader
        pub type R = crate::R<UEP4_CTRL_SPEC>;
        ///Register `UEP4_CTRL` writer
        pub type W = crate::W<UEP4_CTRL_SPEC>;
        ///Field `MASK_UEP_T_RES` reader - response control of endpoint's receiver to the IN transaction
        pub type MASK_UEP_T_RES_R = crate::FieldReader;
        ///Field `MASK_UEP_T_RES` writer - response control of endpoint's receiver to the IN transaction
        pub type MASK_UEP_T_RES_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `UEP_T_TOG` reader - synchronization trigger bit for sender of USB endpoint (handling IN transactions)
        pub type UEP_T_TOG_R = crate::BitReader;
        ///Field `UEP_T_TOG` writer - synchronization trigger bit for sender of USB endpoint (handling IN transactions)
        pub type UEP_T_TOG_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UEP_T_AUTO_TOG` reader - sync trigger bit aoto flip enable control
        pub type UEP_T_AUTO_TOG_R = crate::BitReader;
        ///Field `UEP_T_AUTO_TOG` writer - sync trigger bit aoto flip enable control
        pub type UEP_T_AUTO_TOG_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `MASK_UEP_R_RES` reader - response control of endpoint's receiver to the OUT transaction
        pub type MASK_UEP_R_RES_R = crate::FieldReader;
        ///Field `MASK_UEP_R_RES` writer - response control of endpoint's receiver to the OUT transaction
        pub type MASK_UEP_R_RES_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `MASK_UEP_R_TOG` reader - desired synchronization trigger bit for receiver of USB endpoint (handling OUT transactions)
        pub type MASK_UEP_R_TOG_R = crate::BitReader;
        ///Field `MASK_UEP_R_TOG` writer - desired synchronization trigger bit for receiver of USB endpoint (handling OUT transactions)
        pub type MASK_UEP_R_TOG_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UEP_R_AUTO_TOG` reader - sync trigger bit aoto flip enable control
        pub type UEP_R_AUTO_TOG_R = crate::BitReader;
        ///Field `UEP_R_AUTO_TOG` writer - sync trigger bit aoto flip enable control
        pub type UEP_R_AUTO_TOG_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bits 0:1 - response control of endpoint's receiver to the IN transaction
            #[inline(always)]
            pub fn mask_uep_t_res(&self) -> MASK_UEP_T_RES_R {
                MASK_UEP_T_RES_R::new((self.bits & 3) as u8)
            }
            ///Bit 2 - synchronization trigger bit for sender of USB endpoint (handling IN transactions)
            #[inline(always)]
            pub fn uep_t_tog(&self) -> UEP_T_TOG_R {
                UEP_T_TOG_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - sync trigger bit aoto flip enable control
            #[inline(always)]
            pub fn uep_t_auto_tog(&self) -> UEP_T_AUTO_TOG_R {
                UEP_T_AUTO_TOG_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bits 8:9 - response control of endpoint's receiver to the OUT transaction
            #[inline(always)]
            pub fn mask_uep_r_res(&self) -> MASK_UEP_R_RES_R {
                MASK_UEP_R_RES_R::new(((self.bits >> 8) & 3) as u8)
            }
            ///Bit 10 - desired synchronization trigger bit for receiver of USB endpoint (handling OUT transactions)
            #[inline(always)]
            pub fn mask_uep_r_tog(&self) -> MASK_UEP_R_TOG_R {
                MASK_UEP_R_TOG_R::new(((self.bits >> 10) & 1) != 0)
            }
            ///Bit 11 - sync trigger bit aoto flip enable control
            #[inline(always)]
            pub fn uep_r_auto_tog(&self) -> UEP_R_AUTO_TOG_R {
                UEP_R_AUTO_TOG_R::new(((self.bits >> 11) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:1 - response control of endpoint's receiver to the IN transaction
            #[inline(always)]
            #[must_use]
            pub fn mask_uep_t_res(&mut self) -> MASK_UEP_T_RES_W<UEP4_CTRL_SPEC> {
                MASK_UEP_T_RES_W::new(self, 0)
            }
            ///Bit 2 - synchronization trigger bit for sender of USB endpoint (handling IN transactions)
            #[inline(always)]
            #[must_use]
            pub fn uep_t_tog(&mut self) -> UEP_T_TOG_W<UEP4_CTRL_SPEC> {
                UEP_T_TOG_W::new(self, 2)
            }
            ///Bit 3 - sync trigger bit aoto flip enable control
            #[inline(always)]
            #[must_use]
            pub fn uep_t_auto_tog(&mut self) -> UEP_T_AUTO_TOG_W<UEP4_CTRL_SPEC> {
                UEP_T_AUTO_TOG_W::new(self, 3)
            }
            ///Bits 8:9 - response control of endpoint's receiver to the OUT transaction
            #[inline(always)]
            #[must_use]
            pub fn mask_uep_r_res(&mut self) -> MASK_UEP_R_RES_W<UEP4_CTRL_SPEC> {
                MASK_UEP_R_RES_W::new(self, 8)
            }
            ///Bit 10 - desired synchronization trigger bit for receiver of USB endpoint (handling OUT transactions)
            #[inline(always)]
            #[must_use]
            pub fn mask_uep_r_tog(&mut self) -> MASK_UEP_R_TOG_W<UEP4_CTRL_SPEC> {
                MASK_UEP_R_TOG_W::new(self, 10)
            }
            ///Bit 11 - sync trigger bit aoto flip enable control
            #[inline(always)]
            #[must_use]
            pub fn uep_r_auto_tog(&mut self) -> UEP_R_AUTO_TOG_W<UEP4_CTRL_SPEC> {
                UEP_R_AUTO_TOG_W::new(self, 11)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///endpoint control register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`uep4_ctrl::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep4_ctrl::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct UEP4_CTRL_SPEC;
        impl crate::RegisterSpec for UEP4_CTRL_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`uep4_ctrl::R`](R) reader structure
        impl crate::Readable for UEP4_CTRL_SPEC {}
        ///`write(|w| ..)` method takes [`uep4_ctrl::W`](W) writer structure
        impl crate::Writable for UEP4_CTRL_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets UEP4_CTRL to value 0
        impl crate::Resettable for UEP4_CTRL_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///UEP5_CTRL (rw) register accessor: endpoint control register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`uep5_ctrl::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep5_ctrl::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@uep5_ctrl`]
    ///module
    pub type UEP5_CTRL = crate::Reg<uep5_ctrl::UEP5_CTRL_SPEC>;
    ///endpoint control register
    pub mod uep5_ctrl {
        ///Register `UEP5_CTRL` reader
        pub type R = crate::R<UEP5_CTRL_SPEC>;
        ///Register `UEP5_CTRL` writer
        pub type W = crate::W<UEP5_CTRL_SPEC>;
        ///Field `MASK_UEP_T_RES` reader - response control of endpoint's receiver to the IN transaction
        pub type MASK_UEP_T_RES_R = crate::FieldReader;
        ///Field `MASK_UEP_T_RES` writer - response control of endpoint's receiver to the IN transaction
        pub type MASK_UEP_T_RES_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `UEP_T_TOG` reader - synchronization trigger bit for sender of USB endpoint (handling IN transactions)
        pub type UEP_T_TOG_R = crate::BitReader;
        ///Field `UEP_T_TOG` writer - synchronization trigger bit for sender of USB endpoint (handling IN transactions)
        pub type UEP_T_TOG_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UEP_T_AUTO_TOG` reader - sync trigger bit aoto flip enable control
        pub type UEP_T_AUTO_TOG_R = crate::BitReader;
        ///Field `UEP_T_AUTO_TOG` writer - sync trigger bit aoto flip enable control
        pub type UEP_T_AUTO_TOG_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `MASK_UEP_R_RES` reader - response control of endpoint's receiver to the OUT transaction
        pub type MASK_UEP_R_RES_R = crate::FieldReader;
        ///Field `MASK_UEP_R_RES` writer - response control of endpoint's receiver to the OUT transaction
        pub type MASK_UEP_R_RES_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `MASK_UEP_R_TOG` reader - desired synchronization trigger bit for receiver of USB endpoint (handling OUT transactions)
        pub type MASK_UEP_R_TOG_R = crate::BitReader;
        ///Field `MASK_UEP_R_TOG` writer - desired synchronization trigger bit for receiver of USB endpoint (handling OUT transactions)
        pub type MASK_UEP_R_TOG_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UEP_R_AUTO_TOG` reader - sync trigger bit aoto flip enable control
        pub type UEP_R_AUTO_TOG_R = crate::BitReader;
        ///Field `UEP_R_AUTO_TOG` writer - sync trigger bit aoto flip enable control
        pub type UEP_R_AUTO_TOG_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bits 0:1 - response control of endpoint's receiver to the IN transaction
            #[inline(always)]
            pub fn mask_uep_t_res(&self) -> MASK_UEP_T_RES_R {
                MASK_UEP_T_RES_R::new((self.bits & 3) as u8)
            }
            ///Bit 2 - synchronization trigger bit for sender of USB endpoint (handling IN transactions)
            #[inline(always)]
            pub fn uep_t_tog(&self) -> UEP_T_TOG_R {
                UEP_T_TOG_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - sync trigger bit aoto flip enable control
            #[inline(always)]
            pub fn uep_t_auto_tog(&self) -> UEP_T_AUTO_TOG_R {
                UEP_T_AUTO_TOG_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bits 8:9 - response control of endpoint's receiver to the OUT transaction
            #[inline(always)]
            pub fn mask_uep_r_res(&self) -> MASK_UEP_R_RES_R {
                MASK_UEP_R_RES_R::new(((self.bits >> 8) & 3) as u8)
            }
            ///Bit 10 - desired synchronization trigger bit for receiver of USB endpoint (handling OUT transactions)
            #[inline(always)]
            pub fn mask_uep_r_tog(&self) -> MASK_UEP_R_TOG_R {
                MASK_UEP_R_TOG_R::new(((self.bits >> 10) & 1) != 0)
            }
            ///Bit 11 - sync trigger bit aoto flip enable control
            #[inline(always)]
            pub fn uep_r_auto_tog(&self) -> UEP_R_AUTO_TOG_R {
                UEP_R_AUTO_TOG_R::new(((self.bits >> 11) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:1 - response control of endpoint's receiver to the IN transaction
            #[inline(always)]
            #[must_use]
            pub fn mask_uep_t_res(&mut self) -> MASK_UEP_T_RES_W<UEP5_CTRL_SPEC> {
                MASK_UEP_T_RES_W::new(self, 0)
            }
            ///Bit 2 - synchronization trigger bit for sender of USB endpoint (handling IN transactions)
            #[inline(always)]
            #[must_use]
            pub fn uep_t_tog(&mut self) -> UEP_T_TOG_W<UEP5_CTRL_SPEC> {
                UEP_T_TOG_W::new(self, 2)
            }
            ///Bit 3 - sync trigger bit aoto flip enable control
            #[inline(always)]
            #[must_use]
            pub fn uep_t_auto_tog(&mut self) -> UEP_T_AUTO_TOG_W<UEP5_CTRL_SPEC> {
                UEP_T_AUTO_TOG_W::new(self, 3)
            }
            ///Bits 8:9 - response control of endpoint's receiver to the OUT transaction
            #[inline(always)]
            #[must_use]
            pub fn mask_uep_r_res(&mut self) -> MASK_UEP_R_RES_W<UEP5_CTRL_SPEC> {
                MASK_UEP_R_RES_W::new(self, 8)
            }
            ///Bit 10 - desired synchronization trigger bit for receiver of USB endpoint (handling OUT transactions)
            #[inline(always)]
            #[must_use]
            pub fn mask_uep_r_tog(&mut self) -> MASK_UEP_R_TOG_W<UEP5_CTRL_SPEC> {
                MASK_UEP_R_TOG_W::new(self, 10)
            }
            ///Bit 11 - sync trigger bit aoto flip enable control
            #[inline(always)]
            #[must_use]
            pub fn uep_r_auto_tog(&mut self) -> UEP_R_AUTO_TOG_W<UEP5_CTRL_SPEC> {
                UEP_R_AUTO_TOG_W::new(self, 11)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///endpoint control register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`uep5_ctrl::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep5_ctrl::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct UEP5_CTRL_SPEC;
        impl crate::RegisterSpec for UEP5_CTRL_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`uep5_ctrl::R`](R) reader structure
        impl crate::Readable for UEP5_CTRL_SPEC {}
        ///`write(|w| ..)` method takes [`uep5_ctrl::W`](W) writer structure
        impl crate::Writable for UEP5_CTRL_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets UEP5_CTRL to value 0
        impl crate::Resettable for UEP5_CTRL_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///UEP6_CTRL (rw) register accessor: endpoint control register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`uep6_ctrl::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep6_ctrl::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@uep6_ctrl`]
    ///module
    pub type UEP6_CTRL = crate::Reg<uep6_ctrl::UEP6_CTRL_SPEC>;
    ///endpoint control register
    pub mod uep6_ctrl {
        ///Register `UEP6_CTRL` reader
        pub type R = crate::R<UEP6_CTRL_SPEC>;
        ///Register `UEP6_CTRL` writer
        pub type W = crate::W<UEP6_CTRL_SPEC>;
        ///Field `MASK_UEP_T_RES` reader - response control of endpoint's receiver to the IN transaction
        pub type MASK_UEP_T_RES_R = crate::FieldReader;
        ///Field `MASK_UEP_T_RES` writer - response control of endpoint's receiver to the IN transaction
        pub type MASK_UEP_T_RES_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `UEP_T_TOG` reader - synchronization trigger bit for sender of USB endpoint (handling IN transactions)
        pub type UEP_T_TOG_R = crate::BitReader;
        ///Field `UEP_T_TOG` writer - synchronization trigger bit for sender of USB endpoint (handling IN transactions)
        pub type UEP_T_TOG_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UEP_T_AUTO_TOG` reader - sync trigger bit aoto flip enable control
        pub type UEP_T_AUTO_TOG_R = crate::BitReader;
        ///Field `UEP_T_AUTO_TOG` writer - sync trigger bit aoto flip enable control
        pub type UEP_T_AUTO_TOG_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `MASK_UEP_R_RES` reader - response control of endpoint's receiver to the OUT transaction
        pub type MASK_UEP_R_RES_R = crate::FieldReader;
        ///Field `MASK_UEP_R_RES` writer - response control of endpoint's receiver to the OUT transaction
        pub type MASK_UEP_R_RES_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `MASK_UEP_R_TOG` reader - desired synchronization trigger bit for receiver of USB endpoint (handling OUT transactions)
        pub type MASK_UEP_R_TOG_R = crate::BitReader;
        ///Field `MASK_UEP_R_TOG` writer - desired synchronization trigger bit for receiver of USB endpoint (handling OUT transactions)
        pub type MASK_UEP_R_TOG_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UEP_R_AUTO_TOG` reader - sync trigger bit aoto flip enable control
        pub type UEP_R_AUTO_TOG_R = crate::BitReader;
        ///Field `UEP_R_AUTO_TOG` writer - sync trigger bit aoto flip enable control
        pub type UEP_R_AUTO_TOG_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bits 0:1 - response control of endpoint's receiver to the IN transaction
            #[inline(always)]
            pub fn mask_uep_t_res(&self) -> MASK_UEP_T_RES_R {
                MASK_UEP_T_RES_R::new((self.bits & 3) as u8)
            }
            ///Bit 2 - synchronization trigger bit for sender of USB endpoint (handling IN transactions)
            #[inline(always)]
            pub fn uep_t_tog(&self) -> UEP_T_TOG_R {
                UEP_T_TOG_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - sync trigger bit aoto flip enable control
            #[inline(always)]
            pub fn uep_t_auto_tog(&self) -> UEP_T_AUTO_TOG_R {
                UEP_T_AUTO_TOG_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bits 8:9 - response control of endpoint's receiver to the OUT transaction
            #[inline(always)]
            pub fn mask_uep_r_res(&self) -> MASK_UEP_R_RES_R {
                MASK_UEP_R_RES_R::new(((self.bits >> 8) & 3) as u8)
            }
            ///Bit 10 - desired synchronization trigger bit for receiver of USB endpoint (handling OUT transactions)
            #[inline(always)]
            pub fn mask_uep_r_tog(&self) -> MASK_UEP_R_TOG_R {
                MASK_UEP_R_TOG_R::new(((self.bits >> 10) & 1) != 0)
            }
            ///Bit 11 - sync trigger bit aoto flip enable control
            #[inline(always)]
            pub fn uep_r_auto_tog(&self) -> UEP_R_AUTO_TOG_R {
                UEP_R_AUTO_TOG_R::new(((self.bits >> 11) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:1 - response control of endpoint's receiver to the IN transaction
            #[inline(always)]
            #[must_use]
            pub fn mask_uep_t_res(&mut self) -> MASK_UEP_T_RES_W<UEP6_CTRL_SPEC> {
                MASK_UEP_T_RES_W::new(self, 0)
            }
            ///Bit 2 - synchronization trigger bit for sender of USB endpoint (handling IN transactions)
            #[inline(always)]
            #[must_use]
            pub fn uep_t_tog(&mut self) -> UEP_T_TOG_W<UEP6_CTRL_SPEC> {
                UEP_T_TOG_W::new(self, 2)
            }
            ///Bit 3 - sync trigger bit aoto flip enable control
            #[inline(always)]
            #[must_use]
            pub fn uep_t_auto_tog(&mut self) -> UEP_T_AUTO_TOG_W<UEP6_CTRL_SPEC> {
                UEP_T_AUTO_TOG_W::new(self, 3)
            }
            ///Bits 8:9 - response control of endpoint's receiver to the OUT transaction
            #[inline(always)]
            #[must_use]
            pub fn mask_uep_r_res(&mut self) -> MASK_UEP_R_RES_W<UEP6_CTRL_SPEC> {
                MASK_UEP_R_RES_W::new(self, 8)
            }
            ///Bit 10 - desired synchronization trigger bit for receiver of USB endpoint (handling OUT transactions)
            #[inline(always)]
            #[must_use]
            pub fn mask_uep_r_tog(&mut self) -> MASK_UEP_R_TOG_W<UEP6_CTRL_SPEC> {
                MASK_UEP_R_TOG_W::new(self, 10)
            }
            ///Bit 11 - sync trigger bit aoto flip enable control
            #[inline(always)]
            #[must_use]
            pub fn uep_r_auto_tog(&mut self) -> UEP_R_AUTO_TOG_W<UEP6_CTRL_SPEC> {
                UEP_R_AUTO_TOG_W::new(self, 11)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///endpoint control register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`uep6_ctrl::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep6_ctrl::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct UEP6_CTRL_SPEC;
        impl crate::RegisterSpec for UEP6_CTRL_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`uep6_ctrl::R`](R) reader structure
        impl crate::Readable for UEP6_CTRL_SPEC {}
        ///`write(|w| ..)` method takes [`uep6_ctrl::W`](W) writer structure
        impl crate::Writable for UEP6_CTRL_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets UEP6_CTRL to value 0
        impl crate::Resettable for UEP6_CTRL_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///UEP7_CTRL (rw) register accessor: endpoint control register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`uep7_ctrl::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep7_ctrl::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@uep7_ctrl`]
    ///module
    pub type UEP7_CTRL = crate::Reg<uep7_ctrl::UEP7_CTRL_SPEC>;
    ///endpoint control register
    pub mod uep7_ctrl {
        ///Register `UEP7_CTRL` reader
        pub type R = crate::R<UEP7_CTRL_SPEC>;
        ///Register `UEP7_CTRL` writer
        pub type W = crate::W<UEP7_CTRL_SPEC>;
        ///Field `MASK_UEP_T_RES` reader - response control of endpoint's receiver to the IN transaction
        pub type MASK_UEP_T_RES_R = crate::FieldReader;
        ///Field `MASK_UEP_T_RES` writer - response control of endpoint's receiver to the IN transaction
        pub type MASK_UEP_T_RES_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `UEP_T_TOG` reader - synchronization trigger bit for sender of USB endpoint (handling IN transactions)
        pub type UEP_T_TOG_R = crate::BitReader;
        ///Field `UEP_T_TOG` writer - synchronization trigger bit for sender of USB endpoint (handling IN transactions)
        pub type UEP_T_TOG_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UEP_T_AUTO_TOG` reader - sync trigger bit aoto flip enable control
        pub type UEP_T_AUTO_TOG_R = crate::BitReader;
        ///Field `UEP_T_AUTO_TOG` writer - sync trigger bit aoto flip enable control
        pub type UEP_T_AUTO_TOG_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `MASK_UEP_R_RES` reader - response control of endpoint's receiver to the OUT transaction
        pub type MASK_UEP_R_RES_R = crate::FieldReader;
        ///Field `MASK_UEP_R_RES` writer - response control of endpoint's receiver to the OUT transaction
        pub type MASK_UEP_R_RES_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `MASK_UEP_R_TOG` reader - desired synchronization trigger bit for receiver of USB endpoint (handling OUT transactions)
        pub type MASK_UEP_R_TOG_R = crate::BitReader;
        ///Field `MASK_UEP_R_TOG` writer - desired synchronization trigger bit for receiver of USB endpoint (handling OUT transactions)
        pub type MASK_UEP_R_TOG_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UEP_R_AUTO_TOG` reader - sync trigger bit aoto flip enable control
        pub type UEP_R_AUTO_TOG_R = crate::BitReader;
        ///Field `UEP_R_AUTO_TOG` writer - sync trigger bit aoto flip enable control
        pub type UEP_R_AUTO_TOG_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bits 0:1 - response control of endpoint's receiver to the IN transaction
            #[inline(always)]
            pub fn mask_uep_t_res(&self) -> MASK_UEP_T_RES_R {
                MASK_UEP_T_RES_R::new((self.bits & 3) as u8)
            }
            ///Bit 2 - synchronization trigger bit for sender of USB endpoint (handling IN transactions)
            #[inline(always)]
            pub fn uep_t_tog(&self) -> UEP_T_TOG_R {
                UEP_T_TOG_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - sync trigger bit aoto flip enable control
            #[inline(always)]
            pub fn uep_t_auto_tog(&self) -> UEP_T_AUTO_TOG_R {
                UEP_T_AUTO_TOG_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bits 8:9 - response control of endpoint's receiver to the OUT transaction
            #[inline(always)]
            pub fn mask_uep_r_res(&self) -> MASK_UEP_R_RES_R {
                MASK_UEP_R_RES_R::new(((self.bits >> 8) & 3) as u8)
            }
            ///Bit 10 - desired synchronization trigger bit for receiver of USB endpoint (handling OUT transactions)
            #[inline(always)]
            pub fn mask_uep_r_tog(&self) -> MASK_UEP_R_TOG_R {
                MASK_UEP_R_TOG_R::new(((self.bits >> 10) & 1) != 0)
            }
            ///Bit 11 - sync trigger bit aoto flip enable control
            #[inline(always)]
            pub fn uep_r_auto_tog(&self) -> UEP_R_AUTO_TOG_R {
                UEP_R_AUTO_TOG_R::new(((self.bits >> 11) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:1 - response control of endpoint's receiver to the IN transaction
            #[inline(always)]
            #[must_use]
            pub fn mask_uep_t_res(&mut self) -> MASK_UEP_T_RES_W<UEP7_CTRL_SPEC> {
                MASK_UEP_T_RES_W::new(self, 0)
            }
            ///Bit 2 - synchronization trigger bit for sender of USB endpoint (handling IN transactions)
            #[inline(always)]
            #[must_use]
            pub fn uep_t_tog(&mut self) -> UEP_T_TOG_W<UEP7_CTRL_SPEC> {
                UEP_T_TOG_W::new(self, 2)
            }
            ///Bit 3 - sync trigger bit aoto flip enable control
            #[inline(always)]
            #[must_use]
            pub fn uep_t_auto_tog(&mut self) -> UEP_T_AUTO_TOG_W<UEP7_CTRL_SPEC> {
                UEP_T_AUTO_TOG_W::new(self, 3)
            }
            ///Bits 8:9 - response control of endpoint's receiver to the OUT transaction
            #[inline(always)]
            #[must_use]
            pub fn mask_uep_r_res(&mut self) -> MASK_UEP_R_RES_W<UEP7_CTRL_SPEC> {
                MASK_UEP_R_RES_W::new(self, 8)
            }
            ///Bit 10 - desired synchronization trigger bit for receiver of USB endpoint (handling OUT transactions)
            #[inline(always)]
            #[must_use]
            pub fn mask_uep_r_tog(&mut self) -> MASK_UEP_R_TOG_W<UEP7_CTRL_SPEC> {
                MASK_UEP_R_TOG_W::new(self, 10)
            }
            ///Bit 11 - sync trigger bit aoto flip enable control
            #[inline(always)]
            #[must_use]
            pub fn uep_r_auto_tog(&mut self) -> UEP_R_AUTO_TOG_W<UEP7_CTRL_SPEC> {
                UEP_R_AUTO_TOG_W::new(self, 11)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///endpoint control register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`uep7_ctrl::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep7_ctrl::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct UEP7_CTRL_SPEC;
        impl crate::RegisterSpec for UEP7_CTRL_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`uep7_ctrl::R`](R) reader structure
        impl crate::Readable for UEP7_CTRL_SPEC {}
        ///`write(|w| ..)` method takes [`uep7_ctrl::W`](W) writer structure
        impl crate::Writable for UEP7_CTRL_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets UEP7_CTRL to value 0
        impl crate::Resettable for UEP7_CTRL_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
}
///Systick registers, 64-bit downcounter for QingKeV4
pub struct SYSTICK {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for SYSTICK {}
impl SYSTICK {
    ///Pointer to the register block
    pub const PTR: *const systick::RegisterBlock = 0xe000_f000 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const systick::RegisterBlock {
        Self::PTR
    }
    /// Steal an instance of this peripheral
    ///
    /// # Safety
    ///
    /// Ensure that the new instance of the peripheral cannot be used in a way
    /// that may race with any existing instances, for example by only
    /// accessing read-only or write-only registers, or by consuming the
    /// original peripheral and using critical sections to coordinate
    /// access between multiple new instances.
    ///
    /// Additionally, other software such as HALs may rely on only one
    /// peripheral instance existing to ensure memory safety; ensure
    /// no stolen instances are passed to such software.
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for SYSTICK {
    type Target = systick::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for SYSTICK {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("SYSTICK").finish()
    }
}
///Systick registers, 64-bit downcounter for QingKeV4
pub mod systick {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        ctlr: CTLR,
        sr: SR,
        _reserved_2_cnt: [u8; 0x08],
        _reserved_3_cmp: [u8; 0x08],
    }
    impl RegisterBlock {
        ///0x00 - System count control register
        #[inline(always)]
        pub const fn ctlr(&self) -> &CTLR {
            &self.ctlr
        }
        ///0x04 - System count status register
        #[inline(always)]
        pub const fn sr(&self) -> &SR {
            &self.sr
        }
        ///0x08 - System counter register, lower 32-bit
        #[inline(always)]
        pub const fn cntl(&self) -> &CNTL {
            unsafe { &*(self as *const Self).cast::<u8>().add(8).cast() }
        }
        ///0x08..0x10 - System counter register
        #[inline(always)]
        pub const fn cnt(&self) -> &CNT {
            unsafe { &*(self as *const Self).cast::<u8>().add(8).cast() }
        }
        ///0x10 - System count compare register, lower 32-bit
        #[inline(always)]
        pub const fn cmpl(&self) -> &CMPL {
            unsafe { &*(self as *const Self).cast::<u8>().add(16).cast() }
        }
        ///0x10..0x18 - System count compare register
        #[inline(always)]
        pub const fn cmp(&self) -> &CMP {
            unsafe { &*(self as *const Self).cast::<u8>().add(16).cast() }
        }
    }
    ///CTLR (rw) register accessor: System count control register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`ctlr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ctlr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@ctlr`]
    ///module
    pub type CTLR = crate::Reg<ctlr::CTLR_SPEC>;
    ///System count control register
    pub mod ctlr {
        ///Register `CTLR` reader
        pub type R = crate::R<CTLR_SPEC>;
        ///Register `CTLR` writer
        pub type W = crate::W<CTLR_SPEC>;
        ///Field `STE` reader - Counter enable control bit
        pub type STE_R = crate::BitReader;
        ///Field `STE` writer - Counter enable control bit
        pub type STE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `STIE` reader - Counter interrupt enable control bit
        pub type STIE_R = crate::BitReader;
        ///Field `STIE` writer - Counter interrupt enable control bit
        pub type STIE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `STCLK` reader - Counter system clock sourse selection bit
        pub type STCLK_R = crate::BitReader<STCLK_A>;
        ///Counter system clock sourse selection bit
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum STCLK_A {
            ///0: HCLK/8
            HclkDiv8 = 0,
            ///1: HCLK
            Hclk = 1,
        }
        impl From<STCLK_A> for bool {
            #[inline(always)]
            fn from(variant: STCLK_A) -> Self {
                variant as u8 != 0
            }
        }
        impl STCLK_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub const fn variant(&self) -> STCLK_A {
                match self.bits {
                    false => STCLK_A::HclkDiv8,
                    true => STCLK_A::Hclk,
                }
            }
            ///HCLK/8
            #[inline(always)]
            pub fn is_hclk_div8(&self) -> bool {
                *self == STCLK_A::HclkDiv8
            }
            ///HCLK
            #[inline(always)]
            pub fn is_hclk(&self) -> bool {
                *self == STCLK_A::Hclk
            }
        }
        ///Field `STCLK` writer - Counter system clock sourse selection bit
        pub type STCLK_W<'a, REG> = crate::BitWriter<'a, REG, STCLK_A>;
        impl<'a, REG> STCLK_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            ///HCLK/8
            #[inline(always)]
            pub fn hclk_div8(self) -> &'a mut crate::W<REG> {
                self.variant(STCLK_A::HclkDiv8)
            }
            ///HCLK
            #[inline(always)]
            pub fn hclk(self) -> &'a mut crate::W<REG> {
                self.variant(STCLK_A::Hclk)
            }
        }
        ///Field `STRE` reader - Auto reload count enable bit
        pub type STRE_R = crate::BitReader;
        ///Field `STRE` writer - Auto reload count enable bit
        pub type STRE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `MODE` reader - Counter mode
        pub type MODE_R = crate::BitReader<MODE_A>;
        ///Counter mode
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum MODE_A {
            ///0: Upcount
            Upcount = 0,
            ///1: Downcount
            Downcount = 1,
        }
        impl From<MODE_A> for bool {
            #[inline(always)]
            fn from(variant: MODE_A) -> Self {
                variant as u8 != 0
            }
        }
        impl MODE_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub const fn variant(&self) -> MODE_A {
                match self.bits {
                    false => MODE_A::Upcount,
                    true => MODE_A::Downcount,
                }
            }
            ///Upcount
            #[inline(always)]
            pub fn is_upcount(&self) -> bool {
                *self == MODE_A::Upcount
            }
            ///Downcount
            #[inline(always)]
            pub fn is_downcount(&self) -> bool {
                *self == MODE_A::Downcount
            }
        }
        ///Field `MODE` writer - Counter mode
        pub type MODE_W<'a, REG> = crate::BitWriter<'a, REG, MODE_A>;
        impl<'a, REG> MODE_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            ///Upcount
            #[inline(always)]
            pub fn upcount(self) -> &'a mut crate::W<REG> {
                self.variant(MODE_A::Upcount)
            }
            ///Downcount
            #[inline(always)]
            pub fn downcount(self) -> &'a mut crate::W<REG> {
                self.variant(MODE_A::Downcount)
            }
        }
        ///Field `INIT` reader - Counter initial value update
        pub type INIT_R = crate::BitReader;
        ///Field `INIT` writer - Counter initial value update
        pub type INIT_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `SWIE` reader - Software interrupt enable
        pub type SWIE_R = crate::BitReader;
        ///Field `SWIE` writer - Software interrupt enable
        pub type SWIE_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - Counter enable control bit
            #[inline(always)]
            pub fn ste(&self) -> STE_R {
                STE_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Counter interrupt enable control bit
            #[inline(always)]
            pub fn stie(&self) -> STIE_R {
                STIE_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - Counter system clock sourse selection bit
            #[inline(always)]
            pub fn stclk(&self) -> STCLK_R {
                STCLK_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - Auto reload count enable bit
            #[inline(always)]
            pub fn stre(&self) -> STRE_R {
                STRE_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - Counter mode
            #[inline(always)]
            pub fn mode(&self) -> MODE_R {
                MODE_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - Counter initial value update
            #[inline(always)]
            pub fn init(&self) -> INIT_R {
                INIT_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 31 - Software interrupt enable
            #[inline(always)]
            pub fn swie(&self) -> SWIE_R {
                SWIE_R::new(((self.bits >> 31) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - Counter enable control bit
            #[inline(always)]
            #[must_use]
            pub fn ste(&mut self) -> STE_W<CTLR_SPEC> {
                STE_W::new(self, 0)
            }
            ///Bit 1 - Counter interrupt enable control bit
            #[inline(always)]
            #[must_use]
            pub fn stie(&mut self) -> STIE_W<CTLR_SPEC> {
                STIE_W::new(self, 1)
            }
            ///Bit 2 - Counter system clock sourse selection bit
            #[inline(always)]
            #[must_use]
            pub fn stclk(&mut self) -> STCLK_W<CTLR_SPEC> {
                STCLK_W::new(self, 2)
            }
            ///Bit 3 - Auto reload count enable bit
            #[inline(always)]
            #[must_use]
            pub fn stre(&mut self) -> STRE_W<CTLR_SPEC> {
                STRE_W::new(self, 3)
            }
            ///Bit 4 - Counter mode
            #[inline(always)]
            #[must_use]
            pub fn mode(&mut self) -> MODE_W<CTLR_SPEC> {
                MODE_W::new(self, 4)
            }
            ///Bit 5 - Counter initial value update
            #[inline(always)]
            #[must_use]
            pub fn init(&mut self) -> INIT_W<CTLR_SPEC> {
                INIT_W::new(self, 5)
            }
            ///Bit 31 - Software interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn swie(&mut self) -> SWIE_W<CTLR_SPEC> {
                SWIE_W::new(self, 31)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///System count control register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`ctlr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ctlr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct CTLR_SPEC;
        impl crate::RegisterSpec for CTLR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`ctlr::R`](R) reader structure
        impl crate::Readable for CTLR_SPEC {}
        ///`write(|w| ..)` method takes [`ctlr::W`](W) writer structure
        impl crate::Writable for CTLR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets CTLR to value 0
        impl crate::Resettable for CTLR_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///SR (rw) register accessor: System count status register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`sr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`sr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@sr`]
    ///module
    pub type SR = crate::Reg<sr::SR_SPEC>;
    ///System count status register
    pub mod sr {
        ///Register `SR` reader
        pub type R = crate::R<SR_SPEC>;
        ///Register `SR` writer
        pub type W = crate::W<SR_SPEC>;
        ///Field `CNTIF` reader - Count value compare flag
        pub type CNTIF_R = crate::BitReader;
        ///Field `CNTIF` writer - Count value compare flag
        pub type CNTIF_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - Count value compare flag
            #[inline(always)]
            pub fn cntif(&self) -> CNTIF_R {
                CNTIF_R::new((self.bits & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - Count value compare flag
            #[inline(always)]
            #[must_use]
            pub fn cntif(&mut self) -> CNTIF_W<SR_SPEC> {
                CNTIF_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///System count status register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`sr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`sr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct SR_SPEC;
        impl crate::RegisterSpec for SR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`sr::R`](R) reader structure
        impl crate::Readable for SR_SPEC {}
        ///`write(|w| ..)` method takes [`sr::W`](W) writer structure
        impl crate::Writable for SR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets SR to value 0
        impl crate::Resettable for SR_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///CNT (rw) register accessor: System counter register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`cnt::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cnt::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@cnt`]
    ///module
    pub type CNT = crate::Reg<cnt::CNT_SPEC>;
    ///System counter register
    pub mod cnt {
        ///Register `CNT` reader
        pub type R = crate::R<CNT_SPEC>;
        ///Register `CNT` writer
        pub type W = crate::W<CNT_SPEC>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<CNT_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                core::fmt::Debug::fmt(&self.read(), f)
            }
        }
        impl W {
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u64) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///System counter register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`cnt::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cnt::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct CNT_SPEC;
        impl crate::RegisterSpec for CNT_SPEC {
            type Ux = u64;
        }
        ///`read()` method returns [`cnt::R`](R) reader structure
        impl crate::Readable for CNT_SPEC {}
        ///`write(|w| ..)` method takes [`cnt::W`](W) writer structure
        impl crate::Writable for CNT_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u64 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u64 = 0;
        }
        ///`reset()` method sets CNT to value 0
        impl crate::Resettable for CNT_SPEC {
            const RESET_VALUE: u64 = 0;
        }
    }
    ///CNTL (rw) register accessor: System counter register, lower 32-bit
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`cntl::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cntl::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@cntl`]
    ///module
    pub type CNTL = crate::Reg<cntl::CNTL_SPEC>;
    ///System counter register, lower 32-bit
    pub mod cntl {
        ///Register `CNTL` reader
        pub type R = crate::R<CNTL_SPEC>;
        ///Register `CNTL` writer
        pub type W = crate::W<CNTL_SPEC>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<CNTL_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                core::fmt::Debug::fmt(&self.read(), f)
            }
        }
        impl W {
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///System counter register, lower 32-bit
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`cntl::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cntl::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct CNTL_SPEC;
        impl crate::RegisterSpec for CNTL_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`cntl::R`](R) reader structure
        impl crate::Readable for CNTL_SPEC {}
        ///`write(|w| ..)` method takes [`cntl::W`](W) writer structure
        impl crate::Writable for CNTL_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets CNTL to value 0
        impl crate::Resettable for CNTL_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///CMP (rw) register accessor: System count compare register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`cmp::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cmp::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@cmp`]
    ///module
    pub type CMP = crate::Reg<cmp::CMP_SPEC>;
    ///System count compare register
    pub mod cmp {
        ///Register `CMP` reader
        pub type R = crate::R<CMP_SPEC>;
        ///Register `CMP` writer
        pub type W = crate::W<CMP_SPEC>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<CMP_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                core::fmt::Debug::fmt(&self.read(), f)
            }
        }
        impl W {
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u64) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///System count compare register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`cmp::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cmp::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct CMP_SPEC;
        impl crate::RegisterSpec for CMP_SPEC {
            type Ux = u64;
        }
        ///`read()` method returns [`cmp::R`](R) reader structure
        impl crate::Readable for CMP_SPEC {}
        ///`write(|w| ..)` method takes [`cmp::W`](W) writer structure
        impl crate::Writable for CMP_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u64 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u64 = 0;
        }
        ///`reset()` method sets CMP to value 0
        impl crate::Resettable for CMP_SPEC {
            const RESET_VALUE: u64 = 0;
        }
    }
    ///CMPL (rw) register accessor: System count compare register, lower 32-bit
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`cmpl::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cmpl::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@cmpl`]
    ///module
    pub type CMPL = crate::Reg<cmpl::CMPL_SPEC>;
    ///System count compare register, lower 32-bit
    pub mod cmpl {
        ///Register `CMPL` reader
        pub type R = crate::R<CMPL_SPEC>;
        ///Register `CMPL` writer
        pub type W = crate::W<CMPL_SPEC>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<CMPL_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                core::fmt::Debug::fmt(&self.read(), f)
            }
        }
        impl W {
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///System count compare register, lower 32-bit
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`cmpl::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cmpl::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct CMPL_SPEC;
        impl crate::RegisterSpec for CMPL_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`cmpl::R`](R) reader structure
        impl crate::Readable for CMPL_SPEC {}
        ///`write(|w| ..)` method takes [`cmpl::W`](W) writer structure
        impl crate::Writable for CMPL_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets CMPL to value 0
        impl crate::Resettable for CMPL_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
}
#[no_mangle]
static mut DEVICE_PERIPHERALS: bool = false;
/// All the peripherals.
#[allow(non_snake_case)]
pub struct Peripherals {
    ///CAN
    pub CAN: CAN,
    ///PWR
    pub PWR: PWR,
    ///RCC
    pub RCC: RCC,
    ///EXTEN
    pub EXTEN: EXTEN,
    ///OPA
    pub OPA: OPA,
    ///GPIOA
    pub GPIOA: GPIOA,
    ///GPIOB
    pub GPIOB: GPIOB,
    ///GPIOC
    pub GPIOC: GPIOC,
    ///GPIOD
    pub GPIOD: GPIOD,
    ///AFIO
    pub AFIO: AFIO,
    ///EXTI
    pub EXTI: EXTI,
    ///DMA
    pub DMA: DMA,
    ///RTC
    pub RTC: RTC,
    ///BKP
    pub BKP: BKP,
    ///IWDG
    pub IWDG: IWDG,
    ///WWDG
    pub WWDG: WWDG,
    ///TIM1
    pub TIM1: TIM1,
    ///TIM2
    pub TIM2: TIM2,
    ///TIM3
    pub TIM3: TIM3,
    ///TIM4
    pub TIM4: TIM4,
    ///I2C1
    pub I2C1: I2C1,
    ///I2C2
    pub I2C2: I2C2,
    ///SPI1
    pub SPI1: SPI1,
    ///SPI2
    pub SPI2: SPI2,
    ///USART1
    pub USART1: USART1,
    ///USART2
    pub USART2: USART2,
    ///USART3
    pub USART3: USART3,
    ///UART4
    pub UART4: UART4,
    ///ADC__TKEY
    pub ADC__TKEY: ADC__TKEY,
    ///DBG
    pub DBG: DBG,
    ///CRC
    pub CRC: CRC,
    ///FLASH
    pub FLASH: FLASH,
    ///PFIC
    pub PFIC: PFIC,
    ///LPTIM
    pub LPTIM: LPTIM,
    ///USBPD
    pub USBPD: USBPD,
    ///USBFS
    pub USBFS: USBFS,
    ///SYSTICK
    pub SYSTICK: SYSTICK,
}
impl Peripherals {
    /// Returns all the peripherals *once*.
    #[cfg(feature = "critical-section")]
    #[inline]
    pub fn take() -> Option<Self> {
        critical_section::with(|_| {
            if unsafe { DEVICE_PERIPHERALS } {
                return None;
            }
            Some(unsafe { Peripherals::steal() })
        })
    }
    /// Unchecked version of `Peripherals::take`.
    ///
    /// # Safety
    ///
    /// Each of the returned peripherals must be used at most once.
    #[inline]
    pub unsafe fn steal() -> Self {
        DEVICE_PERIPHERALS = true;
        Peripherals {
            CAN: CAN {
                _marker: PhantomData,
            },
            PWR: PWR {
                _marker: PhantomData,
            },
            RCC: RCC {
                _marker: PhantomData,
            },
            EXTEN: EXTEN {
                _marker: PhantomData,
            },
            OPA: OPA {
                _marker: PhantomData,
            },
            GPIOA: GPIOA {
                _marker: PhantomData,
            },
            GPIOB: GPIOB {
                _marker: PhantomData,
            },
            GPIOC: GPIOC {
                _marker: PhantomData,
            },
            GPIOD: GPIOD {
                _marker: PhantomData,
            },
            AFIO: AFIO {
                _marker: PhantomData,
            },
            EXTI: EXTI {
                _marker: PhantomData,
            },
            DMA: DMA {
                _marker: PhantomData,
            },
            RTC: RTC {
                _marker: PhantomData,
            },
            BKP: BKP {
                _marker: PhantomData,
            },
            IWDG: IWDG {
                _marker: PhantomData,
            },
            WWDG: WWDG {
                _marker: PhantomData,
            },
            TIM1: TIM1 {
                _marker: PhantomData,
            },
            TIM2: TIM2 {
                _marker: PhantomData,
            },
            TIM3: TIM3 {
                _marker: PhantomData,
            },
            TIM4: TIM4 {
                _marker: PhantomData,
            },
            I2C1: I2C1 {
                _marker: PhantomData,
            },
            I2C2: I2C2 {
                _marker: PhantomData,
            },
            SPI1: SPI1 {
                _marker: PhantomData,
            },
            SPI2: SPI2 {
                _marker: PhantomData,
            },
            USART1: USART1 {
                _marker: PhantomData,
            },
            USART2: USART2 {
                _marker: PhantomData,
            },
            USART3: USART3 {
                _marker: PhantomData,
            },
            UART4: UART4 {
                _marker: PhantomData,
            },
            ADC__TKEY: ADC__TKEY {
                _marker: PhantomData,
            },
            DBG: DBG {
                _marker: PhantomData,
            },
            CRC: CRC {
                _marker: PhantomData,
            },
            FLASH: FLASH {
                _marker: PhantomData,
            },
            PFIC: PFIC {
                _marker: PhantomData,
            },
            LPTIM: LPTIM {
                _marker: PhantomData,
            },
            USBPD: USBPD {
                _marker: PhantomData,
            },
            USBFS: USBFS {
                _marker: PhantomData,
            },
            SYSTICK: SYSTICK {
                _marker: PhantomData,
            },
        }
    }
}
