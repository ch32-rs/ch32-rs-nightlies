//!Peripheral access API for CH573SFR microcontrollers (generated using svd2rust v0.31.5 ( ))
//!
//!You can find an overview of the generated API [here].
//!
//!API features to be included in the [next]
//!svd2rust release can be generated by cloning the svd2rust [repository], checking out the above commit, and running `cargo doc --open`.
//!
//![here]: https://docs.rs/svd2rust/0.31.5/svd2rust/#peripheral-api
//![next]: https://github.com/rust-embedded/svd2rust/blob/master/CHANGELOG.md#unreleased
//![repository]: https://github.com/rust-embedded/svd2rust
use core::marker::PhantomData;
use core::ops::Deref;
///Number available in the NVIC for configuring priority
pub const NVIC_PRIO_BITS: u8 = 2;
#[cfg(feature = "rt")]
extern "C" {
    fn TMR0();
    fn GPIO_A();
    fn GPIO_B();
    fn SPI0();
    fn USB();
    fn TMR2();
    fn UART0();
    fn UART1();
    fn RTC();
    fn ADC();
    fn TMR3();
    fn UART2();
    fn UART3();
    fn WDOG_BAT();
}
#[doc(hidden)]
#[repr(C)]
pub union Vector {
    pub _handler: unsafe extern "C" fn(),
    pub _reserved: usize,
}
#[cfg(feature = "rt")]
#[doc(hidden)]
#[no_mangle]
pub static __EXTERNAL_INTERRUPTS: [Vector; 22] = [
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _handler: TMR0 },
    Vector { _handler: GPIO_A },
    Vector { _handler: GPIO_B },
    Vector { _handler: SPI0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _handler: USB },
    Vector { _handler: TMR2 },
    Vector { _handler: UART0 },
    Vector { _handler: UART1 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _handler: RTC },
    Vector { _handler: ADC },
    Vector { _handler: TMR3 },
    Vector { _handler: UART2 },
    Vector { _handler: UART3 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _handler: WDOG_BAT },
];
#[doc(hidden)]
pub mod interrupt {
    ///Enumeration of all the interrupts.
    #[derive(Copy, Clone, Debug, PartialEq, Eq)]
    #[repr(u16)]
    pub enum Interrupt {
        ///2 - TMR0_IRQHandler
        TMR0 = 2,
        ///3 - GPIO_IRQHandler
        GPIO_A = 3,
        ///4 - GPIO_IRQHandler
        GPIO_B = 4,
        ///5 - SPI0_IRQHandler
        SPI0 = 5,
        ///8 - USB_IRQHandler
        USB = 8,
        ///9 - TMR2_IRQHandler
        TMR2 = 9,
        ///10 - UART0_IRQHandler
        UART0 = 10,
        ///11 - UART1_IRQHandler
        UART1 = 11,
        ///14 - RTC_IRQHandler
        RTC = 14,
        ///15 - ADC_IRQHandler
        ADC = 15,
        ///16 - TMR3_IRQHandler
        TMR3 = 16,
        ///17 - UART1_IRQHandler
        UART2 = 17,
        ///18 - UART3_IRQHandler
        UART3 = 18,
        ///21 - WDT_IRQHandler
        WDOG_BAT = 21,
    }
    /// TryFromInterruptError
    #[derive(Debug, Copy, Clone)]
    pub struct TryFromInterruptError(());
    impl Interrupt {
        /// Attempt to convert a given value into an `Interrupt`
        #[inline]
        pub fn try_from(value: u8) -> Result<Self, TryFromInterruptError> {
            match value {
                2 => Ok(Interrupt::TMR0),
                3 => Ok(Interrupt::GPIO_A),
                4 => Ok(Interrupt::GPIO_B),
                5 => Ok(Interrupt::SPI0),
                8 => Ok(Interrupt::USB),
                9 => Ok(Interrupt::TMR2),
                10 => Ok(Interrupt::UART0),
                11 => Ok(Interrupt::UART1),
                14 => Ok(Interrupt::RTC),
                15 => Ok(Interrupt::ADC),
                16 => Ok(Interrupt::TMR3),
                17 => Ok(Interrupt::UART2),
                18 => Ok(Interrupt::UART3),
                21 => Ok(Interrupt::WDOG_BAT),
                _ => Err(TryFromInterruptError(())),
            }
        }
    }
    #[cfg(feature = "rt")]
    #[macro_export]
    /// Assigns a handler to an interrupt
    ///
    /// This macro takes two arguments: the name of an interrupt and the path to the
    /// function that will be used as the handler of that interrupt. That function
    /// must have signature `fn()`.
    ///
    /// Optionally, a third argument may be used to declare interrupt local data.
    /// The handler will have exclusive access to these *local* variables on each
    /// invocation. If the third argument is used then the signature of the handler
    /// function must be `fn(&mut $NAME::Locals)` where `$NAME` is the first argument
    /// passed to the macro.
    ///
    /// # Example
    ///
    /// ``` ignore
    /// interrupt!(TIM2, periodic);
    ///
    /// fn periodic() {
    ///     print!(".");
    /// }
    ///
    /// interrupt!(TIM3, tick, locals: {
    ///     tick: bool = false;
    /// });
    ///
    /// fn tick(locals: &mut TIM3::Locals) {
    ///     locals.tick = !locals.tick;
    ///
    ///     if locals.tick {
    ///         println!("Tick");
    ///     } else {
    ///         println!("Tock");
    ///     }
    /// }
    /// ```
    macro_rules ! interrupt { ($ NAME : ident , $ path : path , locals : { $ ($ lvar : ident : $ lty : ty = $ lval : expr ;) * }) => { # [allow (non_snake_case)]
mod $ NAME { pub struct Locals { $ (pub $ lvar : $ lty ,) * } } # [allow (non_snake_case)]
# [no_mangle]
pub extern "C" fn $ NAME () { let _ = $ crate :: interrupt :: Interrupt :: $ NAME ; static mut LOCALS : self :: $ NAME :: Locals = self :: $ NAME :: Locals { $ ($ lvar : $ lval ,) * } ; let f : fn (& mut self :: $ NAME :: Locals) = $ path ; f (unsafe { & mut LOCALS }) ; } } ; ($ NAME : ident , $ path : path) => { # [allow (non_snake_case)]
# [no_mangle]
pub extern "C" fn $ NAME () { let _ = $ crate :: interrupt :: Interrupt :: $ NAME ; let f : fn () = $ path ; f () ; } } }
}
pub use self::interrupt::Interrupt;
///System Control Register
pub struct SYS {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for SYS {}
impl SYS {
    ///Pointer to the register block
    pub const PTR: *const sys::RegisterBlock = 0x4000_1000 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const sys::RegisterBlock {
        Self::PTR
    }
    /// Steal an instance of this peripheral
    ///
    /// # Safety
    ///
    /// Ensure that the new instance of the peripheral cannot be used in a way
    /// that may race with any existing instances, for example by only
    /// accessing read-only or write-only registers, or by consuming the
    /// original peripheral and using critical sections to coordinate
    /// access between multiple new instances.
    ///
    /// Additionally, other software such as HALs may rely on only one
    /// peripheral instance existing to ensure memory safety; ensure
    /// no stolen instances are passed to such software.
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for SYS {
    type Target = sys::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for SYS {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("SYS").finish()
    }
}
///System Control Register
pub mod sys {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        _reserved0: [u8; 0x04],
        reset_status__r8_glob_rom_cfg: RESET_STATUS__R8_GLOB_ROM_CFG,
        _reserved1: [u8; 0x03],
        clk_sys_cfg: CLK_SYS_CFG,
        hfck_pwr_ctrl: HFCK_PWR_CTRL,
        _reserved3: [u8; 0x01],
        slp_clk_off0: SLP_CLK_OFF0,
        slp_clk_off1: SLP_CLK_OFF1,
        slp_wake_ctrl: SLP_WAKE_CTRL,
        slp_power_ctrl: SLP_POWER_CTRL,
        _reserved7: [u8; 0x08],
        pin_alternate: PIN_ALTERNATE,
        pin_analog_ie: PIN_ANALOG_IE,
        _reserved9: [u8; 0x04],
        power_plan: POWER_PLAN,
        aux_power_adj: AUX_POWER_ADJ,
        _reserved11: [u8; 0x01],
        bat_det_ctrl: BAT_DET_CTRL,
        bat_det_cfg: BAT_DET_CFG,
        bat_status: BAT_STATUS,
        _reserved14: [u8; 0x05],
        int32k_tune: INT32K_TUNE,
        xt32k_tune: XT32K_TUNE,
        ck32k_config: CK32K_CONFIG,
        rtc_flag_ctrl: RTC_FLAG_CTRL,
        rtc_mode_ctrl: RTC_MODE_CTRL,
        _reserved19: [u8; 0x02],
        rtc_trig: RTC_TRIG,
        rtc_cnt_32k: RTC_CNT_32K,
        rtc_cnt_2s: RTC_CNT_2S,
        rtc_cnt_day: RTC_CNT_DAY,
        safe_access_sig: SAFE_ACCESS_SIG,
        chip_id: CHIP_ID,
        safe_access_id: SAFE_ACCESS_ID,
        wdog_count: WDOG_COUNT,
        _reserved27: [u8; 0x01],
        glob_cfg_info: GLOB_CFG_INFO,
        rst_wdog_ctrl: RST_WDOG_CTRL,
        glob_reset_keep: GLOB_RESET_KEEP,
        _reserved30: [u8; 0x03],
        pll_config: PLL_CONFIG,
        _reserved31: [u8; 0x02],
        xt32m_tune: XT32M_TUNE,
        _reserved32: [u8; 0x01],
        osc_cal_cnt: OSC_CAL_CNT,
        osc_cal_ctrl: OSC_CAL_CTRL,
        _reserved34: [u8; 0x01],
        tkey_count: TKEY_COUNT,
        _reserved35: [u8; 0x01],
        tkey_convert: TKEY_CONVERT,
        tkey_cfg: TKEY_CFG,
        adc_channel: ADC_CHANNEL,
        adc_cfg: ADC_CFG,
        adc_convert: ADC_CONVERT,
        tem_sensor: TEM_SENSOR,
        adc_data: ADC_DATA,
        adc_int_flag: ADC_INT_FLAG,
        _reserved43: [u8; 0x01],
        adc_dma_ctrl: ADC_DMA_CTRL,
        adc_ctrl_dma: ADC_CTRL_DMA,
        adc_dma_if: ADC_DMA_IF,
        adc_auto_cycle: ADC_AUTO_CYCLE,
        adc_dma_now: ADC_DMA_NOW,
        _reserved48: [u8; 0x02],
        adc_dma_beg: ADC_DMA_BEG,
        _reserved49: [u8; 0x02],
        adc_dma_end: ADC_DMA_END,
        _reserved50: [u8; 0x22],
        pa_int_en: PA_INT_EN,
        pb_int_en: PB_INT_EN,
        pa_int_mode: PA_INT_MODE,
        pb_int_mode: PB_INT_MODE,
        _reserved54: [u8; 0x04],
        pa_int_if: PA_INT_IF,
        pb_int_if: PB_INT_IF,
        pa_dir: PA_DIR,
        pa_pin: PA_PIN,
        pa_out: PA_OUT,
        pa_clr: PA_CLR,
        pa_pu: PA_PU,
        pa_pd_drv: PA_PD_DRV,
        _reserved62: [u8; 0x08],
        pb_dir: PB_DIR,
        pb_pin: PB_PIN,
        pb_out__r8_slv_rd_data: PB_OUT__R8_SLV_RD_DATA,
        pb_clr: PB_CLR,
        pb_pu: PB_PU,
        pb_pd_drv: PB_PD_DRV,
    }
    impl RegisterBlock {
        ///0x04 - RWA, reset status, SAM or flash ROM configuration
        #[inline(always)]
        pub const fn reset_status__r8_glob_rom_cfg(&self) -> &RESET_STATUS__R8_GLOB_ROM_CFG {
            &self.reset_status__r8_glob_rom_cfg
        }
        ///0x08 - RWA, system clock configuration, SAM
        #[inline(always)]
        pub const fn clk_sys_cfg(&self) -> &CLK_SYS_CFG {
            &self.clk_sys_cfg
        }
        ///0x0a - RWA, high frequency clock module power control, SAM
        #[inline(always)]
        pub const fn hfck_pwr_ctrl(&self) -> &HFCK_PWR_CTRL {
            &self.hfck_pwr_ctrl
        }
        ///0x0c - RWA, sleep clock off control byte 0, SAM
        #[inline(always)]
        pub const fn slp_clk_off0(&self) -> &SLP_CLK_OFF0 {
            &self.slp_clk_off0
        }
        ///0x0d - RWA, sleep clock off control byte 1, SAM
        #[inline(always)]
        pub const fn slp_clk_off1(&self) -> &SLP_CLK_OFF1 {
            &self.slp_clk_off1
        }
        ///0x0e - RWA, wake control, SAM
        #[inline(always)]
        pub const fn slp_wake_ctrl(&self) -> &SLP_WAKE_CTRL {
            &self.slp_wake_ctrl
        }
        ///0x0f - RWA, peripherals power down control, SAM
        #[inline(always)]
        pub const fn slp_power_ctrl(&self) -> &SLP_POWER_CTRL {
            &self.slp_power_ctrl
        }
        ///0x18 - RW, function pin alternate configuration
        #[inline(always)]
        pub const fn pin_alternate(&self) -> &PIN_ALTERNATE {
            &self.pin_alternate
        }
        ///0x1a - RW, analog pin enable and digital input disable
        #[inline(always)]
        pub const fn pin_analog_ie(&self) -> &PIN_ANALOG_IE {
            &self.pin_analog_ie
        }
        ///0x20 - RWA, power plan before sleep instruction, SAM
        #[inline(always)]
        pub const fn power_plan(&self) -> &POWER_PLAN {
            &self.power_plan
        }
        ///0x22 - RWA, aux power adjust control, SAM
        #[inline(always)]
        pub const fn aux_power_adj(&self) -> &AUX_POWER_ADJ {
            &self.aux_power_adj
        }
        ///0x24 - RWA, battery voltage detector control, SAM
        #[inline(always)]
        pub const fn bat_det_ctrl(&self) -> &BAT_DET_CTRL {
            &self.bat_det_ctrl
        }
        ///0x25 - RWA, battery voltage detector configuration, SAM
        #[inline(always)]
        pub const fn bat_det_cfg(&self) -> &BAT_DET_CFG {
            &self.bat_det_cfg
        }
        ///0x26 - RO, battery status
        #[inline(always)]
        pub const fn bat_status(&self) -> &BAT_STATUS {
            &self.bat_status
        }
        ///0x2c - RWA, internal 32KHz oscillator tune control, SAM
        #[inline(always)]
        pub const fn int32k_tune(&self) -> &INT32K_TUNE {
            &self.int32k_tune
        }
        ///0x2e - RWA, external 32KHz oscillator tune control, SAM
        #[inline(always)]
        pub const fn xt32k_tune(&self) -> &XT32K_TUNE {
            &self.xt32k_tune
        }
        ///0x2f - RWA, 32KHz oscillator configure
        #[inline(always)]
        pub const fn ck32k_config(&self) -> &CK32K_CONFIG {
            &self.ck32k_config
        }
        ///0x30 - RW, RTC flag and clear control
        #[inline(always)]
        pub const fn rtc_flag_ctrl(&self) -> &RTC_FLAG_CTRL {
            &self.rtc_flag_ctrl
        }
        ///0x31 - RWA, RTC mode control, SAM
        #[inline(always)]
        pub const fn rtc_mode_ctrl(&self) -> &RTC_MODE_CTRL {
            &self.rtc_mode_ctrl
        }
        ///0x34 - RWA, RTC trigger value, SAM
        #[inline(always)]
        pub const fn rtc_trig(&self) -> &RTC_TRIG {
            &self.rtc_trig
        }
        ///0x38 - RO, RTC count based 32KHz
        #[inline(always)]
        pub const fn rtc_cnt_32k(&self) -> &RTC_CNT_32K {
            &self.rtc_cnt_32k
        }
        ///0x3a - RO, RTC count based 2 second
        #[inline(always)]
        pub const fn rtc_cnt_2s(&self) -> &RTC_CNT_2S {
            &self.rtc_cnt_2s
        }
        ///0x3c - RO, RTC count based one day, only low 14 bit
        #[inline(always)]
        pub const fn rtc_cnt_day(&self) -> &RTC_CNT_DAY {
            &self.rtc_cnt_day
        }
        ///0x40 - WO, safe accessing sign register, must write SAFE_ACCESS_SIG1 then SAFE_ACCESS_SIG2 to enter safe accessing mode
        #[inline(always)]
        pub const fn safe_access_sig(&self) -> &SAFE_ACCESS_SIG {
            &self.safe_access_sig
        }
        ///0x41 - RF, chip ID register, always is ID_CH57*
        #[inline(always)]
        pub const fn chip_id(&self) -> &CHIP_ID {
            &self.chip_id
        }
        ///0x42 - RF, safe accessing ID register, always 0x04
        #[inline(always)]
        pub const fn safe_access_id(&self) -> &SAFE_ACCESS_ID {
            &self.safe_access_id
        }
        ///0x43 - RW, watch-dog count, count by clock frequency Fsys/131072
        #[inline(always)]
        pub const fn wdog_count(&self) -> &WDOG_COUNT {
            &self.wdog_count
        }
        ///0x45 - RO, global configuration information and status
        #[inline(always)]
        pub const fn glob_cfg_info(&self) -> &GLOB_CFG_INFO {
            &self.glob_cfg_info
        }
        ///0x46 - RWA, reset and watch-dog control, SAM
        #[inline(always)]
        pub const fn rst_wdog_ctrl(&self) -> &RST_WDOG_CTRL {
            &self.rst_wdog_ctrl
        }
        ///0x47 - RW, value keeper during global reset
        #[inline(always)]
        pub const fn glob_reset_keep(&self) -> &GLOB_RESET_KEEP {
            &self.glob_reset_keep
        }
        ///0x4b - RWA, PLL configuration control, SAM
        #[inline(always)]
        pub const fn pll_config(&self) -> &PLL_CONFIG {
            &self.pll_config
        }
        ///0x4e - RWA, external 32MHz oscillator tune control, SAM
        #[inline(always)]
        pub const fn xt32m_tune(&self) -> &XT32M_TUNE {
            &self.xt32m_tune
        }
        ///0x50 - RO, system clock count value for 32KHz 5 cycles
        #[inline(always)]
        pub const fn osc_cal_cnt(&self) -> &OSC_CAL_CNT {
            &self.osc_cal_cnt
        }
        ///0x52 - RWA, oscillator frequency calibration control, SAM
        #[inline(always)]
        pub const fn osc_cal_ctrl(&self) -> &OSC_CAL_CTRL {
            &self.osc_cal_ctrl
        }
        ///0x54 - RW, Touchkey charge and discharge count
        #[inline(always)]
        pub const fn tkey_count(&self) -> &TKEY_COUNT {
            &self.tkey_count
        }
        ///0x56 - RW, Touchkey convert start control
        #[inline(always)]
        pub const fn tkey_convert(&self) -> &TKEY_CONVERT {
            &self.tkey_convert
        }
        ///0x57 - RW, Touchkey configure
        #[inline(always)]
        pub const fn tkey_cfg(&self) -> &TKEY_CFG {
            &self.tkey_cfg
        }
        ///0x58 - RW, ADC input channel selection
        #[inline(always)]
        pub const fn adc_channel(&self) -> &ADC_CHANNEL {
            &self.adc_channel
        }
        ///0x59 - RW, ADC configure
        #[inline(always)]
        pub const fn adc_cfg(&self) -> &ADC_CFG {
            &self.adc_cfg
        }
        ///0x5a - RW, ADC convert control
        #[inline(always)]
        pub const fn adc_convert(&self) -> &ADC_CONVERT {
            &self.adc_convert
        }
        ///0x5b - RW, temperature sensor control
        #[inline(always)]
        pub const fn tem_sensor(&self) -> &TEM_SENSOR {
            &self.tem_sensor
        }
        ///0x5c - RO, ADC data
        #[inline(always)]
        pub const fn adc_data(&self) -> &ADC_DATA {
            &self.adc_data
        }
        ///0x5e - RO, ADC interrupt flag register
        #[inline(always)]
        pub const fn adc_int_flag(&self) -> &ADC_INT_FLAG {
            &self.adc_int_flag
        }
        ///0x60 - RO, ADC DMA control and status register
        #[inline(always)]
        pub const fn adc_dma_ctrl(&self) -> &ADC_DMA_CTRL {
            &self.adc_dma_ctrl
        }
        ///0x61 - RW, ADC DMA control
        #[inline(always)]
        pub const fn adc_ctrl_dma(&self) -> &ADC_CTRL_DMA {
            &self.adc_ctrl_dma
        }
        ///0x62 - RO, ADC interrupt flag
        #[inline(always)]
        pub const fn adc_dma_if(&self) -> &ADC_DMA_IF {
            &self.adc_dma_if
        }
        ///0x63 - RO, ADC interrupt flag
        #[inline(always)]
        pub const fn adc_auto_cycle(&self) -> &ADC_AUTO_CYCLE {
            &self.adc_auto_cycle
        }
        ///0x64 - RO, ADC DMA current address
        #[inline(always)]
        pub const fn adc_dma_now(&self) -> &ADC_DMA_NOW {
            &self.adc_dma_now
        }
        ///0x68 - RW, ADC DMA begin address
        #[inline(always)]
        pub const fn adc_dma_beg(&self) -> &ADC_DMA_BEG {
            &self.adc_dma_beg
        }
        ///0x6c - RW, ADC DMA end address
        #[inline(always)]
        pub const fn adc_dma_end(&self) -> &ADC_DMA_END {
            &self.adc_dma_end
        }
        ///0x90 - RW, GPIO PA interrupt enable
        #[inline(always)]
        pub const fn pa_int_en(&self) -> &PA_INT_EN {
            &self.pa_int_en
        }
        ///0x92 - RW, GPIO PB interrupt enable
        #[inline(always)]
        pub const fn pb_int_en(&self) -> &PB_INT_EN {
            &self.pb_int_en
        }
        ///0x94 - RW, GPIO PA interrupt mode: 0=level action, 1=edge action
        #[inline(always)]
        pub const fn pa_int_mode(&self) -> &PA_INT_MODE {
            &self.pa_int_mode
        }
        ///0x96 - RW, GPIO PB interrupt mode: 0=level action, 1=edge action;RW, status for parallel slave read
        #[inline(always)]
        pub const fn pb_int_mode(&self) -> &PB_INT_MODE {
            &self.pb_int_mode
        }
        ///0x9c - RW1, GPIO PA interrupt flag
        #[inline(always)]
        pub const fn pa_int_if(&self) -> &PA_INT_IF {
            &self.pa_int_if
        }
        ///0x9e - RW1, GPIO PB interrupt flag
        #[inline(always)]
        pub const fn pb_int_if(&self) -> &PB_INT_IF {
            &self.pb_int_if
        }
        ///0xa0 - RW, GPIO PA I/O direction: 0=in, 1=out
        #[inline(always)]
        pub const fn pa_dir(&self) -> &PA_DIR {
            &self.pa_dir
        }
        ///0xa4 - RO, GPIO PA input
        #[inline(always)]
        pub const fn pa_pin(&self) -> &PA_PIN {
            &self.pa_pin
        }
        ///0xa8 - RW, GPIO PA output
        #[inline(always)]
        pub const fn pa_out(&self) -> &PA_OUT {
            &self.pa_out
        }
        ///0xac - WZ, GPIO PA clear output: 0=keep, 1=clear
        #[inline(always)]
        pub const fn pa_clr(&self) -> &PA_CLR {
            &self.pa_clr
        }
        ///0xb0 - RW, GPIO PA pullup resistance enable
        #[inline(always)]
        pub const fn pa_pu(&self) -> &PA_PU {
            &self.pa_pu
        }
        ///0xb4 - RW, PA pulldown for input or PA driving capability for output
        #[inline(always)]
        pub const fn pa_pd_drv(&self) -> &PA_PD_DRV {
            &self.pa_pd_drv
        }
        ///0xc0 - RW, GPIO PB I/O direction: 0=in, 1=out
        #[inline(always)]
        pub const fn pb_dir(&self) -> &PB_DIR {
            &self.pb_dir
        }
        ///0xc4 - RO, GPIO PB input
        #[inline(always)]
        pub const fn pb_pin(&self) -> &PB_PIN {
            &self.pb_pin
        }
        ///0xc8 - RW, GPIO PB output;RW, data for parallel slave read
        #[inline(always)]
        pub const fn pb_out__r8_slv_rd_data(&self) -> &PB_OUT__R8_SLV_RD_DATA {
            &self.pb_out__r8_slv_rd_data
        }
        ///0xcc - WZ, GPIO PB clear output: 0=keep, 1=clear
        #[inline(always)]
        pub const fn pb_clr(&self) -> &PB_CLR {
            &self.pb_clr
        }
        ///0xd0 - RW, GPIO PB pullup resistance enable
        #[inline(always)]
        pub const fn pb_pu(&self) -> &PB_PU {
            &self.pb_pu
        }
        ///0xd4 - RW, PB pulldown for input or PB driving capability for output
        #[inline(always)]
        pub const fn pb_pd_drv(&self) -> &PB_PD_DRV {
            &self.pb_pd_drv
        }
    }
    ///CLK_SYS_CFG (rw) register accessor: RWA, system clock configuration, SAM
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`clk_sys_cfg::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`clk_sys_cfg::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@clk_sys_cfg`]
    ///module
    pub type CLK_SYS_CFG = crate::Reg<clk_sys_cfg::CLK_SYS_CFG_SPEC>;
    ///RWA, system clock configuration, SAM
    pub mod clk_sys_cfg {
        ///Register `CLK_SYS_CFG` reader
        pub type R = crate::R<CLK_SYS_CFG_SPEC>;
        ///Register `CLK_SYS_CFG` writer
        pub type W = crate::W<CLK_SYS_CFG_SPEC>;
        ///Field `CLK_PLL_DIV` reader - RWA, output clock divider from PLL or CK32M
        pub type CLK_PLL_DIV_R = crate::FieldReader;
        ///Field `CLK_PLL_DIV` writer - RWA, output clock divider from PLL or CK32M
        pub type CLK_PLL_DIV_W<'a, REG> = crate::FieldWriter<'a, REG, 5>;
        ///Field `CLK_SYS_MOD` reader - RWA, system clock source mode: 00=divided from 32MHz, 01=divided from PLL-480MHz, 10=directly from 32MHz, 11=directly from 32KHz
        pub type CLK_SYS_MOD_R = crate::FieldReader;
        ///Field `CLK_SYS_MOD` writer - RWA, system clock source mode: 00=divided from 32MHz, 01=divided from PLL-480MHz, 10=directly from 32MHz, 11=directly from 32KHz
        pub type CLK_SYS_MOD_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        impl R {
            ///Bits 0:4 - RWA, output clock divider from PLL or CK32M
            #[inline(always)]
            pub fn clk_pll_div(&self) -> CLK_PLL_DIV_R {
                CLK_PLL_DIV_R::new((self.bits & 0x1f) as u8)
            }
            ///Bits 6:7 - RWA, system clock source mode: 00=divided from 32MHz, 01=divided from PLL-480MHz, 10=directly from 32MHz, 11=directly from 32KHz
            #[inline(always)]
            pub fn clk_sys_mod(&self) -> CLK_SYS_MOD_R {
                CLK_SYS_MOD_R::new(((self.bits >> 6) & 3) as u8)
            }
        }
        impl W {
            ///Bits 0:4 - RWA, output clock divider from PLL or CK32M
            #[inline(always)]
            #[must_use]
            pub fn clk_pll_div(&mut self) -> CLK_PLL_DIV_W<CLK_SYS_CFG_SPEC> {
                CLK_PLL_DIV_W::new(self, 0)
            }
            ///Bits 6:7 - RWA, system clock source mode: 00=divided from 32MHz, 01=divided from PLL-480MHz, 10=directly from 32MHz, 11=directly from 32KHz
            #[inline(always)]
            #[must_use]
            pub fn clk_sys_mod(&mut self) -> CLK_SYS_MOD_W<CLK_SYS_CFG_SPEC> {
                CLK_SYS_MOD_W::new(self, 6)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RWA, system clock configuration, SAM
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`clk_sys_cfg::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`clk_sys_cfg::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct CLK_SYS_CFG_SPEC;
        impl crate::RegisterSpec for CLK_SYS_CFG_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`clk_sys_cfg::R`](R) reader structure
        impl crate::Readable for CLK_SYS_CFG_SPEC {}
        ///`write(|w| ..)` method takes [`clk_sys_cfg::W`](W) writer structure
        impl crate::Writable for CLK_SYS_CFG_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets CLK_SYS_CFG to value 0x05
        impl crate::Resettable for CLK_SYS_CFG_SPEC {
            const RESET_VALUE: u16 = 0x05;
        }
    }
    ///HFCK_PWR_CTRL (rw) register accessor: RWA, high frequency clock module power control, SAM
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`hfck_pwr_ctrl::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`hfck_pwr_ctrl::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@hfck_pwr_ctrl`]
    ///module
    pub type HFCK_PWR_CTRL = crate::Reg<hfck_pwr_ctrl::HFCK_PWR_CTRL_SPEC>;
    ///RWA, high frequency clock module power control, SAM
    pub mod hfck_pwr_ctrl {
        ///Register `HFCK_PWR_CTRL` reader
        pub type R = crate::R<HFCK_PWR_CTRL_SPEC>;
        ///Register `HFCK_PWR_CTRL` writer
        pub type W = crate::W<HFCK_PWR_CTRL_SPEC>;
        ///Field `CLK_XT32M_PON` reader - RWA, external 32MHz oscillator power control: 0=power down, 1-power on
        pub type CLK_XT32M_PON_R = crate::BitReader;
        ///Field `CLK_XT32M_PON` writer - RWA, external 32MHz oscillator power control: 0=power down, 1-power on
        pub type CLK_XT32M_PON_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CLK_PLL_PON` reader - RWA, PLL power control: 0=power down, 1-power on
        pub type CLK_PLL_PON_R = crate::BitReader;
        ///Field `CLK_PLL_PON` writer - RWA, PLL power control: 0=power down, 1-power on
        pub type CLK_PLL_PON_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 2 - RWA, external 32MHz oscillator power control: 0=power down, 1-power on
            #[inline(always)]
            pub fn clk_xt32m_pon(&self) -> CLK_XT32M_PON_R {
                CLK_XT32M_PON_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 4 - RWA, PLL power control: 0=power down, 1-power on
            #[inline(always)]
            pub fn clk_pll_pon(&self) -> CLK_PLL_PON_R {
                CLK_PLL_PON_R::new(((self.bits >> 4) & 1) != 0)
            }
        }
        impl W {
            ///Bit 2 - RWA, external 32MHz oscillator power control: 0=power down, 1-power on
            #[inline(always)]
            #[must_use]
            pub fn clk_xt32m_pon(&mut self) -> CLK_XT32M_PON_W<HFCK_PWR_CTRL_SPEC> {
                CLK_XT32M_PON_W::new(self, 2)
            }
            ///Bit 4 - RWA, PLL power control: 0=power down, 1-power on
            #[inline(always)]
            #[must_use]
            pub fn clk_pll_pon(&mut self) -> CLK_PLL_PON_W<HFCK_PWR_CTRL_SPEC> {
                CLK_PLL_PON_W::new(self, 4)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RWA, high frequency clock module power control, SAM
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`hfck_pwr_ctrl::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`hfck_pwr_ctrl::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct HFCK_PWR_CTRL_SPEC;
        impl crate::RegisterSpec for HFCK_PWR_CTRL_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`hfck_pwr_ctrl::R`](R) reader structure
        impl crate::Readable for HFCK_PWR_CTRL_SPEC {}
        ///`write(|w| ..)` method takes [`hfck_pwr_ctrl::W`](W) writer structure
        impl crate::Writable for HFCK_PWR_CTRL_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets HFCK_PWR_CTRL to value 0x04
        impl crate::Resettable for HFCK_PWR_CTRL_SPEC {
            const RESET_VALUE: u8 = 0x04;
        }
    }
    ///SLP_CLK_OFF0 (rw) register accessor: RWA, sleep clock off control byte 0, SAM
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`slp_clk_off0::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`slp_clk_off0::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@slp_clk_off0`]
    ///module
    pub type SLP_CLK_OFF0 = crate::Reg<slp_clk_off0::SLP_CLK_OFF0_SPEC>;
    ///RWA, sleep clock off control byte 0, SAM
    pub mod slp_clk_off0 {
        ///Register `SLP_CLK_OFF0` reader
        pub type R = crate::R<SLP_CLK_OFF0_SPEC>;
        ///Register `SLP_CLK_OFF0` writer
        pub type W = crate::W<SLP_CLK_OFF0_SPEC>;
        ///Field `SLP_CLK_TMR0` reader - RWA, close TMR0 clock
        pub type SLP_CLK_TMR0_R = crate::BitReader;
        ///Field `SLP_CLK_TMR0` writer - RWA, close TMR0 clock
        pub type SLP_CLK_TMR0_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `SLP_CLK_TMR1` reader - RWA, close TMR1 clock
        pub type SLP_CLK_TMR1_R = crate::BitReader;
        ///Field `SLP_CLK_TMR1` writer - RWA, close TMR1 clock
        pub type SLP_CLK_TMR1_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `SLP_CLK_TMR2` reader - RWA, close TMR2 clock
        pub type SLP_CLK_TMR2_R = crate::BitReader;
        ///Field `SLP_CLK_TMR2` writer - RWA, close TMR2 clock
        pub type SLP_CLK_TMR2_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `SLP_CLK_TMR3` reader - RWA, close TMR3 clock
        pub type SLP_CLK_TMR3_R = crate::BitReader;
        ///Field `SLP_CLK_TMR3` writer - RWA, close TMR3 clock
        pub type SLP_CLK_TMR3_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `SLP_CLK_UART0` reader - RWA, close UART0 clock
        pub type SLP_CLK_UART0_R = crate::BitReader;
        ///Field `SLP_CLK_UART0` writer - RWA, close UART0 clock
        pub type SLP_CLK_UART0_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `SLP_CLK_UART1` reader - RWA, close UART1 clock
        pub type SLP_CLK_UART1_R = crate::BitReader;
        ///Field `SLP_CLK_UART1` writer - RWA, close UART1 clock
        pub type SLP_CLK_UART1_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `SLP_CLK_UART2` reader - RWA, close UART2 clock
        pub type SLP_CLK_UART2_R = crate::BitReader;
        ///Field `SLP_CLK_UART2` writer - RWA, close UART2 clock
        pub type SLP_CLK_UART2_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `SLP_CLK_UART3` reader - RWA, close UART3 clock
        pub type SLP_CLK_UART3_R = crate::BitReader;
        ///Field `SLP_CLK_UART3` writer - RWA, close UART3 clock
        pub type SLP_CLK_UART3_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - RWA, close TMR0 clock
            #[inline(always)]
            pub fn slp_clk_tmr0(&self) -> SLP_CLK_TMR0_R {
                SLP_CLK_TMR0_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RWA, close TMR1 clock
            #[inline(always)]
            pub fn slp_clk_tmr1(&self) -> SLP_CLK_TMR1_R {
                SLP_CLK_TMR1_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RWA, close TMR2 clock
            #[inline(always)]
            pub fn slp_clk_tmr2(&self) -> SLP_CLK_TMR2_R {
                SLP_CLK_TMR2_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RWA, close TMR3 clock
            #[inline(always)]
            pub fn slp_clk_tmr3(&self) -> SLP_CLK_TMR3_R {
                SLP_CLK_TMR3_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RWA, close UART0 clock
            #[inline(always)]
            pub fn slp_clk_uart0(&self) -> SLP_CLK_UART0_R {
                SLP_CLK_UART0_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - RWA, close UART1 clock
            #[inline(always)]
            pub fn slp_clk_uart1(&self) -> SLP_CLK_UART1_R {
                SLP_CLK_UART1_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - RWA, close UART2 clock
            #[inline(always)]
            pub fn slp_clk_uart2(&self) -> SLP_CLK_UART2_R {
                SLP_CLK_UART2_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - RWA, close UART3 clock
            #[inline(always)]
            pub fn slp_clk_uart3(&self) -> SLP_CLK_UART3_R {
                SLP_CLK_UART3_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RWA, close TMR0 clock
            #[inline(always)]
            #[must_use]
            pub fn slp_clk_tmr0(&mut self) -> SLP_CLK_TMR0_W<SLP_CLK_OFF0_SPEC> {
                SLP_CLK_TMR0_W::new(self, 0)
            }
            ///Bit 1 - RWA, close TMR1 clock
            #[inline(always)]
            #[must_use]
            pub fn slp_clk_tmr1(&mut self) -> SLP_CLK_TMR1_W<SLP_CLK_OFF0_SPEC> {
                SLP_CLK_TMR1_W::new(self, 1)
            }
            ///Bit 2 - RWA, close TMR2 clock
            #[inline(always)]
            #[must_use]
            pub fn slp_clk_tmr2(&mut self) -> SLP_CLK_TMR2_W<SLP_CLK_OFF0_SPEC> {
                SLP_CLK_TMR2_W::new(self, 2)
            }
            ///Bit 3 - RWA, close TMR3 clock
            #[inline(always)]
            #[must_use]
            pub fn slp_clk_tmr3(&mut self) -> SLP_CLK_TMR3_W<SLP_CLK_OFF0_SPEC> {
                SLP_CLK_TMR3_W::new(self, 3)
            }
            ///Bit 4 - RWA, close UART0 clock
            #[inline(always)]
            #[must_use]
            pub fn slp_clk_uart0(&mut self) -> SLP_CLK_UART0_W<SLP_CLK_OFF0_SPEC> {
                SLP_CLK_UART0_W::new(self, 4)
            }
            ///Bit 5 - RWA, close UART1 clock
            #[inline(always)]
            #[must_use]
            pub fn slp_clk_uart1(&mut self) -> SLP_CLK_UART1_W<SLP_CLK_OFF0_SPEC> {
                SLP_CLK_UART1_W::new(self, 5)
            }
            ///Bit 6 - RWA, close UART2 clock
            #[inline(always)]
            #[must_use]
            pub fn slp_clk_uart2(&mut self) -> SLP_CLK_UART2_W<SLP_CLK_OFF0_SPEC> {
                SLP_CLK_UART2_W::new(self, 6)
            }
            ///Bit 7 - RWA, close UART3 clock
            #[inline(always)]
            #[must_use]
            pub fn slp_clk_uart3(&mut self) -> SLP_CLK_UART3_W<SLP_CLK_OFF0_SPEC> {
                SLP_CLK_UART3_W::new(self, 7)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RWA, sleep clock off control byte 0, SAM
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`slp_clk_off0::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`slp_clk_off0::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct SLP_CLK_OFF0_SPEC;
        impl crate::RegisterSpec for SLP_CLK_OFF0_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`slp_clk_off0::R`](R) reader structure
        impl crate::Readable for SLP_CLK_OFF0_SPEC {}
        ///`write(|w| ..)` method takes [`slp_clk_off0::W`](W) writer structure
        impl crate::Writable for SLP_CLK_OFF0_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets SLP_CLK_OFF0 to value 0
        impl crate::Resettable for SLP_CLK_OFF0_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///SLP_CLK_OFF1 (rw) register accessor: RWA, sleep clock off control byte 1, SAM
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`slp_clk_off1::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`slp_clk_off1::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@slp_clk_off1`]
    ///module
    pub type SLP_CLK_OFF1 = crate::Reg<slp_clk_off1::SLP_CLK_OFF1_SPEC>;
    ///RWA, sleep clock off control byte 1, SAM
    pub mod slp_clk_off1 {
        ///Register `SLP_CLK_OFF1` reader
        pub type R = crate::R<SLP_CLK_OFF1_SPEC>;
        ///Register `SLP_CLK_OFF1` writer
        pub type W = crate::W<SLP_CLK_OFF1_SPEC>;
        ///Field `SLP_CLK_SPI0` reader - RWA, close SPI0 clock
        pub type SLP_CLK_SPI0_R = crate::BitReader;
        ///Field `SLP_CLK_SPI0` writer - RWA, close SPI0 clock
        pub type SLP_CLK_SPI0_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `SLP_CLK_PWMX` reader - RWA, close PWMx clock
        pub type SLP_CLK_PWMX_R = crate::BitReader;
        ///Field `SLP_CLK_PWMX` writer - RWA, close PWMx clock
        pub type SLP_CLK_PWMX_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `SLP_CLK_USB` reader - RWA, close USB clock
        pub type SLP_CLK_USB_R = crate::BitReader;
        ///Field `SLP_CLK_USB` writer - RWA, close USB clock
        pub type SLP_CLK_USB_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `SLP_CLK_BLE` reader - RWA, close BLE clock
        pub type SLP_CLK_BLE_R = crate::BitReader;
        ///Field `SLP_CLK_BLE` writer - RWA, close BLE clock
        pub type SLP_CLK_BLE_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - RWA, close SPI0 clock
            #[inline(always)]
            pub fn slp_clk_spi0(&self) -> SLP_CLK_SPI0_R {
                SLP_CLK_SPI0_R::new((self.bits & 1) != 0)
            }
            ///Bit 2 - RWA, close PWMx clock
            #[inline(always)]
            pub fn slp_clk_pwmx(&self) -> SLP_CLK_PWMX_R {
                SLP_CLK_PWMX_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 4 - RWA, close USB clock
            #[inline(always)]
            pub fn slp_clk_usb(&self) -> SLP_CLK_USB_R {
                SLP_CLK_USB_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 7 - RWA, close BLE clock
            #[inline(always)]
            pub fn slp_clk_ble(&self) -> SLP_CLK_BLE_R {
                SLP_CLK_BLE_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RWA, close SPI0 clock
            #[inline(always)]
            #[must_use]
            pub fn slp_clk_spi0(&mut self) -> SLP_CLK_SPI0_W<SLP_CLK_OFF1_SPEC> {
                SLP_CLK_SPI0_W::new(self, 0)
            }
            ///Bit 2 - RWA, close PWMx clock
            #[inline(always)]
            #[must_use]
            pub fn slp_clk_pwmx(&mut self) -> SLP_CLK_PWMX_W<SLP_CLK_OFF1_SPEC> {
                SLP_CLK_PWMX_W::new(self, 2)
            }
            ///Bit 4 - RWA, close USB clock
            #[inline(always)]
            #[must_use]
            pub fn slp_clk_usb(&mut self) -> SLP_CLK_USB_W<SLP_CLK_OFF1_SPEC> {
                SLP_CLK_USB_W::new(self, 4)
            }
            ///Bit 7 - RWA, close BLE clock
            #[inline(always)]
            #[must_use]
            pub fn slp_clk_ble(&mut self) -> SLP_CLK_BLE_W<SLP_CLK_OFF1_SPEC> {
                SLP_CLK_BLE_W::new(self, 7)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RWA, sleep clock off control byte 1, SAM
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`slp_clk_off1::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`slp_clk_off1::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct SLP_CLK_OFF1_SPEC;
        impl crate::RegisterSpec for SLP_CLK_OFF1_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`slp_clk_off1::R`](R) reader structure
        impl crate::Readable for SLP_CLK_OFF1_SPEC {}
        ///`write(|w| ..)` method takes [`slp_clk_off1::W`](W) writer structure
        impl crate::Writable for SLP_CLK_OFF1_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets SLP_CLK_OFF1 to value 0
        impl crate::Resettable for SLP_CLK_OFF1_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///SLP_WAKE_CTRL (rw) register accessor: RWA, wake control, SAM
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`slp_wake_ctrl::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`slp_wake_ctrl::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@slp_wake_ctrl`]
    ///module
    pub type SLP_WAKE_CTRL = crate::Reg<slp_wake_ctrl::SLP_WAKE_CTRL_SPEC>;
    ///RWA, wake control, SAM
    pub mod slp_wake_ctrl {
        ///Register `SLP_WAKE_CTRL` reader
        pub type R = crate::R<SLP_WAKE_CTRL_SPEC>;
        ///Register `SLP_WAKE_CTRL` writer
        pub type W = crate::W<SLP_WAKE_CTRL_SPEC>;
        ///Field `SLP_USB_WAKE` reader - RWA, enable USB waking
        pub type SLP_USB_WAKE_R = crate::BitReader;
        ///Field `SLP_USB_WAKE` writer - RWA, enable USB waking
        pub type SLP_USB_WAKE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `SLP_RTC_WAKE` reader - RWA, enable RTC waking
        pub type SLP_RTC_WAKE_R = crate::BitReader;
        ///Field `SLP_RTC_WAKE` writer - RWA, enable RTC waking
        pub type SLP_RTC_WAKE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `SLP_GPIO_WAKE` reader - RWA, enable GPIO waking
        pub type SLP_GPIO_WAKE_R = crate::BitReader;
        ///Field `SLP_GPIO_WAKE` writer - RWA, enable GPIO waking
        pub type SLP_GPIO_WAKE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `SLP_BAT_WAKE` reader - RWA, enable BAT waking
        pub type SLP_BAT_WAKE_R = crate::BitReader;
        ///Field `SLP_BAT_WAKE` writer - RWA, enable BAT waking
        pub type SLP_BAT_WAKE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `WAKE_EV_MODE` reader - RWA, event wakeup mode
        pub type WAKE_EV_MODE_R = crate::BitReader;
        ///Field `WAKE_EV_MODE` writer - RWA, event wakeup mode
        pub type WAKE_EV_MODE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `WAKE_DELAY` reader - RWA, wakeup delay
        pub type WAKE_DELAY_R = crate::BitReader;
        ///Field `WAKE_DELAY` writer - RWA, wakeup delay
        pub type WAKE_DELAY_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - RWA, enable USB waking
            #[inline(always)]
            pub fn slp_usb_wake(&self) -> SLP_USB_WAKE_R {
                SLP_USB_WAKE_R::new((self.bits & 1) != 0)
            }
            ///Bit 3 - RWA, enable RTC waking
            #[inline(always)]
            pub fn slp_rtc_wake(&self) -> SLP_RTC_WAKE_R {
                SLP_RTC_WAKE_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RWA, enable GPIO waking
            #[inline(always)]
            pub fn slp_gpio_wake(&self) -> SLP_GPIO_WAKE_R {
                SLP_GPIO_WAKE_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - RWA, enable BAT waking
            #[inline(always)]
            pub fn slp_bat_wake(&self) -> SLP_BAT_WAKE_R {
                SLP_BAT_WAKE_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - RWA, event wakeup mode
            #[inline(always)]
            pub fn wake_ev_mode(&self) -> WAKE_EV_MODE_R {
                WAKE_EV_MODE_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - RWA, wakeup delay
            #[inline(always)]
            pub fn wake_delay(&self) -> WAKE_DELAY_R {
                WAKE_DELAY_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RWA, enable USB waking
            #[inline(always)]
            #[must_use]
            pub fn slp_usb_wake(&mut self) -> SLP_USB_WAKE_W<SLP_WAKE_CTRL_SPEC> {
                SLP_USB_WAKE_W::new(self, 0)
            }
            ///Bit 3 - RWA, enable RTC waking
            #[inline(always)]
            #[must_use]
            pub fn slp_rtc_wake(&mut self) -> SLP_RTC_WAKE_W<SLP_WAKE_CTRL_SPEC> {
                SLP_RTC_WAKE_W::new(self, 3)
            }
            ///Bit 4 - RWA, enable GPIO waking
            #[inline(always)]
            #[must_use]
            pub fn slp_gpio_wake(&mut self) -> SLP_GPIO_WAKE_W<SLP_WAKE_CTRL_SPEC> {
                SLP_GPIO_WAKE_W::new(self, 4)
            }
            ///Bit 5 - RWA, enable BAT waking
            #[inline(always)]
            #[must_use]
            pub fn slp_bat_wake(&mut self) -> SLP_BAT_WAKE_W<SLP_WAKE_CTRL_SPEC> {
                SLP_BAT_WAKE_W::new(self, 5)
            }
            ///Bit 6 - RWA, event wakeup mode
            #[inline(always)]
            #[must_use]
            pub fn wake_ev_mode(&mut self) -> WAKE_EV_MODE_W<SLP_WAKE_CTRL_SPEC> {
                WAKE_EV_MODE_W::new(self, 6)
            }
            ///Bit 7 - RWA, wakeup delay
            #[inline(always)]
            #[must_use]
            pub fn wake_delay(&mut self) -> WAKE_DELAY_W<SLP_WAKE_CTRL_SPEC> {
                WAKE_DELAY_W::new(self, 7)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RWA, wake control, SAM
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`slp_wake_ctrl::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`slp_wake_ctrl::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct SLP_WAKE_CTRL_SPEC;
        impl crate::RegisterSpec for SLP_WAKE_CTRL_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`slp_wake_ctrl::R`](R) reader structure
        impl crate::Readable for SLP_WAKE_CTRL_SPEC {}
        ///`write(|w| ..)` method takes [`slp_wake_ctrl::W`](W) writer structure
        impl crate::Writable for SLP_WAKE_CTRL_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets SLP_WAKE_CTRL to value 0x20
        impl crate::Resettable for SLP_WAKE_CTRL_SPEC {
            const RESET_VALUE: u8 = 0x20;
        }
    }
    ///SLP_POWER_CTRL (rw) register accessor: RWA, peripherals power down control, SAM
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`slp_power_ctrl::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`slp_power_ctrl::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@slp_power_ctrl`]
    ///module
    pub type SLP_POWER_CTRL = crate::Reg<slp_power_ctrl::SLP_POWER_CTRL_SPEC>;
    ///RWA, peripherals power down control, SAM
    pub mod slp_power_ctrl {
        ///Register `SLP_POWER_CTRL` reader
        pub type R = crate::R<SLP_POWER_CTRL_SPEC>;
        ///Register `SLP_POWER_CTRL` writer
        pub type W = crate::W<SLP_POWER_CTRL_SPEC>;
        ///Field `SLP_CLK_RAMX` reader - RWA, close main SRAM clock
        pub type SLP_CLK_RAMX_R = crate::BitReader;
        ///Field `SLP_CLK_RAMX` writer - RWA, close main SRAM clock
        pub type SLP_CLK_RAMX_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `SLP_CLK_RAM2K` reader - RWA, close retention 2KB SRAM clock
        pub type SLP_CLK_RAM2K_R = crate::BitReader;
        ///Field `SLP_CLK_RAM2K` writer - RWA, close retention 2KB SRAM clock
        pub type SLP_CLK_RAM2K_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `RAM_RET_LV` reader - RWA, SRAM retention voltage selection
        pub type RAM_RET_LV_R = crate::BitReader;
        ///Field `RAM_RET_LV` writer - RWA, SRAM retention voltage selection
        pub type RAM_RET_LV_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 4 - RWA, close main SRAM clock
            #[inline(always)]
            pub fn slp_clk_ramx(&self) -> SLP_CLK_RAMX_R {
                SLP_CLK_RAMX_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - RWA, close retention 2KB SRAM clock
            #[inline(always)]
            pub fn slp_clk_ram2k(&self) -> SLP_CLK_RAM2K_R {
                SLP_CLK_RAM2K_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - RWA, SRAM retention voltage selection
            #[inline(always)]
            pub fn ram_ret_lv(&self) -> RAM_RET_LV_R {
                RAM_RET_LV_R::new(((self.bits >> 6) & 1) != 0)
            }
        }
        impl W {
            ///Bit 4 - RWA, close main SRAM clock
            #[inline(always)]
            #[must_use]
            pub fn slp_clk_ramx(&mut self) -> SLP_CLK_RAMX_W<SLP_POWER_CTRL_SPEC> {
                SLP_CLK_RAMX_W::new(self, 4)
            }
            ///Bit 5 - RWA, close retention 2KB SRAM clock
            #[inline(always)]
            #[must_use]
            pub fn slp_clk_ram2k(&mut self) -> SLP_CLK_RAM2K_W<SLP_POWER_CTRL_SPEC> {
                SLP_CLK_RAM2K_W::new(self, 5)
            }
            ///Bit 6 - RWA, SRAM retention voltage selection
            #[inline(always)]
            #[must_use]
            pub fn ram_ret_lv(&mut self) -> RAM_RET_LV_W<SLP_POWER_CTRL_SPEC> {
                RAM_RET_LV_W::new(self, 6)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RWA, peripherals power down control, SAM
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`slp_power_ctrl::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`slp_power_ctrl::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct SLP_POWER_CTRL_SPEC;
        impl crate::RegisterSpec for SLP_POWER_CTRL_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`slp_power_ctrl::R`](R) reader structure
        impl crate::Readable for SLP_POWER_CTRL_SPEC {}
        ///`write(|w| ..)` method takes [`slp_power_ctrl::W`](W) writer structure
        impl crate::Writable for SLP_POWER_CTRL_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets SLP_POWER_CTRL to value 0
        impl crate::Resettable for SLP_POWER_CTRL_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///PIN_ALTERNATE (rw) register accessor: RW, function pin alternate configuration
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`pin_alternate::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pin_alternate::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@pin_alternate`]
    ///module
    pub type PIN_ALTERNATE = crate::Reg<pin_alternate::PIN_ALTERNATE_SPEC>;
    ///RW, function pin alternate configuration
    pub mod pin_alternate {
        ///Register `PIN_ALTERNATE` reader
        pub type R = crate::R<PIN_ALTERNATE_SPEC>;
        ///Register `PIN_ALTERNATE` writer
        pub type W = crate::W<PIN_ALTERNATE_SPEC>;
        ///Field `PIN_TMR0` reader - RW, TMR0 alternate pin enable
        pub type PIN_TMR0_R = crate::BitReader;
        ///Field `PIN_TMR0` writer - RW, TMR0 alternate pin enable
        pub type PIN_TMR0_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PIN_TMR1` reader - RW, TMR1 alternate pin enable
        pub type PIN_TMR1_R = crate::BitReader;
        ///Field `PIN_TMR1` writer - RW, TMR1 alternate pin enable
        pub type PIN_TMR1_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PIN_TMR2` reader - RW, TMR2 alternate pin enable
        pub type PIN_TMR2_R = crate::BitReader;
        ///Field `PIN_TMR2` writer - RW, TMR2 alternate pin enable
        pub type PIN_TMR2_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PIN_UART0` reader - RW, RXD0/TXD0 alternate pin enable
        pub type PIN_UART0_R = crate::BitReader;
        ///Field `PIN_UART0` writer - RW, RXD0/TXD0 alternate pin enable
        pub type PIN_UART0_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PIN_UART1` reader - RW, RXD1/TXD1 alternate pin enable
        pub type PIN_UART1_R = crate::BitReader;
        ///Field `PIN_UART1` writer - RW, RXD1/TXD1 alternate pin enable
        pub type PIN_UART1_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PIN_SPI0` reader - RW, SCS/SCK0/MOSI/MISO alternate pin enable
        pub type PIN_SPI0_R = crate::BitReader;
        ///Field `PIN_SPI0` writer - RW, SCS/SCK0/MOSI/MISO alternate pin enable
        pub type PIN_SPI0_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - RW, TMR0 alternate pin enable
            #[inline(always)]
            pub fn pin_tmr0(&self) -> PIN_TMR0_R {
                PIN_TMR0_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RW, TMR1 alternate pin enable
            #[inline(always)]
            pub fn pin_tmr1(&self) -> PIN_TMR1_R {
                PIN_TMR1_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RW, TMR2 alternate pin enable
            #[inline(always)]
            pub fn pin_tmr2(&self) -> PIN_TMR2_R {
                PIN_TMR2_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 4 - RW, RXD0/TXD0 alternate pin enable
            #[inline(always)]
            pub fn pin_uart0(&self) -> PIN_UART0_R {
                PIN_UART0_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - RW, RXD1/TXD1 alternate pin enable
            #[inline(always)]
            pub fn pin_uart1(&self) -> PIN_UART1_R {
                PIN_UART1_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 8 - RW, SCS/SCK0/MOSI/MISO alternate pin enable
            #[inline(always)]
            pub fn pin_spi0(&self) -> PIN_SPI0_R {
                PIN_SPI0_R::new(((self.bits >> 8) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RW, TMR0 alternate pin enable
            #[inline(always)]
            #[must_use]
            pub fn pin_tmr0(&mut self) -> PIN_TMR0_W<PIN_ALTERNATE_SPEC> {
                PIN_TMR0_W::new(self, 0)
            }
            ///Bit 1 - RW, TMR1 alternate pin enable
            #[inline(always)]
            #[must_use]
            pub fn pin_tmr1(&mut self) -> PIN_TMR1_W<PIN_ALTERNATE_SPEC> {
                PIN_TMR1_W::new(self, 1)
            }
            ///Bit 2 - RW, TMR2 alternate pin enable
            #[inline(always)]
            #[must_use]
            pub fn pin_tmr2(&mut self) -> PIN_TMR2_W<PIN_ALTERNATE_SPEC> {
                PIN_TMR2_W::new(self, 2)
            }
            ///Bit 4 - RW, RXD0/TXD0 alternate pin enable
            #[inline(always)]
            #[must_use]
            pub fn pin_uart0(&mut self) -> PIN_UART0_W<PIN_ALTERNATE_SPEC> {
                PIN_UART0_W::new(self, 4)
            }
            ///Bit 5 - RW, RXD1/TXD1 alternate pin enable
            #[inline(always)]
            #[must_use]
            pub fn pin_uart1(&mut self) -> PIN_UART1_W<PIN_ALTERNATE_SPEC> {
                PIN_UART1_W::new(self, 5)
            }
            ///Bit 8 - RW, SCS/SCK0/MOSI/MISO alternate pin enable
            #[inline(always)]
            #[must_use]
            pub fn pin_spi0(&mut self) -> PIN_SPI0_W<PIN_ALTERNATE_SPEC> {
                PIN_SPI0_W::new(self, 8)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW, function pin alternate configuration
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`pin_alternate::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pin_alternate::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct PIN_ALTERNATE_SPEC;
        impl crate::RegisterSpec for PIN_ALTERNATE_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`pin_alternate::R`](R) reader structure
        impl crate::Readable for PIN_ALTERNATE_SPEC {}
        ///`write(|w| ..)` method takes [`pin_alternate::W`](W) writer structure
        impl crate::Writable for PIN_ALTERNATE_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets PIN_ALTERNATE to value 0
        impl crate::Resettable for PIN_ALTERNATE_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///PIN_ANALOG_IE (rw) register accessor: RW, analog pin enable and digital input disable
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`pin_analog_ie::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pin_analog_ie::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@pin_analog_ie`]
    ///module
    pub type PIN_ANALOG_IE = crate::Reg<pin_analog_ie::PIN_ANALOG_IE_SPEC>;
    ///RW, analog pin enable and digital input disable
    pub mod pin_analog_ie {
        ///Register `PIN_ANALOG_IE` reader
        pub type R = crate::R<PIN_ANALOG_IE_SPEC>;
        ///Register `PIN_ANALOG_IE` writer
        pub type W = crate::W<PIN_ANALOG_IE_SPEC>;
        ///Field `PIN_USB_DP_PU` reader - RW,USB UDP internal pullup resistance enable
        pub type PIN_USB_DP_PU_R = crate::BitReader;
        ///Field `PIN_USB_DP_PU` writer - RW,USB UDP internal pullup resistance enable
        pub type PIN_USB_DP_PU_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PIN_USB_IE` reader - RW, USB analog I/O enable: 0=analog I/O disable, 1=analog I/O enable
        pub type PIN_USB_IE_R = crate::BitReader;
        ///Field `PIN_USB_IE` writer - RW, USB analog I/O enable: 0=analog I/O disable, 1=analog I/O enable
        pub type PIN_USB_IE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PIN_ADC8_9_IE` reader - RW, ADC/TouchKey channel 9/8 digital input disable: 0=digital input enable, 1=digital input disable
        pub type PIN_ADC8_9_IE_R = crate::BitReader;
        ///Field `PIN_ADC8_9_IE` writer - RW, ADC/TouchKey channel 9/8 digital input disable: 0=digital input enable, 1=digital input disable
        pub type PIN_ADC8_9_IE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PIN_ADC0_IE` reader - RW, ADC/TouchKey channel0 digital input disable: 0=digital input enable, 1=digital input disable
        pub type PIN_ADC0_IE_R = crate::BitReader;
        ///Field `PIN_ADC0_IE` writer - RW, ADC/TouchKey channel0 digital input disable: 0=digital input enable, 1=digital input disable
        pub type PIN_ADC0_IE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PIN_ADC1_IE` reader - RW, ADC/TouchKey channel1 digital input disable: 0=digital input enable, 1=digital input disable
        pub type PIN_ADC1_IE_R = crate::BitReader;
        ///Field `PIN_ADC1_IE` writer - RW, ADC/TouchKey channel1 digital input disable: 0=digital input enable, 1=digital input disable
        pub type PIN_ADC1_IE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PIN_ADC12_IE` reader - RW, ADC/TouchKey channel12 digital input disable: 0=digital input enable, 1=digital input disable
        pub type PIN_ADC12_IE_R = crate::BitReader;
        ///Field `PIN_ADC12_IE` writer - RW, ADC/TouchKey channel12 digital input disable: 0=digital input enable, 1=digital input disable
        pub type PIN_ADC12_IE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PIN_ADC13_IE` reader - RW, ADC/TouchKey channel13 digital input disable: 0=digital input enable, 1=digital input disable
        pub type PIN_ADC13_IE_R = crate::BitReader;
        ///Field `PIN_ADC13_IE` writer - RW, ADC/TouchKey channel13 digital input disable: 0=digital input enable, 1=digital input disable
        pub type PIN_ADC13_IE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PIN_XT32K_IE` reader - RW, external 32KHz oscillator digital input disable: 0=digital input enable, 1=digital input disable
        pub type PIN_XT32K_IE_R = crate::BitReader;
        ///Field `PIN_XT32K_IE` writer - RW, external 32KHz oscillator digital input disable: 0=digital input enable, 1=digital input disable
        pub type PIN_XT32K_IE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PIN_ADC2_3_IE` reader - RW, ADC/TouchKey channel 2/3 digital input disable: 0=digital input enable, 1=digital input disable
        pub type PIN_ADC2_3_IE_R = crate::BitReader;
        ///Field `PIN_ADC2_3_IE` writer - RW, ADC/TouchKey channel 2/3 digital input disable: 0=digital input enable, 1=digital input disable
        pub type PIN_ADC2_3_IE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PIN_ADC4_5_IE` reader - RW, ADC/TouchKey channel 4/5 digital input disable: 0=digital input enable, 1=digital input disable
        pub type PIN_ADC4_5_IE_R = crate::BitReader;
        ///Field `PIN_ADC4_5_IE` writer - RW, ADC/TouchKey channel 4/5 digital input disable: 0=digital input enable, 1=digital input disable
        pub type PIN_ADC4_5_IE_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 6 - RW,USB UDP internal pullup resistance enable
            #[inline(always)]
            pub fn pin_usb_dp_pu(&self) -> PIN_USB_DP_PU_R {
                PIN_USB_DP_PU_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - RW, USB analog I/O enable: 0=analog I/O disable, 1=analog I/O enable
            #[inline(always)]
            pub fn pin_usb_ie(&self) -> PIN_USB_IE_R {
                PIN_USB_IE_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bit 8 - RW, ADC/TouchKey channel 9/8 digital input disable: 0=digital input enable, 1=digital input disable
            #[inline(always)]
            pub fn pin_adc8_9_ie(&self) -> PIN_ADC8_9_IE_R {
                PIN_ADC8_9_IE_R::new(((self.bits >> 8) & 1) != 0)
            }
            ///Bit 9 - RW, ADC/TouchKey channel0 digital input disable: 0=digital input enable, 1=digital input disable
            #[inline(always)]
            pub fn pin_adc0_ie(&self) -> PIN_ADC0_IE_R {
                PIN_ADC0_IE_R::new(((self.bits >> 9) & 1) != 0)
            }
            ///Bit 10 - RW, ADC/TouchKey channel1 digital input disable: 0=digital input enable, 1=digital input disable
            #[inline(always)]
            pub fn pin_adc1_ie(&self) -> PIN_ADC1_IE_R {
                PIN_ADC1_IE_R::new(((self.bits >> 10) & 1) != 0)
            }
            ///Bit 11 - RW, ADC/TouchKey channel12 digital input disable: 0=digital input enable, 1=digital input disable
            #[inline(always)]
            pub fn pin_adc12_ie(&self) -> PIN_ADC12_IE_R {
                PIN_ADC12_IE_R::new(((self.bits >> 11) & 1) != 0)
            }
            ///Bit 12 - RW, ADC/TouchKey channel13 digital input disable: 0=digital input enable, 1=digital input disable
            #[inline(always)]
            pub fn pin_adc13_ie(&self) -> PIN_ADC13_IE_R {
                PIN_ADC13_IE_R::new(((self.bits >> 12) & 1) != 0)
            }
            ///Bit 13 - RW, external 32KHz oscillator digital input disable: 0=digital input enable, 1=digital input disable
            #[inline(always)]
            pub fn pin_xt32k_ie(&self) -> PIN_XT32K_IE_R {
                PIN_XT32K_IE_R::new(((self.bits >> 13) & 1) != 0)
            }
            ///Bit 14 - RW, ADC/TouchKey channel 2/3 digital input disable: 0=digital input enable, 1=digital input disable
            #[inline(always)]
            pub fn pin_adc2_3_ie(&self) -> PIN_ADC2_3_IE_R {
                PIN_ADC2_3_IE_R::new(((self.bits >> 14) & 1) != 0)
            }
            ///Bit 15 - RW, ADC/TouchKey channel 4/5 digital input disable: 0=digital input enable, 1=digital input disable
            #[inline(always)]
            pub fn pin_adc4_5_ie(&self) -> PIN_ADC4_5_IE_R {
                PIN_ADC4_5_IE_R::new(((self.bits >> 15) & 1) != 0)
            }
        }
        impl W {
            ///Bit 6 - RW,USB UDP internal pullup resistance enable
            #[inline(always)]
            #[must_use]
            pub fn pin_usb_dp_pu(&mut self) -> PIN_USB_DP_PU_W<PIN_ANALOG_IE_SPEC> {
                PIN_USB_DP_PU_W::new(self, 6)
            }
            ///Bit 7 - RW, USB analog I/O enable: 0=analog I/O disable, 1=analog I/O enable
            #[inline(always)]
            #[must_use]
            pub fn pin_usb_ie(&mut self) -> PIN_USB_IE_W<PIN_ANALOG_IE_SPEC> {
                PIN_USB_IE_W::new(self, 7)
            }
            ///Bit 8 - RW, ADC/TouchKey channel 9/8 digital input disable: 0=digital input enable, 1=digital input disable
            #[inline(always)]
            #[must_use]
            pub fn pin_adc8_9_ie(&mut self) -> PIN_ADC8_9_IE_W<PIN_ANALOG_IE_SPEC> {
                PIN_ADC8_9_IE_W::new(self, 8)
            }
            ///Bit 9 - RW, ADC/TouchKey channel0 digital input disable: 0=digital input enable, 1=digital input disable
            #[inline(always)]
            #[must_use]
            pub fn pin_adc0_ie(&mut self) -> PIN_ADC0_IE_W<PIN_ANALOG_IE_SPEC> {
                PIN_ADC0_IE_W::new(self, 9)
            }
            ///Bit 10 - RW, ADC/TouchKey channel1 digital input disable: 0=digital input enable, 1=digital input disable
            #[inline(always)]
            #[must_use]
            pub fn pin_adc1_ie(&mut self) -> PIN_ADC1_IE_W<PIN_ANALOG_IE_SPEC> {
                PIN_ADC1_IE_W::new(self, 10)
            }
            ///Bit 11 - RW, ADC/TouchKey channel12 digital input disable: 0=digital input enable, 1=digital input disable
            #[inline(always)]
            #[must_use]
            pub fn pin_adc12_ie(&mut self) -> PIN_ADC12_IE_W<PIN_ANALOG_IE_SPEC> {
                PIN_ADC12_IE_W::new(self, 11)
            }
            ///Bit 12 - RW, ADC/TouchKey channel13 digital input disable: 0=digital input enable, 1=digital input disable
            #[inline(always)]
            #[must_use]
            pub fn pin_adc13_ie(&mut self) -> PIN_ADC13_IE_W<PIN_ANALOG_IE_SPEC> {
                PIN_ADC13_IE_W::new(self, 12)
            }
            ///Bit 13 - RW, external 32KHz oscillator digital input disable: 0=digital input enable, 1=digital input disable
            #[inline(always)]
            #[must_use]
            pub fn pin_xt32k_ie(&mut self) -> PIN_XT32K_IE_W<PIN_ANALOG_IE_SPEC> {
                PIN_XT32K_IE_W::new(self, 13)
            }
            ///Bit 14 - RW, ADC/TouchKey channel 2/3 digital input disable: 0=digital input enable, 1=digital input disable
            #[inline(always)]
            #[must_use]
            pub fn pin_adc2_3_ie(&mut self) -> PIN_ADC2_3_IE_W<PIN_ANALOG_IE_SPEC> {
                PIN_ADC2_3_IE_W::new(self, 14)
            }
            ///Bit 15 - RW, ADC/TouchKey channel 4/5 digital input disable: 0=digital input enable, 1=digital input disable
            #[inline(always)]
            #[must_use]
            pub fn pin_adc4_5_ie(&mut self) -> PIN_ADC4_5_IE_W<PIN_ANALOG_IE_SPEC> {
                PIN_ADC4_5_IE_W::new(self, 15)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW, analog pin enable and digital input disable
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`pin_analog_ie::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pin_analog_ie::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct PIN_ANALOG_IE_SPEC;
        impl crate::RegisterSpec for PIN_ANALOG_IE_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`pin_analog_ie::R`](R) reader structure
        impl crate::Readable for PIN_ANALOG_IE_SPEC {}
        ///`write(|w| ..)` method takes [`pin_analog_ie::W`](W) writer structure
        impl crate::Writable for PIN_ANALOG_IE_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets PIN_ANALOG_IE to value 0
        impl crate::Resettable for PIN_ANALOG_IE_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///POWER_PLAN (rw) register accessor: RWA, power plan before sleep instruction, SAM
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`power_plan::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`power_plan::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@power_plan`]
    ///module
    pub type POWER_PLAN = crate::Reg<power_plan::POWER_PLAN_SPEC>;
    ///RWA, power plan before sleep instruction, SAM
    pub mod power_plan {
        ///Register `POWER_PLAN` reader
        pub type R = crate::R<POWER_PLAN_SPEC>;
        ///Register `POWER_PLAN` writer
        pub type W = crate::W<POWER_PLAN_SPEC>;
        ///Field `PWR_XROM` reader - RWA, power for retention 2KB SRAM
        pub type PWR_XROM_R = crate::BitReader;
        ///Field `PWR_XROM` writer - RWA, power for retention 2KB SRAM
        pub type PWR_XROM_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PWR_RAM2K` reader - RWA, power for retention 2KB SRAM
        pub type PWR_RAM2K_R = crate::BitReader;
        ///Field `PWR_RAM2K` writer - RWA, power for retention 2KB SRAM
        pub type PWR_RAM2K_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PWR_CORE` reader - RWA, power retention for core and base peripherals
        pub type PWR_CORE_R = crate::BitReader;
        ///Field `PWR_CORE` writer - RWA, power retention for core and base peripherals
        pub type PWR_CORE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PWR_EXTEND` reader - RWA, power retention for USB and BLE
        pub type PWR_EXTEND_R = crate::BitReader;
        ///Field `PWR_EXTEND` writer - RWA, power retention for USB and BLE
        pub type PWR_EXTEND_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PWR_RAM16K` reader - RWA, power for main SRAM
        pub type PWR_RAM16K_R = crate::BitReader;
        ///Field `PWR_RAM16K` writer - RWA, power for main SRAM
        pub type PWR_RAM16K_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PWR_SYS_EN` reader - RWA, power for system
        pub type PWR_SYS_EN_R = crate::BitReader;
        ///Field `PWR_SYS_EN` writer - RWA, power for system
        pub type PWR_SYS_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PWR_LDO_EN` reader - RWA, LDO enable
        pub type PWR_LDO_EN_R = crate::BitReader;
        ///Field `PWR_LDO_EN` writer - RWA, LDO enable
        pub type PWR_LDO_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PWR_DCDC_EN` reader - RWA, DC/DC converter enable: 0=DC/DC disable and bypass, 1=DC/DC enable
        pub type PWR_DCDC_EN_R = crate::BitReader;
        ///Field `PWR_DCDC_EN` writer - RWA, DC/DC converter enable: 0=DC/DC disable and bypass, 1=DC/DC enable
        pub type PWR_DCDC_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PWR_DCDC_PRE` reader - RWA, DC/DC converter pre-enable
        pub type PWR_DCDC_PRE_R = crate::BitReader;
        ///Field `PWR_DCDC_PRE` writer - RWA, DC/DC converter pre-enable
        pub type PWR_DCDC_PRE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PWR_MUST_0010` reader - RWA, power plan enable, auto clear after sleep executed
        pub type PWR_MUST_0010_R = crate::FieldReader;
        ///Field `PWR_PLAN_EN` reader - RWA, must write 0010
        pub type PWR_PLAN_EN_R = crate::BitReader;
        impl R {
            ///Bit 0 - RWA, power for retention 2KB SRAM
            #[inline(always)]
            pub fn pwr_xrom(&self) -> PWR_XROM_R {
                PWR_XROM_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RWA, power for retention 2KB SRAM
            #[inline(always)]
            pub fn pwr_ram2k(&self) -> PWR_RAM2K_R {
                PWR_RAM2K_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RWA, power retention for core and base peripherals
            #[inline(always)]
            pub fn pwr_core(&self) -> PWR_CORE_R {
                PWR_CORE_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RWA, power retention for USB and BLE
            #[inline(always)]
            pub fn pwr_extend(&self) -> PWR_EXTEND_R {
                PWR_EXTEND_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RWA, power for main SRAM
            #[inline(always)]
            pub fn pwr_ram16k(&self) -> PWR_RAM16K_R {
                PWR_RAM16K_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 7 - RWA, power for system
            #[inline(always)]
            pub fn pwr_sys_en(&self) -> PWR_SYS_EN_R {
                PWR_SYS_EN_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bit 8 - RWA, LDO enable
            #[inline(always)]
            pub fn pwr_ldo_en(&self) -> PWR_LDO_EN_R {
                PWR_LDO_EN_R::new(((self.bits >> 8) & 1) != 0)
            }
            ///Bit 9 - RWA, DC/DC converter enable: 0=DC/DC disable and bypass, 1=DC/DC enable
            #[inline(always)]
            pub fn pwr_dcdc_en(&self) -> PWR_DCDC_EN_R {
                PWR_DCDC_EN_R::new(((self.bits >> 9) & 1) != 0)
            }
            ///Bit 10 - RWA, DC/DC converter pre-enable
            #[inline(always)]
            pub fn pwr_dcdc_pre(&self) -> PWR_DCDC_PRE_R {
                PWR_DCDC_PRE_R::new(((self.bits >> 10) & 1) != 0)
            }
            ///Bits 11:14 - RWA, power plan enable, auto clear after sleep executed
            #[inline(always)]
            pub fn pwr_must_0010(&self) -> PWR_MUST_0010_R {
                PWR_MUST_0010_R::new(((self.bits >> 11) & 0x0f) as u8)
            }
            ///Bit 15 - RWA, must write 0010
            #[inline(always)]
            pub fn pwr_plan_en(&self) -> PWR_PLAN_EN_R {
                PWR_PLAN_EN_R::new(((self.bits >> 15) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RWA, power for retention 2KB SRAM
            #[inline(always)]
            #[must_use]
            pub fn pwr_xrom(&mut self) -> PWR_XROM_W<POWER_PLAN_SPEC> {
                PWR_XROM_W::new(self, 0)
            }
            ///Bit 1 - RWA, power for retention 2KB SRAM
            #[inline(always)]
            #[must_use]
            pub fn pwr_ram2k(&mut self) -> PWR_RAM2K_W<POWER_PLAN_SPEC> {
                PWR_RAM2K_W::new(self, 1)
            }
            ///Bit 2 - RWA, power retention for core and base peripherals
            #[inline(always)]
            #[must_use]
            pub fn pwr_core(&mut self) -> PWR_CORE_W<POWER_PLAN_SPEC> {
                PWR_CORE_W::new(self, 2)
            }
            ///Bit 3 - RWA, power retention for USB and BLE
            #[inline(always)]
            #[must_use]
            pub fn pwr_extend(&mut self) -> PWR_EXTEND_W<POWER_PLAN_SPEC> {
                PWR_EXTEND_W::new(self, 3)
            }
            ///Bit 4 - RWA, power for main SRAM
            #[inline(always)]
            #[must_use]
            pub fn pwr_ram16k(&mut self) -> PWR_RAM16K_W<POWER_PLAN_SPEC> {
                PWR_RAM16K_W::new(self, 4)
            }
            ///Bit 7 - RWA, power for system
            #[inline(always)]
            #[must_use]
            pub fn pwr_sys_en(&mut self) -> PWR_SYS_EN_W<POWER_PLAN_SPEC> {
                PWR_SYS_EN_W::new(self, 7)
            }
            ///Bit 8 - RWA, LDO enable
            #[inline(always)]
            #[must_use]
            pub fn pwr_ldo_en(&mut self) -> PWR_LDO_EN_W<POWER_PLAN_SPEC> {
                PWR_LDO_EN_W::new(self, 8)
            }
            ///Bit 9 - RWA, DC/DC converter enable: 0=DC/DC disable and bypass, 1=DC/DC enable
            #[inline(always)]
            #[must_use]
            pub fn pwr_dcdc_en(&mut self) -> PWR_DCDC_EN_W<POWER_PLAN_SPEC> {
                PWR_DCDC_EN_W::new(self, 9)
            }
            ///Bit 10 - RWA, DC/DC converter pre-enable
            #[inline(always)]
            #[must_use]
            pub fn pwr_dcdc_pre(&mut self) -> PWR_DCDC_PRE_W<POWER_PLAN_SPEC> {
                PWR_DCDC_PRE_W::new(self, 10)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RWA, power plan before sleep instruction, SAM
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`power_plan::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`power_plan::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct POWER_PLAN_SPEC;
        impl crate::RegisterSpec for POWER_PLAN_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`power_plan::R`](R) reader structure
        impl crate::Readable for POWER_PLAN_SPEC {}
        ///`write(|w| ..)` method takes [`power_plan::W`](W) writer structure
        impl crate::Writable for POWER_PLAN_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets POWER_PLAN to value 0x11df
        impl crate::Resettable for POWER_PLAN_SPEC {
            const RESET_VALUE: u16 = 0x11df;
        }
    }
    ///AUX_POWER_ADJ (rw) register accessor: RWA, aux power adjust control, SAM
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`aux_power_adj::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`aux_power_adj::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@aux_power_adj`]
    ///module
    pub type AUX_POWER_ADJ = crate::Reg<aux_power_adj::AUX_POWER_ADJ_SPEC>;
    ///RWA, aux power adjust control, SAM
    pub mod aux_power_adj {
        ///Register `AUX_POWER_ADJ` reader
        pub type R = crate::R<AUX_POWER_ADJ_SPEC>;
        ///Register `AUX_POWER_ADJ` writer
        pub type W = crate::W<AUX_POWER_ADJ_SPEC>;
        ///Field `ULPLDO_ADJ` reader - RWA, Ultra-Low-Power LDO voltage adjust
        pub type ULPLDO_ADJ_R = crate::FieldReader;
        ///Field `ULPLDO_ADJ` writer - RWA, Ultra-Low-Power LDO voltage adjust
        pub type ULPLDO_ADJ_W<'a, REG> = crate::FieldWriter<'a, REG, 3>;
        impl R {
            ///Bits 0:2 - RWA, Ultra-Low-Power LDO voltage adjust
            #[inline(always)]
            pub fn ulpldo_adj(&self) -> ULPLDO_ADJ_R {
                ULPLDO_ADJ_R::new(self.bits & 7)
            }
        }
        impl W {
            ///Bits 0:2 - RWA, Ultra-Low-Power LDO voltage adjust
            #[inline(always)]
            #[must_use]
            pub fn ulpldo_adj(&mut self) -> ULPLDO_ADJ_W<AUX_POWER_ADJ_SPEC> {
                ULPLDO_ADJ_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RWA, aux power adjust control, SAM
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`aux_power_adj::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`aux_power_adj::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct AUX_POWER_ADJ_SPEC;
        impl crate::RegisterSpec for AUX_POWER_ADJ_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`aux_power_adj::R`](R) reader structure
        impl crate::Readable for AUX_POWER_ADJ_SPEC {}
        ///`write(|w| ..)` method takes [`aux_power_adj::W`](W) writer structure
        impl crate::Writable for AUX_POWER_ADJ_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets AUX_POWER_ADJ to value 0
        impl crate::Resettable for AUX_POWER_ADJ_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///BAT_DET_CTRL (rw) register accessor: RWA, battery voltage detector control, SAM
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`bat_det_ctrl::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`bat_det_ctrl::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@bat_det_ctrl`]
    ///module
    pub type BAT_DET_CTRL = crate::Reg<bat_det_ctrl::BAT_DET_CTRL_SPEC>;
    ///RWA, battery voltage detector control, SAM
    pub mod bat_det_ctrl {
        ///Register `BAT_DET_CTRL` reader
        pub type R = crate::R<BAT_DET_CTRL_SPEC>;
        ///Register `BAT_DET_CTRL` writer
        pub type W = crate::W<BAT_DET_CTRL_SPEC>;
        ///Field `BAT_DET_EN__RB_BAT_LOW_VTHX` reader - RWA, battery voltage detector enable/select monitor threshold voltage
        pub type BAT_DET_EN__RB_BAT_LOW_VTHX_R = crate::BitReader;
        ///Field `BAT_DET_EN__RB_BAT_LOW_VTHX` writer - RWA, battery voltage detector enable/select monitor threshold voltage
        pub type BAT_DET_EN__RB_BAT_LOW_VTHX_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `BAT_MON_EN` reader - RWA, battery voltage monitor enable under sleep mode
        pub type BAT_MON_EN_R = crate::BitReader;
        ///Field `BAT_MON_EN` writer - RWA, battery voltage monitor enable under sleep mode
        pub type BAT_MON_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `BAT_LOWER_IE` reader - RWA, interrupt enable for battery lower voltage
        pub type BAT_LOWER_IE_R = crate::BitReader;
        ///Field `BAT_LOWER_IE` writer - RWA, interrupt enable for battery lower voltage
        pub type BAT_LOWER_IE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `BAT_LOW_IE` reader - RWA, interrupt enable for battery low voltage
        pub type BAT_LOW_IE_R = crate::BitReader;
        ///Field `BAT_LOW_IE` writer - RWA, interrupt enable for battery low voltage
        pub type BAT_LOW_IE_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - RWA, battery voltage detector enable/select monitor threshold voltage
            #[inline(always)]
            pub fn bat_det_en__rb_bat_low_vthx(&self) -> BAT_DET_EN__RB_BAT_LOW_VTHX_R {
                BAT_DET_EN__RB_BAT_LOW_VTHX_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RWA, battery voltage monitor enable under sleep mode
            #[inline(always)]
            pub fn bat_mon_en(&self) -> BAT_MON_EN_R {
                BAT_MON_EN_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RWA, interrupt enable for battery lower voltage
            #[inline(always)]
            pub fn bat_lower_ie(&self) -> BAT_LOWER_IE_R {
                BAT_LOWER_IE_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RWA, interrupt enable for battery low voltage
            #[inline(always)]
            pub fn bat_low_ie(&self) -> BAT_LOW_IE_R {
                BAT_LOW_IE_R::new(((self.bits >> 3) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RWA, battery voltage detector enable/select monitor threshold voltage
            #[inline(always)]
            #[must_use]
            pub fn bat_det_en__rb_bat_low_vthx(
                &mut self,
            ) -> BAT_DET_EN__RB_BAT_LOW_VTHX_W<BAT_DET_CTRL_SPEC> {
                BAT_DET_EN__RB_BAT_LOW_VTHX_W::new(self, 0)
            }
            ///Bit 1 - RWA, battery voltage monitor enable under sleep mode
            #[inline(always)]
            #[must_use]
            pub fn bat_mon_en(&mut self) -> BAT_MON_EN_W<BAT_DET_CTRL_SPEC> {
                BAT_MON_EN_W::new(self, 1)
            }
            ///Bit 2 - RWA, interrupt enable for battery lower voltage
            #[inline(always)]
            #[must_use]
            pub fn bat_lower_ie(&mut self) -> BAT_LOWER_IE_W<BAT_DET_CTRL_SPEC> {
                BAT_LOWER_IE_W::new(self, 2)
            }
            ///Bit 3 - RWA, interrupt enable for battery low voltage
            #[inline(always)]
            #[must_use]
            pub fn bat_low_ie(&mut self) -> BAT_LOW_IE_W<BAT_DET_CTRL_SPEC> {
                BAT_LOW_IE_W::new(self, 3)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RWA, battery voltage detector control, SAM
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`bat_det_ctrl::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`bat_det_ctrl::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct BAT_DET_CTRL_SPEC;
        impl crate::RegisterSpec for BAT_DET_CTRL_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`bat_det_ctrl::R`](R) reader structure
        impl crate::Readable for BAT_DET_CTRL_SPEC {}
        ///`write(|w| ..)` method takes [`bat_det_ctrl::W`](W) writer structure
        impl crate::Writable for BAT_DET_CTRL_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets BAT_DET_CTRL to value 0
        impl crate::Resettable for BAT_DET_CTRL_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///BAT_DET_CFG (rw) register accessor: RWA, battery voltage detector configuration, SAM
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`bat_det_cfg::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`bat_det_cfg::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@bat_det_cfg`]
    ///module
    pub type BAT_DET_CFG = crate::Reg<bat_det_cfg::BAT_DET_CFG_SPEC>;
    ///RWA, battery voltage detector configuration, SAM
    pub mod bat_det_cfg {
        ///Register `BAT_DET_CFG` reader
        pub type R = crate::R<BAT_DET_CFG_SPEC>;
        ///Register `BAT_DET_CFG` writer
        pub type W = crate::W<BAT_DET_CFG_SPEC>;
        ///Field `BAT_LOW_VTH` reader - RWA, select threshold voltage of battery voltage low
        pub type BAT_LOW_VTH_R = crate::FieldReader;
        ///Field `BAT_LOW_VTH` writer - RWA, select threshold voltage of battery voltage low
        pub type BAT_LOW_VTH_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        impl R {
            ///Bits 0:1 - RWA, select threshold voltage of battery voltage low
            #[inline(always)]
            pub fn bat_low_vth(&self) -> BAT_LOW_VTH_R {
                BAT_LOW_VTH_R::new(self.bits & 3)
            }
        }
        impl W {
            ///Bits 0:1 - RWA, select threshold voltage of battery voltage low
            #[inline(always)]
            #[must_use]
            pub fn bat_low_vth(&mut self) -> BAT_LOW_VTH_W<BAT_DET_CFG_SPEC> {
                BAT_LOW_VTH_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RWA, battery voltage detector configuration, SAM
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`bat_det_cfg::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`bat_det_cfg::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct BAT_DET_CFG_SPEC;
        impl crate::RegisterSpec for BAT_DET_CFG_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`bat_det_cfg::R`](R) reader structure
        impl crate::Readable for BAT_DET_CFG_SPEC {}
        ///`write(|w| ..)` method takes [`bat_det_cfg::W`](W) writer structure
        impl crate::Writable for BAT_DET_CFG_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets BAT_DET_CFG to value 0x01
        impl crate::Resettable for BAT_DET_CFG_SPEC {
            const RESET_VALUE: u8 = 0x01;
        }
    }
    ///BAT_STATUS (r) register accessor: RO, battery status
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`bat_status::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@bat_status`]
    ///module
    pub type BAT_STATUS = crate::Reg<bat_status::BAT_STATUS_SPEC>;
    ///RO, battery status
    pub mod bat_status {
        ///Register `BAT_STATUS` reader
        pub type R = crate::R<BAT_STATUS_SPEC>;
        ///Field `BAT_STAT_LOWER` reader - RO, battery lower voltage status, high action
        pub type BAT_STAT_LOWER_R = crate::BitReader;
        ///Field `BAT_STAT_LOW` reader - RO, battery low voltage status, high action
        pub type BAT_STAT_LOW_R = crate::BitReader;
        impl R {
            ///Bit 0 - RO, battery lower voltage status, high action
            #[inline(always)]
            pub fn bat_stat_lower(&self) -> BAT_STAT_LOWER_R {
                BAT_STAT_LOWER_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RO, battery low voltage status, high action
            #[inline(always)]
            pub fn bat_stat_low(&self) -> BAT_STAT_LOW_R {
                BAT_STAT_LOW_R::new(((self.bits >> 1) & 1) != 0)
            }
        }
        ///RO, battery status
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`bat_status::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct BAT_STATUS_SPEC;
        impl crate::RegisterSpec for BAT_STATUS_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`bat_status::R`](R) reader structure
        impl crate::Readable for BAT_STATUS_SPEC {}
        ///`reset()` method sets BAT_STATUS to value 0
        impl crate::Resettable for BAT_STATUS_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///INT32K_TUNE (rw) register accessor: RWA, internal 32KHz oscillator tune control, SAM
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`int32k_tune::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`int32k_tune::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@int32k_tune`]
    ///module
    pub type INT32K_TUNE = crate::Reg<int32k_tune::INT32K_TUNE_SPEC>;
    ///RWA, internal 32KHz oscillator tune control, SAM
    pub mod int32k_tune {
        ///Register `INT32K_TUNE` reader
        pub type R = crate::R<INT32K_TUNE_SPEC>;
        ///Register `INT32K_TUNE` writer
        pub type W = crate::W<INT32K_TUNE_SPEC>;
        ///Field `INT32K_TUNE` reader - RWA, internal 32KHz oscillator frequency tune
        pub type INT32K_TUNE_R = crate::FieldReader<u16>;
        ///Field `INT32K_TUNE` writer - RWA, internal 32KHz oscillator frequency tune
        pub type INT32K_TUNE_W<'a, REG> = crate::FieldWriter<'a, REG, 12, u16>;
        impl R {
            ///Bits 0:11 - RWA, internal 32KHz oscillator frequency tune
            #[inline(always)]
            pub fn int32k_tune(&self) -> INT32K_TUNE_R {
                INT32K_TUNE_R::new(self.bits & 0x0fff)
            }
        }
        impl W {
            ///Bits 0:11 - RWA, internal 32KHz oscillator frequency tune
            #[inline(always)]
            #[must_use]
            pub fn int32k_tune(&mut self) -> INT32K_TUNE_W<INT32K_TUNE_SPEC> {
                INT32K_TUNE_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RWA, internal 32KHz oscillator tune control, SAM
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`int32k_tune::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`int32k_tune::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct INT32K_TUNE_SPEC;
        impl crate::RegisterSpec for INT32K_TUNE_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`int32k_tune::R`](R) reader structure
        impl crate::Readable for INT32K_TUNE_SPEC {}
        ///`write(|w| ..)` method takes [`int32k_tune::W`](W) writer structure
        impl crate::Writable for INT32K_TUNE_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets INT32K_TUNE to value 0x0800
        impl crate::Resettable for INT32K_TUNE_SPEC {
            const RESET_VALUE: u16 = 0x0800;
        }
    }
    ///XT32K_TUNE (rw) register accessor: RWA, external 32KHz oscillator tune control, SAM
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`xt32k_tune::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`xt32k_tune::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@xt32k_tune`]
    ///module
    pub type XT32K_TUNE = crate::Reg<xt32k_tune::XT32K_TUNE_SPEC>;
    ///RWA, external 32KHz oscillator tune control, SAM
    pub mod xt32k_tune {
        ///Register `XT32K_TUNE` reader
        pub type R = crate::R<XT32K_TUNE_SPEC>;
        ///Register `XT32K_TUNE` writer
        pub type W = crate::W<XT32K_TUNE_SPEC>;
        ///Field `XT32K_I_TUNE` reader - RWA, external 32KHz oscillator current tune: 00=75% current, 01=standard current, 10=150% current, 11=200% current
        pub type XT32K_I_TUNE_R = crate::FieldReader;
        ///Field `XT32K_I_TUNE` writer - RWA, external 32KHz oscillator current tune: 00=75% current, 01=standard current, 10=150% current, 11=200% current
        pub type XT32K_I_TUNE_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `XT32K_C_LOAD` reader - RWA, external 32KHz oscillator load capacitor tune: Cap = RB_XT32K_C_LOAD + 12pF
        pub type XT32K_C_LOAD_R = crate::FieldReader;
        ///Field `XT32K_C_LOAD` writer - RWA, external 32KHz oscillator load capacitor tune: Cap = RB_XT32K_C_LOAD + 12pF
        pub type XT32K_C_LOAD_W<'a, REG> = crate::FieldWriter<'a, REG, 4>;
        impl R {
            ///Bits 0:1 - RWA, external 32KHz oscillator current tune: 00=75% current, 01=standard current, 10=150% current, 11=200% current
            #[inline(always)]
            pub fn xt32k_i_tune(&self) -> XT32K_I_TUNE_R {
                XT32K_I_TUNE_R::new(self.bits & 3)
            }
            ///Bits 4:7 - RWA, external 32KHz oscillator load capacitor tune: Cap = RB_XT32K_C_LOAD + 12pF
            #[inline(always)]
            pub fn xt32k_c_load(&self) -> XT32K_C_LOAD_R {
                XT32K_C_LOAD_R::new((self.bits >> 4) & 0x0f)
            }
        }
        impl W {
            ///Bits 0:1 - RWA, external 32KHz oscillator current tune: 00=75% current, 01=standard current, 10=150% current, 11=200% current
            #[inline(always)]
            #[must_use]
            pub fn xt32k_i_tune(&mut self) -> XT32K_I_TUNE_W<XT32K_TUNE_SPEC> {
                XT32K_I_TUNE_W::new(self, 0)
            }
            ///Bits 4:7 - RWA, external 32KHz oscillator load capacitor tune: Cap = RB_XT32K_C_LOAD + 12pF
            #[inline(always)]
            #[must_use]
            pub fn xt32k_c_load(&mut self) -> XT32K_C_LOAD_W<XT32K_TUNE_SPEC> {
                XT32K_C_LOAD_W::new(self, 4)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RWA, external 32KHz oscillator tune control, SAM
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`xt32k_tune::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`xt32k_tune::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct XT32K_TUNE_SPEC;
        impl crate::RegisterSpec for XT32K_TUNE_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`xt32k_tune::R`](R) reader structure
        impl crate::Readable for XT32K_TUNE_SPEC {}
        ///`write(|w| ..)` method takes [`xt32k_tune::W`](W) writer structure
        impl crate::Writable for XT32K_TUNE_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets XT32K_TUNE to value 0xc3
        impl crate::Resettable for XT32K_TUNE_SPEC {
            const RESET_VALUE: u8 = 0xc3;
        }
    }
    ///CK32K_CONFIG (rw) register accessor: RWA, 32KHz oscillator configure
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`ck32k_config::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ck32k_config::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@ck32k_config`]
    ///module
    pub type CK32K_CONFIG = crate::Reg<ck32k_config::CK32K_CONFIG_SPEC>;
    ///RWA, 32KHz oscillator configure
    pub mod ck32k_config {
        ///Register `CK32K_CONFIG` reader
        pub type R = crate::R<CK32K_CONFIG_SPEC>;
        ///Register `CK32K_CONFIG` writer
        pub type W = crate::W<CK32K_CONFIG_SPEC>;
        ///Field `CLK_XT32K_PON` reader - RWA, external 32KHz oscillator power on
        pub type CLK_XT32K_PON_R = crate::BitReader;
        ///Field `CLK_XT32K_PON` writer - RWA, external 32KHz oscillator power on
        pub type CLK_XT32K_PON_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CLK_INT32K_PON` reader - RWA, internal 32KHz oscillator power on
        pub type CLK_INT32K_PON_R = crate::BitReader;
        ///Field `CLK_INT32K_PON` writer - RWA, internal 32KHz oscillator power on
        pub type CLK_INT32K_PON_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CLK_OSC32K_XT` reader - RWA, 32KHz oscillator source selection: 0=RC, 1=XT
        pub type CLK_OSC32K_XT_R = crate::BitReader;
        ///Field `CLK_OSC32K_XT` writer - RWA, 32KHz oscillator source selection: 0=RC, 1=XT
        pub type CLK_OSC32K_XT_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CLK_32K_PIN` reader - RO, 32KHz oscillator clock pin status
        pub type CLK_32K_PIN_R = crate::BitReader;
        impl R {
            ///Bit 0 - RWA, external 32KHz oscillator power on
            #[inline(always)]
            pub fn clk_xt32k_pon(&self) -> CLK_XT32K_PON_R {
                CLK_XT32K_PON_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RWA, internal 32KHz oscillator power on
            #[inline(always)]
            pub fn clk_int32k_pon(&self) -> CLK_INT32K_PON_R {
                CLK_INT32K_PON_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RWA, 32KHz oscillator source selection: 0=RC, 1=XT
            #[inline(always)]
            pub fn clk_osc32k_xt(&self) -> CLK_OSC32K_XT_R {
                CLK_OSC32K_XT_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 7 - RO, 32KHz oscillator clock pin status
            #[inline(always)]
            pub fn clk_32k_pin(&self) -> CLK_32K_PIN_R {
                CLK_32K_PIN_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RWA, external 32KHz oscillator power on
            #[inline(always)]
            #[must_use]
            pub fn clk_xt32k_pon(&mut self) -> CLK_XT32K_PON_W<CK32K_CONFIG_SPEC> {
                CLK_XT32K_PON_W::new(self, 0)
            }
            ///Bit 1 - RWA, internal 32KHz oscillator power on
            #[inline(always)]
            #[must_use]
            pub fn clk_int32k_pon(&mut self) -> CLK_INT32K_PON_W<CK32K_CONFIG_SPEC> {
                CLK_INT32K_PON_W::new(self, 1)
            }
            ///Bit 2 - RWA, 32KHz oscillator source selection: 0=RC, 1=XT
            #[inline(always)]
            #[must_use]
            pub fn clk_osc32k_xt(&mut self) -> CLK_OSC32K_XT_W<CK32K_CONFIG_SPEC> {
                CLK_OSC32K_XT_W::new(self, 2)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RWA, 32KHz oscillator configure
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`ck32k_config::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ck32k_config::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct CK32K_CONFIG_SPEC;
        impl crate::RegisterSpec for CK32K_CONFIG_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`ck32k_config::R`](R) reader structure
        impl crate::Readable for CK32K_CONFIG_SPEC {}
        ///`write(|w| ..)` method takes [`ck32k_config::W`](W) writer structure
        impl crate::Writable for CK32K_CONFIG_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets CK32K_CONFIG to value 0x02
        impl crate::Resettable for CK32K_CONFIG_SPEC {
            const RESET_VALUE: u8 = 0x02;
        }
    }
    ///RTC_FLAG_CTRL (rw) register accessor: RW, RTC flag and clear control
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`rtc_flag_ctrl::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`rtc_flag_ctrl::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@rtc_flag_ctrl`]
    ///module
    pub type RTC_FLAG_CTRL = crate::Reg<rtc_flag_ctrl::RTC_FLAG_CTRL_SPEC>;
    ///RW, RTC flag and clear control
    pub mod rtc_flag_ctrl {
        ///Register `RTC_FLAG_CTRL` reader
        pub type R = crate::R<RTC_FLAG_CTRL_SPEC>;
        ///Register `RTC_FLAG_CTRL` writer
        pub type W = crate::W<RTC_FLAG_CTRL_SPEC>;
        ///Field `RTC_TMR_CLR` reader - RW, set 1 to clear RTC timer action flag, auto clear
        pub type RTC_TMR_CLR_R = crate::BitReader;
        ///Field `RTC_TMR_CLR` writer - RW, set 1 to clear RTC timer action flag, auto clear
        pub type RTC_TMR_CLR_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `RTC_TRIG_CLR` reader - RW, set 1 to clear RTC trigger action flag, auto clear
        pub type RTC_TRIG_CLR_R = crate::BitReader;
        ///Field `RTC_TRIG_CLR` writer - RW, set 1 to clear RTC trigger action flag, auto clear
        pub type RTC_TRIG_CLR_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `RTC_TMR_FLAG` reader - RO, RTC timer action flag
        pub type RTC_TMR_FLAG_R = crate::BitReader;
        ///Field `RTC_TRIG_FLAG` reader - RO, RTC trigger action flag
        pub type RTC_TRIG_FLAG_R = crate::BitReader;
        impl R {
            ///Bit 4 - RW, set 1 to clear RTC timer action flag, auto clear
            #[inline(always)]
            pub fn rtc_tmr_clr(&self) -> RTC_TMR_CLR_R {
                RTC_TMR_CLR_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - RW, set 1 to clear RTC trigger action flag, auto clear
            #[inline(always)]
            pub fn rtc_trig_clr(&self) -> RTC_TRIG_CLR_R {
                RTC_TRIG_CLR_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - RO, RTC timer action flag
            #[inline(always)]
            pub fn rtc_tmr_flag(&self) -> RTC_TMR_FLAG_R {
                RTC_TMR_FLAG_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - RO, RTC trigger action flag
            #[inline(always)]
            pub fn rtc_trig_flag(&self) -> RTC_TRIG_FLAG_R {
                RTC_TRIG_FLAG_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 4 - RW, set 1 to clear RTC timer action flag, auto clear
            #[inline(always)]
            #[must_use]
            pub fn rtc_tmr_clr(&mut self) -> RTC_TMR_CLR_W<RTC_FLAG_CTRL_SPEC> {
                RTC_TMR_CLR_W::new(self, 4)
            }
            ///Bit 5 - RW, set 1 to clear RTC trigger action flag, auto clear
            #[inline(always)]
            #[must_use]
            pub fn rtc_trig_clr(&mut self) -> RTC_TRIG_CLR_W<RTC_FLAG_CTRL_SPEC> {
                RTC_TRIG_CLR_W::new(self, 5)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW, RTC flag and clear control
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`rtc_flag_ctrl::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`rtc_flag_ctrl::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct RTC_FLAG_CTRL_SPEC;
        impl crate::RegisterSpec for RTC_FLAG_CTRL_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`rtc_flag_ctrl::R`](R) reader structure
        impl crate::Readable for RTC_FLAG_CTRL_SPEC {}
        ///`write(|w| ..)` method takes [`rtc_flag_ctrl::W`](W) writer structure
        impl crate::Writable for RTC_FLAG_CTRL_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets RTC_FLAG_CTRL to value 0x30
        impl crate::Resettable for RTC_FLAG_CTRL_SPEC {
            const RESET_VALUE: u8 = 0x30;
        }
    }
    ///RTC_MODE_CTRL (rw) register accessor: RWA, RTC mode control, SAM
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`rtc_mode_ctrl::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`rtc_mode_ctrl::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@rtc_mode_ctrl`]
    ///module
    pub type RTC_MODE_CTRL = crate::Reg<rtc_mode_ctrl::RTC_MODE_CTRL_SPEC>;
    ///RWA, RTC mode control, SAM
    pub mod rtc_mode_ctrl {
        ///Register `RTC_MODE_CTRL` reader
        pub type R = crate::R<RTC_MODE_CTRL_SPEC>;
        ///Register `RTC_MODE_CTRL` writer
        pub type W = crate::W<RTC_MODE_CTRL_SPEC>;
        ///Field `RTC_TMR_MODE` reader - RWA, RTC timer mode: 000=0.125S, 001=0.25S, 010=0.5S, 011=1S, 100=2S, 101=4S, 110=8S, 111=16S
        pub type RTC_TMR_MODE_R = crate::FieldReader;
        ///Field `RTC_TMR_MODE` writer - RWA, RTC timer mode: 000=0.125S, 001=0.25S, 010=0.5S, 011=1S, 100=2S, 101=4S, 110=8S, 111=16S
        pub type RTC_TMR_MODE_W<'a, REG> = crate::FieldWriter<'a, REG, 3>;
        ///Field `RTC_IGNORE_B0` reader - RWA, force ignore bit0 for trigger mode: 0=compare bit0, 1=ignore bit0
        pub type RTC_IGNORE_B0_R = crate::BitReader;
        ///Field `RTC_IGNORE_B0` writer - RWA, force ignore bit0 for trigger mode: 0=compare bit0, 1=ignore bit0
        pub type RTC_IGNORE_B0_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `RTC_TMR_EN` reader - RWA, RTC timer mode enable
        pub type RTC_TMR_EN_R = crate::BitReader;
        ///Field `RTC_TMR_EN` writer - RWA, RTC timer mode enable
        pub type RTC_TMR_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `RTC_TRIG_EN` reader - RWA, RTC trigger mode enable
        pub type RTC_TRIG_EN_R = crate::BitReader;
        ///Field `RTC_TRIG_EN` writer - RWA, RTC trigger mode enable
        pub type RTC_TRIG_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `RTC_LOAD_LO` reader - RWA, set 1 to load RTC count low word R32_RTC_CNT_32K, auto clear after loaded
        pub type RTC_LOAD_LO_R = crate::BitReader;
        ///Field `RTC_LOAD_LO` writer - RWA, set 1 to load RTC count low word R32_RTC_CNT_32K, auto clear after loaded
        pub type RTC_LOAD_LO_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `RTC_LOAD_HI` reader - RWA, set 1 to load RTC count high word R32_RTC_CNT_DAY, auto clear after loaded
        pub type RTC_LOAD_HI_R = crate::BitReader;
        ///Field `RTC_LOAD_HI` writer - RWA, set 1 to load RTC count high word R32_RTC_CNT_DAY, auto clear after loaded
        pub type RTC_LOAD_HI_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bits 0:2 - RWA, RTC timer mode: 000=0.125S, 001=0.25S, 010=0.5S, 011=1S, 100=2S, 101=4S, 110=8S, 111=16S
            #[inline(always)]
            pub fn rtc_tmr_mode(&self) -> RTC_TMR_MODE_R {
                RTC_TMR_MODE_R::new(self.bits & 7)
            }
            ///Bit 3 - RWA, force ignore bit0 for trigger mode: 0=compare bit0, 1=ignore bit0
            #[inline(always)]
            pub fn rtc_ignore_b0(&self) -> RTC_IGNORE_B0_R {
                RTC_IGNORE_B0_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RWA, RTC timer mode enable
            #[inline(always)]
            pub fn rtc_tmr_en(&self) -> RTC_TMR_EN_R {
                RTC_TMR_EN_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - RWA, RTC trigger mode enable
            #[inline(always)]
            pub fn rtc_trig_en(&self) -> RTC_TRIG_EN_R {
                RTC_TRIG_EN_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - RWA, set 1 to load RTC count low word R32_RTC_CNT_32K, auto clear after loaded
            #[inline(always)]
            pub fn rtc_load_lo(&self) -> RTC_LOAD_LO_R {
                RTC_LOAD_LO_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - RWA, set 1 to load RTC count high word R32_RTC_CNT_DAY, auto clear after loaded
            #[inline(always)]
            pub fn rtc_load_hi(&self) -> RTC_LOAD_HI_R {
                RTC_LOAD_HI_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:2 - RWA, RTC timer mode: 000=0.125S, 001=0.25S, 010=0.5S, 011=1S, 100=2S, 101=4S, 110=8S, 111=16S
            #[inline(always)]
            #[must_use]
            pub fn rtc_tmr_mode(&mut self) -> RTC_TMR_MODE_W<RTC_MODE_CTRL_SPEC> {
                RTC_TMR_MODE_W::new(self, 0)
            }
            ///Bit 3 - RWA, force ignore bit0 for trigger mode: 0=compare bit0, 1=ignore bit0
            #[inline(always)]
            #[must_use]
            pub fn rtc_ignore_b0(&mut self) -> RTC_IGNORE_B0_W<RTC_MODE_CTRL_SPEC> {
                RTC_IGNORE_B0_W::new(self, 3)
            }
            ///Bit 4 - RWA, RTC timer mode enable
            #[inline(always)]
            #[must_use]
            pub fn rtc_tmr_en(&mut self) -> RTC_TMR_EN_W<RTC_MODE_CTRL_SPEC> {
                RTC_TMR_EN_W::new(self, 4)
            }
            ///Bit 5 - RWA, RTC trigger mode enable
            #[inline(always)]
            #[must_use]
            pub fn rtc_trig_en(&mut self) -> RTC_TRIG_EN_W<RTC_MODE_CTRL_SPEC> {
                RTC_TRIG_EN_W::new(self, 5)
            }
            ///Bit 6 - RWA, set 1 to load RTC count low word R32_RTC_CNT_32K, auto clear after loaded
            #[inline(always)]
            #[must_use]
            pub fn rtc_load_lo(&mut self) -> RTC_LOAD_LO_W<RTC_MODE_CTRL_SPEC> {
                RTC_LOAD_LO_W::new(self, 6)
            }
            ///Bit 7 - RWA, set 1 to load RTC count high word R32_RTC_CNT_DAY, auto clear after loaded
            #[inline(always)]
            #[must_use]
            pub fn rtc_load_hi(&mut self) -> RTC_LOAD_HI_W<RTC_MODE_CTRL_SPEC> {
                RTC_LOAD_HI_W::new(self, 7)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RWA, RTC mode control, SAM
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`rtc_mode_ctrl::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`rtc_mode_ctrl::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct RTC_MODE_CTRL_SPEC;
        impl crate::RegisterSpec for RTC_MODE_CTRL_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`rtc_mode_ctrl::R`](R) reader structure
        impl crate::Readable for RTC_MODE_CTRL_SPEC {}
        ///`write(|w| ..)` method takes [`rtc_mode_ctrl::W`](W) writer structure
        impl crate::Writable for RTC_MODE_CTRL_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets RTC_MODE_CTRL to value 0x02
        impl crate::Resettable for RTC_MODE_CTRL_SPEC {
            const RESET_VALUE: u8 = 0x02;
        }
    }
    ///RTC_TRIG (rw) register accessor: RWA, RTC trigger value, SAM
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`rtc_trig::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`rtc_trig::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@rtc_trig`]
    ///module
    pub type RTC_TRIG = crate::Reg<rtc_trig::RTC_TRIG_SPEC>;
    ///RWA, RTC trigger value, SAM
    pub mod rtc_trig {
        ///Register `RTC_TRIG` reader
        pub type R = crate::R<RTC_TRIG_SPEC>;
        ///Register `RTC_TRIG` writer
        pub type W = crate::W<RTC_TRIG_SPEC>;
        ///Field `RTC_TRIG` reader - RWA, RTC trigger value
        pub type RTC_TRIG_R = crate::FieldReader<u32>;
        ///Field `RTC_TRIG` writer - RWA, RTC trigger value
        pub type RTC_TRIG_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - RWA, RTC trigger value
            #[inline(always)]
            pub fn rtc_trig(&self) -> RTC_TRIG_R {
                RTC_TRIG_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RWA, RTC trigger value
            #[inline(always)]
            #[must_use]
            pub fn rtc_trig(&mut self) -> RTC_TRIG_W<RTC_TRIG_SPEC> {
                RTC_TRIG_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RWA, RTC trigger value, SAM
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`rtc_trig::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`rtc_trig::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct RTC_TRIG_SPEC;
        impl crate::RegisterSpec for RTC_TRIG_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`rtc_trig::R`](R) reader structure
        impl crate::Readable for RTC_TRIG_SPEC {}
        ///`write(|w| ..)` method takes [`rtc_trig::W`](W) writer structure
        impl crate::Writable for RTC_TRIG_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets RTC_TRIG to value 0
        impl crate::Resettable for RTC_TRIG_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///RTC_CNT_32K (r) register accessor: RO, RTC count based 32KHz
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`rtc_cnt_32k::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@rtc_cnt_32k`]
    ///module
    pub type RTC_CNT_32K = crate::Reg<rtc_cnt_32k::RTC_CNT_32K_SPEC>;
    ///RO, RTC count based 32KHz
    pub mod rtc_cnt_32k {
        ///Register `RTC_CNT_32K` reader
        pub type R = crate::R<RTC_CNT_32K_SPEC>;
        ///Field `RTC_CNT_32K` reader - RWA,RTC count based 32KHz
        pub type RTC_CNT_32K_R = crate::FieldReader<u16>;
        impl R {
            ///Bits 0:15 - RWA,RTC count based 32KHz
            #[inline(always)]
            pub fn rtc_cnt_32k(&self) -> RTC_CNT_32K_R {
                RTC_CNT_32K_R::new(self.bits)
            }
        }
        ///RO, RTC count based 32KHz
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`rtc_cnt_32k::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct RTC_CNT_32K_SPEC;
        impl crate::RegisterSpec for RTC_CNT_32K_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`rtc_cnt_32k::R`](R) reader structure
        impl crate::Readable for RTC_CNT_32K_SPEC {}
        ///`reset()` method sets RTC_CNT_32K to value 0
        impl crate::Resettable for RTC_CNT_32K_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///RTC_CNT_2S (r) register accessor: RO, RTC count based 2 second
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`rtc_cnt_2s::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@rtc_cnt_2s`]
    ///module
    pub type RTC_CNT_2S = crate::Reg<rtc_cnt_2s::RTC_CNT_2S_SPEC>;
    ///RO, RTC count based 2 second
    pub mod rtc_cnt_2s {
        ///Register `RTC_CNT_2S` reader
        pub type R = crate::R<RTC_CNT_2S_SPEC>;
        ///Field `RTC_CNT_2S` reader - RO, RTC count based 2 second
        pub type RTC_CNT_2S_R = crate::FieldReader<u16>;
        impl R {
            ///Bits 0:15 - RO, RTC count based 2 second
            #[inline(always)]
            pub fn rtc_cnt_2s(&self) -> RTC_CNT_2S_R {
                RTC_CNT_2S_R::new(self.bits)
            }
        }
        ///RO, RTC count based 2 second
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`rtc_cnt_2s::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct RTC_CNT_2S_SPEC;
        impl crate::RegisterSpec for RTC_CNT_2S_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`rtc_cnt_2s::R`](R) reader structure
        impl crate::Readable for RTC_CNT_2S_SPEC {}
        ///`reset()` method sets RTC_CNT_2S to value 0
        impl crate::Resettable for RTC_CNT_2S_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///RTC_CNT_DAY (r) register accessor: RO, RTC count based one day, only low 14 bit
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`rtc_cnt_day::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@rtc_cnt_day`]
    ///module
    pub type RTC_CNT_DAY = crate::Reg<rtc_cnt_day::RTC_CNT_DAY_SPEC>;
    ///RO, RTC count based one day, only low 14 bit
    pub mod rtc_cnt_day {
        ///Register `RTC_CNT_DAY` reader
        pub type R = crate::R<RTC_CNT_DAY_SPEC>;
        ///Field `RTC_CNT_DAY` reader - RWA,RTC count based one day
        pub type RTC_CNT_DAY_R = crate::FieldReader<u16>;
        impl R {
            ///Bits 0:13 - RWA,RTC count based one day
            #[inline(always)]
            pub fn rtc_cnt_day(&self) -> RTC_CNT_DAY_R {
                RTC_CNT_DAY_R::new((self.bits & 0x3fff) as u16)
            }
        }
        ///RO, RTC count based one day, only low 14 bit
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`rtc_cnt_day::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct RTC_CNT_DAY_SPEC;
        impl crate::RegisterSpec for RTC_CNT_DAY_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`rtc_cnt_day::R`](R) reader structure
        impl crate::Readable for RTC_CNT_DAY_SPEC {}
        ///`reset()` method sets RTC_CNT_DAY to value 0
        impl crate::Resettable for RTC_CNT_DAY_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///SAFE_ACCESS_SIG (rw) register accessor: WO, safe accessing sign register, must write SAFE_ACCESS_SIG1 then SAFE_ACCESS_SIG2 to enter safe accessing mode
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`safe_access_sig::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`safe_access_sig::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@safe_access_sig`]
    ///module
    pub type SAFE_ACCESS_SIG = crate::Reg<safe_access_sig::SAFE_ACCESS_SIG_SPEC>;
    ///WO, safe accessing sign register, must write SAFE_ACCESS_SIG1 then SAFE_ACCESS_SIG2 to enter safe accessing mode
    pub mod safe_access_sig {
        ///Register `SAFE_ACCESS_SIG` reader
        pub type R = crate::R<SAFE_ACCESS_SIG_SPEC>;
        ///Register `SAFE_ACCESS_SIG` writer
        pub type W = crate::W<SAFE_ACCESS_SIG_SPEC>;
        ///Field `SAFE_ACC_MODE` reader - RO, current safe accessing mode: 11=safe unlocked (SAM), other=locked (00..01..10..11)
        pub type SAFE_ACC_MODE_R = crate::FieldReader;
        ///Field `SAFE_ACC_MODE` writer - RO, current safe accessing mode: 11=safe unlocked (SAM), other=locked (00..01..10..11)
        pub type SAFE_ACC_MODE_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `SAFE_ACCESS_SIG` reader - WO, safe accessing sign register, must write 0x57 then 0xA8 to enter safe accessing mode
        pub type SAFE_ACCESS_SIG_R = crate::FieldReader;
        ///Field `SAFE_ACCESS_SIG` writer - WO, safe accessing sign register, must write 0x57 then 0xA8 to enter safe accessing mode
        pub type SAFE_ACCESS_SIG_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        ///Field `SAFE_ACC_ACT` reader - RO, indicate safe accessing status now: 0=locked, read only, 1=safe/unlocked (SAM), write enabled
        pub type SAFE_ACC_ACT_R = crate::BitReader;
        ///Field `SAFE_ACC_ACT` writer - RO, indicate safe accessing status now: 0=locked, read only, 1=safe/unlocked (SAM), write enabled
        pub type SAFE_ACC_ACT_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `SAFE_ACC_TIMER` reader - RO, safe accessing timer bit mask (16*clock number)
        pub type SAFE_ACC_TIMER_R = crate::FieldReader;
        ///Field `SAFE_ACC_TIMER` writer - RO, safe accessing timer bit mask (16*clock number)
        pub type SAFE_ACC_TIMER_W<'a, REG> = crate::FieldWriter<'a, REG, 3>;
        impl R {
            ///Bits 0:1 - RO, current safe accessing mode: 11=safe unlocked (SAM), other=locked (00..01..10..11)
            #[inline(always)]
            pub fn safe_acc_mode(&self) -> SAFE_ACC_MODE_R {
                SAFE_ACC_MODE_R::new(self.bits & 3)
            }
            ///Bits 0:7 - WO, safe accessing sign register, must write 0x57 then 0xA8 to enter safe accessing mode
            #[inline(always)]
            pub fn safe_access_sig(&self) -> SAFE_ACCESS_SIG_R {
                SAFE_ACCESS_SIG_R::new(self.bits)
            }
            ///Bit 3 - RO, indicate safe accessing status now: 0=locked, read only, 1=safe/unlocked (SAM), write enabled
            #[inline(always)]
            pub fn safe_acc_act(&self) -> SAFE_ACC_ACT_R {
                SAFE_ACC_ACT_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bits 4:6 - RO, safe accessing timer bit mask (16*clock number)
            #[inline(always)]
            pub fn safe_acc_timer(&self) -> SAFE_ACC_TIMER_R {
                SAFE_ACC_TIMER_R::new((self.bits >> 4) & 7)
            }
        }
        impl W {
            ///Bits 0:1 - RO, current safe accessing mode: 11=safe unlocked (SAM), other=locked (00..01..10..11)
            #[inline(always)]
            #[must_use]
            pub fn safe_acc_mode(&mut self) -> SAFE_ACC_MODE_W<SAFE_ACCESS_SIG_SPEC> {
                SAFE_ACC_MODE_W::new(self, 0)
            }
            ///Bits 0:7 - WO, safe accessing sign register, must write 0x57 then 0xA8 to enter safe accessing mode
            #[inline(always)]
            #[must_use]
            pub fn safe_access_sig(&mut self) -> SAFE_ACCESS_SIG_W<SAFE_ACCESS_SIG_SPEC> {
                SAFE_ACCESS_SIG_W::new(self, 0)
            }
            ///Bit 3 - RO, indicate safe accessing status now: 0=locked, read only, 1=safe/unlocked (SAM), write enabled
            #[inline(always)]
            #[must_use]
            pub fn safe_acc_act(&mut self) -> SAFE_ACC_ACT_W<SAFE_ACCESS_SIG_SPEC> {
                SAFE_ACC_ACT_W::new(self, 3)
            }
            ///Bits 4:6 - RO, safe accessing timer bit mask (16*clock number)
            #[inline(always)]
            #[must_use]
            pub fn safe_acc_timer(&mut self) -> SAFE_ACC_TIMER_W<SAFE_ACCESS_SIG_SPEC> {
                SAFE_ACC_TIMER_W::new(self, 4)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///WO, safe accessing sign register, must write SAFE_ACCESS_SIG1 then SAFE_ACCESS_SIG2 to enter safe accessing mode
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`safe_access_sig::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`safe_access_sig::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct SAFE_ACCESS_SIG_SPEC;
        impl crate::RegisterSpec for SAFE_ACCESS_SIG_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`safe_access_sig::R`](R) reader structure
        impl crate::Readable for SAFE_ACCESS_SIG_SPEC {}
        ///`write(|w| ..)` method takes [`safe_access_sig::W`](W) writer structure
        impl crate::Writable for SAFE_ACCESS_SIG_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets SAFE_ACCESS_SIG to value 0
        impl crate::Resettable for SAFE_ACCESS_SIG_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///CHIP_ID (r) register accessor: RF, chip ID register, always is ID_CH57*
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`chip_id::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@chip_id`]
    ///module
    pub type CHIP_ID = crate::Reg<chip_id::CHIP_ID_SPEC>;
    ///RF, chip ID register, always is ID_CH57*
    pub mod chip_id {
        ///Register `CHIP_ID` reader
        pub type R = crate::R<CHIP_ID_SPEC>;
        ///Field `CHIP_ID` reader - RF,chip ID register
        pub type CHIP_ID_R = crate::FieldReader;
        impl R {
            ///Bits 0:7 - RF,chip ID register
            #[inline(always)]
            pub fn chip_id(&self) -> CHIP_ID_R {
                CHIP_ID_R::new(self.bits)
            }
        }
        ///RF, chip ID register, always is ID_CH57*
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`chip_id::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct CHIP_ID_SPEC;
        impl crate::RegisterSpec for CHIP_ID_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`chip_id::R`](R) reader structure
        impl crate::Readable for CHIP_ID_SPEC {}
        ///`reset()` method sets CHIP_ID to value 0x73
        impl crate::Resettable for CHIP_ID_SPEC {
            const RESET_VALUE: u8 = 0x73;
        }
    }
    ///SAFE_ACCESS_ID (r) register accessor: RF, safe accessing ID register, always 0x04
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`safe_access_id::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@safe_access_id`]
    ///module
    pub type SAFE_ACCESS_ID = crate::Reg<safe_access_id::SAFE_ACCESS_ID_SPEC>;
    ///RF, safe accessing ID register, always 0x04
    pub mod safe_access_id {
        ///Register `SAFE_ACCESS_ID` reader
        pub type R = crate::R<SAFE_ACCESS_ID_SPEC>;
        ///Field `SAFE_ACCESS_ID` reader - RF,safe accessing ID register
        pub type SAFE_ACCESS_ID_R = crate::FieldReader;
        impl R {
            ///Bits 0:7 - RF,safe accessing ID register
            #[inline(always)]
            pub fn safe_access_id(&self) -> SAFE_ACCESS_ID_R {
                SAFE_ACCESS_ID_R::new(self.bits)
            }
        }
        ///RF, safe accessing ID register, always 0x04
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`safe_access_id::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct SAFE_ACCESS_ID_SPEC;
        impl crate::RegisterSpec for SAFE_ACCESS_ID_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`safe_access_id::R`](R) reader structure
        impl crate::Readable for SAFE_ACCESS_ID_SPEC {}
        ///`reset()` method sets SAFE_ACCESS_ID to value 0x04
        impl crate::Resettable for SAFE_ACCESS_ID_SPEC {
            const RESET_VALUE: u8 = 0x04;
        }
    }
    ///WDOG_COUNT (rw) register accessor: RW, watch-dog count, count by clock frequency Fsys/131072
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`wdog_count::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`wdog_count::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@wdog_count`]
    ///module
    pub type WDOG_COUNT = crate::Reg<wdog_count::WDOG_COUNT_SPEC>;
    ///RW, watch-dog count, count by clock frequency Fsys/131072
    pub mod wdog_count {
        ///Register `WDOG_COUNT` reader
        pub type R = crate::R<WDOG_COUNT_SPEC>;
        ///Register `WDOG_COUNT` writer
        pub type W = crate::W<WDOG_COUNT_SPEC>;
        ///Field `WDOG_COUNT` reader - RF,watch-dog count, count by clock frequency Fsys/131072
        pub type WDOG_COUNT_R = crate::FieldReader;
        ///Field `WDOG_COUNT` writer - RF,watch-dog count, count by clock frequency Fsys/131072
        pub type WDOG_COUNT_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            ///Bits 0:7 - RF,watch-dog count, count by clock frequency Fsys/131072
            #[inline(always)]
            pub fn wdog_count(&self) -> WDOG_COUNT_R {
                WDOG_COUNT_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:7 - RF,watch-dog count, count by clock frequency Fsys/131072
            #[inline(always)]
            #[must_use]
            pub fn wdog_count(&mut self) -> WDOG_COUNT_W<WDOG_COUNT_SPEC> {
                WDOG_COUNT_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW, watch-dog count, count by clock frequency Fsys/131072
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`wdog_count::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`wdog_count::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct WDOG_COUNT_SPEC;
        impl crate::RegisterSpec for WDOG_COUNT_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`wdog_count::R`](R) reader structure
        impl crate::Readable for WDOG_COUNT_SPEC {}
        ///`write(|w| ..)` method takes [`wdog_count::W`](W) writer structure
        impl crate::Writable for WDOG_COUNT_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets WDOG_COUNT to value 0
        impl crate::Resettable for WDOG_COUNT_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///RESET_STATUS__R8_GLOB_ROM_CFG (r) register accessor: RWA, reset status, SAM or flash ROM configuration
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`reset_status__r8_glob_rom_cfg::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@reset_status__r8_glob_rom_cfg`]
    ///module
    pub type RESET_STATUS__R8_GLOB_ROM_CFG =
        crate::Reg<reset_status__r8_glob_rom_cfg::RESET_STATUS__R8_GLOB_ROM_CFG_SPEC>;
    ///RWA, reset status, SAM or flash ROM configuration
    pub mod reset_status__r8_glob_rom_cfg {
        ///Register `RESET_STATUS__R8_GLOB_ROM_CFG` reader
        pub type R = crate::R<RESET_STATUS__R8_GLOB_ROM_CFG_SPEC>;
        ///Field `RESET_FLAG` reader - RO, recent reset flag
        pub type RESET_FLAG_R = crate::FieldReader;
        ///Field `ROM_CODE_OFS` reader - RWA, code offset address selection in Flash ROM: 0=start address 0x000000, 1=start address 0x008000
        pub type ROM_CODE_OFS_R = crate::BitReader;
        ///Field `ROM_CTRL_EN` reader - RWA, enable flash ROM control interface enable
        pub type ROM_CTRL_EN_R = crate::BitReader;
        ///Field `ROM_DATA_WE` reader - RWA,enable flash ROM data and code area being erase/write
        pub type ROM_DATA_WE_R = crate::BitReader;
        ///Field `ROM_CODE_WE` reader - RWA, enable flash ROM code area being erase or write
        pub type ROM_CODE_WE_R = crate::BitReader;
        impl R {
            ///Bits 0:2 - RO, recent reset flag
            #[inline(always)]
            pub fn reset_flag(&self) -> RESET_FLAG_R {
                RESET_FLAG_R::new(self.bits & 7)
            }
            ///Bit 4 - RWA, code offset address selection in Flash ROM: 0=start address 0x000000, 1=start address 0x008000
            #[inline(always)]
            pub fn rom_code_ofs(&self) -> ROM_CODE_OFS_R {
                ROM_CODE_OFS_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - RWA, enable flash ROM control interface enable
            #[inline(always)]
            pub fn rom_ctrl_en(&self) -> ROM_CTRL_EN_R {
                ROM_CTRL_EN_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - RWA,enable flash ROM data and code area being erase/write
            #[inline(always)]
            pub fn rom_data_we(&self) -> ROM_DATA_WE_R {
                ROM_DATA_WE_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - RWA, enable flash ROM code area being erase or write
            #[inline(always)]
            pub fn rom_code_we(&self) -> ROM_CODE_WE_R {
                ROM_CODE_WE_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        ///RWA, reset status, SAM or flash ROM configuration
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`reset_status__r8_glob_rom_cfg::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct RESET_STATUS__R8_GLOB_ROM_CFG_SPEC;
        impl crate::RegisterSpec for RESET_STATUS__R8_GLOB_ROM_CFG_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`reset_status__r8_glob_rom_cfg::R`](R) reader structure
        impl crate::Readable for RESET_STATUS__R8_GLOB_ROM_CFG_SPEC {}
        ///`reset()` method sets RESET_STATUS__R8_GLOB_ROM_CFG to value 0x01
        impl crate::Resettable for RESET_STATUS__R8_GLOB_ROM_CFG_SPEC {
            const RESET_VALUE: u8 = 0x01;
        }
    }
    ///GLOB_CFG_INFO (r) register accessor: RO, global configuration information and status
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`glob_cfg_info::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@glob_cfg_info`]
    ///module
    pub type GLOB_CFG_INFO = crate::Reg<glob_cfg_info::GLOB_CFG_INFO_SPEC>;
    ///RO, global configuration information and status
    pub mod glob_cfg_info {
        ///Register `GLOB_CFG_INFO` reader
        pub type R = crate::R<GLOB_CFG_INFO_SPEC>;
        ///Field `CFG_ROM_READ` reader - RO, indicate protected status of Flash ROM code and data: 0=reading protect, 1=enable read by external programmer
        pub type CFG_ROM_READ_R = crate::BitReader;
        ///Field `CFG_RESET_EN` reader - RO, manual reset input enable status
        pub type CFG_RESET_EN_R = crate::BitReader;
        ///Field `CFG_BOOT_EN` reader - RO, boot-loader enable status
        pub type CFG_BOOT_EN_R = crate::BitReader;
        ///Field `CFG_DEBUG_EN` reader - RO, debug enable status
        pub type CFG_DEBUG_EN_R = crate::BitReader;
        ///Field `BOOT_LOADER` reader - RO, indicate boot loader status: 0=application status (by software reset), 1=boot loader status
        pub type BOOT_LOADER_R = crate::BitReader;
        impl R {
            ///Bit 0 - RO, indicate protected status of Flash ROM code and data: 0=reading protect, 1=enable read by external programmer
            #[inline(always)]
            pub fn cfg_rom_read(&self) -> CFG_ROM_READ_R {
                CFG_ROM_READ_R::new((self.bits & 1) != 0)
            }
            ///Bit 2 - RO, manual reset input enable status
            #[inline(always)]
            pub fn cfg_reset_en(&self) -> CFG_RESET_EN_R {
                CFG_RESET_EN_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RO, boot-loader enable status
            #[inline(always)]
            pub fn cfg_boot_en(&self) -> CFG_BOOT_EN_R {
                CFG_BOOT_EN_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RO, debug enable status
            #[inline(always)]
            pub fn cfg_debug_en(&self) -> CFG_DEBUG_EN_R {
                CFG_DEBUG_EN_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - RO, indicate boot loader status: 0=application status (by software reset), 1=boot loader status
            #[inline(always)]
            pub fn boot_loader(&self) -> BOOT_LOADER_R {
                BOOT_LOADER_R::new(((self.bits >> 5) & 1) != 0)
            }
        }
        ///RO, global configuration information and status
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`glob_cfg_info::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct GLOB_CFG_INFO_SPEC;
        impl crate::RegisterSpec for GLOB_CFG_INFO_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`glob_cfg_info::R`](R) reader structure
        impl crate::Readable for GLOB_CFG_INFO_SPEC {}
        ///`reset()` method sets GLOB_CFG_INFO to value 0xe8
        impl crate::Resettable for GLOB_CFG_INFO_SPEC {
            const RESET_VALUE: u8 = 0xe8;
        }
    }
    ///RST_WDOG_CTRL (rw) register accessor: RWA, reset and watch-dog control, SAM
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`rst_wdog_ctrl::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`rst_wdog_ctrl::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@rst_wdog_ctrl`]
    ///module
    pub type RST_WDOG_CTRL = crate::Reg<rst_wdog_ctrl::RST_WDOG_CTRL_SPEC>;
    ///RWA, reset and watch-dog control, SAM
    pub mod rst_wdog_ctrl {
        ///Register `RST_WDOG_CTRL` reader
        pub type R = crate::R<RST_WDOG_CTRL_SPEC>;
        ///Register `RST_WDOG_CTRL` writer
        pub type W = crate::W<RST_WDOG_CTRL_SPEC>;
        ///Field `SOFTWARE_RESET` reader - WA or WZ, global software reset, high action, auto clear
        pub type SOFTWARE_RESET_R = crate::BitReader;
        ///Field `SOFTWARE_RESET` writer - WA or WZ, global software reset, high action, auto clear
        pub type SOFTWARE_RESET_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `WDOG_RST_EN` reader - RWA, enable watch-dog reset if watch-dog timer overflow: 0=as timer only, 1=enable reset if timer overflow
        pub type WDOG_RST_EN_R = crate::BitReader;
        ///Field `WDOG_RST_EN` writer - RWA, enable watch-dog reset if watch-dog timer overflow: 0=as timer only, 1=enable reset if timer overflow
        pub type WDOG_RST_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `WDOG_INT_EN` reader - RWA, watch-dog timer overflow interrupt enable: 0=disable, 1=enable
        pub type WDOG_INT_EN_R = crate::BitReader;
        ///Field `WDOG_INT_EN` writer - RWA, watch-dog timer overflow interrupt enable: 0=disable, 1=enable
        pub type WDOG_INT_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `WDOG_INT_FLAG` reader - RW1, watch-dog timer overflow interrupt flag, cleared by RW1 or reload watch-dog count or __SEV(Send-Event)
        pub type WDOG_INT_FLAG_R = crate::BitReader;
        ///Field `WDOG_INT_FLAG` writer - RW1, watch-dog timer overflow interrupt flag, cleared by RW1 or reload watch-dog count or __SEV(Send-Event)
        pub type WDOG_INT_FLAG_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - WA or WZ, global software reset, high action, auto clear
            #[inline(always)]
            pub fn software_reset(&self) -> SOFTWARE_RESET_R {
                SOFTWARE_RESET_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RWA, enable watch-dog reset if watch-dog timer overflow: 0=as timer only, 1=enable reset if timer overflow
            #[inline(always)]
            pub fn wdog_rst_en(&self) -> WDOG_RST_EN_R {
                WDOG_RST_EN_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RWA, watch-dog timer overflow interrupt enable: 0=disable, 1=enable
            #[inline(always)]
            pub fn wdog_int_en(&self) -> WDOG_INT_EN_R {
                WDOG_INT_EN_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 4 - RW1, watch-dog timer overflow interrupt flag, cleared by RW1 or reload watch-dog count or __SEV(Send-Event)
            #[inline(always)]
            pub fn wdog_int_flag(&self) -> WDOG_INT_FLAG_R {
                WDOG_INT_FLAG_R::new(((self.bits >> 4) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - WA or WZ, global software reset, high action, auto clear
            #[inline(always)]
            #[must_use]
            pub fn software_reset(&mut self) -> SOFTWARE_RESET_W<RST_WDOG_CTRL_SPEC> {
                SOFTWARE_RESET_W::new(self, 0)
            }
            ///Bit 1 - RWA, enable watch-dog reset if watch-dog timer overflow: 0=as timer only, 1=enable reset if timer overflow
            #[inline(always)]
            #[must_use]
            pub fn wdog_rst_en(&mut self) -> WDOG_RST_EN_W<RST_WDOG_CTRL_SPEC> {
                WDOG_RST_EN_W::new(self, 1)
            }
            ///Bit 2 - RWA, watch-dog timer overflow interrupt enable: 0=disable, 1=enable
            #[inline(always)]
            #[must_use]
            pub fn wdog_int_en(&mut self) -> WDOG_INT_EN_W<RST_WDOG_CTRL_SPEC> {
                WDOG_INT_EN_W::new(self, 2)
            }
            ///Bit 4 - RW1, watch-dog timer overflow interrupt flag, cleared by RW1 or reload watch-dog count or __SEV(Send-Event)
            #[inline(always)]
            #[must_use]
            pub fn wdog_int_flag(&mut self) -> WDOG_INT_FLAG_W<RST_WDOG_CTRL_SPEC> {
                WDOG_INT_FLAG_W::new(self, 4)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RWA, reset and watch-dog control, SAM
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`rst_wdog_ctrl::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`rst_wdog_ctrl::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct RST_WDOG_CTRL_SPEC;
        impl crate::RegisterSpec for RST_WDOG_CTRL_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`rst_wdog_ctrl::R`](R) reader structure
        impl crate::Readable for RST_WDOG_CTRL_SPEC {}
        ///`write(|w| ..)` method takes [`rst_wdog_ctrl::W`](W) writer structure
        impl crate::Writable for RST_WDOG_CTRL_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets RST_WDOG_CTRL to value 0
        impl crate::Resettable for RST_WDOG_CTRL_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///GLOB_RESET_KEEP (rw) register accessor: RW, value keeper during global reset
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`glob_reset_keep::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`glob_reset_keep::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@glob_reset_keep`]
    ///module
    pub type GLOB_RESET_KEEP = crate::Reg<glob_reset_keep::GLOB_RESET_KEEP_SPEC>;
    ///RW, value keeper during global reset
    pub mod glob_reset_keep {
        ///Register `GLOB_RESET_KEEP` reader
        pub type R = crate::R<GLOB_RESET_KEEP_SPEC>;
        ///Register `GLOB_RESET_KEEP` writer
        pub type W = crate::W<GLOB_RESET_KEEP_SPEC>;
        ///Field `GLOB_RESET_KEEP` reader - RW, value keeper during global reset
        pub type GLOB_RESET_KEEP_R = crate::FieldReader;
        ///Field `GLOB_RESET_KEEP` writer - RW, value keeper during global reset
        pub type GLOB_RESET_KEEP_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            ///Bits 0:7 - RW, value keeper during global reset
            #[inline(always)]
            pub fn glob_reset_keep(&self) -> GLOB_RESET_KEEP_R {
                GLOB_RESET_KEEP_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:7 - RW, value keeper during global reset
            #[inline(always)]
            #[must_use]
            pub fn glob_reset_keep(&mut self) -> GLOB_RESET_KEEP_W<GLOB_RESET_KEEP_SPEC> {
                GLOB_RESET_KEEP_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW, value keeper during global reset
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`glob_reset_keep::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`glob_reset_keep::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct GLOB_RESET_KEEP_SPEC;
        impl crate::RegisterSpec for GLOB_RESET_KEEP_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`glob_reset_keep::R`](R) reader structure
        impl crate::Readable for GLOB_RESET_KEEP_SPEC {}
        ///`write(|w| ..)` method takes [`glob_reset_keep::W`](W) writer structure
        impl crate::Writable for GLOB_RESET_KEEP_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets GLOB_RESET_KEEP to value 0
        impl crate::Resettable for GLOB_RESET_KEEP_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///PLL_CONFIG (rw) register accessor: RWA, PLL configuration control, SAM
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`pll_config::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pll_config::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@pll_config`]
    ///module
    pub type PLL_CONFIG = crate::Reg<pll_config::PLL_CONFIG_SPEC>;
    ///RWA, PLL configuration control, SAM
    pub mod pll_config {
        ///Register `PLL_CONFIG` reader
        pub type R = crate::R<PLL_CONFIG_SPEC>;
        ///Register `PLL_CONFIG` writer
        pub type W = crate::W<PLL_CONFIG_SPEC>;
        ///Field `PLL_CFG_DAT` reader - RWA, PLL configure data
        pub type PLL_CFG_DAT_R = crate::FieldReader;
        ///Field `PLL_CFG_DAT` writer - RWA, PLL configure data
        pub type PLL_CFG_DAT_W<'a, REG> = crate::FieldWriter<'a, REG, 7>;
        impl R {
            ///Bits 0:6 - RWA, PLL configure data
            #[inline(always)]
            pub fn pll_cfg_dat(&self) -> PLL_CFG_DAT_R {
                PLL_CFG_DAT_R::new(self.bits & 0x7f)
            }
        }
        impl W {
            ///Bits 0:6 - RWA, PLL configure data
            #[inline(always)]
            #[must_use]
            pub fn pll_cfg_dat(&mut self) -> PLL_CFG_DAT_W<PLL_CONFIG_SPEC> {
                PLL_CFG_DAT_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RWA, PLL configuration control, SAM
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`pll_config::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pll_config::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct PLL_CONFIG_SPEC;
        impl crate::RegisterSpec for PLL_CONFIG_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`pll_config::R`](R) reader structure
        impl crate::Readable for PLL_CONFIG_SPEC {}
        ///`write(|w| ..)` method takes [`pll_config::W`](W) writer structure
        impl crate::Writable for PLL_CONFIG_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets PLL_CONFIG to value 0x4a
        impl crate::Resettable for PLL_CONFIG_SPEC {
            const RESET_VALUE: u8 = 0x4a;
        }
    }
    ///XT32M_TUNE (rw) register accessor: RWA, external 32MHz oscillator tune control, SAM
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`xt32m_tune::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`xt32m_tune::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@xt32m_tune`]
    ///module
    pub type XT32M_TUNE = crate::Reg<xt32m_tune::XT32M_TUNE_SPEC>;
    ///RWA, external 32MHz oscillator tune control, SAM
    pub mod xt32m_tune {
        ///Register `XT32M_TUNE` reader
        pub type R = crate::R<XT32M_TUNE_SPEC>;
        ///Register `XT32M_TUNE` writer
        pub type W = crate::W<XT32M_TUNE_SPEC>;
        ///Field `XT32M_I_BIAS` reader - RWA, external 32MHz oscillator bias current tune: 00=75% current, 01=standard current, 10=125% current, 11=150% current
        pub type XT32M_I_BIAS_R = crate::FieldReader;
        ///Field `XT32M_I_BIAS` writer - RWA, external 32MHz oscillator bias current tune: 00=75% current, 01=standard current, 10=125% current, 11=150% current
        pub type XT32M_I_BIAS_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `XT32M_C_LOAD` reader - RWA, external 32MHz oscillator load capacitor tune: Cap = RB_XT32M_C_LOAD * 2 + 10pF
        pub type XT32M_C_LOAD_R = crate::FieldReader;
        ///Field `XT32M_C_LOAD` writer - RWA, external 32MHz oscillator load capacitor tune: Cap = RB_XT32M_C_LOAD * 2 + 10pF
        pub type XT32M_C_LOAD_W<'a, REG> = crate::FieldWriter<'a, REG, 3>;
        impl R {
            ///Bits 0:1 - RWA, external 32MHz oscillator bias current tune: 00=75% current, 01=standard current, 10=125% current, 11=150% current
            #[inline(always)]
            pub fn xt32m_i_bias(&self) -> XT32M_I_BIAS_R {
                XT32M_I_BIAS_R::new(self.bits & 3)
            }
            ///Bits 4:6 - RWA, external 32MHz oscillator load capacitor tune: Cap = RB_XT32M_C_LOAD * 2 + 10pF
            #[inline(always)]
            pub fn xt32m_c_load(&self) -> XT32M_C_LOAD_R {
                XT32M_C_LOAD_R::new((self.bits >> 4) & 7)
            }
        }
        impl W {
            ///Bits 0:1 - RWA, external 32MHz oscillator bias current tune: 00=75% current, 01=standard current, 10=125% current, 11=150% current
            #[inline(always)]
            #[must_use]
            pub fn xt32m_i_bias(&mut self) -> XT32M_I_BIAS_W<XT32M_TUNE_SPEC> {
                XT32M_I_BIAS_W::new(self, 0)
            }
            ///Bits 4:6 - RWA, external 32MHz oscillator load capacitor tune: Cap = RB_XT32M_C_LOAD * 2 + 10pF
            #[inline(always)]
            #[must_use]
            pub fn xt32m_c_load(&mut self) -> XT32M_C_LOAD_W<XT32M_TUNE_SPEC> {
                XT32M_C_LOAD_W::new(self, 4)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RWA, external 32MHz oscillator tune control, SAM
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`xt32m_tune::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`xt32m_tune::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct XT32M_TUNE_SPEC;
        impl crate::RegisterSpec for XT32M_TUNE_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`xt32m_tune::R`](R) reader structure
        impl crate::Readable for XT32M_TUNE_SPEC {}
        ///`write(|w| ..)` method takes [`xt32m_tune::W`](W) writer structure
        impl crate::Writable for XT32M_TUNE_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets XT32M_TUNE to value 0x31
        impl crate::Resettable for XT32M_TUNE_SPEC {
            const RESET_VALUE: u8 = 0x31;
        }
    }
    ///OSC_CAL_CNT (r) register accessor: RO, system clock count value for 32KHz 5 cycles
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`osc_cal_cnt::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@osc_cal_cnt`]
    ///module
    pub type OSC_CAL_CNT = crate::Reg<osc_cal_cnt::OSC_CAL_CNT_SPEC>;
    ///RO, system clock count value for 32KHz 5 cycles
    pub mod osc_cal_cnt {
        ///Register `OSC_CAL_CNT` reader
        pub type R = crate::R<OSC_CAL_CNT_SPEC>;
        ///Field `OSC_CAL_CNT` reader - RO, system clock count value for 32KHz 5 cycles
        pub type OSC_CAL_CNT_R = crate::FieldReader<u16>;
        impl R {
            ///Bits 0:13 - RO, system clock count value for 32KHz 5 cycles
            #[inline(always)]
            pub fn osc_cal_cnt(&self) -> OSC_CAL_CNT_R {
                OSC_CAL_CNT_R::new(self.bits & 0x3fff)
            }
        }
        ///RO, system clock count value for 32KHz 5 cycles
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`osc_cal_cnt::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct OSC_CAL_CNT_SPEC;
        impl crate::RegisterSpec for OSC_CAL_CNT_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`osc_cal_cnt::R`](R) reader structure
        impl crate::Readable for OSC_CAL_CNT_SPEC {}
        ///`reset()` method sets OSC_CAL_CNT to value 0
        impl crate::Resettable for OSC_CAL_CNT_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///OSC_CAL_CTRL (rw) register accessor: RWA, oscillator frequency calibration control, SAM
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`osc_cal_ctrl::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`osc_cal_ctrl::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@osc_cal_ctrl`]
    ///module
    pub type OSC_CAL_CTRL = crate::Reg<osc_cal_ctrl::OSC_CAL_CTRL_SPEC>;
    ///RWA, oscillator frequency calibration control, SAM
    pub mod osc_cal_ctrl {
        ///Register `OSC_CAL_CTRL` reader
        pub type R = crate::R<OSC_CAL_CTRL_SPEC>;
        ///Register `OSC_CAL_CTRL` writer
        pub type W = crate::W<OSC_CAL_CTRL_SPEC>;
        ///Field `OSC_CNT_EN` reader - RWA, calibration counter enable
        pub type OSC_CNT_EN_R = crate::BitReader;
        ///Field `OSC_CNT_EN` writer - RWA, calibration counter enable
        pub type OSC_CNT_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `OSC_CNT_HALT` reader - RO, calibration counter halt status: 0=counting, 1=halt for reading count value
        pub type OSC_CNT_HALT_R = crate::BitReader;
        impl R {
            ///Bit 0 - RWA, calibration counter enable
            #[inline(always)]
            pub fn osc_cnt_en(&self) -> OSC_CNT_EN_R {
                OSC_CNT_EN_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RO, calibration counter halt status: 0=counting, 1=halt for reading count value
            #[inline(always)]
            pub fn osc_cnt_halt(&self) -> OSC_CNT_HALT_R {
                OSC_CNT_HALT_R::new(((self.bits >> 1) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RWA, calibration counter enable
            #[inline(always)]
            #[must_use]
            pub fn osc_cnt_en(&mut self) -> OSC_CNT_EN_W<OSC_CAL_CTRL_SPEC> {
                OSC_CNT_EN_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RWA, oscillator frequency calibration control, SAM
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`osc_cal_ctrl::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`osc_cal_ctrl::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct OSC_CAL_CTRL_SPEC;
        impl crate::RegisterSpec for OSC_CAL_CTRL_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`osc_cal_ctrl::R`](R) reader structure
        impl crate::Readable for OSC_CAL_CTRL_SPEC {}
        ///`write(|w| ..)` method takes [`osc_cal_ctrl::W`](W) writer structure
        impl crate::Writable for OSC_CAL_CTRL_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets OSC_CAL_CTRL to value 0x02
        impl crate::Resettable for OSC_CAL_CTRL_SPEC {
            const RESET_VALUE: u8 = 0x02;
        }
    }
    ///TKEY_COUNT (rw) register accessor: RW, Touchkey charge and discharge count
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`tkey_count::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`tkey_count::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@tkey_count`]
    ///module
    pub type TKEY_COUNT = crate::Reg<tkey_count::TKEY_COUNT_SPEC>;
    ///RW, Touchkey charge and discharge count
    pub mod tkey_count {
        ///Register `TKEY_COUNT` reader
        pub type R = crate::R<TKEY_COUNT_SPEC>;
        ///Register `TKEY_COUNT` writer
        pub type W = crate::W<TKEY_COUNT_SPEC>;
        ///Field `TKEY_CHARG_CNT` reader - RW, Touchkey charge count
        pub type TKEY_CHARG_CNT_R = crate::FieldReader;
        ///Field `TKEY_CHARG_CNT` writer - RW, Touchkey charge count
        pub type TKEY_CHARG_CNT_W<'a, REG> = crate::FieldWriter<'a, REG, 5>;
        ///Field `TKEY_DISCH_CNT` reader - RW, Touchkey discharge count
        pub type TKEY_DISCH_CNT_R = crate::FieldReader;
        ///Field `TKEY_DISCH_CNT` writer - RW, Touchkey discharge count
        pub type TKEY_DISCH_CNT_W<'a, REG> = crate::FieldWriter<'a, REG, 3>;
        impl R {
            ///Bits 0:4 - RW, Touchkey charge count
            #[inline(always)]
            pub fn tkey_charg_cnt(&self) -> TKEY_CHARG_CNT_R {
                TKEY_CHARG_CNT_R::new(self.bits & 0x1f)
            }
            ///Bits 5:7 - RW, Touchkey discharge count
            #[inline(always)]
            pub fn tkey_disch_cnt(&self) -> TKEY_DISCH_CNT_R {
                TKEY_DISCH_CNT_R::new((self.bits >> 5) & 7)
            }
        }
        impl W {
            ///Bits 0:4 - RW, Touchkey charge count
            #[inline(always)]
            #[must_use]
            pub fn tkey_charg_cnt(&mut self) -> TKEY_CHARG_CNT_W<TKEY_COUNT_SPEC> {
                TKEY_CHARG_CNT_W::new(self, 0)
            }
            ///Bits 5:7 - RW, Touchkey discharge count
            #[inline(always)]
            #[must_use]
            pub fn tkey_disch_cnt(&mut self) -> TKEY_DISCH_CNT_W<TKEY_COUNT_SPEC> {
                TKEY_DISCH_CNT_W::new(self, 5)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW, Touchkey charge and discharge count
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`tkey_count::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`tkey_count::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct TKEY_COUNT_SPEC;
        impl crate::RegisterSpec for TKEY_COUNT_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`tkey_count::R`](R) reader structure
        impl crate::Readable for TKEY_COUNT_SPEC {}
        ///`write(|w| ..)` method takes [`tkey_count::W`](W) writer structure
        impl crate::Writable for TKEY_COUNT_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets TKEY_COUNT to value 0
        impl crate::Resettable for TKEY_COUNT_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///TKEY_CONVERT (rw) register accessor: RW, Touchkey convert start control
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`tkey_convert::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`tkey_convert::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@tkey_convert`]
    ///module
    pub type TKEY_CONVERT = crate::Reg<tkey_convert::TKEY_CONVERT_SPEC>;
    ///RW, Touchkey convert start control
    pub mod tkey_convert {
        ///Register `TKEY_CONVERT` reader
        pub type R = crate::R<TKEY_CONVERT_SPEC>;
        ///Register `TKEY_CONVERT` writer
        pub type W = crate::W<TKEY_CONVERT_SPEC>;
        ///Field `TKEY_START` reader - RW, Touchkey convert start control
        pub type TKEY_START_R = crate::BitReader;
        ///Field `TKEY_START` writer - RW, Touchkey convert start control
        pub type TKEY_START_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - RW, Touchkey convert start control
            #[inline(always)]
            pub fn tkey_start(&self) -> TKEY_START_R {
                TKEY_START_R::new((self.bits & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RW, Touchkey convert start control
            #[inline(always)]
            #[must_use]
            pub fn tkey_start(&mut self) -> TKEY_START_W<TKEY_CONVERT_SPEC> {
                TKEY_START_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW, Touchkey convert start control
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`tkey_convert::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`tkey_convert::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct TKEY_CONVERT_SPEC;
        impl crate::RegisterSpec for TKEY_CONVERT_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`tkey_convert::R`](R) reader structure
        impl crate::Readable for TKEY_CONVERT_SPEC {}
        ///`write(|w| ..)` method takes [`tkey_convert::W`](W) writer structure
        impl crate::Writable for TKEY_CONVERT_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets TKEY_CONVERT to value 0
        impl crate::Resettable for TKEY_CONVERT_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///TKEY_CFG (rw) register accessor: RW, Touchkey configure
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`tkey_cfg::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`tkey_cfg::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@tkey_cfg`]
    ///module
    pub type TKEY_CFG = crate::Reg<tkey_cfg::TKEY_CFG_SPEC>;
    ///RW, Touchkey configure
    pub mod tkey_cfg {
        ///Register `TKEY_CFG` reader
        pub type R = crate::R<TKEY_CFG_SPEC>;
        ///Register `TKEY_CFG` writer
        pub type W = crate::W<TKEY_CFG_SPEC>;
        ///Field `TKEY_PWR_ON` reader - RW, Touchkey power on
        pub type TKEY_PWR_ON_R = crate::BitReader;
        ///Field `TKEY_PWR_ON` writer - RW, Touchkey power on
        pub type TKEY_PWR_ON_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TKEY_CURRENT` reader - RW, Touchkey charge current selection
        pub type TKEY_CURRENT_R = crate::BitReader;
        ///Field `TKEY_CURRENT` writer - RW, Touchkey charge current selection
        pub type TKEY_CURRENT_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TKEY_PGA_ADJ` reader - RW, ADC input PGA speed selection
        pub type TKEY_PGA_ADJ_R = crate::BitReader;
        ///Field `TKEY_PGA_ADJ` writer - RW, ADC input PGA speed selection
        pub type TKEY_PGA_ADJ_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - RW, Touchkey power on
            #[inline(always)]
            pub fn tkey_pwr_on(&self) -> TKEY_PWR_ON_R {
                TKEY_PWR_ON_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RW, Touchkey charge current selection
            #[inline(always)]
            pub fn tkey_current(&self) -> TKEY_CURRENT_R {
                TKEY_CURRENT_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 3 - RW, ADC input PGA speed selection
            #[inline(always)]
            pub fn tkey_pga_adj(&self) -> TKEY_PGA_ADJ_R {
                TKEY_PGA_ADJ_R::new(((self.bits >> 3) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RW, Touchkey power on
            #[inline(always)]
            #[must_use]
            pub fn tkey_pwr_on(&mut self) -> TKEY_PWR_ON_W<TKEY_CFG_SPEC> {
                TKEY_PWR_ON_W::new(self, 0)
            }
            ///Bit 1 - RW, Touchkey charge current selection
            #[inline(always)]
            #[must_use]
            pub fn tkey_current(&mut self) -> TKEY_CURRENT_W<TKEY_CFG_SPEC> {
                TKEY_CURRENT_W::new(self, 1)
            }
            ///Bit 3 - RW, ADC input PGA speed selection
            #[inline(always)]
            #[must_use]
            pub fn tkey_pga_adj(&mut self) -> TKEY_PGA_ADJ_W<TKEY_CFG_SPEC> {
                TKEY_PGA_ADJ_W::new(self, 3)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW, Touchkey configure
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`tkey_cfg::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`tkey_cfg::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct TKEY_CFG_SPEC;
        impl crate::RegisterSpec for TKEY_CFG_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`tkey_cfg::R`](R) reader structure
        impl crate::Readable for TKEY_CFG_SPEC {}
        ///`write(|w| ..)` method takes [`tkey_cfg::W`](W) writer structure
        impl crate::Writable for TKEY_CFG_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets TKEY_CFG to value 0
        impl crate::Resettable for TKEY_CFG_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///ADC_CHANNEL (rw) register accessor: RW, ADC input channel selection
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`adc_channel::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`adc_channel::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@adc_channel`]
    ///module
    pub type ADC_CHANNEL = crate::Reg<adc_channel::ADC_CHANNEL_SPEC>;
    ///RW, ADC input channel selection
    pub mod adc_channel {
        ///Register `ADC_CHANNEL` reader
        pub type R = crate::R<ADC_CHANNEL_SPEC>;
        ///Register `ADC_CHANNEL` writer
        pub type W = crate::W<ADC_CHANNEL_SPEC>;
        ///Field `ADC_CH_INX` reader - RW, ADC input channel index
        pub type ADC_CH_INX_R = crate::FieldReader;
        ///Field `ADC_CH_INX` writer - RW, ADC input channel index
        pub type ADC_CH_INX_W<'a, REG> = crate::FieldWriter<'a, REG, 4>;
        impl R {
            ///Bits 0:3 - RW, ADC input channel index
            #[inline(always)]
            pub fn adc_ch_inx(&self) -> ADC_CH_INX_R {
                ADC_CH_INX_R::new(self.bits & 0x0f)
            }
        }
        impl W {
            ///Bits 0:3 - RW, ADC input channel index
            #[inline(always)]
            #[must_use]
            pub fn adc_ch_inx(&mut self) -> ADC_CH_INX_W<ADC_CHANNEL_SPEC> {
                ADC_CH_INX_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW, ADC input channel selection
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`adc_channel::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`adc_channel::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct ADC_CHANNEL_SPEC;
        impl crate::RegisterSpec for ADC_CHANNEL_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`adc_channel::R`](R) reader structure
        impl crate::Readable for ADC_CHANNEL_SPEC {}
        ///`write(|w| ..)` method takes [`adc_channel::W`](W) writer structure
        impl crate::Writable for ADC_CHANNEL_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets ADC_CHANNEL to value 0x0f
        impl crate::Resettable for ADC_CHANNEL_SPEC {
            const RESET_VALUE: u8 = 0x0f;
        }
    }
    ///ADC_CFG (rw) register accessor: RW, ADC configure
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`adc_cfg::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`adc_cfg::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@adc_cfg`]
    ///module
    pub type ADC_CFG = crate::Reg<adc_cfg::ADC_CFG_SPEC>;
    ///RW, ADC configure
    pub mod adc_cfg {
        ///Register `ADC_CFG` reader
        pub type R = crate::R<ADC_CFG_SPEC>;
        ///Register `ADC_CFG` writer
        pub type W = crate::W<ADC_CFG_SPEC>;
        ///Field `ADC_POWER_ON` reader - RW, ADC power control: 0=power down, 1=power on
        pub type ADC_POWER_ON_R = crate::BitReader;
        ///Field `ADC_POWER_ON` writer - RW, ADC power control: 0=power down, 1=power on
        pub type ADC_POWER_ON_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `ADC_BUF_EN` reader - RW, ADC input buffer enable
        pub type ADC_BUF_EN_R = crate::BitReader;
        ///Field `ADC_BUF_EN` writer - RW, ADC input buffer enable
        pub type ADC_BUF_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `ADC_DIFF_EN` reader - RW, ADC input channel mode: 0=single-end, 1=differnetial
        pub type ADC_DIFF_EN_R = crate::BitReader;
        ///Field `ADC_DIFF_EN` writer - RW, ADC input channel mode: 0=single-end, 1=differnetial
        pub type ADC_DIFF_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `ADC_OFS_TEST` reader - RW, enable ADC offset test mode: 0=normal mode, 1=short port4 to test offset
        pub type ADC_OFS_TEST_R = crate::BitReader;
        ///Field `ADC_OFS_TEST` writer - RW, enable ADC offset test mode: 0=normal mode, 1=short port4 to test offset
        pub type ADC_OFS_TEST_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `ADC_PGA_GAIN` reader - RW, set ADC input PGA gain: 00=-12dB, 01=-6dB, 10=0dB, 11=6dB
        pub type ADC_PGA_GAIN_R = crate::FieldReader;
        ///Field `ADC_PGA_GAIN` writer - RW, set ADC input PGA gain: 00=-12dB, 01=-6dB, 10=0dB, 11=6dB
        pub type ADC_PGA_GAIN_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `ADC_CLK_DIV` reader - RW, select ADC clock frequency: 00=3.2MHz, 01=2.67MHz, 10=5.33MHz, 11=4MHz
        pub type ADC_CLK_DIV_R = crate::FieldReader;
        ///Field `ADC_CLK_DIV` writer - RW, select ADC clock frequency: 00=3.2MHz, 01=2.67MHz, 10=5.33MHz, 11=4MHz
        pub type ADC_CLK_DIV_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        impl R {
            ///Bit 0 - RW, ADC power control: 0=power down, 1=power on
            #[inline(always)]
            pub fn adc_power_on(&self) -> ADC_POWER_ON_R {
                ADC_POWER_ON_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RW, ADC input buffer enable
            #[inline(always)]
            pub fn adc_buf_en(&self) -> ADC_BUF_EN_R {
                ADC_BUF_EN_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RW, ADC input channel mode: 0=single-end, 1=differnetial
            #[inline(always)]
            pub fn adc_diff_en(&self) -> ADC_DIFF_EN_R {
                ADC_DIFF_EN_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RW, enable ADC offset test mode: 0=normal mode, 1=short port4 to test offset
            #[inline(always)]
            pub fn adc_ofs_test(&self) -> ADC_OFS_TEST_R {
                ADC_OFS_TEST_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bits 4:5 - RW, set ADC input PGA gain: 00=-12dB, 01=-6dB, 10=0dB, 11=6dB
            #[inline(always)]
            pub fn adc_pga_gain(&self) -> ADC_PGA_GAIN_R {
                ADC_PGA_GAIN_R::new((self.bits >> 4) & 3)
            }
            ///Bits 6:7 - RW, select ADC clock frequency: 00=3.2MHz, 01=2.67MHz, 10=5.33MHz, 11=4MHz
            #[inline(always)]
            pub fn adc_clk_div(&self) -> ADC_CLK_DIV_R {
                ADC_CLK_DIV_R::new((self.bits >> 6) & 3)
            }
        }
        impl W {
            ///Bit 0 - RW, ADC power control: 0=power down, 1=power on
            #[inline(always)]
            #[must_use]
            pub fn adc_power_on(&mut self) -> ADC_POWER_ON_W<ADC_CFG_SPEC> {
                ADC_POWER_ON_W::new(self, 0)
            }
            ///Bit 1 - RW, ADC input buffer enable
            #[inline(always)]
            #[must_use]
            pub fn adc_buf_en(&mut self) -> ADC_BUF_EN_W<ADC_CFG_SPEC> {
                ADC_BUF_EN_W::new(self, 1)
            }
            ///Bit 2 - RW, ADC input channel mode: 0=single-end, 1=differnetial
            #[inline(always)]
            #[must_use]
            pub fn adc_diff_en(&mut self) -> ADC_DIFF_EN_W<ADC_CFG_SPEC> {
                ADC_DIFF_EN_W::new(self, 2)
            }
            ///Bit 3 - RW, enable ADC offset test mode: 0=normal mode, 1=short port4 to test offset
            #[inline(always)]
            #[must_use]
            pub fn adc_ofs_test(&mut self) -> ADC_OFS_TEST_W<ADC_CFG_SPEC> {
                ADC_OFS_TEST_W::new(self, 3)
            }
            ///Bits 4:5 - RW, set ADC input PGA gain: 00=-12dB, 01=-6dB, 10=0dB, 11=6dB
            #[inline(always)]
            #[must_use]
            pub fn adc_pga_gain(&mut self) -> ADC_PGA_GAIN_W<ADC_CFG_SPEC> {
                ADC_PGA_GAIN_W::new(self, 4)
            }
            ///Bits 6:7 - RW, select ADC clock frequency: 00=3.2MHz, 01=2.67MHz, 10=5.33MHz, 11=4MHz
            #[inline(always)]
            #[must_use]
            pub fn adc_clk_div(&mut self) -> ADC_CLK_DIV_W<ADC_CFG_SPEC> {
                ADC_CLK_DIV_W::new(self, 6)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW, ADC configure
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`adc_cfg::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`adc_cfg::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct ADC_CFG_SPEC;
        impl crate::RegisterSpec for ADC_CFG_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`adc_cfg::R`](R) reader structure
        impl crate::Readable for ADC_CFG_SPEC {}
        ///`write(|w| ..)` method takes [`adc_cfg::W`](W) writer structure
        impl crate::Writable for ADC_CFG_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets ADC_CFG to value 0xa0
        impl crate::Resettable for ADC_CFG_SPEC {
            const RESET_VALUE: u8 = 0xa0;
        }
    }
    ///ADC_CONVERT (rw) register accessor: RW, ADC convert control
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`adc_convert::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`adc_convert::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@adc_convert`]
    ///module
    pub type ADC_CONVERT = crate::Reg<adc_convert::ADC_CONVERT_SPEC>;
    ///RW, ADC convert control
    pub mod adc_convert {
        ///Register `ADC_CONVERT` reader
        pub type R = crate::R<ADC_CONVERT_SPEC>;
        ///Register `ADC_CONVERT` writer
        pub type W = crate::W<ADC_CONVERT_SPEC>;
        ///Field `ADC_START` reader - RW, ADC convert start control: 0=stop ADC convert, 1=start an ADC convert, auto clear
        pub type ADC_START_R = crate::BitReader;
        ///Field `ADC_START` writer - RW, ADC convert start control: 0=stop ADC convert, 1=start an ADC convert, auto clear
        pub type ADC_START_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `ADC_EOC_X` reader - RO, end of ADC conversion flag
        pub type ADC_EOC_X_R = crate::BitReader;
        impl R {
            ///Bit 0 - RW, ADC convert start control: 0=stop ADC convert, 1=start an ADC convert, auto clear
            #[inline(always)]
            pub fn adc_start(&self) -> ADC_START_R {
                ADC_START_R::new((self.bits & 1) != 0)
            }
            ///Bit 7 - RO, end of ADC conversion flag
            #[inline(always)]
            pub fn adc_eoc_x(&self) -> ADC_EOC_X_R {
                ADC_EOC_X_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RW, ADC convert start control: 0=stop ADC convert, 1=start an ADC convert, auto clear
            #[inline(always)]
            #[must_use]
            pub fn adc_start(&mut self) -> ADC_START_W<ADC_CONVERT_SPEC> {
                ADC_START_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW, ADC convert control
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`adc_convert::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`adc_convert::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct ADC_CONVERT_SPEC;
        impl crate::RegisterSpec for ADC_CONVERT_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`adc_convert::R`](R) reader structure
        impl crate::Readable for ADC_CONVERT_SPEC {}
        ///`write(|w| ..)` method takes [`adc_convert::W`](W) writer structure
        impl crate::Writable for ADC_CONVERT_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets ADC_CONVERT to value 0
        impl crate::Resettable for ADC_CONVERT_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///TEM_SENSOR (rw) register accessor: RW, temperature sensor control
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`tem_sensor::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`tem_sensor::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@tem_sensor`]
    ///module
    pub type TEM_SENSOR = crate::Reg<tem_sensor::TEM_SENSOR_SPEC>;
    ///RW, temperature sensor control
    pub mod tem_sensor {
        ///Register `TEM_SENSOR` reader
        pub type R = crate::R<TEM_SENSOR_SPEC>;
        ///Register `TEM_SENSOR` writer
        pub type W = crate::W<TEM_SENSOR_SPEC>;
        ///Field `TEM_SEN_PWR_ON` reader - RW, temperature sensor power control: 0=power down, 1=power on
        pub type TEM_SEN_PWR_ON_R = crate::BitReader;
        ///Field `TEM_SEN_PWR_ON` writer - RW, temperature sensor power control: 0=power down, 1=power on
        pub type TEM_SEN_PWR_ON_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 7 - RW, temperature sensor power control: 0=power down, 1=power on
            #[inline(always)]
            pub fn tem_sen_pwr_on(&self) -> TEM_SEN_PWR_ON_R {
                TEM_SEN_PWR_ON_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 7 - RW, temperature sensor power control: 0=power down, 1=power on
            #[inline(always)]
            #[must_use]
            pub fn tem_sen_pwr_on(&mut self) -> TEM_SEN_PWR_ON_W<TEM_SENSOR_SPEC> {
                TEM_SEN_PWR_ON_W::new(self, 7)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW, temperature sensor control
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`tem_sensor::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`tem_sensor::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct TEM_SENSOR_SPEC;
        impl crate::RegisterSpec for TEM_SENSOR_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`tem_sensor::R`](R) reader structure
        impl crate::Readable for TEM_SENSOR_SPEC {}
        ///`write(|w| ..)` method takes [`tem_sensor::W`](W) writer structure
        impl crate::Writable for TEM_SENSOR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets TEM_SENSOR to value 0
        impl crate::Resettable for TEM_SENSOR_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///ADC_DATA (r) register accessor: RO, ADC data
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`adc_data::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@adc_data`]
    ///module
    pub type ADC_DATA = crate::Reg<adc_data::ADC_DATA_SPEC>;
    ///RO, ADC data
    pub mod adc_data {
        ///Register `ADC_DATA` reader
        pub type R = crate::R<ADC_DATA_SPEC>;
        ///Field `ADC_DATA` reader - RO, ADC conversion data
        pub type ADC_DATA_R = crate::FieldReader<u16>;
        impl R {
            ///Bits 0:11 - RO, ADC conversion data
            #[inline(always)]
            pub fn adc_data(&self) -> ADC_DATA_R {
                ADC_DATA_R::new(self.bits & 0x0fff)
            }
        }
        ///RO, ADC data
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`adc_data::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct ADC_DATA_SPEC;
        impl crate::RegisterSpec for ADC_DATA_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`adc_data::R`](R) reader structure
        impl crate::Readable for ADC_DATA_SPEC {}
        ///`reset()` method sets ADC_DATA to value 0
        impl crate::Resettable for ADC_DATA_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///ADC_INT_FLAG (r) register accessor: RO, ADC interrupt flag register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`adc_int_flag::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@adc_int_flag`]
    ///module
    pub type ADC_INT_FLAG = crate::Reg<adc_int_flag::ADC_INT_FLAG_SPEC>;
    ///RO, ADC interrupt flag register
    pub mod adc_int_flag {
        ///Register `ADC_INT_FLAG` reader
        pub type R = crate::R<ADC_INT_FLAG_SPEC>;
        ///Field `ADC_IF_EOC` reader - RO, ADC conversion interrupt flag: 0=free or converting, 1=end of conversion, interrupt action, write R8_ADC_CONVERT to clear flag
        pub type ADC_IF_EOC_R = crate::BitReader;
        impl R {
            ///Bit 7 - RO, ADC conversion interrupt flag: 0=free or converting, 1=end of conversion, interrupt action, write R8_ADC_CONVERT to clear flag
            #[inline(always)]
            pub fn adc_if_eoc(&self) -> ADC_IF_EOC_R {
                ADC_IF_EOC_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        ///RO, ADC interrupt flag register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`adc_int_flag::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct ADC_INT_FLAG_SPEC;
        impl crate::RegisterSpec for ADC_INT_FLAG_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`adc_int_flag::R`](R) reader structure
        impl crate::Readable for ADC_INT_FLAG_SPEC {}
        ///`reset()` method sets ADC_INT_FLAG to value 0
        impl crate::Resettable for ADC_INT_FLAG_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///ADC_DMA_CTRL (rw) register accessor: RO, ADC DMA control and status register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`adc_dma_ctrl::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`adc_dma_ctrl::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@adc_dma_ctrl`]
    ///module
    pub type ADC_DMA_CTRL = crate::Reg<adc_dma_ctrl::ADC_DMA_CTRL_SPEC>;
    ///RO, ADC DMA control and status register
    pub mod adc_dma_ctrl {
        ///Register `ADC_DMA_CTRL` reader
        pub type R = crate::R<ADC_DMA_CTRL_SPEC>;
        ///Register `ADC_DMA_CTRL` writer
        pub type W = crate::W<ADC_DMA_CTRL_SPEC>;
        ///Field `ADC_DMA_CTRL` reader - RW, ADC DMA enable
        pub type ADC_DMA_CTRL_R = crate::FieldReader;
        ///Field `ADC_DMA_CTRL` writer - RW, ADC DMA enable
        pub type ADC_DMA_CTRL_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            ///Bits 0:7 - RW, ADC DMA enable
            #[inline(always)]
            pub fn adc_dma_ctrl(&self) -> ADC_DMA_CTRL_R {
                ADC_DMA_CTRL_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:7 - RW, ADC DMA enable
            #[inline(always)]
            #[must_use]
            pub fn adc_dma_ctrl(&mut self) -> ADC_DMA_CTRL_W<ADC_DMA_CTRL_SPEC> {
                ADC_DMA_CTRL_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RO, ADC DMA control and status register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`adc_dma_ctrl::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`adc_dma_ctrl::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct ADC_DMA_CTRL_SPEC;
        impl crate::RegisterSpec for ADC_DMA_CTRL_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`adc_dma_ctrl::R`](R) reader structure
        impl crate::Readable for ADC_DMA_CTRL_SPEC {}
        ///`write(|w| ..)` method takes [`adc_dma_ctrl::W`](W) writer structure
        impl crate::Writable for ADC_DMA_CTRL_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets ADC_DMA_CTRL to value 0
        impl crate::Resettable for ADC_DMA_CTRL_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///ADC_CTRL_DMA (rw) register accessor: RW, ADC DMA control
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`adc_ctrl_dma::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`adc_ctrl_dma::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@adc_ctrl_dma`]
    ///module
    pub type ADC_CTRL_DMA = crate::Reg<adc_ctrl_dma::ADC_CTRL_DMA_SPEC>;
    ///RW, ADC DMA control
    pub mod adc_ctrl_dma {
        ///Register `ADC_CTRL_DMA` reader
        pub type R = crate::R<ADC_CTRL_DMA_SPEC>;
        ///Register `ADC_CTRL_DMA` writer
        pub type W = crate::W<ADC_CTRL_DMA_SPEC>;
        ///Field `ADC_DMA_ENABLE` reader - RW, ADC DMA enable
        pub type ADC_DMA_ENABLE_R = crate::BitReader;
        ///Field `ADC_DMA_ENABLE` writer - RW, ADC DMA enable
        pub type ADC_DMA_ENABLE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `ADC_DMA_LOOP` reader - RW, ADC DMA address loop enable
        pub type ADC_DMA_LOOP_R = crate::BitReader;
        ///Field `ADC_DMA_LOOP` writer - RW, ADC DMA address loop enable
        pub type ADC_DMA_LOOP_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `ADC_IE_DMA_END` reader - RW, enable interrupt for ADC DMA completion
        pub type ADC_IE_DMA_END_R = crate::BitReader;
        ///Field `ADC_IE_DMA_END` writer - RW, enable interrupt for ADC DMA completion
        pub type ADC_IE_DMA_END_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `ADC_IE_EOC` reader - RW, enable interrupt for end of ADC conversion
        pub type ADC_IE_EOC_R = crate::BitReader;
        ///Field `ADC_IE_EOC` writer - RW, enable interrupt for end of ADC conversion
        pub type ADC_IE_EOC_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `ADC_AUTO_EN` reader - RW, enable auto continuing ADC for DMA
        pub type ADC_AUTO_EN_R = crate::BitReader;
        ///Field `ADC_AUTO_EN` writer - RW, enable auto continuing ADC for DMA
        pub type ADC_AUTO_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - RW, ADC DMA enable
            #[inline(always)]
            pub fn adc_dma_enable(&self) -> ADC_DMA_ENABLE_R {
                ADC_DMA_ENABLE_R::new((self.bits & 1) != 0)
            }
            ///Bit 2 - RW, ADC DMA address loop enable
            #[inline(always)]
            pub fn adc_dma_loop(&self) -> ADC_DMA_LOOP_R {
                ADC_DMA_LOOP_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RW, enable interrupt for ADC DMA completion
            #[inline(always)]
            pub fn adc_ie_dma_end(&self) -> ADC_IE_DMA_END_R {
                ADC_IE_DMA_END_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RW, enable interrupt for end of ADC conversion
            #[inline(always)]
            pub fn adc_ie_eoc(&self) -> ADC_IE_EOC_R {
                ADC_IE_EOC_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 7 - RW, enable auto continuing ADC for DMA
            #[inline(always)]
            pub fn adc_auto_en(&self) -> ADC_AUTO_EN_R {
                ADC_AUTO_EN_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RW, ADC DMA enable
            #[inline(always)]
            #[must_use]
            pub fn adc_dma_enable(&mut self) -> ADC_DMA_ENABLE_W<ADC_CTRL_DMA_SPEC> {
                ADC_DMA_ENABLE_W::new(self, 0)
            }
            ///Bit 2 - RW, ADC DMA address loop enable
            #[inline(always)]
            #[must_use]
            pub fn adc_dma_loop(&mut self) -> ADC_DMA_LOOP_W<ADC_CTRL_DMA_SPEC> {
                ADC_DMA_LOOP_W::new(self, 2)
            }
            ///Bit 3 - RW, enable interrupt for ADC DMA completion
            #[inline(always)]
            #[must_use]
            pub fn adc_ie_dma_end(&mut self) -> ADC_IE_DMA_END_W<ADC_CTRL_DMA_SPEC> {
                ADC_IE_DMA_END_W::new(self, 3)
            }
            ///Bit 4 - RW, enable interrupt for end of ADC conversion
            #[inline(always)]
            #[must_use]
            pub fn adc_ie_eoc(&mut self) -> ADC_IE_EOC_W<ADC_CTRL_DMA_SPEC> {
                ADC_IE_EOC_W::new(self, 4)
            }
            ///Bit 7 - RW, enable auto continuing ADC for DMA
            #[inline(always)]
            #[must_use]
            pub fn adc_auto_en(&mut self) -> ADC_AUTO_EN_W<ADC_CTRL_DMA_SPEC> {
                ADC_AUTO_EN_W::new(self, 7)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW, ADC DMA control
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`adc_ctrl_dma::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`adc_ctrl_dma::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct ADC_CTRL_DMA_SPEC;
        impl crate::RegisterSpec for ADC_CTRL_DMA_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`adc_ctrl_dma::R`](R) reader structure
        impl crate::Readable for ADC_CTRL_DMA_SPEC {}
        ///`write(|w| ..)` method takes [`adc_ctrl_dma::W`](W) writer structure
        impl crate::Writable for ADC_CTRL_DMA_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets ADC_CTRL_DMA to value 0
        impl crate::Resettable for ADC_CTRL_DMA_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///ADC_DMA_IF (rw) register accessor: RO, ADC interrupt flag
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`adc_dma_if::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`adc_dma_if::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@adc_dma_if`]
    ///module
    pub type ADC_DMA_IF = crate::Reg<adc_dma_if::ADC_DMA_IF_SPEC>;
    ///RO, ADC interrupt flag
    pub mod adc_dma_if {
        ///Register `ADC_DMA_IF` reader
        pub type R = crate::R<ADC_DMA_IF_SPEC>;
        ///Register `ADC_DMA_IF` writer
        pub type W = crate::W<ADC_DMA_IF_SPEC>;
        ///Field `ADC_IF_DMA_END` reader - interrupt flag for ADC DMA completion
        pub type ADC_IF_DMA_END_R = crate::BitReader;
        ///Field `ADC_IF_DMA_END` writer - interrupt flag for ADC DMA completion
        pub type ADC_IF_DMA_END_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `ADC_IF_END_ADC` reader - interrupt flag for end of ADC conversion
        pub type ADC_IF_END_ADC_R = crate::BitReader;
        ///Field `ADC_IF_END_ADC` writer - interrupt flag for end of ADC conversion
        pub type ADC_IF_END_ADC_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 3 - interrupt flag for ADC DMA completion
            #[inline(always)]
            pub fn adc_if_dma_end(&self) -> ADC_IF_DMA_END_R {
                ADC_IF_DMA_END_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - interrupt flag for end of ADC conversion
            #[inline(always)]
            pub fn adc_if_end_adc(&self) -> ADC_IF_END_ADC_R {
                ADC_IF_END_ADC_R::new(((self.bits >> 4) & 1) != 0)
            }
        }
        impl W {
            ///Bit 3 - interrupt flag for ADC DMA completion
            #[inline(always)]
            #[must_use]
            pub fn adc_if_dma_end(&mut self) -> ADC_IF_DMA_END_W<ADC_DMA_IF_SPEC> {
                ADC_IF_DMA_END_W::new(self, 3)
            }
            ///Bit 4 - interrupt flag for end of ADC conversion
            #[inline(always)]
            #[must_use]
            pub fn adc_if_end_adc(&mut self) -> ADC_IF_END_ADC_W<ADC_DMA_IF_SPEC> {
                ADC_IF_END_ADC_W::new(self, 4)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RO, ADC interrupt flag
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`adc_dma_if::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`adc_dma_if::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct ADC_DMA_IF_SPEC;
        impl crate::RegisterSpec for ADC_DMA_IF_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`adc_dma_if::R`](R) reader structure
        impl crate::Readable for ADC_DMA_IF_SPEC {}
        ///`write(|w| ..)` method takes [`adc_dma_if::W`](W) writer structure
        impl crate::Writable for ADC_DMA_IF_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets ADC_DMA_IF to value 0
        impl crate::Resettable for ADC_DMA_IF_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///ADC_AUTO_CYCLE (rw) register accessor: RO, ADC interrupt flag
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`adc_auto_cycle::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`adc_auto_cycle::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@adc_auto_cycle`]
    ///module
    pub type ADC_AUTO_CYCLE = crate::Reg<adc_auto_cycle::ADC_AUTO_CYCLE_SPEC>;
    ///RO, ADC interrupt flag
    pub mod adc_auto_cycle {
        ///Register `ADC_AUTO_CYCLE` reader
        pub type R = crate::R<ADC_AUTO_CYCLE_SPEC>;
        ///Register `ADC_AUTO_CYCLE` writer
        pub type W = crate::W<ADC_AUTO_CYCLE_SPEC>;
        ///Field `ADC_AUTO_CYCLE` reader - auto ADC cycle value, unit is 16 Fsys
        pub type ADC_AUTO_CYCLE_R = crate::FieldReader;
        ///Field `ADC_AUTO_CYCLE` writer - auto ADC cycle value, unit is 16 Fsys
        pub type ADC_AUTO_CYCLE_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            ///Bits 0:7 - auto ADC cycle value, unit is 16 Fsys
            #[inline(always)]
            pub fn adc_auto_cycle(&self) -> ADC_AUTO_CYCLE_R {
                ADC_AUTO_CYCLE_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:7 - auto ADC cycle value, unit is 16 Fsys
            #[inline(always)]
            #[must_use]
            pub fn adc_auto_cycle(&mut self) -> ADC_AUTO_CYCLE_W<ADC_AUTO_CYCLE_SPEC> {
                ADC_AUTO_CYCLE_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RO, ADC interrupt flag
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`adc_auto_cycle::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`adc_auto_cycle::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct ADC_AUTO_CYCLE_SPEC;
        impl crate::RegisterSpec for ADC_AUTO_CYCLE_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`adc_auto_cycle::R`](R) reader structure
        impl crate::Readable for ADC_AUTO_CYCLE_SPEC {}
        ///`write(|w| ..)` method takes [`adc_auto_cycle::W`](W) writer structure
        impl crate::Writable for ADC_AUTO_CYCLE_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets ADC_AUTO_CYCLE to value 0
        impl crate::Resettable for ADC_AUTO_CYCLE_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///ADC_DMA_NOW (r) register accessor: RO, ADC DMA current address
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`adc_dma_now::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@adc_dma_now`]
    ///module
    pub type ADC_DMA_NOW = crate::Reg<adc_dma_now::ADC_DMA_NOW_SPEC>;
    ///RO, ADC DMA current address
    pub mod adc_dma_now {
        ///Register `ADC_DMA_NOW` reader
        pub type R = crate::R<ADC_DMA_NOW_SPEC>;
        ///Field `ADC_DMA_NOW` reader - ADC DMA current address
        pub type ADC_DMA_NOW_R = crate::FieldReader<u16>;
        impl R {
            ///Bits 0:15 - ADC DMA current address
            #[inline(always)]
            pub fn adc_dma_now(&self) -> ADC_DMA_NOW_R {
                ADC_DMA_NOW_R::new(self.bits)
            }
        }
        ///RO, ADC DMA current address
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`adc_dma_now::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct ADC_DMA_NOW_SPEC;
        impl crate::RegisterSpec for ADC_DMA_NOW_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`adc_dma_now::R`](R) reader structure
        impl crate::Readable for ADC_DMA_NOW_SPEC {}
        ///`reset()` method sets ADC_DMA_NOW to value 0
        impl crate::Resettable for ADC_DMA_NOW_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///ADC_DMA_BEG (rw) register accessor: RW, ADC DMA begin address
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`adc_dma_beg::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`adc_dma_beg::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@adc_dma_beg`]
    ///module
    pub type ADC_DMA_BEG = crate::Reg<adc_dma_beg::ADC_DMA_BEG_SPEC>;
    ///RW, ADC DMA begin address
    pub mod adc_dma_beg {
        ///Register `ADC_DMA_BEG` reader
        pub type R = crate::R<ADC_DMA_BEG_SPEC>;
        ///Register `ADC_DMA_BEG` writer
        pub type W = crate::W<ADC_DMA_BEG_SPEC>;
        ///Field `ADC_DMA_BEG` reader - ADC DMA begin address
        pub type ADC_DMA_BEG_R = crate::FieldReader<u16>;
        ///Field `ADC_DMA_BEG` writer - ADC DMA begin address
        pub type ADC_DMA_BEG_W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            ///Bits 0:15 - ADC DMA begin address
            #[inline(always)]
            pub fn adc_dma_beg(&self) -> ADC_DMA_BEG_R {
                ADC_DMA_BEG_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - ADC DMA begin address
            #[inline(always)]
            #[must_use]
            pub fn adc_dma_beg(&mut self) -> ADC_DMA_BEG_W<ADC_DMA_BEG_SPEC> {
                ADC_DMA_BEG_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW, ADC DMA begin address
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`adc_dma_beg::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`adc_dma_beg::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct ADC_DMA_BEG_SPEC;
        impl crate::RegisterSpec for ADC_DMA_BEG_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`adc_dma_beg::R`](R) reader structure
        impl crate::Readable for ADC_DMA_BEG_SPEC {}
        ///`write(|w| ..)` method takes [`adc_dma_beg::W`](W) writer structure
        impl crate::Writable for ADC_DMA_BEG_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets ADC_DMA_BEG to value 0
        impl crate::Resettable for ADC_DMA_BEG_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///ADC_DMA_END (rw) register accessor: RW, ADC DMA end address
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`adc_dma_end::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`adc_dma_end::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@adc_dma_end`]
    ///module
    pub type ADC_DMA_END = crate::Reg<adc_dma_end::ADC_DMA_END_SPEC>;
    ///RW, ADC DMA end address
    pub mod adc_dma_end {
        ///Register `ADC_DMA_END` reader
        pub type R = crate::R<ADC_DMA_END_SPEC>;
        ///Register `ADC_DMA_END` writer
        pub type W = crate::W<ADC_DMA_END_SPEC>;
        ///Field `ADC_DMA_END` reader - ADC DMA end address
        pub type ADC_DMA_END_R = crate::FieldReader<u16>;
        ///Field `ADC_DMA_END` writer - ADC DMA end address
        pub type ADC_DMA_END_W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            ///Bits 0:15 - ADC DMA end address
            #[inline(always)]
            pub fn adc_dma_end(&self) -> ADC_DMA_END_R {
                ADC_DMA_END_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - ADC DMA end address
            #[inline(always)]
            #[must_use]
            pub fn adc_dma_end(&mut self) -> ADC_DMA_END_W<ADC_DMA_END_SPEC> {
                ADC_DMA_END_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW, ADC DMA end address
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`adc_dma_end::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`adc_dma_end::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct ADC_DMA_END_SPEC;
        impl crate::RegisterSpec for ADC_DMA_END_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`adc_dma_end::R`](R) reader structure
        impl crate::Readable for ADC_DMA_END_SPEC {}
        ///`write(|w| ..)` method takes [`adc_dma_end::W`](W) writer structure
        impl crate::Writable for ADC_DMA_END_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets ADC_DMA_END to value 0
        impl crate::Resettable for ADC_DMA_END_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///PA_INT_EN (rw) register accessor: RW, GPIO PA interrupt enable
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`pa_int_en::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pa_int_en::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@pa_int_en`]
    ///module
    pub type PA_INT_EN = crate::Reg<pa_int_en::PA_INT_EN_SPEC>;
    ///RW, GPIO PA interrupt enable
    pub mod pa_int_en {
        ///Register `PA_INT_EN` reader
        pub type R = crate::R<PA_INT_EN_SPEC>;
        ///Register `PA_INT_EN` writer
        pub type W = crate::W<PA_INT_EN_SPEC>;
        ///Field `PA_INT_EN` reader - GPIO PA interrupt enable
        pub type PA_INT_EN_R = crate::FieldReader<u16>;
        ///Field `PA_INT_EN` writer - GPIO PA interrupt enable
        pub type PA_INT_EN_W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            ///Bits 0:15 - GPIO PA interrupt enable
            #[inline(always)]
            pub fn pa_int_en(&self) -> PA_INT_EN_R {
                PA_INT_EN_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - GPIO PA interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn pa_int_en(&mut self) -> PA_INT_EN_W<PA_INT_EN_SPEC> {
                PA_INT_EN_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW, GPIO PA interrupt enable
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`pa_int_en::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pa_int_en::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct PA_INT_EN_SPEC;
        impl crate::RegisterSpec for PA_INT_EN_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`pa_int_en::R`](R) reader structure
        impl crate::Readable for PA_INT_EN_SPEC {}
        ///`write(|w| ..)` method takes [`pa_int_en::W`](W) writer structure
        impl crate::Writable for PA_INT_EN_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets PA_INT_EN to value 0
        impl crate::Resettable for PA_INT_EN_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///PB_INT_EN (rw) register accessor: RW, GPIO PB interrupt enable
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`pb_int_en::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pb_int_en::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@pb_int_en`]
    ///module
    pub type PB_INT_EN = crate::Reg<pb_int_en::PB_INT_EN_SPEC>;
    ///RW, GPIO PB interrupt enable
    pub mod pb_int_en {
        ///Register `PB_INT_EN` reader
        pub type R = crate::R<PB_INT_EN_SPEC>;
        ///Register `PB_INT_EN` writer
        pub type W = crate::W<PB_INT_EN_SPEC>;
        ///Field `PB_INT_EN` reader - GPIO PB interrupt enable
        pub type PB_INT_EN_R = crate::FieldReader<u16>;
        ///Field `PB_INT_EN` writer - GPIO PB interrupt enable
        pub type PB_INT_EN_W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            ///Bits 0:15 - GPIO PB interrupt enable
            #[inline(always)]
            pub fn pb_int_en(&self) -> PB_INT_EN_R {
                PB_INT_EN_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - GPIO PB interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn pb_int_en(&mut self) -> PB_INT_EN_W<PB_INT_EN_SPEC> {
                PB_INT_EN_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW, GPIO PB interrupt enable
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`pb_int_en::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pb_int_en::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct PB_INT_EN_SPEC;
        impl crate::RegisterSpec for PB_INT_EN_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`pb_int_en::R`](R) reader structure
        impl crate::Readable for PB_INT_EN_SPEC {}
        ///`write(|w| ..)` method takes [`pb_int_en::W`](W) writer structure
        impl crate::Writable for PB_INT_EN_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets PB_INT_EN to value 0
        impl crate::Resettable for PB_INT_EN_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///PA_INT_MODE (rw) register accessor: RW, GPIO PA interrupt mode: 0=level action, 1=edge action
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`pa_int_mode::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pa_int_mode::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@pa_int_mode`]
    ///module
    pub type PA_INT_MODE = crate::Reg<pa_int_mode::PA_INT_MODE_SPEC>;
    ///RW, GPIO PA interrupt mode: 0=level action, 1=edge action
    pub mod pa_int_mode {
        ///Register `PA_INT_MODE` reader
        pub type R = crate::R<PA_INT_MODE_SPEC>;
        ///Register `PA_INT_MODE` writer
        pub type W = crate::W<PA_INT_MODE_SPEC>;
        ///Field `PA_INT_MODE` reader - GPIO PA interrupt mode
        pub type PA_INT_MODE_R = crate::FieldReader<u16>;
        ///Field `PA_INT_MODE` writer - GPIO PA interrupt mode
        pub type PA_INT_MODE_W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            ///Bits 0:15 - GPIO PA interrupt mode
            #[inline(always)]
            pub fn pa_int_mode(&self) -> PA_INT_MODE_R {
                PA_INT_MODE_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - GPIO PA interrupt mode
            #[inline(always)]
            #[must_use]
            pub fn pa_int_mode(&mut self) -> PA_INT_MODE_W<PA_INT_MODE_SPEC> {
                PA_INT_MODE_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW, GPIO PA interrupt mode: 0=level action, 1=edge action
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`pa_int_mode::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pa_int_mode::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct PA_INT_MODE_SPEC;
        impl crate::RegisterSpec for PA_INT_MODE_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`pa_int_mode::R`](R) reader structure
        impl crate::Readable for PA_INT_MODE_SPEC {}
        ///`write(|w| ..)` method takes [`pa_int_mode::W`](W) writer structure
        impl crate::Writable for PA_INT_MODE_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets PA_INT_MODE to value 0
        impl crate::Resettable for PA_INT_MODE_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///PB_INT_MODE (rw) register accessor: RW, GPIO PB interrupt mode: 0=level action, 1=edge action;RW, status for parallel slave read
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`pb_int_mode::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pb_int_mode::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@pb_int_mode`]
    ///module
    pub type PB_INT_MODE = crate::Reg<pb_int_mode::PB_INT_MODE_SPEC>;
    ///RW, GPIO PB interrupt mode: 0=level action, 1=edge action;RW, status for parallel slave read
    pub mod pb_int_mode {
        ///Register `PB_INT_MODE` reader
        pub type R = crate::R<PB_INT_MODE_SPEC>;
        ///Register `PB_INT_MODE` writer
        pub type W = crate::W<PB_INT_MODE_SPEC>;
        ///Field `PB_INT_MODE` reader - GPIO PB interrupt mode
        pub type PB_INT_MODE_R = crate::FieldReader<u16>;
        ///Field `PB_INT_MODE` writer - GPIO PB interrupt mode
        pub type PB_INT_MODE_W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            ///Bits 0:15 - GPIO PB interrupt mode
            #[inline(always)]
            pub fn pb_int_mode(&self) -> PB_INT_MODE_R {
                PB_INT_MODE_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - GPIO PB interrupt mode
            #[inline(always)]
            #[must_use]
            pub fn pb_int_mode(&mut self) -> PB_INT_MODE_W<PB_INT_MODE_SPEC> {
                PB_INT_MODE_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW, GPIO PB interrupt mode: 0=level action, 1=edge action;RW, status for parallel slave read
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`pb_int_mode::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pb_int_mode::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct PB_INT_MODE_SPEC;
        impl crate::RegisterSpec for PB_INT_MODE_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`pb_int_mode::R`](R) reader structure
        impl crate::Readable for PB_INT_MODE_SPEC {}
        ///`write(|w| ..)` method takes [`pb_int_mode::W`](W) writer structure
        impl crate::Writable for PB_INT_MODE_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets PB_INT_MODE to value 0
        impl crate::Resettable for PB_INT_MODE_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///PA_INT_IF (rw) register accessor: RW1, GPIO PA interrupt flag
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`pa_int_if::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pa_int_if::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@pa_int_if`]
    ///module
    pub type PA_INT_IF = crate::Reg<pa_int_if::PA_INT_IF_SPEC>;
    ///RW1, GPIO PA interrupt flag
    pub mod pa_int_if {
        ///Register `PA_INT_IF` reader
        pub type R = crate::R<PA_INT_IF_SPEC>;
        ///Register `PA_INT_IF` writer
        pub type W = crate::W<PA_INT_IF_SPEC>;
        ///Field `PA_INT_IF` reader - GPIO PA interrupt flag
        pub type PA_INT_IF_R = crate::FieldReader<u16>;
        ///Field `PA_INT_IF` writer - GPIO PA interrupt flag
        pub type PA_INT_IF_W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            ///Bits 0:15 - GPIO PA interrupt flag
            #[inline(always)]
            pub fn pa_int_if(&self) -> PA_INT_IF_R {
                PA_INT_IF_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - GPIO PA interrupt flag
            #[inline(always)]
            #[must_use]
            pub fn pa_int_if(&mut self) -> PA_INT_IF_W<PA_INT_IF_SPEC> {
                PA_INT_IF_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW1, GPIO PA interrupt flag
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`pa_int_if::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pa_int_if::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct PA_INT_IF_SPEC;
        impl crate::RegisterSpec for PA_INT_IF_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`pa_int_if::R`](R) reader structure
        impl crate::Readable for PA_INT_IF_SPEC {}
        ///`write(|w| ..)` method takes [`pa_int_if::W`](W) writer structure
        impl crate::Writable for PA_INT_IF_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets PA_INT_IF to value 0
        impl crate::Resettable for PA_INT_IF_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///PB_INT_IF (rw) register accessor: RW1, GPIO PB interrupt flag
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`pb_int_if::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pb_int_if::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@pb_int_if`]
    ///module
    pub type PB_INT_IF = crate::Reg<pb_int_if::PB_INT_IF_SPEC>;
    ///RW1, GPIO PB interrupt flag
    pub mod pb_int_if {
        ///Register `PB_INT_IF` reader
        pub type R = crate::R<PB_INT_IF_SPEC>;
        ///Register `PB_INT_IF` writer
        pub type W = crate::W<PB_INT_IF_SPEC>;
        ///Field `PB_INT_IF` reader - GPIO PB interrupt flag
        pub type PB_INT_IF_R = crate::FieldReader<u16>;
        ///Field `PB_INT_IF` writer - GPIO PB interrupt flag
        pub type PB_INT_IF_W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            ///Bits 0:15 - GPIO PB interrupt flag
            #[inline(always)]
            pub fn pb_int_if(&self) -> PB_INT_IF_R {
                PB_INT_IF_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - GPIO PB interrupt flag
            #[inline(always)]
            #[must_use]
            pub fn pb_int_if(&mut self) -> PB_INT_IF_W<PB_INT_IF_SPEC> {
                PB_INT_IF_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW1, GPIO PB interrupt flag
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`pb_int_if::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pb_int_if::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct PB_INT_IF_SPEC;
        impl crate::RegisterSpec for PB_INT_IF_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`pb_int_if::R`](R) reader structure
        impl crate::Readable for PB_INT_IF_SPEC {}
        ///`write(|w| ..)` method takes [`pb_int_if::W`](W) writer structure
        impl crate::Writable for PB_INT_IF_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets PB_INT_IF to value 0
        impl crate::Resettable for PB_INT_IF_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///PA_DIR (rw) register accessor: RW, GPIO PA I/O direction: 0=in, 1=out
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`pa_dir::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pa_dir::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@pa_dir`]
    ///module
    pub type PA_DIR = crate::Reg<pa_dir::PA_DIR_SPEC>;
    ///RW, GPIO PA I/O direction: 0=in, 1=out
    pub mod pa_dir {
        ///Register `PA_DIR` reader
        pub type R = crate::R<PA_DIR_SPEC>;
        ///Register `PA_DIR` writer
        pub type W = crate::W<PA_DIR_SPEC>;
        ///Field `PA_DIR_0` reader - GPIO PA I/O direction byte 0
        pub type PA_DIR_0_R = crate::FieldReader;
        ///Field `PA_DIR_0` writer - GPIO PA I/O direction byte 0
        pub type PA_DIR_0_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        ///Field `PA_DIR_1` reader - GPIO PA I/O direction byte 1
        pub type PA_DIR_1_R = crate::FieldReader;
        ///Field `PA_DIR_1` writer - GPIO PA I/O direction byte 1
        pub type PA_DIR_1_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            ///Bits 0:7 - GPIO PA I/O direction byte 0
            #[inline(always)]
            pub fn pa_dir_0(&self) -> PA_DIR_0_R {
                PA_DIR_0_R::new((self.bits & 0xff) as u8)
            }
            ///Bits 8:15 - GPIO PA I/O direction byte 1
            #[inline(always)]
            pub fn pa_dir_1(&self) -> PA_DIR_1_R {
                PA_DIR_1_R::new(((self.bits >> 8) & 0xff) as u8)
            }
        }
        impl W {
            ///Bits 0:7 - GPIO PA I/O direction byte 0
            #[inline(always)]
            #[must_use]
            pub fn pa_dir_0(&mut self) -> PA_DIR_0_W<PA_DIR_SPEC> {
                PA_DIR_0_W::new(self, 0)
            }
            ///Bits 8:15 - GPIO PA I/O direction byte 1
            #[inline(always)]
            #[must_use]
            pub fn pa_dir_1(&mut self) -> PA_DIR_1_W<PA_DIR_SPEC> {
                PA_DIR_1_W::new(self, 8)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW, GPIO PA I/O direction: 0=in, 1=out
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`pa_dir::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pa_dir::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct PA_DIR_SPEC;
        impl crate::RegisterSpec for PA_DIR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`pa_dir::R`](R) reader structure
        impl crate::Readable for PA_DIR_SPEC {}
        ///`write(|w| ..)` method takes [`pa_dir::W`](W) writer structure
        impl crate::Writable for PA_DIR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets PA_DIR to value 0
        impl crate::Resettable for PA_DIR_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///PA_PIN (r) register accessor: RO, GPIO PA input
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`pa_pin::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@pa_pin`]
    ///module
    pub type PA_PIN = crate::Reg<pa_pin::PA_PIN_SPEC>;
    ///RO, GPIO PA input
    pub mod pa_pin {
        ///Register `PA_PIN` reader
        pub type R = crate::R<PA_PIN_SPEC>;
        ///Field `PA_PIN_0` reader - GPIO PA input byte 0
        pub type PA_PIN_0_R = crate::FieldReader;
        ///Field `PA_PIN_1` reader - GPIO PA input byte 1
        pub type PA_PIN_1_R = crate::FieldReader;
        impl R {
            ///Bits 0:7 - GPIO PA input byte 0
            #[inline(always)]
            pub fn pa_pin_0(&self) -> PA_PIN_0_R {
                PA_PIN_0_R::new((self.bits & 0xff) as u8)
            }
            ///Bits 8:15 - GPIO PA input byte 1
            #[inline(always)]
            pub fn pa_pin_1(&self) -> PA_PIN_1_R {
                PA_PIN_1_R::new(((self.bits >> 8) & 0xff) as u8)
            }
        }
        ///RO, GPIO PA input
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`pa_pin::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct PA_PIN_SPEC;
        impl crate::RegisterSpec for PA_PIN_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`pa_pin::R`](R) reader structure
        impl crate::Readable for PA_PIN_SPEC {}
        ///`reset()` method sets PA_PIN to value 0
        impl crate::Resettable for PA_PIN_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///PA_OUT (rw) register accessor: RW, GPIO PA output
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`pa_out::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pa_out::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@pa_out`]
    ///module
    pub type PA_OUT = crate::Reg<pa_out::PA_OUT_SPEC>;
    ///RW, GPIO PA output
    pub mod pa_out {
        ///Register `PA_OUT` reader
        pub type R = crate::R<PA_OUT_SPEC>;
        ///Register `PA_OUT` writer
        pub type W = crate::W<PA_OUT_SPEC>;
        ///Field `PA_OUT_0` reader - GPIO PA output byte 0
        pub type PA_OUT_0_R = crate::FieldReader;
        ///Field `PA_OUT_0` writer - GPIO PA output byte 0
        pub type PA_OUT_0_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        ///Field `PA_OUT_1` reader - GPIO PA output byte 1
        pub type PA_OUT_1_R = crate::FieldReader;
        ///Field `PA_OUT_1` writer - GPIO PA output byte 1
        pub type PA_OUT_1_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            ///Bits 0:7 - GPIO PA output byte 0
            #[inline(always)]
            pub fn pa_out_0(&self) -> PA_OUT_0_R {
                PA_OUT_0_R::new((self.bits & 0xff) as u8)
            }
            ///Bits 8:15 - GPIO PA output byte 1
            #[inline(always)]
            pub fn pa_out_1(&self) -> PA_OUT_1_R {
                PA_OUT_1_R::new(((self.bits >> 8) & 0xff) as u8)
            }
        }
        impl W {
            ///Bits 0:7 - GPIO PA output byte 0
            #[inline(always)]
            #[must_use]
            pub fn pa_out_0(&mut self) -> PA_OUT_0_W<PA_OUT_SPEC> {
                PA_OUT_0_W::new(self, 0)
            }
            ///Bits 8:15 - GPIO PA output byte 1
            #[inline(always)]
            #[must_use]
            pub fn pa_out_1(&mut self) -> PA_OUT_1_W<PA_OUT_SPEC> {
                PA_OUT_1_W::new(self, 8)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW, GPIO PA output
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`pa_out::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pa_out::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct PA_OUT_SPEC;
        impl crate::RegisterSpec for PA_OUT_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`pa_out::R`](R) reader structure
        impl crate::Readable for PA_OUT_SPEC {}
        ///`write(|w| ..)` method takes [`pa_out::W`](W) writer structure
        impl crate::Writable for PA_OUT_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets PA_OUT to value 0
        impl crate::Resettable for PA_OUT_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///PA_CLR (rw) register accessor: WZ, GPIO PA clear output: 0=keep, 1=clear
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`pa_clr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pa_clr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@pa_clr`]
    ///module
    pub type PA_CLR = crate::Reg<pa_clr::PA_CLR_SPEC>;
    ///WZ, GPIO PA clear output: 0=keep, 1=clear
    pub mod pa_clr {
        ///Register `PA_CLR` reader
        pub type R = crate::R<PA_CLR_SPEC>;
        ///Register `PA_CLR` writer
        pub type W = crate::W<PA_CLR_SPEC>;
        ///Field `PA_CLR_0` reader - GPIO PA clear output byte 0
        pub type PA_CLR_0_R = crate::FieldReader;
        ///Field `PA_CLR_0` writer - GPIO PA clear output byte 0
        pub type PA_CLR_0_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        ///Field `PA_CLR_1` reader - GPIO PA clear output byte 1
        pub type PA_CLR_1_R = crate::FieldReader;
        ///Field `PA_CLR_1` writer - GPIO PA clear output byte 1
        pub type PA_CLR_1_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            ///Bits 0:7 - GPIO PA clear output byte 0
            #[inline(always)]
            pub fn pa_clr_0(&self) -> PA_CLR_0_R {
                PA_CLR_0_R::new((self.bits & 0xff) as u8)
            }
            ///Bits 8:15 - GPIO PA clear output byte 1
            #[inline(always)]
            pub fn pa_clr_1(&self) -> PA_CLR_1_R {
                PA_CLR_1_R::new(((self.bits >> 8) & 0xff) as u8)
            }
        }
        impl W {
            ///Bits 0:7 - GPIO PA clear output byte 0
            #[inline(always)]
            #[must_use]
            pub fn pa_clr_0(&mut self) -> PA_CLR_0_W<PA_CLR_SPEC> {
                PA_CLR_0_W::new(self, 0)
            }
            ///Bits 8:15 - GPIO PA clear output byte 1
            #[inline(always)]
            #[must_use]
            pub fn pa_clr_1(&mut self) -> PA_CLR_1_W<PA_CLR_SPEC> {
                PA_CLR_1_W::new(self, 8)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///WZ, GPIO PA clear output: 0=keep, 1=clear
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`pa_clr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pa_clr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct PA_CLR_SPEC;
        impl crate::RegisterSpec for PA_CLR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`pa_clr::R`](R) reader structure
        impl crate::Readable for PA_CLR_SPEC {}
        ///`write(|w| ..)` method takes [`pa_clr::W`](W) writer structure
        impl crate::Writable for PA_CLR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets PA_CLR to value 0
        impl crate::Resettable for PA_CLR_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///PA_PU (rw) register accessor: RW, GPIO PA pullup resistance enable
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`pa_pu::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pa_pu::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@pa_pu`]
    ///module
    pub type PA_PU = crate::Reg<pa_pu::PA_PU_SPEC>;
    ///RW, GPIO PA pullup resistance enable
    pub mod pa_pu {
        ///Register `PA_PU` reader
        pub type R = crate::R<PA_PU_SPEC>;
        ///Register `PA_PU` writer
        pub type W = crate::W<PA_PU_SPEC>;
        ///Field `PA_PU_0` reader - GPIO PA pullup resistance enable byte 0
        pub type PA_PU_0_R = crate::FieldReader;
        ///Field `PA_PU_0` writer - GPIO PA pullup resistance enable byte 0
        pub type PA_PU_0_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        ///Field `PA_PU_1` reader - GPIO PA pullup resistance enable byte 0
        pub type PA_PU_1_R = crate::FieldReader;
        ///Field `PA_PU_1` writer - GPIO PA pullup resistance enable byte 0
        pub type PA_PU_1_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            ///Bits 0:7 - GPIO PA pullup resistance enable byte 0
            #[inline(always)]
            pub fn pa_pu_0(&self) -> PA_PU_0_R {
                PA_PU_0_R::new((self.bits & 0xff) as u8)
            }
            ///Bits 8:15 - GPIO PA pullup resistance enable byte 0
            #[inline(always)]
            pub fn pa_pu_1(&self) -> PA_PU_1_R {
                PA_PU_1_R::new(((self.bits >> 8) & 0xff) as u8)
            }
        }
        impl W {
            ///Bits 0:7 - GPIO PA pullup resistance enable byte 0
            #[inline(always)]
            #[must_use]
            pub fn pa_pu_0(&mut self) -> PA_PU_0_W<PA_PU_SPEC> {
                PA_PU_0_W::new(self, 0)
            }
            ///Bits 8:15 - GPIO PA pullup resistance enable byte 0
            #[inline(always)]
            #[must_use]
            pub fn pa_pu_1(&mut self) -> PA_PU_1_W<PA_PU_SPEC> {
                PA_PU_1_W::new(self, 8)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW, GPIO PA pullup resistance enable
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`pa_pu::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pa_pu::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct PA_PU_SPEC;
        impl crate::RegisterSpec for PA_PU_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`pa_pu::R`](R) reader structure
        impl crate::Readable for PA_PU_SPEC {}
        ///`write(|w| ..)` method takes [`pa_pu::W`](W) writer structure
        impl crate::Writable for PA_PU_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets PA_PU to value 0
        impl crate::Resettable for PA_PU_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///PA_PD_DRV (rw) register accessor: RW, PA pulldown for input or PA driving capability for output
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`pa_pd_drv::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pa_pd_drv::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@pa_pd_drv`]
    ///module
    pub type PA_PD_DRV = crate::Reg<pa_pd_drv::PA_PD_DRV_SPEC>;
    ///RW, PA pulldown for input or PA driving capability for output
    pub mod pa_pd_drv {
        ///Register `PA_PD_DRV` reader
        pub type R = crate::R<PA_PD_DRV_SPEC>;
        ///Register `PA_PD_DRV` writer
        pub type W = crate::W<PA_PD_DRV_SPEC>;
        ///Field `PA_PD_DRV_0` reader - PA pulldown for input or PA driving capability for output byte 0
        pub type PA_PD_DRV_0_R = crate::FieldReader;
        ///Field `PA_PD_DRV_0` writer - PA pulldown for input or PA driving capability for output byte 0
        pub type PA_PD_DRV_0_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        ///Field `PA_PD_DRV_1` reader - PA pulldown for input or PA driving capability for output byte 1
        pub type PA_PD_DRV_1_R = crate::FieldReader;
        ///Field `PA_PD_DRV_1` writer - PA pulldown for input or PA driving capability for output byte 1
        pub type PA_PD_DRV_1_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            ///Bits 0:7 - PA pulldown for input or PA driving capability for output byte 0
            #[inline(always)]
            pub fn pa_pd_drv_0(&self) -> PA_PD_DRV_0_R {
                PA_PD_DRV_0_R::new((self.bits & 0xff) as u8)
            }
            ///Bits 8:15 - PA pulldown for input or PA driving capability for output byte 1
            #[inline(always)]
            pub fn pa_pd_drv_1(&self) -> PA_PD_DRV_1_R {
                PA_PD_DRV_1_R::new(((self.bits >> 8) & 0xff) as u8)
            }
        }
        impl W {
            ///Bits 0:7 - PA pulldown for input or PA driving capability for output byte 0
            #[inline(always)]
            #[must_use]
            pub fn pa_pd_drv_0(&mut self) -> PA_PD_DRV_0_W<PA_PD_DRV_SPEC> {
                PA_PD_DRV_0_W::new(self, 0)
            }
            ///Bits 8:15 - PA pulldown for input or PA driving capability for output byte 1
            #[inline(always)]
            #[must_use]
            pub fn pa_pd_drv_1(&mut self) -> PA_PD_DRV_1_W<PA_PD_DRV_SPEC> {
                PA_PD_DRV_1_W::new(self, 8)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW, PA pulldown for input or PA driving capability for output
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`pa_pd_drv::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pa_pd_drv::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct PA_PD_DRV_SPEC;
        impl crate::RegisterSpec for PA_PD_DRV_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`pa_pd_drv::R`](R) reader structure
        impl crate::Readable for PA_PD_DRV_SPEC {}
        ///`write(|w| ..)` method takes [`pa_pd_drv::W`](W) writer structure
        impl crate::Writable for PA_PD_DRV_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets PA_PD_DRV to value 0
        impl crate::Resettable for PA_PD_DRV_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///PB_DIR (rw) register accessor: RW, GPIO PB I/O direction: 0=in, 1=out
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`pb_dir::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pb_dir::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@pb_dir`]
    ///module
    pub type PB_DIR = crate::Reg<pb_dir::PB_DIR_SPEC>;
    ///RW, GPIO PB I/O direction: 0=in, 1=out
    pub mod pb_dir {
        ///Register `PB_DIR` reader
        pub type R = crate::R<PB_DIR_SPEC>;
        ///Register `PB_DIR` writer
        pub type W = crate::W<PB_DIR_SPEC>;
        ///Field `PB_DIR_0` reader - GPIO PB I/O direction byte 0
        pub type PB_DIR_0_R = crate::FieldReader;
        ///Field `PB_DIR_0` writer - GPIO PB I/O direction byte 0
        pub type PB_DIR_0_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        ///Field `PB_DIR_1` reader - GPIO PB I/O direction byte 1
        pub type PB_DIR_1_R = crate::FieldReader;
        ///Field `PB_DIR_1` writer - GPIO PB I/O direction byte 1
        pub type PB_DIR_1_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        ///Field `PB_DIR_2` reader - GPIO PB I/O direction byte 2
        pub type PB_DIR_2_R = crate::FieldReader;
        ///Field `PB_DIR_2` writer - GPIO PB I/O direction byte 2
        pub type PB_DIR_2_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            ///Bits 0:7 - GPIO PB I/O direction byte 0
            #[inline(always)]
            pub fn pb_dir_0(&self) -> PB_DIR_0_R {
                PB_DIR_0_R::new((self.bits & 0xff) as u8)
            }
            ///Bits 8:15 - GPIO PB I/O direction byte 1
            #[inline(always)]
            pub fn pb_dir_1(&self) -> PB_DIR_1_R {
                PB_DIR_1_R::new(((self.bits >> 8) & 0xff) as u8)
            }
            ///Bits 16:23 - GPIO PB I/O direction byte 2
            #[inline(always)]
            pub fn pb_dir_2(&self) -> PB_DIR_2_R {
                PB_DIR_2_R::new(((self.bits >> 16) & 0xff) as u8)
            }
        }
        impl W {
            ///Bits 0:7 - GPIO PB I/O direction byte 0
            #[inline(always)]
            #[must_use]
            pub fn pb_dir_0(&mut self) -> PB_DIR_0_W<PB_DIR_SPEC> {
                PB_DIR_0_W::new(self, 0)
            }
            ///Bits 8:15 - GPIO PB I/O direction byte 1
            #[inline(always)]
            #[must_use]
            pub fn pb_dir_1(&mut self) -> PB_DIR_1_W<PB_DIR_SPEC> {
                PB_DIR_1_W::new(self, 8)
            }
            ///Bits 16:23 - GPIO PB I/O direction byte 2
            #[inline(always)]
            #[must_use]
            pub fn pb_dir_2(&mut self) -> PB_DIR_2_W<PB_DIR_SPEC> {
                PB_DIR_2_W::new(self, 16)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW, GPIO PB I/O direction: 0=in, 1=out
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`pb_dir::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pb_dir::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct PB_DIR_SPEC;
        impl crate::RegisterSpec for PB_DIR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`pb_dir::R`](R) reader structure
        impl crate::Readable for PB_DIR_SPEC {}
        ///`write(|w| ..)` method takes [`pb_dir::W`](W) writer structure
        impl crate::Writable for PB_DIR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets PB_DIR to value 0
        impl crate::Resettable for PB_DIR_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///PB_PIN (r) register accessor: RO, GPIO PB input
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`pb_pin::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@pb_pin`]
    ///module
    pub type PB_PIN = crate::Reg<pb_pin::PB_PIN_SPEC>;
    ///RO, GPIO PB input
    pub mod pb_pin {
        ///Register `PB_PIN` reader
        pub type R = crate::R<PB_PIN_SPEC>;
        ///Field `PB_PIN_0` reader - GPIO PB input byte 0
        pub type PB_PIN_0_R = crate::FieldReader;
        ///Field `PB_PIN_1` reader - GPIO PB input byte 1
        pub type PB_PIN_1_R = crate::FieldReader;
        ///Field `PB_PIN_2` reader - GPIO PB input byte 2
        pub type PB_PIN_2_R = crate::FieldReader;
        impl R {
            ///Bits 0:7 - GPIO PB input byte 0
            #[inline(always)]
            pub fn pb_pin_0(&self) -> PB_PIN_0_R {
                PB_PIN_0_R::new((self.bits & 0xff) as u8)
            }
            ///Bits 8:15 - GPIO PB input byte 1
            #[inline(always)]
            pub fn pb_pin_1(&self) -> PB_PIN_1_R {
                PB_PIN_1_R::new(((self.bits >> 8) & 0xff) as u8)
            }
            ///Bits 16:23 - GPIO PB input byte 2
            #[inline(always)]
            pub fn pb_pin_2(&self) -> PB_PIN_2_R {
                PB_PIN_2_R::new(((self.bits >> 16) & 0xff) as u8)
            }
        }
        ///RO, GPIO PB input
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`pb_pin::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct PB_PIN_SPEC;
        impl crate::RegisterSpec for PB_PIN_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`pb_pin::R`](R) reader structure
        impl crate::Readable for PB_PIN_SPEC {}
        ///`reset()` method sets PB_PIN to value 0
        impl crate::Resettable for PB_PIN_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///PB_OUT__R8_SLV_RD_DATA (rw) register accessor: RW, GPIO PB output;RW, data for parallel slave read
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`pb_out__r8_slv_rd_data::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pb_out__r8_slv_rd_data::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@pb_out__r8_slv_rd_data`]
    ///module
    pub type PB_OUT__R8_SLV_RD_DATA =
        crate::Reg<pb_out__r8_slv_rd_data::PB_OUT__R8_SLV_RD_DATA_SPEC>;
    ///RW, GPIO PB output;RW, data for parallel slave read
    pub mod pb_out__r8_slv_rd_data {
        ///Register `PB_OUT__R8_SLV_RD_DATA` reader
        pub type R = crate::R<PB_OUT__R8_SLV_RD_DATA_SPEC>;
        ///Register `PB_OUT__R8_SLV_RD_DATA` writer
        pub type W = crate::W<PB_OUT__R8_SLV_RD_DATA_SPEC>;
        ///Field `PB_OUT_0` reader - GPIO PB output byte 0
        pub type PB_OUT_0_R = crate::FieldReader;
        ///Field `PB_OUT_0` writer - GPIO PB output byte 0
        pub type PB_OUT_0_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        ///Field `PB_OUT_1` reader - GPIO PB output byte 1
        pub type PB_OUT_1_R = crate::FieldReader;
        ///Field `PB_OUT_1` writer - GPIO PB output byte 1
        pub type PB_OUT_1_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        ///Field `PB_OUT_2` reader - GPIO PB output byte 2
        pub type PB_OUT_2_R = crate::FieldReader;
        ///Field `PB_OUT_2` writer - GPIO PB output byte 2
        pub type PB_OUT_2_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            ///Bits 0:7 - GPIO PB output byte 0
            #[inline(always)]
            pub fn pb_out_0(&self) -> PB_OUT_0_R {
                PB_OUT_0_R::new((self.bits & 0xff) as u8)
            }
            ///Bits 8:15 - GPIO PB output byte 1
            #[inline(always)]
            pub fn pb_out_1(&self) -> PB_OUT_1_R {
                PB_OUT_1_R::new(((self.bits >> 8) & 0xff) as u8)
            }
            ///Bits 16:23 - GPIO PB output byte 2
            #[inline(always)]
            pub fn pb_out_2(&self) -> PB_OUT_2_R {
                PB_OUT_2_R::new(((self.bits >> 16) & 0xff) as u8)
            }
        }
        impl W {
            ///Bits 0:7 - GPIO PB output byte 0
            #[inline(always)]
            #[must_use]
            pub fn pb_out_0(&mut self) -> PB_OUT_0_W<PB_OUT__R8_SLV_RD_DATA_SPEC> {
                PB_OUT_0_W::new(self, 0)
            }
            ///Bits 8:15 - GPIO PB output byte 1
            #[inline(always)]
            #[must_use]
            pub fn pb_out_1(&mut self) -> PB_OUT_1_W<PB_OUT__R8_SLV_RD_DATA_SPEC> {
                PB_OUT_1_W::new(self, 8)
            }
            ///Bits 16:23 - GPIO PB output byte 2
            #[inline(always)]
            #[must_use]
            pub fn pb_out_2(&mut self) -> PB_OUT_2_W<PB_OUT__R8_SLV_RD_DATA_SPEC> {
                PB_OUT_2_W::new(self, 16)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW, GPIO PB output;RW, data for parallel slave read
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`pb_out__r8_slv_rd_data::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pb_out__r8_slv_rd_data::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct PB_OUT__R8_SLV_RD_DATA_SPEC;
        impl crate::RegisterSpec for PB_OUT__R8_SLV_RD_DATA_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`pb_out__r8_slv_rd_data::R`](R) reader structure
        impl crate::Readable for PB_OUT__R8_SLV_RD_DATA_SPEC {}
        ///`write(|w| ..)` method takes [`pb_out__r8_slv_rd_data::W`](W) writer structure
        impl crate::Writable for PB_OUT__R8_SLV_RD_DATA_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets PB_OUT__R8_SLV_RD_DATA to value 0
        impl crate::Resettable for PB_OUT__R8_SLV_RD_DATA_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///PB_CLR (rw) register accessor: WZ, GPIO PB clear output: 0=keep, 1=clear
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`pb_clr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pb_clr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@pb_clr`]
    ///module
    pub type PB_CLR = crate::Reg<pb_clr::PB_CLR_SPEC>;
    ///WZ, GPIO PB clear output: 0=keep, 1=clear
    pub mod pb_clr {
        ///Register `PB_CLR` reader
        pub type R = crate::R<PB_CLR_SPEC>;
        ///Register `PB_CLR` writer
        pub type W = crate::W<PB_CLR_SPEC>;
        ///Field `PB_CLR_0` reader - GPIO PB clear output byte 0
        pub type PB_CLR_0_R = crate::FieldReader;
        ///Field `PB_CLR_0` writer - GPIO PB clear output byte 0
        pub type PB_CLR_0_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        ///Field `PB_CLR_1` reader - GPIO PB clear output byte 1
        pub type PB_CLR_1_R = crate::FieldReader;
        ///Field `PB_CLR_1` writer - GPIO PB clear output byte 1
        pub type PB_CLR_1_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        ///Field `PB_CLR_2` reader - GPIO PB clear output byte 2
        pub type PB_CLR_2_R = crate::FieldReader;
        ///Field `PB_CLR_2` writer - GPIO PB clear output byte 2
        pub type PB_CLR_2_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            ///Bits 0:7 - GPIO PB clear output byte 0
            #[inline(always)]
            pub fn pb_clr_0(&self) -> PB_CLR_0_R {
                PB_CLR_0_R::new((self.bits & 0xff) as u8)
            }
            ///Bits 8:15 - GPIO PB clear output byte 1
            #[inline(always)]
            pub fn pb_clr_1(&self) -> PB_CLR_1_R {
                PB_CLR_1_R::new(((self.bits >> 8) & 0xff) as u8)
            }
            ///Bits 16:23 - GPIO PB clear output byte 2
            #[inline(always)]
            pub fn pb_clr_2(&self) -> PB_CLR_2_R {
                PB_CLR_2_R::new(((self.bits >> 16) & 0xff) as u8)
            }
        }
        impl W {
            ///Bits 0:7 - GPIO PB clear output byte 0
            #[inline(always)]
            #[must_use]
            pub fn pb_clr_0(&mut self) -> PB_CLR_0_W<PB_CLR_SPEC> {
                PB_CLR_0_W::new(self, 0)
            }
            ///Bits 8:15 - GPIO PB clear output byte 1
            #[inline(always)]
            #[must_use]
            pub fn pb_clr_1(&mut self) -> PB_CLR_1_W<PB_CLR_SPEC> {
                PB_CLR_1_W::new(self, 8)
            }
            ///Bits 16:23 - GPIO PB clear output byte 2
            #[inline(always)]
            #[must_use]
            pub fn pb_clr_2(&mut self) -> PB_CLR_2_W<PB_CLR_SPEC> {
                PB_CLR_2_W::new(self, 16)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///WZ, GPIO PB clear output: 0=keep, 1=clear
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`pb_clr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pb_clr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct PB_CLR_SPEC;
        impl crate::RegisterSpec for PB_CLR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`pb_clr::R`](R) reader structure
        impl crate::Readable for PB_CLR_SPEC {}
        ///`write(|w| ..)` method takes [`pb_clr::W`](W) writer structure
        impl crate::Writable for PB_CLR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets PB_CLR to value 0
        impl crate::Resettable for PB_CLR_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///PB_PU (rw) register accessor: RW, GPIO PB pullup resistance enable
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`pb_pu::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pb_pu::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@pb_pu`]
    ///module
    pub type PB_PU = crate::Reg<pb_pu::PB_PU_SPEC>;
    ///RW, GPIO PB pullup resistance enable
    pub mod pb_pu {
        ///Register `PB_PU` reader
        pub type R = crate::R<PB_PU_SPEC>;
        ///Register `PB_PU` writer
        pub type W = crate::W<PB_PU_SPEC>;
        ///Field `PB_PU_0` reader - GPIO PB pullup resistance enable byte 0
        pub type PB_PU_0_R = crate::FieldReader;
        ///Field `PB_PU_0` writer - GPIO PB pullup resistance enable byte 0
        pub type PB_PU_0_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        ///Field `PB_PU_1` reader - GPIO PB pullup resistance enable byte 1
        pub type PB_PU_1_R = crate::FieldReader;
        ///Field `PB_PU_1` writer - GPIO PB pullup resistance enable byte 1
        pub type PB_PU_1_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        ///Field `PB_PU_2` reader - GPIO PB pullup resistance enable byte 2
        pub type PB_PU_2_R = crate::FieldReader;
        ///Field `PB_PU_2` writer - GPIO PB pullup resistance enable byte 2
        pub type PB_PU_2_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            ///Bits 0:7 - GPIO PB pullup resistance enable byte 0
            #[inline(always)]
            pub fn pb_pu_0(&self) -> PB_PU_0_R {
                PB_PU_0_R::new((self.bits & 0xff) as u8)
            }
            ///Bits 8:15 - GPIO PB pullup resistance enable byte 1
            #[inline(always)]
            pub fn pb_pu_1(&self) -> PB_PU_1_R {
                PB_PU_1_R::new(((self.bits >> 8) & 0xff) as u8)
            }
            ///Bits 16:23 - GPIO PB pullup resistance enable byte 2
            #[inline(always)]
            pub fn pb_pu_2(&self) -> PB_PU_2_R {
                PB_PU_2_R::new(((self.bits >> 16) & 0xff) as u8)
            }
        }
        impl W {
            ///Bits 0:7 - GPIO PB pullup resistance enable byte 0
            #[inline(always)]
            #[must_use]
            pub fn pb_pu_0(&mut self) -> PB_PU_0_W<PB_PU_SPEC> {
                PB_PU_0_W::new(self, 0)
            }
            ///Bits 8:15 - GPIO PB pullup resistance enable byte 1
            #[inline(always)]
            #[must_use]
            pub fn pb_pu_1(&mut self) -> PB_PU_1_W<PB_PU_SPEC> {
                PB_PU_1_W::new(self, 8)
            }
            ///Bits 16:23 - GPIO PB pullup resistance enable byte 2
            #[inline(always)]
            #[must_use]
            pub fn pb_pu_2(&mut self) -> PB_PU_2_W<PB_PU_SPEC> {
                PB_PU_2_W::new(self, 16)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW, GPIO PB pullup resistance enable
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`pb_pu::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pb_pu::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct PB_PU_SPEC;
        impl crate::RegisterSpec for PB_PU_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`pb_pu::R`](R) reader structure
        impl crate::Readable for PB_PU_SPEC {}
        ///`write(|w| ..)` method takes [`pb_pu::W`](W) writer structure
        impl crate::Writable for PB_PU_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets PB_PU to value 0
        impl crate::Resettable for PB_PU_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///PB_PD_DRV (rw) register accessor: RW, PB pulldown for input or PB driving capability for output
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`pb_pd_drv::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pb_pd_drv::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@pb_pd_drv`]
    ///module
    pub type PB_PD_DRV = crate::Reg<pb_pd_drv::PB_PD_DRV_SPEC>;
    ///RW, PB pulldown for input or PB driving capability for output
    pub mod pb_pd_drv {
        ///Register `PB_PD_DRV` reader
        pub type R = crate::R<PB_PD_DRV_SPEC>;
        ///Register `PB_PD_DRV` writer
        pub type W = crate::W<PB_PD_DRV_SPEC>;
        ///Field `PB_PD_DRV_0` reader - PB pulldown for input or PB driving capability for output byte 0
        pub type PB_PD_DRV_0_R = crate::FieldReader;
        ///Field `PB_PD_DRV_0` writer - PB pulldown for input or PB driving capability for output byte 0
        pub type PB_PD_DRV_0_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        ///Field `PB_PD_DRV_1` reader - PB pulldown for input or PB driving capability for output byte 0
        pub type PB_PD_DRV_1_R = crate::FieldReader;
        ///Field `PB_PD_DRV_1` writer - PB pulldown for input or PB driving capability for output byte 0
        pub type PB_PD_DRV_1_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        ///Field `PB_PD_DRV_2` reader - PB pulldown for input or PB driving capability for output byte 0
        pub type PB_PD_DRV_2_R = crate::FieldReader;
        ///Field `PB_PD_DRV_2` writer - PB pulldown for input or PB driving capability for output byte 0
        pub type PB_PD_DRV_2_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            ///Bits 0:7 - PB pulldown for input or PB driving capability for output byte 0
            #[inline(always)]
            pub fn pb_pd_drv_0(&self) -> PB_PD_DRV_0_R {
                PB_PD_DRV_0_R::new((self.bits & 0xff) as u8)
            }
            ///Bits 8:15 - PB pulldown for input or PB driving capability for output byte 0
            #[inline(always)]
            pub fn pb_pd_drv_1(&self) -> PB_PD_DRV_1_R {
                PB_PD_DRV_1_R::new(((self.bits >> 8) & 0xff) as u8)
            }
            ///Bits 16:23 - PB pulldown for input or PB driving capability for output byte 0
            #[inline(always)]
            pub fn pb_pd_drv_2(&self) -> PB_PD_DRV_2_R {
                PB_PD_DRV_2_R::new(((self.bits >> 16) & 0xff) as u8)
            }
        }
        impl W {
            ///Bits 0:7 - PB pulldown for input or PB driving capability for output byte 0
            #[inline(always)]
            #[must_use]
            pub fn pb_pd_drv_0(&mut self) -> PB_PD_DRV_0_W<PB_PD_DRV_SPEC> {
                PB_PD_DRV_0_W::new(self, 0)
            }
            ///Bits 8:15 - PB pulldown for input or PB driving capability for output byte 0
            #[inline(always)]
            #[must_use]
            pub fn pb_pd_drv_1(&mut self) -> PB_PD_DRV_1_W<PB_PD_DRV_SPEC> {
                PB_PD_DRV_1_W::new(self, 8)
            }
            ///Bits 16:23 - PB pulldown for input or PB driving capability for output byte 0
            #[inline(always)]
            #[must_use]
            pub fn pb_pd_drv_2(&mut self) -> PB_PD_DRV_2_W<PB_PD_DRV_SPEC> {
                PB_PD_DRV_2_W::new(self, 16)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW, PB pulldown for input or PB driving capability for output
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`pb_pd_drv::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pb_pd_drv::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct PB_PD_DRV_SPEC;
        impl crate::RegisterSpec for PB_PD_DRV_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`pb_pd_drv::R`](R) reader structure
        impl crate::Readable for PB_PD_DRV_SPEC {}
        ///`write(|w| ..)` method takes [`pb_pd_drv::W`](W) writer structure
        impl crate::Writable for PB_PD_DRV_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets PB_PD_DRV to value 0
        impl crate::Resettable for PB_PD_DRV_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
}
///Timer0 register
pub struct TMR0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for TMR0 {}
impl TMR0 {
    ///Pointer to the register block
    pub const PTR: *const tmr0::RegisterBlock = 0x4000_2000 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const tmr0::RegisterBlock {
        Self::PTR
    }
    /// Steal an instance of this peripheral
    ///
    /// # Safety
    ///
    /// Ensure that the new instance of the peripheral cannot be used in a way
    /// that may race with any existing instances, for example by only
    /// accessing read-only or write-only registers, or by consuming the
    /// original peripheral and using critical sections to coordinate
    /// access between multiple new instances.
    ///
    /// Additionally, other software such as HALs may rely on only one
    /// peripheral instance existing to ensure memory safety; ensure
    /// no stolen instances are passed to such software.
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for TMR0 {
    type Target = tmr0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for TMR0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("TMR0").finish()
    }
}
///Timer0 register
pub mod tmr0 {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        ctrl_mod: CTRL_MOD,
        _reserved1: [u8; 0x01],
        inter_en: INTER_EN,
        _reserved2: [u8; 0x03],
        int_flag: INT_FLAG,
        fifo_count: FIFO_COUNT,
        count: COUNT,
        cnt_end: CNT_END,
        fifo: FIFO,
    }
    impl RegisterBlock {
        ///0x00 - RW, TMR0 mode control
        #[inline(always)]
        pub const fn ctrl_mod(&self) -> &CTRL_MOD {
            &self.ctrl_mod
        }
        ///0x02 - RW, TMR0 interrupt enable
        #[inline(always)]
        pub const fn inter_en(&self) -> &INTER_EN {
            &self.inter_en
        }
        ///0x06 - RW1, TMR0 interrupt flag
        #[inline(always)]
        pub const fn int_flag(&self) -> &INT_FLAG {
            &self.int_flag
        }
        ///0x07 - RO, TMR0 FIFO count status
        #[inline(always)]
        pub const fn fifo_count(&self) -> &FIFO_COUNT {
            &self.fifo_count
        }
        ///0x08 - RO, TMR0 current count
        #[inline(always)]
        pub const fn count(&self) -> &COUNT {
            &self.count
        }
        ///0x0c - RW, TMR0 end count value, only low 26 bit
        #[inline(always)]
        pub const fn cnt_end(&self) -> &CNT_END {
            &self.cnt_end
        }
        ///0x10 - RO/WO, TMR0 FIFO register, only low 26 bit
        #[inline(always)]
        pub const fn fifo(&self) -> &FIFO {
            &self.fifo
        }
    }
    ///CTRL_MOD (rw) register accessor: RW, TMR0 mode control
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`ctrl_mod::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ctrl_mod::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@ctrl_mod`]
    ///module
    pub type CTRL_MOD = crate::Reg<ctrl_mod::CTRL_MOD_SPEC>;
    ///RW, TMR0 mode control
    pub mod ctrl_mod {
        ///Register `CTRL_MOD` reader
        pub type R = crate::R<CTRL_MOD_SPEC>;
        ///Register `CTRL_MOD` writer
        pub type W = crate::W<CTRL_MOD_SPEC>;
        ///Field `TMR_MODE_IN` reader - RW, timer in mode: 0=timer/PWM, 1=capture/count
        pub type TMR_MODE_IN_R = crate::BitReader;
        ///Field `TMR_MODE_IN` writer - RW, timer in mode: 0=timer/PWM, 1=capture/count
        pub type TMR_MODE_IN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TMR_ALL_CLEAR` reader - RW, force clear timer FIFO and count
        pub type TMR_ALL_CLEAR_R = crate::BitReader;
        ///Field `TMR_ALL_CLEAR` writer - RW, force clear timer FIFO and count
        pub type TMR_ALL_CLEAR_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TMR_COUNT_EN` reader - RW, timer count enable
        pub type TMR_COUNT_EN_R = crate::BitReader;
        ///Field `TMR_COUNT_EN` writer - RW, timer count enable
        pub type TMR_COUNT_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TMR_OUT_EN` reader - RW, timer output enable
        pub type TMR_OUT_EN_R = crate::BitReader;
        ///Field `TMR_OUT_EN` writer - RW, timer output enable
        pub type TMR_OUT_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TMR_OUT_POLAR__RB_TMR_CAP_COUNT` reader - RW, timer PWM output polarity: 0=default low and high action, 1=default high and low action;RW, count sub-mode if RB_TMR_MODE_IN=1: 0=capture, 1=count
        pub type TMR_OUT_POLAR__RB_TMR_CAP_COUNT_R = crate::BitReader;
        ///Field `TMR_OUT_POLAR__RB_TMR_CAP_COUNT` writer - RW, timer PWM output polarity: 0=default low and high action, 1=default high and low action;RW, count sub-mode if RB_TMR_MODE_IN=1: 0=capture, 1=count
        pub type TMR_OUT_POLAR__RB_TMR_CAP_COUNT_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TMR_PWM_REPEAT__RB_TMR_CAP_EDGE` reader - RW, timer PWM repeat mode: 00=1, 01=4, 10=8, 11-16;RW, timer capture edge mode: 00=disable, 01=edge change, 10=fall to fall, 11-rise to rise
        pub type TMR_PWM_REPEAT__RB_TMR_CAP_EDGE_R = crate::FieldReader;
        ///Field `TMR_PWM_REPEAT__RB_TMR_CAP_EDGE` writer - RW, timer PWM repeat mode: 00=1, 01=4, 10=8, 11-16;RW, timer capture edge mode: 00=disable, 01=edge change, 10=fall to fall, 11-rise to rise
        pub type TMR_PWM_REPEAT__RB_TMR_CAP_EDGE_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        impl R {
            ///Bit 0 - RW, timer in mode: 0=timer/PWM, 1=capture/count
            #[inline(always)]
            pub fn tmr_mode_in(&self) -> TMR_MODE_IN_R {
                TMR_MODE_IN_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RW, force clear timer FIFO and count
            #[inline(always)]
            pub fn tmr_all_clear(&self) -> TMR_ALL_CLEAR_R {
                TMR_ALL_CLEAR_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RW, timer count enable
            #[inline(always)]
            pub fn tmr_count_en(&self) -> TMR_COUNT_EN_R {
                TMR_COUNT_EN_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RW, timer output enable
            #[inline(always)]
            pub fn tmr_out_en(&self) -> TMR_OUT_EN_R {
                TMR_OUT_EN_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RW, timer PWM output polarity: 0=default low and high action, 1=default high and low action;RW, count sub-mode if RB_TMR_MODE_IN=1: 0=capture, 1=count
            #[inline(always)]
            pub fn tmr_out_polar__rb_tmr_cap_count(&self) -> TMR_OUT_POLAR__RB_TMR_CAP_COUNT_R {
                TMR_OUT_POLAR__RB_TMR_CAP_COUNT_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bits 6:7 - RW, timer PWM repeat mode: 00=1, 01=4, 10=8, 11-16;RW, timer capture edge mode: 00=disable, 01=edge change, 10=fall to fall, 11-rise to rise
            #[inline(always)]
            pub fn tmr_pwm_repeat__rb_tmr_cap_edge(&self) -> TMR_PWM_REPEAT__RB_TMR_CAP_EDGE_R {
                TMR_PWM_REPEAT__RB_TMR_CAP_EDGE_R::new((self.bits >> 6) & 3)
            }
        }
        impl W {
            ///Bit 0 - RW, timer in mode: 0=timer/PWM, 1=capture/count
            #[inline(always)]
            #[must_use]
            pub fn tmr_mode_in(&mut self) -> TMR_MODE_IN_W<CTRL_MOD_SPEC> {
                TMR_MODE_IN_W::new(self, 0)
            }
            ///Bit 1 - RW, force clear timer FIFO and count
            #[inline(always)]
            #[must_use]
            pub fn tmr_all_clear(&mut self) -> TMR_ALL_CLEAR_W<CTRL_MOD_SPEC> {
                TMR_ALL_CLEAR_W::new(self, 1)
            }
            ///Bit 2 - RW, timer count enable
            #[inline(always)]
            #[must_use]
            pub fn tmr_count_en(&mut self) -> TMR_COUNT_EN_W<CTRL_MOD_SPEC> {
                TMR_COUNT_EN_W::new(self, 2)
            }
            ///Bit 3 - RW, timer output enable
            #[inline(always)]
            #[must_use]
            pub fn tmr_out_en(&mut self) -> TMR_OUT_EN_W<CTRL_MOD_SPEC> {
                TMR_OUT_EN_W::new(self, 3)
            }
            ///Bit 4 - RW, timer PWM output polarity: 0=default low and high action, 1=default high and low action;RW, count sub-mode if RB_TMR_MODE_IN=1: 0=capture, 1=count
            #[inline(always)]
            #[must_use]
            pub fn tmr_out_polar__rb_tmr_cap_count(
                &mut self,
            ) -> TMR_OUT_POLAR__RB_TMR_CAP_COUNT_W<CTRL_MOD_SPEC> {
                TMR_OUT_POLAR__RB_TMR_CAP_COUNT_W::new(self, 4)
            }
            ///Bits 6:7 - RW, timer PWM repeat mode: 00=1, 01=4, 10=8, 11-16;RW, timer capture edge mode: 00=disable, 01=edge change, 10=fall to fall, 11-rise to rise
            #[inline(always)]
            #[must_use]
            pub fn tmr_pwm_repeat__rb_tmr_cap_edge(
                &mut self,
            ) -> TMR_PWM_REPEAT__RB_TMR_CAP_EDGE_W<CTRL_MOD_SPEC> {
                TMR_PWM_REPEAT__RB_TMR_CAP_EDGE_W::new(self, 6)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW, TMR0 mode control
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`ctrl_mod::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ctrl_mod::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct CTRL_MOD_SPEC;
        impl crate::RegisterSpec for CTRL_MOD_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`ctrl_mod::R`](R) reader structure
        impl crate::Readable for CTRL_MOD_SPEC {}
        ///`write(|w| ..)` method takes [`ctrl_mod::W`](W) writer structure
        impl crate::Writable for CTRL_MOD_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets CTRL_MOD to value 0x02
        impl crate::Resettable for CTRL_MOD_SPEC {
            const RESET_VALUE: u8 = 0x02;
        }
    }
    ///INTER_EN (rw) register accessor: RW, TMR0 interrupt enable
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`inter_en::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`inter_en::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@inter_en`]
    ///module
    pub type INTER_EN = crate::Reg<inter_en::INTER_EN_SPEC>;
    ///RW, TMR0 interrupt enable
    pub mod inter_en {
        ///Register `INTER_EN` reader
        pub type R = crate::R<INTER_EN_SPEC>;
        ///Register `INTER_EN` writer
        pub type W = crate::W<INTER_EN_SPEC>;
        ///Field `TMR_IE_CYC_END` reader - RW, enable interrupt for timer capture count timeout or PWM cycle end
        pub type TMR_IE_CYC_END_R = crate::BitReader;
        ///Field `TMR_IE_CYC_END` writer - RW, enable interrupt for timer capture count timeout or PWM cycle end
        pub type TMR_IE_CYC_END_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TMR_IE_DATA_ACT` reader - RW, enable interrupt for timer capture input action or PWM trigger
        pub type TMR_IE_DATA_ACT_R = crate::BitReader;
        ///Field `TMR_IE_DATA_ACT` writer - RW, enable interrupt for timer capture input action or PWM trigger
        pub type TMR_IE_DATA_ACT_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TMR_IE_FIFO_HF` reader - RW, enable interrupt for timer FIFO half (capture fifo >=4 or PWM fifo less than 3)
        pub type TMR_IE_FIFO_HF_R = crate::BitReader;
        ///Field `TMR_IE_FIFO_HF` writer - RW, enable interrupt for timer FIFO half (capture fifo >=4 or PWM fifo less than 3)
        pub type TMR_IE_FIFO_HF_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TMR_IE_DMA_END` reader - RW, enable interrupt for timer1/2 DMA completion
        pub type TMR_IE_DMA_END_R = crate::BitReader;
        ///Field `TMR_IE_DMA_END` writer - RW, enable interrupt for timer1/2 DMA completion
        pub type TMR_IE_DMA_END_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TMR_IE_FIFO_OV` reader - RW, enable interrupt for timer FIFO overflow
        pub type TMR_IE_FIFO_OV_R = crate::BitReader;
        ///Field `TMR_IE_FIFO_OV` writer - RW, enable interrupt for timer FIFO overflow
        pub type TMR_IE_FIFO_OV_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - RW, enable interrupt for timer capture count timeout or PWM cycle end
            #[inline(always)]
            pub fn tmr_ie_cyc_end(&self) -> TMR_IE_CYC_END_R {
                TMR_IE_CYC_END_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RW, enable interrupt for timer capture input action or PWM trigger
            #[inline(always)]
            pub fn tmr_ie_data_act(&self) -> TMR_IE_DATA_ACT_R {
                TMR_IE_DATA_ACT_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RW, enable interrupt for timer FIFO half (capture fifo >=4 or PWM fifo less than 3)
            #[inline(always)]
            pub fn tmr_ie_fifo_hf(&self) -> TMR_IE_FIFO_HF_R {
                TMR_IE_FIFO_HF_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RW, enable interrupt for timer1/2 DMA completion
            #[inline(always)]
            pub fn tmr_ie_dma_end(&self) -> TMR_IE_DMA_END_R {
                TMR_IE_DMA_END_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RW, enable interrupt for timer FIFO overflow
            #[inline(always)]
            pub fn tmr_ie_fifo_ov(&self) -> TMR_IE_FIFO_OV_R {
                TMR_IE_FIFO_OV_R::new(((self.bits >> 4) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RW, enable interrupt for timer capture count timeout or PWM cycle end
            #[inline(always)]
            #[must_use]
            pub fn tmr_ie_cyc_end(&mut self) -> TMR_IE_CYC_END_W<INTER_EN_SPEC> {
                TMR_IE_CYC_END_W::new(self, 0)
            }
            ///Bit 1 - RW, enable interrupt for timer capture input action or PWM trigger
            #[inline(always)]
            #[must_use]
            pub fn tmr_ie_data_act(&mut self) -> TMR_IE_DATA_ACT_W<INTER_EN_SPEC> {
                TMR_IE_DATA_ACT_W::new(self, 1)
            }
            ///Bit 2 - RW, enable interrupt for timer FIFO half (capture fifo >=4 or PWM fifo less than 3)
            #[inline(always)]
            #[must_use]
            pub fn tmr_ie_fifo_hf(&mut self) -> TMR_IE_FIFO_HF_W<INTER_EN_SPEC> {
                TMR_IE_FIFO_HF_W::new(self, 2)
            }
            ///Bit 3 - RW, enable interrupt for timer1/2 DMA completion
            #[inline(always)]
            #[must_use]
            pub fn tmr_ie_dma_end(&mut self) -> TMR_IE_DMA_END_W<INTER_EN_SPEC> {
                TMR_IE_DMA_END_W::new(self, 3)
            }
            ///Bit 4 - RW, enable interrupt for timer FIFO overflow
            #[inline(always)]
            #[must_use]
            pub fn tmr_ie_fifo_ov(&mut self) -> TMR_IE_FIFO_OV_W<INTER_EN_SPEC> {
                TMR_IE_FIFO_OV_W::new(self, 4)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW, TMR0 interrupt enable
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`inter_en::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`inter_en::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct INTER_EN_SPEC;
        impl crate::RegisterSpec for INTER_EN_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`inter_en::R`](R) reader structure
        impl crate::Readable for INTER_EN_SPEC {}
        ///`write(|w| ..)` method takes [`inter_en::W`](W) writer structure
        impl crate::Writable for INTER_EN_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets INTER_EN to value 0
        impl crate::Resettable for INTER_EN_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///INT_FLAG (rw) register accessor: RW1, TMR0 interrupt flag
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`int_flag::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`int_flag::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@int_flag`]
    ///module
    pub type INT_FLAG = crate::Reg<int_flag::INT_FLAG_SPEC>;
    ///RW1, TMR0 interrupt flag
    pub mod int_flag {
        ///Register `INT_FLAG` reader
        pub type R = crate::R<INT_FLAG_SPEC>;
        ///Register `INT_FLAG` writer
        pub type W = crate::W<INT_FLAG_SPEC>;
        ///Field `TMR_IF_CYC_END` reader - RW1, interrupt flag for timer capture count timeout or PWM cycle end
        pub type TMR_IF_CYC_END_R = crate::BitReader;
        ///Field `TMR_IF_CYC_END` writer - RW1, interrupt flag for timer capture count timeout or PWM cycle end
        pub type TMR_IF_CYC_END_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TMR_IF_DATA_ACT` reader - RW1, interrupt flag for timer capture input action or PWM trigger
        pub type TMR_IF_DATA_ACT_R = crate::BitReader;
        ///Field `TMR_IF_DATA_ACT` writer - RW1, interrupt flag for timer capture input action or PWM trigger
        pub type TMR_IF_DATA_ACT_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TMR_IF_FIFO_HF` reader - RW1, interrupt flag for timer FIFO half (capture fifo >=4 or PWM fifo less than 3
        pub type TMR_IF_FIFO_HF_R = crate::BitReader;
        ///Field `TMR_IF_FIFO_HF` writer - RW1, interrupt flag for timer FIFO half (capture fifo >=4 or PWM fifo less than 3
        pub type TMR_IF_FIFO_HF_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TMR_IF_DMA_END` reader - RW1, interrupt flag for timer1/2 DMA completion
        pub type TMR_IF_DMA_END_R = crate::BitReader;
        ///Field `TMR_IF_DMA_END` writer - RW1, interrupt flag for timer1/2 DMA completion
        pub type TMR_IF_DMA_END_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TMR_IF_FIFO_OV` reader - RW1, interrupt flag for timer FIFO overflow
        pub type TMR_IF_FIFO_OV_R = crate::BitReader;
        ///Field `TMR_IF_FIFO_OV` writer - RW1, interrupt flag for timer FIFO overflow
        pub type TMR_IF_FIFO_OV_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - RW1, interrupt flag for timer capture count timeout or PWM cycle end
            #[inline(always)]
            pub fn tmr_if_cyc_end(&self) -> TMR_IF_CYC_END_R {
                TMR_IF_CYC_END_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RW1, interrupt flag for timer capture input action or PWM trigger
            #[inline(always)]
            pub fn tmr_if_data_act(&self) -> TMR_IF_DATA_ACT_R {
                TMR_IF_DATA_ACT_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RW1, interrupt flag for timer FIFO half (capture fifo >=4 or PWM fifo less than 3
            #[inline(always)]
            pub fn tmr_if_fifo_hf(&self) -> TMR_IF_FIFO_HF_R {
                TMR_IF_FIFO_HF_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RW1, interrupt flag for timer1/2 DMA completion
            #[inline(always)]
            pub fn tmr_if_dma_end(&self) -> TMR_IF_DMA_END_R {
                TMR_IF_DMA_END_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RW1, interrupt flag for timer FIFO overflow
            #[inline(always)]
            pub fn tmr_if_fifo_ov(&self) -> TMR_IF_FIFO_OV_R {
                TMR_IF_FIFO_OV_R::new(((self.bits >> 4) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RW1, interrupt flag for timer capture count timeout or PWM cycle end
            #[inline(always)]
            #[must_use]
            pub fn tmr_if_cyc_end(&mut self) -> TMR_IF_CYC_END_W<INT_FLAG_SPEC> {
                TMR_IF_CYC_END_W::new(self, 0)
            }
            ///Bit 1 - RW1, interrupt flag for timer capture input action or PWM trigger
            #[inline(always)]
            #[must_use]
            pub fn tmr_if_data_act(&mut self) -> TMR_IF_DATA_ACT_W<INT_FLAG_SPEC> {
                TMR_IF_DATA_ACT_W::new(self, 1)
            }
            ///Bit 2 - RW1, interrupt flag for timer FIFO half (capture fifo >=4 or PWM fifo less than 3
            #[inline(always)]
            #[must_use]
            pub fn tmr_if_fifo_hf(&mut self) -> TMR_IF_FIFO_HF_W<INT_FLAG_SPEC> {
                TMR_IF_FIFO_HF_W::new(self, 2)
            }
            ///Bit 3 - RW1, interrupt flag for timer1/2 DMA completion
            #[inline(always)]
            #[must_use]
            pub fn tmr_if_dma_end(&mut self) -> TMR_IF_DMA_END_W<INT_FLAG_SPEC> {
                TMR_IF_DMA_END_W::new(self, 3)
            }
            ///Bit 4 - RW1, interrupt flag for timer FIFO overflow
            #[inline(always)]
            #[must_use]
            pub fn tmr_if_fifo_ov(&mut self) -> TMR_IF_FIFO_OV_W<INT_FLAG_SPEC> {
                TMR_IF_FIFO_OV_W::new(self, 4)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW1, TMR0 interrupt flag
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`int_flag::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`int_flag::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct INT_FLAG_SPEC;
        impl crate::RegisterSpec for INT_FLAG_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`int_flag::R`](R) reader structure
        impl crate::Readable for INT_FLAG_SPEC {}
        ///`write(|w| ..)` method takes [`int_flag::W`](W) writer structure
        impl crate::Writable for INT_FLAG_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets INT_FLAG to value 0
        impl crate::Resettable for INT_FLAG_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///FIFO_COUNT (r) register accessor: RO, TMR0 FIFO count status
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`fifo_count::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@fifo_count`]
    ///module
    pub type FIFO_COUNT = crate::Reg<fifo_count::FIFO_COUNT_SPEC>;
    ///RO, TMR0 FIFO count status
    pub mod fifo_count {
        ///Register `FIFO_COUNT` reader
        pub type R = crate::R<FIFO_COUNT_SPEC>;
        ///Field `FIFO_COUNT` reader - RW1,TMR0 FIFO count status
        pub type FIFO_COUNT_R = crate::FieldReader;
        impl R {
            ///Bits 0:7 - RW1,TMR0 FIFO count status
            #[inline(always)]
            pub fn fifo_count(&self) -> FIFO_COUNT_R {
                FIFO_COUNT_R::new(self.bits)
            }
        }
        ///RO, TMR0 FIFO count status
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`fifo_count::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct FIFO_COUNT_SPEC;
        impl crate::RegisterSpec for FIFO_COUNT_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`fifo_count::R`](R) reader structure
        impl crate::Readable for FIFO_COUNT_SPEC {}
        ///`reset()` method sets FIFO_COUNT to value 0
        impl crate::Resettable for FIFO_COUNT_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///COUNT (r) register accessor: RO, TMR0 current count
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`count::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@count`]
    ///module
    pub type COUNT = crate::Reg<count::COUNT_SPEC>;
    ///RO, TMR0 current count
    pub mod count {
        ///Register `COUNT` reader
        pub type R = crate::R<COUNT_SPEC>;
        ///Field `COUNT` reader - RW1,TMR0 current count
        pub type COUNT_R = crate::FieldReader<u32>;
        impl R {
            ///Bits 0:31 - RW1,TMR0 current count
            #[inline(always)]
            pub fn count(&self) -> COUNT_R {
                COUNT_R::new(self.bits)
            }
        }
        ///RO, TMR0 current count
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`count::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct COUNT_SPEC;
        impl crate::RegisterSpec for COUNT_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`count::R`](R) reader structure
        impl crate::Readable for COUNT_SPEC {}
        ///`reset()` method sets COUNT to value 0
        impl crate::Resettable for COUNT_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///CNT_END (rw) register accessor: RW, TMR0 end count value, only low 26 bit
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`cnt_end::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cnt_end::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@cnt_end`]
    ///module
    pub type CNT_END = crate::Reg<cnt_end::CNT_END_SPEC>;
    ///RW, TMR0 end count value, only low 26 bit
    pub mod cnt_end {
        ///Register `CNT_END` reader
        pub type R = crate::R<CNT_END_SPEC>;
        ///Register `CNT_END` writer
        pub type W = crate::W<CNT_END_SPEC>;
        ///Field `CNT_END` reader - RW1,TMR0 end count value
        pub type CNT_END_R = crate::FieldReader<u32>;
        ///Field `CNT_END` writer - RW1,TMR0 end count value
        pub type CNT_END_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - RW1,TMR0 end count value
            #[inline(always)]
            pub fn cnt_end(&self) -> CNT_END_R {
                CNT_END_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW1,TMR0 end count value
            #[inline(always)]
            #[must_use]
            pub fn cnt_end(&mut self) -> CNT_END_W<CNT_END_SPEC> {
                CNT_END_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW, TMR0 end count value, only low 26 bit
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`cnt_end::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cnt_end::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct CNT_END_SPEC;
        impl crate::RegisterSpec for CNT_END_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`cnt_end::R`](R) reader structure
        impl crate::Readable for CNT_END_SPEC {}
        ///`write(|w| ..)` method takes [`cnt_end::W`](W) writer structure
        impl crate::Writable for CNT_END_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets CNT_END to value 0
        impl crate::Resettable for CNT_END_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///FIFO (r) register accessor: RO/WO, TMR0 FIFO register, only low 26 bit
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`fifo::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@fifo`]
    ///module
    pub type FIFO = crate::Reg<fifo::FIFO_SPEC>;
    ///RO/WO, TMR0 FIFO register, only low 26 bit
    pub mod fifo {
        ///Register `FIFO` reader
        pub type R = crate::R<FIFO_SPEC>;
        ///Field `FIFO` reader - RW1,TMR0 FIFO register
        pub type FIFO_R = crate::FieldReader<u32>;
        impl R {
            ///Bits 0:31 - RW1,TMR0 FIFO register
            #[inline(always)]
            pub fn fifo(&self) -> FIFO_R {
                FIFO_R::new(self.bits)
            }
        }
        ///RO/WO, TMR0 FIFO register, only low 26 bit
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`fifo::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct FIFO_SPEC;
        impl crate::RegisterSpec for FIFO_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`fifo::R`](R) reader structure
        impl crate::Readable for FIFO_SPEC {}
        ///`reset()` method sets FIFO to value 0
        impl crate::Resettable for FIFO_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
}
///Timer1 register
pub struct TMR1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for TMR1 {}
impl TMR1 {
    ///Pointer to the register block
    pub const PTR: *const tmr1::RegisterBlock = 0x4000_2400 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const tmr1::RegisterBlock {
        Self::PTR
    }
    /// Steal an instance of this peripheral
    ///
    /// # Safety
    ///
    /// Ensure that the new instance of the peripheral cannot be used in a way
    /// that may race with any existing instances, for example by only
    /// accessing read-only or write-only registers, or by consuming the
    /// original peripheral and using critical sections to coordinate
    /// access between multiple new instances.
    ///
    /// Additionally, other software such as HALs may rely on only one
    /// peripheral instance existing to ensure memory safety; ensure
    /// no stolen instances are passed to such software.
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for TMR1 {
    type Target = tmr1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for TMR1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("TMR1").finish()
    }
}
///Timer1 register
pub mod tmr1 {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        ctrl_mod: CTRL_MOD,
        ctrl_dma: CTRL_DMA,
        inter_en: INTER_EN,
        _reserved3: [u8; 0x03],
        int_flag: INT_FLAG,
        fifo_count: FIFO_COUNT,
        count: COUNT,
        cnt_end: CNT_END,
        fifo: FIFO,
        dma_now: DMA_NOW,
        _reserved9: [u8; 0x02],
        dma_beg: DMA_BEG,
        _reserved10: [u8; 0x02],
        dma_end: DMA_END,
    }
    impl RegisterBlock {
        ///0x00 - RW, TMR1 mode control
        #[inline(always)]
        pub const fn ctrl_mod(&self) -> &CTRL_MOD {
            &self.ctrl_mod
        }
        ///0x01 - RW, TMR1 DMA control
        #[inline(always)]
        pub const fn ctrl_dma(&self) -> &CTRL_DMA {
            &self.ctrl_dma
        }
        ///0x02 - RW, TMR1 interrupt enable
        #[inline(always)]
        pub const fn inter_en(&self) -> &INTER_EN {
            &self.inter_en
        }
        ///0x06 - RW1, TMR1 interrupt flag
        #[inline(always)]
        pub const fn int_flag(&self) -> &INT_FLAG {
            &self.int_flag
        }
        ///0x07 - RO, TMR1 FIFO count status
        #[inline(always)]
        pub const fn fifo_count(&self) -> &FIFO_COUNT {
            &self.fifo_count
        }
        ///0x08 - RO, TMR1 current count
        #[inline(always)]
        pub const fn count(&self) -> &COUNT {
            &self.count
        }
        ///0x0c - RW, TMR1 end count value, only low 26 bit
        #[inline(always)]
        pub const fn cnt_end(&self) -> &CNT_END {
            &self.cnt_end
        }
        ///0x10 - RO, TMR1 FIFO register, only low 26 bit
        #[inline(always)]
        pub const fn fifo(&self) -> &FIFO {
            &self.fifo
        }
        ///0x14 - RO, TMR1 DMA current address
        #[inline(always)]
        pub const fn dma_now(&self) -> &DMA_NOW {
            &self.dma_now
        }
        ///0x18 - RW, TMR1 DMA begin address
        #[inline(always)]
        pub const fn dma_beg(&self) -> &DMA_BEG {
            &self.dma_beg
        }
        ///0x1c - RW, TMR1 DMA end address
        #[inline(always)]
        pub const fn dma_end(&self) -> &DMA_END {
            &self.dma_end
        }
    }
    ///CTRL_MOD (rw) register accessor: RW, TMR1 mode control
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`ctrl_mod::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ctrl_mod::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@ctrl_mod`]
    ///module
    pub type CTRL_MOD = crate::Reg<ctrl_mod::CTRL_MOD_SPEC>;
    ///RW, TMR1 mode control
    pub mod ctrl_mod {
        ///Register `CTRL_MOD` reader
        pub type R = crate::R<CTRL_MOD_SPEC>;
        ///Register `CTRL_MOD` writer
        pub type W = crate::W<CTRL_MOD_SPEC>;
        ///Field `TMR_MODE_IN` reader - RW, timer in mode: 0=timer/PWM, 1=capture/count
        pub type TMR_MODE_IN_R = crate::BitReader;
        ///Field `TMR_MODE_IN` writer - RW, timer in mode: 0=timer/PWM, 1=capture/count
        pub type TMR_MODE_IN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TMR_ALL_CLEAR` reader - RW, force clear timer FIFO and count
        pub type TMR_ALL_CLEAR_R = crate::BitReader;
        ///Field `TMR_ALL_CLEAR` writer - RW, force clear timer FIFO and count
        pub type TMR_ALL_CLEAR_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TMR_COUNT_EN` reader - RW, timer count enable
        pub type TMR_COUNT_EN_R = crate::BitReader;
        ///Field `TMR_COUNT_EN` writer - RW, timer count enable
        pub type TMR_COUNT_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TMR_OUT_EN` reader - RW, timer output enable
        pub type TMR_OUT_EN_R = crate::BitReader;
        ///Field `TMR_OUT_EN` writer - RW, timer output enable
        pub type TMR_OUT_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TMR_OUT_POLAR__RB_TMR_CAP_COUNT` reader - RW, timer PWM output polarity: 0=default low and high action, 1=default high and low action;RW, count sub-mode if RB_TMR_MODE_IN=1: 0=capture, 1=count
        pub type TMR_OUT_POLAR__RB_TMR_CAP_COUNT_R = crate::BitReader;
        ///Field `TMR_OUT_POLAR__RB_TMR_CAP_COUNT` writer - RW, timer PWM output polarity: 0=default low and high action, 1=default high and low action;RW, count sub-mode if RB_TMR_MODE_IN=1: 0=capture, 1=count
        pub type TMR_OUT_POLAR__RB_TMR_CAP_COUNT_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TMR_PWM_REPEAT__RB_TMR_CAP_EDGE` reader - RW, timer PWM repeat mode: 00=1, 01=4, 10=8, 11-16;RW, timer capture edge mode: 00=disable, 01=edge change, 10=fall to fall, 11-rise to rise
        pub type TMR_PWM_REPEAT__RB_TMR_CAP_EDGE_R = crate::FieldReader;
        ///Field `TMR_PWM_REPEAT__RB_TMR_CAP_EDGE` writer - RW, timer PWM repeat mode: 00=1, 01=4, 10=8, 11-16;RW, timer capture edge mode: 00=disable, 01=edge change, 10=fall to fall, 11-rise to rise
        pub type TMR_PWM_REPEAT__RB_TMR_CAP_EDGE_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        impl R {
            ///Bit 0 - RW, timer in mode: 0=timer/PWM, 1=capture/count
            #[inline(always)]
            pub fn tmr_mode_in(&self) -> TMR_MODE_IN_R {
                TMR_MODE_IN_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RW, force clear timer FIFO and count
            #[inline(always)]
            pub fn tmr_all_clear(&self) -> TMR_ALL_CLEAR_R {
                TMR_ALL_CLEAR_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RW, timer count enable
            #[inline(always)]
            pub fn tmr_count_en(&self) -> TMR_COUNT_EN_R {
                TMR_COUNT_EN_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RW, timer output enable
            #[inline(always)]
            pub fn tmr_out_en(&self) -> TMR_OUT_EN_R {
                TMR_OUT_EN_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RW, timer PWM output polarity: 0=default low and high action, 1=default high and low action;RW, count sub-mode if RB_TMR_MODE_IN=1: 0=capture, 1=count
            #[inline(always)]
            pub fn tmr_out_polar__rb_tmr_cap_count(&self) -> TMR_OUT_POLAR__RB_TMR_CAP_COUNT_R {
                TMR_OUT_POLAR__RB_TMR_CAP_COUNT_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bits 6:7 - RW, timer PWM repeat mode: 00=1, 01=4, 10=8, 11-16;RW, timer capture edge mode: 00=disable, 01=edge change, 10=fall to fall, 11-rise to rise
            #[inline(always)]
            pub fn tmr_pwm_repeat__rb_tmr_cap_edge(&self) -> TMR_PWM_REPEAT__RB_TMR_CAP_EDGE_R {
                TMR_PWM_REPEAT__RB_TMR_CAP_EDGE_R::new((self.bits >> 6) & 3)
            }
        }
        impl W {
            ///Bit 0 - RW, timer in mode: 0=timer/PWM, 1=capture/count
            #[inline(always)]
            #[must_use]
            pub fn tmr_mode_in(&mut self) -> TMR_MODE_IN_W<CTRL_MOD_SPEC> {
                TMR_MODE_IN_W::new(self, 0)
            }
            ///Bit 1 - RW, force clear timer FIFO and count
            #[inline(always)]
            #[must_use]
            pub fn tmr_all_clear(&mut self) -> TMR_ALL_CLEAR_W<CTRL_MOD_SPEC> {
                TMR_ALL_CLEAR_W::new(self, 1)
            }
            ///Bit 2 - RW, timer count enable
            #[inline(always)]
            #[must_use]
            pub fn tmr_count_en(&mut self) -> TMR_COUNT_EN_W<CTRL_MOD_SPEC> {
                TMR_COUNT_EN_W::new(self, 2)
            }
            ///Bit 3 - RW, timer output enable
            #[inline(always)]
            #[must_use]
            pub fn tmr_out_en(&mut self) -> TMR_OUT_EN_W<CTRL_MOD_SPEC> {
                TMR_OUT_EN_W::new(self, 3)
            }
            ///Bit 4 - RW, timer PWM output polarity: 0=default low and high action, 1=default high and low action;RW, count sub-mode if RB_TMR_MODE_IN=1: 0=capture, 1=count
            #[inline(always)]
            #[must_use]
            pub fn tmr_out_polar__rb_tmr_cap_count(
                &mut self,
            ) -> TMR_OUT_POLAR__RB_TMR_CAP_COUNT_W<CTRL_MOD_SPEC> {
                TMR_OUT_POLAR__RB_TMR_CAP_COUNT_W::new(self, 4)
            }
            ///Bits 6:7 - RW, timer PWM repeat mode: 00=1, 01=4, 10=8, 11-16;RW, timer capture edge mode: 00=disable, 01=edge change, 10=fall to fall, 11-rise to rise
            #[inline(always)]
            #[must_use]
            pub fn tmr_pwm_repeat__rb_tmr_cap_edge(
                &mut self,
            ) -> TMR_PWM_REPEAT__RB_TMR_CAP_EDGE_W<CTRL_MOD_SPEC> {
                TMR_PWM_REPEAT__RB_TMR_CAP_EDGE_W::new(self, 6)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW, TMR1 mode control
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`ctrl_mod::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ctrl_mod::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct CTRL_MOD_SPEC;
        impl crate::RegisterSpec for CTRL_MOD_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`ctrl_mod::R`](R) reader structure
        impl crate::Readable for CTRL_MOD_SPEC {}
        ///`write(|w| ..)` method takes [`ctrl_mod::W`](W) writer structure
        impl crate::Writable for CTRL_MOD_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets CTRL_MOD to value 0x02
        impl crate::Resettable for CTRL_MOD_SPEC {
            const RESET_VALUE: u8 = 0x02;
        }
    }
    ///CTRL_DMA (rw) register accessor: RW, TMR1 DMA control
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`ctrl_dma::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ctrl_dma::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@ctrl_dma`]
    ///module
    pub type CTRL_DMA = crate::Reg<ctrl_dma::CTRL_DMA_SPEC>;
    ///RW, TMR1 DMA control
    pub mod ctrl_dma {
        ///Register `CTRL_DMA` reader
        pub type R = crate::R<CTRL_DMA_SPEC>;
        ///Register `CTRL_DMA` writer
        pub type W = crate::W<CTRL_DMA_SPEC>;
        ///Field `TMR_DMA_ENABLE` reader - RW, timer1/2 DMA enable
        pub type TMR_DMA_ENABLE_R = crate::BitReader;
        ///Field `TMR_DMA_ENABLE` writer - RW, timer1/2 DMA enable
        pub type TMR_DMA_ENABLE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TMR_DMA_LOOP` reader - RW, timer1/2 DMA address loop enable
        pub type TMR_DMA_LOOP_R = crate::BitReader;
        ///Field `TMR_DMA_LOOP` writer - RW, timer1/2 DMA address loop enable
        pub type TMR_DMA_LOOP_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - RW, timer1/2 DMA enable
            #[inline(always)]
            pub fn tmr_dma_enable(&self) -> TMR_DMA_ENABLE_R {
                TMR_DMA_ENABLE_R::new((self.bits & 1) != 0)
            }
            ///Bit 2 - RW, timer1/2 DMA address loop enable
            #[inline(always)]
            pub fn tmr_dma_loop(&self) -> TMR_DMA_LOOP_R {
                TMR_DMA_LOOP_R::new(((self.bits >> 2) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RW, timer1/2 DMA enable
            #[inline(always)]
            #[must_use]
            pub fn tmr_dma_enable(&mut self) -> TMR_DMA_ENABLE_W<CTRL_DMA_SPEC> {
                TMR_DMA_ENABLE_W::new(self, 0)
            }
            ///Bit 2 - RW, timer1/2 DMA address loop enable
            #[inline(always)]
            #[must_use]
            pub fn tmr_dma_loop(&mut self) -> TMR_DMA_LOOP_W<CTRL_DMA_SPEC> {
                TMR_DMA_LOOP_W::new(self, 2)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW, TMR1 DMA control
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`ctrl_dma::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ctrl_dma::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct CTRL_DMA_SPEC;
        impl crate::RegisterSpec for CTRL_DMA_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`ctrl_dma::R`](R) reader structure
        impl crate::Readable for CTRL_DMA_SPEC {}
        ///`write(|w| ..)` method takes [`ctrl_dma::W`](W) writer structure
        impl crate::Writable for CTRL_DMA_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets CTRL_DMA to value 0
        impl crate::Resettable for CTRL_DMA_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///INTER_EN (rw) register accessor: RW, TMR1 interrupt enable
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`inter_en::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`inter_en::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@inter_en`]
    ///module
    pub type INTER_EN = crate::Reg<inter_en::INTER_EN_SPEC>;
    ///RW, TMR1 interrupt enable
    pub mod inter_en {
        ///Register `INTER_EN` reader
        pub type R = crate::R<INTER_EN_SPEC>;
        ///Register `INTER_EN` writer
        pub type W = crate::W<INTER_EN_SPEC>;
        ///Field `TMR_IE_CYC_END` reader - RW, enable interrupt for timer capture count timeout or PWM cycle end
        pub type TMR_IE_CYC_END_R = crate::BitReader;
        ///Field `TMR_IE_CYC_END` writer - RW, enable interrupt for timer capture count timeout or PWM cycle end
        pub type TMR_IE_CYC_END_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TMR_IE_DATA_ACT` reader - RW, enable interrupt for timer capture input action or PWM trigger
        pub type TMR_IE_DATA_ACT_R = crate::BitReader;
        ///Field `TMR_IE_DATA_ACT` writer - RW, enable interrupt for timer capture input action or PWM trigger
        pub type TMR_IE_DATA_ACT_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TMR_IE_FIFO_HF` reader - RW, enable interrupt for timer FIFO half (capture fifo >=4 or PWM fifo less than 3)
        pub type TMR_IE_FIFO_HF_R = crate::BitReader;
        ///Field `TMR_IE_FIFO_HF` writer - RW, enable interrupt for timer FIFO half (capture fifo >=4 or PWM fifo less than 3)
        pub type TMR_IE_FIFO_HF_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TMR_IE_DMA_END` reader - RW, enable interrupt for timer1/2 DMA completion
        pub type TMR_IE_DMA_END_R = crate::BitReader;
        ///Field `TMR_IE_DMA_END` writer - RW, enable interrupt for timer1/2 DMA completion
        pub type TMR_IE_DMA_END_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TMR_IE_FIFO_OV` reader - RW, enable interrupt for timer FIFO overflow
        pub type TMR_IE_FIFO_OV_R = crate::BitReader;
        ///Field `TMR_IE_FIFO_OV` writer - RW, enable interrupt for timer FIFO overflow
        pub type TMR_IE_FIFO_OV_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - RW, enable interrupt for timer capture count timeout or PWM cycle end
            #[inline(always)]
            pub fn tmr_ie_cyc_end(&self) -> TMR_IE_CYC_END_R {
                TMR_IE_CYC_END_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RW, enable interrupt for timer capture input action or PWM trigger
            #[inline(always)]
            pub fn tmr_ie_data_act(&self) -> TMR_IE_DATA_ACT_R {
                TMR_IE_DATA_ACT_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RW, enable interrupt for timer FIFO half (capture fifo >=4 or PWM fifo less than 3)
            #[inline(always)]
            pub fn tmr_ie_fifo_hf(&self) -> TMR_IE_FIFO_HF_R {
                TMR_IE_FIFO_HF_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RW, enable interrupt for timer1/2 DMA completion
            #[inline(always)]
            pub fn tmr_ie_dma_end(&self) -> TMR_IE_DMA_END_R {
                TMR_IE_DMA_END_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RW, enable interrupt for timer FIFO overflow
            #[inline(always)]
            pub fn tmr_ie_fifo_ov(&self) -> TMR_IE_FIFO_OV_R {
                TMR_IE_FIFO_OV_R::new(((self.bits >> 4) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RW, enable interrupt for timer capture count timeout or PWM cycle end
            #[inline(always)]
            #[must_use]
            pub fn tmr_ie_cyc_end(&mut self) -> TMR_IE_CYC_END_W<INTER_EN_SPEC> {
                TMR_IE_CYC_END_W::new(self, 0)
            }
            ///Bit 1 - RW, enable interrupt for timer capture input action or PWM trigger
            #[inline(always)]
            #[must_use]
            pub fn tmr_ie_data_act(&mut self) -> TMR_IE_DATA_ACT_W<INTER_EN_SPEC> {
                TMR_IE_DATA_ACT_W::new(self, 1)
            }
            ///Bit 2 - RW, enable interrupt for timer FIFO half (capture fifo >=4 or PWM fifo less than 3)
            #[inline(always)]
            #[must_use]
            pub fn tmr_ie_fifo_hf(&mut self) -> TMR_IE_FIFO_HF_W<INTER_EN_SPEC> {
                TMR_IE_FIFO_HF_W::new(self, 2)
            }
            ///Bit 3 - RW, enable interrupt for timer1/2 DMA completion
            #[inline(always)]
            #[must_use]
            pub fn tmr_ie_dma_end(&mut self) -> TMR_IE_DMA_END_W<INTER_EN_SPEC> {
                TMR_IE_DMA_END_W::new(self, 3)
            }
            ///Bit 4 - RW, enable interrupt for timer FIFO overflow
            #[inline(always)]
            #[must_use]
            pub fn tmr_ie_fifo_ov(&mut self) -> TMR_IE_FIFO_OV_W<INTER_EN_SPEC> {
                TMR_IE_FIFO_OV_W::new(self, 4)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW, TMR1 interrupt enable
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`inter_en::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`inter_en::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct INTER_EN_SPEC;
        impl crate::RegisterSpec for INTER_EN_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`inter_en::R`](R) reader structure
        impl crate::Readable for INTER_EN_SPEC {}
        ///`write(|w| ..)` method takes [`inter_en::W`](W) writer structure
        impl crate::Writable for INTER_EN_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets INTER_EN to value 0
        impl crate::Resettable for INTER_EN_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///INT_FLAG (rw) register accessor: RW1, TMR1 interrupt flag
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`int_flag::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`int_flag::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@int_flag`]
    ///module
    pub type INT_FLAG = crate::Reg<int_flag::INT_FLAG_SPEC>;
    ///RW1, TMR1 interrupt flag
    pub mod int_flag {
        ///Register `INT_FLAG` reader
        pub type R = crate::R<INT_FLAG_SPEC>;
        ///Register `INT_FLAG` writer
        pub type W = crate::W<INT_FLAG_SPEC>;
        ///Field `TMR_IF_CYC_END` reader - RW1, interrupt flag for timer capture count timeout or PWM cycle end
        pub type TMR_IF_CYC_END_R = crate::BitReader;
        ///Field `TMR_IF_CYC_END` writer - RW1, interrupt flag for timer capture count timeout or PWM cycle end
        pub type TMR_IF_CYC_END_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TMR_IF_DATA_ACT` reader - RW1, interrupt flag for timer capture input action or PWM trigger
        pub type TMR_IF_DATA_ACT_R = crate::BitReader;
        ///Field `TMR_IF_DATA_ACT` writer - RW1, interrupt flag for timer capture input action or PWM trigger
        pub type TMR_IF_DATA_ACT_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TMR_IF_FIFO_HF` reader - RW1, interrupt flag for timer FIFO half (capture fifo >=4 or PWM fifo less than 3
        pub type TMR_IF_FIFO_HF_R = crate::BitReader;
        ///Field `TMR_IF_FIFO_HF` writer - RW1, interrupt flag for timer FIFO half (capture fifo >=4 or PWM fifo less than 3
        pub type TMR_IF_FIFO_HF_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TMR_IF_DMA_END` reader - RW1, interrupt flag for timer1/2 DMA completion
        pub type TMR_IF_DMA_END_R = crate::BitReader;
        ///Field `TMR_IF_DMA_END` writer - RW1, interrupt flag for timer1/2 DMA completion
        pub type TMR_IF_DMA_END_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TMR_IF_FIFO_OV` reader - RW1, interrupt flag for timer FIFO overflow
        pub type TMR_IF_FIFO_OV_R = crate::BitReader;
        ///Field `TMR_IF_FIFO_OV` writer - RW1, interrupt flag for timer FIFO overflow
        pub type TMR_IF_FIFO_OV_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - RW1, interrupt flag for timer capture count timeout or PWM cycle end
            #[inline(always)]
            pub fn tmr_if_cyc_end(&self) -> TMR_IF_CYC_END_R {
                TMR_IF_CYC_END_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RW1, interrupt flag for timer capture input action or PWM trigger
            #[inline(always)]
            pub fn tmr_if_data_act(&self) -> TMR_IF_DATA_ACT_R {
                TMR_IF_DATA_ACT_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RW1, interrupt flag for timer FIFO half (capture fifo >=4 or PWM fifo less than 3
            #[inline(always)]
            pub fn tmr_if_fifo_hf(&self) -> TMR_IF_FIFO_HF_R {
                TMR_IF_FIFO_HF_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RW1, interrupt flag for timer1/2 DMA completion
            #[inline(always)]
            pub fn tmr_if_dma_end(&self) -> TMR_IF_DMA_END_R {
                TMR_IF_DMA_END_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RW1, interrupt flag for timer FIFO overflow
            #[inline(always)]
            pub fn tmr_if_fifo_ov(&self) -> TMR_IF_FIFO_OV_R {
                TMR_IF_FIFO_OV_R::new(((self.bits >> 4) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RW1, interrupt flag for timer capture count timeout or PWM cycle end
            #[inline(always)]
            #[must_use]
            pub fn tmr_if_cyc_end(&mut self) -> TMR_IF_CYC_END_W<INT_FLAG_SPEC> {
                TMR_IF_CYC_END_W::new(self, 0)
            }
            ///Bit 1 - RW1, interrupt flag for timer capture input action or PWM trigger
            #[inline(always)]
            #[must_use]
            pub fn tmr_if_data_act(&mut self) -> TMR_IF_DATA_ACT_W<INT_FLAG_SPEC> {
                TMR_IF_DATA_ACT_W::new(self, 1)
            }
            ///Bit 2 - RW1, interrupt flag for timer FIFO half (capture fifo >=4 or PWM fifo less than 3
            #[inline(always)]
            #[must_use]
            pub fn tmr_if_fifo_hf(&mut self) -> TMR_IF_FIFO_HF_W<INT_FLAG_SPEC> {
                TMR_IF_FIFO_HF_W::new(self, 2)
            }
            ///Bit 3 - RW1, interrupt flag for timer1/2 DMA completion
            #[inline(always)]
            #[must_use]
            pub fn tmr_if_dma_end(&mut self) -> TMR_IF_DMA_END_W<INT_FLAG_SPEC> {
                TMR_IF_DMA_END_W::new(self, 3)
            }
            ///Bit 4 - RW1, interrupt flag for timer FIFO overflow
            #[inline(always)]
            #[must_use]
            pub fn tmr_if_fifo_ov(&mut self) -> TMR_IF_FIFO_OV_W<INT_FLAG_SPEC> {
                TMR_IF_FIFO_OV_W::new(self, 4)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW1, TMR1 interrupt flag
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`int_flag::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`int_flag::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct INT_FLAG_SPEC;
        impl crate::RegisterSpec for INT_FLAG_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`int_flag::R`](R) reader structure
        impl crate::Readable for INT_FLAG_SPEC {}
        ///`write(|w| ..)` method takes [`int_flag::W`](W) writer structure
        impl crate::Writable for INT_FLAG_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets INT_FLAG to value 0
        impl crate::Resettable for INT_FLAG_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///FIFO_COUNT (r) register accessor: RO, TMR1 FIFO count status
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`fifo_count::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@fifo_count`]
    ///module
    pub type FIFO_COUNT = crate::Reg<fifo_count::FIFO_COUNT_SPEC>;
    ///RO, TMR1 FIFO count status
    pub mod fifo_count {
        ///Register `FIFO_COUNT` reader
        pub type R = crate::R<FIFO_COUNT_SPEC>;
        ///Field `FIFO_COUNT` reader - RW1, TMR1 FIFO count status
        pub type FIFO_COUNT_R = crate::FieldReader;
        impl R {
            ///Bits 0:7 - RW1, TMR1 FIFO count status
            #[inline(always)]
            pub fn fifo_count(&self) -> FIFO_COUNT_R {
                FIFO_COUNT_R::new(self.bits)
            }
        }
        ///RO, TMR1 FIFO count status
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`fifo_count::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct FIFO_COUNT_SPEC;
        impl crate::RegisterSpec for FIFO_COUNT_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`fifo_count::R`](R) reader structure
        impl crate::Readable for FIFO_COUNT_SPEC {}
        ///`reset()` method sets FIFO_COUNT to value 0
        impl crate::Resettable for FIFO_COUNT_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///COUNT (r) register accessor: RO, TMR1 current count
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`count::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@count`]
    ///module
    pub type COUNT = crate::Reg<count::COUNT_SPEC>;
    ///RO, TMR1 current count
    pub mod count {
        ///Register `COUNT` reader
        pub type R = crate::R<COUNT_SPEC>;
        ///Field `COUNT` reader - RW1,TMR1 current count
        pub type COUNT_R = crate::FieldReader<u32>;
        impl R {
            ///Bits 0:31 - RW1,TMR1 current count
            #[inline(always)]
            pub fn count(&self) -> COUNT_R {
                COUNT_R::new(self.bits)
            }
        }
        ///RO, TMR1 current count
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`count::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct COUNT_SPEC;
        impl crate::RegisterSpec for COUNT_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`count::R`](R) reader structure
        impl crate::Readable for COUNT_SPEC {}
        ///`reset()` method sets COUNT to value 0
        impl crate::Resettable for COUNT_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///CNT_END (rw) register accessor: RW, TMR1 end count value, only low 26 bit
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`cnt_end::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cnt_end::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@cnt_end`]
    ///module
    pub type CNT_END = crate::Reg<cnt_end::CNT_END_SPEC>;
    ///RW, TMR1 end count value, only low 26 bit
    pub mod cnt_end {
        ///Register `CNT_END` reader
        pub type R = crate::R<CNT_END_SPEC>;
        ///Register `CNT_END` writer
        pub type W = crate::W<CNT_END_SPEC>;
        ///Field `CNT_END` reader - RW1,TMR1 end count value,
        pub type CNT_END_R = crate::FieldReader<u32>;
        ///Field `CNT_END` writer - RW1,TMR1 end count value,
        pub type CNT_END_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - RW1,TMR1 end count value,
            #[inline(always)]
            pub fn cnt_end(&self) -> CNT_END_R {
                CNT_END_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW1,TMR1 end count value,
            #[inline(always)]
            #[must_use]
            pub fn cnt_end(&mut self) -> CNT_END_W<CNT_END_SPEC> {
                CNT_END_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW, TMR1 end count value, only low 26 bit
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`cnt_end::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cnt_end::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct CNT_END_SPEC;
        impl crate::RegisterSpec for CNT_END_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`cnt_end::R`](R) reader structure
        impl crate::Readable for CNT_END_SPEC {}
        ///`write(|w| ..)` method takes [`cnt_end::W`](W) writer structure
        impl crate::Writable for CNT_END_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets CNT_END to value 0
        impl crate::Resettable for CNT_END_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///FIFO (r) register accessor: RO, TMR1 FIFO register, only low 26 bit
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`fifo::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@fifo`]
    ///module
    pub type FIFO = crate::Reg<fifo::FIFO_SPEC>;
    ///RO, TMR1 FIFO register, only low 26 bit
    pub mod fifo {
        ///Register `FIFO` reader
        pub type R = crate::R<FIFO_SPEC>;
        ///Field `FIFO` reader - RW1,TMR1 FIFO register
        pub type FIFO_R = crate::FieldReader<u32>;
        impl R {
            ///Bits 0:31 - RW1,TMR1 FIFO register
            #[inline(always)]
            pub fn fifo(&self) -> FIFO_R {
                FIFO_R::new(self.bits)
            }
        }
        ///RO, TMR1 FIFO register, only low 26 bit
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`fifo::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct FIFO_SPEC;
        impl crate::RegisterSpec for FIFO_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`fifo::R`](R) reader structure
        impl crate::Readable for FIFO_SPEC {}
        ///`reset()` method sets FIFO to value 0
        impl crate::Resettable for FIFO_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///DMA_NOW (r) register accessor: RO, TMR1 DMA current address
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`dma_now::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@dma_now`]
    ///module
    pub type DMA_NOW = crate::Reg<dma_now::DMA_NOW_SPEC>;
    ///RO, TMR1 DMA current address
    pub mod dma_now {
        ///Register `DMA_NOW` reader
        pub type R = crate::R<DMA_NOW_SPEC>;
        ///Field `DMA_NOW` reader - RW1,TMR1 FIFO register
        pub type DMA_NOW_R = crate::FieldReader<u16>;
        impl R {
            ///Bits 0:15 - RW1,TMR1 FIFO register
            #[inline(always)]
            pub fn dma_now(&self) -> DMA_NOW_R {
                DMA_NOW_R::new(self.bits)
            }
        }
        ///RO, TMR1 DMA current address
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`dma_now::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct DMA_NOW_SPEC;
        impl crate::RegisterSpec for DMA_NOW_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`dma_now::R`](R) reader structure
        impl crate::Readable for DMA_NOW_SPEC {}
        ///`reset()` method sets DMA_NOW to value 0
        impl crate::Resettable for DMA_NOW_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///DMA_BEG (rw) register accessor: RW, TMR1 DMA begin address
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`dma_beg::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dma_beg::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@dma_beg`]
    ///module
    pub type DMA_BEG = crate::Reg<dma_beg::DMA_BEG_SPEC>;
    ///RW, TMR1 DMA begin address
    pub mod dma_beg {
        ///Register `DMA_BEG` reader
        pub type R = crate::R<DMA_BEG_SPEC>;
        ///Register `DMA_BEG` writer
        pub type W = crate::W<DMA_BEG_SPEC>;
        ///Field `DMA_BEG` reader - RW1,TMR1 FIFO register
        pub type DMA_BEG_R = crate::FieldReader<u16>;
        ///Field `DMA_BEG` writer - RW1,TMR1 FIFO register
        pub type DMA_BEG_W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            ///Bits 0:15 - RW1,TMR1 FIFO register
            #[inline(always)]
            pub fn dma_beg(&self) -> DMA_BEG_R {
                DMA_BEG_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - RW1,TMR1 FIFO register
            #[inline(always)]
            #[must_use]
            pub fn dma_beg(&mut self) -> DMA_BEG_W<DMA_BEG_SPEC> {
                DMA_BEG_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW, TMR1 DMA begin address
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`dma_beg::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dma_beg::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct DMA_BEG_SPEC;
        impl crate::RegisterSpec for DMA_BEG_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`dma_beg::R`](R) reader structure
        impl crate::Readable for DMA_BEG_SPEC {}
        ///`write(|w| ..)` method takes [`dma_beg::W`](W) writer structure
        impl crate::Writable for DMA_BEG_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets DMA_BEG to value 0
        impl crate::Resettable for DMA_BEG_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///DMA_END (rw) register accessor: RW, TMR1 DMA end address
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`dma_end::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dma_end::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@dma_end`]
    ///module
    pub type DMA_END = crate::Reg<dma_end::DMA_END_SPEC>;
    ///RW, TMR1 DMA end address
    pub mod dma_end {
        ///Register `DMA_END` reader
        pub type R = crate::R<DMA_END_SPEC>;
        ///Register `DMA_END` writer
        pub type W = crate::W<DMA_END_SPEC>;
        ///Field `DMA_END` reader - RW1,TMR1 FIFO register
        pub type DMA_END_R = crate::FieldReader<u16>;
        ///Field `DMA_END` writer - RW1,TMR1 FIFO register
        pub type DMA_END_W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            ///Bits 0:15 - RW1,TMR1 FIFO register
            #[inline(always)]
            pub fn dma_end(&self) -> DMA_END_R {
                DMA_END_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - RW1,TMR1 FIFO register
            #[inline(always)]
            #[must_use]
            pub fn dma_end(&mut self) -> DMA_END_W<DMA_END_SPEC> {
                DMA_END_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW, TMR1 DMA end address
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`dma_end::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dma_end::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct DMA_END_SPEC;
        impl crate::RegisterSpec for DMA_END_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`dma_end::R`](R) reader structure
        impl crate::Readable for DMA_END_SPEC {}
        ///`write(|w| ..)` method takes [`dma_end::W`](W) writer structure
        impl crate::Writable for DMA_END_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets DMA_END to value 0
        impl crate::Resettable for DMA_END_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
}
///Timer2 register
pub struct TMR2 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for TMR2 {}
impl TMR2 {
    ///Pointer to the register block
    pub const PTR: *const tmr2::RegisterBlock = 0x4000_2800 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const tmr2::RegisterBlock {
        Self::PTR
    }
    /// Steal an instance of this peripheral
    ///
    /// # Safety
    ///
    /// Ensure that the new instance of the peripheral cannot be used in a way
    /// that may race with any existing instances, for example by only
    /// accessing read-only or write-only registers, or by consuming the
    /// original peripheral and using critical sections to coordinate
    /// access between multiple new instances.
    ///
    /// Additionally, other software such as HALs may rely on only one
    /// peripheral instance existing to ensure memory safety; ensure
    /// no stolen instances are passed to such software.
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for TMR2 {
    type Target = tmr2::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for TMR2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("TMR2").finish()
    }
}
///Timer2 register
pub mod tmr2 {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        ctrl_mod: CTRL_MOD,
        ctrl_dma: CTRL_DMA,
        inter_en: INTER_EN,
        _reserved3: [u8; 0x03],
        int_flag: INT_FLAG,
        fifo_count: FIFO_COUNT,
        count: COUNT,
        cnt_end: CNT_END,
        fifo: FIFO,
        dma_now: DMA_NOW,
        _reserved9: [u8; 0x02],
        dma_beg: DMA_BEG,
        _reserved10: [u8; 0x02],
        dma_end: DMA_END,
    }
    impl RegisterBlock {
        ///0x00 - RW, TMR2 mode control
        #[inline(always)]
        pub const fn ctrl_mod(&self) -> &CTRL_MOD {
            &self.ctrl_mod
        }
        ///0x01 - RW, TMR2 DMA control
        #[inline(always)]
        pub const fn ctrl_dma(&self) -> &CTRL_DMA {
            &self.ctrl_dma
        }
        ///0x02 - RW, TMR2 interrupt enable
        #[inline(always)]
        pub const fn inter_en(&self) -> &INTER_EN {
            &self.inter_en
        }
        ///0x06 - RW1, TMR2 interrupt flag
        #[inline(always)]
        pub const fn int_flag(&self) -> &INT_FLAG {
            &self.int_flag
        }
        ///0x07 - RO, TMR2 FIFO count status
        #[inline(always)]
        pub const fn fifo_count(&self) -> &FIFO_COUNT {
            &self.fifo_count
        }
        ///0x08 - RO, TMR2 current count
        #[inline(always)]
        pub const fn count(&self) -> &COUNT {
            &self.count
        }
        ///0x0c - RW, TMR2 end count value, only low 26 bit
        #[inline(always)]
        pub const fn cnt_end(&self) -> &CNT_END {
            &self.cnt_end
        }
        ///0x10 - RO, TMR2 FIFO register, only low 26 bit
        #[inline(always)]
        pub const fn fifo(&self) -> &FIFO {
            &self.fifo
        }
        ///0x14 - RO, TMR2 DMA current address
        #[inline(always)]
        pub const fn dma_now(&self) -> &DMA_NOW {
            &self.dma_now
        }
        ///0x18 - RW, TMR2 DMA begin address
        #[inline(always)]
        pub const fn dma_beg(&self) -> &DMA_BEG {
            &self.dma_beg
        }
        ///0x1c - RW, TMR2 DMA end address
        #[inline(always)]
        pub const fn dma_end(&self) -> &DMA_END {
            &self.dma_end
        }
    }
    ///CTRL_MOD (rw) register accessor: RW, TMR2 mode control
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`ctrl_mod::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ctrl_mod::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@ctrl_mod`]
    ///module
    pub type CTRL_MOD = crate::Reg<ctrl_mod::CTRL_MOD_SPEC>;
    ///RW, TMR2 mode control
    pub mod ctrl_mod {
        ///Register `CTRL_MOD` reader
        pub type R = crate::R<CTRL_MOD_SPEC>;
        ///Register `CTRL_MOD` writer
        pub type W = crate::W<CTRL_MOD_SPEC>;
        ///Field `TMR_MODE_IN` reader - RW, timer in mode: 0=timer_PWM, 1=capture_count
        pub type TMR_MODE_IN_R = crate::BitReader;
        ///Field `TMR_MODE_IN` writer - RW, timer in mode: 0=timer_PWM, 1=capture_count
        pub type TMR_MODE_IN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TMR_ALL_CLEAR` reader - RW, force clear timer FIFO and count
        pub type TMR_ALL_CLEAR_R = crate::BitReader;
        ///Field `TMR_ALL_CLEAR` writer - RW, force clear timer FIFO and count
        pub type TMR_ALL_CLEAR_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TMR_COUNT_EN` reader - RW, timer count enable
        pub type TMR_COUNT_EN_R = crate::BitReader;
        ///Field `TMR_COUNT_EN` writer - RW, timer count enable
        pub type TMR_COUNT_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TMR_OUT_EN` reader - RW, timer output enable
        pub type TMR_OUT_EN_R = crate::BitReader;
        ///Field `TMR_OUT_EN` writer - RW, timer output enable
        pub type TMR_OUT_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TMR_OUT_POLAR__RB_TMR_CAP_COUNT` reader - RW, timer PWM output polarity: 0=default low and high action, 1=default high and low action;RW, count sub-mode if RB_TMR_MODE_IN=1: 0=capture, 1=count
        pub type TMR_OUT_POLAR__RB_TMR_CAP_COUNT_R = crate::BitReader;
        ///Field `TMR_OUT_POLAR__RB_TMR_CAP_COUNT` writer - RW, timer PWM output polarity: 0=default low and high action, 1=default high and low action;RW, count sub-mode if RB_TMR_MODE_IN=1: 0=capture, 1=count
        pub type TMR_OUT_POLAR__RB_TMR_CAP_COUNT_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TMR_PWM_REPEAT__RB_TMR_CAP_EDGE` reader - RW, timer PWM repeat mode: 00=1, 01=4, 10=8, 11-16;RW, timer capture edge mode: 00=disable, 01=edge change, 10=fall to fall, 11-rise to rise
        pub type TMR_PWM_REPEAT__RB_TMR_CAP_EDGE_R = crate::FieldReader;
        ///Field `TMR_PWM_REPEAT__RB_TMR_CAP_EDGE` writer - RW, timer PWM repeat mode: 00=1, 01=4, 10=8, 11-16;RW, timer capture edge mode: 00=disable, 01=edge change, 10=fall to fall, 11-rise to rise
        pub type TMR_PWM_REPEAT__RB_TMR_CAP_EDGE_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        impl R {
            ///Bit 0 - RW, timer in mode: 0=timer_PWM, 1=capture_count
            #[inline(always)]
            pub fn tmr_mode_in(&self) -> TMR_MODE_IN_R {
                TMR_MODE_IN_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RW, force clear timer FIFO and count
            #[inline(always)]
            pub fn tmr_all_clear(&self) -> TMR_ALL_CLEAR_R {
                TMR_ALL_CLEAR_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RW, timer count enable
            #[inline(always)]
            pub fn tmr_count_en(&self) -> TMR_COUNT_EN_R {
                TMR_COUNT_EN_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RW, timer output enable
            #[inline(always)]
            pub fn tmr_out_en(&self) -> TMR_OUT_EN_R {
                TMR_OUT_EN_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RW, timer PWM output polarity: 0=default low and high action, 1=default high and low action;RW, count sub-mode if RB_TMR_MODE_IN=1: 0=capture, 1=count
            #[inline(always)]
            pub fn tmr_out_polar__rb_tmr_cap_count(&self) -> TMR_OUT_POLAR__RB_TMR_CAP_COUNT_R {
                TMR_OUT_POLAR__RB_TMR_CAP_COUNT_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bits 6:7 - RW, timer PWM repeat mode: 00=1, 01=4, 10=8, 11-16;RW, timer capture edge mode: 00=disable, 01=edge change, 10=fall to fall, 11-rise to rise
            #[inline(always)]
            pub fn tmr_pwm_repeat__rb_tmr_cap_edge(&self) -> TMR_PWM_REPEAT__RB_TMR_CAP_EDGE_R {
                TMR_PWM_REPEAT__RB_TMR_CAP_EDGE_R::new((self.bits >> 6) & 3)
            }
        }
        impl W {
            ///Bit 0 - RW, timer in mode: 0=timer_PWM, 1=capture_count
            #[inline(always)]
            #[must_use]
            pub fn tmr_mode_in(&mut self) -> TMR_MODE_IN_W<CTRL_MOD_SPEC> {
                TMR_MODE_IN_W::new(self, 0)
            }
            ///Bit 1 - RW, force clear timer FIFO and count
            #[inline(always)]
            #[must_use]
            pub fn tmr_all_clear(&mut self) -> TMR_ALL_CLEAR_W<CTRL_MOD_SPEC> {
                TMR_ALL_CLEAR_W::new(self, 1)
            }
            ///Bit 2 - RW, timer count enable
            #[inline(always)]
            #[must_use]
            pub fn tmr_count_en(&mut self) -> TMR_COUNT_EN_W<CTRL_MOD_SPEC> {
                TMR_COUNT_EN_W::new(self, 2)
            }
            ///Bit 3 - RW, timer output enable
            #[inline(always)]
            #[must_use]
            pub fn tmr_out_en(&mut self) -> TMR_OUT_EN_W<CTRL_MOD_SPEC> {
                TMR_OUT_EN_W::new(self, 3)
            }
            ///Bit 4 - RW, timer PWM output polarity: 0=default low and high action, 1=default high and low action;RW, count sub-mode if RB_TMR_MODE_IN=1: 0=capture, 1=count
            #[inline(always)]
            #[must_use]
            pub fn tmr_out_polar__rb_tmr_cap_count(
                &mut self,
            ) -> TMR_OUT_POLAR__RB_TMR_CAP_COUNT_W<CTRL_MOD_SPEC> {
                TMR_OUT_POLAR__RB_TMR_CAP_COUNT_W::new(self, 4)
            }
            ///Bits 6:7 - RW, timer PWM repeat mode: 00=1, 01=4, 10=8, 11-16;RW, timer capture edge mode: 00=disable, 01=edge change, 10=fall to fall, 11-rise to rise
            #[inline(always)]
            #[must_use]
            pub fn tmr_pwm_repeat__rb_tmr_cap_edge(
                &mut self,
            ) -> TMR_PWM_REPEAT__RB_TMR_CAP_EDGE_W<CTRL_MOD_SPEC> {
                TMR_PWM_REPEAT__RB_TMR_CAP_EDGE_W::new(self, 6)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW, TMR2 mode control
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`ctrl_mod::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ctrl_mod::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct CTRL_MOD_SPEC;
        impl crate::RegisterSpec for CTRL_MOD_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`ctrl_mod::R`](R) reader structure
        impl crate::Readable for CTRL_MOD_SPEC {}
        ///`write(|w| ..)` method takes [`ctrl_mod::W`](W) writer structure
        impl crate::Writable for CTRL_MOD_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets CTRL_MOD to value 0x02
        impl crate::Resettable for CTRL_MOD_SPEC {
            const RESET_VALUE: u8 = 0x02;
        }
    }
    ///CTRL_DMA (rw) register accessor: RW, TMR2 DMA control
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`ctrl_dma::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ctrl_dma::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@ctrl_dma`]
    ///module
    pub type CTRL_DMA = crate::Reg<ctrl_dma::CTRL_DMA_SPEC>;
    ///RW, TMR2 DMA control
    pub mod ctrl_dma {
        ///Register `CTRL_DMA` reader
        pub type R = crate::R<CTRL_DMA_SPEC>;
        ///Register `CTRL_DMA` writer
        pub type W = crate::W<CTRL_DMA_SPEC>;
        ///Field `TMR_DMA_ENABLE` reader - RW, timer1_2 DMA enable
        pub type TMR_DMA_ENABLE_R = crate::BitReader;
        ///Field `TMR_DMA_ENABLE` writer - RW, timer1_2 DMA enable
        pub type TMR_DMA_ENABLE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TMR_DMA_LOOP` reader - RW, timer1_2 DMA address loop enable
        pub type TMR_DMA_LOOP_R = crate::BitReader;
        ///Field `TMR_DMA_LOOP` writer - RW, timer1_2 DMA address loop enable
        pub type TMR_DMA_LOOP_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - RW, timer1_2 DMA enable
            #[inline(always)]
            pub fn tmr_dma_enable(&self) -> TMR_DMA_ENABLE_R {
                TMR_DMA_ENABLE_R::new((self.bits & 1) != 0)
            }
            ///Bit 2 - RW, timer1_2 DMA address loop enable
            #[inline(always)]
            pub fn tmr_dma_loop(&self) -> TMR_DMA_LOOP_R {
                TMR_DMA_LOOP_R::new(((self.bits >> 2) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RW, timer1_2 DMA enable
            #[inline(always)]
            #[must_use]
            pub fn tmr_dma_enable(&mut self) -> TMR_DMA_ENABLE_W<CTRL_DMA_SPEC> {
                TMR_DMA_ENABLE_W::new(self, 0)
            }
            ///Bit 2 - RW, timer1_2 DMA address loop enable
            #[inline(always)]
            #[must_use]
            pub fn tmr_dma_loop(&mut self) -> TMR_DMA_LOOP_W<CTRL_DMA_SPEC> {
                TMR_DMA_LOOP_W::new(self, 2)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW, TMR2 DMA control
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`ctrl_dma::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ctrl_dma::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct CTRL_DMA_SPEC;
        impl crate::RegisterSpec for CTRL_DMA_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`ctrl_dma::R`](R) reader structure
        impl crate::Readable for CTRL_DMA_SPEC {}
        ///`write(|w| ..)` method takes [`ctrl_dma::W`](W) writer structure
        impl crate::Writable for CTRL_DMA_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets CTRL_DMA to value 0
        impl crate::Resettable for CTRL_DMA_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///INTER_EN (rw) register accessor: RW, TMR2 interrupt enable
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`inter_en::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`inter_en::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@inter_en`]
    ///module
    pub type INTER_EN = crate::Reg<inter_en::INTER_EN_SPEC>;
    ///RW, TMR2 interrupt enable
    pub mod inter_en {
        ///Register `INTER_EN` reader
        pub type R = crate::R<INTER_EN_SPEC>;
        ///Register `INTER_EN` writer
        pub type W = crate::W<INTER_EN_SPEC>;
        ///Field `TMR_IE_CYC_END` reader - RW, enable interrupt for timer capture count timeout or PWM cycle end
        pub type TMR_IE_CYC_END_R = crate::BitReader;
        ///Field `TMR_IE_CYC_END` writer - RW, enable interrupt for timer capture count timeout or PWM cycle end
        pub type TMR_IE_CYC_END_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TMR_IE_DATA_ACT` reader - RW, enable interrupt for timer capture input action or PWM trigger
        pub type TMR_IE_DATA_ACT_R = crate::BitReader;
        ///Field `TMR_IE_DATA_ACT` writer - RW, enable interrupt for timer capture input action or PWM trigger
        pub type TMR_IE_DATA_ACT_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TMR_IE_FIFO_HF` reader - RW, enable interrupt for timer FIFO half (capture fifo >=4 or PWM fifo less than 3)
        pub type TMR_IE_FIFO_HF_R = crate::BitReader;
        ///Field `TMR_IE_FIFO_HF` writer - RW, enable interrupt for timer FIFO half (capture fifo >=4 or PWM fifo less than 3)
        pub type TMR_IE_FIFO_HF_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TMR_IE_DMA_END` reader - RW, enable interrupt for timer1/2 DMA completion
        pub type TMR_IE_DMA_END_R = crate::BitReader;
        ///Field `TMR_IE_DMA_END` writer - RW, enable interrupt for timer1/2 DMA completion
        pub type TMR_IE_DMA_END_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TMR_IE_FIFO_OV` reader - RW, enable interrupt for timer FIFO overflow
        pub type TMR_IE_FIFO_OV_R = crate::BitReader;
        ///Field `TMR_IE_FIFO_OV` writer - RW, enable interrupt for timer FIFO overflow
        pub type TMR_IE_FIFO_OV_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - RW, enable interrupt for timer capture count timeout or PWM cycle end
            #[inline(always)]
            pub fn tmr_ie_cyc_end(&self) -> TMR_IE_CYC_END_R {
                TMR_IE_CYC_END_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RW, enable interrupt for timer capture input action or PWM trigger
            #[inline(always)]
            pub fn tmr_ie_data_act(&self) -> TMR_IE_DATA_ACT_R {
                TMR_IE_DATA_ACT_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RW, enable interrupt for timer FIFO half (capture fifo >=4 or PWM fifo less than 3)
            #[inline(always)]
            pub fn tmr_ie_fifo_hf(&self) -> TMR_IE_FIFO_HF_R {
                TMR_IE_FIFO_HF_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RW, enable interrupt for timer1/2 DMA completion
            #[inline(always)]
            pub fn tmr_ie_dma_end(&self) -> TMR_IE_DMA_END_R {
                TMR_IE_DMA_END_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RW, enable interrupt for timer FIFO overflow
            #[inline(always)]
            pub fn tmr_ie_fifo_ov(&self) -> TMR_IE_FIFO_OV_R {
                TMR_IE_FIFO_OV_R::new(((self.bits >> 4) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RW, enable interrupt for timer capture count timeout or PWM cycle end
            #[inline(always)]
            #[must_use]
            pub fn tmr_ie_cyc_end(&mut self) -> TMR_IE_CYC_END_W<INTER_EN_SPEC> {
                TMR_IE_CYC_END_W::new(self, 0)
            }
            ///Bit 1 - RW, enable interrupt for timer capture input action or PWM trigger
            #[inline(always)]
            #[must_use]
            pub fn tmr_ie_data_act(&mut self) -> TMR_IE_DATA_ACT_W<INTER_EN_SPEC> {
                TMR_IE_DATA_ACT_W::new(self, 1)
            }
            ///Bit 2 - RW, enable interrupt for timer FIFO half (capture fifo >=4 or PWM fifo less than 3)
            #[inline(always)]
            #[must_use]
            pub fn tmr_ie_fifo_hf(&mut self) -> TMR_IE_FIFO_HF_W<INTER_EN_SPEC> {
                TMR_IE_FIFO_HF_W::new(self, 2)
            }
            ///Bit 3 - RW, enable interrupt for timer1/2 DMA completion
            #[inline(always)]
            #[must_use]
            pub fn tmr_ie_dma_end(&mut self) -> TMR_IE_DMA_END_W<INTER_EN_SPEC> {
                TMR_IE_DMA_END_W::new(self, 3)
            }
            ///Bit 4 - RW, enable interrupt for timer FIFO overflow
            #[inline(always)]
            #[must_use]
            pub fn tmr_ie_fifo_ov(&mut self) -> TMR_IE_FIFO_OV_W<INTER_EN_SPEC> {
                TMR_IE_FIFO_OV_W::new(self, 4)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW, TMR2 interrupt enable
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`inter_en::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`inter_en::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct INTER_EN_SPEC;
        impl crate::RegisterSpec for INTER_EN_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`inter_en::R`](R) reader structure
        impl crate::Readable for INTER_EN_SPEC {}
        ///`write(|w| ..)` method takes [`inter_en::W`](W) writer structure
        impl crate::Writable for INTER_EN_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets INTER_EN to value 0
        impl crate::Resettable for INTER_EN_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///INT_FLAG (rw) register accessor: RW1, TMR2 interrupt flag
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`int_flag::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`int_flag::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@int_flag`]
    ///module
    pub type INT_FLAG = crate::Reg<int_flag::INT_FLAG_SPEC>;
    ///RW1, TMR2 interrupt flag
    pub mod int_flag {
        ///Register `INT_FLAG` reader
        pub type R = crate::R<INT_FLAG_SPEC>;
        ///Register `INT_FLAG` writer
        pub type W = crate::W<INT_FLAG_SPEC>;
        ///Field `TMR_IF_CYC_END` reader - RW1, interrupt flag for timer capture count timeout or PWM cycle end
        pub type TMR_IF_CYC_END_R = crate::BitReader;
        ///Field `TMR_IF_CYC_END` writer - RW1, interrupt flag for timer capture count timeout or PWM cycle end
        pub type TMR_IF_CYC_END_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TMR_IF_DATA_ACT` reader - RW1, interrupt flag for timer capture input action or PWM trigger
        pub type TMR_IF_DATA_ACT_R = crate::BitReader;
        ///Field `TMR_IF_DATA_ACT` writer - RW1, interrupt flag for timer capture input action or PWM trigger
        pub type TMR_IF_DATA_ACT_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TMR_IF_FIFO_HF` reader - RW1, interrupt flag for timer FIFO half (capture fifo >=4 or PWM fifo less than 3
        pub type TMR_IF_FIFO_HF_R = crate::BitReader;
        ///Field `TMR_IF_FIFO_HF` writer - RW1, interrupt flag for timer FIFO half (capture fifo >=4 or PWM fifo less than 3
        pub type TMR_IF_FIFO_HF_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TMR_IF_DMA_END` reader - RW1, interrupt flag for timer1/2 DMA completion
        pub type TMR_IF_DMA_END_R = crate::BitReader;
        ///Field `TMR_IF_DMA_END` writer - RW1, interrupt flag for timer1/2 DMA completion
        pub type TMR_IF_DMA_END_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TMR_IF_FIFO_OV` reader - RW1, interrupt flag for timer FIFO overflow
        pub type TMR_IF_FIFO_OV_R = crate::BitReader;
        ///Field `TMR_IF_FIFO_OV` writer - RW1, interrupt flag for timer FIFO overflow
        pub type TMR_IF_FIFO_OV_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - RW1, interrupt flag for timer capture count timeout or PWM cycle end
            #[inline(always)]
            pub fn tmr_if_cyc_end(&self) -> TMR_IF_CYC_END_R {
                TMR_IF_CYC_END_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RW1, interrupt flag for timer capture input action or PWM trigger
            #[inline(always)]
            pub fn tmr_if_data_act(&self) -> TMR_IF_DATA_ACT_R {
                TMR_IF_DATA_ACT_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RW1, interrupt flag for timer FIFO half (capture fifo >=4 or PWM fifo less than 3
            #[inline(always)]
            pub fn tmr_if_fifo_hf(&self) -> TMR_IF_FIFO_HF_R {
                TMR_IF_FIFO_HF_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RW1, interrupt flag for timer1/2 DMA completion
            #[inline(always)]
            pub fn tmr_if_dma_end(&self) -> TMR_IF_DMA_END_R {
                TMR_IF_DMA_END_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RW1, interrupt flag for timer FIFO overflow
            #[inline(always)]
            pub fn tmr_if_fifo_ov(&self) -> TMR_IF_FIFO_OV_R {
                TMR_IF_FIFO_OV_R::new(((self.bits >> 4) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RW1, interrupt flag for timer capture count timeout or PWM cycle end
            #[inline(always)]
            #[must_use]
            pub fn tmr_if_cyc_end(&mut self) -> TMR_IF_CYC_END_W<INT_FLAG_SPEC> {
                TMR_IF_CYC_END_W::new(self, 0)
            }
            ///Bit 1 - RW1, interrupt flag for timer capture input action or PWM trigger
            #[inline(always)]
            #[must_use]
            pub fn tmr_if_data_act(&mut self) -> TMR_IF_DATA_ACT_W<INT_FLAG_SPEC> {
                TMR_IF_DATA_ACT_W::new(self, 1)
            }
            ///Bit 2 - RW1, interrupt flag for timer FIFO half (capture fifo >=4 or PWM fifo less than 3
            #[inline(always)]
            #[must_use]
            pub fn tmr_if_fifo_hf(&mut self) -> TMR_IF_FIFO_HF_W<INT_FLAG_SPEC> {
                TMR_IF_FIFO_HF_W::new(self, 2)
            }
            ///Bit 3 - RW1, interrupt flag for timer1/2 DMA completion
            #[inline(always)]
            #[must_use]
            pub fn tmr_if_dma_end(&mut self) -> TMR_IF_DMA_END_W<INT_FLAG_SPEC> {
                TMR_IF_DMA_END_W::new(self, 3)
            }
            ///Bit 4 - RW1, interrupt flag for timer FIFO overflow
            #[inline(always)]
            #[must_use]
            pub fn tmr_if_fifo_ov(&mut self) -> TMR_IF_FIFO_OV_W<INT_FLAG_SPEC> {
                TMR_IF_FIFO_OV_W::new(self, 4)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW1, TMR2 interrupt flag
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`int_flag::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`int_flag::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct INT_FLAG_SPEC;
        impl crate::RegisterSpec for INT_FLAG_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`int_flag::R`](R) reader structure
        impl crate::Readable for INT_FLAG_SPEC {}
        ///`write(|w| ..)` method takes [`int_flag::W`](W) writer structure
        impl crate::Writable for INT_FLAG_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets INT_FLAG to value 0
        impl crate::Resettable for INT_FLAG_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///FIFO_COUNT (r) register accessor: RO, TMR2 FIFO count status
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`fifo_count::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@fifo_count`]
    ///module
    pub type FIFO_COUNT = crate::Reg<fifo_count::FIFO_COUNT_SPEC>;
    ///RO, TMR2 FIFO count status
    pub mod fifo_count {
        ///Register `FIFO_COUNT` reader
        pub type R = crate::R<FIFO_COUNT_SPEC>;
        ///Field `FIFO_COUNT` reader - RW, TMR2 FIFO count status
        pub type FIFO_COUNT_R = crate::FieldReader;
        impl R {
            ///Bits 0:7 - RW, TMR2 FIFO count status
            #[inline(always)]
            pub fn fifo_count(&self) -> FIFO_COUNT_R {
                FIFO_COUNT_R::new(self.bits)
            }
        }
        ///RO, TMR2 FIFO count status
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`fifo_count::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct FIFO_COUNT_SPEC;
        impl crate::RegisterSpec for FIFO_COUNT_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`fifo_count::R`](R) reader structure
        impl crate::Readable for FIFO_COUNT_SPEC {}
        ///`reset()` method sets FIFO_COUNT to value 0
        impl crate::Resettable for FIFO_COUNT_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///COUNT (r) register accessor: RO, TMR2 current count
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`count::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@count`]
    ///module
    pub type COUNT = crate::Reg<count::COUNT_SPEC>;
    ///RO, TMR2 current count
    pub mod count {
        ///Register `COUNT` reader
        pub type R = crate::R<COUNT_SPEC>;
        ///Field `COUNT` reader - RW, TMR2 current count
        pub type COUNT_R = crate::FieldReader<u32>;
        impl R {
            ///Bits 0:31 - RW, TMR2 current count
            #[inline(always)]
            pub fn count(&self) -> COUNT_R {
                COUNT_R::new(self.bits)
            }
        }
        ///RO, TMR2 current count
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`count::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct COUNT_SPEC;
        impl crate::RegisterSpec for COUNT_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`count::R`](R) reader structure
        impl crate::Readable for COUNT_SPEC {}
        ///`reset()` method sets COUNT to value 0
        impl crate::Resettable for COUNT_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///CNT_END (rw) register accessor: RW, TMR2 end count value, only low 26 bit
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`cnt_end::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cnt_end::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@cnt_end`]
    ///module
    pub type CNT_END = crate::Reg<cnt_end::CNT_END_SPEC>;
    ///RW, TMR2 end count value, only low 26 bit
    pub mod cnt_end {
        ///Register `CNT_END` reader
        pub type R = crate::R<CNT_END_SPEC>;
        ///Register `CNT_END` writer
        pub type W = crate::W<CNT_END_SPEC>;
        ///Field `COUNT` reader - RW, TMR2 current count
        pub type COUNT_R = crate::FieldReader<u32>;
        ///Field `COUNT` writer - RW, TMR2 current count
        pub type COUNT_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - RW, TMR2 current count
            #[inline(always)]
            pub fn count(&self) -> COUNT_R {
                COUNT_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW, TMR2 current count
            #[inline(always)]
            #[must_use]
            pub fn count(&mut self) -> COUNT_W<CNT_END_SPEC> {
                COUNT_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW, TMR2 end count value, only low 26 bit
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`cnt_end::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cnt_end::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct CNT_END_SPEC;
        impl crate::RegisterSpec for CNT_END_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`cnt_end::R`](R) reader structure
        impl crate::Readable for CNT_END_SPEC {}
        ///`write(|w| ..)` method takes [`cnt_end::W`](W) writer structure
        impl crate::Writable for CNT_END_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets CNT_END to value 0
        impl crate::Resettable for CNT_END_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///FIFO (rw) register accessor: RO, TMR2 FIFO register, only low 26 bit
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`fifo::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`fifo::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@fifo`]
    ///module
    pub type FIFO = crate::Reg<fifo::FIFO_SPEC>;
    ///RO, TMR2 FIFO register, only low 26 bit
    pub mod fifo {
        ///Register `FIFO` reader
        pub type R = crate::R<FIFO_SPEC>;
        ///Register `FIFO` writer
        pub type W = crate::W<FIFO_SPEC>;
        ///Field `FIFO` reader - RW, TMR2 current count
        pub type FIFO_R = crate::FieldReader<u32>;
        ///Field `FIFO` writer - RW, TMR2 current count
        pub type FIFO_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - RW, TMR2 current count
            #[inline(always)]
            pub fn fifo(&self) -> FIFO_R {
                FIFO_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW, TMR2 current count
            #[inline(always)]
            #[must_use]
            pub fn fifo(&mut self) -> FIFO_W<FIFO_SPEC> {
                FIFO_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RO, TMR2 FIFO register, only low 26 bit
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`fifo::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`fifo::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct FIFO_SPEC;
        impl crate::RegisterSpec for FIFO_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`fifo::R`](R) reader structure
        impl crate::Readable for FIFO_SPEC {}
        ///`write(|w| ..)` method takes [`fifo::W`](W) writer structure
        impl crate::Writable for FIFO_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets FIFO to value 0
        impl crate::Resettable for FIFO_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///DMA_NOW (r) register accessor: RO, TMR2 DMA current address
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`dma_now::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@dma_now`]
    ///module
    pub type DMA_NOW = crate::Reg<dma_now::DMA_NOW_SPEC>;
    ///RO, TMR2 DMA current address
    pub mod dma_now {
        ///Register `DMA_NOW` reader
        pub type R = crate::R<DMA_NOW_SPEC>;
        ///Field `DMA_NOW` reader - RW, TMR2 current count
        pub type DMA_NOW_R = crate::FieldReader<u16>;
        impl R {
            ///Bits 0:15 - RW, TMR2 current count
            #[inline(always)]
            pub fn dma_now(&self) -> DMA_NOW_R {
                DMA_NOW_R::new(self.bits)
            }
        }
        ///RO, TMR2 DMA current address
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`dma_now::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct DMA_NOW_SPEC;
        impl crate::RegisterSpec for DMA_NOW_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`dma_now::R`](R) reader structure
        impl crate::Readable for DMA_NOW_SPEC {}
        ///`reset()` method sets DMA_NOW to value 0
        impl crate::Resettable for DMA_NOW_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///DMA_BEG (rw) register accessor: RW, TMR2 DMA begin address
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`dma_beg::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dma_beg::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@dma_beg`]
    ///module
    pub type DMA_BEG = crate::Reg<dma_beg::DMA_BEG_SPEC>;
    ///RW, TMR2 DMA begin address
    pub mod dma_beg {
        ///Register `DMA_BEG` reader
        pub type R = crate::R<DMA_BEG_SPEC>;
        ///Register `DMA_BEG` writer
        pub type W = crate::W<DMA_BEG_SPEC>;
        ///Field `DMA_BEG` reader - RW, TMR2 DMA begin address
        pub type DMA_BEG_R = crate::FieldReader<u16>;
        ///Field `DMA_BEG` writer - RW, TMR2 DMA begin address
        pub type DMA_BEG_W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            ///Bits 0:15 - RW, TMR2 DMA begin address
            #[inline(always)]
            pub fn dma_beg(&self) -> DMA_BEG_R {
                DMA_BEG_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - RW, TMR2 DMA begin address
            #[inline(always)]
            #[must_use]
            pub fn dma_beg(&mut self) -> DMA_BEG_W<DMA_BEG_SPEC> {
                DMA_BEG_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW, TMR2 DMA begin address
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`dma_beg::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dma_beg::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct DMA_BEG_SPEC;
        impl crate::RegisterSpec for DMA_BEG_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`dma_beg::R`](R) reader structure
        impl crate::Readable for DMA_BEG_SPEC {}
        ///`write(|w| ..)` method takes [`dma_beg::W`](W) writer structure
        impl crate::Writable for DMA_BEG_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets DMA_BEG to value 0
        impl crate::Resettable for DMA_BEG_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///DMA_END (rw) register accessor: RW, TMR2 DMA end address
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`dma_end::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dma_end::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@dma_end`]
    ///module
    pub type DMA_END = crate::Reg<dma_end::DMA_END_SPEC>;
    ///RW, TMR2 DMA end address
    pub mod dma_end {
        ///Register `DMA_END` reader
        pub type R = crate::R<DMA_END_SPEC>;
        ///Register `DMA_END` writer
        pub type W = crate::W<DMA_END_SPEC>;
        ///Field `DMA_END` reader - RW, TMR2 DMA end address
        pub type DMA_END_R = crate::FieldReader<u16>;
        ///Field `DMA_END` writer - RW, TMR2 DMA end address
        pub type DMA_END_W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            ///Bits 0:15 - RW, TMR2 DMA end address
            #[inline(always)]
            pub fn dma_end(&self) -> DMA_END_R {
                DMA_END_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - RW, TMR2 DMA end address
            #[inline(always)]
            #[must_use]
            pub fn dma_end(&mut self) -> DMA_END_W<DMA_END_SPEC> {
                DMA_END_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW, TMR2 DMA end address
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`dma_end::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dma_end::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct DMA_END_SPEC;
        impl crate::RegisterSpec for DMA_END_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`dma_end::R`](R) reader structure
        impl crate::Readable for DMA_END_SPEC {}
        ///`write(|w| ..)` method takes [`dma_end::W`](W) writer structure
        impl crate::Writable for DMA_END_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets DMA_END to value 0
        impl crate::Resettable for DMA_END_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
}
///Timer3 register
pub struct TMR3 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for TMR3 {}
impl TMR3 {
    ///Pointer to the register block
    pub const PTR: *const tmr3::RegisterBlock = 0x4000_2c00 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const tmr3::RegisterBlock {
        Self::PTR
    }
    /// Steal an instance of this peripheral
    ///
    /// # Safety
    ///
    /// Ensure that the new instance of the peripheral cannot be used in a way
    /// that may race with any existing instances, for example by only
    /// accessing read-only or write-only registers, or by consuming the
    /// original peripheral and using critical sections to coordinate
    /// access between multiple new instances.
    ///
    /// Additionally, other software such as HALs may rely on only one
    /// peripheral instance existing to ensure memory safety; ensure
    /// no stolen instances are passed to such software.
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for TMR3 {
    type Target = tmr3::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for TMR3 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("TMR3").finish()
    }
}
///Timer3 register
pub mod tmr3 {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        ctrl_mod: CTRL_MOD,
        _reserved1: [u8; 0x01],
        inter_en: INTER_EN,
        _reserved2: [u8; 0x03],
        int_flag: INT_FLAG,
        fifo_count: FIFO_COUNT,
        count: COUNT,
        cnt_end: CNT_END,
        fifo: FIFO,
    }
    impl RegisterBlock {
        ///0x00 - RW, TMR3 mode control
        #[inline(always)]
        pub const fn ctrl_mod(&self) -> &CTRL_MOD {
            &self.ctrl_mod
        }
        ///0x02 - RW, TMR3 interrupt enable
        #[inline(always)]
        pub const fn inter_en(&self) -> &INTER_EN {
            &self.inter_en
        }
        ///0x06 - RW1, TMR3 interrupt flag
        #[inline(always)]
        pub const fn int_flag(&self) -> &INT_FLAG {
            &self.int_flag
        }
        ///0x07 - RO, TMR3 FIFO count status
        #[inline(always)]
        pub const fn fifo_count(&self) -> &FIFO_COUNT {
            &self.fifo_count
        }
        ///0x08 - RO, TMR3 current count
        #[inline(always)]
        pub const fn count(&self) -> &COUNT {
            &self.count
        }
        ///0x0c - RW, TMR3 end count value, only low 26 bit
        #[inline(always)]
        pub const fn cnt_end(&self) -> &CNT_END {
            &self.cnt_end
        }
        ///0x10 - RO/WO, TMR3 FIFO register, only low 26 bit
        #[inline(always)]
        pub const fn fifo(&self) -> &FIFO {
            &self.fifo
        }
    }
    ///CTRL_MOD (rw) register accessor: RW, TMR3 mode control
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`ctrl_mod::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ctrl_mod::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@ctrl_mod`]
    ///module
    pub type CTRL_MOD = crate::Reg<ctrl_mod::CTRL_MOD_SPEC>;
    ///RW, TMR3 mode control
    pub mod ctrl_mod {
        ///Register `CTRL_MOD` reader
        pub type R = crate::R<CTRL_MOD_SPEC>;
        ///Register `CTRL_MOD` writer
        pub type W = crate::W<CTRL_MOD_SPEC>;
        ///Field `TMR_MODE_IN` reader - RW, timer in mode: 0=timer/PWM, 1=capture/count
        pub type TMR_MODE_IN_R = crate::BitReader;
        ///Field `TMR_MODE_IN` writer - RW, timer in mode: 0=timer/PWM, 1=capture/count
        pub type TMR_MODE_IN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TMR_ALL_CLEAR` reader - RW, force clear timer FIFO and count
        pub type TMR_ALL_CLEAR_R = crate::BitReader;
        ///Field `TMR_ALL_CLEAR` writer - RW, force clear timer FIFO and count
        pub type TMR_ALL_CLEAR_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TMR_COUNT_EN` reader - RW, timer count enable
        pub type TMR_COUNT_EN_R = crate::BitReader;
        ///Field `TMR_COUNT_EN` writer - RW, timer count enable
        pub type TMR_COUNT_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TMR_OUT_EN` reader - RW, timer output enable
        pub type TMR_OUT_EN_R = crate::BitReader;
        ///Field `TMR_OUT_EN` writer - RW, timer output enable
        pub type TMR_OUT_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TMR_OUT_POLAR__RB_TMR_CAP_COUNT` reader - RW, timer PWM output polarity: 0=default low and high action, 1=default high and low action;RW, count sub-mode if RB_TMR_MODE_IN=1: 0=capture, 1=count
        pub type TMR_OUT_POLAR__RB_TMR_CAP_COUNT_R = crate::BitReader;
        ///Field `TMR_OUT_POLAR__RB_TMR_CAP_COUNT` writer - RW, timer PWM output polarity: 0=default low and high action, 1=default high and low action;RW, count sub-mode if RB_TMR_MODE_IN=1: 0=capture, 1=count
        pub type TMR_OUT_POLAR__RB_TMR_CAP_COUNT_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TMR_PWM_REPEAT__RB_TMR_CAP_EDGE` reader - RW, timer PWM repeat mode: 00=1, 01=4, 10=8, 11-16;RW, timer capture edge mode: 00=disable, 01=edge change, 10=fall to fall, 11-rise to rise
        pub type TMR_PWM_REPEAT__RB_TMR_CAP_EDGE_R = crate::FieldReader;
        ///Field `TMR_PWM_REPEAT__RB_TMR_CAP_EDGE` writer - RW, timer PWM repeat mode: 00=1, 01=4, 10=8, 11-16;RW, timer capture edge mode: 00=disable, 01=edge change, 10=fall to fall, 11-rise to rise
        pub type TMR_PWM_REPEAT__RB_TMR_CAP_EDGE_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        impl R {
            ///Bit 0 - RW, timer in mode: 0=timer/PWM, 1=capture/count
            #[inline(always)]
            pub fn tmr_mode_in(&self) -> TMR_MODE_IN_R {
                TMR_MODE_IN_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RW, force clear timer FIFO and count
            #[inline(always)]
            pub fn tmr_all_clear(&self) -> TMR_ALL_CLEAR_R {
                TMR_ALL_CLEAR_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RW, timer count enable
            #[inline(always)]
            pub fn tmr_count_en(&self) -> TMR_COUNT_EN_R {
                TMR_COUNT_EN_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RW, timer output enable
            #[inline(always)]
            pub fn tmr_out_en(&self) -> TMR_OUT_EN_R {
                TMR_OUT_EN_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RW, timer PWM output polarity: 0=default low and high action, 1=default high and low action;RW, count sub-mode if RB_TMR_MODE_IN=1: 0=capture, 1=count
            #[inline(always)]
            pub fn tmr_out_polar__rb_tmr_cap_count(&self) -> TMR_OUT_POLAR__RB_TMR_CAP_COUNT_R {
                TMR_OUT_POLAR__RB_TMR_CAP_COUNT_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bits 6:7 - RW, timer PWM repeat mode: 00=1, 01=4, 10=8, 11-16;RW, timer capture edge mode: 00=disable, 01=edge change, 10=fall to fall, 11-rise to rise
            #[inline(always)]
            pub fn tmr_pwm_repeat__rb_tmr_cap_edge(&self) -> TMR_PWM_REPEAT__RB_TMR_CAP_EDGE_R {
                TMR_PWM_REPEAT__RB_TMR_CAP_EDGE_R::new((self.bits >> 6) & 3)
            }
        }
        impl W {
            ///Bit 0 - RW, timer in mode: 0=timer/PWM, 1=capture/count
            #[inline(always)]
            #[must_use]
            pub fn tmr_mode_in(&mut self) -> TMR_MODE_IN_W<CTRL_MOD_SPEC> {
                TMR_MODE_IN_W::new(self, 0)
            }
            ///Bit 1 - RW, force clear timer FIFO and count
            #[inline(always)]
            #[must_use]
            pub fn tmr_all_clear(&mut self) -> TMR_ALL_CLEAR_W<CTRL_MOD_SPEC> {
                TMR_ALL_CLEAR_W::new(self, 1)
            }
            ///Bit 2 - RW, timer count enable
            #[inline(always)]
            #[must_use]
            pub fn tmr_count_en(&mut self) -> TMR_COUNT_EN_W<CTRL_MOD_SPEC> {
                TMR_COUNT_EN_W::new(self, 2)
            }
            ///Bit 3 - RW, timer output enable
            #[inline(always)]
            #[must_use]
            pub fn tmr_out_en(&mut self) -> TMR_OUT_EN_W<CTRL_MOD_SPEC> {
                TMR_OUT_EN_W::new(self, 3)
            }
            ///Bit 4 - RW, timer PWM output polarity: 0=default low and high action, 1=default high and low action;RW, count sub-mode if RB_TMR_MODE_IN=1: 0=capture, 1=count
            #[inline(always)]
            #[must_use]
            pub fn tmr_out_polar__rb_tmr_cap_count(
                &mut self,
            ) -> TMR_OUT_POLAR__RB_TMR_CAP_COUNT_W<CTRL_MOD_SPEC> {
                TMR_OUT_POLAR__RB_TMR_CAP_COUNT_W::new(self, 4)
            }
            ///Bits 6:7 - RW, timer PWM repeat mode: 00=1, 01=4, 10=8, 11-16;RW, timer capture edge mode: 00=disable, 01=edge change, 10=fall to fall, 11-rise to rise
            #[inline(always)]
            #[must_use]
            pub fn tmr_pwm_repeat__rb_tmr_cap_edge(
                &mut self,
            ) -> TMR_PWM_REPEAT__RB_TMR_CAP_EDGE_W<CTRL_MOD_SPEC> {
                TMR_PWM_REPEAT__RB_TMR_CAP_EDGE_W::new(self, 6)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW, TMR3 mode control
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`ctrl_mod::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ctrl_mod::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct CTRL_MOD_SPEC;
        impl crate::RegisterSpec for CTRL_MOD_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`ctrl_mod::R`](R) reader structure
        impl crate::Readable for CTRL_MOD_SPEC {}
        ///`write(|w| ..)` method takes [`ctrl_mod::W`](W) writer structure
        impl crate::Writable for CTRL_MOD_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets CTRL_MOD to value 0x02
        impl crate::Resettable for CTRL_MOD_SPEC {
            const RESET_VALUE: u8 = 0x02;
        }
    }
    ///INTER_EN (rw) register accessor: RW, TMR3 interrupt enable
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`inter_en::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`inter_en::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@inter_en`]
    ///module
    pub type INTER_EN = crate::Reg<inter_en::INTER_EN_SPEC>;
    ///RW, TMR3 interrupt enable
    pub mod inter_en {
        ///Register `INTER_EN` reader
        pub type R = crate::R<INTER_EN_SPEC>;
        ///Register `INTER_EN` writer
        pub type W = crate::W<INTER_EN_SPEC>;
        ///Field `TMR_IE_CYC_END` reader - RW, enable interrupt for timer capture count timeout or PWM cycle end
        pub type TMR_IE_CYC_END_R = crate::BitReader;
        ///Field `TMR_IE_CYC_END` writer - RW, enable interrupt for timer capture count timeout or PWM cycle end
        pub type TMR_IE_CYC_END_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TMR_IE_DATA_ACT` reader - RW, enable interrupt for timer capture input action or PWM trigger
        pub type TMR_IE_DATA_ACT_R = crate::BitReader;
        ///Field `TMR_IE_DATA_ACT` writer - RW, enable interrupt for timer capture input action or PWM trigger
        pub type TMR_IE_DATA_ACT_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TMR_IE_FIFO_HF` reader - RW, enable interrupt for timer FIFO half (capture fifo >=4 or PWM fifo less than 3)
        pub type TMR_IE_FIFO_HF_R = crate::BitReader;
        ///Field `TMR_IE_FIFO_HF` writer - RW, enable interrupt for timer FIFO half (capture fifo >=4 or PWM fifo less than 3)
        pub type TMR_IE_FIFO_HF_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TMR_IE_DMA_END` reader - RW, enable interrupt for timer1/2 DMA completion
        pub type TMR_IE_DMA_END_R = crate::BitReader;
        ///Field `TMR_IE_DMA_END` writer - RW, enable interrupt for timer1/2 DMA completion
        pub type TMR_IE_DMA_END_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TMR_IE_FIFO_OV` reader - RW, enable interrupt for timer FIFO overflow
        pub type TMR_IE_FIFO_OV_R = crate::BitReader;
        ///Field `TMR_IE_FIFO_OV` writer - RW, enable interrupt for timer FIFO overflow
        pub type TMR_IE_FIFO_OV_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - RW, enable interrupt for timer capture count timeout or PWM cycle end
            #[inline(always)]
            pub fn tmr_ie_cyc_end(&self) -> TMR_IE_CYC_END_R {
                TMR_IE_CYC_END_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RW, enable interrupt for timer capture input action or PWM trigger
            #[inline(always)]
            pub fn tmr_ie_data_act(&self) -> TMR_IE_DATA_ACT_R {
                TMR_IE_DATA_ACT_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RW, enable interrupt for timer FIFO half (capture fifo >=4 or PWM fifo less than 3)
            #[inline(always)]
            pub fn tmr_ie_fifo_hf(&self) -> TMR_IE_FIFO_HF_R {
                TMR_IE_FIFO_HF_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RW, enable interrupt for timer1/2 DMA completion
            #[inline(always)]
            pub fn tmr_ie_dma_end(&self) -> TMR_IE_DMA_END_R {
                TMR_IE_DMA_END_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RW, enable interrupt for timer FIFO overflow
            #[inline(always)]
            pub fn tmr_ie_fifo_ov(&self) -> TMR_IE_FIFO_OV_R {
                TMR_IE_FIFO_OV_R::new(((self.bits >> 4) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RW, enable interrupt for timer capture count timeout or PWM cycle end
            #[inline(always)]
            #[must_use]
            pub fn tmr_ie_cyc_end(&mut self) -> TMR_IE_CYC_END_W<INTER_EN_SPEC> {
                TMR_IE_CYC_END_W::new(self, 0)
            }
            ///Bit 1 - RW, enable interrupt for timer capture input action or PWM trigger
            #[inline(always)]
            #[must_use]
            pub fn tmr_ie_data_act(&mut self) -> TMR_IE_DATA_ACT_W<INTER_EN_SPEC> {
                TMR_IE_DATA_ACT_W::new(self, 1)
            }
            ///Bit 2 - RW, enable interrupt for timer FIFO half (capture fifo >=4 or PWM fifo less than 3)
            #[inline(always)]
            #[must_use]
            pub fn tmr_ie_fifo_hf(&mut self) -> TMR_IE_FIFO_HF_W<INTER_EN_SPEC> {
                TMR_IE_FIFO_HF_W::new(self, 2)
            }
            ///Bit 3 - RW, enable interrupt for timer1/2 DMA completion
            #[inline(always)]
            #[must_use]
            pub fn tmr_ie_dma_end(&mut self) -> TMR_IE_DMA_END_W<INTER_EN_SPEC> {
                TMR_IE_DMA_END_W::new(self, 3)
            }
            ///Bit 4 - RW, enable interrupt for timer FIFO overflow
            #[inline(always)]
            #[must_use]
            pub fn tmr_ie_fifo_ov(&mut self) -> TMR_IE_FIFO_OV_W<INTER_EN_SPEC> {
                TMR_IE_FIFO_OV_W::new(self, 4)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW, TMR3 interrupt enable
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`inter_en::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`inter_en::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct INTER_EN_SPEC;
        impl crate::RegisterSpec for INTER_EN_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`inter_en::R`](R) reader structure
        impl crate::Readable for INTER_EN_SPEC {}
        ///`write(|w| ..)` method takes [`inter_en::W`](W) writer structure
        impl crate::Writable for INTER_EN_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets INTER_EN to value 0
        impl crate::Resettable for INTER_EN_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///INT_FLAG (rw) register accessor: RW1, TMR3 interrupt flag
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`int_flag::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`int_flag::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@int_flag`]
    ///module
    pub type INT_FLAG = crate::Reg<int_flag::INT_FLAG_SPEC>;
    ///RW1, TMR3 interrupt flag
    pub mod int_flag {
        ///Register `INT_FLAG` reader
        pub type R = crate::R<INT_FLAG_SPEC>;
        ///Register `INT_FLAG` writer
        pub type W = crate::W<INT_FLAG_SPEC>;
        ///Field `TMR_IF_CYC_END` reader - RW1, interrupt flag for timer capture count timeout or PWM cycle end
        pub type TMR_IF_CYC_END_R = crate::BitReader;
        ///Field `TMR_IF_CYC_END` writer - RW1, interrupt flag for timer capture count timeout or PWM cycle end
        pub type TMR_IF_CYC_END_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TMR_IF_DATA_ACT` reader - RW1, interrupt flag for timer capture input action or PWM trigger
        pub type TMR_IF_DATA_ACT_R = crate::BitReader;
        ///Field `TMR_IF_DATA_ACT` writer - RW1, interrupt flag for timer capture input action or PWM trigger
        pub type TMR_IF_DATA_ACT_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TMR_IF_FIFO_HF` reader - RW1, interrupt flag for timer FIFO half (capture fifo >=4 or PWM fifo less than 3
        pub type TMR_IF_FIFO_HF_R = crate::BitReader;
        ///Field `TMR_IF_FIFO_HF` writer - RW1, interrupt flag for timer FIFO half (capture fifo >=4 or PWM fifo less than 3
        pub type TMR_IF_FIFO_HF_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TMR_IF_DMA_END` reader - RW1, interrupt flag for timer1/2 DMA completion
        pub type TMR_IF_DMA_END_R = crate::BitReader;
        ///Field `TMR_IF_DMA_END` writer - RW1, interrupt flag for timer1/2 DMA completion
        pub type TMR_IF_DMA_END_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TMR_IF_FIFO_OV` reader - RW1, interrupt flag for timer FIFO overflow
        pub type TMR_IF_FIFO_OV_R = crate::BitReader;
        ///Field `TMR_IF_FIFO_OV` writer - RW1, interrupt flag for timer FIFO overflow
        pub type TMR_IF_FIFO_OV_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - RW1, interrupt flag for timer capture count timeout or PWM cycle end
            #[inline(always)]
            pub fn tmr_if_cyc_end(&self) -> TMR_IF_CYC_END_R {
                TMR_IF_CYC_END_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RW1, interrupt flag for timer capture input action or PWM trigger
            #[inline(always)]
            pub fn tmr_if_data_act(&self) -> TMR_IF_DATA_ACT_R {
                TMR_IF_DATA_ACT_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RW1, interrupt flag for timer FIFO half (capture fifo >=4 or PWM fifo less than 3
            #[inline(always)]
            pub fn tmr_if_fifo_hf(&self) -> TMR_IF_FIFO_HF_R {
                TMR_IF_FIFO_HF_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RW1, interrupt flag for timer1/2 DMA completion
            #[inline(always)]
            pub fn tmr_if_dma_end(&self) -> TMR_IF_DMA_END_R {
                TMR_IF_DMA_END_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RW1, interrupt flag for timer FIFO overflow
            #[inline(always)]
            pub fn tmr_if_fifo_ov(&self) -> TMR_IF_FIFO_OV_R {
                TMR_IF_FIFO_OV_R::new(((self.bits >> 4) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RW1, interrupt flag for timer capture count timeout or PWM cycle end
            #[inline(always)]
            #[must_use]
            pub fn tmr_if_cyc_end(&mut self) -> TMR_IF_CYC_END_W<INT_FLAG_SPEC> {
                TMR_IF_CYC_END_W::new(self, 0)
            }
            ///Bit 1 - RW1, interrupt flag for timer capture input action or PWM trigger
            #[inline(always)]
            #[must_use]
            pub fn tmr_if_data_act(&mut self) -> TMR_IF_DATA_ACT_W<INT_FLAG_SPEC> {
                TMR_IF_DATA_ACT_W::new(self, 1)
            }
            ///Bit 2 - RW1, interrupt flag for timer FIFO half (capture fifo >=4 or PWM fifo less than 3
            #[inline(always)]
            #[must_use]
            pub fn tmr_if_fifo_hf(&mut self) -> TMR_IF_FIFO_HF_W<INT_FLAG_SPEC> {
                TMR_IF_FIFO_HF_W::new(self, 2)
            }
            ///Bit 3 - RW1, interrupt flag for timer1/2 DMA completion
            #[inline(always)]
            #[must_use]
            pub fn tmr_if_dma_end(&mut self) -> TMR_IF_DMA_END_W<INT_FLAG_SPEC> {
                TMR_IF_DMA_END_W::new(self, 3)
            }
            ///Bit 4 - RW1, interrupt flag for timer FIFO overflow
            #[inline(always)]
            #[must_use]
            pub fn tmr_if_fifo_ov(&mut self) -> TMR_IF_FIFO_OV_W<INT_FLAG_SPEC> {
                TMR_IF_FIFO_OV_W::new(self, 4)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW1, TMR3 interrupt flag
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`int_flag::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`int_flag::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct INT_FLAG_SPEC;
        impl crate::RegisterSpec for INT_FLAG_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`int_flag::R`](R) reader structure
        impl crate::Readable for INT_FLAG_SPEC {}
        ///`write(|w| ..)` method takes [`int_flag::W`](W) writer structure
        impl crate::Writable for INT_FLAG_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets INT_FLAG to value 0
        impl crate::Resettable for INT_FLAG_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///FIFO_COUNT (r) register accessor: RO, TMR3 FIFO count status
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`fifo_count::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@fifo_count`]
    ///module
    pub type FIFO_COUNT = crate::Reg<fifo_count::FIFO_COUNT_SPEC>;
    ///RO, TMR3 FIFO count status
    pub mod fifo_count {
        ///Register `FIFO_COUNT` reader
        pub type R = crate::R<FIFO_COUNT_SPEC>;
        ///Field `FIFO_COUNT` reader - R0, TMR3 FIFO count status
        pub type FIFO_COUNT_R = crate::FieldReader;
        impl R {
            ///Bits 0:7 - R0, TMR3 FIFO count status
            #[inline(always)]
            pub fn fifo_count(&self) -> FIFO_COUNT_R {
                FIFO_COUNT_R::new(self.bits)
            }
        }
        ///RO, TMR3 FIFO count status
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`fifo_count::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct FIFO_COUNT_SPEC;
        impl crate::RegisterSpec for FIFO_COUNT_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`fifo_count::R`](R) reader structure
        impl crate::Readable for FIFO_COUNT_SPEC {}
        ///`reset()` method sets FIFO_COUNT to value 0
        impl crate::Resettable for FIFO_COUNT_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///COUNT (r) register accessor: RO, TMR3 current count
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`count::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@count`]
    ///module
    pub type COUNT = crate::Reg<count::COUNT_SPEC>;
    ///RO, TMR3 current count
    pub mod count {
        ///Register `COUNT` reader
        pub type R = crate::R<COUNT_SPEC>;
        ///Field `COUNT` reader - R0, TMR3 current count
        pub type COUNT_R = crate::FieldReader<u32>;
        impl R {
            ///Bits 0:31 - R0, TMR3 current count
            #[inline(always)]
            pub fn count(&self) -> COUNT_R {
                COUNT_R::new(self.bits)
            }
        }
        ///RO, TMR3 current count
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`count::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct COUNT_SPEC;
        impl crate::RegisterSpec for COUNT_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`count::R`](R) reader structure
        impl crate::Readable for COUNT_SPEC {}
        ///`reset()` method sets COUNT to value 0
        impl crate::Resettable for COUNT_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///CNT_END (rw) register accessor: RW, TMR3 end count value, only low 26 bit
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`cnt_end::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cnt_end::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@cnt_end`]
    ///module
    pub type CNT_END = crate::Reg<cnt_end::CNT_END_SPEC>;
    ///RW, TMR3 end count value, only low 26 bit
    pub mod cnt_end {
        ///Register `CNT_END` reader
        pub type R = crate::R<CNT_END_SPEC>;
        ///Register `CNT_END` writer
        pub type W = crate::W<CNT_END_SPEC>;
        ///Field `CNT_END` reader - RW, TMR3 end count value, only low 26 bit
        pub type CNT_END_R = crate::FieldReader<u32>;
        ///Field `CNT_END` writer - RW, TMR3 end count value, only low 26 bit
        pub type CNT_END_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - RW, TMR3 end count value, only low 26 bit
            #[inline(always)]
            pub fn cnt_end(&self) -> CNT_END_R {
                CNT_END_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW, TMR3 end count value, only low 26 bit
            #[inline(always)]
            #[must_use]
            pub fn cnt_end(&mut self) -> CNT_END_W<CNT_END_SPEC> {
                CNT_END_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW, TMR3 end count value, only low 26 bit
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`cnt_end::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cnt_end::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct CNT_END_SPEC;
        impl crate::RegisterSpec for CNT_END_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`cnt_end::R`](R) reader structure
        impl crate::Readable for CNT_END_SPEC {}
        ///`write(|w| ..)` method takes [`cnt_end::W`](W) writer structure
        impl crate::Writable for CNT_END_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets CNT_END to value 0
        impl crate::Resettable for CNT_END_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///FIFO (rw) register accessor: RO/WO, TMR3 FIFO register, only low 26 bit
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`fifo::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`fifo::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@fifo`]
    ///module
    pub type FIFO = crate::Reg<fifo::FIFO_SPEC>;
    ///RO/WO, TMR3 FIFO register, only low 26 bit
    pub mod fifo {
        ///Register `FIFO` reader
        pub type R = crate::R<FIFO_SPEC>;
        ///Register `FIFO` writer
        pub type W = crate::W<FIFO_SPEC>;
        ///Field `FIFO` reader - RO/WO, TMR3 FIFO register, only low 26 bit
        pub type FIFO_R = crate::FieldReader<u32>;
        ///Field `FIFO` writer - RO/WO, TMR3 FIFO register, only low 26 bit
        pub type FIFO_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - RO/WO, TMR3 FIFO register, only low 26 bit
            #[inline(always)]
            pub fn fifo(&self) -> FIFO_R {
                FIFO_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RO/WO, TMR3 FIFO register, only low 26 bit
            #[inline(always)]
            #[must_use]
            pub fn fifo(&mut self) -> FIFO_W<FIFO_SPEC> {
                FIFO_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RO/WO, TMR3 FIFO register, only low 26 bit
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`fifo::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`fifo::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct FIFO_SPEC;
        impl crate::RegisterSpec for FIFO_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`fifo::R`](R) reader structure
        impl crate::Readable for FIFO_SPEC {}
        ///`write(|w| ..)` method takes [`fifo::W`](W) writer structure
        impl crate::Writable for FIFO_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets FIFO to value 0
        impl crate::Resettable for FIFO_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
}
///UART0 register
pub struct UART0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for UART0 {}
impl UART0 {
    ///Pointer to the register block
    pub const PTR: *const uart0::RegisterBlock = 0x4000_3000 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const uart0::RegisterBlock {
        Self::PTR
    }
    /// Steal an instance of this peripheral
    ///
    /// # Safety
    ///
    /// Ensure that the new instance of the peripheral cannot be used in a way
    /// that may race with any existing instances, for example by only
    /// accessing read-only or write-only registers, or by consuming the
    /// original peripheral and using critical sections to coordinate
    /// access between multiple new instances.
    ///
    /// Additionally, other software such as HALs may rely on only one
    /// peripheral instance existing to ensure memory safety; ensure
    /// no stolen instances are passed to such software.
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for UART0 {
    type Target = uart0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for UART0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("UART0").finish()
    }
}
///UART0 register
pub mod uart0 {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        mcr: MCR,
        ier: IER,
        fcr: FCR,
        lcr: LCR,
        iir: IIR,
        lsr: LSR,
        msr: MSR,
        _reserved7: [u8; 0x01],
        _reserved_7_rbr: [u8; 0x01],
        _reserved8: [u8; 0x01],
        rfc: RFC,
        tfc: TFC,
        dl: DL,
        div: DIV,
        adr: ADR,
    }
    impl RegisterBlock {
        ///0x00 - RW, UART0 modem control
        #[inline(always)]
        pub const fn mcr(&self) -> &MCR {
            &self.mcr
        }
        ///0x01 - RW, UART0 interrupt enable
        #[inline(always)]
        pub const fn ier(&self) -> &IER {
            &self.ier
        }
        ///0x02 - RW, UART0 FIFO control
        #[inline(always)]
        pub const fn fcr(&self) -> &FCR {
            &self.fcr
        }
        ///0x03 - RW, UART0 line control
        #[inline(always)]
        pub const fn lcr(&self) -> &LCR {
            &self.lcr
        }
        ///0x04 - RO, UART0 interrupt identification
        #[inline(always)]
        pub const fn iir(&self) -> &IIR {
            &self.iir
        }
        ///0x05 - RO, UART0 line status
        #[inline(always)]
        pub const fn lsr(&self) -> &LSR {
            &self.lsr
        }
        ///0x06 - RO, UART0 modem status
        #[inline(always)]
        pub const fn msr(&self) -> &MSR {
            &self.msr
        }
        ///0x08 - WO, UART0 transmitter holding, transmittal byte
        #[inline(always)]
        pub const fn thr(&self) -> &THR {
            unsafe { &*(self as *const Self).cast::<u8>().add(8).cast() }
        }
        ///0x08 - RO, UART0 receiver buffer, receiving byte
        #[inline(always)]
        pub const fn rbr(&self) -> &RBR {
            unsafe { &*(self as *const Self).cast::<u8>().add(8).cast() }
        }
        ///0x0a - RO, UART0 receiver FIFO count
        #[inline(always)]
        pub const fn rfc(&self) -> &RFC {
            &self.rfc
        }
        ///0x0b - RO, UART0 transmitter FIFO count
        #[inline(always)]
        pub const fn tfc(&self) -> &TFC {
            &self.tfc
        }
        ///0x0c - RW, UART0 divisor latch
        #[inline(always)]
        pub const fn dl(&self) -> &DL {
            &self.dl
        }
        ///0x0e - RW, UART0 pre-divisor latch byte, only low 7 bit, from 1 to 0/128
        #[inline(always)]
        pub const fn div(&self) -> &DIV {
            &self.div
        }
        ///0x0f - RW, UART0 slave address: 0xFF=disable, other=enable
        #[inline(always)]
        pub const fn adr(&self) -> &ADR {
            &self.adr
        }
    }
    ///MCR (rw) register accessor: RW, UART0 modem control
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`mcr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`mcr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@mcr`]
    ///module
    pub type MCR = crate::Reg<mcr::MCR_SPEC>;
    ///RW, UART0 modem control
    pub mod mcr {
        ///Register `MCR` reader
        pub type R = crate::R<MCR_SPEC>;
        ///Register `MCR` writer
        pub type W = crate::W<MCR_SPEC>;
        ///Field `MCR_DTR` reader - RW, UART0 control DTR
        pub type MCR_DTR_R = crate::BitReader;
        ///Field `MCR_DTR` writer - RW, UART0 control DTR
        pub type MCR_DTR_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `MCR_RTS` reader - RW, UART0 control RTS
        pub type MCR_RTS_R = crate::BitReader;
        ///Field `MCR_RTS` writer - RW, UART0 control RTS
        pub type MCR_RTS_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `MCR_OUT1` reader - RW, UART0 control OUT1
        pub type MCR_OUT1_R = crate::BitReader;
        ///Field `MCR_OUT1` writer - RW, UART0 control OUT1
        pub type MCR_OUT1_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `MCR_OUT2__RB_MCR_INT_OE` reader - RW, UART control OUT2/ UART interrupt output enable
        pub type MCR_OUT2__RB_MCR_INT_OE_R = crate::BitReader;
        ///Field `MCR_OUT2__RB_MCR_INT_OE` writer - RW, UART control OUT2/ UART interrupt output enable
        pub type MCR_OUT2__RB_MCR_INT_OE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `MCR_LOOP` reader - RW, UART0 enable local loop back
        pub type MCR_LOOP_R = crate::BitReader;
        ///Field `MCR_LOOP` writer - RW, UART0 enable local loop back
        pub type MCR_LOOP_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `MCR_AU_FLOW_EN` reader - RW, UART0 enable autoflow control
        pub type MCR_AU_FLOW_EN_R = crate::BitReader;
        ///Field `MCR_AU_FLOW_EN` writer - RW, UART0 enable autoflow control
        pub type MCR_AU_FLOW_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `MCR_TNOW` reader - RW, UART0 enable TNOW output on DTR pin
        pub type MCR_TNOW_R = crate::BitReader;
        ///Field `MCR_TNOW` writer - RW, UART0 enable TNOW output on DTR pin
        pub type MCR_TNOW_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `MCR_HALF` reader - RW, UART0 enable half-duplex
        pub type MCR_HALF_R = crate::BitReader;
        ///Field `MCR_HALF` writer - RW, UART0 enable half-duplex
        pub type MCR_HALF_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - RW, UART0 control DTR
            #[inline(always)]
            pub fn mcr_dtr(&self) -> MCR_DTR_R {
                MCR_DTR_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RW, UART0 control RTS
            #[inline(always)]
            pub fn mcr_rts(&self) -> MCR_RTS_R {
                MCR_RTS_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RW, UART0 control OUT1
            #[inline(always)]
            pub fn mcr_out1(&self) -> MCR_OUT1_R {
                MCR_OUT1_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RW, UART control OUT2/ UART interrupt output enable
            #[inline(always)]
            pub fn mcr_out2__rb_mcr_int_oe(&self) -> MCR_OUT2__RB_MCR_INT_OE_R {
                MCR_OUT2__RB_MCR_INT_OE_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RW, UART0 enable local loop back
            #[inline(always)]
            pub fn mcr_loop(&self) -> MCR_LOOP_R {
                MCR_LOOP_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - RW, UART0 enable autoflow control
            #[inline(always)]
            pub fn mcr_au_flow_en(&self) -> MCR_AU_FLOW_EN_R {
                MCR_AU_FLOW_EN_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - RW, UART0 enable TNOW output on DTR pin
            #[inline(always)]
            pub fn mcr_tnow(&self) -> MCR_TNOW_R {
                MCR_TNOW_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - RW, UART0 enable half-duplex
            #[inline(always)]
            pub fn mcr_half(&self) -> MCR_HALF_R {
                MCR_HALF_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RW, UART0 control DTR
            #[inline(always)]
            #[must_use]
            pub fn mcr_dtr(&mut self) -> MCR_DTR_W<MCR_SPEC> {
                MCR_DTR_W::new(self, 0)
            }
            ///Bit 1 - RW, UART0 control RTS
            #[inline(always)]
            #[must_use]
            pub fn mcr_rts(&mut self) -> MCR_RTS_W<MCR_SPEC> {
                MCR_RTS_W::new(self, 1)
            }
            ///Bit 2 - RW, UART0 control OUT1
            #[inline(always)]
            #[must_use]
            pub fn mcr_out1(&mut self) -> MCR_OUT1_W<MCR_SPEC> {
                MCR_OUT1_W::new(self, 2)
            }
            ///Bit 3 - RW, UART control OUT2/ UART interrupt output enable
            #[inline(always)]
            #[must_use]
            pub fn mcr_out2__rb_mcr_int_oe(&mut self) -> MCR_OUT2__RB_MCR_INT_OE_W<MCR_SPEC> {
                MCR_OUT2__RB_MCR_INT_OE_W::new(self, 3)
            }
            ///Bit 4 - RW, UART0 enable local loop back
            #[inline(always)]
            #[must_use]
            pub fn mcr_loop(&mut self) -> MCR_LOOP_W<MCR_SPEC> {
                MCR_LOOP_W::new(self, 4)
            }
            ///Bit 5 - RW, UART0 enable autoflow control
            #[inline(always)]
            #[must_use]
            pub fn mcr_au_flow_en(&mut self) -> MCR_AU_FLOW_EN_W<MCR_SPEC> {
                MCR_AU_FLOW_EN_W::new(self, 5)
            }
            ///Bit 6 - RW, UART0 enable TNOW output on DTR pin
            #[inline(always)]
            #[must_use]
            pub fn mcr_tnow(&mut self) -> MCR_TNOW_W<MCR_SPEC> {
                MCR_TNOW_W::new(self, 6)
            }
            ///Bit 7 - RW, UART0 enable half-duplex
            #[inline(always)]
            #[must_use]
            pub fn mcr_half(&mut self) -> MCR_HALF_W<MCR_SPEC> {
                MCR_HALF_W::new(self, 7)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW, UART0 modem control
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`mcr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`mcr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct MCR_SPEC;
        impl crate::RegisterSpec for MCR_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`mcr::R`](R) reader structure
        impl crate::Readable for MCR_SPEC {}
        ///`write(|w| ..)` method takes [`mcr::W`](W) writer structure
        impl crate::Writable for MCR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets MCR to value 0
        impl crate::Resettable for MCR_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///IER (rw) register accessor: RW, UART0 interrupt enable
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`ier::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ier::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@ier`]
    ///module
    pub type IER = crate::Reg<ier::IER_SPEC>;
    ///RW, UART0 interrupt enable
    pub mod ier {
        ///Register `IER` reader
        pub type R = crate::R<IER_SPEC>;
        ///Register `IER` writer
        pub type W = crate::W<IER_SPEC>;
        ///Field `IER_RECV_RDY` reader - RW, UART interrupt enable for receiver data ready
        pub type IER_RECV_RDY_R = crate::BitReader;
        ///Field `IER_RECV_RDY` writer - RW, UART interrupt enable for receiver data ready
        pub type IER_RECV_RDY_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `IER_THR_EMPTY` reader - RW, UART interrupt enable for THR empty
        pub type IER_THR_EMPTY_R = crate::BitReader;
        ///Field `IER_THR_EMPTY` writer - RW, UART interrupt enable for THR empty
        pub type IER_THR_EMPTY_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `IER_LINE_STAT` reader - RW, UART interrupt enable for receiver line status
        pub type IER_LINE_STAT_R = crate::BitReader;
        ///Field `IER_LINE_STAT` writer - RW, UART interrupt enable for receiver line status
        pub type IER_LINE_STAT_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `IER_MODEM_CHG` reader - RW, UART0 interrupt enable for modem status change
        pub type IER_MODEM_CHG_R = crate::BitReader;
        ///Field `IER_MODEM_CHG` writer - RW, UART0 interrupt enable for modem status change
        pub type IER_MODEM_CHG_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `IER_DTR_EN` reader - RW, UART0 DTR/TNOW output pin enable
        pub type IER_DTR_EN_R = crate::BitReader;
        ///Field `IER_DTR_EN` writer - RW, UART0 DTR/TNOW output pin enable
        pub type IER_DTR_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `IER_RTS_EN` reader - RW, UART0 RTS output pin enable
        pub type IER_RTS_EN_R = crate::BitReader;
        ///Field `IER_RTS_EN` writer - RW, UART0 RTS output pin enable
        pub type IER_RTS_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `IER_TXD_EN` reader - RW, UART TXD pin enable
        pub type IER_TXD_EN_R = crate::BitReader;
        ///Field `IER_TXD_EN` writer - RW, UART TXD pin enable
        pub type IER_TXD_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `IER_RESET` reader - WZ, UART software reset control, high action, auto clear
        pub type IER_RESET_R = crate::BitReader;
        ///Field `IER_RESET` writer - WZ, UART software reset control, high action, auto clear
        pub type IER_RESET_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - RW, UART interrupt enable for receiver data ready
            #[inline(always)]
            pub fn ier_recv_rdy(&self) -> IER_RECV_RDY_R {
                IER_RECV_RDY_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RW, UART interrupt enable for THR empty
            #[inline(always)]
            pub fn ier_thr_empty(&self) -> IER_THR_EMPTY_R {
                IER_THR_EMPTY_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RW, UART interrupt enable for receiver line status
            #[inline(always)]
            pub fn ier_line_stat(&self) -> IER_LINE_STAT_R {
                IER_LINE_STAT_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RW, UART0 interrupt enable for modem status change
            #[inline(always)]
            pub fn ier_modem_chg(&self) -> IER_MODEM_CHG_R {
                IER_MODEM_CHG_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RW, UART0 DTR/TNOW output pin enable
            #[inline(always)]
            pub fn ier_dtr_en(&self) -> IER_DTR_EN_R {
                IER_DTR_EN_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - RW, UART0 RTS output pin enable
            #[inline(always)]
            pub fn ier_rts_en(&self) -> IER_RTS_EN_R {
                IER_RTS_EN_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - RW, UART TXD pin enable
            #[inline(always)]
            pub fn ier_txd_en(&self) -> IER_TXD_EN_R {
                IER_TXD_EN_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - WZ, UART software reset control, high action, auto clear
            #[inline(always)]
            pub fn ier_reset(&self) -> IER_RESET_R {
                IER_RESET_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RW, UART interrupt enable for receiver data ready
            #[inline(always)]
            #[must_use]
            pub fn ier_recv_rdy(&mut self) -> IER_RECV_RDY_W<IER_SPEC> {
                IER_RECV_RDY_W::new(self, 0)
            }
            ///Bit 1 - RW, UART interrupt enable for THR empty
            #[inline(always)]
            #[must_use]
            pub fn ier_thr_empty(&mut self) -> IER_THR_EMPTY_W<IER_SPEC> {
                IER_THR_EMPTY_W::new(self, 1)
            }
            ///Bit 2 - RW, UART interrupt enable for receiver line status
            #[inline(always)]
            #[must_use]
            pub fn ier_line_stat(&mut self) -> IER_LINE_STAT_W<IER_SPEC> {
                IER_LINE_STAT_W::new(self, 2)
            }
            ///Bit 3 - RW, UART0 interrupt enable for modem status change
            #[inline(always)]
            #[must_use]
            pub fn ier_modem_chg(&mut self) -> IER_MODEM_CHG_W<IER_SPEC> {
                IER_MODEM_CHG_W::new(self, 3)
            }
            ///Bit 4 - RW, UART0 DTR/TNOW output pin enable
            #[inline(always)]
            #[must_use]
            pub fn ier_dtr_en(&mut self) -> IER_DTR_EN_W<IER_SPEC> {
                IER_DTR_EN_W::new(self, 4)
            }
            ///Bit 5 - RW, UART0 RTS output pin enable
            #[inline(always)]
            #[must_use]
            pub fn ier_rts_en(&mut self) -> IER_RTS_EN_W<IER_SPEC> {
                IER_RTS_EN_W::new(self, 5)
            }
            ///Bit 6 - RW, UART TXD pin enable
            #[inline(always)]
            #[must_use]
            pub fn ier_txd_en(&mut self) -> IER_TXD_EN_W<IER_SPEC> {
                IER_TXD_EN_W::new(self, 6)
            }
            ///Bit 7 - WZ, UART software reset control, high action, auto clear
            #[inline(always)]
            #[must_use]
            pub fn ier_reset(&mut self) -> IER_RESET_W<IER_SPEC> {
                IER_RESET_W::new(self, 7)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW, UART0 interrupt enable
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`ier::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ier::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IER_SPEC;
        impl crate::RegisterSpec for IER_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`ier::R`](R) reader structure
        impl crate::Readable for IER_SPEC {}
        ///`write(|w| ..)` method takes [`ier::W`](W) writer structure
        impl crate::Writable for IER_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets IER to value 0
        impl crate::Resettable for IER_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///FCR (rw) register accessor: RW, UART0 FIFO control
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`fcr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`fcr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@fcr`]
    ///module
    pub type FCR = crate::Reg<fcr::FCR_SPEC>;
    ///RW, UART0 FIFO control
    pub mod fcr {
        ///Register `FCR` reader
        pub type R = crate::R<FCR_SPEC>;
        ///Register `FCR` writer
        pub type W = crate::W<FCR_SPEC>;
        ///Field `FCR_FIFO_EN` reader - RW, UART FIFO enable
        pub type FCR_FIFO_EN_R = crate::BitReader;
        ///Field `FCR_FIFO_EN` writer - RW, UART FIFO enable
        pub type FCR_FIFO_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FCR_RX_FIFO_CLR` reader - WZ, clear UART receiver FIFO, high action, auto clear
        pub type FCR_RX_FIFO_CLR_R = crate::BitReader;
        ///Field `FCR_RX_FIFO_CLR` writer - WZ, clear UART receiver FIFO, high action, auto clear
        pub type FCR_RX_FIFO_CLR_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FCR_TX_FIFO_CLR` reader - WZ, clear UART transmitter FIFO, high action, auto clear
        pub type FCR_TX_FIFO_CLR_R = crate::BitReader;
        ///Field `FCR_TX_FIFO_CLR` writer - WZ, clear UART transmitter FIFO, high action, auto clear
        pub type FCR_TX_FIFO_CLR_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FCR_FIFO_TRIG` reader - RW, UART receiver FIFO trigger level: 00-1byte, 01-2bytes, 10-4bytes, 11-7bytes
        pub type FCR_FIFO_TRIG_R = crate::FieldReader;
        ///Field `FCR_FIFO_TRIG` writer - RW, UART receiver FIFO trigger level: 00-1byte, 01-2bytes, 10-4bytes, 11-7bytes
        pub type FCR_FIFO_TRIG_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        impl R {
            ///Bit 0 - RW, UART FIFO enable
            #[inline(always)]
            pub fn fcr_fifo_en(&self) -> FCR_FIFO_EN_R {
                FCR_FIFO_EN_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - WZ, clear UART receiver FIFO, high action, auto clear
            #[inline(always)]
            pub fn fcr_rx_fifo_clr(&self) -> FCR_RX_FIFO_CLR_R {
                FCR_RX_FIFO_CLR_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - WZ, clear UART transmitter FIFO, high action, auto clear
            #[inline(always)]
            pub fn fcr_tx_fifo_clr(&self) -> FCR_TX_FIFO_CLR_R {
                FCR_TX_FIFO_CLR_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bits 6:7 - RW, UART receiver FIFO trigger level: 00-1byte, 01-2bytes, 10-4bytes, 11-7bytes
            #[inline(always)]
            pub fn fcr_fifo_trig(&self) -> FCR_FIFO_TRIG_R {
                FCR_FIFO_TRIG_R::new((self.bits >> 6) & 3)
            }
        }
        impl W {
            ///Bit 0 - RW, UART FIFO enable
            #[inline(always)]
            #[must_use]
            pub fn fcr_fifo_en(&mut self) -> FCR_FIFO_EN_W<FCR_SPEC> {
                FCR_FIFO_EN_W::new(self, 0)
            }
            ///Bit 1 - WZ, clear UART receiver FIFO, high action, auto clear
            #[inline(always)]
            #[must_use]
            pub fn fcr_rx_fifo_clr(&mut self) -> FCR_RX_FIFO_CLR_W<FCR_SPEC> {
                FCR_RX_FIFO_CLR_W::new(self, 1)
            }
            ///Bit 2 - WZ, clear UART transmitter FIFO, high action, auto clear
            #[inline(always)]
            #[must_use]
            pub fn fcr_tx_fifo_clr(&mut self) -> FCR_TX_FIFO_CLR_W<FCR_SPEC> {
                FCR_TX_FIFO_CLR_W::new(self, 2)
            }
            ///Bits 6:7 - RW, UART receiver FIFO trigger level: 00-1byte, 01-2bytes, 10-4bytes, 11-7bytes
            #[inline(always)]
            #[must_use]
            pub fn fcr_fifo_trig(&mut self) -> FCR_FIFO_TRIG_W<FCR_SPEC> {
                FCR_FIFO_TRIG_W::new(self, 6)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW, UART0 FIFO control
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`fcr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`fcr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct FCR_SPEC;
        impl crate::RegisterSpec for FCR_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`fcr::R`](R) reader structure
        impl crate::Readable for FCR_SPEC {}
        ///`write(|w| ..)` method takes [`fcr::W`](W) writer structure
        impl crate::Writable for FCR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets FCR to value 0
        impl crate::Resettable for FCR_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///LCR (rw) register accessor: RW, UART0 line control
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`lcr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`lcr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@lcr`]
    ///module
    pub type LCR = crate::Reg<lcr::LCR_SPEC>;
    ///RW, UART0 line control
    pub mod lcr {
        ///Register `LCR` reader
        pub type R = crate::R<LCR_SPEC>;
        ///Register `LCR` writer
        pub type W = crate::W<LCR_SPEC>;
        ///Field `LCR_WORD_SZ` reader - RW, UART word bit length: 00-5bit, 01-6bit, 10-7bit, 11-8bit
        pub type LCR_WORD_SZ_R = crate::FieldReader;
        ///Field `LCR_WORD_SZ` writer - RW, UART word bit length: 00-5bit, 01-6bit, 10-7bit, 11-8bit
        pub type LCR_WORD_SZ_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `LCR_STOP_BIT` reader - RW, UART stop bit length: 0-1bit, 1-2bit
        pub type LCR_STOP_BIT_R = crate::BitReader;
        ///Field `LCR_STOP_BIT` writer - RW, UART stop bit length: 0-1bit, 1-2bit
        pub type LCR_STOP_BIT_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `LCR_PAR_EN` reader - RW, UART parity enable
        pub type LCR_PAR_EN_R = crate::BitReader;
        ///Field `LCR_PAR_EN` writer - RW, UART parity enable
        pub type LCR_PAR_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `LCR_PAR_MOD` reader - RW, UART parity mode: 00-odd, 01-even, 10-mark, 11-space
        pub type LCR_PAR_MOD_R = crate::FieldReader;
        ///Field `LCR_PAR_MOD` writer - RW, UART parity mode: 00-odd, 01-even, 10-mark, 11-space
        pub type LCR_PAR_MOD_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `LCR_BREAK_EN` reader - RW, UART break control enable
        pub type LCR_BREAK_EN_R = crate::BitReader;
        ///Field `LCR_BREAK_EN` writer - RW, UART break control enable
        pub type LCR_BREAK_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `LCR_GP_BIT__RB_LCR_DLAB` reader - RW, UART general purpose bit;RW, UART reserved bit
        pub type LCR_GP_BIT__RB_LCR_DLAB_R = crate::BitReader;
        ///Field `LCR_GP_BIT__RB_LCR_DLAB` writer - RW, UART general purpose bit;RW, UART reserved bit
        pub type LCR_GP_BIT__RB_LCR_DLAB_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bits 0:1 - RW, UART word bit length: 00-5bit, 01-6bit, 10-7bit, 11-8bit
            #[inline(always)]
            pub fn lcr_word_sz(&self) -> LCR_WORD_SZ_R {
                LCR_WORD_SZ_R::new(self.bits & 3)
            }
            ///Bit 2 - RW, UART stop bit length: 0-1bit, 1-2bit
            #[inline(always)]
            pub fn lcr_stop_bit(&self) -> LCR_STOP_BIT_R {
                LCR_STOP_BIT_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RW, UART parity enable
            #[inline(always)]
            pub fn lcr_par_en(&self) -> LCR_PAR_EN_R {
                LCR_PAR_EN_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bits 4:5 - RW, UART parity mode: 00-odd, 01-even, 10-mark, 11-space
            #[inline(always)]
            pub fn lcr_par_mod(&self) -> LCR_PAR_MOD_R {
                LCR_PAR_MOD_R::new((self.bits >> 4) & 3)
            }
            ///Bit 6 - RW, UART break control enable
            #[inline(always)]
            pub fn lcr_break_en(&self) -> LCR_BREAK_EN_R {
                LCR_BREAK_EN_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - RW, UART general purpose bit;RW, UART reserved bit
            #[inline(always)]
            pub fn lcr_gp_bit__rb_lcr_dlab(&self) -> LCR_GP_BIT__RB_LCR_DLAB_R {
                LCR_GP_BIT__RB_LCR_DLAB_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:1 - RW, UART word bit length: 00-5bit, 01-6bit, 10-7bit, 11-8bit
            #[inline(always)]
            #[must_use]
            pub fn lcr_word_sz(&mut self) -> LCR_WORD_SZ_W<LCR_SPEC> {
                LCR_WORD_SZ_W::new(self, 0)
            }
            ///Bit 2 - RW, UART stop bit length: 0-1bit, 1-2bit
            #[inline(always)]
            #[must_use]
            pub fn lcr_stop_bit(&mut self) -> LCR_STOP_BIT_W<LCR_SPEC> {
                LCR_STOP_BIT_W::new(self, 2)
            }
            ///Bit 3 - RW, UART parity enable
            #[inline(always)]
            #[must_use]
            pub fn lcr_par_en(&mut self) -> LCR_PAR_EN_W<LCR_SPEC> {
                LCR_PAR_EN_W::new(self, 3)
            }
            ///Bits 4:5 - RW, UART parity mode: 00-odd, 01-even, 10-mark, 11-space
            #[inline(always)]
            #[must_use]
            pub fn lcr_par_mod(&mut self) -> LCR_PAR_MOD_W<LCR_SPEC> {
                LCR_PAR_MOD_W::new(self, 4)
            }
            ///Bit 6 - RW, UART break control enable
            #[inline(always)]
            #[must_use]
            pub fn lcr_break_en(&mut self) -> LCR_BREAK_EN_W<LCR_SPEC> {
                LCR_BREAK_EN_W::new(self, 6)
            }
            ///Bit 7 - RW, UART general purpose bit;RW, UART reserved bit
            #[inline(always)]
            #[must_use]
            pub fn lcr_gp_bit__rb_lcr_dlab(&mut self) -> LCR_GP_BIT__RB_LCR_DLAB_W<LCR_SPEC> {
                LCR_GP_BIT__RB_LCR_DLAB_W::new(self, 7)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW, UART0 line control
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`lcr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`lcr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct LCR_SPEC;
        impl crate::RegisterSpec for LCR_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`lcr::R`](R) reader structure
        impl crate::Readable for LCR_SPEC {}
        ///`write(|w| ..)` method takes [`lcr::W`](W) writer structure
        impl crate::Writable for LCR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets LCR to value 0
        impl crate::Resettable for LCR_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///IIR (r) register accessor: RO, UART0 interrupt identification
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iir::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iir`]
    ///module
    pub type IIR = crate::Reg<iir::IIR_SPEC>;
    ///RO, UART0 interrupt identification
    pub mod iir {
        ///Register `IIR` reader
        pub type R = crate::R<IIR_SPEC>;
        ///Field `IIR_NO_INT` reader - RO, UART no interrupt flag: 0=interrupt action, 1=no interrupt
        pub type IIR_NO_INT_R = crate::BitReader;
        ///Field `IIR_INT_MASK` reader - RO, UART interrupt flag bit mask
        pub type IIR_INT_MASK_R = crate::FieldReader;
        ///Field `IIR_FIFO_ID` reader - RO, UART FIFO enabled flag
        pub type IIR_FIFO_ID_R = crate::FieldReader;
        impl R {
            ///Bit 0 - RO, UART no interrupt flag: 0=interrupt action, 1=no interrupt
            #[inline(always)]
            pub fn iir_no_int(&self) -> IIR_NO_INT_R {
                IIR_NO_INT_R::new((self.bits & 1) != 0)
            }
            ///Bits 0:3 - RO, UART interrupt flag bit mask
            #[inline(always)]
            pub fn iir_int_mask(&self) -> IIR_INT_MASK_R {
                IIR_INT_MASK_R::new(self.bits & 0x0f)
            }
            ///Bits 6:7 - RO, UART FIFO enabled flag
            #[inline(always)]
            pub fn iir_fifo_id(&self) -> IIR_FIFO_ID_R {
                IIR_FIFO_ID_R::new((self.bits >> 6) & 3)
            }
        }
        ///RO, UART0 interrupt identification
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iir::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IIR_SPEC;
        impl crate::RegisterSpec for IIR_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`iir::R`](R) reader structure
        impl crate::Readable for IIR_SPEC {}
        ///`reset()` method sets IIR to value 0x01
        impl crate::Resettable for IIR_SPEC {
            const RESET_VALUE: u8 = 0x01;
        }
    }
    ///LSR (r) register accessor: RO, UART0 line status
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`lsr::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@lsr`]
    ///module
    pub type LSR = crate::Reg<lsr::LSR_SPEC>;
    ///RO, UART0 line status
    pub mod lsr {
        ///Register `LSR` reader
        pub type R = crate::R<LSR_SPEC>;
        ///Field `LSR_DATA_RDY` reader - RO, UART receiver fifo data ready status
        pub type LSR_DATA_RDY_R = crate::BitReader;
        ///Field `LSR_OVER_ERR` reader - RZ, UART receiver overrun error
        pub type LSR_OVER_ERR_R = crate::BitReader;
        ///Field `LSR_PAR_ERR` reader - RZ, UART receiver parity error
        pub type LSR_PAR_ERR_R = crate::BitReader;
        ///Field `LSR_FRAME_ERR` reader - RZ, UART receiver frame error
        pub type LSR_FRAME_ERR_R = crate::BitReader;
        ///Field `LSR_BREAK_ERR` reader - RZ, UART receiver break error
        pub type LSR_BREAK_ERR_R = crate::BitReader;
        ///Field `LSR_TX_FIFO_EMP` reader - RO, UART transmitter fifo empty status
        pub type LSR_TX_FIFO_EMP_R = crate::BitReader;
        ///Field `LSR_TX_ALL_EMP` reader - RO, UART transmitter all empty status
        pub type LSR_TX_ALL_EMP_R = crate::BitReader;
        ///Field `LSR_ERR_RX_FIFO` reader - RO, indicate error in UART receiver fifo
        pub type LSR_ERR_RX_FIFO_R = crate::BitReader;
        impl R {
            ///Bit 0 - RO, UART receiver fifo data ready status
            #[inline(always)]
            pub fn lsr_data_rdy(&self) -> LSR_DATA_RDY_R {
                LSR_DATA_RDY_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RZ, UART receiver overrun error
            #[inline(always)]
            pub fn lsr_over_err(&self) -> LSR_OVER_ERR_R {
                LSR_OVER_ERR_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RZ, UART receiver parity error
            #[inline(always)]
            pub fn lsr_par_err(&self) -> LSR_PAR_ERR_R {
                LSR_PAR_ERR_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RZ, UART receiver frame error
            #[inline(always)]
            pub fn lsr_frame_err(&self) -> LSR_FRAME_ERR_R {
                LSR_FRAME_ERR_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RZ, UART receiver break error
            #[inline(always)]
            pub fn lsr_break_err(&self) -> LSR_BREAK_ERR_R {
                LSR_BREAK_ERR_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - RO, UART transmitter fifo empty status
            #[inline(always)]
            pub fn lsr_tx_fifo_emp(&self) -> LSR_TX_FIFO_EMP_R {
                LSR_TX_FIFO_EMP_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - RO, UART transmitter all empty status
            #[inline(always)]
            pub fn lsr_tx_all_emp(&self) -> LSR_TX_ALL_EMP_R {
                LSR_TX_ALL_EMP_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - RO, indicate error in UART receiver fifo
            #[inline(always)]
            pub fn lsr_err_rx_fifo(&self) -> LSR_ERR_RX_FIFO_R {
                LSR_ERR_RX_FIFO_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        ///RO, UART0 line status
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`lsr::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct LSR_SPEC;
        impl crate::RegisterSpec for LSR_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`lsr::R`](R) reader structure
        impl crate::Readable for LSR_SPEC {}
        ///`reset()` method sets LSR to value 0x60
        impl crate::Resettable for LSR_SPEC {
            const RESET_VALUE: u8 = 0x60;
        }
    }
    ///MSR (r) register accessor: RO, UART0 modem status
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`msr::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@msr`]
    ///module
    pub type MSR = crate::Reg<msr::MSR_SPEC>;
    ///RO, UART0 modem status
    pub mod msr {
        ///Register `MSR` reader
        pub type R = crate::R<MSR_SPEC>;
        ///Field `MSR_CTS_CHG` reader - RZ, UART0 CTS changed status, high action
        pub type MSR_CTS_CHG_R = crate::BitReader;
        ///Field `MSR_DSR_CHG` reader - RZ, UART0 DSR changed status, high action
        pub type MSR_DSR_CHG_R = crate::BitReader;
        ///Field `MSR_RI_CHG` reader - RZ, UART0 RI changed status, high action
        pub type MSR_RI_CHG_R = crate::BitReader;
        ///Field `MSR_DCD_CHG` reader - RZ, UART0 DCD changed status, high action
        pub type MSR_DCD_CHG_R = crate::BitReader;
        ///Field `MSR_CTS` reader - RO, UART0 CTS action status
        pub type MSR_CTS_R = crate::BitReader;
        ///Field `MSR_DSR` reader - RO, UART0 DSR action statusv
        pub type MSR_DSR_R = crate::BitReader;
        ///Field `MSR_RI` reader - RO, UART0 RI action status
        pub type MSR_RI_R = crate::BitReader;
        ///Field `MSR_DCD` reader - RO, UART0 DCD action status
        pub type MSR_DCD_R = crate::BitReader;
        impl R {
            ///Bit 0 - RZ, UART0 CTS changed status, high action
            #[inline(always)]
            pub fn msr_cts_chg(&self) -> MSR_CTS_CHG_R {
                MSR_CTS_CHG_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RZ, UART0 DSR changed status, high action
            #[inline(always)]
            pub fn msr_dsr_chg(&self) -> MSR_DSR_CHG_R {
                MSR_DSR_CHG_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RZ, UART0 RI changed status, high action
            #[inline(always)]
            pub fn msr_ri_chg(&self) -> MSR_RI_CHG_R {
                MSR_RI_CHG_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RZ, UART0 DCD changed status, high action
            #[inline(always)]
            pub fn msr_dcd_chg(&self) -> MSR_DCD_CHG_R {
                MSR_DCD_CHG_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RO, UART0 CTS action status
            #[inline(always)]
            pub fn msr_cts(&self) -> MSR_CTS_R {
                MSR_CTS_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - RO, UART0 DSR action statusv
            #[inline(always)]
            pub fn msr_dsr(&self) -> MSR_DSR_R {
                MSR_DSR_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - RO, UART0 RI action status
            #[inline(always)]
            pub fn msr_ri(&self) -> MSR_RI_R {
                MSR_RI_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - RO, UART0 DCD action status
            #[inline(always)]
            pub fn msr_dcd(&self) -> MSR_DCD_R {
                MSR_DCD_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        ///RO, UART0 modem status
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`msr::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct MSR_SPEC;
        impl crate::RegisterSpec for MSR_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`msr::R`](R) reader structure
        impl crate::Readable for MSR_SPEC {}
        ///`reset()` method sets MSR to value 0
        impl crate::Resettable for MSR_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///RBR (r) register accessor: RO, UART0 receiver buffer, receiving byte
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`rbr::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@rbr`]
    ///module
    pub type RBR = crate::Reg<rbr::RBR_SPEC>;
    ///RO, UART0 receiver buffer, receiving byte
    pub mod rbr {
        ///Register `RBR` reader
        pub type R = crate::R<RBR_SPEC>;
        ///Field `RBR` reader - RO, UART0 receiver buffer, receiving byte
        pub type RBR_R = crate::FieldReader;
        impl R {
            ///Bits 0:7 - RO, UART0 receiver buffer, receiving byte
            #[inline(always)]
            pub fn rbr(&self) -> RBR_R {
                RBR_R::new(self.bits)
            }
        }
        ///RO, UART0 receiver buffer, receiving byte
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`rbr::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct RBR_SPEC;
        impl crate::RegisterSpec for RBR_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`rbr::R`](R) reader structure
        impl crate::Readable for RBR_SPEC {}
        ///`reset()` method sets RBR to value 0
        impl crate::Resettable for RBR_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///THR (w) register accessor: WO, UART0 transmitter holding, transmittal byte
    ///
    ///You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`thr::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@thr`]
    ///module
    pub type THR = crate::Reg<thr::THR_SPEC>;
    ///WO, UART0 transmitter holding, transmittal byte
    pub mod thr {
        ///Register `THR` writer
        pub type W = crate::W<THR_SPEC>;
        ///Field `THR` writer - RO, UART0 transmitter holding, transmittal byte
        pub type THR_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl W {
            ///Bits 0:7 - RO, UART0 transmitter holding, transmittal byte
            #[inline(always)]
            #[must_use]
            pub fn thr(&mut self) -> THR_W<THR_SPEC> {
                THR_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///WO, UART0 transmitter holding, transmittal byte
        ///
        ///You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`thr::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct THR_SPEC;
        impl crate::RegisterSpec for THR_SPEC {
            type Ux = u8;
        }
        ///`write(|w| ..)` method takes [`thr::W`](W) writer structure
        impl crate::Writable for THR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets THR to value 0
        impl crate::Resettable for THR_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///RFC (r) register accessor: RO, UART0 receiver FIFO count
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`rfc::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@rfc`]
    ///module
    pub type RFC = crate::Reg<rfc::RFC_SPEC>;
    ///RO, UART0 receiver FIFO count
    pub mod rfc {
        ///Register `RFC` reader
        pub type R = crate::R<RFC_SPEC>;
        ///Field `RFC` reader - RO, UART0 receiver FIFO count
        pub type RFC_R = crate::FieldReader;
        impl R {
            ///Bits 0:7 - RO, UART0 receiver FIFO count
            #[inline(always)]
            pub fn rfc(&self) -> RFC_R {
                RFC_R::new(self.bits)
            }
        }
        ///RO, UART0 receiver FIFO count
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`rfc::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct RFC_SPEC;
        impl crate::RegisterSpec for RFC_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`rfc::R`](R) reader structure
        impl crate::Readable for RFC_SPEC {}
        ///`reset()` method sets RFC to value 0
        impl crate::Resettable for RFC_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///TFC (r) register accessor: RO, UART0 transmitter FIFO count
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`tfc::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@tfc`]
    ///module
    pub type TFC = crate::Reg<tfc::TFC_SPEC>;
    ///RO, UART0 transmitter FIFO count
    pub mod tfc {
        ///Register `TFC` reader
        pub type R = crate::R<TFC_SPEC>;
        ///Field `TFC` reader - RO, UART0 transmitter FIFO count
        pub type TFC_R = crate::FieldReader;
        impl R {
            ///Bits 0:7 - RO, UART0 transmitter FIFO count
            #[inline(always)]
            pub fn tfc(&self) -> TFC_R {
                TFC_R::new(self.bits)
            }
        }
        ///RO, UART0 transmitter FIFO count
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`tfc::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct TFC_SPEC;
        impl crate::RegisterSpec for TFC_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`tfc::R`](R) reader structure
        impl crate::Readable for TFC_SPEC {}
        ///`reset()` method sets TFC to value 0
        impl crate::Resettable for TFC_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///DL (rw) register accessor: RW, UART0 divisor latch
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`dl::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dl::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@dl`]
    ///module
    pub type DL = crate::Reg<dl::DL_SPEC>;
    ///RW, UART0 divisor latch
    pub mod dl {
        ///Register `DL` reader
        pub type R = crate::R<DL_SPEC>;
        ///Register `DL` writer
        pub type W = crate::W<DL_SPEC>;
        ///Field `DL` reader - RW, UART0 divisor latch
        pub type DL_R = crate::FieldReader<u16>;
        ///Field `DL` writer - RW, UART0 divisor latch
        pub type DL_W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            ///Bits 0:15 - RW, UART0 divisor latch
            #[inline(always)]
            pub fn dl(&self) -> DL_R {
                DL_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - RW, UART0 divisor latch
            #[inline(always)]
            #[must_use]
            pub fn dl(&mut self) -> DL_W<DL_SPEC> {
                DL_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW, UART0 divisor latch
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`dl::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dl::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct DL_SPEC;
        impl crate::RegisterSpec for DL_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`dl::R`](R) reader structure
        impl crate::Readable for DL_SPEC {}
        ///`write(|w| ..)` method takes [`dl::W`](W) writer structure
        impl crate::Writable for DL_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets DL to value 0
        impl crate::Resettable for DL_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///DIV (rw) register accessor: RW, UART0 pre-divisor latch byte, only low 7 bit, from 1 to 0/128
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`div::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`div::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@div`]
    ///module
    pub type DIV = crate::Reg<div::DIV_SPEC>;
    ///RW, UART0 pre-divisor latch byte, only low 7 bit, from 1 to 0/128
    pub mod div {
        ///Register `DIV` reader
        pub type R = crate::R<DIV_SPEC>;
        ///Register `DIV` writer
        pub type W = crate::W<DIV_SPEC>;
        ///Field `DIV` reader - RW,UART0 pre-divisor latch byte, only low 7 bit, from 1 to 0/128
        pub type DIV_R = crate::FieldReader;
        ///Field `DIV` writer - RW,UART0 pre-divisor latch byte, only low 7 bit, from 1 to 0/128
        pub type DIV_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            ///Bits 0:7 - RW,UART0 pre-divisor latch byte, only low 7 bit, from 1 to 0/128
            #[inline(always)]
            pub fn div(&self) -> DIV_R {
                DIV_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:7 - RW,UART0 pre-divisor latch byte, only low 7 bit, from 1 to 0/128
            #[inline(always)]
            #[must_use]
            pub fn div(&mut self) -> DIV_W<DIV_SPEC> {
                DIV_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW, UART0 pre-divisor latch byte, only low 7 bit, from 1 to 0/128
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`div::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`div::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct DIV_SPEC;
        impl crate::RegisterSpec for DIV_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`div::R`](R) reader structure
        impl crate::Readable for DIV_SPEC {}
        ///`write(|w| ..)` method takes [`div::W`](W) writer structure
        impl crate::Writable for DIV_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets DIV to value 0
        impl crate::Resettable for DIV_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///ADR (rw) register accessor: RW, UART0 slave address: 0xFF=disable, other=enable
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`adr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`adr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@adr`]
    ///module
    pub type ADR = crate::Reg<adr::ADR_SPEC>;
    ///RW, UART0 slave address: 0xFF=disable, other=enable
    pub mod adr {
        ///Register `ADR` reader
        pub type R = crate::R<ADR_SPEC>;
        ///Register `ADR` writer
        pub type W = crate::W<ADR_SPEC>;
        ///Field `ADR` reader - RW,UART0 slave address: 0xFF=disable, other=enable
        pub type ADR_R = crate::FieldReader;
        ///Field `ADR` writer - RW,UART0 slave address: 0xFF=disable, other=enable
        pub type ADR_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            ///Bits 0:7 - RW,UART0 slave address: 0xFF=disable, other=enable
            #[inline(always)]
            pub fn adr(&self) -> ADR_R {
                ADR_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:7 - RW,UART0 slave address: 0xFF=disable, other=enable
            #[inline(always)]
            #[must_use]
            pub fn adr(&mut self) -> ADR_W<ADR_SPEC> {
                ADR_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW, UART0 slave address: 0xFF=disable, other=enable
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`adr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`adr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct ADR_SPEC;
        impl crate::RegisterSpec for ADR_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`adr::R`](R) reader structure
        impl crate::Readable for ADR_SPEC {}
        ///`write(|w| ..)` method takes [`adr::W`](W) writer structure
        impl crate::Writable for ADR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets ADR to value 0xff
        impl crate::Resettable for ADR_SPEC {
            const RESET_VALUE: u8 = 0xff;
        }
    }
}
///UART1 register
pub struct UART1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for UART1 {}
impl UART1 {
    ///Pointer to the register block
    pub const PTR: *const uart1::RegisterBlock = 0x4000_3400 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const uart1::RegisterBlock {
        Self::PTR
    }
    /// Steal an instance of this peripheral
    ///
    /// # Safety
    ///
    /// Ensure that the new instance of the peripheral cannot be used in a way
    /// that may race with any existing instances, for example by only
    /// accessing read-only or write-only registers, or by consuming the
    /// original peripheral and using critical sections to coordinate
    /// access between multiple new instances.
    ///
    /// Additionally, other software such as HALs may rely on only one
    /// peripheral instance existing to ensure memory safety; ensure
    /// no stolen instances are passed to such software.
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for UART1 {
    type Target = uart1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for UART1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("UART1").finish()
    }
}
///UART1 register
pub mod uart1 {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        mcr: MCR,
        ier: IER,
        fcr: FCR,
        lcr: LCR,
        iir: IIR,
        lsr: LSR,
        _reserved6: [u8; 0x02],
        _reserved_6_rbr: [u8; 0x01],
        _reserved7: [u8; 0x01],
        rfc: RFC,
        tfc: TFC,
        dl: DL,
        div: DIV,
    }
    impl RegisterBlock {
        ///0x00 - RW, UART1 modem control
        #[inline(always)]
        pub const fn mcr(&self) -> &MCR {
            &self.mcr
        }
        ///0x01 - RW, UART1 interrupt enable
        #[inline(always)]
        pub const fn ier(&self) -> &IER {
            &self.ier
        }
        ///0x02 - RW, UART1 FIFO control
        #[inline(always)]
        pub const fn fcr(&self) -> &FCR {
            &self.fcr
        }
        ///0x03 - RW, UART1 line control
        #[inline(always)]
        pub const fn lcr(&self) -> &LCR {
            &self.lcr
        }
        ///0x04 - RO, UART1 interrupt identification
        #[inline(always)]
        pub const fn iir(&self) -> &IIR {
            &self.iir
        }
        ///0x05 - RO, UART1 line status
        #[inline(always)]
        pub const fn lsr(&self) -> &LSR {
            &self.lsr
        }
        ///0x08 - WO, UART1 transmitter holding, transmittal byte
        #[inline(always)]
        pub const fn thr(&self) -> &THR {
            unsafe { &*(self as *const Self).cast::<u8>().add(8).cast() }
        }
        ///0x08 - RO, UART1 receiver buffer, receiving byte
        #[inline(always)]
        pub const fn rbr(&self) -> &RBR {
            unsafe { &*(self as *const Self).cast::<u8>().add(8).cast() }
        }
        ///0x0a - RO, UART1 receiver FIFO count
        #[inline(always)]
        pub const fn rfc(&self) -> &RFC {
            &self.rfc
        }
        ///0x0b - RO, UART1 transmitter FIFO count
        #[inline(always)]
        pub const fn tfc(&self) -> &TFC {
            &self.tfc
        }
        ///0x0c - RW, UART1 divisor latch
        #[inline(always)]
        pub const fn dl(&self) -> &DL {
            &self.dl
        }
        ///0x0e - RW, UART1 pre-divisor latch byte, only low 7 bit, from 1 to 128
        #[inline(always)]
        pub const fn div(&self) -> &DIV {
            &self.div
        }
    }
    ///MCR (rw) register accessor: RW, UART1 modem control
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`mcr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`mcr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@mcr`]
    ///module
    pub type MCR = crate::Reg<mcr::MCR_SPEC>;
    ///RW, UART1 modem control
    pub mod mcr {
        ///Register `MCR` reader
        pub type R = crate::R<MCR_SPEC>;
        ///Register `MCR` writer
        pub type W = crate::W<MCR_SPEC>;
        ///Field `MCR_OUT2__RB_MCR_INT_OE` reader - RW, UART control OUT2/UART interrupt output enable
        pub type MCR_OUT2__RB_MCR_INT_OE_R = crate::BitReader;
        ///Field `MCR_OUT2__RB_MCR_INT_OE` writer - RW, UART control OUT2/UART interrupt output enable
        pub type MCR_OUT2__RB_MCR_INT_OE_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 3 - RW, UART control OUT2/UART interrupt output enable
            #[inline(always)]
            pub fn mcr_out2__rb_mcr_int_oe(&self) -> MCR_OUT2__RB_MCR_INT_OE_R {
                MCR_OUT2__RB_MCR_INT_OE_R::new(((self.bits >> 3) & 1) != 0)
            }
        }
        impl W {
            ///Bit 3 - RW, UART control OUT2/UART interrupt output enable
            #[inline(always)]
            #[must_use]
            pub fn mcr_out2__rb_mcr_int_oe(&mut self) -> MCR_OUT2__RB_MCR_INT_OE_W<MCR_SPEC> {
                MCR_OUT2__RB_MCR_INT_OE_W::new(self, 3)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW, UART1 modem control
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`mcr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`mcr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct MCR_SPEC;
        impl crate::RegisterSpec for MCR_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`mcr::R`](R) reader structure
        impl crate::Readable for MCR_SPEC {}
        ///`write(|w| ..)` method takes [`mcr::W`](W) writer structure
        impl crate::Writable for MCR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets MCR to value 0
        impl crate::Resettable for MCR_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///IER (rw) register accessor: RW, UART1 interrupt enable
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`ier::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ier::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@ier`]
    ///module
    pub type IER = crate::Reg<ier::IER_SPEC>;
    ///RW, UART1 interrupt enable
    pub mod ier {
        ///Register `IER` reader
        pub type R = crate::R<IER_SPEC>;
        ///Register `IER` writer
        pub type W = crate::W<IER_SPEC>;
        ///Field `IER_RECV_RDY` reader - RW, UART interrupt enable for receiver data ready
        pub type IER_RECV_RDY_R = crate::BitReader;
        ///Field `IER_RECV_RDY` writer - RW, UART interrupt enable for receiver data ready
        pub type IER_RECV_RDY_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `IER_THR_EMPTY` reader - RW, UART interrupt enable for THR empty
        pub type IER_THR_EMPTY_R = crate::BitReader;
        ///Field `IER_THR_EMPTY` writer - RW, UART interrupt enable for THR empty
        pub type IER_THR_EMPTY_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `IER_LINE_STAT` reader - RW, UART interrupt enable for receiver line status
        pub type IER_LINE_STAT_R = crate::BitReader;
        ///Field `IER_LINE_STAT` writer - RW, UART interrupt enable for receiver line status
        pub type IER_LINE_STAT_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `IER_TXD_EN` reader - RW, UART TXD pin enable
        pub type IER_TXD_EN_R = crate::BitReader;
        ///Field `IER_TXD_EN` writer - RW, UART TXD pin enable
        pub type IER_TXD_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `IER_RESET` reader - WZ, UART software reset control, high action, auto clear
        pub type IER_RESET_R = crate::BitReader;
        ///Field `IER_RESET` writer - WZ, UART software reset control, high action, auto clear
        pub type IER_RESET_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - RW, UART interrupt enable for receiver data ready
            #[inline(always)]
            pub fn ier_recv_rdy(&self) -> IER_RECV_RDY_R {
                IER_RECV_RDY_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RW, UART interrupt enable for THR empty
            #[inline(always)]
            pub fn ier_thr_empty(&self) -> IER_THR_EMPTY_R {
                IER_THR_EMPTY_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RW, UART interrupt enable for receiver line status
            #[inline(always)]
            pub fn ier_line_stat(&self) -> IER_LINE_STAT_R {
                IER_LINE_STAT_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 6 - RW, UART TXD pin enable
            #[inline(always)]
            pub fn ier_txd_en(&self) -> IER_TXD_EN_R {
                IER_TXD_EN_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - WZ, UART software reset control, high action, auto clear
            #[inline(always)]
            pub fn ier_reset(&self) -> IER_RESET_R {
                IER_RESET_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RW, UART interrupt enable for receiver data ready
            #[inline(always)]
            #[must_use]
            pub fn ier_recv_rdy(&mut self) -> IER_RECV_RDY_W<IER_SPEC> {
                IER_RECV_RDY_W::new(self, 0)
            }
            ///Bit 1 - RW, UART interrupt enable for THR empty
            #[inline(always)]
            #[must_use]
            pub fn ier_thr_empty(&mut self) -> IER_THR_EMPTY_W<IER_SPEC> {
                IER_THR_EMPTY_W::new(self, 1)
            }
            ///Bit 2 - RW, UART interrupt enable for receiver line status
            #[inline(always)]
            #[must_use]
            pub fn ier_line_stat(&mut self) -> IER_LINE_STAT_W<IER_SPEC> {
                IER_LINE_STAT_W::new(self, 2)
            }
            ///Bit 6 - RW, UART TXD pin enable
            #[inline(always)]
            #[must_use]
            pub fn ier_txd_en(&mut self) -> IER_TXD_EN_W<IER_SPEC> {
                IER_TXD_EN_W::new(self, 6)
            }
            ///Bit 7 - WZ, UART software reset control, high action, auto clear
            #[inline(always)]
            #[must_use]
            pub fn ier_reset(&mut self) -> IER_RESET_W<IER_SPEC> {
                IER_RESET_W::new(self, 7)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW, UART1 interrupt enable
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`ier::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ier::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IER_SPEC;
        impl crate::RegisterSpec for IER_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`ier::R`](R) reader structure
        impl crate::Readable for IER_SPEC {}
        ///`write(|w| ..)` method takes [`ier::W`](W) writer structure
        impl crate::Writable for IER_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets IER to value 0
        impl crate::Resettable for IER_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///FCR (rw) register accessor: RW, UART1 FIFO control
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`fcr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`fcr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@fcr`]
    ///module
    pub type FCR = crate::Reg<fcr::FCR_SPEC>;
    ///RW, UART1 FIFO control
    pub mod fcr {
        ///Register `FCR` reader
        pub type R = crate::R<FCR_SPEC>;
        ///Register `FCR` writer
        pub type W = crate::W<FCR_SPEC>;
        ///Field `FCR_FIFO_EN` reader - RW, UART FIFO enable
        pub type FCR_FIFO_EN_R = crate::BitReader;
        ///Field `FCR_FIFO_EN` writer - RW, UART FIFO enable
        pub type FCR_FIFO_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FCR_RX_FIFO_CLR` reader - WZ, clear UART receiver FIFO, high action, auto clear
        pub type FCR_RX_FIFO_CLR_R = crate::BitReader;
        ///Field `FCR_RX_FIFO_CLR` writer - WZ, clear UART receiver FIFO, high action, auto clear
        pub type FCR_RX_FIFO_CLR_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FCR_TX_FIFO_CLR` reader - WZ, clear UART transmitter FIFO, high action, auto clear
        pub type FCR_TX_FIFO_CLR_R = crate::BitReader;
        ///Field `FCR_TX_FIFO_CLR` writer - WZ, clear UART transmitter FIFO, high action, auto clear
        pub type FCR_TX_FIFO_CLR_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FCR_FIFO_TRIG` reader - RW, UART receiver FIFO trigger level: 00-1byte, 01-2bytes, 10-4bytes, 11-7bytes
        pub type FCR_FIFO_TRIG_R = crate::FieldReader;
        ///Field `FCR_FIFO_TRIG` writer - RW, UART receiver FIFO trigger level: 00-1byte, 01-2bytes, 10-4bytes, 11-7bytes
        pub type FCR_FIFO_TRIG_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        impl R {
            ///Bit 0 - RW, UART FIFO enable
            #[inline(always)]
            pub fn fcr_fifo_en(&self) -> FCR_FIFO_EN_R {
                FCR_FIFO_EN_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - WZ, clear UART receiver FIFO, high action, auto clear
            #[inline(always)]
            pub fn fcr_rx_fifo_clr(&self) -> FCR_RX_FIFO_CLR_R {
                FCR_RX_FIFO_CLR_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - WZ, clear UART transmitter FIFO, high action, auto clear
            #[inline(always)]
            pub fn fcr_tx_fifo_clr(&self) -> FCR_TX_FIFO_CLR_R {
                FCR_TX_FIFO_CLR_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bits 6:7 - RW, UART receiver FIFO trigger level: 00-1byte, 01-2bytes, 10-4bytes, 11-7bytes
            #[inline(always)]
            pub fn fcr_fifo_trig(&self) -> FCR_FIFO_TRIG_R {
                FCR_FIFO_TRIG_R::new((self.bits >> 6) & 3)
            }
        }
        impl W {
            ///Bit 0 - RW, UART FIFO enable
            #[inline(always)]
            #[must_use]
            pub fn fcr_fifo_en(&mut self) -> FCR_FIFO_EN_W<FCR_SPEC> {
                FCR_FIFO_EN_W::new(self, 0)
            }
            ///Bit 1 - WZ, clear UART receiver FIFO, high action, auto clear
            #[inline(always)]
            #[must_use]
            pub fn fcr_rx_fifo_clr(&mut self) -> FCR_RX_FIFO_CLR_W<FCR_SPEC> {
                FCR_RX_FIFO_CLR_W::new(self, 1)
            }
            ///Bit 2 - WZ, clear UART transmitter FIFO, high action, auto clear
            #[inline(always)]
            #[must_use]
            pub fn fcr_tx_fifo_clr(&mut self) -> FCR_TX_FIFO_CLR_W<FCR_SPEC> {
                FCR_TX_FIFO_CLR_W::new(self, 2)
            }
            ///Bits 6:7 - RW, UART receiver FIFO trigger level: 00-1byte, 01-2bytes, 10-4bytes, 11-7bytes
            #[inline(always)]
            #[must_use]
            pub fn fcr_fifo_trig(&mut self) -> FCR_FIFO_TRIG_W<FCR_SPEC> {
                FCR_FIFO_TRIG_W::new(self, 6)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW, UART1 FIFO control
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`fcr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`fcr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct FCR_SPEC;
        impl crate::RegisterSpec for FCR_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`fcr::R`](R) reader structure
        impl crate::Readable for FCR_SPEC {}
        ///`write(|w| ..)` method takes [`fcr::W`](W) writer structure
        impl crate::Writable for FCR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets FCR to value 0
        impl crate::Resettable for FCR_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///LCR (rw) register accessor: RW, UART1 line control
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`lcr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`lcr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@lcr`]
    ///module
    pub type LCR = crate::Reg<lcr::LCR_SPEC>;
    ///RW, UART1 line control
    pub mod lcr {
        ///Register `LCR` reader
        pub type R = crate::R<LCR_SPEC>;
        ///Register `LCR` writer
        pub type W = crate::W<LCR_SPEC>;
        ///Field `LCR_WORD_SZ` reader - RW, UART word bit length: 00-5bit, 01-6bit, 10-7bit, 11-8bit
        pub type LCR_WORD_SZ_R = crate::FieldReader;
        ///Field `LCR_WORD_SZ` writer - RW, UART word bit length: 00-5bit, 01-6bit, 10-7bit, 11-8bit
        pub type LCR_WORD_SZ_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `LCR_STOP_BIT` reader - RW, UART stop bit length: 0-1bit, 1-2bit
        pub type LCR_STOP_BIT_R = crate::BitReader;
        ///Field `LCR_STOP_BIT` writer - RW, UART stop bit length: 0-1bit, 1-2bit
        pub type LCR_STOP_BIT_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `LCR_PAR_EN` reader - RW, UART parity enable
        pub type LCR_PAR_EN_R = crate::BitReader;
        ///Field `LCR_PAR_EN` writer - RW, UART parity enable
        pub type LCR_PAR_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `LCR_PAR_MOD` reader - RW, UART parity mode: 00-odd, 01-even, 10-mark, 11-space
        pub type LCR_PAR_MOD_R = crate::FieldReader;
        ///Field `LCR_PAR_MOD` writer - RW, UART parity mode: 00-odd, 01-even, 10-mark, 11-space
        pub type LCR_PAR_MOD_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `LCR_BREAK_EN` reader - RW, UART break control enable
        pub type LCR_BREAK_EN_R = crate::BitReader;
        ///Field `LCR_BREAK_EN` writer - RW, UART break control enable
        pub type LCR_BREAK_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `LCR_GP_BIT__RB_LCR_DLAB` reader - RW, UART general purpose bit;RW, UART reserved bit
        pub type LCR_GP_BIT__RB_LCR_DLAB_R = crate::BitReader;
        ///Field `LCR_GP_BIT__RB_LCR_DLAB` writer - RW, UART general purpose bit;RW, UART reserved bit
        pub type LCR_GP_BIT__RB_LCR_DLAB_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bits 0:1 - RW, UART word bit length: 00-5bit, 01-6bit, 10-7bit, 11-8bit
            #[inline(always)]
            pub fn lcr_word_sz(&self) -> LCR_WORD_SZ_R {
                LCR_WORD_SZ_R::new(self.bits & 3)
            }
            ///Bit 2 - RW, UART stop bit length: 0-1bit, 1-2bit
            #[inline(always)]
            pub fn lcr_stop_bit(&self) -> LCR_STOP_BIT_R {
                LCR_STOP_BIT_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RW, UART parity enable
            #[inline(always)]
            pub fn lcr_par_en(&self) -> LCR_PAR_EN_R {
                LCR_PAR_EN_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bits 4:5 - RW, UART parity mode: 00-odd, 01-even, 10-mark, 11-space
            #[inline(always)]
            pub fn lcr_par_mod(&self) -> LCR_PAR_MOD_R {
                LCR_PAR_MOD_R::new((self.bits >> 4) & 3)
            }
            ///Bit 6 - RW, UART break control enable
            #[inline(always)]
            pub fn lcr_break_en(&self) -> LCR_BREAK_EN_R {
                LCR_BREAK_EN_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - RW, UART general purpose bit;RW, UART reserved bit
            #[inline(always)]
            pub fn lcr_gp_bit__rb_lcr_dlab(&self) -> LCR_GP_BIT__RB_LCR_DLAB_R {
                LCR_GP_BIT__RB_LCR_DLAB_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:1 - RW, UART word bit length: 00-5bit, 01-6bit, 10-7bit, 11-8bit
            #[inline(always)]
            #[must_use]
            pub fn lcr_word_sz(&mut self) -> LCR_WORD_SZ_W<LCR_SPEC> {
                LCR_WORD_SZ_W::new(self, 0)
            }
            ///Bit 2 - RW, UART stop bit length: 0-1bit, 1-2bit
            #[inline(always)]
            #[must_use]
            pub fn lcr_stop_bit(&mut self) -> LCR_STOP_BIT_W<LCR_SPEC> {
                LCR_STOP_BIT_W::new(self, 2)
            }
            ///Bit 3 - RW, UART parity enable
            #[inline(always)]
            #[must_use]
            pub fn lcr_par_en(&mut self) -> LCR_PAR_EN_W<LCR_SPEC> {
                LCR_PAR_EN_W::new(self, 3)
            }
            ///Bits 4:5 - RW, UART parity mode: 00-odd, 01-even, 10-mark, 11-space
            #[inline(always)]
            #[must_use]
            pub fn lcr_par_mod(&mut self) -> LCR_PAR_MOD_W<LCR_SPEC> {
                LCR_PAR_MOD_W::new(self, 4)
            }
            ///Bit 6 - RW, UART break control enable
            #[inline(always)]
            #[must_use]
            pub fn lcr_break_en(&mut self) -> LCR_BREAK_EN_W<LCR_SPEC> {
                LCR_BREAK_EN_W::new(self, 6)
            }
            ///Bit 7 - RW, UART general purpose bit;RW, UART reserved bit
            #[inline(always)]
            #[must_use]
            pub fn lcr_gp_bit__rb_lcr_dlab(&mut self) -> LCR_GP_BIT__RB_LCR_DLAB_W<LCR_SPEC> {
                LCR_GP_BIT__RB_LCR_DLAB_W::new(self, 7)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW, UART1 line control
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`lcr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`lcr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct LCR_SPEC;
        impl crate::RegisterSpec for LCR_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`lcr::R`](R) reader structure
        impl crate::Readable for LCR_SPEC {}
        ///`write(|w| ..)` method takes [`lcr::W`](W) writer structure
        impl crate::Writable for LCR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets LCR to value 0
        impl crate::Resettable for LCR_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///IIR (r) register accessor: RO, UART1 interrupt identification
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iir::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iir`]
    ///module
    pub type IIR = crate::Reg<iir::IIR_SPEC>;
    ///RO, UART1 interrupt identification
    pub mod iir {
        ///Register `IIR` reader
        pub type R = crate::R<IIR_SPEC>;
        ///Field `IIR_NO_INT` reader - RO, UART no interrupt flag: 0=interrupt action, 1=no interrupt
        pub type IIR_NO_INT_R = crate::BitReader;
        ///Field `IIR_INT_MASK` reader - RO, UART interrupt flag bit mask
        pub type IIR_INT_MASK_R = crate::FieldReader;
        ///Field `IIR_FIFO_ID` reader - RO, UART FIFO enabled flag
        pub type IIR_FIFO_ID_R = crate::BitReader;
        impl R {
            ///Bit 0 - RO, UART no interrupt flag: 0=interrupt action, 1=no interrupt
            #[inline(always)]
            pub fn iir_no_int(&self) -> IIR_NO_INT_R {
                IIR_NO_INT_R::new((self.bits & 1) != 0)
            }
            ///Bits 0:3 - RO, UART interrupt flag bit mask
            #[inline(always)]
            pub fn iir_int_mask(&self) -> IIR_INT_MASK_R {
                IIR_INT_MASK_R::new(self.bits & 0x0f)
            }
            ///Bit 7 - RO, UART FIFO enabled flag
            #[inline(always)]
            pub fn iir_fifo_id(&self) -> IIR_FIFO_ID_R {
                IIR_FIFO_ID_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        ///RO, UART1 interrupt identification
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iir::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IIR_SPEC;
        impl crate::RegisterSpec for IIR_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`iir::R`](R) reader structure
        impl crate::Readable for IIR_SPEC {}
        ///`reset()` method sets IIR to value 0x01
        impl crate::Resettable for IIR_SPEC {
            const RESET_VALUE: u8 = 0x01;
        }
    }
    ///LSR (r) register accessor: RO, UART1 line status
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`lsr::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@lsr`]
    ///module
    pub type LSR = crate::Reg<lsr::LSR_SPEC>;
    ///RO, UART1 line status
    pub mod lsr {
        ///Register `LSR` reader
        pub type R = crate::R<LSR_SPEC>;
        ///Field `LSR_DATA_RDY` reader - RO, UART receiver fifo data ready status
        pub type LSR_DATA_RDY_R = crate::BitReader;
        ///Field `LSR_OVER_ERR` reader - RZ, UART receiver overrun error
        pub type LSR_OVER_ERR_R = crate::BitReader;
        ///Field `LSR_PAR_ERR` reader - RZ, UART receiver parity error
        pub type LSR_PAR_ERR_R = crate::BitReader;
        ///Field `LSR_FRAME_ERR` reader - RZ, UART receiver frame error
        pub type LSR_FRAME_ERR_R = crate::BitReader;
        ///Field `LSR_BREAK_ERR` reader - RZ, UART receiver break error
        pub type LSR_BREAK_ERR_R = crate::BitReader;
        ///Field `LSR_TX_FIFO_EMP` reader - RO, UART transmitter fifo empty status
        pub type LSR_TX_FIFO_EMP_R = crate::BitReader;
        ///Field `LSR_TX_ALL_EMP` reader - RO, UART transmitter all empty status
        pub type LSR_TX_ALL_EMP_R = crate::BitReader;
        ///Field `LSR_ERR_RX_FIFO` reader - RO, indicate error in UART receiver fifo
        pub type LSR_ERR_RX_FIFO_R = crate::BitReader;
        impl R {
            ///Bit 0 - RO, UART receiver fifo data ready status
            #[inline(always)]
            pub fn lsr_data_rdy(&self) -> LSR_DATA_RDY_R {
                LSR_DATA_RDY_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RZ, UART receiver overrun error
            #[inline(always)]
            pub fn lsr_over_err(&self) -> LSR_OVER_ERR_R {
                LSR_OVER_ERR_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RZ, UART receiver parity error
            #[inline(always)]
            pub fn lsr_par_err(&self) -> LSR_PAR_ERR_R {
                LSR_PAR_ERR_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RZ, UART receiver frame error
            #[inline(always)]
            pub fn lsr_frame_err(&self) -> LSR_FRAME_ERR_R {
                LSR_FRAME_ERR_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RZ, UART receiver break error
            #[inline(always)]
            pub fn lsr_break_err(&self) -> LSR_BREAK_ERR_R {
                LSR_BREAK_ERR_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - RO, UART transmitter fifo empty status
            #[inline(always)]
            pub fn lsr_tx_fifo_emp(&self) -> LSR_TX_FIFO_EMP_R {
                LSR_TX_FIFO_EMP_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - RO, UART transmitter all empty status
            #[inline(always)]
            pub fn lsr_tx_all_emp(&self) -> LSR_TX_ALL_EMP_R {
                LSR_TX_ALL_EMP_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - RO, indicate error in UART receiver fifo
            #[inline(always)]
            pub fn lsr_err_rx_fifo(&self) -> LSR_ERR_RX_FIFO_R {
                LSR_ERR_RX_FIFO_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        ///RO, UART1 line status
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`lsr::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct LSR_SPEC;
        impl crate::RegisterSpec for LSR_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`lsr::R`](R) reader structure
        impl crate::Readable for LSR_SPEC {}
        ///`reset()` method sets LSR to value 0x60
        impl crate::Resettable for LSR_SPEC {
            const RESET_VALUE: u8 = 0x60;
        }
    }
    ///RBR (r) register accessor: RO, UART1 receiver buffer, receiving byte
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`rbr::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@rbr`]
    ///module
    pub type RBR = crate::Reg<rbr::RBR_SPEC>;
    ///RO, UART1 receiver buffer, receiving byte
    pub mod rbr {
        ///Register `RBR` reader
        pub type R = crate::R<RBR_SPEC>;
        ///Field `RBR` reader - RO, UART1 receiver buffer, receiving byte
        pub type RBR_R = crate::FieldReader;
        impl R {
            ///Bits 0:7 - RO, UART1 receiver buffer, receiving byte
            #[inline(always)]
            pub fn rbr(&self) -> RBR_R {
                RBR_R::new(self.bits)
            }
        }
        ///RO, UART1 receiver buffer, receiving byte
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`rbr::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct RBR_SPEC;
        impl crate::RegisterSpec for RBR_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`rbr::R`](R) reader structure
        impl crate::Readable for RBR_SPEC {}
        ///`reset()` method sets RBR to value 0
        impl crate::Resettable for RBR_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///THR (w) register accessor: WO, UART1 transmitter holding, transmittal byte
    ///
    ///You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`thr::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@thr`]
    ///module
    pub type THR = crate::Reg<thr::THR_SPEC>;
    ///WO, UART1 transmitter holding, transmittal byte
    pub mod thr {
        ///Register `THR` writer
        pub type W = crate::W<THR_SPEC>;
        ///Field `RBR` writer - WO, UART1 transmitter holding, transmittal byte
        pub type RBR_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl W {
            ///Bits 0:7 - WO, UART1 transmitter holding, transmittal byte
            #[inline(always)]
            #[must_use]
            pub fn rbr(&mut self) -> RBR_W<THR_SPEC> {
                RBR_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///WO, UART1 transmitter holding, transmittal byte
        ///
        ///You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`thr::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct THR_SPEC;
        impl crate::RegisterSpec for THR_SPEC {
            type Ux = u8;
        }
        ///`write(|w| ..)` method takes [`thr::W`](W) writer structure
        impl crate::Writable for THR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets THR to value 0
        impl crate::Resettable for THR_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///RFC (r) register accessor: RO, UART1 receiver FIFO count
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`rfc::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@rfc`]
    ///module
    pub type RFC = crate::Reg<rfc::RFC_SPEC>;
    ///RO, UART1 receiver FIFO count
    pub mod rfc {
        ///Register `RFC` reader
        pub type R = crate::R<RFC_SPEC>;
        ///Field `RFC` reader - RO, UART1 receiver FIFO count
        pub type RFC_R = crate::FieldReader;
        impl R {
            ///Bits 0:7 - RO, UART1 receiver FIFO count
            #[inline(always)]
            pub fn rfc(&self) -> RFC_R {
                RFC_R::new(self.bits)
            }
        }
        ///RO, UART1 receiver FIFO count
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`rfc::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct RFC_SPEC;
        impl crate::RegisterSpec for RFC_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`rfc::R`](R) reader structure
        impl crate::Readable for RFC_SPEC {}
        ///`reset()` method sets RFC to value 0
        impl crate::Resettable for RFC_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///TFC (r) register accessor: RO, UART1 transmitter FIFO count
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`tfc::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@tfc`]
    ///module
    pub type TFC = crate::Reg<tfc::TFC_SPEC>;
    ///RO, UART1 transmitter FIFO count
    pub mod tfc {
        ///Register `TFC` reader
        pub type R = crate::R<TFC_SPEC>;
        ///Field `TFC` reader - RO, UART1 receiver FIFO count
        pub type TFC_R = crate::FieldReader;
        impl R {
            ///Bits 0:7 - RO, UART1 receiver FIFO count
            #[inline(always)]
            pub fn tfc(&self) -> TFC_R {
                TFC_R::new(self.bits)
            }
        }
        ///RO, UART1 transmitter FIFO count
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`tfc::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct TFC_SPEC;
        impl crate::RegisterSpec for TFC_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`tfc::R`](R) reader structure
        impl crate::Readable for TFC_SPEC {}
        ///`reset()` method sets TFC to value 0
        impl crate::Resettable for TFC_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///DL (rw) register accessor: RW, UART1 divisor latch
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`dl::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dl::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@dl`]
    ///module
    pub type DL = crate::Reg<dl::DL_SPEC>;
    ///RW, UART1 divisor latch
    pub mod dl {
        ///Register `DL` reader
        pub type R = crate::R<DL_SPEC>;
        ///Register `DL` writer
        pub type W = crate::W<DL_SPEC>;
        ///Field `DL` reader - RW, UART1 divisor latch
        pub type DL_R = crate::FieldReader<u16>;
        ///Field `DL` writer - RW, UART1 divisor latch
        pub type DL_W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            ///Bits 0:15 - RW, UART1 divisor latch
            #[inline(always)]
            pub fn dl(&self) -> DL_R {
                DL_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - RW, UART1 divisor latch
            #[inline(always)]
            #[must_use]
            pub fn dl(&mut self) -> DL_W<DL_SPEC> {
                DL_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW, UART1 divisor latch
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`dl::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dl::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct DL_SPEC;
        impl crate::RegisterSpec for DL_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`dl::R`](R) reader structure
        impl crate::Readable for DL_SPEC {}
        ///`write(|w| ..)` method takes [`dl::W`](W) writer structure
        impl crate::Writable for DL_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets DL to value 0
        impl crate::Resettable for DL_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///DIV (rw) register accessor: RW, UART1 pre-divisor latch byte, only low 7 bit, from 1 to 128
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`div::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`div::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@div`]
    ///module
    pub type DIV = crate::Reg<div::DIV_SPEC>;
    ///RW, UART1 pre-divisor latch byte, only low 7 bit, from 1 to 128
    pub mod div {
        ///Register `DIV` reader
        pub type R = crate::R<DIV_SPEC>;
        ///Register `DIV` writer
        pub type W = crate::W<DIV_SPEC>;
        ///Field `DIV` reader - RW, UART1 pre-divisor latch byte, only low 7 bit, from 1 to 128
        pub type DIV_R = crate::FieldReader;
        ///Field `DIV` writer - RW, UART1 pre-divisor latch byte, only low 7 bit, from 1 to 128
        pub type DIV_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            ///Bits 0:7 - RW, UART1 pre-divisor latch byte, only low 7 bit, from 1 to 128
            #[inline(always)]
            pub fn div(&self) -> DIV_R {
                DIV_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:7 - RW, UART1 pre-divisor latch byte, only low 7 bit, from 1 to 128
            #[inline(always)]
            #[must_use]
            pub fn div(&mut self) -> DIV_W<DIV_SPEC> {
                DIV_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW, UART1 pre-divisor latch byte, only low 7 bit, from 1 to 128
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`div::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`div::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct DIV_SPEC;
        impl crate::RegisterSpec for DIV_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`div::R`](R) reader structure
        impl crate::Readable for DIV_SPEC {}
        ///`write(|w| ..)` method takes [`div::W`](W) writer structure
        impl crate::Writable for DIV_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets DIV to value 0
        impl crate::Resettable for DIV_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
}
///UART2 register
pub struct UART2 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for UART2 {}
impl UART2 {
    ///Pointer to the register block
    pub const PTR: *const uart2::RegisterBlock = 0x4000_3800 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const uart2::RegisterBlock {
        Self::PTR
    }
    /// Steal an instance of this peripheral
    ///
    /// # Safety
    ///
    /// Ensure that the new instance of the peripheral cannot be used in a way
    /// that may race with any existing instances, for example by only
    /// accessing read-only or write-only registers, or by consuming the
    /// original peripheral and using critical sections to coordinate
    /// access between multiple new instances.
    ///
    /// Additionally, other software such as HALs may rely on only one
    /// peripheral instance existing to ensure memory safety; ensure
    /// no stolen instances are passed to such software.
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for UART2 {
    type Target = uart2::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for UART2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("UART2").finish()
    }
}
///UART2 register
pub mod uart2 {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        mcr: MCR,
        ier: IER,
        fcr: FCR,
        lcr: LCR,
        iir: IIR,
        lsr: LSR,
        _reserved6: [u8; 0x02],
        _reserved_6_rbr: [u8; 0x01],
        _reserved7: [u8; 0x01],
        rfc: RFC,
        tfc: TFC,
        dl: DL,
        div: DIV,
    }
    impl RegisterBlock {
        ///0x00 - RW, UART2 modem control
        #[inline(always)]
        pub const fn mcr(&self) -> &MCR {
            &self.mcr
        }
        ///0x01 - RW, UART2 interrupt enable
        #[inline(always)]
        pub const fn ier(&self) -> &IER {
            &self.ier
        }
        ///0x02 - RW, UART2 FIFO control
        #[inline(always)]
        pub const fn fcr(&self) -> &FCR {
            &self.fcr
        }
        ///0x03 - RW, UART2 line control
        #[inline(always)]
        pub const fn lcr(&self) -> &LCR {
            &self.lcr
        }
        ///0x04 - RO, UART2 interrupt identification
        #[inline(always)]
        pub const fn iir(&self) -> &IIR {
            &self.iir
        }
        ///0x05 - RO, UART2 line status
        #[inline(always)]
        pub const fn lsr(&self) -> &LSR {
            &self.lsr
        }
        ///0x08 - WO, UART2 transmitter holding, transmittal byte
        #[inline(always)]
        pub const fn thr(&self) -> &THR {
            unsafe { &*(self as *const Self).cast::<u8>().add(8).cast() }
        }
        ///0x08 - RO, UART2 receiver buffer, receiving byte
        #[inline(always)]
        pub const fn rbr(&self) -> &RBR {
            unsafe { &*(self as *const Self).cast::<u8>().add(8).cast() }
        }
        ///0x0a - RO, UART2 receiver FIFO count
        #[inline(always)]
        pub const fn rfc(&self) -> &RFC {
            &self.rfc
        }
        ///0x0b - RO, UART2 transmitter FIFO count
        #[inline(always)]
        pub const fn tfc(&self) -> &TFC {
            &self.tfc
        }
        ///0x0c - RW, UART2 divisor latch
        #[inline(always)]
        pub const fn dl(&self) -> &DL {
            &self.dl
        }
        ///0x0e - RW, UART2 pre-divisor latch byte, only low 7 bit, from 1 to 128
        #[inline(always)]
        pub const fn div(&self) -> &DIV {
            &self.div
        }
    }
    ///MCR (rw) register accessor: RW, UART2 modem control
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`mcr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`mcr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@mcr`]
    ///module
    pub type MCR = crate::Reg<mcr::MCR_SPEC>;
    ///RW, UART2 modem control
    pub mod mcr {
        ///Register `MCR` reader
        pub type R = crate::R<MCR_SPEC>;
        ///Register `MCR` writer
        pub type W = crate::W<MCR_SPEC>;
        ///Field `MCR_OUT2__RB_MCR_INT_OE` reader - RW, UART control OUT2;UART interrupt output enable
        pub type MCR_OUT2__RB_MCR_INT_OE_R = crate::BitReader;
        ///Field `MCR_OUT2__RB_MCR_INT_OE` writer - RW, UART control OUT2;UART interrupt output enable
        pub type MCR_OUT2__RB_MCR_INT_OE_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 3 - RW, UART control OUT2;UART interrupt output enable
            #[inline(always)]
            pub fn mcr_out2__rb_mcr_int_oe(&self) -> MCR_OUT2__RB_MCR_INT_OE_R {
                MCR_OUT2__RB_MCR_INT_OE_R::new(((self.bits >> 3) & 1) != 0)
            }
        }
        impl W {
            ///Bit 3 - RW, UART control OUT2;UART interrupt output enable
            #[inline(always)]
            #[must_use]
            pub fn mcr_out2__rb_mcr_int_oe(&mut self) -> MCR_OUT2__RB_MCR_INT_OE_W<MCR_SPEC> {
                MCR_OUT2__RB_MCR_INT_OE_W::new(self, 3)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW, UART2 modem control
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`mcr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`mcr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct MCR_SPEC;
        impl crate::RegisterSpec for MCR_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`mcr::R`](R) reader structure
        impl crate::Readable for MCR_SPEC {}
        ///`write(|w| ..)` method takes [`mcr::W`](W) writer structure
        impl crate::Writable for MCR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets MCR to value 0
        impl crate::Resettable for MCR_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///IER (rw) register accessor: RW, UART2 interrupt enable
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`ier::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ier::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@ier`]
    ///module
    pub type IER = crate::Reg<ier::IER_SPEC>;
    ///RW, UART2 interrupt enable
    pub mod ier {
        ///Register `IER` reader
        pub type R = crate::R<IER_SPEC>;
        ///Register `IER` writer
        pub type W = crate::W<IER_SPEC>;
        ///Field `IER_RECV_RDY` reader - RW, UART interrupt enable for receiver data ready
        pub type IER_RECV_RDY_R = crate::BitReader;
        ///Field `IER_RECV_RDY` writer - RW, UART interrupt enable for receiver data ready
        pub type IER_RECV_RDY_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `IER_THR_EMPTY` reader - RW, UART interrupt enable for THR empty
        pub type IER_THR_EMPTY_R = crate::BitReader;
        ///Field `IER_THR_EMPTY` writer - RW, UART interrupt enable for THR empty
        pub type IER_THR_EMPTY_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `IER_LINE_STAT` reader - RW, UART interrupt enable for receiver line status
        pub type IER_LINE_STAT_R = crate::BitReader;
        ///Field `IER_LINE_STAT` writer - RW, UART interrupt enable for receiver line status
        pub type IER_LINE_STAT_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `IER_TXD_EN` reader - RW, UART TXD pin enable
        pub type IER_TXD_EN_R = crate::BitReader;
        ///Field `IER_TXD_EN` writer - RW, UART TXD pin enable
        pub type IER_TXD_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `IER_RESET` reader - WZ, UART software reset control, high action, auto clear
        pub type IER_RESET_R = crate::BitReader;
        ///Field `IER_RESET` writer - WZ, UART software reset control, high action, auto clear
        pub type IER_RESET_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - RW, UART interrupt enable for receiver data ready
            #[inline(always)]
            pub fn ier_recv_rdy(&self) -> IER_RECV_RDY_R {
                IER_RECV_RDY_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RW, UART interrupt enable for THR empty
            #[inline(always)]
            pub fn ier_thr_empty(&self) -> IER_THR_EMPTY_R {
                IER_THR_EMPTY_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RW, UART interrupt enable for receiver line status
            #[inline(always)]
            pub fn ier_line_stat(&self) -> IER_LINE_STAT_R {
                IER_LINE_STAT_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 6 - RW, UART TXD pin enable
            #[inline(always)]
            pub fn ier_txd_en(&self) -> IER_TXD_EN_R {
                IER_TXD_EN_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - WZ, UART software reset control, high action, auto clear
            #[inline(always)]
            pub fn ier_reset(&self) -> IER_RESET_R {
                IER_RESET_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RW, UART interrupt enable for receiver data ready
            #[inline(always)]
            #[must_use]
            pub fn ier_recv_rdy(&mut self) -> IER_RECV_RDY_W<IER_SPEC> {
                IER_RECV_RDY_W::new(self, 0)
            }
            ///Bit 1 - RW, UART interrupt enable for THR empty
            #[inline(always)]
            #[must_use]
            pub fn ier_thr_empty(&mut self) -> IER_THR_EMPTY_W<IER_SPEC> {
                IER_THR_EMPTY_W::new(self, 1)
            }
            ///Bit 2 - RW, UART interrupt enable for receiver line status
            #[inline(always)]
            #[must_use]
            pub fn ier_line_stat(&mut self) -> IER_LINE_STAT_W<IER_SPEC> {
                IER_LINE_STAT_W::new(self, 2)
            }
            ///Bit 6 - RW, UART TXD pin enable
            #[inline(always)]
            #[must_use]
            pub fn ier_txd_en(&mut self) -> IER_TXD_EN_W<IER_SPEC> {
                IER_TXD_EN_W::new(self, 6)
            }
            ///Bit 7 - WZ, UART software reset control, high action, auto clear
            #[inline(always)]
            #[must_use]
            pub fn ier_reset(&mut self) -> IER_RESET_W<IER_SPEC> {
                IER_RESET_W::new(self, 7)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW, UART2 interrupt enable
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`ier::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ier::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IER_SPEC;
        impl crate::RegisterSpec for IER_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`ier::R`](R) reader structure
        impl crate::Readable for IER_SPEC {}
        ///`write(|w| ..)` method takes [`ier::W`](W) writer structure
        impl crate::Writable for IER_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets IER to value 0
        impl crate::Resettable for IER_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///FCR (rw) register accessor: RW, UART2 FIFO control
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`fcr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`fcr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@fcr`]
    ///module
    pub type FCR = crate::Reg<fcr::FCR_SPEC>;
    ///RW, UART2 FIFO control
    pub mod fcr {
        ///Register `FCR` reader
        pub type R = crate::R<FCR_SPEC>;
        ///Register `FCR` writer
        pub type W = crate::W<FCR_SPEC>;
        ///Field `FCR_FIFO_EN` reader - RW, UART FIFO enable
        pub type FCR_FIFO_EN_R = crate::BitReader;
        ///Field `FCR_FIFO_EN` writer - RW, UART FIFO enable
        pub type FCR_FIFO_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FCR_RX_FIFO_CLR` reader - WZ, clear UART receiver FIFO, high action, auto clear
        pub type FCR_RX_FIFO_CLR_R = crate::BitReader;
        ///Field `FCR_RX_FIFO_CLR` writer - WZ, clear UART receiver FIFO, high action, auto clear
        pub type FCR_RX_FIFO_CLR_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FCR_TX_FIFO_CLR` reader - WZ, clear UART transmitter FIFO, high action, auto clear
        pub type FCR_TX_FIFO_CLR_R = crate::BitReader;
        ///Field `FCR_TX_FIFO_CLR` writer - WZ, clear UART transmitter FIFO, high action, auto clear
        pub type FCR_TX_FIFO_CLR_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FCR_FIFO_TRIG` reader - RW, UART receiver FIFO trigger level: 00-1byte, 01-2bytes, 10-4bytes, 11-7bytes
        pub type FCR_FIFO_TRIG_R = crate::FieldReader;
        ///Field `FCR_FIFO_TRIG` writer - RW, UART receiver FIFO trigger level: 00-1byte, 01-2bytes, 10-4bytes, 11-7bytes
        pub type FCR_FIFO_TRIG_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        impl R {
            ///Bit 0 - RW, UART FIFO enable
            #[inline(always)]
            pub fn fcr_fifo_en(&self) -> FCR_FIFO_EN_R {
                FCR_FIFO_EN_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - WZ, clear UART receiver FIFO, high action, auto clear
            #[inline(always)]
            pub fn fcr_rx_fifo_clr(&self) -> FCR_RX_FIFO_CLR_R {
                FCR_RX_FIFO_CLR_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - WZ, clear UART transmitter FIFO, high action, auto clear
            #[inline(always)]
            pub fn fcr_tx_fifo_clr(&self) -> FCR_TX_FIFO_CLR_R {
                FCR_TX_FIFO_CLR_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bits 6:7 - RW, UART receiver FIFO trigger level: 00-1byte, 01-2bytes, 10-4bytes, 11-7bytes
            #[inline(always)]
            pub fn fcr_fifo_trig(&self) -> FCR_FIFO_TRIG_R {
                FCR_FIFO_TRIG_R::new((self.bits >> 6) & 3)
            }
        }
        impl W {
            ///Bit 0 - RW, UART FIFO enable
            #[inline(always)]
            #[must_use]
            pub fn fcr_fifo_en(&mut self) -> FCR_FIFO_EN_W<FCR_SPEC> {
                FCR_FIFO_EN_W::new(self, 0)
            }
            ///Bit 1 - WZ, clear UART receiver FIFO, high action, auto clear
            #[inline(always)]
            #[must_use]
            pub fn fcr_rx_fifo_clr(&mut self) -> FCR_RX_FIFO_CLR_W<FCR_SPEC> {
                FCR_RX_FIFO_CLR_W::new(self, 1)
            }
            ///Bit 2 - WZ, clear UART transmitter FIFO, high action, auto clear
            #[inline(always)]
            #[must_use]
            pub fn fcr_tx_fifo_clr(&mut self) -> FCR_TX_FIFO_CLR_W<FCR_SPEC> {
                FCR_TX_FIFO_CLR_W::new(self, 2)
            }
            ///Bits 6:7 - RW, UART receiver FIFO trigger level: 00-1byte, 01-2bytes, 10-4bytes, 11-7bytes
            #[inline(always)]
            #[must_use]
            pub fn fcr_fifo_trig(&mut self) -> FCR_FIFO_TRIG_W<FCR_SPEC> {
                FCR_FIFO_TRIG_W::new(self, 6)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW, UART2 FIFO control
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`fcr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`fcr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct FCR_SPEC;
        impl crate::RegisterSpec for FCR_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`fcr::R`](R) reader structure
        impl crate::Readable for FCR_SPEC {}
        ///`write(|w| ..)` method takes [`fcr::W`](W) writer structure
        impl crate::Writable for FCR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets FCR to value 0
        impl crate::Resettable for FCR_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///LCR (rw) register accessor: RW, UART2 line control
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`lcr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`lcr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@lcr`]
    ///module
    pub type LCR = crate::Reg<lcr::LCR_SPEC>;
    ///RW, UART2 line control
    pub mod lcr {
        ///Register `LCR` reader
        pub type R = crate::R<LCR_SPEC>;
        ///Register `LCR` writer
        pub type W = crate::W<LCR_SPEC>;
        ///Field `LCR_WORD_SZ` reader - RW, UART word bit length: 00-5bit, 01-6bit, 10-7bit, 11-8bit
        pub type LCR_WORD_SZ_R = crate::FieldReader;
        ///Field `LCR_WORD_SZ` writer - RW, UART word bit length: 00-5bit, 01-6bit, 10-7bit, 11-8bit
        pub type LCR_WORD_SZ_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `LCR_STOP_BIT` reader - RW, UART stop bit length: 0-1bit, 1-2bit
        pub type LCR_STOP_BIT_R = crate::BitReader;
        ///Field `LCR_STOP_BIT` writer - RW, UART stop bit length: 0-1bit, 1-2bit
        pub type LCR_STOP_BIT_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `LCR_PAR_EN` reader - RW, UART parity enable
        pub type LCR_PAR_EN_R = crate::BitReader;
        ///Field `LCR_PAR_EN` writer - RW, UART parity enable
        pub type LCR_PAR_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `LCR_PAR_MOD` reader - RW, UART parity mode: 00-odd, 01-even, 10-mark, 11-space
        pub type LCR_PAR_MOD_R = crate::FieldReader;
        ///Field `LCR_PAR_MOD` writer - RW, UART parity mode: 00-odd, 01-even, 10-mark, 11-space
        pub type LCR_PAR_MOD_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `LCR_BREAK_EN` reader - RW, UART break control enable
        pub type LCR_BREAK_EN_R = crate::BitReader;
        ///Field `LCR_BREAK_EN` writer - RW, UART break control enable
        pub type LCR_BREAK_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `LCR_GP_BIT__RB_LCR_DLAB` reader - RW, UART general purpose bit;RW, UART reserved bit
        pub type LCR_GP_BIT__RB_LCR_DLAB_R = crate::BitReader;
        ///Field `LCR_GP_BIT__RB_LCR_DLAB` writer - RW, UART general purpose bit;RW, UART reserved bit
        pub type LCR_GP_BIT__RB_LCR_DLAB_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bits 0:1 - RW, UART word bit length: 00-5bit, 01-6bit, 10-7bit, 11-8bit
            #[inline(always)]
            pub fn lcr_word_sz(&self) -> LCR_WORD_SZ_R {
                LCR_WORD_SZ_R::new(self.bits & 3)
            }
            ///Bit 2 - RW, UART stop bit length: 0-1bit, 1-2bit
            #[inline(always)]
            pub fn lcr_stop_bit(&self) -> LCR_STOP_BIT_R {
                LCR_STOP_BIT_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RW, UART parity enable
            #[inline(always)]
            pub fn lcr_par_en(&self) -> LCR_PAR_EN_R {
                LCR_PAR_EN_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bits 4:5 - RW, UART parity mode: 00-odd, 01-even, 10-mark, 11-space
            #[inline(always)]
            pub fn lcr_par_mod(&self) -> LCR_PAR_MOD_R {
                LCR_PAR_MOD_R::new((self.bits >> 4) & 3)
            }
            ///Bit 6 - RW, UART break control enable
            #[inline(always)]
            pub fn lcr_break_en(&self) -> LCR_BREAK_EN_R {
                LCR_BREAK_EN_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - RW, UART general purpose bit;RW, UART reserved bit
            #[inline(always)]
            pub fn lcr_gp_bit__rb_lcr_dlab(&self) -> LCR_GP_BIT__RB_LCR_DLAB_R {
                LCR_GP_BIT__RB_LCR_DLAB_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:1 - RW, UART word bit length: 00-5bit, 01-6bit, 10-7bit, 11-8bit
            #[inline(always)]
            #[must_use]
            pub fn lcr_word_sz(&mut self) -> LCR_WORD_SZ_W<LCR_SPEC> {
                LCR_WORD_SZ_W::new(self, 0)
            }
            ///Bit 2 - RW, UART stop bit length: 0-1bit, 1-2bit
            #[inline(always)]
            #[must_use]
            pub fn lcr_stop_bit(&mut self) -> LCR_STOP_BIT_W<LCR_SPEC> {
                LCR_STOP_BIT_W::new(self, 2)
            }
            ///Bit 3 - RW, UART parity enable
            #[inline(always)]
            #[must_use]
            pub fn lcr_par_en(&mut self) -> LCR_PAR_EN_W<LCR_SPEC> {
                LCR_PAR_EN_W::new(self, 3)
            }
            ///Bits 4:5 - RW, UART parity mode: 00-odd, 01-even, 10-mark, 11-space
            #[inline(always)]
            #[must_use]
            pub fn lcr_par_mod(&mut self) -> LCR_PAR_MOD_W<LCR_SPEC> {
                LCR_PAR_MOD_W::new(self, 4)
            }
            ///Bit 6 - RW, UART break control enable
            #[inline(always)]
            #[must_use]
            pub fn lcr_break_en(&mut self) -> LCR_BREAK_EN_W<LCR_SPEC> {
                LCR_BREAK_EN_W::new(self, 6)
            }
            ///Bit 7 - RW, UART general purpose bit;RW, UART reserved bit
            #[inline(always)]
            #[must_use]
            pub fn lcr_gp_bit__rb_lcr_dlab(&mut self) -> LCR_GP_BIT__RB_LCR_DLAB_W<LCR_SPEC> {
                LCR_GP_BIT__RB_LCR_DLAB_W::new(self, 7)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW, UART2 line control
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`lcr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`lcr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct LCR_SPEC;
        impl crate::RegisterSpec for LCR_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`lcr::R`](R) reader structure
        impl crate::Readable for LCR_SPEC {}
        ///`write(|w| ..)` method takes [`lcr::W`](W) writer structure
        impl crate::Writable for LCR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets LCR to value 0
        impl crate::Resettable for LCR_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///IIR (r) register accessor: RO, UART2 interrupt identification
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iir::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iir`]
    ///module
    pub type IIR = crate::Reg<iir::IIR_SPEC>;
    ///RO, UART2 interrupt identification
    pub mod iir {
        ///Register `IIR` reader
        pub type R = crate::R<IIR_SPEC>;
        ///Field `IIR_NO_INT` reader - RO, UART no interrupt flag: 0=interrupt action, 1=no interrupt
        pub type IIR_NO_INT_R = crate::BitReader;
        ///Field `IIR_INT_MASK` reader - RO, UART interrupt flag bit mask
        pub type IIR_INT_MASK_R = crate::FieldReader;
        ///Field `IIR_FIFO_ID` reader - RO, UART FIFO enabled flag
        pub type IIR_FIFO_ID_R = crate::BitReader;
        impl R {
            ///Bit 0 - RO, UART no interrupt flag: 0=interrupt action, 1=no interrupt
            #[inline(always)]
            pub fn iir_no_int(&self) -> IIR_NO_INT_R {
                IIR_NO_INT_R::new((self.bits & 1) != 0)
            }
            ///Bits 0:3 - RO, UART interrupt flag bit mask
            #[inline(always)]
            pub fn iir_int_mask(&self) -> IIR_INT_MASK_R {
                IIR_INT_MASK_R::new(self.bits & 0x0f)
            }
            ///Bit 7 - RO, UART FIFO enabled flag
            #[inline(always)]
            pub fn iir_fifo_id(&self) -> IIR_FIFO_ID_R {
                IIR_FIFO_ID_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        ///RO, UART2 interrupt identification
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iir::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IIR_SPEC;
        impl crate::RegisterSpec for IIR_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`iir::R`](R) reader structure
        impl crate::Readable for IIR_SPEC {}
        ///`reset()` method sets IIR to value 0x01
        impl crate::Resettable for IIR_SPEC {
            const RESET_VALUE: u8 = 0x01;
        }
    }
    ///LSR (r) register accessor: RO, UART2 line status
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`lsr::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@lsr`]
    ///module
    pub type LSR = crate::Reg<lsr::LSR_SPEC>;
    ///RO, UART2 line status
    pub mod lsr {
        ///Register `LSR` reader
        pub type R = crate::R<LSR_SPEC>;
        ///Field `LSR_DATA_RDY` reader - RO, UART receiver fifo data ready status
        pub type LSR_DATA_RDY_R = crate::BitReader;
        ///Field `LSR_OVER_ERR` reader - RZ, UART receiver overrun error
        pub type LSR_OVER_ERR_R = crate::BitReader;
        ///Field `LSR_PAR_ERR` reader - RZ, UART receiver parity error
        pub type LSR_PAR_ERR_R = crate::BitReader;
        ///Field `LSR_FRAME_ERR` reader - RZ, UART receiver frame error
        pub type LSR_FRAME_ERR_R = crate::BitReader;
        ///Field `LSR_BREAK_ERR` reader - RZ, UART receiver break error
        pub type LSR_BREAK_ERR_R = crate::BitReader;
        ///Field `LSR_TX_FIFO_EMP` reader - RO, UART transmitter fifo empty status
        pub type LSR_TX_FIFO_EMP_R = crate::BitReader;
        ///Field `LSR_TX_ALL_EMP` reader - RO, UART transmitter all empty status
        pub type LSR_TX_ALL_EMP_R = crate::BitReader;
        ///Field `LSR_ERR_RX_FIFO` reader - RO, indicate error in UART receiver fifo
        pub type LSR_ERR_RX_FIFO_R = crate::BitReader;
        impl R {
            ///Bit 0 - RO, UART receiver fifo data ready status
            #[inline(always)]
            pub fn lsr_data_rdy(&self) -> LSR_DATA_RDY_R {
                LSR_DATA_RDY_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RZ, UART receiver overrun error
            #[inline(always)]
            pub fn lsr_over_err(&self) -> LSR_OVER_ERR_R {
                LSR_OVER_ERR_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RZ, UART receiver parity error
            #[inline(always)]
            pub fn lsr_par_err(&self) -> LSR_PAR_ERR_R {
                LSR_PAR_ERR_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RZ, UART receiver frame error
            #[inline(always)]
            pub fn lsr_frame_err(&self) -> LSR_FRAME_ERR_R {
                LSR_FRAME_ERR_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RZ, UART receiver break error
            #[inline(always)]
            pub fn lsr_break_err(&self) -> LSR_BREAK_ERR_R {
                LSR_BREAK_ERR_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - RO, UART transmitter fifo empty status
            #[inline(always)]
            pub fn lsr_tx_fifo_emp(&self) -> LSR_TX_FIFO_EMP_R {
                LSR_TX_FIFO_EMP_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - RO, UART transmitter all empty status
            #[inline(always)]
            pub fn lsr_tx_all_emp(&self) -> LSR_TX_ALL_EMP_R {
                LSR_TX_ALL_EMP_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - RO, indicate error in UART receiver fifo
            #[inline(always)]
            pub fn lsr_err_rx_fifo(&self) -> LSR_ERR_RX_FIFO_R {
                LSR_ERR_RX_FIFO_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        ///RO, UART2 line status
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`lsr::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct LSR_SPEC;
        impl crate::RegisterSpec for LSR_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`lsr::R`](R) reader structure
        impl crate::Readable for LSR_SPEC {}
        ///`reset()` method sets LSR to value 0x60
        impl crate::Resettable for LSR_SPEC {
            const RESET_VALUE: u8 = 0x60;
        }
    }
    ///RBR (r) register accessor: RO, UART2 receiver buffer, receiving byte
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`rbr::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@rbr`]
    ///module
    pub type RBR = crate::Reg<rbr::RBR_SPEC>;
    ///RO, UART2 receiver buffer, receiving byte
    pub mod rbr {
        ///Register `RBR` reader
        pub type R = crate::R<RBR_SPEC>;
        ///Field `RBR` reader - RO, UART2 receiver buffer, receiving byte
        pub type RBR_R = crate::FieldReader;
        impl R {
            ///Bits 0:7 - RO, UART2 receiver buffer, receiving byte
            #[inline(always)]
            pub fn rbr(&self) -> RBR_R {
                RBR_R::new(self.bits)
            }
        }
        ///RO, UART2 receiver buffer, receiving byte
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`rbr::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct RBR_SPEC;
        impl crate::RegisterSpec for RBR_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`rbr::R`](R) reader structure
        impl crate::Readable for RBR_SPEC {}
        ///`reset()` method sets RBR to value 0
        impl crate::Resettable for RBR_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///THR (w) register accessor: WO, UART2 transmitter holding, transmittal byte
    ///
    ///You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`thr::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@thr`]
    ///module
    pub type THR = crate::Reg<thr::THR_SPEC>;
    ///WO, UART2 transmitter holding, transmittal byte
    pub mod thr {
        ///Register `THR` writer
        pub type W = crate::W<THR_SPEC>;
        ///Field `THR` writer - WO, UART2 transmitter holding, transmittal byte
        pub type THR_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl W {
            ///Bits 0:7 - WO, UART2 transmitter holding, transmittal byte
            #[inline(always)]
            #[must_use]
            pub fn thr(&mut self) -> THR_W<THR_SPEC> {
                THR_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///WO, UART2 transmitter holding, transmittal byte
        ///
        ///You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`thr::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct THR_SPEC;
        impl crate::RegisterSpec for THR_SPEC {
            type Ux = u8;
        }
        ///`write(|w| ..)` method takes [`thr::W`](W) writer structure
        impl crate::Writable for THR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets THR to value 0
        impl crate::Resettable for THR_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///RFC (r) register accessor: RO, UART2 receiver FIFO count
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`rfc::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@rfc`]
    ///module
    pub type RFC = crate::Reg<rfc::RFC_SPEC>;
    ///RO, UART2 receiver FIFO count
    pub mod rfc {
        ///Register `RFC` reader
        pub type R = crate::R<RFC_SPEC>;
        ///Field `RFC` reader - RO, UART2 receiver FIFO count
        pub type RFC_R = crate::FieldReader;
        impl R {
            ///Bits 0:7 - RO, UART2 receiver FIFO count
            #[inline(always)]
            pub fn rfc(&self) -> RFC_R {
                RFC_R::new(self.bits)
            }
        }
        ///RO, UART2 receiver FIFO count
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`rfc::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct RFC_SPEC;
        impl crate::RegisterSpec for RFC_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`rfc::R`](R) reader structure
        impl crate::Readable for RFC_SPEC {}
        ///`reset()` method sets RFC to value 0
        impl crate::Resettable for RFC_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///TFC (r) register accessor: RO, UART2 transmitter FIFO count
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`tfc::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@tfc`]
    ///module
    pub type TFC = crate::Reg<tfc::TFC_SPEC>;
    ///RO, UART2 transmitter FIFO count
    pub mod tfc {
        ///Register `TFC` reader
        pub type R = crate::R<TFC_SPEC>;
        ///Field `TFC` reader - RO, UART2 transmitter FIFO count
        pub type TFC_R = crate::FieldReader;
        impl R {
            ///Bits 0:7 - RO, UART2 transmitter FIFO count
            #[inline(always)]
            pub fn tfc(&self) -> TFC_R {
                TFC_R::new(self.bits)
            }
        }
        ///RO, UART2 transmitter FIFO count
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`tfc::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct TFC_SPEC;
        impl crate::RegisterSpec for TFC_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`tfc::R`](R) reader structure
        impl crate::Readable for TFC_SPEC {}
        ///`reset()` method sets TFC to value 0
        impl crate::Resettable for TFC_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///DL (rw) register accessor: RW, UART2 divisor latch
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`dl::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dl::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@dl`]
    ///module
    pub type DL = crate::Reg<dl::DL_SPEC>;
    ///RW, UART2 divisor latch
    pub mod dl {
        ///Register `DL` reader
        pub type R = crate::R<DL_SPEC>;
        ///Register `DL` writer
        pub type W = crate::W<DL_SPEC>;
        ///Field `DL` reader - RW, UART2 divisor latch
        pub type DL_R = crate::FieldReader<u16>;
        ///Field `DL` writer - RW, UART2 divisor latch
        pub type DL_W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            ///Bits 0:15 - RW, UART2 divisor latch
            #[inline(always)]
            pub fn dl(&self) -> DL_R {
                DL_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - RW, UART2 divisor latch
            #[inline(always)]
            #[must_use]
            pub fn dl(&mut self) -> DL_W<DL_SPEC> {
                DL_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW, UART2 divisor latch
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`dl::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dl::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct DL_SPEC;
        impl crate::RegisterSpec for DL_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`dl::R`](R) reader structure
        impl crate::Readable for DL_SPEC {}
        ///`write(|w| ..)` method takes [`dl::W`](W) writer structure
        impl crate::Writable for DL_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets DL to value 0
        impl crate::Resettable for DL_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///DIV (rw) register accessor: RW, UART2 pre-divisor latch byte, only low 7 bit, from 1 to 128
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`div::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`div::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@div`]
    ///module
    pub type DIV = crate::Reg<div::DIV_SPEC>;
    ///RW, UART2 pre-divisor latch byte, only low 7 bit, from 1 to 128
    pub mod div {
        ///Register `DIV` reader
        pub type R = crate::R<DIV_SPEC>;
        ///Register `DIV` writer
        pub type W = crate::W<DIV_SPEC>;
        ///Field `DIV` reader - RW, UART2 pre-divisor latch byte, only low 7 bit, from 1 to 128
        pub type DIV_R = crate::FieldReader;
        ///Field `DIV` writer - RW, UART2 pre-divisor latch byte, only low 7 bit, from 1 to 128
        pub type DIV_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            ///Bits 0:7 - RW, UART2 pre-divisor latch byte, only low 7 bit, from 1 to 128
            #[inline(always)]
            pub fn div(&self) -> DIV_R {
                DIV_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:7 - RW, UART2 pre-divisor latch byte, only low 7 bit, from 1 to 128
            #[inline(always)]
            #[must_use]
            pub fn div(&mut self) -> DIV_W<DIV_SPEC> {
                DIV_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW, UART2 pre-divisor latch byte, only low 7 bit, from 1 to 128
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`div::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`div::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct DIV_SPEC;
        impl crate::RegisterSpec for DIV_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`div::R`](R) reader structure
        impl crate::Readable for DIV_SPEC {}
        ///`write(|w| ..)` method takes [`div::W`](W) writer structure
        impl crate::Writable for DIV_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets DIV to value 0
        impl crate::Resettable for DIV_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
}
///UART3 register
pub struct UART3 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for UART3 {}
impl UART3 {
    ///Pointer to the register block
    pub const PTR: *const uart3::RegisterBlock = 0x4000_3c00 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const uart3::RegisterBlock {
        Self::PTR
    }
    /// Steal an instance of this peripheral
    ///
    /// # Safety
    ///
    /// Ensure that the new instance of the peripheral cannot be used in a way
    /// that may race with any existing instances, for example by only
    /// accessing read-only or write-only registers, or by consuming the
    /// original peripheral and using critical sections to coordinate
    /// access between multiple new instances.
    ///
    /// Additionally, other software such as HALs may rely on only one
    /// peripheral instance existing to ensure memory safety; ensure
    /// no stolen instances are passed to such software.
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for UART3 {
    type Target = uart3::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for UART3 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("UART3").finish()
    }
}
///UART3 register
pub mod uart3 {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        mcr: MCR,
        ier: IER,
        fcr: FCR,
        lcr: LCR,
        iir: IIR,
        lsr: LSR,
        _reserved6: [u8; 0x02],
        _reserved_6_rbr: [u8; 0x01],
        _reserved7: [u8; 0x01],
        rfc: RFC,
        tfc: TFC,
        dl: DL,
        div: DIV,
    }
    impl RegisterBlock {
        ///0x00 - RW, UART3 modem control
        #[inline(always)]
        pub const fn mcr(&self) -> &MCR {
            &self.mcr
        }
        ///0x01 - RW, UART3 interrupt enable
        #[inline(always)]
        pub const fn ier(&self) -> &IER {
            &self.ier
        }
        ///0x02 - RW, UART3 FIFO control
        #[inline(always)]
        pub const fn fcr(&self) -> &FCR {
            &self.fcr
        }
        ///0x03 - RW, UART3 line control
        #[inline(always)]
        pub const fn lcr(&self) -> &LCR {
            &self.lcr
        }
        ///0x04 - RO, UART3 interrupt identification
        #[inline(always)]
        pub const fn iir(&self) -> &IIR {
            &self.iir
        }
        ///0x05 - RO, UART3 line status
        #[inline(always)]
        pub const fn lsr(&self) -> &LSR {
            &self.lsr
        }
        ///0x08 - WO, UART3 transmitter holding, transmittal byte
        #[inline(always)]
        pub const fn thr(&self) -> &THR {
            unsafe { &*(self as *const Self).cast::<u8>().add(8).cast() }
        }
        ///0x08 - RO, UART3 receiver buffer, receiving byte
        #[inline(always)]
        pub const fn rbr(&self) -> &RBR {
            unsafe { &*(self as *const Self).cast::<u8>().add(8).cast() }
        }
        ///0x0a - RO, UART3 receiver FIFO count
        #[inline(always)]
        pub const fn rfc(&self) -> &RFC {
            &self.rfc
        }
        ///0x0b - RO, UART3 transmitter FIFO count
        #[inline(always)]
        pub const fn tfc(&self) -> &TFC {
            &self.tfc
        }
        ///0x0c - RW, UART3 divisor latch
        #[inline(always)]
        pub const fn dl(&self) -> &DL {
            &self.dl
        }
        ///0x0e - RW, UART3 pre-divisor latch byte, only low 7 bit, from 1 to 128
        #[inline(always)]
        pub const fn div(&self) -> &DIV {
            &self.div
        }
    }
    ///MCR (rw) register accessor: RW, UART3 modem control
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`mcr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`mcr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@mcr`]
    ///module
    pub type MCR = crate::Reg<mcr::MCR_SPEC>;
    ///RW, UART3 modem control
    pub mod mcr {
        ///Register `MCR` reader
        pub type R = crate::R<MCR_SPEC>;
        ///Register `MCR` writer
        pub type W = crate::W<MCR_SPEC>;
        ///Field `MCR_OUT2__RB_MCR_INT_OE` reader - RW, UART control OUT2;UART interrupt output enable
        pub type MCR_OUT2__RB_MCR_INT_OE_R = crate::BitReader;
        ///Field `MCR_OUT2__RB_MCR_INT_OE` writer - RW, UART control OUT2;UART interrupt output enable
        pub type MCR_OUT2__RB_MCR_INT_OE_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 3 - RW, UART control OUT2;UART interrupt output enable
            #[inline(always)]
            pub fn mcr_out2__rb_mcr_int_oe(&self) -> MCR_OUT2__RB_MCR_INT_OE_R {
                MCR_OUT2__RB_MCR_INT_OE_R::new(((self.bits >> 3) & 1) != 0)
            }
        }
        impl W {
            ///Bit 3 - RW, UART control OUT2;UART interrupt output enable
            #[inline(always)]
            #[must_use]
            pub fn mcr_out2__rb_mcr_int_oe(&mut self) -> MCR_OUT2__RB_MCR_INT_OE_W<MCR_SPEC> {
                MCR_OUT2__RB_MCR_INT_OE_W::new(self, 3)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW, UART3 modem control
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`mcr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`mcr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct MCR_SPEC;
        impl crate::RegisterSpec for MCR_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`mcr::R`](R) reader structure
        impl crate::Readable for MCR_SPEC {}
        ///`write(|w| ..)` method takes [`mcr::W`](W) writer structure
        impl crate::Writable for MCR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets MCR to value 0
        impl crate::Resettable for MCR_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///IER (rw) register accessor: RW, UART3 interrupt enable
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`ier::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ier::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@ier`]
    ///module
    pub type IER = crate::Reg<ier::IER_SPEC>;
    ///RW, UART3 interrupt enable
    pub mod ier {
        ///Register `IER` reader
        pub type R = crate::R<IER_SPEC>;
        ///Register `IER` writer
        pub type W = crate::W<IER_SPEC>;
        ///Field `IER_RECV_RDY` reader - RW, UART interrupt enable for receiver data ready
        pub type IER_RECV_RDY_R = crate::BitReader;
        ///Field `IER_RECV_RDY` writer - RW, UART interrupt enable for receiver data ready
        pub type IER_RECV_RDY_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `IER_THR_EMPTY` reader - RW, UART interrupt enable for THR empty
        pub type IER_THR_EMPTY_R = crate::BitReader;
        ///Field `IER_THR_EMPTY` writer - RW, UART interrupt enable for THR empty
        pub type IER_THR_EMPTY_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `IER_LINE_STAT` reader - RW, UART interrupt enable for receiver line status
        pub type IER_LINE_STAT_R = crate::BitReader;
        ///Field `IER_LINE_STAT` writer - RW, UART interrupt enable for receiver line status
        pub type IER_LINE_STAT_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `IER_TXD_EN` reader - RW, UART TXD pin enable
        pub type IER_TXD_EN_R = crate::BitReader;
        ///Field `IER_TXD_EN` writer - RW, UART TXD pin enable
        pub type IER_TXD_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `IER_RESET` reader - WZ, UART software reset control, high action, auto clear
        pub type IER_RESET_R = crate::BitReader;
        ///Field `IER_RESET` writer - WZ, UART software reset control, high action, auto clear
        pub type IER_RESET_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - RW, UART interrupt enable for receiver data ready
            #[inline(always)]
            pub fn ier_recv_rdy(&self) -> IER_RECV_RDY_R {
                IER_RECV_RDY_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RW, UART interrupt enable for THR empty
            #[inline(always)]
            pub fn ier_thr_empty(&self) -> IER_THR_EMPTY_R {
                IER_THR_EMPTY_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RW, UART interrupt enable for receiver line status
            #[inline(always)]
            pub fn ier_line_stat(&self) -> IER_LINE_STAT_R {
                IER_LINE_STAT_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 6 - RW, UART TXD pin enable
            #[inline(always)]
            pub fn ier_txd_en(&self) -> IER_TXD_EN_R {
                IER_TXD_EN_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - WZ, UART software reset control, high action, auto clear
            #[inline(always)]
            pub fn ier_reset(&self) -> IER_RESET_R {
                IER_RESET_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RW, UART interrupt enable for receiver data ready
            #[inline(always)]
            #[must_use]
            pub fn ier_recv_rdy(&mut self) -> IER_RECV_RDY_W<IER_SPEC> {
                IER_RECV_RDY_W::new(self, 0)
            }
            ///Bit 1 - RW, UART interrupt enable for THR empty
            #[inline(always)]
            #[must_use]
            pub fn ier_thr_empty(&mut self) -> IER_THR_EMPTY_W<IER_SPEC> {
                IER_THR_EMPTY_W::new(self, 1)
            }
            ///Bit 2 - RW, UART interrupt enable for receiver line status
            #[inline(always)]
            #[must_use]
            pub fn ier_line_stat(&mut self) -> IER_LINE_STAT_W<IER_SPEC> {
                IER_LINE_STAT_W::new(self, 2)
            }
            ///Bit 6 - RW, UART TXD pin enable
            #[inline(always)]
            #[must_use]
            pub fn ier_txd_en(&mut self) -> IER_TXD_EN_W<IER_SPEC> {
                IER_TXD_EN_W::new(self, 6)
            }
            ///Bit 7 - WZ, UART software reset control, high action, auto clear
            #[inline(always)]
            #[must_use]
            pub fn ier_reset(&mut self) -> IER_RESET_W<IER_SPEC> {
                IER_RESET_W::new(self, 7)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW, UART3 interrupt enable
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`ier::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ier::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IER_SPEC;
        impl crate::RegisterSpec for IER_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`ier::R`](R) reader structure
        impl crate::Readable for IER_SPEC {}
        ///`write(|w| ..)` method takes [`ier::W`](W) writer structure
        impl crate::Writable for IER_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets IER to value 0
        impl crate::Resettable for IER_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///FCR (rw) register accessor: RW, UART3 FIFO control
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`fcr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`fcr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@fcr`]
    ///module
    pub type FCR = crate::Reg<fcr::FCR_SPEC>;
    ///RW, UART3 FIFO control
    pub mod fcr {
        ///Register `FCR` reader
        pub type R = crate::R<FCR_SPEC>;
        ///Register `FCR` writer
        pub type W = crate::W<FCR_SPEC>;
        ///Field `FCR_FIFO_EN` reader - RW, UART FIFO enable
        pub type FCR_FIFO_EN_R = crate::BitReader;
        ///Field `FCR_FIFO_EN` writer - RW, UART FIFO enable
        pub type FCR_FIFO_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FCR_RX_FIFO_CLR` reader - WZ, clear UART receiver FIFO, high action, auto clear
        pub type FCR_RX_FIFO_CLR_R = crate::BitReader;
        ///Field `FCR_RX_FIFO_CLR` writer - WZ, clear UART receiver FIFO, high action, auto clear
        pub type FCR_RX_FIFO_CLR_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FCR_TX_FIFO_CLR` reader - WZ, clear UART transmitter FIFO, high action, auto clear
        pub type FCR_TX_FIFO_CLR_R = crate::BitReader;
        ///Field `FCR_TX_FIFO_CLR` writer - WZ, clear UART transmitter FIFO, high action, auto clear
        pub type FCR_TX_FIFO_CLR_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FCR_FIFO_TRIG` reader - RW, UART receiver FIFO trigger level: 00-1byte, 01-2bytes, 10-4bytes, 11-7bytes
        pub type FCR_FIFO_TRIG_R = crate::FieldReader;
        ///Field `FCR_FIFO_TRIG` writer - RW, UART receiver FIFO trigger level: 00-1byte, 01-2bytes, 10-4bytes, 11-7bytes
        pub type FCR_FIFO_TRIG_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        impl R {
            ///Bit 0 - RW, UART FIFO enable
            #[inline(always)]
            pub fn fcr_fifo_en(&self) -> FCR_FIFO_EN_R {
                FCR_FIFO_EN_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - WZ, clear UART receiver FIFO, high action, auto clear
            #[inline(always)]
            pub fn fcr_rx_fifo_clr(&self) -> FCR_RX_FIFO_CLR_R {
                FCR_RX_FIFO_CLR_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - WZ, clear UART transmitter FIFO, high action, auto clear
            #[inline(always)]
            pub fn fcr_tx_fifo_clr(&self) -> FCR_TX_FIFO_CLR_R {
                FCR_TX_FIFO_CLR_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bits 6:7 - RW, UART receiver FIFO trigger level: 00-1byte, 01-2bytes, 10-4bytes, 11-7bytes
            #[inline(always)]
            pub fn fcr_fifo_trig(&self) -> FCR_FIFO_TRIG_R {
                FCR_FIFO_TRIG_R::new((self.bits >> 6) & 3)
            }
        }
        impl W {
            ///Bit 0 - RW, UART FIFO enable
            #[inline(always)]
            #[must_use]
            pub fn fcr_fifo_en(&mut self) -> FCR_FIFO_EN_W<FCR_SPEC> {
                FCR_FIFO_EN_W::new(self, 0)
            }
            ///Bit 1 - WZ, clear UART receiver FIFO, high action, auto clear
            #[inline(always)]
            #[must_use]
            pub fn fcr_rx_fifo_clr(&mut self) -> FCR_RX_FIFO_CLR_W<FCR_SPEC> {
                FCR_RX_FIFO_CLR_W::new(self, 1)
            }
            ///Bit 2 - WZ, clear UART transmitter FIFO, high action, auto clear
            #[inline(always)]
            #[must_use]
            pub fn fcr_tx_fifo_clr(&mut self) -> FCR_TX_FIFO_CLR_W<FCR_SPEC> {
                FCR_TX_FIFO_CLR_W::new(self, 2)
            }
            ///Bits 6:7 - RW, UART receiver FIFO trigger level: 00-1byte, 01-2bytes, 10-4bytes, 11-7bytes
            #[inline(always)]
            #[must_use]
            pub fn fcr_fifo_trig(&mut self) -> FCR_FIFO_TRIG_W<FCR_SPEC> {
                FCR_FIFO_TRIG_W::new(self, 6)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW, UART3 FIFO control
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`fcr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`fcr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct FCR_SPEC;
        impl crate::RegisterSpec for FCR_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`fcr::R`](R) reader structure
        impl crate::Readable for FCR_SPEC {}
        ///`write(|w| ..)` method takes [`fcr::W`](W) writer structure
        impl crate::Writable for FCR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets FCR to value 0
        impl crate::Resettable for FCR_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///LCR (rw) register accessor: RW, UART3 line control
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`lcr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`lcr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@lcr`]
    ///module
    pub type LCR = crate::Reg<lcr::LCR_SPEC>;
    ///RW, UART3 line control
    pub mod lcr {
        ///Register `LCR` reader
        pub type R = crate::R<LCR_SPEC>;
        ///Register `LCR` writer
        pub type W = crate::W<LCR_SPEC>;
        ///Field `LCR_WORD_SZ` reader - RW, UART word bit length: 00-5bit, 01-6bit, 10-7bit, 11-8bit
        pub type LCR_WORD_SZ_R = crate::FieldReader;
        ///Field `LCR_WORD_SZ` writer - RW, UART word bit length: 00-5bit, 01-6bit, 10-7bit, 11-8bit
        pub type LCR_WORD_SZ_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `LCR_STOP_BIT` reader - RW, UART stop bit length: 0-1bit, 1-2bit
        pub type LCR_STOP_BIT_R = crate::BitReader;
        ///Field `LCR_STOP_BIT` writer - RW, UART stop bit length: 0-1bit, 1-2bit
        pub type LCR_STOP_BIT_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `LCR_PAR_EN` reader - RW, UART parity enable
        pub type LCR_PAR_EN_R = crate::BitReader;
        ///Field `LCR_PAR_EN` writer - RW, UART parity enable
        pub type LCR_PAR_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `LCR_PAR_MOD` reader - RW, UART parity mode: 00-odd, 01-even, 10-mark, 11-space
        pub type LCR_PAR_MOD_R = crate::FieldReader;
        ///Field `LCR_PAR_MOD` writer - RW, UART parity mode: 00-odd, 01-even, 10-mark, 11-space
        pub type LCR_PAR_MOD_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `LCR_BREAK_EN` reader - RW, UART break control enable
        pub type LCR_BREAK_EN_R = crate::BitReader;
        ///Field `LCR_BREAK_EN` writer - RW, UART break control enable
        pub type LCR_BREAK_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `LCR_GP_BIT__RB_LCR_DLAB` reader - RW, UART general purpose bit;RW, UART reserved bit
        pub type LCR_GP_BIT__RB_LCR_DLAB_R = crate::BitReader;
        ///Field `LCR_GP_BIT__RB_LCR_DLAB` writer - RW, UART general purpose bit;RW, UART reserved bit
        pub type LCR_GP_BIT__RB_LCR_DLAB_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bits 0:1 - RW, UART word bit length: 00-5bit, 01-6bit, 10-7bit, 11-8bit
            #[inline(always)]
            pub fn lcr_word_sz(&self) -> LCR_WORD_SZ_R {
                LCR_WORD_SZ_R::new(self.bits & 3)
            }
            ///Bit 2 - RW, UART stop bit length: 0-1bit, 1-2bit
            #[inline(always)]
            pub fn lcr_stop_bit(&self) -> LCR_STOP_BIT_R {
                LCR_STOP_BIT_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RW, UART parity enable
            #[inline(always)]
            pub fn lcr_par_en(&self) -> LCR_PAR_EN_R {
                LCR_PAR_EN_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bits 4:5 - RW, UART parity mode: 00-odd, 01-even, 10-mark, 11-space
            #[inline(always)]
            pub fn lcr_par_mod(&self) -> LCR_PAR_MOD_R {
                LCR_PAR_MOD_R::new((self.bits >> 4) & 3)
            }
            ///Bit 6 - RW, UART break control enable
            #[inline(always)]
            pub fn lcr_break_en(&self) -> LCR_BREAK_EN_R {
                LCR_BREAK_EN_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - RW, UART general purpose bit;RW, UART reserved bit
            #[inline(always)]
            pub fn lcr_gp_bit__rb_lcr_dlab(&self) -> LCR_GP_BIT__RB_LCR_DLAB_R {
                LCR_GP_BIT__RB_LCR_DLAB_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:1 - RW, UART word bit length: 00-5bit, 01-6bit, 10-7bit, 11-8bit
            #[inline(always)]
            #[must_use]
            pub fn lcr_word_sz(&mut self) -> LCR_WORD_SZ_W<LCR_SPEC> {
                LCR_WORD_SZ_W::new(self, 0)
            }
            ///Bit 2 - RW, UART stop bit length: 0-1bit, 1-2bit
            #[inline(always)]
            #[must_use]
            pub fn lcr_stop_bit(&mut self) -> LCR_STOP_BIT_W<LCR_SPEC> {
                LCR_STOP_BIT_W::new(self, 2)
            }
            ///Bit 3 - RW, UART parity enable
            #[inline(always)]
            #[must_use]
            pub fn lcr_par_en(&mut self) -> LCR_PAR_EN_W<LCR_SPEC> {
                LCR_PAR_EN_W::new(self, 3)
            }
            ///Bits 4:5 - RW, UART parity mode: 00-odd, 01-even, 10-mark, 11-space
            #[inline(always)]
            #[must_use]
            pub fn lcr_par_mod(&mut self) -> LCR_PAR_MOD_W<LCR_SPEC> {
                LCR_PAR_MOD_W::new(self, 4)
            }
            ///Bit 6 - RW, UART break control enable
            #[inline(always)]
            #[must_use]
            pub fn lcr_break_en(&mut self) -> LCR_BREAK_EN_W<LCR_SPEC> {
                LCR_BREAK_EN_W::new(self, 6)
            }
            ///Bit 7 - RW, UART general purpose bit;RW, UART reserved bit
            #[inline(always)]
            #[must_use]
            pub fn lcr_gp_bit__rb_lcr_dlab(&mut self) -> LCR_GP_BIT__RB_LCR_DLAB_W<LCR_SPEC> {
                LCR_GP_BIT__RB_LCR_DLAB_W::new(self, 7)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW, UART3 line control
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`lcr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`lcr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct LCR_SPEC;
        impl crate::RegisterSpec for LCR_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`lcr::R`](R) reader structure
        impl crate::Readable for LCR_SPEC {}
        ///`write(|w| ..)` method takes [`lcr::W`](W) writer structure
        impl crate::Writable for LCR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets LCR to value 0
        impl crate::Resettable for LCR_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///IIR (r) register accessor: RO, UART3 interrupt identification
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iir::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iir`]
    ///module
    pub type IIR = crate::Reg<iir::IIR_SPEC>;
    ///RO, UART3 interrupt identification
    pub mod iir {
        ///Register `IIR` reader
        pub type R = crate::R<IIR_SPEC>;
        ///Field `IIR_NO_INT` reader - RO, UART no interrupt flag: 0=interrupt action, 1=no interrupt
        pub type IIR_NO_INT_R = crate::BitReader;
        ///Field `IIR_INT_MASK` reader - RO, UART interrupt flag bit mask
        pub type IIR_INT_MASK_R = crate::FieldReader;
        ///Field `IIR_FIFO_ID` reader - RO, UART FIFO enabled flag
        pub type IIR_FIFO_ID_R = crate::BitReader;
        impl R {
            ///Bit 0 - RO, UART no interrupt flag: 0=interrupt action, 1=no interrupt
            #[inline(always)]
            pub fn iir_no_int(&self) -> IIR_NO_INT_R {
                IIR_NO_INT_R::new((self.bits & 1) != 0)
            }
            ///Bits 1:3 - RO, UART interrupt flag bit mask
            #[inline(always)]
            pub fn iir_int_mask(&self) -> IIR_INT_MASK_R {
                IIR_INT_MASK_R::new((self.bits >> 1) & 7)
            }
            ///Bit 7 - RO, UART FIFO enabled flag
            #[inline(always)]
            pub fn iir_fifo_id(&self) -> IIR_FIFO_ID_R {
                IIR_FIFO_ID_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        ///RO, UART3 interrupt identification
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iir::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IIR_SPEC;
        impl crate::RegisterSpec for IIR_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`iir::R`](R) reader structure
        impl crate::Readable for IIR_SPEC {}
        ///`reset()` method sets IIR to value 0x01
        impl crate::Resettable for IIR_SPEC {
            const RESET_VALUE: u8 = 0x01;
        }
    }
    ///LSR (r) register accessor: RO, UART3 line status
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`lsr::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@lsr`]
    ///module
    pub type LSR = crate::Reg<lsr::LSR_SPEC>;
    ///RO, UART3 line status
    pub mod lsr {
        ///Register `LSR` reader
        pub type R = crate::R<LSR_SPEC>;
        ///Field `LSR_DATA_RDY` reader - RO, UART receiver fifo data ready status
        pub type LSR_DATA_RDY_R = crate::BitReader;
        ///Field `LSR_OVER_ERR` reader - RZ, UART receiver overrun error
        pub type LSR_OVER_ERR_R = crate::BitReader;
        ///Field `LSR_PAR_ERR` reader - RZ, UART receiver parity error
        pub type LSR_PAR_ERR_R = crate::BitReader;
        ///Field `LSR_FRAME_ERR` reader - RZ, UART receiver frame error
        pub type LSR_FRAME_ERR_R = crate::BitReader;
        ///Field `LSR_BREAK_ERR` reader - RZ, UART receiver break error
        pub type LSR_BREAK_ERR_R = crate::BitReader;
        ///Field `LSR_TX_FIFO_EMP` reader - RO, UART transmitter fifo empty status
        pub type LSR_TX_FIFO_EMP_R = crate::BitReader;
        ///Field `LSR_TX_ALL_EMP` reader - RO, UART transmitter all empty status
        pub type LSR_TX_ALL_EMP_R = crate::BitReader;
        ///Field `LSR_ERR_RX_FIFO` reader - RO, indicate error in UART receiver fifo
        pub type LSR_ERR_RX_FIFO_R = crate::BitReader;
        impl R {
            ///Bit 0 - RO, UART receiver fifo data ready status
            #[inline(always)]
            pub fn lsr_data_rdy(&self) -> LSR_DATA_RDY_R {
                LSR_DATA_RDY_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RZ, UART receiver overrun error
            #[inline(always)]
            pub fn lsr_over_err(&self) -> LSR_OVER_ERR_R {
                LSR_OVER_ERR_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RZ, UART receiver parity error
            #[inline(always)]
            pub fn lsr_par_err(&self) -> LSR_PAR_ERR_R {
                LSR_PAR_ERR_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RZ, UART receiver frame error
            #[inline(always)]
            pub fn lsr_frame_err(&self) -> LSR_FRAME_ERR_R {
                LSR_FRAME_ERR_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RZ, UART receiver break error
            #[inline(always)]
            pub fn lsr_break_err(&self) -> LSR_BREAK_ERR_R {
                LSR_BREAK_ERR_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - RO, UART transmitter fifo empty status
            #[inline(always)]
            pub fn lsr_tx_fifo_emp(&self) -> LSR_TX_FIFO_EMP_R {
                LSR_TX_FIFO_EMP_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - RO, UART transmitter all empty status
            #[inline(always)]
            pub fn lsr_tx_all_emp(&self) -> LSR_TX_ALL_EMP_R {
                LSR_TX_ALL_EMP_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - RO, indicate error in UART receiver fifo
            #[inline(always)]
            pub fn lsr_err_rx_fifo(&self) -> LSR_ERR_RX_FIFO_R {
                LSR_ERR_RX_FIFO_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        ///RO, UART3 line status
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`lsr::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct LSR_SPEC;
        impl crate::RegisterSpec for LSR_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`lsr::R`](R) reader structure
        impl crate::Readable for LSR_SPEC {}
        ///`reset()` method sets LSR to value 0x60
        impl crate::Resettable for LSR_SPEC {
            const RESET_VALUE: u8 = 0x60;
        }
    }
    ///RBR (r) register accessor: RO, UART3 receiver buffer, receiving byte
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`rbr::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@rbr`]
    ///module
    pub type RBR = crate::Reg<rbr::RBR_SPEC>;
    ///RO, UART3 receiver buffer, receiving byte
    pub mod rbr {
        ///Register `RBR` reader
        pub type R = crate::R<RBR_SPEC>;
        ///Field `RBR` reader - RO, UART3 receiver buffer, receiving byte
        pub type RBR_R = crate::FieldReader;
        impl R {
            ///Bits 0:7 - RO, UART3 receiver buffer, receiving byte
            #[inline(always)]
            pub fn rbr(&self) -> RBR_R {
                RBR_R::new(self.bits)
            }
        }
        ///RO, UART3 receiver buffer, receiving byte
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`rbr::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct RBR_SPEC;
        impl crate::RegisterSpec for RBR_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`rbr::R`](R) reader structure
        impl crate::Readable for RBR_SPEC {}
        ///`reset()` method sets RBR to value 0
        impl crate::Resettable for RBR_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///THR (w) register accessor: WO, UART3 transmitter holding, transmittal byte
    ///
    ///You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`thr::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@thr`]
    ///module
    pub type THR = crate::Reg<thr::THR_SPEC>;
    ///WO, UART3 transmitter holding, transmittal byte
    pub mod thr {
        ///Register `THR` writer
        pub type W = crate::W<THR_SPEC>;
        ///Field `THR` writer - WO, UART3 transmitter holding, transmittal byte
        pub type THR_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl W {
            ///Bits 0:7 - WO, UART3 transmitter holding, transmittal byte
            #[inline(always)]
            #[must_use]
            pub fn thr(&mut self) -> THR_W<THR_SPEC> {
                THR_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///WO, UART3 transmitter holding, transmittal byte
        ///
        ///You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`thr::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct THR_SPEC;
        impl crate::RegisterSpec for THR_SPEC {
            type Ux = u8;
        }
        ///`write(|w| ..)` method takes [`thr::W`](W) writer structure
        impl crate::Writable for THR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets THR to value 0
        impl crate::Resettable for THR_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///RFC (r) register accessor: RO, UART3 receiver FIFO count
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`rfc::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@rfc`]
    ///module
    pub type RFC = crate::Reg<rfc::RFC_SPEC>;
    ///RO, UART3 receiver FIFO count
    pub mod rfc {
        ///Register `RFC` reader
        pub type R = crate::R<RFC_SPEC>;
        ///Field `RFC` reader - RO, UART3 receiver FIFO count
        pub type RFC_R = crate::FieldReader;
        impl R {
            ///Bits 0:7 - RO, UART3 receiver FIFO count
            #[inline(always)]
            pub fn rfc(&self) -> RFC_R {
                RFC_R::new(self.bits)
            }
        }
        ///RO, UART3 receiver FIFO count
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`rfc::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct RFC_SPEC;
        impl crate::RegisterSpec for RFC_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`rfc::R`](R) reader structure
        impl crate::Readable for RFC_SPEC {}
        ///`reset()` method sets RFC to value 0
        impl crate::Resettable for RFC_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///TFC (r) register accessor: RO, UART3 transmitter FIFO count
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`tfc::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@tfc`]
    ///module
    pub type TFC = crate::Reg<tfc::TFC_SPEC>;
    ///RO, UART3 transmitter FIFO count
    pub mod tfc {
        ///Register `TFC` reader
        pub type R = crate::R<TFC_SPEC>;
        ///Field `TFC` reader - RO, UART3 transmitter FIFO count
        pub type TFC_R = crate::FieldReader;
        impl R {
            ///Bits 0:7 - RO, UART3 transmitter FIFO count
            #[inline(always)]
            pub fn tfc(&self) -> TFC_R {
                TFC_R::new(self.bits)
            }
        }
        ///RO, UART3 transmitter FIFO count
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`tfc::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct TFC_SPEC;
        impl crate::RegisterSpec for TFC_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`tfc::R`](R) reader structure
        impl crate::Readable for TFC_SPEC {}
        ///`reset()` method sets TFC to value 0
        impl crate::Resettable for TFC_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///DL (rw) register accessor: RW, UART3 divisor latch
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`dl::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dl::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@dl`]
    ///module
    pub type DL = crate::Reg<dl::DL_SPEC>;
    ///RW, UART3 divisor latch
    pub mod dl {
        ///Register `DL` reader
        pub type R = crate::R<DL_SPEC>;
        ///Register `DL` writer
        pub type W = crate::W<DL_SPEC>;
        ///Field `DL` reader - RW, UART3 divisor latch
        pub type DL_R = crate::FieldReader<u16>;
        ///Field `DL` writer - RW, UART3 divisor latch
        pub type DL_W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            ///Bits 0:15 - RW, UART3 divisor latch
            #[inline(always)]
            pub fn dl(&self) -> DL_R {
                DL_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - RW, UART3 divisor latch
            #[inline(always)]
            #[must_use]
            pub fn dl(&mut self) -> DL_W<DL_SPEC> {
                DL_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW, UART3 divisor latch
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`dl::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dl::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct DL_SPEC;
        impl crate::RegisterSpec for DL_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`dl::R`](R) reader structure
        impl crate::Readable for DL_SPEC {}
        ///`write(|w| ..)` method takes [`dl::W`](W) writer structure
        impl crate::Writable for DL_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets DL to value 0
        impl crate::Resettable for DL_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///DIV (rw) register accessor: RW, UART3 pre-divisor latch byte, only low 7 bit, from 1 to 128
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`div::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`div::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@div`]
    ///module
    pub type DIV = crate::Reg<div::DIV_SPEC>;
    ///RW, UART3 pre-divisor latch byte, only low 7 bit, from 1 to 128
    pub mod div {
        ///Register `DIV` reader
        pub type R = crate::R<DIV_SPEC>;
        ///Register `DIV` writer
        pub type W = crate::W<DIV_SPEC>;
        ///Field `DIV` reader - RW, UART3 pre-divisor latch byte, only low 7 bit, from 1 to 128
        pub type DIV_R = crate::FieldReader;
        ///Field `DIV` writer - RW, UART3 pre-divisor latch byte, only low 7 bit, from 1 to 128
        pub type DIV_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            ///Bits 0:7 - RW, UART3 pre-divisor latch byte, only low 7 bit, from 1 to 128
            #[inline(always)]
            pub fn div(&self) -> DIV_R {
                DIV_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:7 - RW, UART3 pre-divisor latch byte, only low 7 bit, from 1 to 128
            #[inline(always)]
            #[must_use]
            pub fn div(&mut self) -> DIV_W<DIV_SPEC> {
                DIV_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW, UART3 pre-divisor latch byte, only low 7 bit, from 1 to 128
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`div::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`div::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct DIV_SPEC;
        impl crate::RegisterSpec for DIV_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`div::R`](R) reader structure
        impl crate::Readable for DIV_SPEC {}
        ///`write(|w| ..)` method takes [`div::W`](W) writer structure
        impl crate::Writable for DIV_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets DIV to value 0
        impl crate::Resettable for DIV_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
}
///SPI0 register
pub struct SPI0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for SPI0 {}
impl SPI0 {
    ///Pointer to the register block
    pub const PTR: *const spi0::RegisterBlock = 0x4000_4000 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const spi0::RegisterBlock {
        Self::PTR
    }
    /// Steal an instance of this peripheral
    ///
    /// # Safety
    ///
    /// Ensure that the new instance of the peripheral cannot be used in a way
    /// that may race with any existing instances, for example by only
    /// accessing read-only or write-only registers, or by consuming the
    /// original peripheral and using critical sections to coordinate
    /// access between multiple new instances.
    ///
    /// Additionally, other software such as HALs may rely on only one
    /// peripheral instance existing to ensure memory safety; ensure
    /// no stolen instances are passed to such software.
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for SPI0 {
    type Target = spi0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for SPI0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("SPI0").finish()
    }
}
///SPI0 register
pub mod spi0 {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        ctrl_mod: CTRL_MOD,
        ctrl_cfg: CTRL_CFG,
        inter_en: INTER_EN,
        clock_div__r8_spi0_slave_pre: CLOCK_DIV__R8_SPI0_SLAVE_PRE,
        buffer: BUFFER,
        run_flag: RUN_FLAG,
        int_flag: INT_FLAG,
        fifo_count: FIFO_COUNT,
        _reserved8: [u8; 0x04],
        total_cnt: TOTAL_CNT,
        _reserved9: [u8; 0x02],
        fifo: FIFO,
        _reserved10: [u8; 0x02],
        fifo_count1: FIFO_COUNT1,
        dma_now: DMA_NOW,
        _reserved12: [u8; 0x02],
        dma_beg: DMA_BEG,
        _reserved13: [u8; 0x02],
        dma_end: DMA_END,
    }
    impl RegisterBlock {
        ///0x00 - RW, SPI0 mode control
        #[inline(always)]
        pub const fn ctrl_mod(&self) -> &CTRL_MOD {
            &self.ctrl_mod
        }
        ///0x01 - RW, SPI0 configuration control
        #[inline(always)]
        pub const fn ctrl_cfg(&self) -> &CTRL_CFG {
            &self.ctrl_cfg
        }
        ///0x02 - RW, SPI0 interrupt enable
        #[inline(always)]
        pub const fn inter_en(&self) -> &INTER_EN {
            &self.inter_en
        }
        ///0x03 - RW, SPI0 master clock divisor;RW, SPI0 slave preset value
        #[inline(always)]
        pub const fn clock_div__r8_spi0_slave_pre(&self) -> &CLOCK_DIV__R8_SPI0_SLAVE_PRE {
            &self.clock_div__r8_spi0_slave_pre
        }
        ///0x04 - RW, SPI0 data buffer
        #[inline(always)]
        pub const fn buffer(&self) -> &BUFFER {
            &self.buffer
        }
        ///0x05 - RO, SPI0 work flag
        #[inline(always)]
        pub const fn run_flag(&self) -> &RUN_FLAG {
            &self.run_flag
        }
        ///0x06 - RW1, SPI0 interrupt flag
        #[inline(always)]
        pub const fn int_flag(&self) -> &INT_FLAG {
            &self.int_flag
        }
        ///0x07 - RO, SPI0 FIFO count status
        #[inline(always)]
        pub const fn fifo_count(&self) -> &FIFO_COUNT {
            &self.fifo_count
        }
        ///0x0c - RW, SPI0 total byte count, only low 12 bit
        #[inline(always)]
        pub const fn total_cnt(&self) -> &TOTAL_CNT {
            &self.total_cnt
        }
        ///0x10 - RO/WO, SPI0 FIFO register
        #[inline(always)]
        pub const fn fifo(&self) -> &FIFO {
            &self.fifo
        }
        ///0x13 - RO, SPI0 FIFO count status
        #[inline(always)]
        pub const fn fifo_count1(&self) -> &FIFO_COUNT1 {
            &self.fifo_count1
        }
        ///0x14 - RW, SPI0 DMA current address
        #[inline(always)]
        pub const fn dma_now(&self) -> &DMA_NOW {
            &self.dma_now
        }
        ///0x18 - RW, SPI0 DMA begin address
        #[inline(always)]
        pub const fn dma_beg(&self) -> &DMA_BEG {
            &self.dma_beg
        }
        ///0x1c - RW, SPI0 DMA end address
        #[inline(always)]
        pub const fn dma_end(&self) -> &DMA_END {
            &self.dma_end
        }
    }
    ///CTRL_MOD (rw) register accessor: RW, SPI0 mode control
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`ctrl_mod::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ctrl_mod::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@ctrl_mod`]
    ///module
    pub type CTRL_MOD = crate::Reg<ctrl_mod::CTRL_MOD_SPEC>;
    ///RW, SPI0 mode control
    pub mod ctrl_mod {
        ///Register `CTRL_MOD` reader
        pub type R = crate::R<CTRL_MOD_SPEC>;
        ///Register `CTRL_MOD` writer
        pub type W = crate::W<CTRL_MOD_SPEC>;
        ///Field `SPI_MODE_SLAVE` reader - RW, SPI0 slave mode: 0=master or host, 1=slave or device
        pub type SPI_MODE_SLAVE_R = crate::BitReader;
        ///Field `SPI_MODE_SLAVE` writer - RW, SPI0 slave mode: 0=master or host, 1=slave or device
        pub type SPI_MODE_SLAVE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `SPI_ALL_CLEAR` reader - RW, force clear SPI FIFO and count
        pub type SPI_ALL_CLEAR_R = crate::BitReader;
        ///Field `SPI_ALL_CLEAR` writer - RW, force clear SPI FIFO and count
        pub type SPI_ALL_CLEAR_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `SPI_2WIRE_MOD` reader - RW, SPI0 enable 2 wire mode for slave: 0=3wire(SCK0,MOSI,MISO), 1=2wire(SCK0,MISO=MXSX)
        pub type SPI_2WIRE_MOD_R = crate::BitReader;
        ///Field `SPI_2WIRE_MOD` writer - RW, SPI0 enable 2 wire mode for slave: 0=3wire(SCK0,MOSI,MISO), 1=2wire(SCK0,MISO=MXSX)
        pub type SPI_2WIRE_MOD_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `SPI_MST_SCK_MOD__RB_SPI_SLV_CMD_MOD` reader - RW, SPI master clock mode: 0=mode 0, 1=mode 3;RW, SPI0 slave command mode: 0=byte stream, 1=first byte command
        pub type SPI_MST_SCK_MOD__RB_SPI_SLV_CMD_MOD_R = crate::BitReader;
        ///Field `SPI_MST_SCK_MOD__RB_SPI_SLV_CMD_MOD` writer - RW, SPI master clock mode: 0=mode 0, 1=mode 3;RW, SPI0 slave command mode: 0=byte stream, 1=first byte command
        pub type SPI_MST_SCK_MOD__RB_SPI_SLV_CMD_MOD_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `SPI_FIFO_DIR` reader - RW, SPI FIFO direction: 0=out(write @master mode), 1=in(read @master mode)
        pub type SPI_FIFO_DIR_R = crate::BitReader;
        ///Field `SPI_FIFO_DIR` writer - RW, SPI FIFO direction: 0=out(write @master mode), 1=in(read @master mode)
        pub type SPI_FIFO_DIR_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `SPI_SCK_OE` reader - RW, SPI SCK output enable
        pub type SPI_SCK_OE_R = crate::BitReader;
        ///Field `SPI_SCK_OE` writer - RW, SPI SCK output enable
        pub type SPI_SCK_OE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `SPI_MOSI_OE` reader - RW, SPI MOSI output enable
        pub type SPI_MOSI_OE_R = crate::BitReader;
        ///Field `SPI_MOSI_OE` writer - RW, SPI MOSI output enable
        pub type SPI_MOSI_OE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `SPI_MISO_OE` reader - RW, SPI MISO output enable
        pub type SPI_MISO_OE_R = crate::BitReader;
        ///Field `SPI_MISO_OE` writer - RW, SPI MISO output enable
        pub type SPI_MISO_OE_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - RW, SPI0 slave mode: 0=master or host, 1=slave or device
            #[inline(always)]
            pub fn spi_mode_slave(&self) -> SPI_MODE_SLAVE_R {
                SPI_MODE_SLAVE_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RW, force clear SPI FIFO and count
            #[inline(always)]
            pub fn spi_all_clear(&self) -> SPI_ALL_CLEAR_R {
                SPI_ALL_CLEAR_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RW, SPI0 enable 2 wire mode for slave: 0=3wire(SCK0,MOSI,MISO), 1=2wire(SCK0,MISO=MXSX)
            #[inline(always)]
            pub fn spi_2wire_mod(&self) -> SPI_2WIRE_MOD_R {
                SPI_2WIRE_MOD_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RW, SPI master clock mode: 0=mode 0, 1=mode 3;RW, SPI0 slave command mode: 0=byte stream, 1=first byte command
            #[inline(always)]
            pub fn spi_mst_sck_mod__rb_spi_slv_cmd_mod(
                &self,
            ) -> SPI_MST_SCK_MOD__RB_SPI_SLV_CMD_MOD_R {
                SPI_MST_SCK_MOD__RB_SPI_SLV_CMD_MOD_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RW, SPI FIFO direction: 0=out(write @master mode), 1=in(read @master mode)
            #[inline(always)]
            pub fn spi_fifo_dir(&self) -> SPI_FIFO_DIR_R {
                SPI_FIFO_DIR_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - RW, SPI SCK output enable
            #[inline(always)]
            pub fn spi_sck_oe(&self) -> SPI_SCK_OE_R {
                SPI_SCK_OE_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - RW, SPI MOSI output enable
            #[inline(always)]
            pub fn spi_mosi_oe(&self) -> SPI_MOSI_OE_R {
                SPI_MOSI_OE_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - RW, SPI MISO output enable
            #[inline(always)]
            pub fn spi_miso_oe(&self) -> SPI_MISO_OE_R {
                SPI_MISO_OE_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RW, SPI0 slave mode: 0=master or host, 1=slave or device
            #[inline(always)]
            #[must_use]
            pub fn spi_mode_slave(&mut self) -> SPI_MODE_SLAVE_W<CTRL_MOD_SPEC> {
                SPI_MODE_SLAVE_W::new(self, 0)
            }
            ///Bit 1 - RW, force clear SPI FIFO and count
            #[inline(always)]
            #[must_use]
            pub fn spi_all_clear(&mut self) -> SPI_ALL_CLEAR_W<CTRL_MOD_SPEC> {
                SPI_ALL_CLEAR_W::new(self, 1)
            }
            ///Bit 2 - RW, SPI0 enable 2 wire mode for slave: 0=3wire(SCK0,MOSI,MISO), 1=2wire(SCK0,MISO=MXSX)
            #[inline(always)]
            #[must_use]
            pub fn spi_2wire_mod(&mut self) -> SPI_2WIRE_MOD_W<CTRL_MOD_SPEC> {
                SPI_2WIRE_MOD_W::new(self, 2)
            }
            ///Bit 3 - RW, SPI master clock mode: 0=mode 0, 1=mode 3;RW, SPI0 slave command mode: 0=byte stream, 1=first byte command
            #[inline(always)]
            #[must_use]
            pub fn spi_mst_sck_mod__rb_spi_slv_cmd_mod(
                &mut self,
            ) -> SPI_MST_SCK_MOD__RB_SPI_SLV_CMD_MOD_W<CTRL_MOD_SPEC> {
                SPI_MST_SCK_MOD__RB_SPI_SLV_CMD_MOD_W::new(self, 3)
            }
            ///Bit 4 - RW, SPI FIFO direction: 0=out(write @master mode), 1=in(read @master mode)
            #[inline(always)]
            #[must_use]
            pub fn spi_fifo_dir(&mut self) -> SPI_FIFO_DIR_W<CTRL_MOD_SPEC> {
                SPI_FIFO_DIR_W::new(self, 4)
            }
            ///Bit 5 - RW, SPI SCK output enable
            #[inline(always)]
            #[must_use]
            pub fn spi_sck_oe(&mut self) -> SPI_SCK_OE_W<CTRL_MOD_SPEC> {
                SPI_SCK_OE_W::new(self, 5)
            }
            ///Bit 6 - RW, SPI MOSI output enable
            #[inline(always)]
            #[must_use]
            pub fn spi_mosi_oe(&mut self) -> SPI_MOSI_OE_W<CTRL_MOD_SPEC> {
                SPI_MOSI_OE_W::new(self, 6)
            }
            ///Bit 7 - RW, SPI MISO output enable
            #[inline(always)]
            #[must_use]
            pub fn spi_miso_oe(&mut self) -> SPI_MISO_OE_W<CTRL_MOD_SPEC> {
                SPI_MISO_OE_W::new(self, 7)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW, SPI0 mode control
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`ctrl_mod::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ctrl_mod::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct CTRL_MOD_SPEC;
        impl crate::RegisterSpec for CTRL_MOD_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`ctrl_mod::R`](R) reader structure
        impl crate::Readable for CTRL_MOD_SPEC {}
        ///`write(|w| ..)` method takes [`ctrl_mod::W`](W) writer structure
        impl crate::Writable for CTRL_MOD_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets CTRL_MOD to value 0x02
        impl crate::Resettable for CTRL_MOD_SPEC {
            const RESET_VALUE: u8 = 0x02;
        }
    }
    ///CTRL_CFG (rw) register accessor: RW, SPI0 configuration control
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`ctrl_cfg::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ctrl_cfg::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@ctrl_cfg`]
    ///module
    pub type CTRL_CFG = crate::Reg<ctrl_cfg::CTRL_CFG_SPEC>;
    ///RW, SPI0 configuration control
    pub mod ctrl_cfg {
        ///Register `CTRL_CFG` reader
        pub type R = crate::R<CTRL_CFG_SPEC>;
        ///Register `CTRL_CFG` writer
        pub type W = crate::W<CTRL_CFG_SPEC>;
        ///Field `SPI_DMA_ENABLE` reader - RW, SPI0 DMA enable
        pub type SPI_DMA_ENABLE_R = crate::BitReader;
        ///Field `SPI_DMA_ENABLE` writer - RW, SPI0 DMA enable
        pub type SPI_DMA_ENABLE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `SPI_DMA_LOOP` reader - RW, SPI0 DMA address loop enable
        pub type SPI_DMA_LOOP_R = crate::BitReader;
        ///Field `SPI_DMA_LOOP` writer - RW, SPI0 DMA address loop enable
        pub type SPI_DMA_LOOP_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `SPI_AUTO_IF` reader - RW, enable buffer/FIFO accessing to auto clear RB_SPI_IF_BYTE_END interrupt flag
        pub type SPI_AUTO_IF_R = crate::BitReader;
        ///Field `SPI_AUTO_IF` writer - RW, enable buffer/FIFO accessing to auto clear RB_SPI_IF_BYTE_END interrupt flag
        pub type SPI_AUTO_IF_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `SPI_BIT_ORDER` reader - RW, SPI bit data order: 0=MSB first, 1=LSB first
        pub type SPI_BIT_ORDER_R = crate::BitReader;
        ///Field `SPI_BIT_ORDER` writer - RW, SPI bit data order: 0=MSB first, 1=LSB first
        pub type SPI_BIT_ORDER_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `SPI_MST_DLY_EN` reader - RW, SPI master input delay enable
        pub type SPI_MST_DLY_EN_R = crate::BitReader;
        ///Field `SPI_MST_DLY_EN` writer - RW, SPI master input delay enable
        pub type SPI_MST_DLY_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - RW, SPI0 DMA enable
            #[inline(always)]
            pub fn spi_dma_enable(&self) -> SPI_DMA_ENABLE_R {
                SPI_DMA_ENABLE_R::new((self.bits & 1) != 0)
            }
            ///Bit 2 - RW, SPI0 DMA address loop enable
            #[inline(always)]
            pub fn spi_dma_loop(&self) -> SPI_DMA_LOOP_R {
                SPI_DMA_LOOP_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 4 - RW, enable buffer/FIFO accessing to auto clear RB_SPI_IF_BYTE_END interrupt flag
            #[inline(always)]
            pub fn spi_auto_if(&self) -> SPI_AUTO_IF_R {
                SPI_AUTO_IF_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - RW, SPI bit data order: 0=MSB first, 1=LSB first
            #[inline(always)]
            pub fn spi_bit_order(&self) -> SPI_BIT_ORDER_R {
                SPI_BIT_ORDER_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - RW, SPI master input delay enable
            #[inline(always)]
            pub fn spi_mst_dly_en(&self) -> SPI_MST_DLY_EN_R {
                SPI_MST_DLY_EN_R::new(((self.bits >> 6) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RW, SPI0 DMA enable
            #[inline(always)]
            #[must_use]
            pub fn spi_dma_enable(&mut self) -> SPI_DMA_ENABLE_W<CTRL_CFG_SPEC> {
                SPI_DMA_ENABLE_W::new(self, 0)
            }
            ///Bit 2 - RW, SPI0 DMA address loop enable
            #[inline(always)]
            #[must_use]
            pub fn spi_dma_loop(&mut self) -> SPI_DMA_LOOP_W<CTRL_CFG_SPEC> {
                SPI_DMA_LOOP_W::new(self, 2)
            }
            ///Bit 4 - RW, enable buffer/FIFO accessing to auto clear RB_SPI_IF_BYTE_END interrupt flag
            #[inline(always)]
            #[must_use]
            pub fn spi_auto_if(&mut self) -> SPI_AUTO_IF_W<CTRL_CFG_SPEC> {
                SPI_AUTO_IF_W::new(self, 4)
            }
            ///Bit 5 - RW, SPI bit data order: 0=MSB first, 1=LSB first
            #[inline(always)]
            #[must_use]
            pub fn spi_bit_order(&mut self) -> SPI_BIT_ORDER_W<CTRL_CFG_SPEC> {
                SPI_BIT_ORDER_W::new(self, 5)
            }
            ///Bit 6 - RW, SPI master input delay enable
            #[inline(always)]
            #[must_use]
            pub fn spi_mst_dly_en(&mut self) -> SPI_MST_DLY_EN_W<CTRL_CFG_SPEC> {
                SPI_MST_DLY_EN_W::new(self, 6)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW, SPI0 configuration control
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`ctrl_cfg::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ctrl_cfg::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct CTRL_CFG_SPEC;
        impl crate::RegisterSpec for CTRL_CFG_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`ctrl_cfg::R`](R) reader structure
        impl crate::Readable for CTRL_CFG_SPEC {}
        ///`write(|w| ..)` method takes [`ctrl_cfg::W`](W) writer structure
        impl crate::Writable for CTRL_CFG_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets CTRL_CFG to value 0
        impl crate::Resettable for CTRL_CFG_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///INTER_EN (rw) register accessor: RW, SPI0 interrupt enable
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`inter_en::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`inter_en::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@inter_en`]
    ///module
    pub type INTER_EN = crate::Reg<inter_en::INTER_EN_SPEC>;
    ///RW, SPI0 interrupt enable
    pub mod inter_en {
        ///Register `INTER_EN` reader
        pub type R = crate::R<INTER_EN_SPEC>;
        ///Register `INTER_EN` writer
        pub type W = crate::W<INTER_EN_SPEC>;
        ///Field `SPI_IE_CNT_END` reader - RW, enable interrupt for SPI total byte count end
        pub type SPI_IE_CNT_END_R = crate::BitReader;
        ///Field `SPI_IE_CNT_END` writer - RW, enable interrupt for SPI total byte count end
        pub type SPI_IE_CNT_END_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `SPI_IE_BYTE_END` reader - RW, enable interrupt for SPI byte exchanged
        pub type SPI_IE_BYTE_END_R = crate::BitReader;
        ///Field `SPI_IE_BYTE_END` writer - RW, enable interrupt for SPI byte exchanged
        pub type SPI_IE_BYTE_END_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `SPI_IE_FIFO_HF` reader - RW, enable interrupt for SPI FIFO half
        pub type SPI_IE_FIFO_HF_R = crate::BitReader;
        ///Field `SPI_IE_FIFO_HF` writer - RW, enable interrupt for SPI FIFO half
        pub type SPI_IE_FIFO_HF_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `SPI_IE_DMA_END` reader - RW, enable interrupt for SPI0 DMA completion
        pub type SPI_IE_DMA_END_R = crate::BitReader;
        ///Field `SPI_IE_DMA_END` writer - RW, enable interrupt for SPI0 DMA completion
        pub type SPI_IE_DMA_END_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `SPI_IE_FIFO_OV` reader - RW, enable interrupt for SPI0 FIFO overflow
        pub type SPI_IE_FIFO_OV_R = crate::BitReader;
        ///Field `SPI_IE_FIFO_OV` writer - RW, enable interrupt for SPI0 FIFO overflow
        pub type SPI_IE_FIFO_OV_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `SPI_IE_FST_BYTE` reader - RW, enable interrupt for SPI0 slave mode first byte received
        pub type SPI_IE_FST_BYTE_R = crate::BitReader;
        ///Field `SPI_IE_FST_BYTE` writer - RW, enable interrupt for SPI0 slave mode first byte received
        pub type SPI_IE_FST_BYTE_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - RW, enable interrupt for SPI total byte count end
            #[inline(always)]
            pub fn spi_ie_cnt_end(&self) -> SPI_IE_CNT_END_R {
                SPI_IE_CNT_END_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RW, enable interrupt for SPI byte exchanged
            #[inline(always)]
            pub fn spi_ie_byte_end(&self) -> SPI_IE_BYTE_END_R {
                SPI_IE_BYTE_END_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RW, enable interrupt for SPI FIFO half
            #[inline(always)]
            pub fn spi_ie_fifo_hf(&self) -> SPI_IE_FIFO_HF_R {
                SPI_IE_FIFO_HF_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RW, enable interrupt for SPI0 DMA completion
            #[inline(always)]
            pub fn spi_ie_dma_end(&self) -> SPI_IE_DMA_END_R {
                SPI_IE_DMA_END_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RW, enable interrupt for SPI0 FIFO overflow
            #[inline(always)]
            pub fn spi_ie_fifo_ov(&self) -> SPI_IE_FIFO_OV_R {
                SPI_IE_FIFO_OV_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 7 - RW, enable interrupt for SPI0 slave mode first byte received
            #[inline(always)]
            pub fn spi_ie_fst_byte(&self) -> SPI_IE_FST_BYTE_R {
                SPI_IE_FST_BYTE_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RW, enable interrupt for SPI total byte count end
            #[inline(always)]
            #[must_use]
            pub fn spi_ie_cnt_end(&mut self) -> SPI_IE_CNT_END_W<INTER_EN_SPEC> {
                SPI_IE_CNT_END_W::new(self, 0)
            }
            ///Bit 1 - RW, enable interrupt for SPI byte exchanged
            #[inline(always)]
            #[must_use]
            pub fn spi_ie_byte_end(&mut self) -> SPI_IE_BYTE_END_W<INTER_EN_SPEC> {
                SPI_IE_BYTE_END_W::new(self, 1)
            }
            ///Bit 2 - RW, enable interrupt for SPI FIFO half
            #[inline(always)]
            #[must_use]
            pub fn spi_ie_fifo_hf(&mut self) -> SPI_IE_FIFO_HF_W<INTER_EN_SPEC> {
                SPI_IE_FIFO_HF_W::new(self, 2)
            }
            ///Bit 3 - RW, enable interrupt for SPI0 DMA completion
            #[inline(always)]
            #[must_use]
            pub fn spi_ie_dma_end(&mut self) -> SPI_IE_DMA_END_W<INTER_EN_SPEC> {
                SPI_IE_DMA_END_W::new(self, 3)
            }
            ///Bit 4 - RW, enable interrupt for SPI0 FIFO overflow
            #[inline(always)]
            #[must_use]
            pub fn spi_ie_fifo_ov(&mut self) -> SPI_IE_FIFO_OV_W<INTER_EN_SPEC> {
                SPI_IE_FIFO_OV_W::new(self, 4)
            }
            ///Bit 7 - RW, enable interrupt for SPI0 slave mode first byte received
            #[inline(always)]
            #[must_use]
            pub fn spi_ie_fst_byte(&mut self) -> SPI_IE_FST_BYTE_W<INTER_EN_SPEC> {
                SPI_IE_FST_BYTE_W::new(self, 7)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW, SPI0 interrupt enable
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`inter_en::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`inter_en::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct INTER_EN_SPEC;
        impl crate::RegisterSpec for INTER_EN_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`inter_en::R`](R) reader structure
        impl crate::Readable for INTER_EN_SPEC {}
        ///`write(|w| ..)` method takes [`inter_en::W`](W) writer structure
        impl crate::Writable for INTER_EN_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets INTER_EN to value 0
        impl crate::Resettable for INTER_EN_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///CLOCK_DIV__R8_SPI0_SLAVE_PRE (rw) register accessor: RW, SPI0 master clock divisor;RW, SPI0 slave preset value
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`clock_div__r8_spi0_slave_pre::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`clock_div__r8_spi0_slave_pre::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@clock_div__r8_spi0_slave_pre`]
    ///module
    pub type CLOCK_DIV__R8_SPI0_SLAVE_PRE =
        crate::Reg<clock_div__r8_spi0_slave_pre::CLOCK_DIV__R8_SPI0_SLAVE_PRE_SPEC>;
    ///RW, SPI0 master clock divisor;RW, SPI0 slave preset value
    pub mod clock_div__r8_spi0_slave_pre {
        ///Register `CLOCK_DIV__R8_SPI0_SLAVE_PRE` reader
        pub type R = crate::R<CLOCK_DIV__R8_SPI0_SLAVE_PRE_SPEC>;
        ///Register `CLOCK_DIV__R8_SPI0_SLAVE_PRE` writer
        pub type W = crate::W<CLOCK_DIV__R8_SPI0_SLAVE_PRE_SPEC>;
        ///Field `CLOCK_DIV__R8_SPI0_SLAVE_PRE` reader - RW, SPI0 master clock divisor;RW, SPI0 slave preset value
        pub type CLOCK_DIV__R8_SPI0_SLAVE_PRE_R = crate::FieldReader;
        ///Field `CLOCK_DIV__R8_SPI0_SLAVE_PRE` writer - RW, SPI0 master clock divisor;RW, SPI0 slave preset value
        pub type CLOCK_DIV__R8_SPI0_SLAVE_PRE_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            ///Bits 0:7 - RW, SPI0 master clock divisor;RW, SPI0 slave preset value
            #[inline(always)]
            pub fn clock_div__r8_spi0_slave_pre(&self) -> CLOCK_DIV__R8_SPI0_SLAVE_PRE_R {
                CLOCK_DIV__R8_SPI0_SLAVE_PRE_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:7 - RW, SPI0 master clock divisor;RW, SPI0 slave preset value
            #[inline(always)]
            #[must_use]
            pub fn clock_div__r8_spi0_slave_pre(
                &mut self,
            ) -> CLOCK_DIV__R8_SPI0_SLAVE_PRE_W<CLOCK_DIV__R8_SPI0_SLAVE_PRE_SPEC> {
                CLOCK_DIV__R8_SPI0_SLAVE_PRE_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW, SPI0 master clock divisor;RW, SPI0 slave preset value
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`clock_div__r8_spi0_slave_pre::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`clock_div__r8_spi0_slave_pre::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct CLOCK_DIV__R8_SPI0_SLAVE_PRE_SPEC;
        impl crate::RegisterSpec for CLOCK_DIV__R8_SPI0_SLAVE_PRE_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`clock_div__r8_spi0_slave_pre::R`](R) reader structure
        impl crate::Readable for CLOCK_DIV__R8_SPI0_SLAVE_PRE_SPEC {}
        ///`write(|w| ..)` method takes [`clock_div__r8_spi0_slave_pre::W`](W) writer structure
        impl crate::Writable for CLOCK_DIV__R8_SPI0_SLAVE_PRE_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets CLOCK_DIV__R8_SPI0_SLAVE_PRE to value 0x10
        impl crate::Resettable for CLOCK_DIV__R8_SPI0_SLAVE_PRE_SPEC {
            const RESET_VALUE: u8 = 0x10;
        }
    }
    ///BUFFER (rw) register accessor: RW, SPI0 data buffer
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`buffer::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`buffer::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@buffer`]
    ///module
    pub type BUFFER = crate::Reg<buffer::BUFFER_SPEC>;
    ///RW, SPI0 data buffer
    pub mod buffer {
        ///Register `BUFFER` reader
        pub type R = crate::R<BUFFER_SPEC>;
        ///Register `BUFFER` writer
        pub type W = crate::W<BUFFER_SPEC>;
        ///Field `BUFFER` reader - RW, SPI0 data buffer
        pub type BUFFER_R = crate::FieldReader;
        ///Field `BUFFER` writer - RW, SPI0 data buffer
        pub type BUFFER_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            ///Bits 0:7 - RW, SPI0 data buffer
            #[inline(always)]
            pub fn buffer(&self) -> BUFFER_R {
                BUFFER_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:7 - RW, SPI0 data buffer
            #[inline(always)]
            #[must_use]
            pub fn buffer(&mut self) -> BUFFER_W<BUFFER_SPEC> {
                BUFFER_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW, SPI0 data buffer
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`buffer::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`buffer::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct BUFFER_SPEC;
        impl crate::RegisterSpec for BUFFER_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`buffer::R`](R) reader structure
        impl crate::Readable for BUFFER_SPEC {}
        ///`write(|w| ..)` method takes [`buffer::W`](W) writer structure
        impl crate::Writable for BUFFER_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets BUFFER to value 0
        impl crate::Resettable for BUFFER_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///RUN_FLAG (r) register accessor: RO, SPI0 work flag
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`run_flag::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@run_flag`]
    ///module
    pub type RUN_FLAG = crate::Reg<run_flag::RUN_FLAG_SPEC>;
    ///RO, SPI0 work flag
    pub mod run_flag {
        ///Register `RUN_FLAG` reader
        pub type R = crate::R<RUN_FLAG_SPEC>;
        ///Field `SPI_SLV_CMD_ACT` reader - RO, SPI0 slave first byte or command flag
        pub type SPI_SLV_CMD_ACT_R = crate::BitReader;
        ///Field `SPI_FIFO_READY` reader - RO, SPI FIFO ready status
        pub type SPI_FIFO_READY_R = crate::BitReader;
        ///Field `SPI_SLV_CS_LOAD` reader - RO, SPI0 slave chip-select loading status
        pub type SPI_SLV_CS_LOAD_R = crate::BitReader;
        ///Field `SPI_SLV_SELECT` reader - RO, SPI0 slave selection status
        pub type SPI_SLV_SELECT_R = crate::BitReader;
        impl R {
            ///Bit 4 - RO, SPI0 slave first byte or command flag
            #[inline(always)]
            pub fn spi_slv_cmd_act(&self) -> SPI_SLV_CMD_ACT_R {
                SPI_SLV_CMD_ACT_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - RO, SPI FIFO ready status
            #[inline(always)]
            pub fn spi_fifo_ready(&self) -> SPI_FIFO_READY_R {
                SPI_FIFO_READY_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - RO, SPI0 slave chip-select loading status
            #[inline(always)]
            pub fn spi_slv_cs_load(&self) -> SPI_SLV_CS_LOAD_R {
                SPI_SLV_CS_LOAD_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - RO, SPI0 slave selection status
            #[inline(always)]
            pub fn spi_slv_select(&self) -> SPI_SLV_SELECT_R {
                SPI_SLV_SELECT_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        ///RO, SPI0 work flag
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`run_flag::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct RUN_FLAG_SPEC;
        impl crate::RegisterSpec for RUN_FLAG_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`run_flag::R`](R) reader structure
        impl crate::Readable for RUN_FLAG_SPEC {}
        ///`reset()` method sets RUN_FLAG to value 0
        impl crate::Resettable for RUN_FLAG_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///INT_FLAG (rw) register accessor: RW1, SPI0 interrupt flag
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`int_flag::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`int_flag::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@int_flag`]
    ///module
    pub type INT_FLAG = crate::Reg<int_flag::INT_FLAG_SPEC>;
    ///RW1, SPI0 interrupt flag
    pub mod int_flag {
        ///Register `INT_FLAG` reader
        pub type R = crate::R<INT_FLAG_SPEC>;
        ///Register `INT_FLAG` writer
        pub type W = crate::W<INT_FLAG_SPEC>;
        ///Field `SPI_IF_CNT_END` reader - RW1, interrupt flag for SPI total byte count end
        pub type SPI_IF_CNT_END_R = crate::BitReader;
        ///Field `SPI_IF_CNT_END` writer - RW1, interrupt flag for SPI total byte count end
        pub type SPI_IF_CNT_END_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `SPI_IF_BYTE_END` reader - RW1, interrupt flag for SPI byte exchanged
        pub type SPI_IF_BYTE_END_R = crate::BitReader;
        ///Field `SPI_IF_BYTE_END` writer - RW1, interrupt flag for SPI byte exchanged
        pub type SPI_IF_BYTE_END_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `SPI_IF_FIFO_HF` reader - RW1, interrupt flag for SPI FIFO half
        pub type SPI_IF_FIFO_HF_R = crate::BitReader;
        ///Field `SPI_IF_FIFO_HF` writer - RW1, interrupt flag for SPI FIFO half
        pub type SPI_IF_FIFO_HF_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `SPI_IF_DMA_END` reader - RW1, interrupt flag for SPI0 DMA completion
        pub type SPI_IF_DMA_END_R = crate::BitReader;
        ///Field `SPI_IF_DMA_END` writer - RW1, interrupt flag for SPI0 DMA completion
        pub type SPI_IF_DMA_END_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `SPI_IF_FIFO_OV` reader - RW1, interrupt flag for SPI0 FIFO overflow
        pub type SPI_IF_FIFO_OV_R = crate::BitReader;
        ///Field `SPI_IF_FIFO_OV` writer - RW1, interrupt flag for SPI0 FIFO overflow
        pub type SPI_IF_FIFO_OV_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `SPI_FREE` reader - RO, current SPI free status
        pub type SPI_FREE_R = crate::BitReader;
        ///Field `SPI_FREE` writer - RO, current SPI free status
        pub type SPI_FREE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `SPI_IF_FST_BYTE` reader - RW1, interrupt flag for SPI0 slave mode first byte received
        pub type SPI_IF_FST_BYTE_R = crate::BitReader;
        ///Field `SPI_IF_FST_BYTE` writer - RW1, interrupt flag for SPI0 slave mode first byte received
        pub type SPI_IF_FST_BYTE_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - RW1, interrupt flag for SPI total byte count end
            #[inline(always)]
            pub fn spi_if_cnt_end(&self) -> SPI_IF_CNT_END_R {
                SPI_IF_CNT_END_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RW1, interrupt flag for SPI byte exchanged
            #[inline(always)]
            pub fn spi_if_byte_end(&self) -> SPI_IF_BYTE_END_R {
                SPI_IF_BYTE_END_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RW1, interrupt flag for SPI FIFO half
            #[inline(always)]
            pub fn spi_if_fifo_hf(&self) -> SPI_IF_FIFO_HF_R {
                SPI_IF_FIFO_HF_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RW1, interrupt flag for SPI0 DMA completion
            #[inline(always)]
            pub fn spi_if_dma_end(&self) -> SPI_IF_DMA_END_R {
                SPI_IF_DMA_END_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RW1, interrupt flag for SPI0 FIFO overflow
            #[inline(always)]
            pub fn spi_if_fifo_ov(&self) -> SPI_IF_FIFO_OV_R {
                SPI_IF_FIFO_OV_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 6 - RO, current SPI free status
            #[inline(always)]
            pub fn spi_free(&self) -> SPI_FREE_R {
                SPI_FREE_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - RW1, interrupt flag for SPI0 slave mode first byte received
            #[inline(always)]
            pub fn spi_if_fst_byte(&self) -> SPI_IF_FST_BYTE_R {
                SPI_IF_FST_BYTE_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RW1, interrupt flag for SPI total byte count end
            #[inline(always)]
            #[must_use]
            pub fn spi_if_cnt_end(&mut self) -> SPI_IF_CNT_END_W<INT_FLAG_SPEC> {
                SPI_IF_CNT_END_W::new(self, 0)
            }
            ///Bit 1 - RW1, interrupt flag for SPI byte exchanged
            #[inline(always)]
            #[must_use]
            pub fn spi_if_byte_end(&mut self) -> SPI_IF_BYTE_END_W<INT_FLAG_SPEC> {
                SPI_IF_BYTE_END_W::new(self, 1)
            }
            ///Bit 2 - RW1, interrupt flag for SPI FIFO half
            #[inline(always)]
            #[must_use]
            pub fn spi_if_fifo_hf(&mut self) -> SPI_IF_FIFO_HF_W<INT_FLAG_SPEC> {
                SPI_IF_FIFO_HF_W::new(self, 2)
            }
            ///Bit 3 - RW1, interrupt flag for SPI0 DMA completion
            #[inline(always)]
            #[must_use]
            pub fn spi_if_dma_end(&mut self) -> SPI_IF_DMA_END_W<INT_FLAG_SPEC> {
                SPI_IF_DMA_END_W::new(self, 3)
            }
            ///Bit 4 - RW1, interrupt flag for SPI0 FIFO overflow
            #[inline(always)]
            #[must_use]
            pub fn spi_if_fifo_ov(&mut self) -> SPI_IF_FIFO_OV_W<INT_FLAG_SPEC> {
                SPI_IF_FIFO_OV_W::new(self, 4)
            }
            ///Bit 6 - RO, current SPI free status
            #[inline(always)]
            #[must_use]
            pub fn spi_free(&mut self) -> SPI_FREE_W<INT_FLAG_SPEC> {
                SPI_FREE_W::new(self, 6)
            }
            ///Bit 7 - RW1, interrupt flag for SPI0 slave mode first byte received
            #[inline(always)]
            #[must_use]
            pub fn spi_if_fst_byte(&mut self) -> SPI_IF_FST_BYTE_W<INT_FLAG_SPEC> {
                SPI_IF_FST_BYTE_W::new(self, 7)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW1, SPI0 interrupt flag
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`int_flag::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`int_flag::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct INT_FLAG_SPEC;
        impl crate::RegisterSpec for INT_FLAG_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`int_flag::R`](R) reader structure
        impl crate::Readable for INT_FLAG_SPEC {}
        ///`write(|w| ..)` method takes [`int_flag::W`](W) writer structure
        impl crate::Writable for INT_FLAG_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets INT_FLAG to value 0x40
        impl crate::Resettable for INT_FLAG_SPEC {
            const RESET_VALUE: u8 = 0x40;
        }
    }
    ///FIFO_COUNT (r) register accessor: RO, SPI0 FIFO count status
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`fifo_count::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@fifo_count`]
    ///module
    pub type FIFO_COUNT = crate::Reg<fifo_count::FIFO_COUNT_SPEC>;
    ///RO, SPI0 FIFO count status
    pub mod fifo_count {
        ///Register `FIFO_COUNT` reader
        pub type R = crate::R<FIFO_COUNT_SPEC>;
        ///Field `FIFO_COUNT` reader - RO, SPI0 FIFO count status
        pub type FIFO_COUNT_R = crate::FieldReader;
        impl R {
            ///Bits 0:7 - RO, SPI0 FIFO count status
            #[inline(always)]
            pub fn fifo_count(&self) -> FIFO_COUNT_R {
                FIFO_COUNT_R::new(self.bits)
            }
        }
        ///RO, SPI0 FIFO count status
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`fifo_count::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct FIFO_COUNT_SPEC;
        impl crate::RegisterSpec for FIFO_COUNT_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`fifo_count::R`](R) reader structure
        impl crate::Readable for FIFO_COUNT_SPEC {}
        ///`reset()` method sets FIFO_COUNT to value 0
        impl crate::Resettable for FIFO_COUNT_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///TOTAL_CNT (rw) register accessor: RW, SPI0 total byte count, only low 12 bit
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`total_cnt::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`total_cnt::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@total_cnt`]
    ///module
    pub type TOTAL_CNT = crate::Reg<total_cnt::TOTAL_CNT_SPEC>;
    ///RW, SPI0 total byte count, only low 12 bit
    pub mod total_cnt {
        ///Register `TOTAL_CNT` reader
        pub type R = crate::R<TOTAL_CNT_SPEC>;
        ///Register `TOTAL_CNT` writer
        pub type W = crate::W<TOTAL_CNT_SPEC>;
        ///Field `TOTAL_CNT` reader - RW, SPI0 total byte count, only low 12 bit
        pub type TOTAL_CNT_R = crate::FieldReader<u16>;
        ///Field `TOTAL_CNT` writer - RW, SPI0 total byte count, only low 12 bit
        pub type TOTAL_CNT_W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            ///Bits 0:15 - RW, SPI0 total byte count, only low 12 bit
            #[inline(always)]
            pub fn total_cnt(&self) -> TOTAL_CNT_R {
                TOTAL_CNT_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - RW, SPI0 total byte count, only low 12 bit
            #[inline(always)]
            #[must_use]
            pub fn total_cnt(&mut self) -> TOTAL_CNT_W<TOTAL_CNT_SPEC> {
                TOTAL_CNT_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW, SPI0 total byte count, only low 12 bit
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`total_cnt::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`total_cnt::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct TOTAL_CNT_SPEC;
        impl crate::RegisterSpec for TOTAL_CNT_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`total_cnt::R`](R) reader structure
        impl crate::Readable for TOTAL_CNT_SPEC {}
        ///`write(|w| ..)` method takes [`total_cnt::W`](W) writer structure
        impl crate::Writable for TOTAL_CNT_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets TOTAL_CNT to value 0
        impl crate::Resettable for TOTAL_CNT_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///FIFO (rw) register accessor: RO/WO, SPI0 FIFO register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`fifo::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`fifo::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@fifo`]
    ///module
    pub type FIFO = crate::Reg<fifo::FIFO_SPEC>;
    ///RO/WO, SPI0 FIFO register
    pub mod fifo {
        ///Register `FIFO` reader
        pub type R = crate::R<FIFO_SPEC>;
        ///Register `FIFO` writer
        pub type W = crate::W<FIFO_SPEC>;
        ///Field `FIFO` reader - RO/WO, SPI0 FIFO register
        pub type FIFO_R = crate::FieldReader;
        ///Field `FIFO` writer - RO/WO, SPI0 FIFO register
        pub type FIFO_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            ///Bits 0:7 - RO/WO, SPI0 FIFO register
            #[inline(always)]
            pub fn fifo(&self) -> FIFO_R {
                FIFO_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:7 - RO/WO, SPI0 FIFO register
            #[inline(always)]
            #[must_use]
            pub fn fifo(&mut self) -> FIFO_W<FIFO_SPEC> {
                FIFO_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RO/WO, SPI0 FIFO register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`fifo::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`fifo::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct FIFO_SPEC;
        impl crate::RegisterSpec for FIFO_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`fifo::R`](R) reader structure
        impl crate::Readable for FIFO_SPEC {}
        ///`write(|w| ..)` method takes [`fifo::W`](W) writer structure
        impl crate::Writable for FIFO_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets FIFO to value 0
        impl crate::Resettable for FIFO_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///FIFO_COUNT1 (r) register accessor: RO, SPI0 FIFO count status
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`fifo_count1::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@fifo_count1`]
    ///module
    pub type FIFO_COUNT1 = crate::Reg<fifo_count1::FIFO_COUNT1_SPEC>;
    ///RO, SPI0 FIFO count status
    pub mod fifo_count1 {
        ///Register `FIFO_COUNT1` reader
        pub type R = crate::R<FIFO_COUNT1_SPEC>;
        ///Field `FIFO_COUNT1` reader - RO, SPI0 FIFO count status
        pub type FIFO_COUNT1_R = crate::FieldReader;
        impl R {
            ///Bits 0:7 - RO, SPI0 FIFO count status
            #[inline(always)]
            pub fn fifo_count1(&self) -> FIFO_COUNT1_R {
                FIFO_COUNT1_R::new(self.bits)
            }
        }
        ///RO, SPI0 FIFO count status
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`fifo_count1::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct FIFO_COUNT1_SPEC;
        impl crate::RegisterSpec for FIFO_COUNT1_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`fifo_count1::R`](R) reader structure
        impl crate::Readable for FIFO_COUNT1_SPEC {}
        ///`reset()` method sets FIFO_COUNT1 to value 0
        impl crate::Resettable for FIFO_COUNT1_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///DMA_NOW (rw) register accessor: RW, SPI0 DMA current address
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`dma_now::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dma_now::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@dma_now`]
    ///module
    pub type DMA_NOW = crate::Reg<dma_now::DMA_NOW_SPEC>;
    ///RW, SPI0 DMA current address
    pub mod dma_now {
        ///Register `DMA_NOW` reader
        pub type R = crate::R<DMA_NOW_SPEC>;
        ///Register `DMA_NOW` writer
        pub type W = crate::W<DMA_NOW_SPEC>;
        ///Field `DMA_NOW` reader - RW, SPI0 DMA current address
        pub type DMA_NOW_R = crate::FieldReader<u16>;
        ///Field `DMA_NOW` writer - RW, SPI0 DMA current address
        pub type DMA_NOW_W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            ///Bits 0:15 - RW, SPI0 DMA current address
            #[inline(always)]
            pub fn dma_now(&self) -> DMA_NOW_R {
                DMA_NOW_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - RW, SPI0 DMA current address
            #[inline(always)]
            #[must_use]
            pub fn dma_now(&mut self) -> DMA_NOW_W<DMA_NOW_SPEC> {
                DMA_NOW_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW, SPI0 DMA current address
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`dma_now::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dma_now::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct DMA_NOW_SPEC;
        impl crate::RegisterSpec for DMA_NOW_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`dma_now::R`](R) reader structure
        impl crate::Readable for DMA_NOW_SPEC {}
        ///`write(|w| ..)` method takes [`dma_now::W`](W) writer structure
        impl crate::Writable for DMA_NOW_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets DMA_NOW to value 0
        impl crate::Resettable for DMA_NOW_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///DMA_BEG (rw) register accessor: RW, SPI0 DMA begin address
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`dma_beg::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dma_beg::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@dma_beg`]
    ///module
    pub type DMA_BEG = crate::Reg<dma_beg::DMA_BEG_SPEC>;
    ///RW, SPI0 DMA begin address
    pub mod dma_beg {
        ///Register `DMA_BEG` reader
        pub type R = crate::R<DMA_BEG_SPEC>;
        ///Register `DMA_BEG` writer
        pub type W = crate::W<DMA_BEG_SPEC>;
        ///Field `DMA_BEG` reader - RW, SPI0 DMA begin address
        pub type DMA_BEG_R = crate::FieldReader<u16>;
        ///Field `DMA_BEG` writer - RW, SPI0 DMA begin address
        pub type DMA_BEG_W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            ///Bits 0:15 - RW, SPI0 DMA begin address
            #[inline(always)]
            pub fn dma_beg(&self) -> DMA_BEG_R {
                DMA_BEG_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - RW, SPI0 DMA begin address
            #[inline(always)]
            #[must_use]
            pub fn dma_beg(&mut self) -> DMA_BEG_W<DMA_BEG_SPEC> {
                DMA_BEG_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW, SPI0 DMA begin address
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`dma_beg::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dma_beg::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct DMA_BEG_SPEC;
        impl crate::RegisterSpec for DMA_BEG_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`dma_beg::R`](R) reader structure
        impl crate::Readable for DMA_BEG_SPEC {}
        ///`write(|w| ..)` method takes [`dma_beg::W`](W) writer structure
        impl crate::Writable for DMA_BEG_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets DMA_BEG to value 0
        impl crate::Resettable for DMA_BEG_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///DMA_END (rw) register accessor: RW, SPI0 DMA end address
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`dma_end::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dma_end::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@dma_end`]
    ///module
    pub type DMA_END = crate::Reg<dma_end::DMA_END_SPEC>;
    ///RW, SPI0 DMA end address
    pub mod dma_end {
        ///Register `DMA_END` reader
        pub type R = crate::R<DMA_END_SPEC>;
        ///Register `DMA_END` writer
        pub type W = crate::W<DMA_END_SPEC>;
        ///Field `DMA_END` reader - RW, SPI0 DMA end address
        pub type DMA_END_R = crate::FieldReader<u16>;
        ///Field `DMA_END` writer - RW, SPI0 DMA end address
        pub type DMA_END_W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            ///Bits 0:15 - RW, SPI0 DMA end address
            #[inline(always)]
            pub fn dma_end(&self) -> DMA_END_R {
                DMA_END_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - RW, SPI0 DMA end address
            #[inline(always)]
            #[must_use]
            pub fn dma_end(&mut self) -> DMA_END_W<DMA_END_SPEC> {
                DMA_END_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW, SPI0 DMA end address
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`dma_end::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dma_end::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct DMA_END_SPEC;
        impl crate::RegisterSpec for DMA_END_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`dma_end::R`](R) reader structure
        impl crate::Readable for DMA_END_SPEC {}
        ///`write(|w| ..)` method takes [`dma_end::W`](W) writer structure
        impl crate::Writable for DMA_END_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets DMA_END to value 0
        impl crate::Resettable for DMA_END_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
}
///PWMx register
pub struct PWMX {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for PWMX {}
impl PWMX {
    ///Pointer to the register block
    pub const PTR: *const pwmx::RegisterBlock = 0x4000_5000 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const pwmx::RegisterBlock {
        Self::PTR
    }
    /// Steal an instance of this peripheral
    ///
    /// # Safety
    ///
    /// Ensure that the new instance of the peripheral cannot be used in a way
    /// that may race with any existing instances, for example by only
    /// accessing read-only or write-only registers, or by consuming the
    /// original peripheral and using critical sections to coordinate
    /// access between multiple new instances.
    ///
    /// Additionally, other software such as HALs may rely on only one
    /// peripheral instance existing to ensure memory safety; ensure
    /// no stolen instances are passed to such software.
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for PWMX {
    type Target = pwmx::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for PWMX {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("PWMX").finish()
    }
}
///PWMx register
pub mod pwmx {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        pwm_out_en: PWM_OUT_EN,
        pwm_polar: PWM_POLAR,
        pwm_config: PWM_CONFIG,
        pwm_clock_div: PWM_CLOCK_DIV,
        pwm4_data: PWM4_DATA,
        pwm5_data: PWM5_DATA,
        pwm6_data: PWM6_DATA,
        pwm7_data: PWM7_DATA,
        pwm8_data: PWM8_DATA,
        pwm9_data: PWM9_DATA,
        pwm10_data: PWM10_DATA,
        pwm11_data: PWM11_DATA,
        pwm_int_ctrl: PWM_INT_CTRL,
    }
    impl RegisterBlock {
        ///0x00 - RW, PWM output enable control
        #[inline(always)]
        pub const fn pwm_out_en(&self) -> &PWM_OUT_EN {
            &self.pwm_out_en
        }
        ///0x01 - RW, PWM output polarity control
        #[inline(always)]
        pub const fn pwm_polar(&self) -> &PWM_POLAR {
            &self.pwm_polar
        }
        ///0x02 - RW, PWM configuration
        #[inline(always)]
        pub const fn pwm_config(&self) -> &PWM_CONFIG {
            &self.pwm_config
        }
        ///0x03 - RW, PWM clock divisor
        #[inline(always)]
        pub const fn pwm_clock_div(&self) -> &PWM_CLOCK_DIV {
            &self.pwm_clock_div
        }
        ///0x04 - RW, PWM4 data holding
        #[inline(always)]
        pub const fn pwm4_data(&self) -> &PWM4_DATA {
            &self.pwm4_data
        }
        ///0x05 - RW, PWM5 data holding
        #[inline(always)]
        pub const fn pwm5_data(&self) -> &PWM5_DATA {
            &self.pwm5_data
        }
        ///0x06 - RW, PWM6 data holding
        #[inline(always)]
        pub const fn pwm6_data(&self) -> &PWM6_DATA {
            &self.pwm6_data
        }
        ///0x07 - RW, PWM7 data holding
        #[inline(always)]
        pub const fn pwm7_data(&self) -> &PWM7_DATA {
            &self.pwm7_data
        }
        ///0x08 - RW, PWM8 data holding
        #[inline(always)]
        pub const fn pwm8_data(&self) -> &PWM8_DATA {
            &self.pwm8_data
        }
        ///0x09 - RW, PWM9 data holding
        #[inline(always)]
        pub const fn pwm9_data(&self) -> &PWM9_DATA {
            &self.pwm9_data
        }
        ///0x0a - RW, PWM10 data holding
        #[inline(always)]
        pub const fn pwm10_data(&self) -> &PWM10_DATA {
            &self.pwm10_data
        }
        ///0x0b - RW, PWM11 data holding
        #[inline(always)]
        pub const fn pwm11_data(&self) -> &PWM11_DATA {
            &self.pwm11_data
        }
        ///0x0c - RW, PWM interrupt control
        #[inline(always)]
        pub const fn pwm_int_ctrl(&self) -> &PWM_INT_CTRL {
            &self.pwm_int_ctrl
        }
    }
    ///PWM_OUT_EN (rw) register accessor: RW, PWM output enable control
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`pwm_out_en::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pwm_out_en::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@pwm_out_en`]
    ///module
    pub type PWM_OUT_EN = crate::Reg<pwm_out_en::PWM_OUT_EN_SPEC>;
    ///RW, PWM output enable control
    pub mod pwm_out_en {
        ///Register `PWM_OUT_EN` reader
        pub type R = crate::R<PWM_OUT_EN_SPEC>;
        ///Register `PWM_OUT_EN` writer
        pub type W = crate::W<PWM_OUT_EN_SPEC>;
        ///Field `PWM4_OUT_EN` reader - RW, PWM4 output enable
        pub type PWM4_OUT_EN_R = crate::BitReader;
        ///Field `PWM4_OUT_EN` writer - RW, PWM4 output enable
        pub type PWM4_OUT_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PWM5_OUT_EN` reader - RW, PWM5 output enable
        pub type PWM5_OUT_EN_R = crate::BitReader;
        ///Field `PWM5_OUT_EN` writer - RW, PWM5 output enable
        pub type PWM5_OUT_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PWM6_OUT_EN` reader - RW, PWM6 output enable
        pub type PWM6_OUT_EN_R = crate::BitReader;
        ///Field `PWM6_OUT_EN` writer - RW, PWM6 output enable
        pub type PWM6_OUT_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PWM7_OUT_EN` reader - RW, PWM7 output enable
        pub type PWM7_OUT_EN_R = crate::BitReader;
        ///Field `PWM7_OUT_EN` writer - RW, PWM7 output enable
        pub type PWM7_OUT_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PWM8_OUT_EN` reader - RW, PWM8 output enable
        pub type PWM8_OUT_EN_R = crate::BitReader;
        ///Field `PWM8_OUT_EN` writer - RW, PWM8 output enable
        pub type PWM8_OUT_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PWM9_OUT_EN` reader - RW, PWM9 output enable
        pub type PWM9_OUT_EN_R = crate::BitReader;
        ///Field `PWM9_OUT_EN` writer - RW, PWM9 output enable
        pub type PWM9_OUT_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PWM10_OUT_EN` reader - RW, PWM10 output enable
        pub type PWM10_OUT_EN_R = crate::BitReader;
        ///Field `PWM10_OUT_EN` writer - RW, PWM10 output enable
        pub type PWM10_OUT_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PWM11_OUT_EN` reader - RW, PWM11 output enable
        pub type PWM11_OUT_EN_R = crate::BitReader;
        ///Field `PWM11_OUT_EN` writer - RW, PWM11 output enable
        pub type PWM11_OUT_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - RW, PWM4 output enable
            #[inline(always)]
            pub fn pwm4_out_en(&self) -> PWM4_OUT_EN_R {
                PWM4_OUT_EN_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RW, PWM5 output enable
            #[inline(always)]
            pub fn pwm5_out_en(&self) -> PWM5_OUT_EN_R {
                PWM5_OUT_EN_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RW, PWM6 output enable
            #[inline(always)]
            pub fn pwm6_out_en(&self) -> PWM6_OUT_EN_R {
                PWM6_OUT_EN_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RW, PWM7 output enable
            #[inline(always)]
            pub fn pwm7_out_en(&self) -> PWM7_OUT_EN_R {
                PWM7_OUT_EN_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RW, PWM8 output enable
            #[inline(always)]
            pub fn pwm8_out_en(&self) -> PWM8_OUT_EN_R {
                PWM8_OUT_EN_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - RW, PWM9 output enable
            #[inline(always)]
            pub fn pwm9_out_en(&self) -> PWM9_OUT_EN_R {
                PWM9_OUT_EN_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - RW, PWM10 output enable
            #[inline(always)]
            pub fn pwm10_out_en(&self) -> PWM10_OUT_EN_R {
                PWM10_OUT_EN_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - RW, PWM11 output enable
            #[inline(always)]
            pub fn pwm11_out_en(&self) -> PWM11_OUT_EN_R {
                PWM11_OUT_EN_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RW, PWM4 output enable
            #[inline(always)]
            #[must_use]
            pub fn pwm4_out_en(&mut self) -> PWM4_OUT_EN_W<PWM_OUT_EN_SPEC> {
                PWM4_OUT_EN_W::new(self, 0)
            }
            ///Bit 1 - RW, PWM5 output enable
            #[inline(always)]
            #[must_use]
            pub fn pwm5_out_en(&mut self) -> PWM5_OUT_EN_W<PWM_OUT_EN_SPEC> {
                PWM5_OUT_EN_W::new(self, 1)
            }
            ///Bit 2 - RW, PWM6 output enable
            #[inline(always)]
            #[must_use]
            pub fn pwm6_out_en(&mut self) -> PWM6_OUT_EN_W<PWM_OUT_EN_SPEC> {
                PWM6_OUT_EN_W::new(self, 2)
            }
            ///Bit 3 - RW, PWM7 output enable
            #[inline(always)]
            #[must_use]
            pub fn pwm7_out_en(&mut self) -> PWM7_OUT_EN_W<PWM_OUT_EN_SPEC> {
                PWM7_OUT_EN_W::new(self, 3)
            }
            ///Bit 4 - RW, PWM8 output enable
            #[inline(always)]
            #[must_use]
            pub fn pwm8_out_en(&mut self) -> PWM8_OUT_EN_W<PWM_OUT_EN_SPEC> {
                PWM8_OUT_EN_W::new(self, 4)
            }
            ///Bit 5 - RW, PWM9 output enable
            #[inline(always)]
            #[must_use]
            pub fn pwm9_out_en(&mut self) -> PWM9_OUT_EN_W<PWM_OUT_EN_SPEC> {
                PWM9_OUT_EN_W::new(self, 5)
            }
            ///Bit 6 - RW, PWM10 output enable
            #[inline(always)]
            #[must_use]
            pub fn pwm10_out_en(&mut self) -> PWM10_OUT_EN_W<PWM_OUT_EN_SPEC> {
                PWM10_OUT_EN_W::new(self, 6)
            }
            ///Bit 7 - RW, PWM11 output enable
            #[inline(always)]
            #[must_use]
            pub fn pwm11_out_en(&mut self) -> PWM11_OUT_EN_W<PWM_OUT_EN_SPEC> {
                PWM11_OUT_EN_W::new(self, 7)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW, PWM output enable control
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`pwm_out_en::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pwm_out_en::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct PWM_OUT_EN_SPEC;
        impl crate::RegisterSpec for PWM_OUT_EN_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`pwm_out_en::R`](R) reader structure
        impl crate::Readable for PWM_OUT_EN_SPEC {}
        ///`write(|w| ..)` method takes [`pwm_out_en::W`](W) writer structure
        impl crate::Writable for PWM_OUT_EN_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets PWM_OUT_EN to value 0
        impl crate::Resettable for PWM_OUT_EN_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///PWM_POLAR (rw) register accessor: RW, PWM output polarity control
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`pwm_polar::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pwm_polar::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@pwm_polar`]
    ///module
    pub type PWM_POLAR = crate::Reg<pwm_polar::PWM_POLAR_SPEC>;
    ///RW, PWM output polarity control
    pub mod pwm_polar {
        ///Register `PWM_POLAR` reader
        pub type R = crate::R<PWM_POLAR_SPEC>;
        ///Register `PWM_POLAR` writer
        pub type W = crate::W<PWM_POLAR_SPEC>;
        ///Field `PWM4_POLAR` reader - RW, PWM4 output polarity: 0=default low and high action, 1=default high and low action
        pub type PWM4_POLAR_R = crate::BitReader;
        ///Field `PWM4_POLAR` writer - RW, PWM4 output polarity: 0=default low and high action, 1=default high and low action
        pub type PWM4_POLAR_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PWM5_POLAR` reader - RW, PWM5 output polarity: 0=default low and high action, 1=default high and low action
        pub type PWM5_POLAR_R = crate::BitReader;
        ///Field `PWM5_POLAR` writer - RW, PWM5 output polarity: 0=default low and high action, 1=default high and low action
        pub type PWM5_POLAR_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PWM6_POLAR` reader - RW, PWM6 output polarity: 0=default low and high action, 1=default high and low action
        pub type PWM6_POLAR_R = crate::BitReader;
        ///Field `PWM6_POLAR` writer - RW, PWM6 output polarity: 0=default low and high action, 1=default high and low action
        pub type PWM6_POLAR_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PWM7_POLAR` reader - RW, PWM7 output polarity: 0=default low and high action, 1=default high and low action
        pub type PWM7_POLAR_R = crate::BitReader;
        ///Field `PWM7_POLAR` writer - RW, PWM7 output polarity: 0=default low and high action, 1=default high and low action
        pub type PWM7_POLAR_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PWM8_POLAR` reader - RW, PWM8 output polarity: 0=default low and high action, 1=default high and low action
        pub type PWM8_POLAR_R = crate::BitReader;
        ///Field `PWM8_POLAR` writer - RW, PWM8 output polarity: 0=default low and high action, 1=default high and low action
        pub type PWM8_POLAR_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PWM9_POLAR` reader - RW, PWM9 output polarity: 0=default low and high action, 1=default high and low action
        pub type PWM9_POLAR_R = crate::BitReader;
        ///Field `PWM9_POLAR` writer - RW, PWM9 output polarity: 0=default low and high action, 1=default high and low action
        pub type PWM9_POLAR_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PWM10_POLAR` reader - RW, PWM10 output polarity: 0=default low and high action, 1=default high and low action
        pub type PWM10_POLAR_R = crate::BitReader;
        ///Field `PWM10_POLAR` writer - RW, PWM10 output polarity: 0=default low and high action, 1=default high and low action
        pub type PWM10_POLAR_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PWM11_POLAR` reader - RW, PWM11 output polarity: 0=default low and high action, 1=default high and low action
        pub type PWM11_POLAR_R = crate::BitReader;
        ///Field `PWM11_POLAR` writer - RW, PWM11 output polarity: 0=default low and high action, 1=default high and low action
        pub type PWM11_POLAR_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - RW, PWM4 output polarity: 0=default low and high action, 1=default high and low action
            #[inline(always)]
            pub fn pwm4_polar(&self) -> PWM4_POLAR_R {
                PWM4_POLAR_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RW, PWM5 output polarity: 0=default low and high action, 1=default high and low action
            #[inline(always)]
            pub fn pwm5_polar(&self) -> PWM5_POLAR_R {
                PWM5_POLAR_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RW, PWM6 output polarity: 0=default low and high action, 1=default high and low action
            #[inline(always)]
            pub fn pwm6_polar(&self) -> PWM6_POLAR_R {
                PWM6_POLAR_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RW, PWM7 output polarity: 0=default low and high action, 1=default high and low action
            #[inline(always)]
            pub fn pwm7_polar(&self) -> PWM7_POLAR_R {
                PWM7_POLAR_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RW, PWM8 output polarity: 0=default low and high action, 1=default high and low action
            #[inline(always)]
            pub fn pwm8_polar(&self) -> PWM8_POLAR_R {
                PWM8_POLAR_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - RW, PWM9 output polarity: 0=default low and high action, 1=default high and low action
            #[inline(always)]
            pub fn pwm9_polar(&self) -> PWM9_POLAR_R {
                PWM9_POLAR_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - RW, PWM10 output polarity: 0=default low and high action, 1=default high and low action
            #[inline(always)]
            pub fn pwm10_polar(&self) -> PWM10_POLAR_R {
                PWM10_POLAR_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - RW, PWM11 output polarity: 0=default low and high action, 1=default high and low action
            #[inline(always)]
            pub fn pwm11_polar(&self) -> PWM11_POLAR_R {
                PWM11_POLAR_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RW, PWM4 output polarity: 0=default low and high action, 1=default high and low action
            #[inline(always)]
            #[must_use]
            pub fn pwm4_polar(&mut self) -> PWM4_POLAR_W<PWM_POLAR_SPEC> {
                PWM4_POLAR_W::new(self, 0)
            }
            ///Bit 1 - RW, PWM5 output polarity: 0=default low and high action, 1=default high and low action
            #[inline(always)]
            #[must_use]
            pub fn pwm5_polar(&mut self) -> PWM5_POLAR_W<PWM_POLAR_SPEC> {
                PWM5_POLAR_W::new(self, 1)
            }
            ///Bit 2 - RW, PWM6 output polarity: 0=default low and high action, 1=default high and low action
            #[inline(always)]
            #[must_use]
            pub fn pwm6_polar(&mut self) -> PWM6_POLAR_W<PWM_POLAR_SPEC> {
                PWM6_POLAR_W::new(self, 2)
            }
            ///Bit 3 - RW, PWM7 output polarity: 0=default low and high action, 1=default high and low action
            #[inline(always)]
            #[must_use]
            pub fn pwm7_polar(&mut self) -> PWM7_POLAR_W<PWM_POLAR_SPEC> {
                PWM7_POLAR_W::new(self, 3)
            }
            ///Bit 4 - RW, PWM8 output polarity: 0=default low and high action, 1=default high and low action
            #[inline(always)]
            #[must_use]
            pub fn pwm8_polar(&mut self) -> PWM8_POLAR_W<PWM_POLAR_SPEC> {
                PWM8_POLAR_W::new(self, 4)
            }
            ///Bit 5 - RW, PWM9 output polarity: 0=default low and high action, 1=default high and low action
            #[inline(always)]
            #[must_use]
            pub fn pwm9_polar(&mut self) -> PWM9_POLAR_W<PWM_POLAR_SPEC> {
                PWM9_POLAR_W::new(self, 5)
            }
            ///Bit 6 - RW, PWM10 output polarity: 0=default low and high action, 1=default high and low action
            #[inline(always)]
            #[must_use]
            pub fn pwm10_polar(&mut self) -> PWM10_POLAR_W<PWM_POLAR_SPEC> {
                PWM10_POLAR_W::new(self, 6)
            }
            ///Bit 7 - RW, PWM11 output polarity: 0=default low and high action, 1=default high and low action
            #[inline(always)]
            #[must_use]
            pub fn pwm11_polar(&mut self) -> PWM11_POLAR_W<PWM_POLAR_SPEC> {
                PWM11_POLAR_W::new(self, 7)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW, PWM output polarity control
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`pwm_polar::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pwm_polar::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct PWM_POLAR_SPEC;
        impl crate::RegisterSpec for PWM_POLAR_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`pwm_polar::R`](R) reader structure
        impl crate::Readable for PWM_POLAR_SPEC {}
        ///`write(|w| ..)` method takes [`pwm_polar::W`](W) writer structure
        impl crate::Writable for PWM_POLAR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets PWM_POLAR to value 0
        impl crate::Resettable for PWM_POLAR_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///PWM_CONFIG (rw) register accessor: RW, PWM configuration
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`pwm_config::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pwm_config::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@pwm_config`]
    ///module
    pub type PWM_CONFIG = crate::Reg<pwm_config::PWM_CONFIG_SPEC>;
    ///RW, PWM configuration
    pub mod pwm_config {
        ///Register `PWM_CONFIG` reader
        pub type R = crate::R<PWM_CONFIG_SPEC>;
        ///Register `PWM_CONFIG` writer
        pub type W = crate::W<PWM_CONFIG_SPEC>;
        ///Field `PWM_CYCLE_SEL` reader - RW, PWM cycle selection: 0=256;128;64;32 clocks, 1=255;127;63;31 clocks
        pub type PWM_CYCLE_SEL_R = crate::BitReader;
        ///Field `PWM_CYCLE_SEL` writer - RW, PWM cycle selection: 0=256;128;64;32 clocks, 1=255;127;63;31 clocks
        pub type PWM_CYCLE_SEL_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PWM_STAG_ST` reader - RO, PWM stagger cycle status
        pub type PWM_STAG_ST_R = crate::BitReader;
        ///Field `PWM_CYC_MOD` reader - RW, PWM data width mode: 00=8 bits data, 01=7 bits data, 10=6 bits data, 11=5 bits data
        pub type PWM_CYC_MOD_R = crate::FieldReader;
        ///Field `PWM_CYC_MOD` writer - RW, PWM data width mode: 00=8 bits data, 01=7 bits data, 10=6 bits data, 11=5 bits data
        pub type PWM_CYC_MOD_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `PWM4_5_STAG_EN` reader - RW, PWM4/5 stagger output enable: 0=independent output, 1=stagger output
        pub type PWM4_5_STAG_EN_R = crate::BitReader;
        ///Field `PWM4_5_STAG_EN` writer - RW, PWM4/5 stagger output enable: 0=independent output, 1=stagger output
        pub type PWM4_5_STAG_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PWM6_7_STAG_EN` reader - RW, PWM6/7 stagger output enable: 0=independent output, 1=stagger output
        pub type PWM6_7_STAG_EN_R = crate::BitReader;
        ///Field `PWM6_7_STAG_EN` writer - RW, PWM6/7 stagger output enable: 0=independent output, 1=stagger output
        pub type PWM6_7_STAG_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PWM8_9_STAG_EN` reader - RW, PWM8/9 stagger output enable: 0=independent output, 1=stagger output
        pub type PWM8_9_STAG_EN_R = crate::BitReader;
        ///Field `PWM8_9_STAG_EN` writer - RW, PWM8/9 stagger output enable: 0=independent output, 1=stagger output
        pub type PWM8_9_STAG_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PWM10_11_STAG_EN` reader - RW, PWM10/11 stagger output enable: 0=independent output, 1=stagger output
        pub type PWM10_11_STAG_EN_R = crate::BitReader;
        ///Field `PWM10_11_STAG_EN` writer - RW, PWM10/11 stagger output enable: 0=independent output, 1=stagger output
        pub type PWM10_11_STAG_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - RW, PWM cycle selection: 0=256;128;64;32 clocks, 1=255;127;63;31 clocks
            #[inline(always)]
            pub fn pwm_cycle_sel(&self) -> PWM_CYCLE_SEL_R {
                PWM_CYCLE_SEL_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RO, PWM stagger cycle status
            #[inline(always)]
            pub fn pwm_stag_st(&self) -> PWM_STAG_ST_R {
                PWM_STAG_ST_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bits 2:3 - RW, PWM data width mode: 00=8 bits data, 01=7 bits data, 10=6 bits data, 11=5 bits data
            #[inline(always)]
            pub fn pwm_cyc_mod(&self) -> PWM_CYC_MOD_R {
                PWM_CYC_MOD_R::new((self.bits >> 2) & 3)
            }
            ///Bit 4 - RW, PWM4/5 stagger output enable: 0=independent output, 1=stagger output
            #[inline(always)]
            pub fn pwm4_5_stag_en(&self) -> PWM4_5_STAG_EN_R {
                PWM4_5_STAG_EN_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - RW, PWM6/7 stagger output enable: 0=independent output, 1=stagger output
            #[inline(always)]
            pub fn pwm6_7_stag_en(&self) -> PWM6_7_STAG_EN_R {
                PWM6_7_STAG_EN_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - RW, PWM8/9 stagger output enable: 0=independent output, 1=stagger output
            #[inline(always)]
            pub fn pwm8_9_stag_en(&self) -> PWM8_9_STAG_EN_R {
                PWM8_9_STAG_EN_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - RW, PWM10/11 stagger output enable: 0=independent output, 1=stagger output
            #[inline(always)]
            pub fn pwm10_11_stag_en(&self) -> PWM10_11_STAG_EN_R {
                PWM10_11_STAG_EN_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RW, PWM cycle selection: 0=256;128;64;32 clocks, 1=255;127;63;31 clocks
            #[inline(always)]
            #[must_use]
            pub fn pwm_cycle_sel(&mut self) -> PWM_CYCLE_SEL_W<PWM_CONFIG_SPEC> {
                PWM_CYCLE_SEL_W::new(self, 0)
            }
            ///Bits 2:3 - RW, PWM data width mode: 00=8 bits data, 01=7 bits data, 10=6 bits data, 11=5 bits data
            #[inline(always)]
            #[must_use]
            pub fn pwm_cyc_mod(&mut self) -> PWM_CYC_MOD_W<PWM_CONFIG_SPEC> {
                PWM_CYC_MOD_W::new(self, 2)
            }
            ///Bit 4 - RW, PWM4/5 stagger output enable: 0=independent output, 1=stagger output
            #[inline(always)]
            #[must_use]
            pub fn pwm4_5_stag_en(&mut self) -> PWM4_5_STAG_EN_W<PWM_CONFIG_SPEC> {
                PWM4_5_STAG_EN_W::new(self, 4)
            }
            ///Bit 5 - RW, PWM6/7 stagger output enable: 0=independent output, 1=stagger output
            #[inline(always)]
            #[must_use]
            pub fn pwm6_7_stag_en(&mut self) -> PWM6_7_STAG_EN_W<PWM_CONFIG_SPEC> {
                PWM6_7_STAG_EN_W::new(self, 5)
            }
            ///Bit 6 - RW, PWM8/9 stagger output enable: 0=independent output, 1=stagger output
            #[inline(always)]
            #[must_use]
            pub fn pwm8_9_stag_en(&mut self) -> PWM8_9_STAG_EN_W<PWM_CONFIG_SPEC> {
                PWM8_9_STAG_EN_W::new(self, 6)
            }
            ///Bit 7 - RW, PWM10/11 stagger output enable: 0=independent output, 1=stagger output
            #[inline(always)]
            #[must_use]
            pub fn pwm10_11_stag_en(&mut self) -> PWM10_11_STAG_EN_W<PWM_CONFIG_SPEC> {
                PWM10_11_STAG_EN_W::new(self, 7)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW, PWM configuration
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`pwm_config::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pwm_config::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct PWM_CONFIG_SPEC;
        impl crate::RegisterSpec for PWM_CONFIG_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`pwm_config::R`](R) reader structure
        impl crate::Readable for PWM_CONFIG_SPEC {}
        ///`write(|w| ..)` method takes [`pwm_config::W`](W) writer structure
        impl crate::Writable for PWM_CONFIG_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets PWM_CONFIG to value 0
        impl crate::Resettable for PWM_CONFIG_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///PWM_CLOCK_DIV (rw) register accessor: RW, PWM clock divisor
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`pwm_clock_div::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pwm_clock_div::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@pwm_clock_div`]
    ///module
    pub type PWM_CLOCK_DIV = crate::Reg<pwm_clock_div::PWM_CLOCK_DIV_SPEC>;
    ///RW, PWM clock divisor
    pub mod pwm_clock_div {
        ///Register `PWM_CLOCK_DIV` reader
        pub type R = crate::R<PWM_CLOCK_DIV_SPEC>;
        ///Register `PWM_CLOCK_DIV` writer
        pub type W = crate::W<PWM_CLOCK_DIV_SPEC>;
        ///Field `PWM_CLOCK_DIV` reader - RW, PWM clock divisor
        pub type PWM_CLOCK_DIV_R = crate::FieldReader;
        ///Field `PWM_CLOCK_DIV` writer - RW, PWM clock divisor
        pub type PWM_CLOCK_DIV_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            ///Bits 0:7 - RW, PWM clock divisor
            #[inline(always)]
            pub fn pwm_clock_div(&self) -> PWM_CLOCK_DIV_R {
                PWM_CLOCK_DIV_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:7 - RW, PWM clock divisor
            #[inline(always)]
            #[must_use]
            pub fn pwm_clock_div(&mut self) -> PWM_CLOCK_DIV_W<PWM_CLOCK_DIV_SPEC> {
                PWM_CLOCK_DIV_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW, PWM clock divisor
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`pwm_clock_div::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pwm_clock_div::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct PWM_CLOCK_DIV_SPEC;
        impl crate::RegisterSpec for PWM_CLOCK_DIV_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`pwm_clock_div::R`](R) reader structure
        impl crate::Readable for PWM_CLOCK_DIV_SPEC {}
        ///`write(|w| ..)` method takes [`pwm_clock_div::W`](W) writer structure
        impl crate::Writable for PWM_CLOCK_DIV_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets PWM_CLOCK_DIV to value 0
        impl crate::Resettable for PWM_CLOCK_DIV_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///PWM4_DATA (rw) register accessor: RW, PWM4 data holding
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`pwm4_data::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pwm4_data::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@pwm4_data`]
    ///module
    pub type PWM4_DATA = crate::Reg<pwm4_data::PWM4_DATA_SPEC>;
    ///RW, PWM4 data holding
    pub mod pwm4_data {
        ///Register `PWM4_DATA` reader
        pub type R = crate::R<PWM4_DATA_SPEC>;
        ///Register `PWM4_DATA` writer
        pub type W = crate::W<PWM4_DATA_SPEC>;
        ///Field `PWM4_DATA` reader - RW, PWM4 data holding
        pub type PWM4_DATA_R = crate::FieldReader;
        ///Field `PWM4_DATA` writer - RW, PWM4 data holding
        pub type PWM4_DATA_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            ///Bits 0:7 - RW, PWM4 data holding
            #[inline(always)]
            pub fn pwm4_data(&self) -> PWM4_DATA_R {
                PWM4_DATA_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:7 - RW, PWM4 data holding
            #[inline(always)]
            #[must_use]
            pub fn pwm4_data(&mut self) -> PWM4_DATA_W<PWM4_DATA_SPEC> {
                PWM4_DATA_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW, PWM4 data holding
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`pwm4_data::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pwm4_data::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct PWM4_DATA_SPEC;
        impl crate::RegisterSpec for PWM4_DATA_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`pwm4_data::R`](R) reader structure
        impl crate::Readable for PWM4_DATA_SPEC {}
        ///`write(|w| ..)` method takes [`pwm4_data::W`](W) writer structure
        impl crate::Writable for PWM4_DATA_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets PWM4_DATA to value 0
        impl crate::Resettable for PWM4_DATA_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///PWM5_DATA (rw) register accessor: RW, PWM5 data holding
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`pwm5_data::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pwm5_data::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@pwm5_data`]
    ///module
    pub type PWM5_DATA = crate::Reg<pwm5_data::PWM5_DATA_SPEC>;
    ///RW, PWM5 data holding
    pub mod pwm5_data {
        ///Register `PWM5_DATA` reader
        pub type R = crate::R<PWM5_DATA_SPEC>;
        ///Register `PWM5_DATA` writer
        pub type W = crate::W<PWM5_DATA_SPEC>;
        ///Field `PWM5_DATA` reader - RW, PWM5 data holding
        pub type PWM5_DATA_R = crate::FieldReader;
        ///Field `PWM5_DATA` writer - RW, PWM5 data holding
        pub type PWM5_DATA_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            ///Bits 0:7 - RW, PWM5 data holding
            #[inline(always)]
            pub fn pwm5_data(&self) -> PWM5_DATA_R {
                PWM5_DATA_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:7 - RW, PWM5 data holding
            #[inline(always)]
            #[must_use]
            pub fn pwm5_data(&mut self) -> PWM5_DATA_W<PWM5_DATA_SPEC> {
                PWM5_DATA_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW, PWM5 data holding
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`pwm5_data::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pwm5_data::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct PWM5_DATA_SPEC;
        impl crate::RegisterSpec for PWM5_DATA_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`pwm5_data::R`](R) reader structure
        impl crate::Readable for PWM5_DATA_SPEC {}
        ///`write(|w| ..)` method takes [`pwm5_data::W`](W) writer structure
        impl crate::Writable for PWM5_DATA_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets PWM5_DATA to value 0
        impl crate::Resettable for PWM5_DATA_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///PWM6_DATA (rw) register accessor: RW, PWM6 data holding
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`pwm6_data::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pwm6_data::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@pwm6_data`]
    ///module
    pub type PWM6_DATA = crate::Reg<pwm6_data::PWM6_DATA_SPEC>;
    ///RW, PWM6 data holding
    pub mod pwm6_data {
        ///Register `PWM6_DATA` reader
        pub type R = crate::R<PWM6_DATA_SPEC>;
        ///Register `PWM6_DATA` writer
        pub type W = crate::W<PWM6_DATA_SPEC>;
        ///Field `PWM6_DATA` reader - RW, PWM6 data holding
        pub type PWM6_DATA_R = crate::FieldReader;
        ///Field `PWM6_DATA` writer - RW, PWM6 data holding
        pub type PWM6_DATA_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            ///Bits 0:7 - RW, PWM6 data holding
            #[inline(always)]
            pub fn pwm6_data(&self) -> PWM6_DATA_R {
                PWM6_DATA_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:7 - RW, PWM6 data holding
            #[inline(always)]
            #[must_use]
            pub fn pwm6_data(&mut self) -> PWM6_DATA_W<PWM6_DATA_SPEC> {
                PWM6_DATA_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW, PWM6 data holding
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`pwm6_data::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pwm6_data::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct PWM6_DATA_SPEC;
        impl crate::RegisterSpec for PWM6_DATA_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`pwm6_data::R`](R) reader structure
        impl crate::Readable for PWM6_DATA_SPEC {}
        ///`write(|w| ..)` method takes [`pwm6_data::W`](W) writer structure
        impl crate::Writable for PWM6_DATA_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets PWM6_DATA to value 0
        impl crate::Resettable for PWM6_DATA_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///PWM7_DATA (rw) register accessor: RW, PWM7 data holding
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`pwm7_data::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pwm7_data::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@pwm7_data`]
    ///module
    pub type PWM7_DATA = crate::Reg<pwm7_data::PWM7_DATA_SPEC>;
    ///RW, PWM7 data holding
    pub mod pwm7_data {
        ///Register `PWM7_DATA` reader
        pub type R = crate::R<PWM7_DATA_SPEC>;
        ///Register `PWM7_DATA` writer
        pub type W = crate::W<PWM7_DATA_SPEC>;
        ///Field `PWM7_DATA` reader - RW, PWM7 data holding
        pub type PWM7_DATA_R = crate::FieldReader;
        ///Field `PWM7_DATA` writer - RW, PWM7 data holding
        pub type PWM7_DATA_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            ///Bits 0:7 - RW, PWM7 data holding
            #[inline(always)]
            pub fn pwm7_data(&self) -> PWM7_DATA_R {
                PWM7_DATA_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:7 - RW, PWM7 data holding
            #[inline(always)]
            #[must_use]
            pub fn pwm7_data(&mut self) -> PWM7_DATA_W<PWM7_DATA_SPEC> {
                PWM7_DATA_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW, PWM7 data holding
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`pwm7_data::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pwm7_data::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct PWM7_DATA_SPEC;
        impl crate::RegisterSpec for PWM7_DATA_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`pwm7_data::R`](R) reader structure
        impl crate::Readable for PWM7_DATA_SPEC {}
        ///`write(|w| ..)` method takes [`pwm7_data::W`](W) writer structure
        impl crate::Writable for PWM7_DATA_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets PWM7_DATA to value 0
        impl crate::Resettable for PWM7_DATA_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///PWM8_DATA (rw) register accessor: RW, PWM8 data holding
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`pwm8_data::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pwm8_data::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@pwm8_data`]
    ///module
    pub type PWM8_DATA = crate::Reg<pwm8_data::PWM8_DATA_SPEC>;
    ///RW, PWM8 data holding
    pub mod pwm8_data {
        ///Register `PWM8_DATA` reader
        pub type R = crate::R<PWM8_DATA_SPEC>;
        ///Register `PWM8_DATA` writer
        pub type W = crate::W<PWM8_DATA_SPEC>;
        ///Field `PWM8_DATA` reader - RW, PWM8 data holding
        pub type PWM8_DATA_R = crate::FieldReader;
        ///Field `PWM8_DATA` writer - RW, PWM8 data holding
        pub type PWM8_DATA_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            ///Bits 0:7 - RW, PWM8 data holding
            #[inline(always)]
            pub fn pwm8_data(&self) -> PWM8_DATA_R {
                PWM8_DATA_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:7 - RW, PWM8 data holding
            #[inline(always)]
            #[must_use]
            pub fn pwm8_data(&mut self) -> PWM8_DATA_W<PWM8_DATA_SPEC> {
                PWM8_DATA_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW, PWM8 data holding
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`pwm8_data::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pwm8_data::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct PWM8_DATA_SPEC;
        impl crate::RegisterSpec for PWM8_DATA_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`pwm8_data::R`](R) reader structure
        impl crate::Readable for PWM8_DATA_SPEC {}
        ///`write(|w| ..)` method takes [`pwm8_data::W`](W) writer structure
        impl crate::Writable for PWM8_DATA_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets PWM8_DATA to value 0
        impl crate::Resettable for PWM8_DATA_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///PWM9_DATA (rw) register accessor: RW, PWM9 data holding
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`pwm9_data::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pwm9_data::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@pwm9_data`]
    ///module
    pub type PWM9_DATA = crate::Reg<pwm9_data::PWM9_DATA_SPEC>;
    ///RW, PWM9 data holding
    pub mod pwm9_data {
        ///Register `PWM9_DATA` reader
        pub type R = crate::R<PWM9_DATA_SPEC>;
        ///Register `PWM9_DATA` writer
        pub type W = crate::W<PWM9_DATA_SPEC>;
        ///Field `PWM9_DATA` reader - RW, PWM9 data holding
        pub type PWM9_DATA_R = crate::FieldReader;
        ///Field `PWM9_DATA` writer - RW, PWM9 data holding
        pub type PWM9_DATA_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            ///Bits 0:7 - RW, PWM9 data holding
            #[inline(always)]
            pub fn pwm9_data(&self) -> PWM9_DATA_R {
                PWM9_DATA_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:7 - RW, PWM9 data holding
            #[inline(always)]
            #[must_use]
            pub fn pwm9_data(&mut self) -> PWM9_DATA_W<PWM9_DATA_SPEC> {
                PWM9_DATA_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW, PWM9 data holding
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`pwm9_data::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pwm9_data::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct PWM9_DATA_SPEC;
        impl crate::RegisterSpec for PWM9_DATA_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`pwm9_data::R`](R) reader structure
        impl crate::Readable for PWM9_DATA_SPEC {}
        ///`write(|w| ..)` method takes [`pwm9_data::W`](W) writer structure
        impl crate::Writable for PWM9_DATA_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets PWM9_DATA to value 0
        impl crate::Resettable for PWM9_DATA_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///PWM10_DATA (rw) register accessor: RW, PWM10 data holding
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`pwm10_data::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pwm10_data::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@pwm10_data`]
    ///module
    pub type PWM10_DATA = crate::Reg<pwm10_data::PWM10_DATA_SPEC>;
    ///RW, PWM10 data holding
    pub mod pwm10_data {
        ///Register `PWM10_DATA` reader
        pub type R = crate::R<PWM10_DATA_SPEC>;
        ///Register `PWM10_DATA` writer
        pub type W = crate::W<PWM10_DATA_SPEC>;
        ///Field `PWM10_DATA` reader - RW, PWM10 data holding
        pub type PWM10_DATA_R = crate::FieldReader;
        ///Field `PWM10_DATA` writer - RW, PWM10 data holding
        pub type PWM10_DATA_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            ///Bits 0:7 - RW, PWM10 data holding
            #[inline(always)]
            pub fn pwm10_data(&self) -> PWM10_DATA_R {
                PWM10_DATA_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:7 - RW, PWM10 data holding
            #[inline(always)]
            #[must_use]
            pub fn pwm10_data(&mut self) -> PWM10_DATA_W<PWM10_DATA_SPEC> {
                PWM10_DATA_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW, PWM10 data holding
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`pwm10_data::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pwm10_data::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct PWM10_DATA_SPEC;
        impl crate::RegisterSpec for PWM10_DATA_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`pwm10_data::R`](R) reader structure
        impl crate::Readable for PWM10_DATA_SPEC {}
        ///`write(|w| ..)` method takes [`pwm10_data::W`](W) writer structure
        impl crate::Writable for PWM10_DATA_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets PWM10_DATA to value 0
        impl crate::Resettable for PWM10_DATA_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///PWM11_DATA (rw) register accessor: RW, PWM11 data holding
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`pwm11_data::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pwm11_data::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@pwm11_data`]
    ///module
    pub type PWM11_DATA = crate::Reg<pwm11_data::PWM11_DATA_SPEC>;
    ///RW, PWM11 data holding
    pub mod pwm11_data {
        ///Register `PWM11_DATA` reader
        pub type R = crate::R<PWM11_DATA_SPEC>;
        ///Register `PWM11_DATA` writer
        pub type W = crate::W<PWM11_DATA_SPEC>;
        ///Field `PWM11_DATA` reader - RW, PWM11 data holding
        pub type PWM11_DATA_R = crate::FieldReader;
        ///Field `PWM11_DATA` writer - RW, PWM11 data holding
        pub type PWM11_DATA_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            ///Bits 0:7 - RW, PWM11 data holding
            #[inline(always)]
            pub fn pwm11_data(&self) -> PWM11_DATA_R {
                PWM11_DATA_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:7 - RW, PWM11 data holding
            #[inline(always)]
            #[must_use]
            pub fn pwm11_data(&mut self) -> PWM11_DATA_W<PWM11_DATA_SPEC> {
                PWM11_DATA_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW, PWM11 data holding
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`pwm11_data::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pwm11_data::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct PWM11_DATA_SPEC;
        impl crate::RegisterSpec for PWM11_DATA_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`pwm11_data::R`](R) reader structure
        impl crate::Readable for PWM11_DATA_SPEC {}
        ///`write(|w| ..)` method takes [`pwm11_data::W`](W) writer structure
        impl crate::Writable for PWM11_DATA_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets PWM11_DATA to value 0
        impl crate::Resettable for PWM11_DATA_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///PWM_INT_CTRL (rw) register accessor: RW, PWM interrupt control
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`pwm_int_ctrl::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pwm_int_ctrl::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@pwm_int_ctrl`]
    ///module
    pub type PWM_INT_CTRL = crate::Reg<pwm_int_ctrl::PWM_INT_CTRL_SPEC>;
    ///RW, PWM interrupt control
    pub mod pwm_int_ctrl {
        ///Register `PWM_INT_CTRL` reader
        pub type R = crate::R<PWM_INT_CTRL_SPEC>;
        ///Register `PWM_INT_CTRL` writer
        pub type W = crate::W<PWM_INT_CTRL_SPEC>;
        ///Field `PWM_IE_CYC` reader - RW, enable interrupt for PWM cycle end
        pub type PWM_IE_CYC_R = crate::BitReader;
        ///Field `PWM_IE_CYC` writer - RW, enable interrupt for PWM cycle end
        pub type PWM_IE_CYC_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PWM_CYC_PRE` reader - RW, select PWM cycle interrupt point
        pub type PWM_CYC_PRE_R = crate::BitReader;
        ///Field `PWM_CYC_PRE` writer - RW, select PWM cycle interrupt point
        pub type PWM_CYC_PRE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PWM_IF_CYC` reader - RW1, interrupt flag for PWM cycle end
        pub type PWM_IF_CYC_R = crate::BitReader;
        ///Field `PWM_IF_CYC` writer - RW1, interrupt flag for PWM cycle end
        pub type PWM_IF_CYC_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - RW, enable interrupt for PWM cycle end
            #[inline(always)]
            pub fn pwm_ie_cyc(&self) -> PWM_IE_CYC_R {
                PWM_IE_CYC_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RW, select PWM cycle interrupt point
            #[inline(always)]
            pub fn pwm_cyc_pre(&self) -> PWM_CYC_PRE_R {
                PWM_CYC_PRE_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 7 - RW1, interrupt flag for PWM cycle end
            #[inline(always)]
            pub fn pwm_if_cyc(&self) -> PWM_IF_CYC_R {
                PWM_IF_CYC_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RW, enable interrupt for PWM cycle end
            #[inline(always)]
            #[must_use]
            pub fn pwm_ie_cyc(&mut self) -> PWM_IE_CYC_W<PWM_INT_CTRL_SPEC> {
                PWM_IE_CYC_W::new(self, 0)
            }
            ///Bit 1 - RW, select PWM cycle interrupt point
            #[inline(always)]
            #[must_use]
            pub fn pwm_cyc_pre(&mut self) -> PWM_CYC_PRE_W<PWM_INT_CTRL_SPEC> {
                PWM_CYC_PRE_W::new(self, 1)
            }
            ///Bit 7 - RW1, interrupt flag for PWM cycle end
            #[inline(always)]
            #[must_use]
            pub fn pwm_if_cyc(&mut self) -> PWM_IF_CYC_W<PWM_INT_CTRL_SPEC> {
                PWM_IF_CYC_W::new(self, 7)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW, PWM interrupt control
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`pwm_int_ctrl::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pwm_int_ctrl::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct PWM_INT_CTRL_SPEC;
        impl crate::RegisterSpec for PWM_INT_CTRL_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`pwm_int_ctrl::R`](R) reader structure
        impl crate::Readable for PWM_INT_CTRL_SPEC {}
        ///`write(|w| ..)` method takes [`pwm_int_ctrl::W`](W) writer structure
        impl crate::Writable for PWM_INT_CTRL_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets PWM_INT_CTRL to value 0
        impl crate::Resettable for PWM_INT_CTRL_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
}
///USB register
pub struct USB {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for USB {}
impl USB {
    ///Pointer to the register block
    pub const PTR: *const usb::RegisterBlock = 0x4000_8000 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const usb::RegisterBlock {
        Self::PTR
    }
    /// Steal an instance of this peripheral
    ///
    /// # Safety
    ///
    /// Ensure that the new instance of the peripheral cannot be used in a way
    /// that may race with any existing instances, for example by only
    /// accessing read-only or write-only registers, or by consuming the
    /// original peripheral and using critical sections to coordinate
    /// access between multiple new instances.
    ///
    /// Additionally, other software such as HALs may rely on only one
    /// peripheral instance existing to ensure memory safety; ensure
    /// no stolen instances are passed to such software.
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for USB {
    type Target = usb::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for USB {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("USB").finish()
    }
}
///USB register
pub mod usb {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        usb_ctrl: USB_CTRL,
        udev_ctrl__r8_uhost_ctrl: UDEV_CTRL__R8_UHOST_CTRL,
        usb_int_en: USB_INT_EN,
        usb_dev_ad: USB_DEV_AD,
        _reserved4: [u8; 0x01],
        usb_mis_st: USB_MIS_ST,
        usb_int_fg: USB_INT_FG,
        usb_int_st: USB_INT_ST,
        usb_rx_len: USB_RX_LEN,
        _reserved8: [u8; 0x03],
        uep4_1_mod: UEP4_1_MOD,
        uep2_3_mod__r8_uh_ep_mod: UEP2_3_MOD__R8_UH_EP_MOD,
        _reserved10: [u8; 0x02],
        uep0_dma: UEP0_DMA,
        _reserved11: [u8; 0x02],
        uep1_dma: UEP1_DMA,
        _reserved12: [u8; 0x02],
        uep2_dma__r16_uh_rx_dma: UEP2_DMA__R16_UH_RX_DMA,
        _reserved13: [u8; 0x02],
        uep3_dma__r16_uh_tx_dma: UEP3_DMA__R16_UH_TX_DMA,
        _reserved14: [u8; 0x02],
        uep0_t_len: UEP0_T_LEN,
        _reserved15: [u8; 0x01],
        uep0_ctrl: UEP0_CTRL,
        _reserved16: [u8; 0x01],
        uep1_t_len: UEP1_T_LEN,
        _reserved17: [u8; 0x01],
        uep1_ctrl__r8_uh_setup: UEP1_CTRL__R8_UH_SETUP,
        _reserved18: [u8; 0x01],
        uep2_t_len_r8_uh_ep_pid: UEP2_T_LEN_R8_UH_EP_PID,
        _reserved19: [u8; 0x01],
        uep2_ctrl_r8_uh_rx_ctrl: UEP2_CTRL_R8_UH_RX_CTRL,
        _reserved20: [u8; 0x01],
        uep3_t_len__r8_uh_tx_len: UEP3_T_LEN__R8_UH_TX_LEN,
        _reserved21: [u8; 0x01],
        uep3_ctrl__r8_uh_tx_ctrl: UEP3_CTRL__R8_UH_TX_CTRL,
        _reserved22: [u8; 0x01],
        uep4_t_len: UEP4_T_LEN,
        _reserved23: [u8; 0x01],
        uep4_ctrl: UEP4_CTRL,
    }
    impl RegisterBlock {
        ///0x00 - USB base control
        #[inline(always)]
        pub const fn usb_ctrl(&self) -> &USB_CTRL {
            &self.usb_ctrl
        }
        ///0x01 - USB device physical prot control
        #[inline(always)]
        pub const fn udev_ctrl__r8_uhost_ctrl(&self) -> &UDEV_CTRL__R8_UHOST_CTRL {
            &self.udev_ctrl__r8_uhost_ctrl
        }
        ///0x02 - USB interrupt enable
        #[inline(always)]
        pub const fn usb_int_en(&self) -> &USB_INT_EN {
            &self.usb_int_en
        }
        ///0x03 - USB device address
        #[inline(always)]
        pub const fn usb_dev_ad(&self) -> &USB_DEV_AD {
            &self.usb_dev_ad
        }
        ///0x05 - USB miscellaneous status
        #[inline(always)]
        pub const fn usb_mis_st(&self) -> &USB_MIS_ST {
            &self.usb_mis_st
        }
        ///0x06 - USB interrupt flag
        #[inline(always)]
        pub const fn usb_int_fg(&self) -> &USB_INT_FG {
            &self.usb_int_fg
        }
        ///0x07 - USB interrupt status
        #[inline(always)]
        pub const fn usb_int_st(&self) -> &USB_INT_ST {
            &self.usb_int_st
        }
        ///0x08 - USB receiving length
        #[inline(always)]
        pub const fn usb_rx_len(&self) -> &USB_RX_LEN {
            &self.usb_rx_len
        }
        ///0x0c - endpoint 4/1 mode
        #[inline(always)]
        pub const fn uep4_1_mod(&self) -> &UEP4_1_MOD {
            &self.uep4_1_mod
        }
        ///0x0d - endpoint 2_3 mode;host endpoint mode
        #[inline(always)]
        pub const fn uep2_3_mod__r8_uh_ep_mod(&self) -> &UEP2_3_MOD__R8_UH_EP_MOD {
            &self.uep2_3_mod__r8_uh_ep_mod
        }
        ///0x10 - endpoint 0 DMA buffer address
        #[inline(always)]
        pub const fn uep0_dma(&self) -> &UEP0_DMA {
            &self.uep0_dma
        }
        ///0x14 - endpoint 1 DMA buffer address
        #[inline(always)]
        pub const fn uep1_dma(&self) -> &UEP1_DMA {
            &self.uep1_dma
        }
        ///0x18 - endpoint 2 DMA buffer address;host rx endpoint buffer high address
        #[inline(always)]
        pub const fn uep2_dma__r16_uh_rx_dma(&self) -> &UEP2_DMA__R16_UH_RX_DMA {
            &self.uep2_dma__r16_uh_rx_dma
        }
        ///0x1c - endpoint 3 DMA buffer address;host tx endpoint buffer high address
        #[inline(always)]
        pub const fn uep3_dma__r16_uh_tx_dma(&self) -> &UEP3_DMA__R16_UH_TX_DMA {
            &self.uep3_dma__r16_uh_tx_dma
        }
        ///0x20 - endpoint 0 transmittal length
        #[inline(always)]
        pub const fn uep0_t_len(&self) -> &UEP0_T_LEN {
            &self.uep0_t_len
        }
        ///0x22 - endpoint 0 control
        #[inline(always)]
        pub const fn uep0_ctrl(&self) -> &UEP0_CTRL {
            &self.uep0_ctrl
        }
        ///0x24 - endpoint 1 transmittal length
        #[inline(always)]
        pub const fn uep1_t_len(&self) -> &UEP1_T_LEN {
            &self.uep1_t_len
        }
        ///0x26 - endpoint 1 control;host aux setup
        #[inline(always)]
        pub const fn uep1_ctrl__r8_uh_setup(&self) -> &UEP1_CTRL__R8_UH_SETUP {
            &self.uep1_ctrl__r8_uh_setup
        }
        ///0x28 - endpoint 2 transmittal length;host endpoint and PID
        #[inline(always)]
        pub const fn uep2_t_len_r8_uh_ep_pid(&self) -> &UEP2_T_LEN_R8_UH_EP_PID {
            &self.uep2_t_len_r8_uh_ep_pid
        }
        ///0x2a - endpoint 2 control;host receiver endpoint control
        #[inline(always)]
        pub const fn uep2_ctrl_r8_uh_rx_ctrl(&self) -> &UEP2_CTRL_R8_UH_RX_CTRL {
            &self.uep2_ctrl_r8_uh_rx_ctrl
        }
        ///0x2c - endpoint 3 transmittal length;host transmittal endpoint transmittal length
        #[inline(always)]
        pub const fn uep3_t_len__r8_uh_tx_len(&self) -> &UEP3_T_LEN__R8_UH_TX_LEN {
            &self.uep3_t_len__r8_uh_tx_len
        }
        ///0x2e - endpoint 3 control;host transmittal endpoint control
        #[inline(always)]
        pub const fn uep3_ctrl__r8_uh_tx_ctrl(&self) -> &UEP3_CTRL__R8_UH_TX_CTRL {
            &self.uep3_ctrl__r8_uh_tx_ctrl
        }
        ///0x30 - endpoint 4 transmittal length
        #[inline(always)]
        pub const fn uep4_t_len(&self) -> &UEP4_T_LEN {
            &self.uep4_t_len
        }
        ///0x32 - endpoint 4 control
        #[inline(always)]
        pub const fn uep4_ctrl(&self) -> &UEP4_CTRL {
            &self.uep4_ctrl
        }
    }
    ///USB_CTRL (rw) register accessor: USB base control
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`usb_ctrl::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`usb_ctrl::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@usb_ctrl`]
    ///module
    pub type USB_CTRL = crate::Reg<usb_ctrl::USB_CTRL_SPEC>;
    ///USB base control
    pub mod usb_ctrl {
        ///Register `USB_CTRL` reader
        pub type R = crate::R<USB_CTRL_SPEC>;
        ///Register `USB_CTRL` writer
        pub type W = crate::W<USB_CTRL_SPEC>;
        ///Field `UC_DMA_EN` reader - DMA enable and DMA interrupt enable for USB
        pub type UC_DMA_EN_R = crate::BitReader;
        ///Field `UC_DMA_EN` writer - DMA enable and DMA interrupt enable for USB
        pub type UC_DMA_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UC_CLR_ALL` reader - force clear FIFO and count of USB
        pub type UC_CLR_ALL_R = crate::BitReader;
        ///Field `UC_CLR_ALL` writer - force clear FIFO and count of USB
        pub type UC_CLR_ALL_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UC_RESET_SIE` reader - force reset USB SIE, need software clear
        pub type UC_RESET_SIE_R = crate::BitReader;
        ///Field `UC_RESET_SIE` writer - force reset USB SIE, need software clear
        pub type UC_RESET_SIE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UC_INT_BUSY` reader - enable automatic responding busy for device mode or automatic pause for host mode during interrupt flag UIF_TRANSFER valid
        pub type UC_INT_BUSY_R = crate::BitReader;
        ///Field `UC_INT_BUSY` writer - enable automatic responding busy for device mode or automatic pause for host mode during interrupt flag UIF_TRANSFER valid
        pub type UC_INT_BUSY_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `MASK_UC_SYS_CTRL` reader - bit mask of USB system control
        pub type MASK_UC_SYS_CTRL_R = crate::FieldReader;
        ///Field `MASK_UC_SYS_CTRL` writer - bit mask of USB system control
        pub type MASK_UC_SYS_CTRL_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `UC_DEV_PU_EN` reader - USB device enable and internal pullup resistance enable
        pub type UC_DEV_PU_EN_R = crate::BitReader;
        ///Field `UC_DEV_PU_EN` writer - USB device enable and internal pullup resistance enable
        pub type UC_DEV_PU_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UC_LOW_SPEED` reader - enable USB low speed: 0=12Mbps, 1=1.5Mbps
        pub type UC_LOW_SPEED_R = crate::BitReader;
        ///Field `UC_LOW_SPEED` writer - enable USB low speed: 0=12Mbps, 1=1.5Mbps
        pub type UC_LOW_SPEED_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UC_HOST_MODE` reader - enable USB host mode: 0=device mode, 1=host mode
        pub type UC_HOST_MODE_R = crate::BitReader;
        ///Field `UC_HOST_MODE` writer - enable USB host mode: 0=device mode, 1=host mode
        pub type UC_HOST_MODE_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - DMA enable and DMA interrupt enable for USB
            #[inline(always)]
            pub fn uc_dma_en(&self) -> UC_DMA_EN_R {
                UC_DMA_EN_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - force clear FIFO and count of USB
            #[inline(always)]
            pub fn uc_clr_all(&self) -> UC_CLR_ALL_R {
                UC_CLR_ALL_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - force reset USB SIE, need software clear
            #[inline(always)]
            pub fn uc_reset_sie(&self) -> UC_RESET_SIE_R {
                UC_RESET_SIE_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - enable automatic responding busy for device mode or automatic pause for host mode during interrupt flag UIF_TRANSFER valid
            #[inline(always)]
            pub fn uc_int_busy(&self) -> UC_INT_BUSY_R {
                UC_INT_BUSY_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bits 4:5 - bit mask of USB system control
            #[inline(always)]
            pub fn mask_uc_sys_ctrl(&self) -> MASK_UC_SYS_CTRL_R {
                MASK_UC_SYS_CTRL_R::new((self.bits >> 4) & 3)
            }
            ///Bit 5 - USB device enable and internal pullup resistance enable
            #[inline(always)]
            pub fn uc_dev_pu_en(&self) -> UC_DEV_PU_EN_R {
                UC_DEV_PU_EN_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - enable USB low speed: 0=12Mbps, 1=1.5Mbps
            #[inline(always)]
            pub fn uc_low_speed(&self) -> UC_LOW_SPEED_R {
                UC_LOW_SPEED_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - enable USB host mode: 0=device mode, 1=host mode
            #[inline(always)]
            pub fn uc_host_mode(&self) -> UC_HOST_MODE_R {
                UC_HOST_MODE_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - DMA enable and DMA interrupt enable for USB
            #[inline(always)]
            #[must_use]
            pub fn uc_dma_en(&mut self) -> UC_DMA_EN_W<USB_CTRL_SPEC> {
                UC_DMA_EN_W::new(self, 0)
            }
            ///Bit 1 - force clear FIFO and count of USB
            #[inline(always)]
            #[must_use]
            pub fn uc_clr_all(&mut self) -> UC_CLR_ALL_W<USB_CTRL_SPEC> {
                UC_CLR_ALL_W::new(self, 1)
            }
            ///Bit 2 - force reset USB SIE, need software clear
            #[inline(always)]
            #[must_use]
            pub fn uc_reset_sie(&mut self) -> UC_RESET_SIE_W<USB_CTRL_SPEC> {
                UC_RESET_SIE_W::new(self, 2)
            }
            ///Bit 3 - enable automatic responding busy for device mode or automatic pause for host mode during interrupt flag UIF_TRANSFER valid
            #[inline(always)]
            #[must_use]
            pub fn uc_int_busy(&mut self) -> UC_INT_BUSY_W<USB_CTRL_SPEC> {
                UC_INT_BUSY_W::new(self, 3)
            }
            ///Bits 4:5 - bit mask of USB system control
            #[inline(always)]
            #[must_use]
            pub fn mask_uc_sys_ctrl(&mut self) -> MASK_UC_SYS_CTRL_W<USB_CTRL_SPEC> {
                MASK_UC_SYS_CTRL_W::new(self, 4)
            }
            ///Bit 5 - USB device enable and internal pullup resistance enable
            #[inline(always)]
            #[must_use]
            pub fn uc_dev_pu_en(&mut self) -> UC_DEV_PU_EN_W<USB_CTRL_SPEC> {
                UC_DEV_PU_EN_W::new(self, 5)
            }
            ///Bit 6 - enable USB low speed: 0=12Mbps, 1=1.5Mbps
            #[inline(always)]
            #[must_use]
            pub fn uc_low_speed(&mut self) -> UC_LOW_SPEED_W<USB_CTRL_SPEC> {
                UC_LOW_SPEED_W::new(self, 6)
            }
            ///Bit 7 - enable USB host mode: 0=device mode, 1=host mode
            #[inline(always)]
            #[must_use]
            pub fn uc_host_mode(&mut self) -> UC_HOST_MODE_W<USB_CTRL_SPEC> {
                UC_HOST_MODE_W::new(self, 7)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///USB base control
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`usb_ctrl::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`usb_ctrl::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct USB_CTRL_SPEC;
        impl crate::RegisterSpec for USB_CTRL_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`usb_ctrl::R`](R) reader structure
        impl crate::Readable for USB_CTRL_SPEC {}
        ///`write(|w| ..)` method takes [`usb_ctrl::W`](W) writer structure
        impl crate::Writable for USB_CTRL_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets USB_CTRL to value 0x06
        impl crate::Resettable for USB_CTRL_SPEC {
            const RESET_VALUE: u8 = 0x06;
        }
    }
    ///UDEV_CTRL__R8_UHOST_CTRL (rw) register accessor: USB device physical prot control
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`udev_ctrl__r8_uhost_ctrl::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`udev_ctrl__r8_uhost_ctrl::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@udev_ctrl__r8_uhost_ctrl`]
    ///module
    pub type UDEV_CTRL__R8_UHOST_CTRL =
        crate::Reg<udev_ctrl__r8_uhost_ctrl::UDEV_CTRL__R8_UHOST_CTRL_SPEC>;
    ///USB device physical prot control
    pub mod udev_ctrl__r8_uhost_ctrl {
        ///Register `UDEV_CTRL__R8_UHOST_CTRL` reader
        pub type R = crate::R<UDEV_CTRL__R8_UHOST_CTRL_SPEC>;
        ///Register `UDEV_CTRL__R8_UHOST_CTRL` writer
        pub type W = crate::W<UDEV_CTRL__R8_UHOST_CTRL_SPEC>;
        ///Field `UD_PORT_EN__RB_UH_PORT_EN` reader - enable USB physical port I-O: 0=disable, 1=enable;enable USB port: 0=disable, 1=enable port, automatic disabled if USB device detached
        pub type UD_PORT_EN__RB_UH_PORT_EN_R = crate::BitReader;
        ///Field `UD_PORT_EN__RB_UH_PORT_EN` writer - enable USB physical port I-O: 0=disable, 1=enable;enable USB port: 0=disable, 1=enable port, automatic disabled if USB device detached
        pub type UD_PORT_EN__RB_UH_PORT_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UD_GP_BIT__RB_UH_BUS_RESET` reader - general purpose bit;control USB bus reset: 0=normal, 1=force bus reset
        pub type UD_GP_BIT__RB_UH_BUS_RESET_R = crate::BitReader;
        ///Field `UD_GP_BIT__RB_UH_BUS_RESET` writer - general purpose bit;control USB bus reset: 0=normal, 1=force bus reset
        pub type UD_GP_BIT__RB_UH_BUS_RESET_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UD_LOW_SPEED__RB_UH_LOW_SPEED` reader - enable USB physical port low speed: 0=full speed, 1=low speed;enable USB port low speed: 0=full speed, 1=low speed
        pub type UD_LOW_SPEED__RB_UH_LOW_SPEED_R = crate::BitReader;
        ///Field `UD_LOW_SPEED__RB_UH_LOW_SPEED` writer - enable USB physical port low speed: 0=full speed, 1=low speed;enable USB port low speed: 0=full speed, 1=low speed
        pub type UD_LOW_SPEED__RB_UH_LOW_SPEED_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UD_DM_PIN__RB_UH_DM_PIN` reader - ReadOnly: indicate current UDM pin level
        pub type UD_DM_PIN__RB_UH_DM_PIN_R = crate::BitReader;
        ///Field `UD_DP_PIN__RB_UH_DP_PIN` reader - ReadOnly: indicate current UDP pin level
        pub type UD_DP_PIN__RB_UH_DP_PIN_R = crate::BitReader;
        ///Field `UD_PD_DIS__RB_UH_PD_DIS` reader - disable USB UDP-UDM pulldown resistance: 0=enable pulldown, 1=disable
        pub type UD_PD_DIS__RB_UH_PD_DIS_R = crate::BitReader;
        impl R {
            ///Bit 0 - enable USB physical port I-O: 0=disable, 1=enable;enable USB port: 0=disable, 1=enable port, automatic disabled if USB device detached
            #[inline(always)]
            pub fn ud_port_en__rb_uh_port_en(&self) -> UD_PORT_EN__RB_UH_PORT_EN_R {
                UD_PORT_EN__RB_UH_PORT_EN_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - general purpose bit;control USB bus reset: 0=normal, 1=force bus reset
            #[inline(always)]
            pub fn ud_gp_bit__rb_uh_bus_reset(&self) -> UD_GP_BIT__RB_UH_BUS_RESET_R {
                UD_GP_BIT__RB_UH_BUS_RESET_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - enable USB physical port low speed: 0=full speed, 1=low speed;enable USB port low speed: 0=full speed, 1=low speed
            #[inline(always)]
            pub fn ud_low_speed__rb_uh_low_speed(&self) -> UD_LOW_SPEED__RB_UH_LOW_SPEED_R {
                UD_LOW_SPEED__RB_UH_LOW_SPEED_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 4 - ReadOnly: indicate current UDM pin level
            #[inline(always)]
            pub fn ud_dm_pin__rb_uh_dm_pin(&self) -> UD_DM_PIN__RB_UH_DM_PIN_R {
                UD_DM_PIN__RB_UH_DM_PIN_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - ReadOnly: indicate current UDP pin level
            #[inline(always)]
            pub fn ud_dp_pin__rb_uh_dp_pin(&self) -> UD_DP_PIN__RB_UH_DP_PIN_R {
                UD_DP_PIN__RB_UH_DP_PIN_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 7 - disable USB UDP-UDM pulldown resistance: 0=enable pulldown, 1=disable
            #[inline(always)]
            pub fn ud_pd_dis__rb_uh_pd_dis(&self) -> UD_PD_DIS__RB_UH_PD_DIS_R {
                UD_PD_DIS__RB_UH_PD_DIS_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - enable USB physical port I-O: 0=disable, 1=enable;enable USB port: 0=disable, 1=enable port, automatic disabled if USB device detached
            #[inline(always)]
            #[must_use]
            pub fn ud_port_en__rb_uh_port_en(
                &mut self,
            ) -> UD_PORT_EN__RB_UH_PORT_EN_W<UDEV_CTRL__R8_UHOST_CTRL_SPEC> {
                UD_PORT_EN__RB_UH_PORT_EN_W::new(self, 0)
            }
            ///Bit 1 - general purpose bit;control USB bus reset: 0=normal, 1=force bus reset
            #[inline(always)]
            #[must_use]
            pub fn ud_gp_bit__rb_uh_bus_reset(
                &mut self,
            ) -> UD_GP_BIT__RB_UH_BUS_RESET_W<UDEV_CTRL__R8_UHOST_CTRL_SPEC> {
                UD_GP_BIT__RB_UH_BUS_RESET_W::new(self, 1)
            }
            ///Bit 2 - enable USB physical port low speed: 0=full speed, 1=low speed;enable USB port low speed: 0=full speed, 1=low speed
            #[inline(always)]
            #[must_use]
            pub fn ud_low_speed__rb_uh_low_speed(
                &mut self,
            ) -> UD_LOW_SPEED__RB_UH_LOW_SPEED_W<UDEV_CTRL__R8_UHOST_CTRL_SPEC> {
                UD_LOW_SPEED__RB_UH_LOW_SPEED_W::new(self, 2)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///USB device physical prot control
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`udev_ctrl__r8_uhost_ctrl::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`udev_ctrl__r8_uhost_ctrl::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct UDEV_CTRL__R8_UHOST_CTRL_SPEC;
        impl crate::RegisterSpec for UDEV_CTRL__R8_UHOST_CTRL_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`udev_ctrl__r8_uhost_ctrl::R`](R) reader structure
        impl crate::Readable for UDEV_CTRL__R8_UHOST_CTRL_SPEC {}
        ///`write(|w| ..)` method takes [`udev_ctrl__r8_uhost_ctrl::W`](W) writer structure
        impl crate::Writable for UDEV_CTRL__R8_UHOST_CTRL_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets UDEV_CTRL__R8_UHOST_CTRL to value 0
        impl crate::Resettable for UDEV_CTRL__R8_UHOST_CTRL_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///USB_INT_EN (rw) register accessor: USB interrupt enable
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`usb_int_en::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`usb_int_en::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@usb_int_en`]
    ///module
    pub type USB_INT_EN = crate::Reg<usb_int_en::USB_INT_EN_SPEC>;
    ///USB interrupt enable
    pub mod usb_int_en {
        ///Register `USB_INT_EN` reader
        pub type R = crate::R<USB_INT_EN_SPEC>;
        ///Register `USB_INT_EN` writer
        pub type W = crate::W<USB_INT_EN_SPEC>;
        ///Field `UIE_BUS_RST__RB_UIE_DETECT` reader - enable interrupt for USB bus reset event for USB device mode;enable interrupt for USB device detected event for USB host mode
        pub type UIE_BUS_RST__RB_UIE_DETECT_R = crate::BitReader;
        ///Field `UIE_BUS_RST__RB_UIE_DETECT` writer - enable interrupt for USB bus reset event for USB device mode;enable interrupt for USB device detected event for USB host mode
        pub type UIE_BUS_RST__RB_UIE_DETECT_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UIE_TRANSFER` reader - enable interrupt for USB transfer completion
        pub type UIE_TRANSFER_R = crate::BitReader;
        ///Field `UIE_TRANSFER` writer - enable interrupt for USB transfer completion
        pub type UIE_TRANSFER_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UIE_SUSPEND` reader - enable interrupt for USB suspend or resume event
        pub type UIE_SUSPEND_R = crate::BitReader;
        ///Field `UIE_SUSPEND` writer - enable interrupt for USB suspend or resume event
        pub type UIE_SUSPEND_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UIE_HST_SOF` reader - enable interrupt for host SOF timer action for USB host mode
        pub type UIE_HST_SOF_R = crate::BitReader;
        ///Field `UIE_HST_SOF` writer - enable interrupt for host SOF timer action for USB host mode
        pub type UIE_HST_SOF_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UIE_FIFO_OV` reader - enable interrupt for FIFO overflow
        pub type UIE_FIFO_OV_R = crate::BitReader;
        ///Field `UIE_FIFO_OV` writer - enable interrupt for FIFO overflow
        pub type UIE_FIFO_OV_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UIE_DEV_NAK` reader - enable interrupt for NAK responded for USB device mode
        pub type UIE_DEV_NAK_R = crate::BitReader;
        ///Field `UIE_DEV_NAK` writer - enable interrupt for NAK responded for USB device mode
        pub type UIE_DEV_NAK_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UIE_DEV_SOF` reader - enable interrupt for SOF received for USB device mode
        pub type UIE_DEV_SOF_R = crate::BitReader;
        ///Field `UIE_DEV_SOF` writer - enable interrupt for SOF received for USB device mode
        pub type UIE_DEV_SOF_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - enable interrupt for USB bus reset event for USB device mode;enable interrupt for USB device detected event for USB host mode
            #[inline(always)]
            pub fn uie_bus_rst__rb_uie_detect(&self) -> UIE_BUS_RST__RB_UIE_DETECT_R {
                UIE_BUS_RST__RB_UIE_DETECT_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - enable interrupt for USB transfer completion
            #[inline(always)]
            pub fn uie_transfer(&self) -> UIE_TRANSFER_R {
                UIE_TRANSFER_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - enable interrupt for USB suspend or resume event
            #[inline(always)]
            pub fn uie_suspend(&self) -> UIE_SUSPEND_R {
                UIE_SUSPEND_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - enable interrupt for host SOF timer action for USB host mode
            #[inline(always)]
            pub fn uie_hst_sof(&self) -> UIE_HST_SOF_R {
                UIE_HST_SOF_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - enable interrupt for FIFO overflow
            #[inline(always)]
            pub fn uie_fifo_ov(&self) -> UIE_FIFO_OV_R {
                UIE_FIFO_OV_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 6 - enable interrupt for NAK responded for USB device mode
            #[inline(always)]
            pub fn uie_dev_nak(&self) -> UIE_DEV_NAK_R {
                UIE_DEV_NAK_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - enable interrupt for SOF received for USB device mode
            #[inline(always)]
            pub fn uie_dev_sof(&self) -> UIE_DEV_SOF_R {
                UIE_DEV_SOF_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - enable interrupt for USB bus reset event for USB device mode;enable interrupt for USB device detected event for USB host mode
            #[inline(always)]
            #[must_use]
            pub fn uie_bus_rst__rb_uie_detect(
                &mut self,
            ) -> UIE_BUS_RST__RB_UIE_DETECT_W<USB_INT_EN_SPEC> {
                UIE_BUS_RST__RB_UIE_DETECT_W::new(self, 0)
            }
            ///Bit 1 - enable interrupt for USB transfer completion
            #[inline(always)]
            #[must_use]
            pub fn uie_transfer(&mut self) -> UIE_TRANSFER_W<USB_INT_EN_SPEC> {
                UIE_TRANSFER_W::new(self, 1)
            }
            ///Bit 2 - enable interrupt for USB suspend or resume event
            #[inline(always)]
            #[must_use]
            pub fn uie_suspend(&mut self) -> UIE_SUSPEND_W<USB_INT_EN_SPEC> {
                UIE_SUSPEND_W::new(self, 2)
            }
            ///Bit 3 - enable interrupt for host SOF timer action for USB host mode
            #[inline(always)]
            #[must_use]
            pub fn uie_hst_sof(&mut self) -> UIE_HST_SOF_W<USB_INT_EN_SPEC> {
                UIE_HST_SOF_W::new(self, 3)
            }
            ///Bit 4 - enable interrupt for FIFO overflow
            #[inline(always)]
            #[must_use]
            pub fn uie_fifo_ov(&mut self) -> UIE_FIFO_OV_W<USB_INT_EN_SPEC> {
                UIE_FIFO_OV_W::new(self, 4)
            }
            ///Bit 6 - enable interrupt for NAK responded for USB device mode
            #[inline(always)]
            #[must_use]
            pub fn uie_dev_nak(&mut self) -> UIE_DEV_NAK_W<USB_INT_EN_SPEC> {
                UIE_DEV_NAK_W::new(self, 6)
            }
            ///Bit 7 - enable interrupt for SOF received for USB device mode
            #[inline(always)]
            #[must_use]
            pub fn uie_dev_sof(&mut self) -> UIE_DEV_SOF_W<USB_INT_EN_SPEC> {
                UIE_DEV_SOF_W::new(self, 7)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///USB interrupt enable
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`usb_int_en::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`usb_int_en::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct USB_INT_EN_SPEC;
        impl crate::RegisterSpec for USB_INT_EN_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`usb_int_en::R`](R) reader structure
        impl crate::Readable for USB_INT_EN_SPEC {}
        ///`write(|w| ..)` method takes [`usb_int_en::W`](W) writer structure
        impl crate::Writable for USB_INT_EN_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets USB_INT_EN to value 0
        impl crate::Resettable for USB_INT_EN_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///USB_DEV_AD (rw) register accessor: USB device address
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`usb_dev_ad::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`usb_dev_ad::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@usb_dev_ad`]
    ///module
    pub type USB_DEV_AD = crate::Reg<usb_dev_ad::USB_DEV_AD_SPEC>;
    ///USB device address
    pub mod usb_dev_ad {
        ///Register `USB_DEV_AD` reader
        pub type R = crate::R<USB_DEV_AD_SPEC>;
        ///Register `USB_DEV_AD` writer
        pub type W = crate::W<USB_DEV_AD_SPEC>;
        ///Field `MASK_USB_ADDR` reader - bit mask for USB device address
        pub type MASK_USB_ADDR_R = crate::FieldReader;
        ///Field `MASK_USB_ADDR` writer - bit mask for USB device address
        pub type MASK_USB_ADDR_W<'a, REG> = crate::FieldWriter<'a, REG, 7>;
        ///Field `UDA_GP_BIT` reader - general purpose bit
        pub type UDA_GP_BIT_R = crate::BitReader;
        ///Field `UDA_GP_BIT` writer - general purpose bit
        pub type UDA_GP_BIT_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bits 0:6 - bit mask for USB device address
            #[inline(always)]
            pub fn mask_usb_addr(&self) -> MASK_USB_ADDR_R {
                MASK_USB_ADDR_R::new(self.bits & 0x7f)
            }
            ///Bit 7 - general purpose bit
            #[inline(always)]
            pub fn uda_gp_bit(&self) -> UDA_GP_BIT_R {
                UDA_GP_BIT_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:6 - bit mask for USB device address
            #[inline(always)]
            #[must_use]
            pub fn mask_usb_addr(&mut self) -> MASK_USB_ADDR_W<USB_DEV_AD_SPEC> {
                MASK_USB_ADDR_W::new(self, 0)
            }
            ///Bit 7 - general purpose bit
            #[inline(always)]
            #[must_use]
            pub fn uda_gp_bit(&mut self) -> UDA_GP_BIT_W<USB_DEV_AD_SPEC> {
                UDA_GP_BIT_W::new(self, 7)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///USB device address
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`usb_dev_ad::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`usb_dev_ad::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct USB_DEV_AD_SPEC;
        impl crate::RegisterSpec for USB_DEV_AD_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`usb_dev_ad::R`](R) reader structure
        impl crate::Readable for USB_DEV_AD_SPEC {}
        ///`write(|w| ..)` method takes [`usb_dev_ad::W`](W) writer structure
        impl crate::Writable for USB_DEV_AD_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets USB_DEV_AD to value 0
        impl crate::Resettable for USB_DEV_AD_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///USB_MIS_ST (r) register accessor: USB miscellaneous status
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`usb_mis_st::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@usb_mis_st`]
    ///module
    pub type USB_MIS_ST = crate::Reg<usb_mis_st::USB_MIS_ST_SPEC>;
    ///USB miscellaneous status
    pub mod usb_mis_st {
        ///Register `USB_MIS_ST` reader
        pub type R = crate::R<USB_MIS_ST_SPEC>;
        ///Field `UMS_DEV_ATTACH` reader - RO, indicate device attached status on USB host
        pub type UMS_DEV_ATTACH_R = crate::BitReader;
        ///Field `UMS_DM_LEVEL` reader - RO, indicate UDM level saved at device attached to USB host
        pub type UMS_DM_LEVEL_R = crate::BitReader;
        ///Field `UMS_SUSPEND` reader - RO, indicate USB suspend status
        pub type UMS_SUSPEND_R = crate::BitReader;
        ///Field `UMS_BUS_RESET` reader - RO, indicate USB bus reset status
        pub type UMS_BUS_RESET_R = crate::BitReader;
        ///Field `UMS_R_FIFO_RDY` reader - RO, indicate USB receiving FIFO ready status (not empty)
        pub type UMS_R_FIFO_RDY_R = crate::BitReader;
        ///Field `UMS_SIE_FREE` reader - RO, indicate USB SIE free status
        pub type UMS_SIE_FREE_R = crate::BitReader;
        ///Field `UMS_SOF_ACT` reader - RO, indicate host SOF timer action status for USB host
        pub type UMS_SOF_ACT_R = crate::BitReader;
        ///Field `UMS_SOF_PRES` reader - RO, indicate host SOF timer presage status
        pub type UMS_SOF_PRES_R = crate::BitReader;
        impl R {
            ///Bit 0 - RO, indicate device attached status on USB host
            #[inline(always)]
            pub fn ums_dev_attach(&self) -> UMS_DEV_ATTACH_R {
                UMS_DEV_ATTACH_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RO, indicate UDM level saved at device attached to USB host
            #[inline(always)]
            pub fn ums_dm_level(&self) -> UMS_DM_LEVEL_R {
                UMS_DM_LEVEL_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RO, indicate USB suspend status
            #[inline(always)]
            pub fn ums_suspend(&self) -> UMS_SUSPEND_R {
                UMS_SUSPEND_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RO, indicate USB bus reset status
            #[inline(always)]
            pub fn ums_bus_reset(&self) -> UMS_BUS_RESET_R {
                UMS_BUS_RESET_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RO, indicate USB receiving FIFO ready status (not empty)
            #[inline(always)]
            pub fn ums_r_fifo_rdy(&self) -> UMS_R_FIFO_RDY_R {
                UMS_R_FIFO_RDY_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - RO, indicate USB SIE free status
            #[inline(always)]
            pub fn ums_sie_free(&self) -> UMS_SIE_FREE_R {
                UMS_SIE_FREE_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - RO, indicate host SOF timer action status for USB host
            #[inline(always)]
            pub fn ums_sof_act(&self) -> UMS_SOF_ACT_R {
                UMS_SOF_ACT_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - RO, indicate host SOF timer presage status
            #[inline(always)]
            pub fn ums_sof_pres(&self) -> UMS_SOF_PRES_R {
                UMS_SOF_PRES_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        ///USB miscellaneous status
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`usb_mis_st::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct USB_MIS_ST_SPEC;
        impl crate::RegisterSpec for USB_MIS_ST_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`usb_mis_st::R`](R) reader structure
        impl crate::Readable for USB_MIS_ST_SPEC {}
        ///`reset()` method sets USB_MIS_ST to value 0
        impl crate::Resettable for USB_MIS_ST_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///USB_INT_FG (rw) register accessor: USB interrupt flag
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`usb_int_fg::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`usb_int_fg::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@usb_int_fg`]
    ///module
    pub type USB_INT_FG = crate::Reg<usb_int_fg::USB_INT_FG_SPEC>;
    ///USB interrupt flag
    pub mod usb_int_fg {
        ///Register `USB_INT_FG` reader
        pub type R = crate::R<USB_INT_FG_SPEC>;
        ///Register `USB_INT_FG` writer
        pub type W = crate::W<USB_INT_FG_SPEC>;
        ///Field `UIF_BUS_RST__RB_UIF_DETECT` reader - RW,bus reset event interrupt flag for USB device mode, direct bit address clear or write 1 to clear;device detected event interrupt flag for USB host mode, direct bit address clear or write 1 to clear
        pub type UIF_BUS_RST__RB_UIF_DETECT_R = crate::BitReader;
        ///Field `UIF_BUS_RST__RB_UIF_DETECT` writer - RW,bus reset event interrupt flag for USB device mode, direct bit address clear or write 1 to clear;device detected event interrupt flag for USB host mode, direct bit address clear or write 1 to clear
        pub type UIF_BUS_RST__RB_UIF_DETECT_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UIF_TRANSFER` reader - RW,USB transfer completion interrupt flag, direct bit address clear or write 1 to clear
        pub type UIF_TRANSFER_R = crate::BitReader;
        ///Field `UIF_TRANSFER` writer - RW,USB transfer completion interrupt flag, direct bit address clear or write 1 to clear
        pub type UIF_TRANSFER_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UIF_SUSPEND` reader - RW,USB suspend or resume event interrupt flag, direct bit address clear or write 1 to clear
        pub type UIF_SUSPEND_R = crate::BitReader;
        ///Field `UIF_SUSPEND` writer - RW,USB suspend or resume event interrupt flag, direct bit address clear or write 1 to clear
        pub type UIF_SUSPEND_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UIF_HST_SOF` reader - RW,host SOF timer interrupt flag for USB host, direct bit address clear or write 1 to clear
        pub type UIF_HST_SOF_R = crate::BitReader;
        ///Field `UIF_HST_SOF` writer - RW,host SOF timer interrupt flag for USB host, direct bit address clear or write 1 to clear
        pub type UIF_HST_SOF_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UIF_FIFO_OV` reader - RW,FIFO overflow interrupt flag for USB, direct bit address clear or write 1 to clear
        pub type UIF_FIFO_OV_R = crate::BitReader;
        ///Field `UIF_FIFO_OV` writer - RW,FIFO overflow interrupt flag for USB, direct bit address clear or write 1 to clear
        pub type UIF_FIFO_OV_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `U_SIE_FREE` reader - RO, indicate USB SIE free status
        pub type U_SIE_FREE_R = crate::BitReader;
        ///Field `U_TOG_OK` reader - RO, indicate current USB transfer toggle is OK
        pub type U_TOG_OK_R = crate::BitReader;
        ///Field `U_IS_NAK` reader - RO, indicate current USB transfer is NAK received
        pub type U_IS_NAK_R = crate::BitReader;
        impl R {
            ///Bit 0 - RW,bus reset event interrupt flag for USB device mode, direct bit address clear or write 1 to clear;device detected event interrupt flag for USB host mode, direct bit address clear or write 1 to clear
            #[inline(always)]
            pub fn uif_bus_rst__rb_uif_detect(&self) -> UIF_BUS_RST__RB_UIF_DETECT_R {
                UIF_BUS_RST__RB_UIF_DETECT_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RW,USB transfer completion interrupt flag, direct bit address clear or write 1 to clear
            #[inline(always)]
            pub fn uif_transfer(&self) -> UIF_TRANSFER_R {
                UIF_TRANSFER_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RW,USB suspend or resume event interrupt flag, direct bit address clear or write 1 to clear
            #[inline(always)]
            pub fn uif_suspend(&self) -> UIF_SUSPEND_R {
                UIF_SUSPEND_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RW,host SOF timer interrupt flag for USB host, direct bit address clear or write 1 to clear
            #[inline(always)]
            pub fn uif_hst_sof(&self) -> UIF_HST_SOF_R {
                UIF_HST_SOF_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RW,FIFO overflow interrupt flag for USB, direct bit address clear or write 1 to clear
            #[inline(always)]
            pub fn uif_fifo_ov(&self) -> UIF_FIFO_OV_R {
                UIF_FIFO_OV_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - RO, indicate USB SIE free status
            #[inline(always)]
            pub fn u_sie_free(&self) -> U_SIE_FREE_R {
                U_SIE_FREE_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - RO, indicate current USB transfer toggle is OK
            #[inline(always)]
            pub fn u_tog_ok(&self) -> U_TOG_OK_R {
                U_TOG_OK_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - RO, indicate current USB transfer is NAK received
            #[inline(always)]
            pub fn u_is_nak(&self) -> U_IS_NAK_R {
                U_IS_NAK_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RW,bus reset event interrupt flag for USB device mode, direct bit address clear or write 1 to clear;device detected event interrupt flag for USB host mode, direct bit address clear or write 1 to clear
            #[inline(always)]
            #[must_use]
            pub fn uif_bus_rst__rb_uif_detect(
                &mut self,
            ) -> UIF_BUS_RST__RB_UIF_DETECT_W<USB_INT_FG_SPEC> {
                UIF_BUS_RST__RB_UIF_DETECT_W::new(self, 0)
            }
            ///Bit 1 - RW,USB transfer completion interrupt flag, direct bit address clear or write 1 to clear
            #[inline(always)]
            #[must_use]
            pub fn uif_transfer(&mut self) -> UIF_TRANSFER_W<USB_INT_FG_SPEC> {
                UIF_TRANSFER_W::new(self, 1)
            }
            ///Bit 2 - RW,USB suspend or resume event interrupt flag, direct bit address clear or write 1 to clear
            #[inline(always)]
            #[must_use]
            pub fn uif_suspend(&mut self) -> UIF_SUSPEND_W<USB_INT_FG_SPEC> {
                UIF_SUSPEND_W::new(self, 2)
            }
            ///Bit 3 - RW,host SOF timer interrupt flag for USB host, direct bit address clear or write 1 to clear
            #[inline(always)]
            #[must_use]
            pub fn uif_hst_sof(&mut self) -> UIF_HST_SOF_W<USB_INT_FG_SPEC> {
                UIF_HST_SOF_W::new(self, 3)
            }
            ///Bit 4 - RW,FIFO overflow interrupt flag for USB, direct bit address clear or write 1 to clear
            #[inline(always)]
            #[must_use]
            pub fn uif_fifo_ov(&mut self) -> UIF_FIFO_OV_W<USB_INT_FG_SPEC> {
                UIF_FIFO_OV_W::new(self, 4)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///USB interrupt flag
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`usb_int_fg::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`usb_int_fg::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct USB_INT_FG_SPEC;
        impl crate::RegisterSpec for USB_INT_FG_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`usb_int_fg::R`](R) reader structure
        impl crate::Readable for USB_INT_FG_SPEC {}
        ///`write(|w| ..)` method takes [`usb_int_fg::W`](W) writer structure
        impl crate::Writable for USB_INT_FG_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets USB_INT_FG to value 0x20
        impl crate::Resettable for USB_INT_FG_SPEC {
            const RESET_VALUE: u8 = 0x20;
        }
    }
    ///USB_INT_ST (r) register accessor: USB interrupt status
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`usb_int_st::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@usb_int_st`]
    ///module
    pub type USB_INT_ST = crate::Reg<usb_int_st::USB_INT_ST_SPEC>;
    ///USB interrupt status
    pub mod usb_int_st {
        ///Register `USB_INT_ST` reader
        pub type R = crate::R<USB_INT_ST_SPEC>;
        ///Field `MASK_UIS_H_RES__MASK_UIS_ENDP` reader - RO, bit mask of current transfer handshake response for USB host mode: 0000=no response, time out from device, others=handshake response PID received;RO, bit mask of current transfer endpoint number for USB device mode
        pub type MASK_UIS_H_RES__MASK_UIS_ENDP_R = crate::FieldReader;
        ///Field `MASK_UIS_TOKEN` reader - RO, bit mask of current token PID code received for USB device mode
        pub type MASK_UIS_TOKEN_R = crate::FieldReader;
        ///Field `UIS_TOG_OK` reader - RO, indicate current USB transfer toggle is OK
        pub type UIS_TOG_OK_R = crate::BitReader;
        ///Field `UIS_SETUP_ACT` reader - RO, indicate current USB transfer is NAK received for USB device mode
        pub type UIS_SETUP_ACT_R = crate::BitReader;
        impl R {
            ///Bits 0:3 - RO, bit mask of current transfer handshake response for USB host mode: 0000=no response, time out from device, others=handshake response PID received;RO, bit mask of current transfer endpoint number for USB device mode
            #[inline(always)]
            pub fn mask_uis_h_res__mask_uis_endp(&self) -> MASK_UIS_H_RES__MASK_UIS_ENDP_R {
                MASK_UIS_H_RES__MASK_UIS_ENDP_R::new(self.bits & 0x0f)
            }
            ///Bits 4:5 - RO, bit mask of current token PID code received for USB device mode
            #[inline(always)]
            pub fn mask_uis_token(&self) -> MASK_UIS_TOKEN_R {
                MASK_UIS_TOKEN_R::new((self.bits >> 4) & 3)
            }
            ///Bit 6 - RO, indicate current USB transfer toggle is OK
            #[inline(always)]
            pub fn uis_tog_ok(&self) -> UIS_TOG_OK_R {
                UIS_TOG_OK_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - RO, indicate current USB transfer is NAK received for USB device mode
            #[inline(always)]
            pub fn uis_setup_act(&self) -> UIS_SETUP_ACT_R {
                UIS_SETUP_ACT_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        ///USB interrupt status
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`usb_int_st::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct USB_INT_ST_SPEC;
        impl crate::RegisterSpec for USB_INT_ST_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`usb_int_st::R`](R) reader structure
        impl crate::Readable for USB_INT_ST_SPEC {}
        ///`reset()` method sets USB_INT_ST to value 0
        impl crate::Resettable for USB_INT_ST_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///USB_RX_LEN (r) register accessor: USB receiving length
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`usb_rx_len::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@usb_rx_len`]
    ///module
    pub type USB_RX_LEN = crate::Reg<usb_rx_len::USB_RX_LEN_SPEC>;
    ///USB receiving length
    pub mod usb_rx_len {
        ///Register `USB_RX_LEN` reader
        pub type R = crate::R<USB_RX_LEN_SPEC>;
        ///Field `USB_RX_LEN` reader - RO,USB receiving length
        pub type USB_RX_LEN_R = crate::FieldReader;
        impl R {
            ///Bits 0:7 - RO,USB receiving length
            #[inline(always)]
            pub fn usb_rx_len(&self) -> USB_RX_LEN_R {
                USB_RX_LEN_R::new(self.bits)
            }
        }
        ///USB receiving length
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`usb_rx_len::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct USB_RX_LEN_SPEC;
        impl crate::RegisterSpec for USB_RX_LEN_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`usb_rx_len::R`](R) reader structure
        impl crate::Readable for USB_RX_LEN_SPEC {}
        ///`reset()` method sets USB_RX_LEN to value 0
        impl crate::Resettable for USB_RX_LEN_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///UEP4_1_MOD (rw) register accessor: endpoint 4/1 mode
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`uep4_1_mod::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep4_1_mod::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@uep4_1_mod`]
    ///module
    pub type UEP4_1_MOD = crate::Reg<uep4_1_mod::UEP4_1_MOD_SPEC>;
    ///endpoint 4/1 mode
    pub mod uep4_1_mod {
        ///Register `UEP4_1_MOD` reader
        pub type R = crate::R<UEP4_1_MOD_SPEC>;
        ///Register `UEP4_1_MOD` writer
        pub type W = crate::W<UEP4_1_MOD_SPEC>;
        ///Field `UEP4_TX_EN` reader - enable USB endpoint 4 transmittal (IN)
        pub type UEP4_TX_EN_R = crate::BitReader;
        ///Field `UEP4_TX_EN` writer - enable USB endpoint 4 transmittal (IN)
        pub type UEP4_TX_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UEP4_RX_EN` reader - enable USB endpoint 4 receiving (OUT)
        pub type UEP4_RX_EN_R = crate::BitReader;
        ///Field `UEP4_RX_EN` writer - enable USB endpoint 4 receiving (OUT)
        pub type UEP4_RX_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UEP1_BUF_MOD` reader - buffer mode of USB endpoint 1
        pub type UEP1_BUF_MOD_R = crate::BitReader;
        ///Field `UEP1_BUF_MOD` writer - buffer mode of USB endpoint 1
        pub type UEP1_BUF_MOD_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UEP1_TX_EN` reader - enable USB endpoint 1 transmittal (IN)
        pub type UEP1_TX_EN_R = crate::BitReader;
        ///Field `UEP1_TX_EN` writer - enable USB endpoint 1 transmittal (IN)
        pub type UEP1_TX_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UEP1_RX_EN` reader - enable USB endpoint 1 receiving (OUT)
        pub type UEP1_RX_EN_R = crate::BitReader;
        ///Field `UEP1_RX_EN` writer - enable USB endpoint 1 receiving (OUT)
        pub type UEP1_RX_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 2 - enable USB endpoint 4 transmittal (IN)
            #[inline(always)]
            pub fn uep4_tx_en(&self) -> UEP4_TX_EN_R {
                UEP4_TX_EN_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - enable USB endpoint 4 receiving (OUT)
            #[inline(always)]
            pub fn uep4_rx_en(&self) -> UEP4_RX_EN_R {
                UEP4_RX_EN_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - buffer mode of USB endpoint 1
            #[inline(always)]
            pub fn uep1_buf_mod(&self) -> UEP1_BUF_MOD_R {
                UEP1_BUF_MOD_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 6 - enable USB endpoint 1 transmittal (IN)
            #[inline(always)]
            pub fn uep1_tx_en(&self) -> UEP1_TX_EN_R {
                UEP1_TX_EN_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - enable USB endpoint 1 receiving (OUT)
            #[inline(always)]
            pub fn uep1_rx_en(&self) -> UEP1_RX_EN_R {
                UEP1_RX_EN_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 2 - enable USB endpoint 4 transmittal (IN)
            #[inline(always)]
            #[must_use]
            pub fn uep4_tx_en(&mut self) -> UEP4_TX_EN_W<UEP4_1_MOD_SPEC> {
                UEP4_TX_EN_W::new(self, 2)
            }
            ///Bit 3 - enable USB endpoint 4 receiving (OUT)
            #[inline(always)]
            #[must_use]
            pub fn uep4_rx_en(&mut self) -> UEP4_RX_EN_W<UEP4_1_MOD_SPEC> {
                UEP4_RX_EN_W::new(self, 3)
            }
            ///Bit 4 - buffer mode of USB endpoint 1
            #[inline(always)]
            #[must_use]
            pub fn uep1_buf_mod(&mut self) -> UEP1_BUF_MOD_W<UEP4_1_MOD_SPEC> {
                UEP1_BUF_MOD_W::new(self, 4)
            }
            ///Bit 6 - enable USB endpoint 1 transmittal (IN)
            #[inline(always)]
            #[must_use]
            pub fn uep1_tx_en(&mut self) -> UEP1_TX_EN_W<UEP4_1_MOD_SPEC> {
                UEP1_TX_EN_W::new(self, 6)
            }
            ///Bit 7 - enable USB endpoint 1 receiving (OUT)
            #[inline(always)]
            #[must_use]
            pub fn uep1_rx_en(&mut self) -> UEP1_RX_EN_W<UEP4_1_MOD_SPEC> {
                UEP1_RX_EN_W::new(self, 7)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///endpoint 4/1 mode
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`uep4_1_mod::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep4_1_mod::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct UEP4_1_MOD_SPEC;
        impl crate::RegisterSpec for UEP4_1_MOD_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`uep4_1_mod::R`](R) reader structure
        impl crate::Readable for UEP4_1_MOD_SPEC {}
        ///`write(|w| ..)` method takes [`uep4_1_mod::W`](W) writer structure
        impl crate::Writable for UEP4_1_MOD_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets UEP4_1_MOD to value 0
        impl crate::Resettable for UEP4_1_MOD_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///UEP2_3_MOD__R8_UH_EP_MOD (rw) register accessor: endpoint 2_3 mode;host endpoint mode
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`uep2_3_mod__r8_uh_ep_mod::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep2_3_mod__r8_uh_ep_mod::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@uep2_3_mod__r8_uh_ep_mod`]
    ///module
    pub type UEP2_3_MOD__R8_UH_EP_MOD =
        crate::Reg<uep2_3_mod__r8_uh_ep_mod::UEP2_3_MOD__R8_UH_EP_MOD_SPEC>;
    ///endpoint 2_3 mode;host endpoint mode
    pub mod uep2_3_mod__r8_uh_ep_mod {
        ///Register `UEP2_3_MOD__R8_UH_EP_MOD` reader
        pub type R = crate::R<UEP2_3_MOD__R8_UH_EP_MOD_SPEC>;
        ///Register `UEP2_3_MOD__R8_UH_EP_MOD` writer
        pub type W = crate::W<UEP2_3_MOD__R8_UH_EP_MOD_SPEC>;
        ///Field `UEP2_BUF_MOD__RB_UH_EP_RBUF_MOD` reader - buffer mode of USB endpoint 2;buffer mode of USB host IN endpoint
        pub type UEP2_BUF_MOD__RB_UH_EP_RBUF_MOD_R = crate::BitReader;
        ///Field `UEP2_BUF_MOD__RB_UH_EP_RBUF_MOD` writer - buffer mode of USB endpoint 2;buffer mode of USB host IN endpoint
        pub type UEP2_BUF_MOD__RB_UH_EP_RBUF_MOD_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UEP2_TX_EN` reader - enable USB endpoint 2 transmittal (IN)
        pub type UEP2_TX_EN_R = crate::BitReader;
        ///Field `UEP2_TX_EN` writer - enable USB endpoint 2 transmittal (IN)
        pub type UEP2_TX_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UEP2_RX_EN__RB_UH_EP_RX_EN` reader - enable USB endpoint 2 receiving (OUT);enable USB host IN endpoint receiving
        pub type UEP2_RX_EN__RB_UH_EP_RX_EN_R = crate::BitReader;
        ///Field `UEP2_RX_EN__RB_UH_EP_RX_EN` writer - enable USB endpoint 2 receiving (OUT);enable USB host IN endpoint receiving
        pub type UEP2_RX_EN__RB_UH_EP_RX_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UEP3_BUF_MOD__RB_UH_EP_TBUF_MOD` reader - buffer mode of USB endpoint 3;buffer mode of USB host OUT endpoint
        pub type UEP3_BUF_MOD__RB_UH_EP_TBUF_MOD_R = crate::BitReader;
        ///Field `UEP3_BUF_MOD__RB_UH_EP_TBUF_MOD` writer - buffer mode of USB endpoint 3;buffer mode of USB host OUT endpoint
        pub type UEP3_BUF_MOD__RB_UH_EP_TBUF_MOD_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UEP3_TX_EN__RB_UH_EP_TX_EN` reader - enable USB endpoint 3 transmittal (IN);enable USB host OUT endpoint transmittal
        pub type UEP3_TX_EN__RB_UH_EP_TX_EN_R = crate::BitReader;
        ///Field `UEP3_TX_EN__RB_UH_EP_TX_EN` writer - enable USB endpoint 3 transmittal (IN);enable USB host OUT endpoint transmittal
        pub type UEP3_TX_EN__RB_UH_EP_TX_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UEP3_RX_EN` reader - enable USB endpoint 3 receiving (OUT)
        pub type UEP3_RX_EN_R = crate::BitReader;
        ///Field `UEP3_RX_EN` writer - enable USB endpoint 3 receiving (OUT)
        pub type UEP3_RX_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - buffer mode of USB endpoint 2;buffer mode of USB host IN endpoint
            #[inline(always)]
            pub fn uep2_buf_mod__rb_uh_ep_rbuf_mod(&self) -> UEP2_BUF_MOD__RB_UH_EP_RBUF_MOD_R {
                UEP2_BUF_MOD__RB_UH_EP_RBUF_MOD_R::new((self.bits & 1) != 0)
            }
            ///Bit 2 - enable USB endpoint 2 transmittal (IN)
            #[inline(always)]
            pub fn uep2_tx_en(&self) -> UEP2_TX_EN_R {
                UEP2_TX_EN_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - enable USB endpoint 2 receiving (OUT);enable USB host IN endpoint receiving
            #[inline(always)]
            pub fn uep2_rx_en__rb_uh_ep_rx_en(&self) -> UEP2_RX_EN__RB_UH_EP_RX_EN_R {
                UEP2_RX_EN__RB_UH_EP_RX_EN_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - buffer mode of USB endpoint 3;buffer mode of USB host OUT endpoint
            #[inline(always)]
            pub fn uep3_buf_mod__rb_uh_ep_tbuf_mod(&self) -> UEP3_BUF_MOD__RB_UH_EP_TBUF_MOD_R {
                UEP3_BUF_MOD__RB_UH_EP_TBUF_MOD_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 6 - enable USB endpoint 3 transmittal (IN);enable USB host OUT endpoint transmittal
            #[inline(always)]
            pub fn uep3_tx_en__rb_uh_ep_tx_en(&self) -> UEP3_TX_EN__RB_UH_EP_TX_EN_R {
                UEP3_TX_EN__RB_UH_EP_TX_EN_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - enable USB endpoint 3 receiving (OUT)
            #[inline(always)]
            pub fn uep3_rx_en(&self) -> UEP3_RX_EN_R {
                UEP3_RX_EN_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - buffer mode of USB endpoint 2;buffer mode of USB host IN endpoint
            #[inline(always)]
            #[must_use]
            pub fn uep2_buf_mod__rb_uh_ep_rbuf_mod(
                &mut self,
            ) -> UEP2_BUF_MOD__RB_UH_EP_RBUF_MOD_W<UEP2_3_MOD__R8_UH_EP_MOD_SPEC> {
                UEP2_BUF_MOD__RB_UH_EP_RBUF_MOD_W::new(self, 0)
            }
            ///Bit 2 - enable USB endpoint 2 transmittal (IN)
            #[inline(always)]
            #[must_use]
            pub fn uep2_tx_en(&mut self) -> UEP2_TX_EN_W<UEP2_3_MOD__R8_UH_EP_MOD_SPEC> {
                UEP2_TX_EN_W::new(self, 2)
            }
            ///Bit 3 - enable USB endpoint 2 receiving (OUT);enable USB host IN endpoint receiving
            #[inline(always)]
            #[must_use]
            pub fn uep2_rx_en__rb_uh_ep_rx_en(
                &mut self,
            ) -> UEP2_RX_EN__RB_UH_EP_RX_EN_W<UEP2_3_MOD__R8_UH_EP_MOD_SPEC> {
                UEP2_RX_EN__RB_UH_EP_RX_EN_W::new(self, 3)
            }
            ///Bit 4 - buffer mode of USB endpoint 3;buffer mode of USB host OUT endpoint
            #[inline(always)]
            #[must_use]
            pub fn uep3_buf_mod__rb_uh_ep_tbuf_mod(
                &mut self,
            ) -> UEP3_BUF_MOD__RB_UH_EP_TBUF_MOD_W<UEP2_3_MOD__R8_UH_EP_MOD_SPEC> {
                UEP3_BUF_MOD__RB_UH_EP_TBUF_MOD_W::new(self, 4)
            }
            ///Bit 6 - enable USB endpoint 3 transmittal (IN);enable USB host OUT endpoint transmittal
            #[inline(always)]
            #[must_use]
            pub fn uep3_tx_en__rb_uh_ep_tx_en(
                &mut self,
            ) -> UEP3_TX_EN__RB_UH_EP_TX_EN_W<UEP2_3_MOD__R8_UH_EP_MOD_SPEC> {
                UEP3_TX_EN__RB_UH_EP_TX_EN_W::new(self, 6)
            }
            ///Bit 7 - enable USB endpoint 3 receiving (OUT)
            #[inline(always)]
            #[must_use]
            pub fn uep3_rx_en(&mut self) -> UEP3_RX_EN_W<UEP2_3_MOD__R8_UH_EP_MOD_SPEC> {
                UEP3_RX_EN_W::new(self, 7)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///endpoint 2_3 mode;host endpoint mode
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`uep2_3_mod__r8_uh_ep_mod::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep2_3_mod__r8_uh_ep_mod::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct UEP2_3_MOD__R8_UH_EP_MOD_SPEC;
        impl crate::RegisterSpec for UEP2_3_MOD__R8_UH_EP_MOD_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`uep2_3_mod__r8_uh_ep_mod::R`](R) reader structure
        impl crate::Readable for UEP2_3_MOD__R8_UH_EP_MOD_SPEC {}
        ///`write(|w| ..)` method takes [`uep2_3_mod__r8_uh_ep_mod::W`](W) writer structure
        impl crate::Writable for UEP2_3_MOD__R8_UH_EP_MOD_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets UEP2_3_MOD__R8_UH_EP_MOD to value 0
        impl crate::Resettable for UEP2_3_MOD__R8_UH_EP_MOD_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///UEP0_DMA (rw) register accessor: endpoint 0 DMA buffer address
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`uep0_dma::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep0_dma::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@uep0_dma`]
    ///module
    pub type UEP0_DMA = crate::Reg<uep0_dma::UEP0_DMA_SPEC>;
    ///endpoint 0 DMA buffer address
    pub mod uep0_dma {
        ///Register `UEP0_DMA` reader
        pub type R = crate::R<UEP0_DMA_SPEC>;
        ///Register `UEP0_DMA` writer
        pub type W = crate::W<UEP0_DMA_SPEC>;
        ///Field `UEP0_DMA` reader - RW,endpoint 0 DMA buffer address
        pub type UEP0_DMA_R = crate::FieldReader<u16>;
        ///Field `UEP0_DMA` writer - RW,endpoint 0 DMA buffer address
        pub type UEP0_DMA_W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            ///Bits 0:15 - RW,endpoint 0 DMA buffer address
            #[inline(always)]
            pub fn uep0_dma(&self) -> UEP0_DMA_R {
                UEP0_DMA_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - RW,endpoint 0 DMA buffer address
            #[inline(always)]
            #[must_use]
            pub fn uep0_dma(&mut self) -> UEP0_DMA_W<UEP0_DMA_SPEC> {
                UEP0_DMA_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///endpoint 0 DMA buffer address
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`uep0_dma::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep0_dma::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct UEP0_DMA_SPEC;
        impl crate::RegisterSpec for UEP0_DMA_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`uep0_dma::R`](R) reader structure
        impl crate::Readable for UEP0_DMA_SPEC {}
        ///`write(|w| ..)` method takes [`uep0_dma::W`](W) writer structure
        impl crate::Writable for UEP0_DMA_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets UEP0_DMA to value 0
        impl crate::Resettable for UEP0_DMA_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///UEP1_DMA (rw) register accessor: endpoint 1 DMA buffer address
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`uep1_dma::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep1_dma::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@uep1_dma`]
    ///module
    pub type UEP1_DMA = crate::Reg<uep1_dma::UEP1_DMA_SPEC>;
    ///endpoint 1 DMA buffer address
    pub mod uep1_dma {
        ///Register `UEP1_DMA` reader
        pub type R = crate::R<UEP1_DMA_SPEC>;
        ///Register `UEP1_DMA` writer
        pub type W = crate::W<UEP1_DMA_SPEC>;
        ///Field `UEP1_DMA` reader - RW,endpoint 1 DMA buffer address
        pub type UEP1_DMA_R = crate::FieldReader<u16>;
        ///Field `UEP1_DMA` writer - RW,endpoint 1 DMA buffer address
        pub type UEP1_DMA_W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            ///Bits 0:15 - RW,endpoint 1 DMA buffer address
            #[inline(always)]
            pub fn uep1_dma(&self) -> UEP1_DMA_R {
                UEP1_DMA_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - RW,endpoint 1 DMA buffer address
            #[inline(always)]
            #[must_use]
            pub fn uep1_dma(&mut self) -> UEP1_DMA_W<UEP1_DMA_SPEC> {
                UEP1_DMA_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///endpoint 1 DMA buffer address
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`uep1_dma::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep1_dma::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct UEP1_DMA_SPEC;
        impl crate::RegisterSpec for UEP1_DMA_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`uep1_dma::R`](R) reader structure
        impl crate::Readable for UEP1_DMA_SPEC {}
        ///`write(|w| ..)` method takes [`uep1_dma::W`](W) writer structure
        impl crate::Writable for UEP1_DMA_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets UEP1_DMA to value 0
        impl crate::Resettable for UEP1_DMA_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///UEP2_DMA__R16_UH_RX_DMA (rw) register accessor: endpoint 2 DMA buffer address;host rx endpoint buffer high address
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`uep2_dma__r16_uh_rx_dma::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep2_dma__r16_uh_rx_dma::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@uep2_dma__r16_uh_rx_dma`]
    ///module
    pub type UEP2_DMA__R16_UH_RX_DMA =
        crate::Reg<uep2_dma__r16_uh_rx_dma::UEP2_DMA__R16_UH_RX_DMA_SPEC>;
    ///endpoint 2 DMA buffer address;host rx endpoint buffer high address
    pub mod uep2_dma__r16_uh_rx_dma {
        ///Register `UEP2_DMA__R16_UH_RX_DMA` reader
        pub type R = crate::R<UEP2_DMA__R16_UH_RX_DMA_SPEC>;
        ///Register `UEP2_DMA__R16_UH_RX_DMA` writer
        pub type W = crate::W<UEP2_DMA__R16_UH_RX_DMA_SPEC>;
        ///Field `UEP2_DMA` reader - RW,endpoint 2 DMA buffer address;host rx endpoint buffer high address
        pub type UEP2_DMA_R = crate::FieldReader<u16>;
        ///Field `UEP2_DMA` writer - RW,endpoint 2 DMA buffer address;host rx endpoint buffer high address
        pub type UEP2_DMA_W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            ///Bits 0:15 - RW,endpoint 2 DMA buffer address;host rx endpoint buffer high address
            #[inline(always)]
            pub fn uep2_dma(&self) -> UEP2_DMA_R {
                UEP2_DMA_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - RW,endpoint 2 DMA buffer address;host rx endpoint buffer high address
            #[inline(always)]
            #[must_use]
            pub fn uep2_dma(&mut self) -> UEP2_DMA_W<UEP2_DMA__R16_UH_RX_DMA_SPEC> {
                UEP2_DMA_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///endpoint 2 DMA buffer address;host rx endpoint buffer high address
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`uep2_dma__r16_uh_rx_dma::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep2_dma__r16_uh_rx_dma::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct UEP2_DMA__R16_UH_RX_DMA_SPEC;
        impl crate::RegisterSpec for UEP2_DMA__R16_UH_RX_DMA_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`uep2_dma__r16_uh_rx_dma::R`](R) reader structure
        impl crate::Readable for UEP2_DMA__R16_UH_RX_DMA_SPEC {}
        ///`write(|w| ..)` method takes [`uep2_dma__r16_uh_rx_dma::W`](W) writer structure
        impl crate::Writable for UEP2_DMA__R16_UH_RX_DMA_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets UEP2_DMA__R16_UH_RX_DMA to value 0
        impl crate::Resettable for UEP2_DMA__R16_UH_RX_DMA_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///UEP3_DMA__R16_UH_TX_DMA (rw) register accessor: endpoint 3 DMA buffer address;host tx endpoint buffer high address
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`uep3_dma__r16_uh_tx_dma::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep3_dma__r16_uh_tx_dma::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@uep3_dma__r16_uh_tx_dma`]
    ///module
    pub type UEP3_DMA__R16_UH_TX_DMA =
        crate::Reg<uep3_dma__r16_uh_tx_dma::UEP3_DMA__R16_UH_TX_DMA_SPEC>;
    ///endpoint 3 DMA buffer address;host tx endpoint buffer high address
    pub mod uep3_dma__r16_uh_tx_dma {
        ///Register `UEP3_DMA__R16_UH_TX_DMA` reader
        pub type R = crate::R<UEP3_DMA__R16_UH_TX_DMA_SPEC>;
        ///Register `UEP3_DMA__R16_UH_TX_DMA` writer
        pub type W = crate::W<UEP3_DMA__R16_UH_TX_DMA_SPEC>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<UEP3_DMA__R16_UH_TX_DMA_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                core::fmt::Debug::fmt(&self.read(), f)
            }
        }
        impl W {
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///endpoint 3 DMA buffer address;host tx endpoint buffer high address
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`uep3_dma__r16_uh_tx_dma::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep3_dma__r16_uh_tx_dma::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct UEP3_DMA__R16_UH_TX_DMA_SPEC;
        impl crate::RegisterSpec for UEP3_DMA__R16_UH_TX_DMA_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`uep3_dma__r16_uh_tx_dma::R`](R) reader structure
        impl crate::Readable for UEP3_DMA__R16_UH_TX_DMA_SPEC {}
        ///`write(|w| ..)` method takes [`uep3_dma__r16_uh_tx_dma::W`](W) writer structure
        impl crate::Writable for UEP3_DMA__R16_UH_TX_DMA_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets UEP3_DMA__R16_UH_TX_DMA to value 0
        impl crate::Resettable for UEP3_DMA__R16_UH_TX_DMA_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///UEP0_T_LEN (rw) register accessor: endpoint 0 transmittal length
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`uep0_t_len::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep0_t_len::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@uep0_t_len`]
    ///module
    pub type UEP0_T_LEN = crate::Reg<uep0_t_len::UEP0_T_LEN_SPEC>;
    ///endpoint 0 transmittal length
    pub mod uep0_t_len {
        ///Register `UEP0_T_LEN` reader
        pub type R = crate::R<UEP0_T_LEN_SPEC>;
        ///Register `UEP0_T_LEN` writer
        pub type W = crate::W<UEP0_T_LEN_SPEC>;
        ///Field `UEP0_T_LEN` reader - endpoint 0 transmittal length
        pub type UEP0_T_LEN_R = crate::FieldReader;
        ///Field `UEP0_T_LEN` writer - endpoint 0 transmittal length
        pub type UEP0_T_LEN_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            ///Bits 0:7 - endpoint 0 transmittal length
            #[inline(always)]
            pub fn uep0_t_len(&self) -> UEP0_T_LEN_R {
                UEP0_T_LEN_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:7 - endpoint 0 transmittal length
            #[inline(always)]
            #[must_use]
            pub fn uep0_t_len(&mut self) -> UEP0_T_LEN_W<UEP0_T_LEN_SPEC> {
                UEP0_T_LEN_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///endpoint 0 transmittal length
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`uep0_t_len::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep0_t_len::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct UEP0_T_LEN_SPEC;
        impl crate::RegisterSpec for UEP0_T_LEN_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`uep0_t_len::R`](R) reader structure
        impl crate::Readable for UEP0_T_LEN_SPEC {}
        ///`write(|w| ..)` method takes [`uep0_t_len::W`](W) writer structure
        impl crate::Writable for UEP0_T_LEN_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets UEP0_T_LEN to value 0
        impl crate::Resettable for UEP0_T_LEN_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///UEP0_CTRL (rw) register accessor: endpoint 0 control
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`uep0_ctrl::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep0_ctrl::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@uep0_ctrl`]
    ///module
    pub type UEP0_CTRL = crate::Reg<uep0_ctrl::UEP0_CTRL_SPEC>;
    ///endpoint 0 control
    pub mod uep0_ctrl {
        ///Register `UEP0_CTRL` reader
        pub type R = crate::R<UEP0_CTRL_SPEC>;
        ///Register `UEP0_CTRL` writer
        pub type W = crate::W<UEP0_CTRL_SPEC>;
        ///Field `MASK_UEP_T_RES` reader - bit mask of handshake response type for USB endpoint X transmittal (IN)
        pub type MASK_UEP_T_RES_R = crate::FieldReader;
        ///Field `MASK_UEP_T_RES` writer - bit mask of handshake response type for USB endpoint X transmittal (IN)
        pub type MASK_UEP_T_RES_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `MASK_UEP_R_RES` reader - bit mask of handshake response type for USB endpoint X receiving (OUT)
        pub type MASK_UEP_R_RES_R = crate::FieldReader;
        ///Field `MASK_UEP_R_RES` writer - bit mask of handshake response type for USB endpoint X receiving (OUT)
        pub type MASK_UEP_R_RES_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `UEP_AUTO_TOG` reader - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
        pub type UEP_AUTO_TOG_R = crate::BitReader;
        ///Field `UEP_AUTO_TOG` writer - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
        pub type UEP_AUTO_TOG_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UEP_T_TOG` reader - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
        pub type UEP_T_TOG_R = crate::BitReader;
        ///Field `UEP_T_TOG` writer - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
        pub type UEP_T_TOG_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UEP_R_TOG` reader - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
        pub type UEP_R_TOG_R = crate::BitReader;
        ///Field `UEP_R_TOG` writer - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
        pub type UEP_R_TOG_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)
            #[inline(always)]
            pub fn mask_uep_t_res(&self) -> MASK_UEP_T_RES_R {
                MASK_UEP_T_RES_R::new(self.bits & 3)
            }
            ///Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)
            #[inline(always)]
            pub fn mask_uep_r_res(&self) -> MASK_UEP_R_RES_R {
                MASK_UEP_R_RES_R::new((self.bits >> 2) & 3)
            }
            ///Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
            #[inline(always)]
            pub fn uep_auto_tog(&self) -> UEP_AUTO_TOG_R {
                UEP_AUTO_TOG_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
            #[inline(always)]
            pub fn uep_t_tog(&self) -> UEP_T_TOG_R {
                UEP_T_TOG_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
            #[inline(always)]
            pub fn uep_r_tog(&self) -> UEP_R_TOG_R {
                UEP_R_TOG_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)
            #[inline(always)]
            #[must_use]
            pub fn mask_uep_t_res(&mut self) -> MASK_UEP_T_RES_W<UEP0_CTRL_SPEC> {
                MASK_UEP_T_RES_W::new(self, 0)
            }
            ///Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)
            #[inline(always)]
            #[must_use]
            pub fn mask_uep_r_res(&mut self) -> MASK_UEP_R_RES_W<UEP0_CTRL_SPEC> {
                MASK_UEP_R_RES_W::new(self, 2)
            }
            ///Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
            #[inline(always)]
            #[must_use]
            pub fn uep_auto_tog(&mut self) -> UEP_AUTO_TOG_W<UEP0_CTRL_SPEC> {
                UEP_AUTO_TOG_W::new(self, 4)
            }
            ///Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
            #[inline(always)]
            #[must_use]
            pub fn uep_t_tog(&mut self) -> UEP_T_TOG_W<UEP0_CTRL_SPEC> {
                UEP_T_TOG_W::new(self, 6)
            }
            ///Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
            #[inline(always)]
            #[must_use]
            pub fn uep_r_tog(&mut self) -> UEP_R_TOG_W<UEP0_CTRL_SPEC> {
                UEP_R_TOG_W::new(self, 7)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///endpoint 0 control
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`uep0_ctrl::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep0_ctrl::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct UEP0_CTRL_SPEC;
        impl crate::RegisterSpec for UEP0_CTRL_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`uep0_ctrl::R`](R) reader structure
        impl crate::Readable for UEP0_CTRL_SPEC {}
        ///`write(|w| ..)` method takes [`uep0_ctrl::W`](W) writer structure
        impl crate::Writable for UEP0_CTRL_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets UEP0_CTRL to value 0
        impl crate::Resettable for UEP0_CTRL_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///UEP1_T_LEN (rw) register accessor: endpoint 1 transmittal length
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`uep1_t_len::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep1_t_len::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@uep1_t_len`]
    ///module
    pub type UEP1_T_LEN = crate::Reg<uep1_t_len::UEP1_T_LEN_SPEC>;
    ///endpoint 1 transmittal length
    pub mod uep1_t_len {
        ///Register `UEP1_T_LEN` reader
        pub type R = crate::R<UEP1_T_LEN_SPEC>;
        ///Register `UEP1_T_LEN` writer
        pub type W = crate::W<UEP1_T_LEN_SPEC>;
        ///Field `UEP1_T_LEN` reader - endpoint 1 transmittal length
        pub type UEP1_T_LEN_R = crate::FieldReader;
        ///Field `UEP1_T_LEN` writer - endpoint 1 transmittal length
        pub type UEP1_T_LEN_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            ///Bits 0:7 - endpoint 1 transmittal length
            #[inline(always)]
            pub fn uep1_t_len(&self) -> UEP1_T_LEN_R {
                UEP1_T_LEN_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:7 - endpoint 1 transmittal length
            #[inline(always)]
            #[must_use]
            pub fn uep1_t_len(&mut self) -> UEP1_T_LEN_W<UEP1_T_LEN_SPEC> {
                UEP1_T_LEN_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///endpoint 1 transmittal length
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`uep1_t_len::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep1_t_len::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct UEP1_T_LEN_SPEC;
        impl crate::RegisterSpec for UEP1_T_LEN_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`uep1_t_len::R`](R) reader structure
        impl crate::Readable for UEP1_T_LEN_SPEC {}
        ///`write(|w| ..)` method takes [`uep1_t_len::W`](W) writer structure
        impl crate::Writable for UEP1_T_LEN_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets UEP1_T_LEN to value 0
        impl crate::Resettable for UEP1_T_LEN_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///UEP1_CTRL__R8_UH_SETUP (rw) register accessor: endpoint 1 control;host aux setup
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`uep1_ctrl__r8_uh_setup::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep1_ctrl__r8_uh_setup::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@uep1_ctrl__r8_uh_setup`]
    ///module
    pub type UEP1_CTRL__R8_UH_SETUP =
        crate::Reg<uep1_ctrl__r8_uh_setup::UEP1_CTRL__R8_UH_SETUP_SPEC>;
    ///endpoint 1 control;host aux setup
    pub mod uep1_ctrl__r8_uh_setup {
        ///Register `UEP1_CTRL__R8_UH_SETUP` reader
        pub type R = crate::R<UEP1_CTRL__R8_UH_SETUP_SPEC>;
        ///Register `UEP1_CTRL__R8_UH_SETUP` writer
        pub type W = crate::W<UEP1_CTRL__R8_UH_SETUP_SPEC>;
        ///Field `MASK_UEP_T_RES` reader - bit mask of handshake response type for USB endpoint X transmittal (IN)
        pub type MASK_UEP_T_RES_R = crate::FieldReader;
        ///Field `MASK_UEP_T_RES` writer - bit mask of handshake response type for USB endpoint X transmittal (IN)
        pub type MASK_UEP_T_RES_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `MASK_UEP_R_RES` reader - bit mask of handshake response type for USB endpoint X receiving (OUT)
        pub type MASK_UEP_R_RES_R = crate::FieldReader;
        ///Field `MASK_UEP_R_RES` writer - bit mask of handshake response type for USB endpoint X receiving (OUT)
        pub type MASK_UEP_R_RES_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `UEP_AUTO_TOG` reader - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
        pub type UEP_AUTO_TOG_R = crate::BitReader;
        ///Field `UEP_AUTO_TOG` writer - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
        pub type UEP_AUTO_TOG_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UEP_T_TOG__RB_UH_SOF_EN` reader - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1;USB host automatic SOF enable
        pub type UEP_T_TOG__RB_UH_SOF_EN_R = crate::BitReader;
        ///Field `UEP_T_TOG__RB_UH_SOF_EN` writer - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1;USB host automatic SOF enable
        pub type UEP_T_TOG__RB_UH_SOF_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UEP_R_TOG__RB_UH_PRE_PID_EN` reader - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1;RB_UH_PRE_PID_EN;USB host PRE PID enable for low speed device via hub
        pub type UEP_R_TOG__RB_UH_PRE_PID_EN_R = crate::BitReader;
        ///Field `UEP_R_TOG__RB_UH_PRE_PID_EN` writer - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1;RB_UH_PRE_PID_EN;USB host PRE PID enable for low speed device via hub
        pub type UEP_R_TOG__RB_UH_PRE_PID_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)
            #[inline(always)]
            pub fn mask_uep_t_res(&self) -> MASK_UEP_T_RES_R {
                MASK_UEP_T_RES_R::new(self.bits & 3)
            }
            ///Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)
            #[inline(always)]
            pub fn mask_uep_r_res(&self) -> MASK_UEP_R_RES_R {
                MASK_UEP_R_RES_R::new((self.bits >> 2) & 3)
            }
            ///Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
            #[inline(always)]
            pub fn uep_auto_tog(&self) -> UEP_AUTO_TOG_R {
                UEP_AUTO_TOG_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1;USB host automatic SOF enable
            #[inline(always)]
            pub fn uep_t_tog__rb_uh_sof_en(&self) -> UEP_T_TOG__RB_UH_SOF_EN_R {
                UEP_T_TOG__RB_UH_SOF_EN_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1;RB_UH_PRE_PID_EN;USB host PRE PID enable for low speed device via hub
            #[inline(always)]
            pub fn uep_r_tog__rb_uh_pre_pid_en(&self) -> UEP_R_TOG__RB_UH_PRE_PID_EN_R {
                UEP_R_TOG__RB_UH_PRE_PID_EN_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)
            #[inline(always)]
            #[must_use]
            pub fn mask_uep_t_res(&mut self) -> MASK_UEP_T_RES_W<UEP1_CTRL__R8_UH_SETUP_SPEC> {
                MASK_UEP_T_RES_W::new(self, 0)
            }
            ///Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)
            #[inline(always)]
            #[must_use]
            pub fn mask_uep_r_res(&mut self) -> MASK_UEP_R_RES_W<UEP1_CTRL__R8_UH_SETUP_SPEC> {
                MASK_UEP_R_RES_W::new(self, 2)
            }
            ///Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
            #[inline(always)]
            #[must_use]
            pub fn uep_auto_tog(&mut self) -> UEP_AUTO_TOG_W<UEP1_CTRL__R8_UH_SETUP_SPEC> {
                UEP_AUTO_TOG_W::new(self, 4)
            }
            ///Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1;USB host automatic SOF enable
            #[inline(always)]
            #[must_use]
            pub fn uep_t_tog__rb_uh_sof_en(
                &mut self,
            ) -> UEP_T_TOG__RB_UH_SOF_EN_W<UEP1_CTRL__R8_UH_SETUP_SPEC> {
                UEP_T_TOG__RB_UH_SOF_EN_W::new(self, 6)
            }
            ///Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1;RB_UH_PRE_PID_EN;USB host PRE PID enable for low speed device via hub
            #[inline(always)]
            #[must_use]
            pub fn uep_r_tog__rb_uh_pre_pid_en(
                &mut self,
            ) -> UEP_R_TOG__RB_UH_PRE_PID_EN_W<UEP1_CTRL__R8_UH_SETUP_SPEC> {
                UEP_R_TOG__RB_UH_PRE_PID_EN_W::new(self, 7)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///endpoint 1 control;host aux setup
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`uep1_ctrl__r8_uh_setup::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep1_ctrl__r8_uh_setup::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct UEP1_CTRL__R8_UH_SETUP_SPEC;
        impl crate::RegisterSpec for UEP1_CTRL__R8_UH_SETUP_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`uep1_ctrl__r8_uh_setup::R`](R) reader structure
        impl crate::Readable for UEP1_CTRL__R8_UH_SETUP_SPEC {}
        ///`write(|w| ..)` method takes [`uep1_ctrl__r8_uh_setup::W`](W) writer structure
        impl crate::Writable for UEP1_CTRL__R8_UH_SETUP_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets UEP1_CTRL__R8_UH_SETUP to value 0
        impl crate::Resettable for UEP1_CTRL__R8_UH_SETUP_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///UEP2_T_LEN_R8_UH_EP_PID (rw) register accessor: endpoint 2 transmittal length;host endpoint and PID
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`uep2_t_len_r8_uh_ep_pid::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep2_t_len_r8_uh_ep_pid::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@uep2_t_len_r8_uh_ep_pid`]
    ///module
    pub type UEP2_T_LEN_R8_UH_EP_PID =
        crate::Reg<uep2_t_len_r8_uh_ep_pid::UEP2_T_LEN_R8_UH_EP_PID_SPEC>;
    ///endpoint 2 transmittal length;host endpoint and PID
    pub mod uep2_t_len_r8_uh_ep_pid {
        ///Register `UEP2_T_LEN_R8_UH_EP_PID` reader
        pub type R = crate::R<UEP2_T_LEN_R8_UH_EP_PID_SPEC>;
        ///Register `UEP2_T_LEN_R8_UH_EP_PID` writer
        pub type W = crate::W<UEP2_T_LEN_R8_UH_EP_PID_SPEC>;
        ///Field `MASK_UH_ENDP` reader - bit mask of endpoint number for USB host transfer
        pub type MASK_UH_ENDP_R = crate::FieldReader;
        ///Field `MASK_UH_ENDP` writer - bit mask of endpoint number for USB host transfer
        pub type MASK_UH_ENDP_W<'a, REG> = crate::FieldWriter<'a, REG, 4>;
        ///Field `UEP2_T_LEN` reader - endpoint 2 transmittal length;
        pub type UEP2_T_LEN_R = crate::FieldReader;
        ///Field `UEP2_T_LEN` writer - endpoint 2 transmittal length;
        pub type UEP2_T_LEN_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        ///Field `MASK_UH_TOKEN` reader - bit mask of token PID for USB host transfer
        pub type MASK_UH_TOKEN_R = crate::FieldReader;
        ///Field `MASK_UH_TOKEN` writer - bit mask of token PID for USB host transfer
        pub type MASK_UH_TOKEN_W<'a, REG> = crate::FieldWriter<'a, REG, 4>;
        impl R {
            ///Bits 0:3 - bit mask of endpoint number for USB host transfer
            #[inline(always)]
            pub fn mask_uh_endp(&self) -> MASK_UH_ENDP_R {
                MASK_UH_ENDP_R::new(self.bits & 0x0f)
            }
            ///Bits 0:7 - endpoint 2 transmittal length;
            #[inline(always)]
            pub fn uep2_t_len(&self) -> UEP2_T_LEN_R {
                UEP2_T_LEN_R::new(self.bits)
            }
            ///Bits 4:7 - bit mask of token PID for USB host transfer
            #[inline(always)]
            pub fn mask_uh_token(&self) -> MASK_UH_TOKEN_R {
                MASK_UH_TOKEN_R::new((self.bits >> 4) & 0x0f)
            }
        }
        impl W {
            ///Bits 0:3 - bit mask of endpoint number for USB host transfer
            #[inline(always)]
            #[must_use]
            pub fn mask_uh_endp(&mut self) -> MASK_UH_ENDP_W<UEP2_T_LEN_R8_UH_EP_PID_SPEC> {
                MASK_UH_ENDP_W::new(self, 0)
            }
            ///Bits 0:7 - endpoint 2 transmittal length;
            #[inline(always)]
            #[must_use]
            pub fn uep2_t_len(&mut self) -> UEP2_T_LEN_W<UEP2_T_LEN_R8_UH_EP_PID_SPEC> {
                UEP2_T_LEN_W::new(self, 0)
            }
            ///Bits 4:7 - bit mask of token PID for USB host transfer
            #[inline(always)]
            #[must_use]
            pub fn mask_uh_token(&mut self) -> MASK_UH_TOKEN_W<UEP2_T_LEN_R8_UH_EP_PID_SPEC> {
                MASK_UH_TOKEN_W::new(self, 4)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///endpoint 2 transmittal length;host endpoint and PID
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`uep2_t_len_r8_uh_ep_pid::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep2_t_len_r8_uh_ep_pid::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct UEP2_T_LEN_R8_UH_EP_PID_SPEC;
        impl crate::RegisterSpec for UEP2_T_LEN_R8_UH_EP_PID_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`uep2_t_len_r8_uh_ep_pid::R`](R) reader structure
        impl crate::Readable for UEP2_T_LEN_R8_UH_EP_PID_SPEC {}
        ///`write(|w| ..)` method takes [`uep2_t_len_r8_uh_ep_pid::W`](W) writer structure
        impl crate::Writable for UEP2_T_LEN_R8_UH_EP_PID_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets UEP2_T_LEN_R8_UH_EP_PID to value 0
        impl crate::Resettable for UEP2_T_LEN_R8_UH_EP_PID_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///UEP2_CTRL_R8_UH_RX_CTRL (rw) register accessor: endpoint 2 control;host receiver endpoint control
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`uep2_ctrl_r8_uh_rx_ctrl::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep2_ctrl_r8_uh_rx_ctrl::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@uep2_ctrl_r8_uh_rx_ctrl`]
    ///module
    pub type UEP2_CTRL_R8_UH_RX_CTRL =
        crate::Reg<uep2_ctrl_r8_uh_rx_ctrl::UEP2_CTRL_R8_UH_RX_CTRL_SPEC>;
    ///endpoint 2 control;host receiver endpoint control
    pub mod uep2_ctrl_r8_uh_rx_ctrl {
        ///Register `UEP2_CTRL_R8_UH_RX_CTRL` reader
        pub type R = crate::R<UEP2_CTRL_R8_UH_RX_CTRL_SPEC>;
        ///Register `UEP2_CTRL_R8_UH_RX_CTRL` writer
        pub type W = crate::W<UEP2_CTRL_R8_UH_RX_CTRL_SPEC>;
        ///Field `MASK_UEP_T_RES` reader - bit mask of handshake response type for USB endpoint X transmittal (IN)
        pub type MASK_UEP_T_RES_R = crate::FieldReader;
        ///Field `MASK_UEP_T_RES` writer - bit mask of handshake response type for USB endpoint X transmittal (IN)
        pub type MASK_UEP_T_RES_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `MASK_UH_R_RES` reader - bit mask of handshake response type for USB endpoint X receiving (OUT)
        pub type MASK_UH_R_RES_R = crate::BitReader;
        ///Field `MASK_UH_R_RES` writer - bit mask of handshake response type for USB endpoint X receiving (OUT)
        pub type MASK_UH_R_RES_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `MASK_UEP_R_RES` reader - bit mask of handshake response type for USB endpoint X receiving (OUT)
        pub type MASK_UEP_R_RES_R = crate::FieldReader;
        ///Field `MASK_UEP_R_RES` writer - bit mask of handshake response type for USB endpoint X receiving (OUT)
        pub type MASK_UEP_R_RES_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `UEP_AUTO_TOG__RB_UH_R_AUTO_TOG` reader - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle;enable automatic toggle after successful transfer completion: 0=manual toggle, 1=automatic toggle
        pub type UEP_AUTO_TOG__RB_UH_R_AUTO_TOG_R = crate::BitReader;
        ///Field `UEP_AUTO_TOG__RB_UH_R_AUTO_TOG` writer - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle;enable automatic toggle after successful transfer completion: 0=manual toggle, 1=automatic toggle
        pub type UEP_AUTO_TOG__RB_UH_R_AUTO_TOG_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UEP_T_TOG` reader - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
        pub type UEP_T_TOG_R = crate::BitReader;
        ///Field `UEP_T_TOG` writer - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
        pub type UEP_T_TOG_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UEP_R_TOG__RB_UH_R_TOG` reader - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1;expected data toggle flag of host receiving (IN): 0=DATA0, 1=DATA1
        pub type UEP_R_TOG__RB_UH_R_TOG_R = crate::BitReader;
        ///Field `UEP_R_TOG__RB_UH_R_TOG` writer - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1;expected data toggle flag of host receiving (IN): 0=DATA0, 1=DATA1
        pub type UEP_R_TOG__RB_UH_R_TOG_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)
            #[inline(always)]
            pub fn mask_uep_t_res(&self) -> MASK_UEP_T_RES_R {
                MASK_UEP_T_RES_R::new(self.bits & 3)
            }
            ///Bit 2 - bit mask of handshake response type for USB endpoint X receiving (OUT)
            #[inline(always)]
            pub fn mask_uh_r_res(&self) -> MASK_UH_R_RES_R {
                MASK_UH_R_RES_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)
            #[inline(always)]
            pub fn mask_uep_r_res(&self) -> MASK_UEP_R_RES_R {
                MASK_UEP_R_RES_R::new((self.bits >> 2) & 3)
            }
            ///Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle;enable automatic toggle after successful transfer completion: 0=manual toggle, 1=automatic toggle
            #[inline(always)]
            pub fn uep_auto_tog__rb_uh_r_auto_tog(&self) -> UEP_AUTO_TOG__RB_UH_R_AUTO_TOG_R {
                UEP_AUTO_TOG__RB_UH_R_AUTO_TOG_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
            #[inline(always)]
            pub fn uep_t_tog(&self) -> UEP_T_TOG_R {
                UEP_T_TOG_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1;expected data toggle flag of host receiving (IN): 0=DATA0, 1=DATA1
            #[inline(always)]
            pub fn uep_r_tog__rb_uh_r_tog(&self) -> UEP_R_TOG__RB_UH_R_TOG_R {
                UEP_R_TOG__RB_UH_R_TOG_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)
            #[inline(always)]
            #[must_use]
            pub fn mask_uep_t_res(&mut self) -> MASK_UEP_T_RES_W<UEP2_CTRL_R8_UH_RX_CTRL_SPEC> {
                MASK_UEP_T_RES_W::new(self, 0)
            }
            ///Bit 2 - bit mask of handshake response type for USB endpoint X receiving (OUT)
            #[inline(always)]
            #[must_use]
            pub fn mask_uh_r_res(&mut self) -> MASK_UH_R_RES_W<UEP2_CTRL_R8_UH_RX_CTRL_SPEC> {
                MASK_UH_R_RES_W::new(self, 2)
            }
            ///Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)
            #[inline(always)]
            #[must_use]
            pub fn mask_uep_r_res(&mut self) -> MASK_UEP_R_RES_W<UEP2_CTRL_R8_UH_RX_CTRL_SPEC> {
                MASK_UEP_R_RES_W::new(self, 2)
            }
            ///Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle;enable automatic toggle after successful transfer completion: 0=manual toggle, 1=automatic toggle
            #[inline(always)]
            #[must_use]
            pub fn uep_auto_tog__rb_uh_r_auto_tog(
                &mut self,
            ) -> UEP_AUTO_TOG__RB_UH_R_AUTO_TOG_W<UEP2_CTRL_R8_UH_RX_CTRL_SPEC> {
                UEP_AUTO_TOG__RB_UH_R_AUTO_TOG_W::new(self, 4)
            }
            ///Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
            #[inline(always)]
            #[must_use]
            pub fn uep_t_tog(&mut self) -> UEP_T_TOG_W<UEP2_CTRL_R8_UH_RX_CTRL_SPEC> {
                UEP_T_TOG_W::new(self, 6)
            }
            ///Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1;expected data toggle flag of host receiving (IN): 0=DATA0, 1=DATA1
            #[inline(always)]
            #[must_use]
            pub fn uep_r_tog__rb_uh_r_tog(
                &mut self,
            ) -> UEP_R_TOG__RB_UH_R_TOG_W<UEP2_CTRL_R8_UH_RX_CTRL_SPEC> {
                UEP_R_TOG__RB_UH_R_TOG_W::new(self, 7)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///endpoint 2 control;host receiver endpoint control
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`uep2_ctrl_r8_uh_rx_ctrl::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep2_ctrl_r8_uh_rx_ctrl::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct UEP2_CTRL_R8_UH_RX_CTRL_SPEC;
        impl crate::RegisterSpec for UEP2_CTRL_R8_UH_RX_CTRL_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`uep2_ctrl_r8_uh_rx_ctrl::R`](R) reader structure
        impl crate::Readable for UEP2_CTRL_R8_UH_RX_CTRL_SPEC {}
        ///`write(|w| ..)` method takes [`uep2_ctrl_r8_uh_rx_ctrl::W`](W) writer structure
        impl crate::Writable for UEP2_CTRL_R8_UH_RX_CTRL_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets UEP2_CTRL_R8_UH_RX_CTRL to value 0
        impl crate::Resettable for UEP2_CTRL_R8_UH_RX_CTRL_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///UEP3_T_LEN__R8_UH_TX_LEN (rw) register accessor: endpoint 3 transmittal length;host transmittal endpoint transmittal length
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`uep3_t_len__r8_uh_tx_len::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep3_t_len__r8_uh_tx_len::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@uep3_t_len__r8_uh_tx_len`]
    ///module
    pub type UEP3_T_LEN__R8_UH_TX_LEN =
        crate::Reg<uep3_t_len__r8_uh_tx_len::UEP3_T_LEN__R8_UH_TX_LEN_SPEC>;
    ///endpoint 3 transmittal length;host transmittal endpoint transmittal length
    pub mod uep3_t_len__r8_uh_tx_len {
        ///Register `UEP3_T_LEN__R8_UH_TX_LEN` reader
        pub type R = crate::R<UEP3_T_LEN__R8_UH_TX_LEN_SPEC>;
        ///Register `UEP3_T_LEN__R8_UH_TX_LEN` writer
        pub type W = crate::W<UEP3_T_LEN__R8_UH_TX_LEN_SPEC>;
        ///Field `UEP3_T_LEN__R8_UH_TX_LEN` reader - endpoint 1 transmittal length
        pub type UEP3_T_LEN__R8_UH_TX_LEN_R = crate::FieldReader;
        ///Field `UEP3_T_LEN__R8_UH_TX_LEN` writer - endpoint 1 transmittal length
        pub type UEP3_T_LEN__R8_UH_TX_LEN_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            ///Bits 0:7 - endpoint 1 transmittal length
            #[inline(always)]
            pub fn uep3_t_len__r8_uh_tx_len(&self) -> UEP3_T_LEN__R8_UH_TX_LEN_R {
                UEP3_T_LEN__R8_UH_TX_LEN_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:7 - endpoint 1 transmittal length
            #[inline(always)]
            #[must_use]
            pub fn uep3_t_len__r8_uh_tx_len(
                &mut self,
            ) -> UEP3_T_LEN__R8_UH_TX_LEN_W<UEP3_T_LEN__R8_UH_TX_LEN_SPEC> {
                UEP3_T_LEN__R8_UH_TX_LEN_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///endpoint 3 transmittal length;host transmittal endpoint transmittal length
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`uep3_t_len__r8_uh_tx_len::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep3_t_len__r8_uh_tx_len::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct UEP3_T_LEN__R8_UH_TX_LEN_SPEC;
        impl crate::RegisterSpec for UEP3_T_LEN__R8_UH_TX_LEN_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`uep3_t_len__r8_uh_tx_len::R`](R) reader structure
        impl crate::Readable for UEP3_T_LEN__R8_UH_TX_LEN_SPEC {}
        ///`write(|w| ..)` method takes [`uep3_t_len__r8_uh_tx_len::W`](W) writer structure
        impl crate::Writable for UEP3_T_LEN__R8_UH_TX_LEN_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets UEP3_T_LEN__R8_UH_TX_LEN to value 0
        impl crate::Resettable for UEP3_T_LEN__R8_UH_TX_LEN_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///UEP3_CTRL__R8_UH_TX_CTRL (rw) register accessor: endpoint 3 control;host transmittal endpoint control
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`uep3_ctrl__r8_uh_tx_ctrl::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep3_ctrl__r8_uh_tx_ctrl::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@uep3_ctrl__r8_uh_tx_ctrl`]
    ///module
    pub type UEP3_CTRL__R8_UH_TX_CTRL =
        crate::Reg<uep3_ctrl__r8_uh_tx_ctrl::UEP3_CTRL__R8_UH_TX_CTRL_SPEC>;
    ///endpoint 3 control;host transmittal endpoint control
    pub mod uep3_ctrl__r8_uh_tx_ctrl {
        ///Register `UEP3_CTRL__R8_UH_TX_CTRL` reader
        pub type R = crate::R<UEP3_CTRL__R8_UH_TX_CTRL_SPEC>;
        ///Register `UEP3_CTRL__R8_UH_TX_CTRL` writer
        pub type W = crate::W<UEP3_CTRL__R8_UH_TX_CTRL_SPEC>;
        ///Field `UH_T_RES` reader - bit mask of handshake response type for USB endpoint X transmittal (IN)
        pub type UH_T_RES_R = crate::FieldReader;
        ///Field `UH_T_RES` writer - bit mask of handshake response type for USB endpoint X transmittal (IN)
        pub type UH_T_RES_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `MASK_UEP_T_RES` reader - bit mask of handshake response type for USB endpoint X transmittal (IN)
        pub type MASK_UEP_T_RES_R = crate::FieldReader;
        ///Field `MASK_UEP_T_RES` writer - bit mask of handshake response type for USB endpoint X transmittal (IN)
        pub type MASK_UEP_T_RES_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `MASK_UEP_R_RES` reader - bit mask of handshake response type for USB endpoint X receiving (OUT)
        pub type MASK_UEP_R_RES_R = crate::FieldReader;
        ///Field `MASK_UEP_R_RES` writer - bit mask of handshake response type for USB endpoint X receiving (OUT)
        pub type MASK_UEP_R_RES_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `UEP_AUTO_TOG_RB_UH_T_AUTO_TOG` reader - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
        pub type UEP_AUTO_TOG_RB_UH_T_AUTO_TOG_R = crate::BitReader;
        ///Field `UEP_AUTO_TOG_RB_UH_T_AUTO_TOG` writer - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
        pub type UEP_AUTO_TOG_RB_UH_T_AUTO_TOG_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UEP_T_TOG_RB_UH_T_TOG` reader - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
        pub type UEP_T_TOG_RB_UH_T_TOG_R = crate::BitReader;
        ///Field `UEP_T_TOG_RB_UH_T_TOG` writer - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
        pub type UEP_T_TOG_RB_UH_T_TOG_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UEP_R_TOG` reader - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
        pub type UEP_R_TOG_R = crate::BitReader;
        ///Field `UEP_R_TOG` writer - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
        pub type UEP_R_TOG_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)
            #[inline(always)]
            pub fn uh_t_res(&self) -> UH_T_RES_R {
                UH_T_RES_R::new(self.bits & 3)
            }
            ///Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)
            #[inline(always)]
            pub fn mask_uep_t_res(&self) -> MASK_UEP_T_RES_R {
                MASK_UEP_T_RES_R::new(self.bits & 3)
            }
            ///Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)
            #[inline(always)]
            pub fn mask_uep_r_res(&self) -> MASK_UEP_R_RES_R {
                MASK_UEP_R_RES_R::new((self.bits >> 2) & 3)
            }
            ///Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
            #[inline(always)]
            pub fn uep_auto_tog_rb_uh_t_auto_tog(&self) -> UEP_AUTO_TOG_RB_UH_T_AUTO_TOG_R {
                UEP_AUTO_TOG_RB_UH_T_AUTO_TOG_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
            #[inline(always)]
            pub fn uep_t_tog_rb_uh_t_tog(&self) -> UEP_T_TOG_RB_UH_T_TOG_R {
                UEP_T_TOG_RB_UH_T_TOG_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
            #[inline(always)]
            pub fn uep_r_tog(&self) -> UEP_R_TOG_R {
                UEP_R_TOG_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)
            #[inline(always)]
            #[must_use]
            pub fn uh_t_res(&mut self) -> UH_T_RES_W<UEP3_CTRL__R8_UH_TX_CTRL_SPEC> {
                UH_T_RES_W::new(self, 0)
            }
            ///Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)
            #[inline(always)]
            #[must_use]
            pub fn mask_uep_t_res(&mut self) -> MASK_UEP_T_RES_W<UEP3_CTRL__R8_UH_TX_CTRL_SPEC> {
                MASK_UEP_T_RES_W::new(self, 0)
            }
            ///Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)
            #[inline(always)]
            #[must_use]
            pub fn mask_uep_r_res(&mut self) -> MASK_UEP_R_RES_W<UEP3_CTRL__R8_UH_TX_CTRL_SPEC> {
                MASK_UEP_R_RES_W::new(self, 2)
            }
            ///Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
            #[inline(always)]
            #[must_use]
            pub fn uep_auto_tog_rb_uh_t_auto_tog(
                &mut self,
            ) -> UEP_AUTO_TOG_RB_UH_T_AUTO_TOG_W<UEP3_CTRL__R8_UH_TX_CTRL_SPEC> {
                UEP_AUTO_TOG_RB_UH_T_AUTO_TOG_W::new(self, 4)
            }
            ///Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
            #[inline(always)]
            #[must_use]
            pub fn uep_t_tog_rb_uh_t_tog(
                &mut self,
            ) -> UEP_T_TOG_RB_UH_T_TOG_W<UEP3_CTRL__R8_UH_TX_CTRL_SPEC> {
                UEP_T_TOG_RB_UH_T_TOG_W::new(self, 6)
            }
            ///Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
            #[inline(always)]
            #[must_use]
            pub fn uep_r_tog(&mut self) -> UEP_R_TOG_W<UEP3_CTRL__R8_UH_TX_CTRL_SPEC> {
                UEP_R_TOG_W::new(self, 7)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///endpoint 3 control;host transmittal endpoint control
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`uep3_ctrl__r8_uh_tx_ctrl::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep3_ctrl__r8_uh_tx_ctrl::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct UEP3_CTRL__R8_UH_TX_CTRL_SPEC;
        impl crate::RegisterSpec for UEP3_CTRL__R8_UH_TX_CTRL_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`uep3_ctrl__r8_uh_tx_ctrl::R`](R) reader structure
        impl crate::Readable for UEP3_CTRL__R8_UH_TX_CTRL_SPEC {}
        ///`write(|w| ..)` method takes [`uep3_ctrl__r8_uh_tx_ctrl::W`](W) writer structure
        impl crate::Writable for UEP3_CTRL__R8_UH_TX_CTRL_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets UEP3_CTRL__R8_UH_TX_CTRL to value 0
        impl crate::Resettable for UEP3_CTRL__R8_UH_TX_CTRL_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///UEP4_T_LEN (rw) register accessor: endpoint 4 transmittal length
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`uep4_t_len::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep4_t_len::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@uep4_t_len`]
    ///module
    pub type UEP4_T_LEN = crate::Reg<uep4_t_len::UEP4_T_LEN_SPEC>;
    ///endpoint 4 transmittal length
    pub mod uep4_t_len {
        ///Register `UEP4_T_LEN` reader
        pub type R = crate::R<UEP4_T_LEN_SPEC>;
        ///Register `UEP4_T_LEN` writer
        pub type W = crate::W<UEP4_T_LEN_SPEC>;
        ///Field `UEP4_T_LEN` reader - endpoint 4transmittal length
        pub type UEP4_T_LEN_R = crate::FieldReader;
        ///Field `UEP4_T_LEN` writer - endpoint 4transmittal length
        pub type UEP4_T_LEN_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            ///Bits 0:7 - endpoint 4transmittal length
            #[inline(always)]
            pub fn uep4_t_len(&self) -> UEP4_T_LEN_R {
                UEP4_T_LEN_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:7 - endpoint 4transmittal length
            #[inline(always)]
            #[must_use]
            pub fn uep4_t_len(&mut self) -> UEP4_T_LEN_W<UEP4_T_LEN_SPEC> {
                UEP4_T_LEN_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///endpoint 4 transmittal length
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`uep4_t_len::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep4_t_len::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct UEP4_T_LEN_SPEC;
        impl crate::RegisterSpec for UEP4_T_LEN_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`uep4_t_len::R`](R) reader structure
        impl crate::Readable for UEP4_T_LEN_SPEC {}
        ///`write(|w| ..)` method takes [`uep4_t_len::W`](W) writer structure
        impl crate::Writable for UEP4_T_LEN_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets UEP4_T_LEN to value 0
        impl crate::Resettable for UEP4_T_LEN_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///UEP4_CTRL (rw) register accessor: endpoint 4 control
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`uep4_ctrl::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep4_ctrl::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@uep4_ctrl`]
    ///module
    pub type UEP4_CTRL = crate::Reg<uep4_ctrl::UEP4_CTRL_SPEC>;
    ///endpoint 4 control
    pub mod uep4_ctrl {
        ///Register `UEP4_CTRL` reader
        pub type R = crate::R<UEP4_CTRL_SPEC>;
        ///Register `UEP4_CTRL` writer
        pub type W = crate::W<UEP4_CTRL_SPEC>;
        ///Field `MASK_UEP_T_RES` reader - bit mask of handshake response type for USB endpoint X transmittal (IN)
        pub type MASK_UEP_T_RES_R = crate::FieldReader;
        ///Field `MASK_UEP_T_RES` writer - bit mask of handshake response type for USB endpoint X transmittal (IN)
        pub type MASK_UEP_T_RES_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `MASK_UEP_R_RES` reader - bit mask of handshake response type for USB endpoint X receiving (OUT)
        pub type MASK_UEP_R_RES_R = crate::FieldReader;
        ///Field `MASK_UEP_R_RES` writer - bit mask of handshake response type for USB endpoint X receiving (OUT)
        pub type MASK_UEP_R_RES_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `UEP_AUTO_TOG` reader - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
        pub type UEP_AUTO_TOG_R = crate::BitReader;
        ///Field `UEP_AUTO_TOG` writer - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
        pub type UEP_AUTO_TOG_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UEP_T_TOG` reader - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
        pub type UEP_T_TOG_R = crate::BitReader;
        ///Field `UEP_T_TOG` writer - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
        pub type UEP_T_TOG_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UEP_R_TOG` reader - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
        pub type UEP_R_TOG_R = crate::BitReader;
        ///Field `UEP_R_TOG` writer - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
        pub type UEP_R_TOG_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)
            #[inline(always)]
            pub fn mask_uep_t_res(&self) -> MASK_UEP_T_RES_R {
                MASK_UEP_T_RES_R::new(self.bits & 3)
            }
            ///Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)
            #[inline(always)]
            pub fn mask_uep_r_res(&self) -> MASK_UEP_R_RES_R {
                MASK_UEP_R_RES_R::new((self.bits >> 2) & 3)
            }
            ///Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
            #[inline(always)]
            pub fn uep_auto_tog(&self) -> UEP_AUTO_TOG_R {
                UEP_AUTO_TOG_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
            #[inline(always)]
            pub fn uep_t_tog(&self) -> UEP_T_TOG_R {
                UEP_T_TOG_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
            #[inline(always)]
            pub fn uep_r_tog(&self) -> UEP_R_TOG_R {
                UEP_R_TOG_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)
            #[inline(always)]
            #[must_use]
            pub fn mask_uep_t_res(&mut self) -> MASK_UEP_T_RES_W<UEP4_CTRL_SPEC> {
                MASK_UEP_T_RES_W::new(self, 0)
            }
            ///Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)
            #[inline(always)]
            #[must_use]
            pub fn mask_uep_r_res(&mut self) -> MASK_UEP_R_RES_W<UEP4_CTRL_SPEC> {
                MASK_UEP_R_RES_W::new(self, 2)
            }
            ///Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
            #[inline(always)]
            #[must_use]
            pub fn uep_auto_tog(&mut self) -> UEP_AUTO_TOG_W<UEP4_CTRL_SPEC> {
                UEP_AUTO_TOG_W::new(self, 4)
            }
            ///Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
            #[inline(always)]
            #[must_use]
            pub fn uep_t_tog(&mut self) -> UEP_T_TOG_W<UEP4_CTRL_SPEC> {
                UEP_T_TOG_W::new(self, 6)
            }
            ///Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
            #[inline(always)]
            #[must_use]
            pub fn uep_r_tog(&mut self) -> UEP_R_TOG_W<UEP4_CTRL_SPEC> {
                UEP_R_TOG_W::new(self, 7)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///endpoint 4 control
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`uep4_ctrl::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep4_ctrl::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct UEP4_CTRL_SPEC;
        impl crate::RegisterSpec for UEP4_CTRL_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`uep4_ctrl::R`](R) reader structure
        impl crate::Readable for UEP4_CTRL_SPEC {}
        ///`write(|w| ..)` method takes [`uep4_ctrl::W`](W) writer structure
        impl crate::Writable for UEP4_CTRL_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets UEP4_CTRL to value 0
        impl crate::Resettable for UEP4_CTRL_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
}
///Program Fast Interrupt Controller
pub struct PFIC {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for PFIC {}
impl PFIC {
    ///Pointer to the register block
    pub const PTR: *const pfic::RegisterBlock = 0xe000_e000 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const pfic::RegisterBlock {
        Self::PTR
    }
    /// Steal an instance of this peripheral
    ///
    /// # Safety
    ///
    /// Ensure that the new instance of the peripheral cannot be used in a way
    /// that may race with any existing instances, for example by only
    /// accessing read-only or write-only registers, or by consuming the
    /// original peripheral and using critical sections to coordinate
    /// access between multiple new instances.
    ///
    /// Additionally, other software such as HALs may rely on only one
    /// peripheral instance existing to ensure memory safety; ensure
    /// no stolen instances are passed to such software.
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for PFIC {
    type Target = pfic::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for PFIC {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("PFIC").finish()
    }
}
///Program Fast Interrupt Controller
pub mod pfic {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        isr1: ISR1,
        isr2: ISR2,
        _reserved2: [u8; 0x18],
        ipr1: IPR1,
        ipr2: IPR2,
        _reserved4: [u8; 0x18],
        ithresdr: ITHRESDR,
        fibaddrr: FIBADDRR,
        cfgr: CFGR,
        gisr: GISR,
        _reserved8: [u8; 0x10],
        fifoaddrr0: FIFOADDRR0,
        fifoaddrr1: FIFOADDRR1,
        fifoaddrr2: FIFOADDRR2,
        fifoaddrr3: FIFOADDRR3,
        _reserved12: [u8; 0x90],
        ienr1: IENR1,
        ienr2: IENR2,
        _reserved14: [u8; 0x78],
        irer1: IRER1,
        irer2: IRER2,
        _reserved16: [u8; 0x78],
        ipsr1: IPSR1,
        ipsr2: IPSR2,
        _reserved18: [u8; 0x78],
        iprr1: IPRR1,
        iprr2: IPRR2,
        _reserved20: [u8; 0x78],
        iactr1: IACTR1,
        iactr2: IACTR2,
        _reserved22: [u8; 0xf8],
        iprior0: IPRIOR0,
        _reserved23: [u8; 0x1c],
        iprior1: IPRIOR1,
        _reserved24: [u8; 0x1c],
        iprior2: IPRIOR2,
        _reserved25: [u8; 0x1c],
        iprior3: IPRIOR3,
        _reserved26: [u8; 0x1c],
        iprior4: IPRIOR4,
        _reserved27: [u8; 0x1c],
        iprior5: IPRIOR5,
        _reserved28: [u8; 0x1c],
        iprior6: IPRIOR6,
        _reserved29: [u8; 0x1c],
        iprior7: IPRIOR7,
        _reserved30: [u8; 0x1c],
        iprior8: IPRIOR8,
        _reserved31: [u8; 0x1c],
        iprior9: IPRIOR9,
        _reserved32: [u8; 0x1c],
        iprior10: IPRIOR10,
        _reserved33: [u8; 0x1c],
        iprior11: IPRIOR11,
        _reserved34: [u8; 0x1c],
        iprior12: IPRIOR12,
        _reserved35: [u8; 0x1c],
        iprior13: IPRIOR13,
        _reserved36: [u8; 0x1c],
        iprior14: IPRIOR14,
        _reserved37: [u8; 0x1c],
        iprior15: IPRIOR15,
        _reserved38: [u8; 0x1c],
        iprior16: IPRIOR16,
        _reserved39: [u8; 0x1c],
        iprior17: IPRIOR17,
        _reserved40: [u8; 0x1c],
        iprior18: IPRIOR18,
        _reserved41: [u8; 0x1c],
        iprior19: IPRIOR19,
        _reserved42: [u8; 0x1c],
        iprior20: IPRIOR20,
        _reserved43: [u8; 0x1c],
        iprior21: IPRIOR21,
        _reserved44: [u8; 0x1c],
        iprior22: IPRIOR22,
        _reserved45: [u8; 0x1c],
        iprior23: IPRIOR23,
        _reserved46: [u8; 0x1c],
        iprior24: IPRIOR24,
        _reserved47: [u8; 0x1c],
        iprior25: IPRIOR25,
        _reserved48: [u8; 0x1c],
        iprior26: IPRIOR26,
        _reserved49: [u8; 0x1c],
        iprior27: IPRIOR27,
        _reserved50: [u8; 0x1c],
        iprior28: IPRIOR28,
        _reserved51: [u8; 0x1c],
        iprior29: IPRIOR29,
        _reserved52: [u8; 0x1c],
        iprior30: IPRIOR30,
        _reserved53: [u8; 0x1c],
        iprior31: IPRIOR31,
        _reserved54: [u8; 0x1c],
        iprior32: IPRIOR32,
        _reserved55: [u8; 0x1c],
        iprior33: IPRIOR33,
        _reserved56: [u8; 0x1c],
        iprior34: IPRIOR34,
        _reserved57: [u8; 0x1c],
        iprior35: IPRIOR35,
        _reserved58: [u8; 0x1c],
        iprior36: IPRIOR36,
        _reserved59: [u8; 0x1c],
        iprior37: IPRIOR37,
        _reserved60: [u8; 0x1c],
        iprior38: IPRIOR38,
        _reserved61: [u8; 0x1c],
        iprior39: IPRIOR39,
        _reserved62: [u8; 0x1c],
        iprior40: IPRIOR40,
        _reserved63: [u8; 0x1c],
        iprior41: IPRIOR41,
        _reserved64: [u8; 0x1c],
        iprior42: IPRIOR42,
        _reserved65: [u8; 0x1c],
        iprior43: IPRIOR43,
        _reserved66: [u8; 0x1c],
        iprior44: IPRIOR44,
        _reserved67: [u8; 0x1c],
        iprior45: IPRIOR45,
        _reserved68: [u8; 0x1c],
        iprior46: IPRIOR46,
        _reserved69: [u8; 0x1c],
        iprior47: IPRIOR47,
        _reserved70: [u8; 0x1c],
        iprior48: IPRIOR48,
        _reserved71: [u8; 0x1c],
        iprior49: IPRIOR49,
        _reserved72: [u8; 0x1c],
        iprior50: IPRIOR50,
        _reserved73: [u8; 0x1c],
        iprior51: IPRIOR51,
        _reserved74: [u8; 0x1c],
        iprior52: IPRIOR52,
        _reserved75: [u8; 0x1c],
        iprior53: IPRIOR53,
        _reserved76: [u8; 0x2c],
        iprior54: IPRIOR54,
        _reserved77: [u8; 0x0c],
        iprior55: IPRIOR55,
        _reserved78: [u8; 0x1c],
        iprior56: IPRIOR56,
        _reserved79: [u8; 0x1c],
        iprior57: IPRIOR57,
        _reserved80: [u8; 0x1c],
        iprior58: IPRIOR58,
        _reserved81: [u8; 0x1c],
        iprior59: IPRIOR59,
        _reserved82: [u8; 0x1c],
        iprior60: IPRIOR60,
        _reserved83: [u8; 0x1c],
        iprior61: IPRIOR61,
        _reserved84: [u8; 0x3c],
        iprior62: IPRIOR62,
        _reserved85: [u8; 0x1c],
        iprior63: IPRIOR63,
        _reserved86: [u8; 0x010c],
        sctlr: SCTLR,
        vtctlr: VTCTLR,
    }
    impl RegisterBlock {
        ///0x00 - RO,Interrupt Status Register
        #[inline(always)]
        pub const fn isr1(&self) -> &ISR1 {
            &self.isr1
        }
        ///0x04 - RO,Interrupt Status Register
        #[inline(always)]
        pub const fn isr2(&self) -> &ISR2 {
            &self.isr2
        }
        ///0x20 - RO,Interrupt Pending Register
        #[inline(always)]
        pub const fn ipr1(&self) -> &IPR1 {
            &self.ipr1
        }
        ///0x24 - RO,Interrupt Pending Register
        #[inline(always)]
        pub const fn ipr2(&self) -> &IPR2 {
            &self.ipr2
        }
        ///0x40 - RW,Interrupt Priority Register
        #[inline(always)]
        pub const fn ithresdr(&self) -> &ITHRESDR {
            &self.ithresdr
        }
        ///0x44 - RW,Interrupt Fast Address Register
        #[inline(always)]
        pub const fn fibaddrr(&self) -> &FIBADDRR {
            &self.fibaddrr
        }
        ///0x48 - Interrupt Config Register
        #[inline(always)]
        pub const fn cfgr(&self) -> &CFGR {
            &self.cfgr
        }
        ///0x4c - Interrupt Global Register
        #[inline(always)]
        pub const fn gisr(&self) -> &GISR {
            &self.gisr
        }
        ///0x60 - Interrupt 0 address Register
        #[inline(always)]
        pub const fn fifoaddrr0(&self) -> &FIFOADDRR0 {
            &self.fifoaddrr0
        }
        ///0x64 - Interrupt 1 address Register
        #[inline(always)]
        pub const fn fifoaddrr1(&self) -> &FIFOADDRR1 {
            &self.fifoaddrr1
        }
        ///0x68 - Interrupt 2 address Register
        #[inline(always)]
        pub const fn fifoaddrr2(&self) -> &FIFOADDRR2 {
            &self.fifoaddrr2
        }
        ///0x6c - Interrupt 3 address Register
        #[inline(always)]
        pub const fn fifoaddrr3(&self) -> &FIFOADDRR3 {
            &self.fifoaddrr3
        }
        ///0x100 - Interrupt Setting Register
        #[inline(always)]
        pub const fn ienr1(&self) -> &IENR1 {
            &self.ienr1
        }
        ///0x104 - Interrupt Setting Register
        #[inline(always)]
        pub const fn ienr2(&self) -> &IENR2 {
            &self.ienr2
        }
        ///0x180 - Interrupt Clear Register
        #[inline(always)]
        pub const fn irer1(&self) -> &IRER1 {
            &self.irer1
        }
        ///0x184 - Interrupt Clear Register
        #[inline(always)]
        pub const fn irer2(&self) -> &IRER2 {
            &self.irer2
        }
        ///0x200 - Interrupt Pending Register
        #[inline(always)]
        pub const fn ipsr1(&self) -> &IPSR1 {
            &self.ipsr1
        }
        ///0x204 - Interrupt Pending Register
        #[inline(always)]
        pub const fn ipsr2(&self) -> &IPSR2 {
            &self.ipsr2
        }
        ///0x280 - Interrupt Pending Clear Register
        #[inline(always)]
        pub const fn iprr1(&self) -> &IPRR1 {
            &self.iprr1
        }
        ///0x284 - Interrupt Pending Clear Register
        #[inline(always)]
        pub const fn iprr2(&self) -> &IPRR2 {
            &self.iprr2
        }
        ///0x300 - Interrupt ACTIVE Register
        #[inline(always)]
        pub const fn iactr1(&self) -> &IACTR1 {
            &self.iactr1
        }
        ///0x304 - Interrupt ACTIVE Register
        #[inline(always)]
        pub const fn iactr2(&self) -> &IACTR2 {
            &self.iactr2
        }
        ///0x400 - Interrupt Priority configuration Register
        #[inline(always)]
        pub const fn iprior0(&self) -> &IPRIOR0 {
            &self.iprior0
        }
        ///0x420 - Interrupt Priority configuration Register
        #[inline(always)]
        pub const fn iprior1(&self) -> &IPRIOR1 {
            &self.iprior1
        }
        ///0x440 - Interrupt Priority configuration Register
        #[inline(always)]
        pub const fn iprior2(&self) -> &IPRIOR2 {
            &self.iprior2
        }
        ///0x460 - Interrupt Priority configuration Register
        #[inline(always)]
        pub const fn iprior3(&self) -> &IPRIOR3 {
            &self.iprior3
        }
        ///0x480 - Interrupt Priority configuration Register
        #[inline(always)]
        pub const fn iprior4(&self) -> &IPRIOR4 {
            &self.iprior4
        }
        ///0x4a0 - Interrupt Priority configuration Register
        #[inline(always)]
        pub const fn iprior5(&self) -> &IPRIOR5 {
            &self.iprior5
        }
        ///0x4c0 - Interrupt Priority configuration Register
        #[inline(always)]
        pub const fn iprior6(&self) -> &IPRIOR6 {
            &self.iprior6
        }
        ///0x4e0 - Interrupt Priority configuration Register
        #[inline(always)]
        pub const fn iprior7(&self) -> &IPRIOR7 {
            &self.iprior7
        }
        ///0x500 - Interrupt Priority configuration Register
        #[inline(always)]
        pub const fn iprior8(&self) -> &IPRIOR8 {
            &self.iprior8
        }
        ///0x520 - Interrupt Priority configuration Register
        #[inline(always)]
        pub const fn iprior9(&self) -> &IPRIOR9 {
            &self.iprior9
        }
        ///0x540 - Interrupt Priority configuration Register
        #[inline(always)]
        pub const fn iprior10(&self) -> &IPRIOR10 {
            &self.iprior10
        }
        ///0x560 - Interrupt Priority configuration Register
        #[inline(always)]
        pub const fn iprior11(&self) -> &IPRIOR11 {
            &self.iprior11
        }
        ///0x580 - Interrupt Priority configuration Register
        #[inline(always)]
        pub const fn iprior12(&self) -> &IPRIOR12 {
            &self.iprior12
        }
        ///0x5a0 - Interrupt Priority configuration Register
        #[inline(always)]
        pub const fn iprior13(&self) -> &IPRIOR13 {
            &self.iprior13
        }
        ///0x5c0 - Interrupt Priority configuration Register
        #[inline(always)]
        pub const fn iprior14(&self) -> &IPRIOR14 {
            &self.iprior14
        }
        ///0x5e0 - Interrupt Priority configuration Register
        #[inline(always)]
        pub const fn iprior15(&self) -> &IPRIOR15 {
            &self.iprior15
        }
        ///0x600 - Interrupt Priority configuration Register
        #[inline(always)]
        pub const fn iprior16(&self) -> &IPRIOR16 {
            &self.iprior16
        }
        ///0x620 - Interrupt Priority configuration Register
        #[inline(always)]
        pub const fn iprior17(&self) -> &IPRIOR17 {
            &self.iprior17
        }
        ///0x640 - Interrupt Priority configuration Register
        #[inline(always)]
        pub const fn iprior18(&self) -> &IPRIOR18 {
            &self.iprior18
        }
        ///0x660 - Interrupt Priority configuration Register
        #[inline(always)]
        pub const fn iprior19(&self) -> &IPRIOR19 {
            &self.iprior19
        }
        ///0x680 - Interrupt Priority configuration Register
        #[inline(always)]
        pub const fn iprior20(&self) -> &IPRIOR20 {
            &self.iprior20
        }
        ///0x6a0 - Interrupt Priority configuration Register
        #[inline(always)]
        pub const fn iprior21(&self) -> &IPRIOR21 {
            &self.iprior21
        }
        ///0x6c0 - Interrupt Priority configuration Register
        #[inline(always)]
        pub const fn iprior22(&self) -> &IPRIOR22 {
            &self.iprior22
        }
        ///0x6e0 - Interrupt Priority configuration Register
        #[inline(always)]
        pub const fn iprior23(&self) -> &IPRIOR23 {
            &self.iprior23
        }
        ///0x700 - Interrupt Priority configuration Register
        #[inline(always)]
        pub const fn iprior24(&self) -> &IPRIOR24 {
            &self.iprior24
        }
        ///0x720 - Interrupt Priority configuration Register
        #[inline(always)]
        pub const fn iprior25(&self) -> &IPRIOR25 {
            &self.iprior25
        }
        ///0x740 - Interrupt Priority configuration Register
        #[inline(always)]
        pub const fn iprior26(&self) -> &IPRIOR26 {
            &self.iprior26
        }
        ///0x760 - Interrupt Priority configuration Register
        #[inline(always)]
        pub const fn iprior27(&self) -> &IPRIOR27 {
            &self.iprior27
        }
        ///0x780 - Interrupt Priority configuration Register
        #[inline(always)]
        pub const fn iprior28(&self) -> &IPRIOR28 {
            &self.iprior28
        }
        ///0x7a0 - Interrupt Priority configuration Register
        #[inline(always)]
        pub const fn iprior29(&self) -> &IPRIOR29 {
            &self.iprior29
        }
        ///0x7c0 - Interrupt Priority configuration Register
        #[inline(always)]
        pub const fn iprior30(&self) -> &IPRIOR30 {
            &self.iprior30
        }
        ///0x7e0 - Interrupt Priority configuration Register
        #[inline(always)]
        pub const fn iprior31(&self) -> &IPRIOR31 {
            &self.iprior31
        }
        ///0x800 - Interrupt Priority configuration Register
        #[inline(always)]
        pub const fn iprior32(&self) -> &IPRIOR32 {
            &self.iprior32
        }
        ///0x820 - Interrupt Priority configuration Register
        #[inline(always)]
        pub const fn iprior33(&self) -> &IPRIOR33 {
            &self.iprior33
        }
        ///0x840 - Interrupt Priority configuration Register
        #[inline(always)]
        pub const fn iprior34(&self) -> &IPRIOR34 {
            &self.iprior34
        }
        ///0x860 - Interrupt Priority configuration Register
        #[inline(always)]
        pub const fn iprior35(&self) -> &IPRIOR35 {
            &self.iprior35
        }
        ///0x880 - Interrupt Priority configuration Register
        #[inline(always)]
        pub const fn iprior36(&self) -> &IPRIOR36 {
            &self.iprior36
        }
        ///0x8a0 - Interrupt Priority configuration Register
        #[inline(always)]
        pub const fn iprior37(&self) -> &IPRIOR37 {
            &self.iprior37
        }
        ///0x8c0 - Interrupt Priority configuration Register
        #[inline(always)]
        pub const fn iprior38(&self) -> &IPRIOR38 {
            &self.iprior38
        }
        ///0x8e0 - Interrupt Priority configuration Register
        #[inline(always)]
        pub const fn iprior39(&self) -> &IPRIOR39 {
            &self.iprior39
        }
        ///0x900 - Interrupt Priority configuration Register
        #[inline(always)]
        pub const fn iprior40(&self) -> &IPRIOR40 {
            &self.iprior40
        }
        ///0x920 - Interrupt Priority configuration Register
        #[inline(always)]
        pub const fn iprior41(&self) -> &IPRIOR41 {
            &self.iprior41
        }
        ///0x940 - Interrupt Priority configuration Register
        #[inline(always)]
        pub const fn iprior42(&self) -> &IPRIOR42 {
            &self.iprior42
        }
        ///0x960 - Interrupt Priority configuration Register
        #[inline(always)]
        pub const fn iprior43(&self) -> &IPRIOR43 {
            &self.iprior43
        }
        ///0x980 - Interrupt Priority configuration Register
        #[inline(always)]
        pub const fn iprior44(&self) -> &IPRIOR44 {
            &self.iprior44
        }
        ///0x9a0 - Interrupt Priority configuration Register
        #[inline(always)]
        pub const fn iprior45(&self) -> &IPRIOR45 {
            &self.iprior45
        }
        ///0x9c0 - Interrupt Priority configuration Register
        #[inline(always)]
        pub const fn iprior46(&self) -> &IPRIOR46 {
            &self.iprior46
        }
        ///0x9e0 - Interrupt Priority configuration Register
        #[inline(always)]
        pub const fn iprior47(&self) -> &IPRIOR47 {
            &self.iprior47
        }
        ///0xa00 - Interrupt Priority configuration Register
        #[inline(always)]
        pub const fn iprior48(&self) -> &IPRIOR48 {
            &self.iprior48
        }
        ///0xa20 - Interrupt Priority configuration Register
        #[inline(always)]
        pub const fn iprior49(&self) -> &IPRIOR49 {
            &self.iprior49
        }
        ///0xa40 - Interrupt Priority configuration Register
        #[inline(always)]
        pub const fn iprior50(&self) -> &IPRIOR50 {
            &self.iprior50
        }
        ///0xa60 - Interrupt Priority configuration Register
        #[inline(always)]
        pub const fn iprior51(&self) -> &IPRIOR51 {
            &self.iprior51
        }
        ///0xa80 - Interrupt Priority configuration Register
        #[inline(always)]
        pub const fn iprior52(&self) -> &IPRIOR52 {
            &self.iprior52
        }
        ///0xaa0 - Interrupt Priority configuration Register
        #[inline(always)]
        pub const fn iprior53(&self) -> &IPRIOR53 {
            &self.iprior53
        }
        ///0xad0 - Interrupt Priority configuration Register
        #[inline(always)]
        pub const fn iprior54(&self) -> &IPRIOR54 {
            &self.iprior54
        }
        ///0xae0 - Interrupt Priority configuration Register
        #[inline(always)]
        pub const fn iprior55(&self) -> &IPRIOR55 {
            &self.iprior55
        }
        ///0xb00 - Interrupt Priority configuration Register
        #[inline(always)]
        pub const fn iprior56(&self) -> &IPRIOR56 {
            &self.iprior56
        }
        ///0xb20 - Interrupt Priority configuration Register
        #[inline(always)]
        pub const fn iprior57(&self) -> &IPRIOR57 {
            &self.iprior57
        }
        ///0xb40 - Interrupt Priority configuration Register
        #[inline(always)]
        pub const fn iprior58(&self) -> &IPRIOR58 {
            &self.iprior58
        }
        ///0xb60 - Interrupt Priority configuration Register
        #[inline(always)]
        pub const fn iprior59(&self) -> &IPRIOR59 {
            &self.iprior59
        }
        ///0xb80 - Interrupt Priority configuration Register
        #[inline(always)]
        pub const fn iprior60(&self) -> &IPRIOR60 {
            &self.iprior60
        }
        ///0xba0 - Interrupt Priority configuration Register
        #[inline(always)]
        pub const fn iprior61(&self) -> &IPRIOR61 {
            &self.iprior61
        }
        ///0xbe0 - Interrupt Priority configuration Register
        #[inline(always)]
        pub const fn iprior62(&self) -> &IPRIOR62 {
            &self.iprior62
        }
        ///0xc00 - Interrupt Priority configuration Register
        #[inline(always)]
        pub const fn iprior63(&self) -> &IPRIOR63 {
            &self.iprior63
        }
        ///0xd10 - System Control Register
        #[inline(always)]
        pub const fn sctlr(&self) -> &SCTLR {
            &self.sctlr
        }
        ///0xd14 - System Control Register
        #[inline(always)]
        pub const fn vtctlr(&self) -> &VTCTLR {
            &self.vtctlr
        }
    }
    ///ISR1 (rw) register accessor: RO,Interrupt Status Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`isr1::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`isr1::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@isr1`]
    ///module
    pub type ISR1 = crate::Reg<isr1::ISR1_SPEC>;
    ///RO,Interrupt Status Register
    pub mod isr1 {
        ///Register `ISR1` reader
        pub type R = crate::R<ISR1_SPEC>;
        ///Register `ISR1` writer
        pub type W = crate::W<ISR1_SPEC>;
        ///Field `INTENSTA` reader - Interrupt ID Status
        pub type INTENSTA_R = crate::FieldReader<u32>;
        ///Field `INTENSTA` writer - Interrupt ID Status
        pub type INTENSTA_W<'a, REG> = crate::FieldWriter<'a, REG, 20, u32>;
        impl R {
            ///Bits 12:31 - Interrupt ID Status
            #[inline(always)]
            pub fn intensta(&self) -> INTENSTA_R {
                INTENSTA_R::new((self.bits >> 12) & 0x000f_ffff)
            }
        }
        impl W {
            ///Bits 12:31 - Interrupt ID Status
            #[inline(always)]
            #[must_use]
            pub fn intensta(&mut self) -> INTENSTA_W<ISR1_SPEC> {
                INTENSTA_W::new(self, 12)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RO,Interrupt Status Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`isr1::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`isr1::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct ISR1_SPEC;
        impl crate::RegisterSpec for ISR1_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`isr1::R`](R) reader structure
        impl crate::Readable for ISR1_SPEC {}
        ///`write(|w| ..)` method takes [`isr1::W`](W) writer structure
        impl crate::Writable for ISR1_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets ISR1 to value 0
        impl crate::Resettable for ISR1_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///ISR2 (rw) register accessor: RO,Interrupt Status Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`isr2::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`isr2::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@isr2`]
    ///module
    pub type ISR2 = crate::Reg<isr2::ISR2_SPEC>;
    ///RO,Interrupt Status Register
    pub mod isr2 {
        ///Register `ISR2` reader
        pub type R = crate::R<ISR2_SPEC>;
        ///Register `ISR2` writer
        pub type W = crate::W<ISR2_SPEC>;
        ///Field `INTENSTA` reader - Interrupt ID Status
        pub type INTENSTA_R = crate::FieldReader;
        ///Field `INTENSTA` writer - Interrupt ID Status
        pub type INTENSTA_W<'a, REG> = crate::FieldWriter<'a, REG, 4>;
        impl R {
            ///Bits 0:3 - Interrupt ID Status
            #[inline(always)]
            pub fn intensta(&self) -> INTENSTA_R {
                INTENSTA_R::new((self.bits & 0x0f) as u8)
            }
        }
        impl W {
            ///Bits 0:3 - Interrupt ID Status
            #[inline(always)]
            #[must_use]
            pub fn intensta(&mut self) -> INTENSTA_W<ISR2_SPEC> {
                INTENSTA_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RO,Interrupt Status Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`isr2::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`isr2::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct ISR2_SPEC;
        impl crate::RegisterSpec for ISR2_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`isr2::R`](R) reader structure
        impl crate::Readable for ISR2_SPEC {}
        ///`write(|w| ..)` method takes [`isr2::W`](W) writer structure
        impl crate::Writable for ISR2_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets ISR2 to value 0
        impl crate::Resettable for ISR2_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPR1 (rw) register accessor: RO,Interrupt Pending Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`ipr1::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ipr1::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@ipr1`]
    ///module
    pub type IPR1 = crate::Reg<ipr1::IPR1_SPEC>;
    ///RO,Interrupt Pending Register
    pub mod ipr1 {
        ///Register `IPR1` reader
        pub type R = crate::R<IPR1_SPEC>;
        ///Register `IPR1` writer
        pub type W = crate::W<IPR1_SPEC>;
        ///Field `PENDSTA` reader - PENDSTA
        pub type PENDSTA_R = crate::FieldReader<u32>;
        ///Field `PENDSTA` writer - PENDSTA
        pub type PENDSTA_W<'a, REG> = crate::FieldWriter<'a, REG, 20, u32>;
        impl R {
            ///Bits 12:31 - PENDSTA
            #[inline(always)]
            pub fn pendsta(&self) -> PENDSTA_R {
                PENDSTA_R::new((self.bits >> 12) & 0x000f_ffff)
            }
        }
        impl W {
            ///Bits 12:31 - PENDSTA
            #[inline(always)]
            #[must_use]
            pub fn pendsta(&mut self) -> PENDSTA_W<IPR1_SPEC> {
                PENDSTA_W::new(self, 12)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RO,Interrupt Pending Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`ipr1::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ipr1::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPR1_SPEC;
        impl crate::RegisterSpec for IPR1_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`ipr1::R`](R) reader structure
        impl crate::Readable for IPR1_SPEC {}
        ///`write(|w| ..)` method takes [`ipr1::W`](W) writer structure
        impl crate::Writable for IPR1_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPR1 to value 0
        impl crate::Resettable for IPR1_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPR2 (r) register accessor: RO,Interrupt Pending Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`ipr2::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@ipr2`]
    ///module
    pub type IPR2 = crate::Reg<ipr2::IPR2_SPEC>;
    ///RO,Interrupt Pending Register
    pub mod ipr2 {
        ///Register `IPR2` reader
        pub type R = crate::R<IPR2_SPEC>;
        ///Field `PENDSTA` reader - PENDSTA
        pub type PENDSTA_R = crate::FieldReader;
        impl R {
            ///Bits 0:3 - PENDSTA
            #[inline(always)]
            pub fn pendsta(&self) -> PENDSTA_R {
                PENDSTA_R::new((self.bits & 0x0f) as u8)
            }
        }
        ///RO,Interrupt Pending Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`ipr2::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPR2_SPEC;
        impl crate::RegisterSpec for IPR2_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`ipr2::R`](R) reader structure
        impl crate::Readable for IPR2_SPEC {}
        ///`reset()` method sets IPR2 to value 0
        impl crate::Resettable for IPR2_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///ITHRESDR (rw) register accessor: RW,Interrupt Priority Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`ithresdr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ithresdr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@ithresdr`]
    ///module
    pub type ITHRESDR = crate::Reg<ithresdr::ITHRESDR_SPEC>;
    ///RW,Interrupt Priority Register
    pub mod ithresdr {
        ///Register `ITHRESDR` reader
        pub type R = crate::R<ITHRESDR_SPEC>;
        ///Register `ITHRESDR` writer
        pub type W = crate::W<ITHRESDR_SPEC>;
        ///Field `THRESHOLD` reader - RW,THRESHOLD
        pub type THRESHOLD_R = crate::FieldReader;
        ///Field `THRESHOLD` writer - RW,THRESHOLD
        pub type THRESHOLD_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            ///Bits 0:7 - RW,THRESHOLD
            #[inline(always)]
            pub fn threshold(&self) -> THRESHOLD_R {
                THRESHOLD_R::new((self.bits & 0xff) as u8)
            }
        }
        impl W {
            ///Bits 0:7 - RW,THRESHOLD
            #[inline(always)]
            #[must_use]
            pub fn threshold(&mut self) -> THRESHOLD_W<ITHRESDR_SPEC> {
                THRESHOLD_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW,Interrupt Priority Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`ithresdr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ithresdr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct ITHRESDR_SPEC;
        impl crate::RegisterSpec for ITHRESDR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`ithresdr::R`](R) reader structure
        impl crate::Readable for ITHRESDR_SPEC {}
        ///`write(|w| ..)` method takes [`ithresdr::W`](W) writer structure
        impl crate::Writable for ITHRESDR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets ITHRESDR to value 0
        impl crate::Resettable for ITHRESDR_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///FIBADDRR (rw) register accessor: RW,Interrupt Fast Address Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`fibaddrr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`fibaddrr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@fibaddrr`]
    ///module
    pub type FIBADDRR = crate::Reg<fibaddrr::FIBADDRR_SPEC>;
    ///RW,Interrupt Fast Address Register
    pub mod fibaddrr {
        ///Register `FIBADDRR` reader
        pub type R = crate::R<FIBADDRR_SPEC>;
        ///Register `FIBADDRR` writer
        pub type W = crate::W<FIBADDRR_SPEC>;
        ///Field `BASEADDR` reader - BASEADDR
        pub type BASEADDR_R = crate::FieldReader;
        ///Field `BASEADDR` writer - BASEADDR
        pub type BASEADDR_W<'a, REG> = crate::FieldWriter<'a, REG, 4>;
        impl R {
            ///Bits 28:31 - BASEADDR
            #[inline(always)]
            pub fn baseaddr(&self) -> BASEADDR_R {
                BASEADDR_R::new(((self.bits >> 28) & 0x0f) as u8)
            }
        }
        impl W {
            ///Bits 28:31 - BASEADDR
            #[inline(always)]
            #[must_use]
            pub fn baseaddr(&mut self) -> BASEADDR_W<FIBADDRR_SPEC> {
                BASEADDR_W::new(self, 28)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW,Interrupt Fast Address Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`fibaddrr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`fibaddrr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct FIBADDRR_SPEC;
        impl crate::RegisterSpec for FIBADDRR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`fibaddrr::R`](R) reader structure
        impl crate::Readable for FIBADDRR_SPEC {}
        ///`write(|w| ..)` method takes [`fibaddrr::W`](W) writer structure
        impl crate::Writable for FIBADDRR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets FIBADDRR to value 0
        impl crate::Resettable for FIBADDRR_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///CFGR (rw) register accessor: Interrupt Config Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`cfgr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cfgr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@cfgr`]
    ///module
    pub type CFGR = crate::Reg<cfgr::CFGR_SPEC>;
    ///Interrupt Config Register
    pub mod cfgr {
        ///Register `CFGR` reader
        pub type R = crate::R<CFGR_SPEC>;
        ///Register `CFGR` writer
        pub type W = crate::W<CFGR_SPEC>;
        ///Field `HWSTKCTRL` reader - RW,HWSTKCTRL
        pub type HWSTKCTRL_R = crate::BitReader;
        ///Field `HWSTKCTRL` writer - RW,HWSTKCTRL
        pub type HWSTKCTRL_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `NESTCTRL` reader - RW,NESTCTRL
        pub type NESTCTRL_R = crate::BitReader;
        ///Field `NESTCTRL` writer - RW,NESTCTRL
        pub type NESTCTRL_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `NMISET` reader - WO,NMISET
        pub type NMISET_R = crate::BitReader;
        ///Field `NMISET` writer - WO,NMISET
        pub type NMISET_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `NMIRESET` reader - WO,NMIRESET
        pub type NMIRESET_R = crate::BitReader;
        ///Field `NMIRESET` writer - WO,NMIRESET
        pub type NMIRESET_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `EXCSET` reader - WO,EXCSET
        pub type EXCSET_R = crate::BitReader;
        ///Field `EXCSET` writer - WO,EXCSET
        pub type EXCSET_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `EXCRESET` reader - WO,EXCRESET
        pub type EXCRESET_R = crate::BitReader;
        ///Field `EXCRESET` writer - WO,EXCRESET
        pub type EXCRESET_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PFICRESET` reader - WO,PFICRSET
        pub type PFICRESET_R = crate::BitReader;
        ///Field `PFICRESET` writer - WO,PFICRSET
        pub type PFICRESET_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `SYSRESET` reader - WO,SYSRESET
        pub type SYSRESET_R = crate::BitReader;
        ///Field `SYSRESET` writer - WO,SYSRESET
        pub type SYSRESET_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `KEYCODE` reader - WO,KEYCODE
        pub type KEYCODE_R = crate::FieldReader<u16>;
        ///Field `KEYCODE` writer - WO,KEYCODE
        pub type KEYCODE_W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            ///Bit 0 - RW,HWSTKCTRL
            #[inline(always)]
            pub fn hwstkctrl(&self) -> HWSTKCTRL_R {
                HWSTKCTRL_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RW,NESTCTRL
            #[inline(always)]
            pub fn nestctrl(&self) -> NESTCTRL_R {
                NESTCTRL_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - WO,NMISET
            #[inline(always)]
            pub fn nmiset(&self) -> NMISET_R {
                NMISET_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - WO,NMIRESET
            #[inline(always)]
            pub fn nmireset(&self) -> NMIRESET_R {
                NMIRESET_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - WO,EXCSET
            #[inline(always)]
            pub fn excset(&self) -> EXCSET_R {
                EXCSET_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - WO,EXCRESET
            #[inline(always)]
            pub fn excreset(&self) -> EXCRESET_R {
                EXCRESET_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - WO,PFICRSET
            #[inline(always)]
            pub fn pficreset(&self) -> PFICRESET_R {
                PFICRESET_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - WO,SYSRESET
            #[inline(always)]
            pub fn sysreset(&self) -> SYSRESET_R {
                SYSRESET_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bits 16:31 - WO,KEYCODE
            #[inline(always)]
            pub fn keycode(&self) -> KEYCODE_R {
                KEYCODE_R::new(((self.bits >> 16) & 0xffff) as u16)
            }
        }
        impl W {
            ///Bit 0 - RW,HWSTKCTRL
            #[inline(always)]
            #[must_use]
            pub fn hwstkctrl(&mut self) -> HWSTKCTRL_W<CFGR_SPEC> {
                HWSTKCTRL_W::new(self, 0)
            }
            ///Bit 1 - RW,NESTCTRL
            #[inline(always)]
            #[must_use]
            pub fn nestctrl(&mut self) -> NESTCTRL_W<CFGR_SPEC> {
                NESTCTRL_W::new(self, 1)
            }
            ///Bit 2 - WO,NMISET
            #[inline(always)]
            #[must_use]
            pub fn nmiset(&mut self) -> NMISET_W<CFGR_SPEC> {
                NMISET_W::new(self, 2)
            }
            ///Bit 3 - WO,NMIRESET
            #[inline(always)]
            #[must_use]
            pub fn nmireset(&mut self) -> NMIRESET_W<CFGR_SPEC> {
                NMIRESET_W::new(self, 3)
            }
            ///Bit 4 - WO,EXCSET
            #[inline(always)]
            #[must_use]
            pub fn excset(&mut self) -> EXCSET_W<CFGR_SPEC> {
                EXCSET_W::new(self, 4)
            }
            ///Bit 5 - WO,EXCRESET
            #[inline(always)]
            #[must_use]
            pub fn excreset(&mut self) -> EXCRESET_W<CFGR_SPEC> {
                EXCRESET_W::new(self, 5)
            }
            ///Bit 6 - WO,PFICRSET
            #[inline(always)]
            #[must_use]
            pub fn pficreset(&mut self) -> PFICRESET_W<CFGR_SPEC> {
                PFICRESET_W::new(self, 6)
            }
            ///Bit 7 - WO,SYSRESET
            #[inline(always)]
            #[must_use]
            pub fn sysreset(&mut self) -> SYSRESET_W<CFGR_SPEC> {
                SYSRESET_W::new(self, 7)
            }
            ///Bits 16:31 - WO,KEYCODE
            #[inline(always)]
            #[must_use]
            pub fn keycode(&mut self) -> KEYCODE_W<CFGR_SPEC> {
                KEYCODE_W::new(self, 16)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Config Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`cfgr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cfgr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct CFGR_SPEC;
        impl crate::RegisterSpec for CFGR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`cfgr::R`](R) reader structure
        impl crate::Readable for CFGR_SPEC {}
        ///`write(|w| ..)` method takes [`cfgr::W`](W) writer structure
        impl crate::Writable for CFGR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets CFGR to value 0
        impl crate::Resettable for CFGR_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///GISR (r) register accessor: Interrupt Global Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`gisr::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@gisr`]
    ///module
    pub type GISR = crate::Reg<gisr::GISR_SPEC>;
    ///Interrupt Global Register
    pub mod gisr {
        ///Register `GISR` reader
        pub type R = crate::R<GISR_SPEC>;
        ///Field `NESTSTA` reader - RO,NESTSTA
        pub type NESTSTA_R = crate::FieldReader;
        ///Field `GACTSTA` reader - RO,GACTSTA
        pub type GACTSTA_R = crate::BitReader;
        ///Field `GPENDSTA` reader - RO,GPENDSTA
        pub type GPENDSTA_R = crate::BitReader;
        impl R {
            ///Bits 0:7 - RO,NESTSTA
            #[inline(always)]
            pub fn neststa(&self) -> NESTSTA_R {
                NESTSTA_R::new((self.bits & 0xff) as u8)
            }
            ///Bit 8 - RO,GACTSTA
            #[inline(always)]
            pub fn gactsta(&self) -> GACTSTA_R {
                GACTSTA_R::new(((self.bits >> 8) & 1) != 0)
            }
            ///Bit 9 - RO,GPENDSTA
            #[inline(always)]
            pub fn gpendsta(&self) -> GPENDSTA_R {
                GPENDSTA_R::new(((self.bits >> 9) & 1) != 0)
            }
        }
        ///Interrupt Global Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`gisr::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct GISR_SPEC;
        impl crate::RegisterSpec for GISR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`gisr::R`](R) reader structure
        impl crate::Readable for GISR_SPEC {}
        ///`reset()` method sets GISR to value 0
        impl crate::Resettable for GISR_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///FIFOADDRR0 (rw) register accessor: Interrupt 0 address Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`fifoaddrr0::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`fifoaddrr0::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@fifoaddrr0`]
    ///module
    pub type FIFOADDRR0 = crate::Reg<fifoaddrr0::FIFOADDRR0_SPEC>;
    ///Interrupt 0 address Register
    pub mod fifoaddrr0 {
        ///Register `FIFOADDRR0` reader
        pub type R = crate::R<FIFOADDRR0_SPEC>;
        ///Register `FIFOADDRR0` writer
        pub type W = crate::W<FIFOADDRR0_SPEC>;
        ///Field `OFFADDR0` reader - RW,OFFADDR0
        pub type OFFADDR0_R = crate::FieldReader<u32>;
        ///Field `OFFADDR0` writer - RW,OFFADDR0
        pub type OFFADDR0_W<'a, REG> = crate::FieldWriter<'a, REG, 24, u32>;
        ///Field `IRQID0` reader - RW,IRQID0
        pub type IRQID0_R = crate::FieldReader;
        ///Field `IRQID0` writer - RW,IRQID0
        pub type IRQID0_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            ///Bits 0:23 - RW,OFFADDR0
            #[inline(always)]
            pub fn offaddr0(&self) -> OFFADDR0_R {
                OFFADDR0_R::new(self.bits & 0x00ff_ffff)
            }
            ///Bits 24:31 - RW,IRQID0
            #[inline(always)]
            pub fn irqid0(&self) -> IRQID0_R {
                IRQID0_R::new(((self.bits >> 24) & 0xff) as u8)
            }
        }
        impl W {
            ///Bits 0:23 - RW,OFFADDR0
            #[inline(always)]
            #[must_use]
            pub fn offaddr0(&mut self) -> OFFADDR0_W<FIFOADDRR0_SPEC> {
                OFFADDR0_W::new(self, 0)
            }
            ///Bits 24:31 - RW,IRQID0
            #[inline(always)]
            #[must_use]
            pub fn irqid0(&mut self) -> IRQID0_W<FIFOADDRR0_SPEC> {
                IRQID0_W::new(self, 24)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt 0 address Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`fifoaddrr0::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`fifoaddrr0::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct FIFOADDRR0_SPEC;
        impl crate::RegisterSpec for FIFOADDRR0_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`fifoaddrr0::R`](R) reader structure
        impl crate::Readable for FIFOADDRR0_SPEC {}
        ///`write(|w| ..)` method takes [`fifoaddrr0::W`](W) writer structure
        impl crate::Writable for FIFOADDRR0_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets FIFOADDRR0 to value 0
        impl crate::Resettable for FIFOADDRR0_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///FIFOADDRR1 (rw) register accessor: Interrupt 1 address Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`fifoaddrr1::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`fifoaddrr1::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@fifoaddrr1`]
    ///module
    pub type FIFOADDRR1 = crate::Reg<fifoaddrr1::FIFOADDRR1_SPEC>;
    ///Interrupt 1 address Register
    pub mod fifoaddrr1 {
        ///Register `FIFOADDRR1` reader
        pub type R = crate::R<FIFOADDRR1_SPEC>;
        ///Register `FIFOADDRR1` writer
        pub type W = crate::W<FIFOADDRR1_SPEC>;
        ///Field `OFFADDR1` reader - RW,OFFADDR1
        pub type OFFADDR1_R = crate::FieldReader<u32>;
        ///Field `OFFADDR1` writer - RW,OFFADDR1
        pub type OFFADDR1_W<'a, REG> = crate::FieldWriter<'a, REG, 24, u32>;
        ///Field `IRQID1` reader - RW,IRQID1
        pub type IRQID1_R = crate::FieldReader;
        ///Field `IRQID1` writer - RW,IRQID1
        pub type IRQID1_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            ///Bits 0:23 - RW,OFFADDR1
            #[inline(always)]
            pub fn offaddr1(&self) -> OFFADDR1_R {
                OFFADDR1_R::new(self.bits & 0x00ff_ffff)
            }
            ///Bits 24:31 - RW,IRQID1
            #[inline(always)]
            pub fn irqid1(&self) -> IRQID1_R {
                IRQID1_R::new(((self.bits >> 24) & 0xff) as u8)
            }
        }
        impl W {
            ///Bits 0:23 - RW,OFFADDR1
            #[inline(always)]
            #[must_use]
            pub fn offaddr1(&mut self) -> OFFADDR1_W<FIFOADDRR1_SPEC> {
                OFFADDR1_W::new(self, 0)
            }
            ///Bits 24:31 - RW,IRQID1
            #[inline(always)]
            #[must_use]
            pub fn irqid1(&mut self) -> IRQID1_W<FIFOADDRR1_SPEC> {
                IRQID1_W::new(self, 24)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt 1 address Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`fifoaddrr1::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`fifoaddrr1::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct FIFOADDRR1_SPEC;
        impl crate::RegisterSpec for FIFOADDRR1_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`fifoaddrr1::R`](R) reader structure
        impl crate::Readable for FIFOADDRR1_SPEC {}
        ///`write(|w| ..)` method takes [`fifoaddrr1::W`](W) writer structure
        impl crate::Writable for FIFOADDRR1_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets FIFOADDRR1 to value 0
        impl crate::Resettable for FIFOADDRR1_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///FIFOADDRR2 (rw) register accessor: Interrupt 2 address Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`fifoaddrr2::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`fifoaddrr2::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@fifoaddrr2`]
    ///module
    pub type FIFOADDRR2 = crate::Reg<fifoaddrr2::FIFOADDRR2_SPEC>;
    ///Interrupt 2 address Register
    pub mod fifoaddrr2 {
        ///Register `FIFOADDRR2` reader
        pub type R = crate::R<FIFOADDRR2_SPEC>;
        ///Register `FIFOADDRR2` writer
        pub type W = crate::W<FIFOADDRR2_SPEC>;
        ///Field `OFFADDR2` reader - RW,OFFADDR2
        pub type OFFADDR2_R = crate::FieldReader<u32>;
        ///Field `OFFADDR2` writer - RW,OFFADDR2
        pub type OFFADDR2_W<'a, REG> = crate::FieldWriter<'a, REG, 24, u32>;
        ///Field `IRQID2` reader - RW,IRQID2
        pub type IRQID2_R = crate::FieldReader;
        ///Field `IRQID2` writer - RW,IRQID2
        pub type IRQID2_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            ///Bits 0:23 - RW,OFFADDR2
            #[inline(always)]
            pub fn offaddr2(&self) -> OFFADDR2_R {
                OFFADDR2_R::new(self.bits & 0x00ff_ffff)
            }
            ///Bits 24:31 - RW,IRQID2
            #[inline(always)]
            pub fn irqid2(&self) -> IRQID2_R {
                IRQID2_R::new(((self.bits >> 24) & 0xff) as u8)
            }
        }
        impl W {
            ///Bits 0:23 - RW,OFFADDR2
            #[inline(always)]
            #[must_use]
            pub fn offaddr2(&mut self) -> OFFADDR2_W<FIFOADDRR2_SPEC> {
                OFFADDR2_W::new(self, 0)
            }
            ///Bits 24:31 - RW,IRQID2
            #[inline(always)]
            #[must_use]
            pub fn irqid2(&mut self) -> IRQID2_W<FIFOADDRR2_SPEC> {
                IRQID2_W::new(self, 24)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt 2 address Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`fifoaddrr2::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`fifoaddrr2::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct FIFOADDRR2_SPEC;
        impl crate::RegisterSpec for FIFOADDRR2_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`fifoaddrr2::R`](R) reader structure
        impl crate::Readable for FIFOADDRR2_SPEC {}
        ///`write(|w| ..)` method takes [`fifoaddrr2::W`](W) writer structure
        impl crate::Writable for FIFOADDRR2_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets FIFOADDRR2 to value 0
        impl crate::Resettable for FIFOADDRR2_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///FIFOADDRR3 (rw) register accessor: Interrupt 3 address Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`fifoaddrr3::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`fifoaddrr3::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@fifoaddrr3`]
    ///module
    pub type FIFOADDRR3 = crate::Reg<fifoaddrr3::FIFOADDRR3_SPEC>;
    ///Interrupt 3 address Register
    pub mod fifoaddrr3 {
        ///Register `FIFOADDRR3` reader
        pub type R = crate::R<FIFOADDRR3_SPEC>;
        ///Register `FIFOADDRR3` writer
        pub type W = crate::W<FIFOADDRR3_SPEC>;
        ///Field `OFFADDR3` reader - RW,OFFADDR3
        pub type OFFADDR3_R = crate::FieldReader<u32>;
        ///Field `OFFADDR3` writer - RW,OFFADDR3
        pub type OFFADDR3_W<'a, REG> = crate::FieldWriter<'a, REG, 24, u32>;
        ///Field `IRQID3` reader - RW,IRQID3
        pub type IRQID3_R = crate::FieldReader;
        ///Field `IRQID3` writer - RW,IRQID3
        pub type IRQID3_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            ///Bits 0:23 - RW,OFFADDR3
            #[inline(always)]
            pub fn offaddr3(&self) -> OFFADDR3_R {
                OFFADDR3_R::new(self.bits & 0x00ff_ffff)
            }
            ///Bits 24:31 - RW,IRQID3
            #[inline(always)]
            pub fn irqid3(&self) -> IRQID3_R {
                IRQID3_R::new(((self.bits >> 24) & 0xff) as u8)
            }
        }
        impl W {
            ///Bits 0:23 - RW,OFFADDR3
            #[inline(always)]
            #[must_use]
            pub fn offaddr3(&mut self) -> OFFADDR3_W<FIFOADDRR3_SPEC> {
                OFFADDR3_W::new(self, 0)
            }
            ///Bits 24:31 - RW,IRQID3
            #[inline(always)]
            #[must_use]
            pub fn irqid3(&mut self) -> IRQID3_W<FIFOADDRR3_SPEC> {
                IRQID3_W::new(self, 24)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt 3 address Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`fifoaddrr3::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`fifoaddrr3::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct FIFOADDRR3_SPEC;
        impl crate::RegisterSpec for FIFOADDRR3_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`fifoaddrr3::R`](R) reader structure
        impl crate::Readable for FIFOADDRR3_SPEC {}
        ///`write(|w| ..)` method takes [`fifoaddrr3::W`](W) writer structure
        impl crate::Writable for FIFOADDRR3_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets FIFOADDRR3 to value 0
        impl crate::Resettable for FIFOADDRR3_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IENR1 (rw) register accessor: Interrupt Setting Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`ienr1::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ienr1::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@ienr1`]
    ///module
    pub type IENR1 = crate::Reg<ienr1::IENR1_SPEC>;
    ///Interrupt Setting Register
    pub mod ienr1 {
        ///Register `IENR1` reader
        pub type R = crate::R<IENR1_SPEC>;
        ///Register `IENR1` writer
        pub type W = crate::W<IENR1_SPEC>;
        ///Field `INTEN` reader - RW1,INTEN
        pub type INTEN_R = crate::FieldReader<u32>;
        ///Field `INTEN` writer - RW1,INTEN
        pub type INTEN_W<'a, REG> = crate::FieldWriter<'a, REG, 20, u32>;
        impl R {
            ///Bits 12:31 - RW1,INTEN
            #[inline(always)]
            pub fn inten(&self) -> INTEN_R {
                INTEN_R::new((self.bits >> 12) & 0x000f_ffff)
            }
        }
        impl W {
            ///Bits 12:31 - RW1,INTEN
            #[inline(always)]
            #[must_use]
            pub fn inten(&mut self) -> INTEN_W<IENR1_SPEC> {
                INTEN_W::new(self, 12)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Setting Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`ienr1::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ienr1::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IENR1_SPEC;
        impl crate::RegisterSpec for IENR1_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`ienr1::R`](R) reader structure
        impl crate::Readable for IENR1_SPEC {}
        ///`write(|w| ..)` method takes [`ienr1::W`](W) writer structure
        impl crate::Writable for IENR1_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IENR1 to value 0
        impl crate::Resettable for IENR1_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IENR2 (rw) register accessor: Interrupt Setting Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`ienr2::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ienr2::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@ienr2`]
    ///module
    pub type IENR2 = crate::Reg<ienr2::IENR2_SPEC>;
    ///Interrupt Setting Register
    pub mod ienr2 {
        ///Register `IENR2` reader
        pub type R = crate::R<IENR2_SPEC>;
        ///Register `IENR2` writer
        pub type W = crate::W<IENR2_SPEC>;
        ///Field `INTEN` reader - RW1,INTEN
        pub type INTEN_R = crate::FieldReader;
        ///Field `INTEN` writer - RW1,INTEN
        pub type INTEN_W<'a, REG> = crate::FieldWriter<'a, REG, 4>;
        impl R {
            ///Bits 0:3 - RW1,INTEN
            #[inline(always)]
            pub fn inten(&self) -> INTEN_R {
                INTEN_R::new((self.bits & 0x0f) as u8)
            }
        }
        impl W {
            ///Bits 0:3 - RW1,INTEN
            #[inline(always)]
            #[must_use]
            pub fn inten(&mut self) -> INTEN_W<IENR2_SPEC> {
                INTEN_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Setting Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`ienr2::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ienr2::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IENR2_SPEC;
        impl crate::RegisterSpec for IENR2_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`ienr2::R`](R) reader structure
        impl crate::Readable for IENR2_SPEC {}
        ///`write(|w| ..)` method takes [`ienr2::W`](W) writer structure
        impl crate::Writable for IENR2_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IENR2 to value 0
        impl crate::Resettable for IENR2_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IRER1 (rw) register accessor: Interrupt Clear Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`irer1::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`irer1::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@irer1`]
    ///module
    pub type IRER1 = crate::Reg<irer1::IRER1_SPEC>;
    ///Interrupt Clear Register
    pub mod irer1 {
        ///Register `IRER1` reader
        pub type R = crate::R<IRER1_SPEC>;
        ///Register `IRER1` writer
        pub type W = crate::W<IRER1_SPEC>;
        ///Field `INTRESET` reader - RW1,INTRESET
        pub type INTRESET_R = crate::FieldReader<u32>;
        ///Field `INTRESET` writer - RW1,INTRESET
        pub type INTRESET_W<'a, REG> = crate::FieldWriter<'a, REG, 20, u32>;
        impl R {
            ///Bits 12:31 - RW1,INTRESET
            #[inline(always)]
            pub fn intreset(&self) -> INTRESET_R {
                INTRESET_R::new((self.bits >> 12) & 0x000f_ffff)
            }
        }
        impl W {
            ///Bits 12:31 - RW1,INTRESET
            #[inline(always)]
            #[must_use]
            pub fn intreset(&mut self) -> INTRESET_W<IRER1_SPEC> {
                INTRESET_W::new(self, 12)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Clear Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`irer1::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`irer1::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IRER1_SPEC;
        impl crate::RegisterSpec for IRER1_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`irer1::R`](R) reader structure
        impl crate::Readable for IRER1_SPEC {}
        ///`write(|w| ..)` method takes [`irer1::W`](W) writer structure
        impl crate::Writable for IRER1_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IRER1 to value 0
        impl crate::Resettable for IRER1_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IRER2 (rw) register accessor: Interrupt Clear Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`irer2::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`irer2::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@irer2`]
    ///module
    pub type IRER2 = crate::Reg<irer2::IRER2_SPEC>;
    ///Interrupt Clear Register
    pub mod irer2 {
        ///Register `IRER2` reader
        pub type R = crate::R<IRER2_SPEC>;
        ///Register `IRER2` writer
        pub type W = crate::W<IRER2_SPEC>;
        ///Field `INTRESET` reader - RW1,INTRESET
        pub type INTRESET_R = crate::FieldReader;
        ///Field `INTRESET` writer - RW1,INTRESET
        pub type INTRESET_W<'a, REG> = crate::FieldWriter<'a, REG, 4>;
        impl R {
            ///Bits 0:3 - RW1,INTRESET
            #[inline(always)]
            pub fn intreset(&self) -> INTRESET_R {
                INTRESET_R::new((self.bits & 0x0f) as u8)
            }
        }
        impl W {
            ///Bits 0:3 - RW1,INTRESET
            #[inline(always)]
            #[must_use]
            pub fn intreset(&mut self) -> INTRESET_W<IRER2_SPEC> {
                INTRESET_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Clear Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`irer2::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`irer2::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IRER2_SPEC;
        impl crate::RegisterSpec for IRER2_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`irer2::R`](R) reader structure
        impl crate::Readable for IRER2_SPEC {}
        ///`write(|w| ..)` method takes [`irer2::W`](W) writer structure
        impl crate::Writable for IRER2_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IRER2 to value 0
        impl crate::Resettable for IRER2_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPSR1 (rw) register accessor: Interrupt Pending Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`ipsr1::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ipsr1::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@ipsr1`]
    ///module
    pub type IPSR1 = crate::Reg<ipsr1::IPSR1_SPEC>;
    ///Interrupt Pending Register
    pub mod ipsr1 {
        ///Register `IPSR1` reader
        pub type R = crate::R<IPSR1_SPEC>;
        ///Register `IPSR1` writer
        pub type W = crate::W<IPSR1_SPEC>;
        ///Field `PENDSET` reader - RW1,PENDSET
        pub type PENDSET_R = crate::FieldReader<u32>;
        ///Field `PENDSET` writer - RW1,PENDSET
        pub type PENDSET_W<'a, REG> = crate::FieldWriter<'a, REG, 20, u32>;
        impl R {
            ///Bits 12:31 - RW1,PENDSET
            #[inline(always)]
            pub fn pendset(&self) -> PENDSET_R {
                PENDSET_R::new((self.bits >> 12) & 0x000f_ffff)
            }
        }
        impl W {
            ///Bits 12:31 - RW1,PENDSET
            #[inline(always)]
            #[must_use]
            pub fn pendset(&mut self) -> PENDSET_W<IPSR1_SPEC> {
                PENDSET_W::new(self, 12)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Pending Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`ipsr1::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ipsr1::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPSR1_SPEC;
        impl crate::RegisterSpec for IPSR1_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`ipsr1::R`](R) reader structure
        impl crate::Readable for IPSR1_SPEC {}
        ///`write(|w| ..)` method takes [`ipsr1::W`](W) writer structure
        impl crate::Writable for IPSR1_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPSR1 to value 0
        impl crate::Resettable for IPSR1_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPSR2 (rw) register accessor: Interrupt Pending Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`ipsr2::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ipsr2::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@ipsr2`]
    ///module
    pub type IPSR2 = crate::Reg<ipsr2::IPSR2_SPEC>;
    ///Interrupt Pending Register
    pub mod ipsr2 {
        ///Register `IPSR2` reader
        pub type R = crate::R<IPSR2_SPEC>;
        ///Register `IPSR2` writer
        pub type W = crate::W<IPSR2_SPEC>;
        ///Field `PENDSET` reader - RW1,PENDSET
        pub type PENDSET_R = crate::FieldReader;
        ///Field `PENDSET` writer - RW1,PENDSET
        pub type PENDSET_W<'a, REG> = crate::FieldWriter<'a, REG, 4>;
        impl R {
            ///Bits 0:3 - RW1,PENDSET
            #[inline(always)]
            pub fn pendset(&self) -> PENDSET_R {
                PENDSET_R::new((self.bits & 0x0f) as u8)
            }
        }
        impl W {
            ///Bits 0:3 - RW1,PENDSET
            #[inline(always)]
            #[must_use]
            pub fn pendset(&mut self) -> PENDSET_W<IPSR2_SPEC> {
                PENDSET_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Pending Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`ipsr2::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ipsr2::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPSR2_SPEC;
        impl crate::RegisterSpec for IPSR2_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`ipsr2::R`](R) reader structure
        impl crate::Readable for IPSR2_SPEC {}
        ///`write(|w| ..)` method takes [`ipsr2::W`](W) writer structure
        impl crate::Writable for IPSR2_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPSR2 to value 0
        impl crate::Resettable for IPSR2_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRR1 (rw) register accessor: Interrupt Pending Clear Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprr1::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprr1::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprr1`]
    ///module
    pub type IPRR1 = crate::Reg<iprr1::IPRR1_SPEC>;
    ///Interrupt Pending Clear Register
    pub mod iprr1 {
        ///Register `IPRR1` reader
        pub type R = crate::R<IPRR1_SPEC>;
        ///Register `IPRR1` writer
        pub type W = crate::W<IPRR1_SPEC>;
        ///Field `PENDRESET` reader - RW1,PENDRESET
        pub type PENDRESET_R = crate::FieldReader<u32>;
        ///Field `PENDRESET` writer - RW1,PENDRESET
        pub type PENDRESET_W<'a, REG> = crate::FieldWriter<'a, REG, 20, u32>;
        impl R {
            ///Bits 12:31 - RW1,PENDRESET
            #[inline(always)]
            pub fn pendreset(&self) -> PENDRESET_R {
                PENDRESET_R::new((self.bits >> 12) & 0x000f_ffff)
            }
        }
        impl W {
            ///Bits 12:31 - RW1,PENDRESET
            #[inline(always)]
            #[must_use]
            pub fn pendreset(&mut self) -> PENDRESET_W<IPRR1_SPEC> {
                PENDRESET_W::new(self, 12)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Pending Clear Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprr1::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprr1::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRR1_SPEC;
        impl crate::RegisterSpec for IPRR1_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprr1::R`](R) reader structure
        impl crate::Readable for IPRR1_SPEC {}
        ///`write(|w| ..)` method takes [`iprr1::W`](W) writer structure
        impl crate::Writable for IPRR1_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRR1 to value 0
        impl crate::Resettable for IPRR1_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRR2 (rw) register accessor: Interrupt Pending Clear Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprr2::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprr2::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprr2`]
    ///module
    pub type IPRR2 = crate::Reg<iprr2::IPRR2_SPEC>;
    ///Interrupt Pending Clear Register
    pub mod iprr2 {
        ///Register `IPRR2` reader
        pub type R = crate::R<IPRR2_SPEC>;
        ///Register `IPRR2` writer
        pub type W = crate::W<IPRR2_SPEC>;
        ///Field `PENDRESET` reader - RW1,PENDRESET
        pub type PENDRESET_R = crate::FieldReader;
        ///Field `PENDRESET` writer - RW1,PENDRESET
        pub type PENDRESET_W<'a, REG> = crate::FieldWriter<'a, REG, 4>;
        impl R {
            ///Bits 0:3 - RW1,PENDRESET
            #[inline(always)]
            pub fn pendreset(&self) -> PENDRESET_R {
                PENDRESET_R::new((self.bits & 0x0f) as u8)
            }
        }
        impl W {
            ///Bits 0:3 - RW1,PENDRESET
            #[inline(always)]
            #[must_use]
            pub fn pendreset(&mut self) -> PENDRESET_W<IPRR2_SPEC> {
                PENDRESET_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Pending Clear Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprr2::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprr2::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRR2_SPEC;
        impl crate::RegisterSpec for IPRR2_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprr2::R`](R) reader structure
        impl crate::Readable for IPRR2_SPEC {}
        ///`write(|w| ..)` method takes [`iprr2::W`](W) writer structure
        impl crate::Writable for IPRR2_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRR2 to value 0
        impl crate::Resettable for IPRR2_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IACTR1 (rw) register accessor: Interrupt ACTIVE Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iactr1::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iactr1::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iactr1`]
    ///module
    pub type IACTR1 = crate::Reg<iactr1::IACTR1_SPEC>;
    ///Interrupt ACTIVE Register
    pub mod iactr1 {
        ///Register `IACTR1` reader
        pub type R = crate::R<IACTR1_SPEC>;
        ///Register `IACTR1` writer
        pub type W = crate::W<IACTR1_SPEC>;
        ///Field `IACTS` reader - RW1,IACTS
        pub type IACTS_R = crate::FieldReader<u32>;
        ///Field `IACTS` writer - RW1,IACTS
        pub type IACTS_W<'a, REG> = crate::FieldWriter<'a, REG, 20, u32>;
        impl R {
            ///Bits 12:31 - RW1,IACTS
            #[inline(always)]
            pub fn iacts(&self) -> IACTS_R {
                IACTS_R::new((self.bits >> 12) & 0x000f_ffff)
            }
        }
        impl W {
            ///Bits 12:31 - RW1,IACTS
            #[inline(always)]
            #[must_use]
            pub fn iacts(&mut self) -> IACTS_W<IACTR1_SPEC> {
                IACTS_W::new(self, 12)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt ACTIVE Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iactr1::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iactr1::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IACTR1_SPEC;
        impl crate::RegisterSpec for IACTR1_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iactr1::R`](R) reader structure
        impl crate::Readable for IACTR1_SPEC {}
        ///`write(|w| ..)` method takes [`iactr1::W`](W) writer structure
        impl crate::Writable for IACTR1_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IACTR1 to value 0
        impl crate::Resettable for IACTR1_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IACTR2 (rw) register accessor: Interrupt ACTIVE Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iactr2::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iactr2::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iactr2`]
    ///module
    pub type IACTR2 = crate::Reg<iactr2::IACTR2_SPEC>;
    ///Interrupt ACTIVE Register
    pub mod iactr2 {
        ///Register `IACTR2` reader
        pub type R = crate::R<IACTR2_SPEC>;
        ///Register `IACTR2` writer
        pub type W = crate::W<IACTR2_SPEC>;
        ///Field `IACTS` reader - RW1,IACTS
        pub type IACTS_R = crate::FieldReader;
        ///Field `IACTS` writer - RW1,IACTS
        pub type IACTS_W<'a, REG> = crate::FieldWriter<'a, REG, 4>;
        impl R {
            ///Bits 0:3 - RW1,IACTS
            #[inline(always)]
            pub fn iacts(&self) -> IACTS_R {
                IACTS_R::new((self.bits & 0x0f) as u8)
            }
        }
        impl W {
            ///Bits 0:3 - RW1,IACTS
            #[inline(always)]
            #[must_use]
            pub fn iacts(&mut self) -> IACTS_W<IACTR2_SPEC> {
                IACTS_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt ACTIVE Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iactr2::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iactr2::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IACTR2_SPEC;
        impl crate::RegisterSpec for IACTR2_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iactr2::R`](R) reader structure
        impl crate::Readable for IACTR2_SPEC {}
        ///`write(|w| ..)` method takes [`iactr2::W`](W) writer structure
        impl crate::Writable for IACTR2_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IACTR2 to value 0
        impl crate::Resettable for IACTR2_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR0 (rw) register accessor: Interrupt Priority configuration Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior0::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior0::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior0`]
    ///module
    pub type IPRIOR0 = crate::Reg<iprior0::IPRIOR0_SPEC>;
    ///Interrupt Priority configuration Register
    pub mod iprior0 {
        ///Register `IPRIOR0` reader
        pub type R = crate::R<IPRIOR0_SPEC>;
        ///Register `IPRIOR0` writer
        pub type W = crate::W<IPRIOR0_SPEC>;
        ///Field `IPRIOR0` reader - RW,IPRIOR0
        pub type IPRIOR0_R = crate::FieldReader<u32>;
        ///Field `IPRIOR0` writer - RW,IPRIOR0
        pub type IPRIOR0_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - RW,IPRIOR0
            #[inline(always)]
            pub fn iprior0(&self) -> IPRIOR0_R {
                IPRIOR0_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,IPRIOR0
            #[inline(always)]
            #[must_use]
            pub fn iprior0(&mut self) -> IPRIOR0_W<IPRIOR0_SPEC> {
                IPRIOR0_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior0::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior0::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR0_SPEC;
        impl crate::RegisterSpec for IPRIOR0_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior0::R`](R) reader structure
        impl crate::Readable for IPRIOR0_SPEC {}
        ///`write(|w| ..)` method takes [`iprior0::W`](W) writer structure
        impl crate::Writable for IPRIOR0_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR0 to value 0
        impl crate::Resettable for IPRIOR0_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR1 (rw) register accessor: Interrupt Priority configuration Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior1::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior1::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior1`]
    ///module
    pub type IPRIOR1 = crate::Reg<iprior1::IPRIOR1_SPEC>;
    ///Interrupt Priority configuration Register
    pub mod iprior1 {
        ///Register `IPRIOR1` reader
        pub type R = crate::R<IPRIOR1_SPEC>;
        ///Register `IPRIOR1` writer
        pub type W = crate::W<IPRIOR1_SPEC>;
        ///Field `IPRIOR1` reader - >RW,IPRIOR1
        pub type IPRIOR1_R = crate::FieldReader<u32>;
        ///Field `IPRIOR1` writer - >RW,IPRIOR1
        pub type IPRIOR1_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - >RW,IPRIOR1
            #[inline(always)]
            pub fn iprior1(&self) -> IPRIOR1_R {
                IPRIOR1_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - >RW,IPRIOR1
            #[inline(always)]
            #[must_use]
            pub fn iprior1(&mut self) -> IPRIOR1_W<IPRIOR1_SPEC> {
                IPRIOR1_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior1::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior1::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR1_SPEC;
        impl crate::RegisterSpec for IPRIOR1_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior1::R`](R) reader structure
        impl crate::Readable for IPRIOR1_SPEC {}
        ///`write(|w| ..)` method takes [`iprior1::W`](W) writer structure
        impl crate::Writable for IPRIOR1_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR1 to value 0
        impl crate::Resettable for IPRIOR1_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR2 (rw) register accessor: Interrupt Priority configuration Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior2::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior2::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior2`]
    ///module
    pub type IPRIOR2 = crate::Reg<iprior2::IPRIOR2_SPEC>;
    ///Interrupt Priority configuration Register
    pub mod iprior2 {
        ///Register `IPRIOR2` reader
        pub type R = crate::R<IPRIOR2_SPEC>;
        ///Register `IPRIOR2` writer
        pub type W = crate::W<IPRIOR2_SPEC>;
        ///Field `IPRIOR2` reader - >RW,IPRIOR2
        pub type IPRIOR2_R = crate::FieldReader<u32>;
        ///Field `IPRIOR2` writer - >RW,IPRIOR2
        pub type IPRIOR2_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - >RW,IPRIOR2
            #[inline(always)]
            pub fn iprior2(&self) -> IPRIOR2_R {
                IPRIOR2_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - >RW,IPRIOR2
            #[inline(always)]
            #[must_use]
            pub fn iprior2(&mut self) -> IPRIOR2_W<IPRIOR2_SPEC> {
                IPRIOR2_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior2::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior2::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR2_SPEC;
        impl crate::RegisterSpec for IPRIOR2_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior2::R`](R) reader structure
        impl crate::Readable for IPRIOR2_SPEC {}
        ///`write(|w| ..)` method takes [`iprior2::W`](W) writer structure
        impl crate::Writable for IPRIOR2_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR2 to value 0
        impl crate::Resettable for IPRIOR2_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR3 (rw) register accessor: Interrupt Priority configuration Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior3::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior3::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior3`]
    ///module
    pub type IPRIOR3 = crate::Reg<iprior3::IPRIOR3_SPEC>;
    ///Interrupt Priority configuration Register
    pub mod iprior3 {
        ///Register `IPRIOR3` reader
        pub type R = crate::R<IPRIOR3_SPEC>;
        ///Register `IPRIOR3` writer
        pub type W = crate::W<IPRIOR3_SPEC>;
        ///Field `IPRIOR3` reader - >RW,IPRIOR3
        pub type IPRIOR3_R = crate::FieldReader<u32>;
        ///Field `IPRIOR3` writer - >RW,IPRIOR3
        pub type IPRIOR3_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - >RW,IPRIOR3
            #[inline(always)]
            pub fn iprior3(&self) -> IPRIOR3_R {
                IPRIOR3_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - >RW,IPRIOR3
            #[inline(always)]
            #[must_use]
            pub fn iprior3(&mut self) -> IPRIOR3_W<IPRIOR3_SPEC> {
                IPRIOR3_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior3::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior3::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR3_SPEC;
        impl crate::RegisterSpec for IPRIOR3_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior3::R`](R) reader structure
        impl crate::Readable for IPRIOR3_SPEC {}
        ///`write(|w| ..)` method takes [`iprior3::W`](W) writer structure
        impl crate::Writable for IPRIOR3_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR3 to value 0
        impl crate::Resettable for IPRIOR3_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR4 (rw) register accessor: Interrupt Priority configuration Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior4::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior4::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior4`]
    ///module
    pub type IPRIOR4 = crate::Reg<iprior4::IPRIOR4_SPEC>;
    ///Interrupt Priority configuration Register
    pub mod iprior4 {
        ///Register `IPRIOR4` reader
        pub type R = crate::R<IPRIOR4_SPEC>;
        ///Register `IPRIOR4` writer
        pub type W = crate::W<IPRIOR4_SPEC>;
        ///Field `IPRIOR4` reader - >RW,IPRIOR4
        pub type IPRIOR4_R = crate::FieldReader<u32>;
        ///Field `IPRIOR4` writer - >RW,IPRIOR4
        pub type IPRIOR4_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - >RW,IPRIOR4
            #[inline(always)]
            pub fn iprior4(&self) -> IPRIOR4_R {
                IPRIOR4_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - >RW,IPRIOR4
            #[inline(always)]
            #[must_use]
            pub fn iprior4(&mut self) -> IPRIOR4_W<IPRIOR4_SPEC> {
                IPRIOR4_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior4::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior4::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR4_SPEC;
        impl crate::RegisterSpec for IPRIOR4_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior4::R`](R) reader structure
        impl crate::Readable for IPRIOR4_SPEC {}
        ///`write(|w| ..)` method takes [`iprior4::W`](W) writer structure
        impl crate::Writable for IPRIOR4_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR4 to value 0
        impl crate::Resettable for IPRIOR4_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR5 (rw) register accessor: Interrupt Priority configuration Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior5::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior5::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior5`]
    ///module
    pub type IPRIOR5 = crate::Reg<iprior5::IPRIOR5_SPEC>;
    ///Interrupt Priority configuration Register
    pub mod iprior5 {
        ///Register `IPRIOR5` reader
        pub type R = crate::R<IPRIOR5_SPEC>;
        ///Register `IPRIOR5` writer
        pub type W = crate::W<IPRIOR5_SPEC>;
        ///Field `IPRIOR5` reader - >RW,IPRIOR5
        pub type IPRIOR5_R = crate::FieldReader<u32>;
        ///Field `IPRIOR5` writer - >RW,IPRIOR5
        pub type IPRIOR5_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - >RW,IPRIOR5
            #[inline(always)]
            pub fn iprior5(&self) -> IPRIOR5_R {
                IPRIOR5_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - >RW,IPRIOR5
            #[inline(always)]
            #[must_use]
            pub fn iprior5(&mut self) -> IPRIOR5_W<IPRIOR5_SPEC> {
                IPRIOR5_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior5::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior5::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR5_SPEC;
        impl crate::RegisterSpec for IPRIOR5_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior5::R`](R) reader structure
        impl crate::Readable for IPRIOR5_SPEC {}
        ///`write(|w| ..)` method takes [`iprior5::W`](W) writer structure
        impl crate::Writable for IPRIOR5_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR5 to value 0
        impl crate::Resettable for IPRIOR5_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR6 (rw) register accessor: Interrupt Priority configuration Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior6::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior6::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior6`]
    ///module
    pub type IPRIOR6 = crate::Reg<iprior6::IPRIOR6_SPEC>;
    ///Interrupt Priority configuration Register
    pub mod iprior6 {
        ///Register `IPRIOR6` reader
        pub type R = crate::R<IPRIOR6_SPEC>;
        ///Register `IPRIOR6` writer
        pub type W = crate::W<IPRIOR6_SPEC>;
        ///Field `IPRIOR6` reader - >RW,IPRIOR6
        pub type IPRIOR6_R = crate::FieldReader<u32>;
        ///Field `IPRIOR6` writer - >RW,IPRIOR6
        pub type IPRIOR6_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - >RW,IPRIOR6
            #[inline(always)]
            pub fn iprior6(&self) -> IPRIOR6_R {
                IPRIOR6_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - >RW,IPRIOR6
            #[inline(always)]
            #[must_use]
            pub fn iprior6(&mut self) -> IPRIOR6_W<IPRIOR6_SPEC> {
                IPRIOR6_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior6::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior6::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR6_SPEC;
        impl crate::RegisterSpec for IPRIOR6_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior6::R`](R) reader structure
        impl crate::Readable for IPRIOR6_SPEC {}
        ///`write(|w| ..)` method takes [`iprior6::W`](W) writer structure
        impl crate::Writable for IPRIOR6_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR6 to value 0
        impl crate::Resettable for IPRIOR6_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR7 (rw) register accessor: Interrupt Priority configuration Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior7::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior7::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior7`]
    ///module
    pub type IPRIOR7 = crate::Reg<iprior7::IPRIOR7_SPEC>;
    ///Interrupt Priority configuration Register
    pub mod iprior7 {
        ///Register `IPRIOR7` reader
        pub type R = crate::R<IPRIOR7_SPEC>;
        ///Register `IPRIOR7` writer
        pub type W = crate::W<IPRIOR7_SPEC>;
        ///Field `IPRIOR7` reader - >RW,IPRIOR7
        pub type IPRIOR7_R = crate::FieldReader<u32>;
        ///Field `IPRIOR7` writer - >RW,IPRIOR7
        pub type IPRIOR7_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - >RW,IPRIOR7
            #[inline(always)]
            pub fn iprior7(&self) -> IPRIOR7_R {
                IPRIOR7_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - >RW,IPRIOR7
            #[inline(always)]
            #[must_use]
            pub fn iprior7(&mut self) -> IPRIOR7_W<IPRIOR7_SPEC> {
                IPRIOR7_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior7::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior7::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR7_SPEC;
        impl crate::RegisterSpec for IPRIOR7_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior7::R`](R) reader structure
        impl crate::Readable for IPRIOR7_SPEC {}
        ///`write(|w| ..)` method takes [`iprior7::W`](W) writer structure
        impl crate::Writable for IPRIOR7_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR7 to value 0
        impl crate::Resettable for IPRIOR7_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR8 (rw) register accessor: Interrupt Priority configuration Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior8::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior8::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior8`]
    ///module
    pub type IPRIOR8 = crate::Reg<iprior8::IPRIOR8_SPEC>;
    ///Interrupt Priority configuration Register
    pub mod iprior8 {
        ///Register `IPRIOR8` reader
        pub type R = crate::R<IPRIOR8_SPEC>;
        ///Register `IPRIOR8` writer
        pub type W = crate::W<IPRIOR8_SPEC>;
        ///Field `IPRIOR8` reader - >RW,IPRIOR8
        pub type IPRIOR8_R = crate::FieldReader<u32>;
        ///Field `IPRIOR8` writer - >RW,IPRIOR8
        pub type IPRIOR8_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - >RW,IPRIOR8
            #[inline(always)]
            pub fn iprior8(&self) -> IPRIOR8_R {
                IPRIOR8_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - >RW,IPRIOR8
            #[inline(always)]
            #[must_use]
            pub fn iprior8(&mut self) -> IPRIOR8_W<IPRIOR8_SPEC> {
                IPRIOR8_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior8::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior8::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR8_SPEC;
        impl crate::RegisterSpec for IPRIOR8_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior8::R`](R) reader structure
        impl crate::Readable for IPRIOR8_SPEC {}
        ///`write(|w| ..)` method takes [`iprior8::W`](W) writer structure
        impl crate::Writable for IPRIOR8_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR8 to value 0
        impl crate::Resettable for IPRIOR8_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR9 (rw) register accessor: Interrupt Priority configuration Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior9::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior9::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior9`]
    ///module
    pub type IPRIOR9 = crate::Reg<iprior9::IPRIOR9_SPEC>;
    ///Interrupt Priority configuration Register
    pub mod iprior9 {
        ///Register `IPRIOR9` reader
        pub type R = crate::R<IPRIOR9_SPEC>;
        ///Register `IPRIOR9` writer
        pub type W = crate::W<IPRIOR9_SPEC>;
        ///Field `IPRIOR9` reader - >RW,IPRIOR9
        pub type IPRIOR9_R = crate::FieldReader<u32>;
        ///Field `IPRIOR9` writer - >RW,IPRIOR9
        pub type IPRIOR9_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - >RW,IPRIOR9
            #[inline(always)]
            pub fn iprior9(&self) -> IPRIOR9_R {
                IPRIOR9_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - >RW,IPRIOR9
            #[inline(always)]
            #[must_use]
            pub fn iprior9(&mut self) -> IPRIOR9_W<IPRIOR9_SPEC> {
                IPRIOR9_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior9::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior9::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR9_SPEC;
        impl crate::RegisterSpec for IPRIOR9_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior9::R`](R) reader structure
        impl crate::Readable for IPRIOR9_SPEC {}
        ///`write(|w| ..)` method takes [`iprior9::W`](W) writer structure
        impl crate::Writable for IPRIOR9_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR9 to value 0
        impl crate::Resettable for IPRIOR9_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR10 (rw) register accessor: Interrupt Priority configuration Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior10::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior10::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior10`]
    ///module
    pub type IPRIOR10 = crate::Reg<iprior10::IPRIOR10_SPEC>;
    ///Interrupt Priority configuration Register
    pub mod iprior10 {
        ///Register `IPRIOR10` reader
        pub type R = crate::R<IPRIOR10_SPEC>;
        ///Register `IPRIOR10` writer
        pub type W = crate::W<IPRIOR10_SPEC>;
        ///Field `IPRIOR10` reader - >RW,IPRIOR10
        pub type IPRIOR10_R = crate::FieldReader<u32>;
        ///Field `IPRIOR10` writer - >RW,IPRIOR10
        pub type IPRIOR10_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - >RW,IPRIOR10
            #[inline(always)]
            pub fn iprior10(&self) -> IPRIOR10_R {
                IPRIOR10_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - >RW,IPRIOR10
            #[inline(always)]
            #[must_use]
            pub fn iprior10(&mut self) -> IPRIOR10_W<IPRIOR10_SPEC> {
                IPRIOR10_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior10::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior10::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR10_SPEC;
        impl crate::RegisterSpec for IPRIOR10_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior10::R`](R) reader structure
        impl crate::Readable for IPRIOR10_SPEC {}
        ///`write(|w| ..)` method takes [`iprior10::W`](W) writer structure
        impl crate::Writable for IPRIOR10_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR10 to value 0
        impl crate::Resettable for IPRIOR10_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR11 (rw) register accessor: Interrupt Priority configuration Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior11::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior11::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior11`]
    ///module
    pub type IPRIOR11 = crate::Reg<iprior11::IPRIOR11_SPEC>;
    ///Interrupt Priority configuration Register
    pub mod iprior11 {
        ///Register `IPRIOR11` reader
        pub type R = crate::R<IPRIOR11_SPEC>;
        ///Register `IPRIOR11` writer
        pub type W = crate::W<IPRIOR11_SPEC>;
        ///Field `IPRIOR11` reader - RW,IPRIOR11
        pub type IPRIOR11_R = crate::FieldReader<u32>;
        ///Field `IPRIOR11` writer - RW,IPRIOR11
        pub type IPRIOR11_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - RW,IPRIOR11
            #[inline(always)]
            pub fn iprior11(&self) -> IPRIOR11_R {
                IPRIOR11_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,IPRIOR11
            #[inline(always)]
            #[must_use]
            pub fn iprior11(&mut self) -> IPRIOR11_W<IPRIOR11_SPEC> {
                IPRIOR11_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior11::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior11::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR11_SPEC;
        impl crate::RegisterSpec for IPRIOR11_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior11::R`](R) reader structure
        impl crate::Readable for IPRIOR11_SPEC {}
        ///`write(|w| ..)` method takes [`iprior11::W`](W) writer structure
        impl crate::Writable for IPRIOR11_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR11 to value 0
        impl crate::Resettable for IPRIOR11_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR12 (rw) register accessor: Interrupt Priority configuration Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior12::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior12::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior12`]
    ///module
    pub type IPRIOR12 = crate::Reg<iprior12::IPRIOR12_SPEC>;
    ///Interrupt Priority configuration Register
    pub mod iprior12 {
        ///Register `IPRIOR12` reader
        pub type R = crate::R<IPRIOR12_SPEC>;
        ///Register `IPRIOR12` writer
        pub type W = crate::W<IPRIOR12_SPEC>;
        ///Field `IPRIOR12` reader - RW,IPRIOR12
        pub type IPRIOR12_R = crate::FieldReader<u32>;
        ///Field `IPRIOR12` writer - RW,IPRIOR12
        pub type IPRIOR12_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - RW,IPRIOR12
            #[inline(always)]
            pub fn iprior12(&self) -> IPRIOR12_R {
                IPRIOR12_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,IPRIOR12
            #[inline(always)]
            #[must_use]
            pub fn iprior12(&mut self) -> IPRIOR12_W<IPRIOR12_SPEC> {
                IPRIOR12_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior12::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior12::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR12_SPEC;
        impl crate::RegisterSpec for IPRIOR12_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior12::R`](R) reader structure
        impl crate::Readable for IPRIOR12_SPEC {}
        ///`write(|w| ..)` method takes [`iprior12::W`](W) writer structure
        impl crate::Writable for IPRIOR12_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR12 to value 0
        impl crate::Resettable for IPRIOR12_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR13 (rw) register accessor: Interrupt Priority configuration Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior13::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior13::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior13`]
    ///module
    pub type IPRIOR13 = crate::Reg<iprior13::IPRIOR13_SPEC>;
    ///Interrupt Priority configuration Register
    pub mod iprior13 {
        ///Register `IPRIOR13` reader
        pub type R = crate::R<IPRIOR13_SPEC>;
        ///Register `IPRIOR13` writer
        pub type W = crate::W<IPRIOR13_SPEC>;
        ///Field `IPRIOR13` reader - RW,IPRIOR13
        pub type IPRIOR13_R = crate::FieldReader<u32>;
        ///Field `IPRIOR13` writer - RW,IPRIOR13
        pub type IPRIOR13_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - RW,IPRIOR13
            #[inline(always)]
            pub fn iprior13(&self) -> IPRIOR13_R {
                IPRIOR13_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,IPRIOR13
            #[inline(always)]
            #[must_use]
            pub fn iprior13(&mut self) -> IPRIOR13_W<IPRIOR13_SPEC> {
                IPRIOR13_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior13::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior13::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR13_SPEC;
        impl crate::RegisterSpec for IPRIOR13_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior13::R`](R) reader structure
        impl crate::Readable for IPRIOR13_SPEC {}
        ///`write(|w| ..)` method takes [`iprior13::W`](W) writer structure
        impl crate::Writable for IPRIOR13_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR13 to value 0
        impl crate::Resettable for IPRIOR13_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR14 (rw) register accessor: Interrupt Priority configuration Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior14::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior14::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior14`]
    ///module
    pub type IPRIOR14 = crate::Reg<iprior14::IPRIOR14_SPEC>;
    ///Interrupt Priority configuration Register
    pub mod iprior14 {
        ///Register `IPRIOR14` reader
        pub type R = crate::R<IPRIOR14_SPEC>;
        ///Register `IPRIOR14` writer
        pub type W = crate::W<IPRIOR14_SPEC>;
        ///Field `IPRIOR14` reader - RW,IPRIOR14
        pub type IPRIOR14_R = crate::FieldReader<u32>;
        ///Field `IPRIOR14` writer - RW,IPRIOR14
        pub type IPRIOR14_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - RW,IPRIOR14
            #[inline(always)]
            pub fn iprior14(&self) -> IPRIOR14_R {
                IPRIOR14_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,IPRIOR14
            #[inline(always)]
            #[must_use]
            pub fn iprior14(&mut self) -> IPRIOR14_W<IPRIOR14_SPEC> {
                IPRIOR14_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior14::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior14::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR14_SPEC;
        impl crate::RegisterSpec for IPRIOR14_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior14::R`](R) reader structure
        impl crate::Readable for IPRIOR14_SPEC {}
        ///`write(|w| ..)` method takes [`iprior14::W`](W) writer structure
        impl crate::Writable for IPRIOR14_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR14 to value 0
        impl crate::Resettable for IPRIOR14_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR15 (rw) register accessor: Interrupt Priority configuration Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior15::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior15::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior15`]
    ///module
    pub type IPRIOR15 = crate::Reg<iprior15::IPRIOR15_SPEC>;
    ///Interrupt Priority configuration Register
    pub mod iprior15 {
        ///Register `IPRIOR15` reader
        pub type R = crate::R<IPRIOR15_SPEC>;
        ///Register `IPRIOR15` writer
        pub type W = crate::W<IPRIOR15_SPEC>;
        ///Field `IPRIOR15` reader - RW,IPRIOR15
        pub type IPRIOR15_R = crate::FieldReader<u32>;
        ///Field `IPRIOR15` writer - RW,IPRIOR15
        pub type IPRIOR15_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - RW,IPRIOR15
            #[inline(always)]
            pub fn iprior15(&self) -> IPRIOR15_R {
                IPRIOR15_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,IPRIOR15
            #[inline(always)]
            #[must_use]
            pub fn iprior15(&mut self) -> IPRIOR15_W<IPRIOR15_SPEC> {
                IPRIOR15_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior15::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior15::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR15_SPEC;
        impl crate::RegisterSpec for IPRIOR15_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior15::R`](R) reader structure
        impl crate::Readable for IPRIOR15_SPEC {}
        ///`write(|w| ..)` method takes [`iprior15::W`](W) writer structure
        impl crate::Writable for IPRIOR15_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR15 to value 0
        impl crate::Resettable for IPRIOR15_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR16 (rw) register accessor: Interrupt Priority configuration Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior16::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior16::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior16`]
    ///module
    pub type IPRIOR16 = crate::Reg<iprior16::IPRIOR16_SPEC>;
    ///Interrupt Priority configuration Register
    pub mod iprior16 {
        ///Register `IPRIOR16` reader
        pub type R = crate::R<IPRIOR16_SPEC>;
        ///Register `IPRIOR16` writer
        pub type W = crate::W<IPRIOR16_SPEC>;
        ///Field `IPRIOR16` reader - RW,IPRIOR16
        pub type IPRIOR16_R = crate::FieldReader<u32>;
        ///Field `IPRIOR16` writer - RW,IPRIOR16
        pub type IPRIOR16_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - RW,IPRIOR16
            #[inline(always)]
            pub fn iprior16(&self) -> IPRIOR16_R {
                IPRIOR16_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,IPRIOR16
            #[inline(always)]
            #[must_use]
            pub fn iprior16(&mut self) -> IPRIOR16_W<IPRIOR16_SPEC> {
                IPRIOR16_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior16::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior16::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR16_SPEC;
        impl crate::RegisterSpec for IPRIOR16_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior16::R`](R) reader structure
        impl crate::Readable for IPRIOR16_SPEC {}
        ///`write(|w| ..)` method takes [`iprior16::W`](W) writer structure
        impl crate::Writable for IPRIOR16_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR16 to value 0
        impl crate::Resettable for IPRIOR16_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR17 (rw) register accessor: Interrupt Priority configuration Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior17::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior17::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior17`]
    ///module
    pub type IPRIOR17 = crate::Reg<iprior17::IPRIOR17_SPEC>;
    ///Interrupt Priority configuration Register
    pub mod iprior17 {
        ///Register `IPRIOR17` reader
        pub type R = crate::R<IPRIOR17_SPEC>;
        ///Register `IPRIOR17` writer
        pub type W = crate::W<IPRIOR17_SPEC>;
        ///Field `IPRIOR17` reader - RW,IPRIOR17
        pub type IPRIOR17_R = crate::FieldReader<u32>;
        ///Field `IPRIOR17` writer - RW,IPRIOR17
        pub type IPRIOR17_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - RW,IPRIOR17
            #[inline(always)]
            pub fn iprior17(&self) -> IPRIOR17_R {
                IPRIOR17_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,IPRIOR17
            #[inline(always)]
            #[must_use]
            pub fn iprior17(&mut self) -> IPRIOR17_W<IPRIOR17_SPEC> {
                IPRIOR17_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior17::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior17::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR17_SPEC;
        impl crate::RegisterSpec for IPRIOR17_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior17::R`](R) reader structure
        impl crate::Readable for IPRIOR17_SPEC {}
        ///`write(|w| ..)` method takes [`iprior17::W`](W) writer structure
        impl crate::Writable for IPRIOR17_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR17 to value 0
        impl crate::Resettable for IPRIOR17_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR18 (rw) register accessor: Interrupt Priority configuration Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior18::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior18::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior18`]
    ///module
    pub type IPRIOR18 = crate::Reg<iprior18::IPRIOR18_SPEC>;
    ///Interrupt Priority configuration Register
    pub mod iprior18 {
        ///Register `IPRIOR18` reader
        pub type R = crate::R<IPRIOR18_SPEC>;
        ///Register `IPRIOR18` writer
        pub type W = crate::W<IPRIOR18_SPEC>;
        ///Field `IPRIOR18` reader - RW,IPRIOR18
        pub type IPRIOR18_R = crate::FieldReader<u32>;
        ///Field `IPRIOR18` writer - RW,IPRIOR18
        pub type IPRIOR18_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - RW,IPRIOR18
            #[inline(always)]
            pub fn iprior18(&self) -> IPRIOR18_R {
                IPRIOR18_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,IPRIOR18
            #[inline(always)]
            #[must_use]
            pub fn iprior18(&mut self) -> IPRIOR18_W<IPRIOR18_SPEC> {
                IPRIOR18_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior18::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior18::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR18_SPEC;
        impl crate::RegisterSpec for IPRIOR18_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior18::R`](R) reader structure
        impl crate::Readable for IPRIOR18_SPEC {}
        ///`write(|w| ..)` method takes [`iprior18::W`](W) writer structure
        impl crate::Writable for IPRIOR18_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR18 to value 0
        impl crate::Resettable for IPRIOR18_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR19 (rw) register accessor: Interrupt Priority configuration Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior19::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior19::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior19`]
    ///module
    pub type IPRIOR19 = crate::Reg<iprior19::IPRIOR19_SPEC>;
    ///Interrupt Priority configuration Register
    pub mod iprior19 {
        ///Register `IPRIOR19` reader
        pub type R = crate::R<IPRIOR19_SPEC>;
        ///Register `IPRIOR19` writer
        pub type W = crate::W<IPRIOR19_SPEC>;
        ///Field `IPRIOR19` reader - RW,IPRIOR19
        pub type IPRIOR19_R = crate::FieldReader<u32>;
        ///Field `IPRIOR19` writer - RW,IPRIOR19
        pub type IPRIOR19_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - RW,IPRIOR19
            #[inline(always)]
            pub fn iprior19(&self) -> IPRIOR19_R {
                IPRIOR19_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,IPRIOR19
            #[inline(always)]
            #[must_use]
            pub fn iprior19(&mut self) -> IPRIOR19_W<IPRIOR19_SPEC> {
                IPRIOR19_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior19::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior19::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR19_SPEC;
        impl crate::RegisterSpec for IPRIOR19_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior19::R`](R) reader structure
        impl crate::Readable for IPRIOR19_SPEC {}
        ///`write(|w| ..)` method takes [`iprior19::W`](W) writer structure
        impl crate::Writable for IPRIOR19_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR19 to value 0
        impl crate::Resettable for IPRIOR19_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR20 (rw) register accessor: Interrupt Priority configuration Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior20::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior20::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior20`]
    ///module
    pub type IPRIOR20 = crate::Reg<iprior20::IPRIOR20_SPEC>;
    ///Interrupt Priority configuration Register
    pub mod iprior20 {
        ///Register `IPRIOR20` reader
        pub type R = crate::R<IPRIOR20_SPEC>;
        ///Register `IPRIOR20` writer
        pub type W = crate::W<IPRIOR20_SPEC>;
        ///Field `IPRIOR20` reader - RW,IPRIOR20
        pub type IPRIOR20_R = crate::FieldReader<u32>;
        ///Field `IPRIOR20` writer - RW,IPRIOR20
        pub type IPRIOR20_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - RW,IPRIOR20
            #[inline(always)]
            pub fn iprior20(&self) -> IPRIOR20_R {
                IPRIOR20_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,IPRIOR20
            #[inline(always)]
            #[must_use]
            pub fn iprior20(&mut self) -> IPRIOR20_W<IPRIOR20_SPEC> {
                IPRIOR20_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior20::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior20::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR20_SPEC;
        impl crate::RegisterSpec for IPRIOR20_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior20::R`](R) reader structure
        impl crate::Readable for IPRIOR20_SPEC {}
        ///`write(|w| ..)` method takes [`iprior20::W`](W) writer structure
        impl crate::Writable for IPRIOR20_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR20 to value 0
        impl crate::Resettable for IPRIOR20_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR21 (rw) register accessor: Interrupt Priority configuration Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior21::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior21::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior21`]
    ///module
    pub type IPRIOR21 = crate::Reg<iprior21::IPRIOR21_SPEC>;
    ///Interrupt Priority configuration Register
    pub mod iprior21 {
        ///Register `IPRIOR21` reader
        pub type R = crate::R<IPRIOR21_SPEC>;
        ///Register `IPRIOR21` writer
        pub type W = crate::W<IPRIOR21_SPEC>;
        ///Field `IPRIOR21` reader - RW,IPRIOR21
        pub type IPRIOR21_R = crate::FieldReader<u32>;
        ///Field `IPRIOR21` writer - RW,IPRIOR21
        pub type IPRIOR21_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - RW,IPRIOR21
            #[inline(always)]
            pub fn iprior21(&self) -> IPRIOR21_R {
                IPRIOR21_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,IPRIOR21
            #[inline(always)]
            #[must_use]
            pub fn iprior21(&mut self) -> IPRIOR21_W<IPRIOR21_SPEC> {
                IPRIOR21_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior21::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior21::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR21_SPEC;
        impl crate::RegisterSpec for IPRIOR21_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior21::R`](R) reader structure
        impl crate::Readable for IPRIOR21_SPEC {}
        ///`write(|w| ..)` method takes [`iprior21::W`](W) writer structure
        impl crate::Writable for IPRIOR21_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR21 to value 0
        impl crate::Resettable for IPRIOR21_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR22 (rw) register accessor: Interrupt Priority configuration Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior22::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior22::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior22`]
    ///module
    pub type IPRIOR22 = crate::Reg<iprior22::IPRIOR22_SPEC>;
    ///Interrupt Priority configuration Register
    pub mod iprior22 {
        ///Register `IPRIOR22` reader
        pub type R = crate::R<IPRIOR22_SPEC>;
        ///Register `IPRIOR22` writer
        pub type W = crate::W<IPRIOR22_SPEC>;
        ///Field `IPRIOR22` reader - RW,IPRIOR22
        pub type IPRIOR22_R = crate::FieldReader<u32>;
        ///Field `IPRIOR22` writer - RW,IPRIOR22
        pub type IPRIOR22_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - RW,IPRIOR22
            #[inline(always)]
            pub fn iprior22(&self) -> IPRIOR22_R {
                IPRIOR22_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,IPRIOR22
            #[inline(always)]
            #[must_use]
            pub fn iprior22(&mut self) -> IPRIOR22_W<IPRIOR22_SPEC> {
                IPRIOR22_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior22::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior22::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR22_SPEC;
        impl crate::RegisterSpec for IPRIOR22_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior22::R`](R) reader structure
        impl crate::Readable for IPRIOR22_SPEC {}
        ///`write(|w| ..)` method takes [`iprior22::W`](W) writer structure
        impl crate::Writable for IPRIOR22_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR22 to value 0
        impl crate::Resettable for IPRIOR22_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR23 (rw) register accessor: Interrupt Priority configuration Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior23::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior23::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior23`]
    ///module
    pub type IPRIOR23 = crate::Reg<iprior23::IPRIOR23_SPEC>;
    ///Interrupt Priority configuration Register
    pub mod iprior23 {
        ///Register `IPRIOR23` reader
        pub type R = crate::R<IPRIOR23_SPEC>;
        ///Register `IPRIOR23` writer
        pub type W = crate::W<IPRIOR23_SPEC>;
        ///Field `IPRIOR23` reader - RW,IPRIOR23
        pub type IPRIOR23_R = crate::FieldReader<u32>;
        ///Field `IPRIOR23` writer - RW,IPRIOR23
        pub type IPRIOR23_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - RW,IPRIOR23
            #[inline(always)]
            pub fn iprior23(&self) -> IPRIOR23_R {
                IPRIOR23_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,IPRIOR23
            #[inline(always)]
            #[must_use]
            pub fn iprior23(&mut self) -> IPRIOR23_W<IPRIOR23_SPEC> {
                IPRIOR23_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior23::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior23::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR23_SPEC;
        impl crate::RegisterSpec for IPRIOR23_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior23::R`](R) reader structure
        impl crate::Readable for IPRIOR23_SPEC {}
        ///`write(|w| ..)` method takes [`iprior23::W`](W) writer structure
        impl crate::Writable for IPRIOR23_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR23 to value 0
        impl crate::Resettable for IPRIOR23_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR24 (rw) register accessor: Interrupt Priority configuration Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior24::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior24::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior24`]
    ///module
    pub type IPRIOR24 = crate::Reg<iprior24::IPRIOR24_SPEC>;
    ///Interrupt Priority configuration Register
    pub mod iprior24 {
        ///Register `IPRIOR24` reader
        pub type R = crate::R<IPRIOR24_SPEC>;
        ///Register `IPRIOR24` writer
        pub type W = crate::W<IPRIOR24_SPEC>;
        ///Field `IPRIOR24` reader - RW,IPRIOR24
        pub type IPRIOR24_R = crate::FieldReader<u32>;
        ///Field `IPRIOR24` writer - RW,IPRIOR24
        pub type IPRIOR24_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - RW,IPRIOR24
            #[inline(always)]
            pub fn iprior24(&self) -> IPRIOR24_R {
                IPRIOR24_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,IPRIOR24
            #[inline(always)]
            #[must_use]
            pub fn iprior24(&mut self) -> IPRIOR24_W<IPRIOR24_SPEC> {
                IPRIOR24_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior24::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior24::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR24_SPEC;
        impl crate::RegisterSpec for IPRIOR24_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior24::R`](R) reader structure
        impl crate::Readable for IPRIOR24_SPEC {}
        ///`write(|w| ..)` method takes [`iprior24::W`](W) writer structure
        impl crate::Writable for IPRIOR24_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR24 to value 0
        impl crate::Resettable for IPRIOR24_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR25 (rw) register accessor: Interrupt Priority configuration Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior25::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior25::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior25`]
    ///module
    pub type IPRIOR25 = crate::Reg<iprior25::IPRIOR25_SPEC>;
    ///Interrupt Priority configuration Register
    pub mod iprior25 {
        ///Register `IPRIOR25` reader
        pub type R = crate::R<IPRIOR25_SPEC>;
        ///Register `IPRIOR25` writer
        pub type W = crate::W<IPRIOR25_SPEC>;
        ///Field `IPRIOR25` reader - RW,IPRIOR25
        pub type IPRIOR25_R = crate::FieldReader<u32>;
        ///Field `IPRIOR25` writer - RW,IPRIOR25
        pub type IPRIOR25_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - RW,IPRIOR25
            #[inline(always)]
            pub fn iprior25(&self) -> IPRIOR25_R {
                IPRIOR25_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,IPRIOR25
            #[inline(always)]
            #[must_use]
            pub fn iprior25(&mut self) -> IPRIOR25_W<IPRIOR25_SPEC> {
                IPRIOR25_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior25::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior25::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR25_SPEC;
        impl crate::RegisterSpec for IPRIOR25_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior25::R`](R) reader structure
        impl crate::Readable for IPRIOR25_SPEC {}
        ///`write(|w| ..)` method takes [`iprior25::W`](W) writer structure
        impl crate::Writable for IPRIOR25_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR25 to value 0
        impl crate::Resettable for IPRIOR25_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR26 (rw) register accessor: Interrupt Priority configuration Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior26::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior26::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior26`]
    ///module
    pub type IPRIOR26 = crate::Reg<iprior26::IPRIOR26_SPEC>;
    ///Interrupt Priority configuration Register
    pub mod iprior26 {
        ///Register `IPRIOR26` reader
        pub type R = crate::R<IPRIOR26_SPEC>;
        ///Register `IPRIOR26` writer
        pub type W = crate::W<IPRIOR26_SPEC>;
        ///Field `IPRIOR26` reader - RW,IPRIOR26
        pub type IPRIOR26_R = crate::FieldReader<u32>;
        ///Field `IPRIOR26` writer - RW,IPRIOR26
        pub type IPRIOR26_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - RW,IPRIOR26
            #[inline(always)]
            pub fn iprior26(&self) -> IPRIOR26_R {
                IPRIOR26_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,IPRIOR26
            #[inline(always)]
            #[must_use]
            pub fn iprior26(&mut self) -> IPRIOR26_W<IPRIOR26_SPEC> {
                IPRIOR26_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior26::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior26::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR26_SPEC;
        impl crate::RegisterSpec for IPRIOR26_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior26::R`](R) reader structure
        impl crate::Readable for IPRIOR26_SPEC {}
        ///`write(|w| ..)` method takes [`iprior26::W`](W) writer structure
        impl crate::Writable for IPRIOR26_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR26 to value 0
        impl crate::Resettable for IPRIOR26_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR27 (rw) register accessor: Interrupt Priority configuration Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior27::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior27::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior27`]
    ///module
    pub type IPRIOR27 = crate::Reg<iprior27::IPRIOR27_SPEC>;
    ///Interrupt Priority configuration Register
    pub mod iprior27 {
        ///Register `IPRIOR27` reader
        pub type R = crate::R<IPRIOR27_SPEC>;
        ///Register `IPRIOR27` writer
        pub type W = crate::W<IPRIOR27_SPEC>;
        ///Field `IPRIOR27` reader - RW,IPRIOR27
        pub type IPRIOR27_R = crate::FieldReader<u32>;
        ///Field `IPRIOR27` writer - RW,IPRIOR27
        pub type IPRIOR27_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - RW,IPRIOR27
            #[inline(always)]
            pub fn iprior27(&self) -> IPRIOR27_R {
                IPRIOR27_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,IPRIOR27
            #[inline(always)]
            #[must_use]
            pub fn iprior27(&mut self) -> IPRIOR27_W<IPRIOR27_SPEC> {
                IPRIOR27_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior27::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior27::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR27_SPEC;
        impl crate::RegisterSpec for IPRIOR27_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior27::R`](R) reader structure
        impl crate::Readable for IPRIOR27_SPEC {}
        ///`write(|w| ..)` method takes [`iprior27::W`](W) writer structure
        impl crate::Writable for IPRIOR27_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR27 to value 0
        impl crate::Resettable for IPRIOR27_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR28 (rw) register accessor: Interrupt Priority configuration Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior28::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior28::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior28`]
    ///module
    pub type IPRIOR28 = crate::Reg<iprior28::IPRIOR28_SPEC>;
    ///Interrupt Priority configuration Register
    pub mod iprior28 {
        ///Register `IPRIOR28` reader
        pub type R = crate::R<IPRIOR28_SPEC>;
        ///Register `IPRIOR28` writer
        pub type W = crate::W<IPRIOR28_SPEC>;
        ///Field `IPRIOR28` reader - RW,IPRIOR28
        pub type IPRIOR28_R = crate::FieldReader<u32>;
        ///Field `IPRIOR28` writer - RW,IPRIOR28
        pub type IPRIOR28_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - RW,IPRIOR28
            #[inline(always)]
            pub fn iprior28(&self) -> IPRIOR28_R {
                IPRIOR28_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,IPRIOR28
            #[inline(always)]
            #[must_use]
            pub fn iprior28(&mut self) -> IPRIOR28_W<IPRIOR28_SPEC> {
                IPRIOR28_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior28::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior28::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR28_SPEC;
        impl crate::RegisterSpec for IPRIOR28_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior28::R`](R) reader structure
        impl crate::Readable for IPRIOR28_SPEC {}
        ///`write(|w| ..)` method takes [`iprior28::W`](W) writer structure
        impl crate::Writable for IPRIOR28_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR28 to value 0
        impl crate::Resettable for IPRIOR28_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR29 (rw) register accessor: Interrupt Priority configuration Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior29::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior29::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior29`]
    ///module
    pub type IPRIOR29 = crate::Reg<iprior29::IPRIOR29_SPEC>;
    ///Interrupt Priority configuration Register
    pub mod iprior29 {
        ///Register `IPRIOR29` reader
        pub type R = crate::R<IPRIOR29_SPEC>;
        ///Register `IPRIOR29` writer
        pub type W = crate::W<IPRIOR29_SPEC>;
        ///Field `IPRIOR29` reader - RW,IPRIOR29
        pub type IPRIOR29_R = crate::FieldReader<u32>;
        ///Field `IPRIOR29` writer - RW,IPRIOR29
        pub type IPRIOR29_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - RW,IPRIOR29
            #[inline(always)]
            pub fn iprior29(&self) -> IPRIOR29_R {
                IPRIOR29_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,IPRIOR29
            #[inline(always)]
            #[must_use]
            pub fn iprior29(&mut self) -> IPRIOR29_W<IPRIOR29_SPEC> {
                IPRIOR29_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior29::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior29::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR29_SPEC;
        impl crate::RegisterSpec for IPRIOR29_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior29::R`](R) reader structure
        impl crate::Readable for IPRIOR29_SPEC {}
        ///`write(|w| ..)` method takes [`iprior29::W`](W) writer structure
        impl crate::Writable for IPRIOR29_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR29 to value 0
        impl crate::Resettable for IPRIOR29_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR30 (rw) register accessor: Interrupt Priority configuration Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior30::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior30::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior30`]
    ///module
    pub type IPRIOR30 = crate::Reg<iprior30::IPRIOR30_SPEC>;
    ///Interrupt Priority configuration Register
    pub mod iprior30 {
        ///Register `IPRIOR30` reader
        pub type R = crate::R<IPRIOR30_SPEC>;
        ///Register `IPRIOR30` writer
        pub type W = crate::W<IPRIOR30_SPEC>;
        ///Field `IPRIOR30` reader - RW,IPRIOR30
        pub type IPRIOR30_R = crate::FieldReader<u32>;
        ///Field `IPRIOR30` writer - RW,IPRIOR30
        pub type IPRIOR30_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - RW,IPRIOR30
            #[inline(always)]
            pub fn iprior30(&self) -> IPRIOR30_R {
                IPRIOR30_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,IPRIOR30
            #[inline(always)]
            #[must_use]
            pub fn iprior30(&mut self) -> IPRIOR30_W<IPRIOR30_SPEC> {
                IPRIOR30_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior30::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior30::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR30_SPEC;
        impl crate::RegisterSpec for IPRIOR30_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior30::R`](R) reader structure
        impl crate::Readable for IPRIOR30_SPEC {}
        ///`write(|w| ..)` method takes [`iprior30::W`](W) writer structure
        impl crate::Writable for IPRIOR30_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR30 to value 0
        impl crate::Resettable for IPRIOR30_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR31 (rw) register accessor: Interrupt Priority configuration Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior31::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior31::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior31`]
    ///module
    pub type IPRIOR31 = crate::Reg<iprior31::IPRIOR31_SPEC>;
    ///Interrupt Priority configuration Register
    pub mod iprior31 {
        ///Register `IPRIOR31` reader
        pub type R = crate::R<IPRIOR31_SPEC>;
        ///Register `IPRIOR31` writer
        pub type W = crate::W<IPRIOR31_SPEC>;
        ///Field `IPRIOR31` reader - RW,IPRIOR31
        pub type IPRIOR31_R = crate::FieldReader<u32>;
        ///Field `IPRIOR31` writer - RW,IPRIOR31
        pub type IPRIOR31_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - RW,IPRIOR31
            #[inline(always)]
            pub fn iprior31(&self) -> IPRIOR31_R {
                IPRIOR31_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,IPRIOR31
            #[inline(always)]
            #[must_use]
            pub fn iprior31(&mut self) -> IPRIOR31_W<IPRIOR31_SPEC> {
                IPRIOR31_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior31::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior31::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR31_SPEC;
        impl crate::RegisterSpec for IPRIOR31_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior31::R`](R) reader structure
        impl crate::Readable for IPRIOR31_SPEC {}
        ///`write(|w| ..)` method takes [`iprior31::W`](W) writer structure
        impl crate::Writable for IPRIOR31_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR31 to value 0
        impl crate::Resettable for IPRIOR31_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR32 (rw) register accessor: Interrupt Priority configuration Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior32::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior32::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior32`]
    ///module
    pub type IPRIOR32 = crate::Reg<iprior32::IPRIOR32_SPEC>;
    ///Interrupt Priority configuration Register
    pub mod iprior32 {
        ///Register `IPRIOR32` reader
        pub type R = crate::R<IPRIOR32_SPEC>;
        ///Register `IPRIOR32` writer
        pub type W = crate::W<IPRIOR32_SPEC>;
        ///Field `IPRIOR32` reader - RW,IPRIOR32
        pub type IPRIOR32_R = crate::FieldReader<u32>;
        ///Field `IPRIOR32` writer - RW,IPRIOR32
        pub type IPRIOR32_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - RW,IPRIOR32
            #[inline(always)]
            pub fn iprior32(&self) -> IPRIOR32_R {
                IPRIOR32_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,IPRIOR32
            #[inline(always)]
            #[must_use]
            pub fn iprior32(&mut self) -> IPRIOR32_W<IPRIOR32_SPEC> {
                IPRIOR32_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior32::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior32::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR32_SPEC;
        impl crate::RegisterSpec for IPRIOR32_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior32::R`](R) reader structure
        impl crate::Readable for IPRIOR32_SPEC {}
        ///`write(|w| ..)` method takes [`iprior32::W`](W) writer structure
        impl crate::Writable for IPRIOR32_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR32 to value 0
        impl crate::Resettable for IPRIOR32_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR33 (rw) register accessor: Interrupt Priority configuration Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior33::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior33::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior33`]
    ///module
    pub type IPRIOR33 = crate::Reg<iprior33::IPRIOR33_SPEC>;
    ///Interrupt Priority configuration Register
    pub mod iprior33 {
        ///Register `IPRIOR33` reader
        pub type R = crate::R<IPRIOR33_SPEC>;
        ///Register `IPRIOR33` writer
        pub type W = crate::W<IPRIOR33_SPEC>;
        ///Field `IPRIOR33` reader - RW,IPRIOR33
        pub type IPRIOR33_R = crate::FieldReader<u32>;
        ///Field `IPRIOR33` writer - RW,IPRIOR33
        pub type IPRIOR33_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - RW,IPRIOR33
            #[inline(always)]
            pub fn iprior33(&self) -> IPRIOR33_R {
                IPRIOR33_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,IPRIOR33
            #[inline(always)]
            #[must_use]
            pub fn iprior33(&mut self) -> IPRIOR33_W<IPRIOR33_SPEC> {
                IPRIOR33_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior33::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior33::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR33_SPEC;
        impl crate::RegisterSpec for IPRIOR33_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior33::R`](R) reader structure
        impl crate::Readable for IPRIOR33_SPEC {}
        ///`write(|w| ..)` method takes [`iprior33::W`](W) writer structure
        impl crate::Writable for IPRIOR33_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR33 to value 0
        impl crate::Resettable for IPRIOR33_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR34 (rw) register accessor: Interrupt Priority configuration Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior34::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior34::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior34`]
    ///module
    pub type IPRIOR34 = crate::Reg<iprior34::IPRIOR34_SPEC>;
    ///Interrupt Priority configuration Register
    pub mod iprior34 {
        ///Register `IPRIOR34` reader
        pub type R = crate::R<IPRIOR34_SPEC>;
        ///Register `IPRIOR34` writer
        pub type W = crate::W<IPRIOR34_SPEC>;
        ///Field `IPRIOR34` reader - RW,IPRIOR34
        pub type IPRIOR34_R = crate::FieldReader<u32>;
        ///Field `IPRIOR34` writer - RW,IPRIOR34
        pub type IPRIOR34_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - RW,IPRIOR34
            #[inline(always)]
            pub fn iprior34(&self) -> IPRIOR34_R {
                IPRIOR34_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,IPRIOR34
            #[inline(always)]
            #[must_use]
            pub fn iprior34(&mut self) -> IPRIOR34_W<IPRIOR34_SPEC> {
                IPRIOR34_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior34::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior34::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR34_SPEC;
        impl crate::RegisterSpec for IPRIOR34_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior34::R`](R) reader structure
        impl crate::Readable for IPRIOR34_SPEC {}
        ///`write(|w| ..)` method takes [`iprior34::W`](W) writer structure
        impl crate::Writable for IPRIOR34_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR34 to value 0
        impl crate::Resettable for IPRIOR34_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR35 (rw) register accessor: Interrupt Priority configuration Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior35::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior35::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior35`]
    ///module
    pub type IPRIOR35 = crate::Reg<iprior35::IPRIOR35_SPEC>;
    ///Interrupt Priority configuration Register
    pub mod iprior35 {
        ///Register `IPRIOR35` reader
        pub type R = crate::R<IPRIOR35_SPEC>;
        ///Register `IPRIOR35` writer
        pub type W = crate::W<IPRIOR35_SPEC>;
        ///Field `IPRIOR35` reader - RW,IPRIOR35
        pub type IPRIOR35_R = crate::FieldReader<u32>;
        ///Field `IPRIOR35` writer - RW,IPRIOR35
        pub type IPRIOR35_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - RW,IPRIOR35
            #[inline(always)]
            pub fn iprior35(&self) -> IPRIOR35_R {
                IPRIOR35_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,IPRIOR35
            #[inline(always)]
            #[must_use]
            pub fn iprior35(&mut self) -> IPRIOR35_W<IPRIOR35_SPEC> {
                IPRIOR35_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior35::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior35::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR35_SPEC;
        impl crate::RegisterSpec for IPRIOR35_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior35::R`](R) reader structure
        impl crate::Readable for IPRIOR35_SPEC {}
        ///`write(|w| ..)` method takes [`iprior35::W`](W) writer structure
        impl crate::Writable for IPRIOR35_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR35 to value 0
        impl crate::Resettable for IPRIOR35_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR36 (rw) register accessor: Interrupt Priority configuration Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior36::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior36::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior36`]
    ///module
    pub type IPRIOR36 = crate::Reg<iprior36::IPRIOR36_SPEC>;
    ///Interrupt Priority configuration Register
    pub mod iprior36 {
        ///Register `IPRIOR36` reader
        pub type R = crate::R<IPRIOR36_SPEC>;
        ///Register `IPRIOR36` writer
        pub type W = crate::W<IPRIOR36_SPEC>;
        ///Field `IPRIOR36` reader - RW,IPRIOR36
        pub type IPRIOR36_R = crate::FieldReader<u32>;
        ///Field `IPRIOR36` writer - RW,IPRIOR36
        pub type IPRIOR36_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - RW,IPRIOR36
            #[inline(always)]
            pub fn iprior36(&self) -> IPRIOR36_R {
                IPRIOR36_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,IPRIOR36
            #[inline(always)]
            #[must_use]
            pub fn iprior36(&mut self) -> IPRIOR36_W<IPRIOR36_SPEC> {
                IPRIOR36_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior36::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior36::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR36_SPEC;
        impl crate::RegisterSpec for IPRIOR36_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior36::R`](R) reader structure
        impl crate::Readable for IPRIOR36_SPEC {}
        ///`write(|w| ..)` method takes [`iprior36::W`](W) writer structure
        impl crate::Writable for IPRIOR36_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR36 to value 0
        impl crate::Resettable for IPRIOR36_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR37 (rw) register accessor: Interrupt Priority configuration Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior37::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior37::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior37`]
    ///module
    pub type IPRIOR37 = crate::Reg<iprior37::IPRIOR37_SPEC>;
    ///Interrupt Priority configuration Register
    pub mod iprior37 {
        ///Register `IPRIOR37` reader
        pub type R = crate::R<IPRIOR37_SPEC>;
        ///Register `IPRIOR37` writer
        pub type W = crate::W<IPRIOR37_SPEC>;
        ///Field `IPRIOR37` reader - RW,IPRIOR37
        pub type IPRIOR37_R = crate::FieldReader<u32>;
        ///Field `IPRIOR37` writer - RW,IPRIOR37
        pub type IPRIOR37_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - RW,IPRIOR37
            #[inline(always)]
            pub fn iprior37(&self) -> IPRIOR37_R {
                IPRIOR37_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,IPRIOR37
            #[inline(always)]
            #[must_use]
            pub fn iprior37(&mut self) -> IPRIOR37_W<IPRIOR37_SPEC> {
                IPRIOR37_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior37::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior37::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR37_SPEC;
        impl crate::RegisterSpec for IPRIOR37_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior37::R`](R) reader structure
        impl crate::Readable for IPRIOR37_SPEC {}
        ///`write(|w| ..)` method takes [`iprior37::W`](W) writer structure
        impl crate::Writable for IPRIOR37_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR37 to value 0
        impl crate::Resettable for IPRIOR37_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR38 (rw) register accessor: Interrupt Priority configuration Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior38::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior38::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior38`]
    ///module
    pub type IPRIOR38 = crate::Reg<iprior38::IPRIOR38_SPEC>;
    ///Interrupt Priority configuration Register
    pub mod iprior38 {
        ///Register `IPRIOR38` reader
        pub type R = crate::R<IPRIOR38_SPEC>;
        ///Register `IPRIOR38` writer
        pub type W = crate::W<IPRIOR38_SPEC>;
        ///Field `IPRIOR38` reader - RW,IPRIOR38
        pub type IPRIOR38_R = crate::FieldReader<u32>;
        ///Field `IPRIOR38` writer - RW,IPRIOR38
        pub type IPRIOR38_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - RW,IPRIOR38
            #[inline(always)]
            pub fn iprior38(&self) -> IPRIOR38_R {
                IPRIOR38_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,IPRIOR38
            #[inline(always)]
            #[must_use]
            pub fn iprior38(&mut self) -> IPRIOR38_W<IPRIOR38_SPEC> {
                IPRIOR38_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior38::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior38::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR38_SPEC;
        impl crate::RegisterSpec for IPRIOR38_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior38::R`](R) reader structure
        impl crate::Readable for IPRIOR38_SPEC {}
        ///`write(|w| ..)` method takes [`iprior38::W`](W) writer structure
        impl crate::Writable for IPRIOR38_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR38 to value 0
        impl crate::Resettable for IPRIOR38_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR39 (rw) register accessor: Interrupt Priority configuration Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior39::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior39::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior39`]
    ///module
    pub type IPRIOR39 = crate::Reg<iprior39::IPRIOR39_SPEC>;
    ///Interrupt Priority configuration Register
    pub mod iprior39 {
        ///Register `IPRIOR39` reader
        pub type R = crate::R<IPRIOR39_SPEC>;
        ///Register `IPRIOR39` writer
        pub type W = crate::W<IPRIOR39_SPEC>;
        ///Field `IPRIOR39` reader - RW,IPRIOR39
        pub type IPRIOR39_R = crate::FieldReader<u32>;
        ///Field `IPRIOR39` writer - RW,IPRIOR39
        pub type IPRIOR39_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - RW,IPRIOR39
            #[inline(always)]
            pub fn iprior39(&self) -> IPRIOR39_R {
                IPRIOR39_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,IPRIOR39
            #[inline(always)]
            #[must_use]
            pub fn iprior39(&mut self) -> IPRIOR39_W<IPRIOR39_SPEC> {
                IPRIOR39_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior39::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior39::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR39_SPEC;
        impl crate::RegisterSpec for IPRIOR39_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior39::R`](R) reader structure
        impl crate::Readable for IPRIOR39_SPEC {}
        ///`write(|w| ..)` method takes [`iprior39::W`](W) writer structure
        impl crate::Writable for IPRIOR39_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR39 to value 0
        impl crate::Resettable for IPRIOR39_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR40 (rw) register accessor: Interrupt Priority configuration Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior40::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior40::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior40`]
    ///module
    pub type IPRIOR40 = crate::Reg<iprior40::IPRIOR40_SPEC>;
    ///Interrupt Priority configuration Register
    pub mod iprior40 {
        ///Register `IPRIOR40` reader
        pub type R = crate::R<IPRIOR40_SPEC>;
        ///Register `IPRIOR40` writer
        pub type W = crate::W<IPRIOR40_SPEC>;
        ///Field `IPRIOR40` reader - RW,IPRIOR40
        pub type IPRIOR40_R = crate::FieldReader<u32>;
        ///Field `IPRIOR40` writer - RW,IPRIOR40
        pub type IPRIOR40_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - RW,IPRIOR40
            #[inline(always)]
            pub fn iprior40(&self) -> IPRIOR40_R {
                IPRIOR40_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,IPRIOR40
            #[inline(always)]
            #[must_use]
            pub fn iprior40(&mut self) -> IPRIOR40_W<IPRIOR40_SPEC> {
                IPRIOR40_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior40::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior40::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR40_SPEC;
        impl crate::RegisterSpec for IPRIOR40_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior40::R`](R) reader structure
        impl crate::Readable for IPRIOR40_SPEC {}
        ///`write(|w| ..)` method takes [`iprior40::W`](W) writer structure
        impl crate::Writable for IPRIOR40_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR40 to value 0
        impl crate::Resettable for IPRIOR40_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR41 (rw) register accessor: Interrupt Priority configuration Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior41::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior41::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior41`]
    ///module
    pub type IPRIOR41 = crate::Reg<iprior41::IPRIOR41_SPEC>;
    ///Interrupt Priority configuration Register
    pub mod iprior41 {
        ///Register `IPRIOR41` reader
        pub type R = crate::R<IPRIOR41_SPEC>;
        ///Register `IPRIOR41` writer
        pub type W = crate::W<IPRIOR41_SPEC>;
        ///Field `IPRIOR41` reader - RW,IPRIOR41
        pub type IPRIOR41_R = crate::FieldReader<u32>;
        ///Field `IPRIOR41` writer - RW,IPRIOR41
        pub type IPRIOR41_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - RW,IPRIOR41
            #[inline(always)]
            pub fn iprior41(&self) -> IPRIOR41_R {
                IPRIOR41_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,IPRIOR41
            #[inline(always)]
            #[must_use]
            pub fn iprior41(&mut self) -> IPRIOR41_W<IPRIOR41_SPEC> {
                IPRIOR41_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior41::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior41::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR41_SPEC;
        impl crate::RegisterSpec for IPRIOR41_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior41::R`](R) reader structure
        impl crate::Readable for IPRIOR41_SPEC {}
        ///`write(|w| ..)` method takes [`iprior41::W`](W) writer structure
        impl crate::Writable for IPRIOR41_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR41 to value 0
        impl crate::Resettable for IPRIOR41_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR42 (rw) register accessor: Interrupt Priority configuration Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior42::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior42::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior42`]
    ///module
    pub type IPRIOR42 = crate::Reg<iprior42::IPRIOR42_SPEC>;
    ///Interrupt Priority configuration Register
    pub mod iprior42 {
        ///Register `IPRIOR42` reader
        pub type R = crate::R<IPRIOR42_SPEC>;
        ///Register `IPRIOR42` writer
        pub type W = crate::W<IPRIOR42_SPEC>;
        ///Field `IPRIOR42` reader - RW,IPRIOR42
        pub type IPRIOR42_R = crate::FieldReader<u32>;
        ///Field `IPRIOR42` writer - RW,IPRIOR42
        pub type IPRIOR42_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - RW,IPRIOR42
            #[inline(always)]
            pub fn iprior42(&self) -> IPRIOR42_R {
                IPRIOR42_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,IPRIOR42
            #[inline(always)]
            #[must_use]
            pub fn iprior42(&mut self) -> IPRIOR42_W<IPRIOR42_SPEC> {
                IPRIOR42_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior42::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior42::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR42_SPEC;
        impl crate::RegisterSpec for IPRIOR42_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior42::R`](R) reader structure
        impl crate::Readable for IPRIOR42_SPEC {}
        ///`write(|w| ..)` method takes [`iprior42::W`](W) writer structure
        impl crate::Writable for IPRIOR42_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR42 to value 0
        impl crate::Resettable for IPRIOR42_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR43 (rw) register accessor: Interrupt Priority configuration Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior43::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior43::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior43`]
    ///module
    pub type IPRIOR43 = crate::Reg<iprior43::IPRIOR43_SPEC>;
    ///Interrupt Priority configuration Register
    pub mod iprior43 {
        ///Register `IPRIOR43` reader
        pub type R = crate::R<IPRIOR43_SPEC>;
        ///Register `IPRIOR43` writer
        pub type W = crate::W<IPRIOR43_SPEC>;
        ///Field `IPRIOR43` reader - RW,IPRIOR43
        pub type IPRIOR43_R = crate::FieldReader<u32>;
        ///Field `IPRIOR43` writer - RW,IPRIOR43
        pub type IPRIOR43_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - RW,IPRIOR43
            #[inline(always)]
            pub fn iprior43(&self) -> IPRIOR43_R {
                IPRIOR43_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,IPRIOR43
            #[inline(always)]
            #[must_use]
            pub fn iprior43(&mut self) -> IPRIOR43_W<IPRIOR43_SPEC> {
                IPRIOR43_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior43::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior43::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR43_SPEC;
        impl crate::RegisterSpec for IPRIOR43_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior43::R`](R) reader structure
        impl crate::Readable for IPRIOR43_SPEC {}
        ///`write(|w| ..)` method takes [`iprior43::W`](W) writer structure
        impl crate::Writable for IPRIOR43_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR43 to value 0
        impl crate::Resettable for IPRIOR43_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR44 (rw) register accessor: Interrupt Priority configuration Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior44::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior44::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior44`]
    ///module
    pub type IPRIOR44 = crate::Reg<iprior44::IPRIOR44_SPEC>;
    ///Interrupt Priority configuration Register
    pub mod iprior44 {
        ///Register `IPRIOR44` reader
        pub type R = crate::R<IPRIOR44_SPEC>;
        ///Register `IPRIOR44` writer
        pub type W = crate::W<IPRIOR44_SPEC>;
        ///Field `IPRIOR44` reader - RW,IPRIOR44
        pub type IPRIOR44_R = crate::FieldReader<u32>;
        ///Field `IPRIOR44` writer - RW,IPRIOR44
        pub type IPRIOR44_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - RW,IPRIOR44
            #[inline(always)]
            pub fn iprior44(&self) -> IPRIOR44_R {
                IPRIOR44_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,IPRIOR44
            #[inline(always)]
            #[must_use]
            pub fn iprior44(&mut self) -> IPRIOR44_W<IPRIOR44_SPEC> {
                IPRIOR44_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior44::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior44::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR44_SPEC;
        impl crate::RegisterSpec for IPRIOR44_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior44::R`](R) reader structure
        impl crate::Readable for IPRIOR44_SPEC {}
        ///`write(|w| ..)` method takes [`iprior44::W`](W) writer structure
        impl crate::Writable for IPRIOR44_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR44 to value 0
        impl crate::Resettable for IPRIOR44_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR45 (rw) register accessor: Interrupt Priority configuration Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior45::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior45::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior45`]
    ///module
    pub type IPRIOR45 = crate::Reg<iprior45::IPRIOR45_SPEC>;
    ///Interrupt Priority configuration Register
    pub mod iprior45 {
        ///Register `IPRIOR45` reader
        pub type R = crate::R<IPRIOR45_SPEC>;
        ///Register `IPRIOR45` writer
        pub type W = crate::W<IPRIOR45_SPEC>;
        ///Field `IPRIOR45` reader - RW,IPRIOR45
        pub type IPRIOR45_R = crate::FieldReader<u32>;
        ///Field `IPRIOR45` writer - RW,IPRIOR45
        pub type IPRIOR45_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - RW,IPRIOR45
            #[inline(always)]
            pub fn iprior45(&self) -> IPRIOR45_R {
                IPRIOR45_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,IPRIOR45
            #[inline(always)]
            #[must_use]
            pub fn iprior45(&mut self) -> IPRIOR45_W<IPRIOR45_SPEC> {
                IPRIOR45_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior45::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior45::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR45_SPEC;
        impl crate::RegisterSpec for IPRIOR45_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior45::R`](R) reader structure
        impl crate::Readable for IPRIOR45_SPEC {}
        ///`write(|w| ..)` method takes [`iprior45::W`](W) writer structure
        impl crate::Writable for IPRIOR45_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR45 to value 0
        impl crate::Resettable for IPRIOR45_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR46 (rw) register accessor: Interrupt Priority configuration Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior46::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior46::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior46`]
    ///module
    pub type IPRIOR46 = crate::Reg<iprior46::IPRIOR46_SPEC>;
    ///Interrupt Priority configuration Register
    pub mod iprior46 {
        ///Register `IPRIOR46` reader
        pub type R = crate::R<IPRIOR46_SPEC>;
        ///Register `IPRIOR46` writer
        pub type W = crate::W<IPRIOR46_SPEC>;
        ///Field `IPRIOR46` reader - RW,IPRIOR46
        pub type IPRIOR46_R = crate::FieldReader<u32>;
        ///Field `IPRIOR46` writer - RW,IPRIOR46
        pub type IPRIOR46_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - RW,IPRIOR46
            #[inline(always)]
            pub fn iprior46(&self) -> IPRIOR46_R {
                IPRIOR46_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,IPRIOR46
            #[inline(always)]
            #[must_use]
            pub fn iprior46(&mut self) -> IPRIOR46_W<IPRIOR46_SPEC> {
                IPRIOR46_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior46::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior46::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR46_SPEC;
        impl crate::RegisterSpec for IPRIOR46_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior46::R`](R) reader structure
        impl crate::Readable for IPRIOR46_SPEC {}
        ///`write(|w| ..)` method takes [`iprior46::W`](W) writer structure
        impl crate::Writable for IPRIOR46_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR46 to value 0
        impl crate::Resettable for IPRIOR46_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR47 (rw) register accessor: Interrupt Priority configuration Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior47::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior47::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior47`]
    ///module
    pub type IPRIOR47 = crate::Reg<iprior47::IPRIOR47_SPEC>;
    ///Interrupt Priority configuration Register
    pub mod iprior47 {
        ///Register `IPRIOR47` reader
        pub type R = crate::R<IPRIOR47_SPEC>;
        ///Register `IPRIOR47` writer
        pub type W = crate::W<IPRIOR47_SPEC>;
        ///Field `IPRIOR47` reader - RW,IPRIOR47
        pub type IPRIOR47_R = crate::FieldReader<u32>;
        ///Field `IPRIOR47` writer - RW,IPRIOR47
        pub type IPRIOR47_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - RW,IPRIOR47
            #[inline(always)]
            pub fn iprior47(&self) -> IPRIOR47_R {
                IPRIOR47_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,IPRIOR47
            #[inline(always)]
            #[must_use]
            pub fn iprior47(&mut self) -> IPRIOR47_W<IPRIOR47_SPEC> {
                IPRIOR47_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior47::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior47::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR47_SPEC;
        impl crate::RegisterSpec for IPRIOR47_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior47::R`](R) reader structure
        impl crate::Readable for IPRIOR47_SPEC {}
        ///`write(|w| ..)` method takes [`iprior47::W`](W) writer structure
        impl crate::Writable for IPRIOR47_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR47 to value 0
        impl crate::Resettable for IPRIOR47_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR48 (rw) register accessor: Interrupt Priority configuration Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior48::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior48::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior48`]
    ///module
    pub type IPRIOR48 = crate::Reg<iprior48::IPRIOR48_SPEC>;
    ///Interrupt Priority configuration Register
    pub mod iprior48 {
        ///Register `IPRIOR48` reader
        pub type R = crate::R<IPRIOR48_SPEC>;
        ///Register `IPRIOR48` writer
        pub type W = crate::W<IPRIOR48_SPEC>;
        ///Field `IPRIOR48` reader - RW,IPRIOR48
        pub type IPRIOR48_R = crate::FieldReader<u32>;
        ///Field `IPRIOR48` writer - RW,IPRIOR48
        pub type IPRIOR48_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - RW,IPRIOR48
            #[inline(always)]
            pub fn iprior48(&self) -> IPRIOR48_R {
                IPRIOR48_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,IPRIOR48
            #[inline(always)]
            #[must_use]
            pub fn iprior48(&mut self) -> IPRIOR48_W<IPRIOR48_SPEC> {
                IPRIOR48_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior48::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior48::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR48_SPEC;
        impl crate::RegisterSpec for IPRIOR48_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior48::R`](R) reader structure
        impl crate::Readable for IPRIOR48_SPEC {}
        ///`write(|w| ..)` method takes [`iprior48::W`](W) writer structure
        impl crate::Writable for IPRIOR48_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR48 to value 0
        impl crate::Resettable for IPRIOR48_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR49 (rw) register accessor: Interrupt Priority configuration Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior49::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior49::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior49`]
    ///module
    pub type IPRIOR49 = crate::Reg<iprior49::IPRIOR49_SPEC>;
    ///Interrupt Priority configuration Register
    pub mod iprior49 {
        ///Register `IPRIOR49` reader
        pub type R = crate::R<IPRIOR49_SPEC>;
        ///Register `IPRIOR49` writer
        pub type W = crate::W<IPRIOR49_SPEC>;
        ///Field `IPRIOR49` reader - RW,IPRIOR49
        pub type IPRIOR49_R = crate::FieldReader<u32>;
        ///Field `IPRIOR49` writer - RW,IPRIOR49
        pub type IPRIOR49_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - RW,IPRIOR49
            #[inline(always)]
            pub fn iprior49(&self) -> IPRIOR49_R {
                IPRIOR49_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,IPRIOR49
            #[inline(always)]
            #[must_use]
            pub fn iprior49(&mut self) -> IPRIOR49_W<IPRIOR49_SPEC> {
                IPRIOR49_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior49::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior49::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR49_SPEC;
        impl crate::RegisterSpec for IPRIOR49_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior49::R`](R) reader structure
        impl crate::Readable for IPRIOR49_SPEC {}
        ///`write(|w| ..)` method takes [`iprior49::W`](W) writer structure
        impl crate::Writable for IPRIOR49_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR49 to value 0
        impl crate::Resettable for IPRIOR49_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR50 (rw) register accessor: Interrupt Priority configuration Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior50::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior50::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior50`]
    ///module
    pub type IPRIOR50 = crate::Reg<iprior50::IPRIOR50_SPEC>;
    ///Interrupt Priority configuration Register
    pub mod iprior50 {
        ///Register `IPRIOR50` reader
        pub type R = crate::R<IPRIOR50_SPEC>;
        ///Register `IPRIOR50` writer
        pub type W = crate::W<IPRIOR50_SPEC>;
        ///Field `IPRIOR50` reader - RW,IPRIOR50
        pub type IPRIOR50_R = crate::FieldReader<u32>;
        ///Field `IPRIOR50` writer - RW,IPRIOR50
        pub type IPRIOR50_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - RW,IPRIOR50
            #[inline(always)]
            pub fn iprior50(&self) -> IPRIOR50_R {
                IPRIOR50_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,IPRIOR50
            #[inline(always)]
            #[must_use]
            pub fn iprior50(&mut self) -> IPRIOR50_W<IPRIOR50_SPEC> {
                IPRIOR50_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior50::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior50::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR50_SPEC;
        impl crate::RegisterSpec for IPRIOR50_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior50::R`](R) reader structure
        impl crate::Readable for IPRIOR50_SPEC {}
        ///`write(|w| ..)` method takes [`iprior50::W`](W) writer structure
        impl crate::Writable for IPRIOR50_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR50 to value 0
        impl crate::Resettable for IPRIOR50_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR51 (rw) register accessor: Interrupt Priority configuration Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior51::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior51::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior51`]
    ///module
    pub type IPRIOR51 = crate::Reg<iprior51::IPRIOR51_SPEC>;
    ///Interrupt Priority configuration Register
    pub mod iprior51 {
        ///Register `IPRIOR51` reader
        pub type R = crate::R<IPRIOR51_SPEC>;
        ///Register `IPRIOR51` writer
        pub type W = crate::W<IPRIOR51_SPEC>;
        ///Field `IPRIOR51` reader - RW,IPRIOR51
        pub type IPRIOR51_R = crate::FieldReader<u32>;
        ///Field `IPRIOR51` writer - RW,IPRIOR51
        pub type IPRIOR51_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - RW,IPRIOR51
            #[inline(always)]
            pub fn iprior51(&self) -> IPRIOR51_R {
                IPRIOR51_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,IPRIOR51
            #[inline(always)]
            #[must_use]
            pub fn iprior51(&mut self) -> IPRIOR51_W<IPRIOR51_SPEC> {
                IPRIOR51_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior51::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior51::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR51_SPEC;
        impl crate::RegisterSpec for IPRIOR51_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior51::R`](R) reader structure
        impl crate::Readable for IPRIOR51_SPEC {}
        ///`write(|w| ..)` method takes [`iprior51::W`](W) writer structure
        impl crate::Writable for IPRIOR51_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR51 to value 0
        impl crate::Resettable for IPRIOR51_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR52 (rw) register accessor: Interrupt Priority configuration Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior52::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior52::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior52`]
    ///module
    pub type IPRIOR52 = crate::Reg<iprior52::IPRIOR52_SPEC>;
    ///Interrupt Priority configuration Register
    pub mod iprior52 {
        ///Register `IPRIOR52` reader
        pub type R = crate::R<IPRIOR52_SPEC>;
        ///Register `IPRIOR52` writer
        pub type W = crate::W<IPRIOR52_SPEC>;
        ///Field `IPRIOR52` reader - RW,IPRIOR52
        pub type IPRIOR52_R = crate::FieldReader<u32>;
        ///Field `IPRIOR52` writer - RW,IPRIOR52
        pub type IPRIOR52_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - RW,IPRIOR52
            #[inline(always)]
            pub fn iprior52(&self) -> IPRIOR52_R {
                IPRIOR52_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,IPRIOR52
            #[inline(always)]
            #[must_use]
            pub fn iprior52(&mut self) -> IPRIOR52_W<IPRIOR52_SPEC> {
                IPRIOR52_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior52::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior52::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR52_SPEC;
        impl crate::RegisterSpec for IPRIOR52_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior52::R`](R) reader structure
        impl crate::Readable for IPRIOR52_SPEC {}
        ///`write(|w| ..)` method takes [`iprior52::W`](W) writer structure
        impl crate::Writable for IPRIOR52_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR52 to value 0
        impl crate::Resettable for IPRIOR52_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR53 (rw) register accessor: Interrupt Priority configuration Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior53::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior53::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior53`]
    ///module
    pub type IPRIOR53 = crate::Reg<iprior53::IPRIOR53_SPEC>;
    ///Interrupt Priority configuration Register
    pub mod iprior53 {
        ///Register `IPRIOR53` reader
        pub type R = crate::R<IPRIOR53_SPEC>;
        ///Register `IPRIOR53` writer
        pub type W = crate::W<IPRIOR53_SPEC>;
        ///Field `IPRIOR53` reader - RW,IPRIOR53
        pub type IPRIOR53_R = crate::FieldReader<u32>;
        ///Field `IPRIOR53` writer - RW,IPRIOR53
        pub type IPRIOR53_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - RW,IPRIOR53
            #[inline(always)]
            pub fn iprior53(&self) -> IPRIOR53_R {
                IPRIOR53_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,IPRIOR53
            #[inline(always)]
            #[must_use]
            pub fn iprior53(&mut self) -> IPRIOR53_W<IPRIOR53_SPEC> {
                IPRIOR53_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior53::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior53::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR53_SPEC;
        impl crate::RegisterSpec for IPRIOR53_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior53::R`](R) reader structure
        impl crate::Readable for IPRIOR53_SPEC {}
        ///`write(|w| ..)` method takes [`iprior53::W`](W) writer structure
        impl crate::Writable for IPRIOR53_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR53 to value 0
        impl crate::Resettable for IPRIOR53_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR54 (rw) register accessor: Interrupt Priority configuration Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior54::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior54::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior54`]
    ///module
    pub type IPRIOR54 = crate::Reg<iprior54::IPRIOR54_SPEC>;
    ///Interrupt Priority configuration Register
    pub mod iprior54 {
        ///Register `IPRIOR54` reader
        pub type R = crate::R<IPRIOR54_SPEC>;
        ///Register `IPRIOR54` writer
        pub type W = crate::W<IPRIOR54_SPEC>;
        ///Field `IPRIOR54` reader - RW,IPRIOR54
        pub type IPRIOR54_R = crate::FieldReader<u32>;
        ///Field `IPRIOR54` writer - RW,IPRIOR54
        pub type IPRIOR54_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - RW,IPRIOR54
            #[inline(always)]
            pub fn iprior54(&self) -> IPRIOR54_R {
                IPRIOR54_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,IPRIOR54
            #[inline(always)]
            #[must_use]
            pub fn iprior54(&mut self) -> IPRIOR54_W<IPRIOR54_SPEC> {
                IPRIOR54_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior54::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior54::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR54_SPEC;
        impl crate::RegisterSpec for IPRIOR54_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior54::R`](R) reader structure
        impl crate::Readable for IPRIOR54_SPEC {}
        ///`write(|w| ..)` method takes [`iprior54::W`](W) writer structure
        impl crate::Writable for IPRIOR54_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR54 to value 0
        impl crate::Resettable for IPRIOR54_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR55 (rw) register accessor: Interrupt Priority configuration Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior55::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior55::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior55`]
    ///module
    pub type IPRIOR55 = crate::Reg<iprior55::IPRIOR55_SPEC>;
    ///Interrupt Priority configuration Register
    pub mod iprior55 {
        ///Register `IPRIOR55` reader
        pub type R = crate::R<IPRIOR55_SPEC>;
        ///Register `IPRIOR55` writer
        pub type W = crate::W<IPRIOR55_SPEC>;
        ///Field `IPRIOR55` reader - RW,IPRIOR55
        pub type IPRIOR55_R = crate::FieldReader<u32>;
        ///Field `IPRIOR55` writer - RW,IPRIOR55
        pub type IPRIOR55_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - RW,IPRIOR55
            #[inline(always)]
            pub fn iprior55(&self) -> IPRIOR55_R {
                IPRIOR55_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,IPRIOR55
            #[inline(always)]
            #[must_use]
            pub fn iprior55(&mut self) -> IPRIOR55_W<IPRIOR55_SPEC> {
                IPRIOR55_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior55::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior55::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR55_SPEC;
        impl crate::RegisterSpec for IPRIOR55_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior55::R`](R) reader structure
        impl crate::Readable for IPRIOR55_SPEC {}
        ///`write(|w| ..)` method takes [`iprior55::W`](W) writer structure
        impl crate::Writable for IPRIOR55_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR55 to value 0
        impl crate::Resettable for IPRIOR55_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR56 (rw) register accessor: Interrupt Priority configuration Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior56::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior56::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior56`]
    ///module
    pub type IPRIOR56 = crate::Reg<iprior56::IPRIOR56_SPEC>;
    ///Interrupt Priority configuration Register
    pub mod iprior56 {
        ///Register `IPRIOR56` reader
        pub type R = crate::R<IPRIOR56_SPEC>;
        ///Register `IPRIOR56` writer
        pub type W = crate::W<IPRIOR56_SPEC>;
        ///Field `IPRIOR56` reader - RW,IPRIOR56
        pub type IPRIOR56_R = crate::FieldReader<u32>;
        ///Field `IPRIOR56` writer - RW,IPRIOR56
        pub type IPRIOR56_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - RW,IPRIOR56
            #[inline(always)]
            pub fn iprior56(&self) -> IPRIOR56_R {
                IPRIOR56_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,IPRIOR56
            #[inline(always)]
            #[must_use]
            pub fn iprior56(&mut self) -> IPRIOR56_W<IPRIOR56_SPEC> {
                IPRIOR56_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior56::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior56::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR56_SPEC;
        impl crate::RegisterSpec for IPRIOR56_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior56::R`](R) reader structure
        impl crate::Readable for IPRIOR56_SPEC {}
        ///`write(|w| ..)` method takes [`iprior56::W`](W) writer structure
        impl crate::Writable for IPRIOR56_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR56 to value 0
        impl crate::Resettable for IPRIOR56_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR57 (rw) register accessor: Interrupt Priority configuration Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior57::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior57::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior57`]
    ///module
    pub type IPRIOR57 = crate::Reg<iprior57::IPRIOR57_SPEC>;
    ///Interrupt Priority configuration Register
    pub mod iprior57 {
        ///Register `IPRIOR57` reader
        pub type R = crate::R<IPRIOR57_SPEC>;
        ///Register `IPRIOR57` writer
        pub type W = crate::W<IPRIOR57_SPEC>;
        ///Field `IPRIOR57` reader - RW,IPRIOR57
        pub type IPRIOR57_R = crate::FieldReader<u32>;
        ///Field `IPRIOR57` writer - RW,IPRIOR57
        pub type IPRIOR57_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - RW,IPRIOR57
            #[inline(always)]
            pub fn iprior57(&self) -> IPRIOR57_R {
                IPRIOR57_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,IPRIOR57
            #[inline(always)]
            #[must_use]
            pub fn iprior57(&mut self) -> IPRIOR57_W<IPRIOR57_SPEC> {
                IPRIOR57_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior57::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior57::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR57_SPEC;
        impl crate::RegisterSpec for IPRIOR57_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior57::R`](R) reader structure
        impl crate::Readable for IPRIOR57_SPEC {}
        ///`write(|w| ..)` method takes [`iprior57::W`](W) writer structure
        impl crate::Writable for IPRIOR57_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR57 to value 0
        impl crate::Resettable for IPRIOR57_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR58 (rw) register accessor: Interrupt Priority configuration Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior58::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior58::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior58`]
    ///module
    pub type IPRIOR58 = crate::Reg<iprior58::IPRIOR58_SPEC>;
    ///Interrupt Priority configuration Register
    pub mod iprior58 {
        ///Register `IPRIOR58` reader
        pub type R = crate::R<IPRIOR58_SPEC>;
        ///Register `IPRIOR58` writer
        pub type W = crate::W<IPRIOR58_SPEC>;
        ///Field `IPRIOR58` reader - RW,IPRIOR58
        pub type IPRIOR58_R = crate::FieldReader<u32>;
        ///Field `IPRIOR58` writer - RW,IPRIOR58
        pub type IPRIOR58_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - RW,IPRIOR58
            #[inline(always)]
            pub fn iprior58(&self) -> IPRIOR58_R {
                IPRIOR58_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,IPRIOR58
            #[inline(always)]
            #[must_use]
            pub fn iprior58(&mut self) -> IPRIOR58_W<IPRIOR58_SPEC> {
                IPRIOR58_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior58::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior58::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR58_SPEC;
        impl crate::RegisterSpec for IPRIOR58_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior58::R`](R) reader structure
        impl crate::Readable for IPRIOR58_SPEC {}
        ///`write(|w| ..)` method takes [`iprior58::W`](W) writer structure
        impl crate::Writable for IPRIOR58_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR58 to value 0
        impl crate::Resettable for IPRIOR58_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR59 (rw) register accessor: Interrupt Priority configuration Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior59::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior59::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior59`]
    ///module
    pub type IPRIOR59 = crate::Reg<iprior59::IPRIOR59_SPEC>;
    ///Interrupt Priority configuration Register
    pub mod iprior59 {
        ///Register `IPRIOR59` reader
        pub type R = crate::R<IPRIOR59_SPEC>;
        ///Register `IPRIOR59` writer
        pub type W = crate::W<IPRIOR59_SPEC>;
        ///Field `IPRIOR59` reader - RW,IPRIOR59
        pub type IPRIOR59_R = crate::FieldReader<u32>;
        ///Field `IPRIOR59` writer - RW,IPRIOR59
        pub type IPRIOR59_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - RW,IPRIOR59
            #[inline(always)]
            pub fn iprior59(&self) -> IPRIOR59_R {
                IPRIOR59_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,IPRIOR59
            #[inline(always)]
            #[must_use]
            pub fn iprior59(&mut self) -> IPRIOR59_W<IPRIOR59_SPEC> {
                IPRIOR59_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior59::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior59::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR59_SPEC;
        impl crate::RegisterSpec for IPRIOR59_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior59::R`](R) reader structure
        impl crate::Readable for IPRIOR59_SPEC {}
        ///`write(|w| ..)` method takes [`iprior59::W`](W) writer structure
        impl crate::Writable for IPRIOR59_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR59 to value 0
        impl crate::Resettable for IPRIOR59_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR60 (rw) register accessor: Interrupt Priority configuration Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior60::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior60::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior60`]
    ///module
    pub type IPRIOR60 = crate::Reg<iprior60::IPRIOR60_SPEC>;
    ///Interrupt Priority configuration Register
    pub mod iprior60 {
        ///Register `IPRIOR60` reader
        pub type R = crate::R<IPRIOR60_SPEC>;
        ///Register `IPRIOR60` writer
        pub type W = crate::W<IPRIOR60_SPEC>;
        ///Field `IPRIOR60` reader - RW,IPRIOR60
        pub type IPRIOR60_R = crate::FieldReader<u32>;
        ///Field `IPRIOR60` writer - RW,IPRIOR60
        pub type IPRIOR60_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - RW,IPRIOR60
            #[inline(always)]
            pub fn iprior60(&self) -> IPRIOR60_R {
                IPRIOR60_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,IPRIOR60
            #[inline(always)]
            #[must_use]
            pub fn iprior60(&mut self) -> IPRIOR60_W<IPRIOR60_SPEC> {
                IPRIOR60_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior60::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior60::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR60_SPEC;
        impl crate::RegisterSpec for IPRIOR60_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior60::R`](R) reader structure
        impl crate::Readable for IPRIOR60_SPEC {}
        ///`write(|w| ..)` method takes [`iprior60::W`](W) writer structure
        impl crate::Writable for IPRIOR60_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR60 to value 0
        impl crate::Resettable for IPRIOR60_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR61 (rw) register accessor: Interrupt Priority configuration Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior61::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior61::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior61`]
    ///module
    pub type IPRIOR61 = crate::Reg<iprior61::IPRIOR61_SPEC>;
    ///Interrupt Priority configuration Register
    pub mod iprior61 {
        ///Register `IPRIOR61` reader
        pub type R = crate::R<IPRIOR61_SPEC>;
        ///Register `IPRIOR61` writer
        pub type W = crate::W<IPRIOR61_SPEC>;
        ///Field `IPRIOR61` reader - RW,IPRIOR61
        pub type IPRIOR61_R = crate::FieldReader<u32>;
        ///Field `IPRIOR61` writer - RW,IPRIOR61
        pub type IPRIOR61_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - RW,IPRIOR61
            #[inline(always)]
            pub fn iprior61(&self) -> IPRIOR61_R {
                IPRIOR61_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,IPRIOR61
            #[inline(always)]
            #[must_use]
            pub fn iprior61(&mut self) -> IPRIOR61_W<IPRIOR61_SPEC> {
                IPRIOR61_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior61::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior61::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR61_SPEC;
        impl crate::RegisterSpec for IPRIOR61_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior61::R`](R) reader structure
        impl crate::Readable for IPRIOR61_SPEC {}
        ///`write(|w| ..)` method takes [`iprior61::W`](W) writer structure
        impl crate::Writable for IPRIOR61_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR61 to value 0
        impl crate::Resettable for IPRIOR61_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR62 (rw) register accessor: Interrupt Priority configuration Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior62::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior62::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior62`]
    ///module
    pub type IPRIOR62 = crate::Reg<iprior62::IPRIOR62_SPEC>;
    ///Interrupt Priority configuration Register
    pub mod iprior62 {
        ///Register `IPRIOR62` reader
        pub type R = crate::R<IPRIOR62_SPEC>;
        ///Register `IPRIOR62` writer
        pub type W = crate::W<IPRIOR62_SPEC>;
        ///Field `IPRIOR62` reader - RW,IPRIOR62
        pub type IPRIOR62_R = crate::FieldReader<u32>;
        ///Field `IPRIOR62` writer - RW,IPRIOR62
        pub type IPRIOR62_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - RW,IPRIOR62
            #[inline(always)]
            pub fn iprior62(&self) -> IPRIOR62_R {
                IPRIOR62_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,IPRIOR62
            #[inline(always)]
            #[must_use]
            pub fn iprior62(&mut self) -> IPRIOR62_W<IPRIOR62_SPEC> {
                IPRIOR62_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior62::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior62::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR62_SPEC;
        impl crate::RegisterSpec for IPRIOR62_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior62::R`](R) reader structure
        impl crate::Readable for IPRIOR62_SPEC {}
        ///`write(|w| ..)` method takes [`iprior62::W`](W) writer structure
        impl crate::Writable for IPRIOR62_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR62 to value 0
        impl crate::Resettable for IPRIOR62_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR63 (rw) register accessor: Interrupt Priority configuration Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior63::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior63::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior63`]
    ///module
    pub type IPRIOR63 = crate::Reg<iprior63::IPRIOR63_SPEC>;
    ///Interrupt Priority configuration Register
    pub mod iprior63 {
        ///Register `IPRIOR63` reader
        pub type R = crate::R<IPRIOR63_SPEC>;
        ///Register `IPRIOR63` writer
        pub type W = crate::W<IPRIOR63_SPEC>;
        ///Field `IPRIOR63` reader - RW,IPRIOR63
        pub type IPRIOR63_R = crate::FieldReader<u32>;
        ///Field `IPRIOR63` writer - RW,IPRIOR63
        pub type IPRIOR63_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - RW,IPRIOR63
            #[inline(always)]
            pub fn iprior63(&self) -> IPRIOR63_R {
                IPRIOR63_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,IPRIOR63
            #[inline(always)]
            #[must_use]
            pub fn iprior63(&mut self) -> IPRIOR63_W<IPRIOR63_SPEC> {
                IPRIOR63_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior63::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior63::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR63_SPEC;
        impl crate::RegisterSpec for IPRIOR63_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior63::R`](R) reader structure
        impl crate::Readable for IPRIOR63_SPEC {}
        ///`write(|w| ..)` method takes [`iprior63::W`](W) writer structure
        impl crate::Writable for IPRIOR63_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR63 to value 0
        impl crate::Resettable for IPRIOR63_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///SCTLR (rw) register accessor: System Control Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`sctlr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`sctlr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@sctlr`]
    ///module
    pub type SCTLR = crate::Reg<sctlr::SCTLR_SPEC>;
    ///System Control Register
    pub mod sctlr {
        ///Register `SCTLR` reader
        pub type R = crate::R<SCTLR_SPEC>;
        ///Register `SCTLR` writer
        pub type W = crate::W<SCTLR_SPEC>;
        ///Field `SLEEPONEXIT` reader - RW,SLEEPONEXIT
        pub type SLEEPONEXIT_R = crate::BitReader;
        ///Field `SLEEPONEXIT` writer - RW,SLEEPONEXIT
        pub type SLEEPONEXIT_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `SLEEPDEEP` reader - RW,SLEEPDEEP
        pub type SLEEPDEEP_R = crate::BitReader;
        ///Field `SLEEPDEEP` writer - RW,SLEEPDEEP
        pub type SLEEPDEEP_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `WFITOWFE` reader - RW,WFITOWFE
        pub type WFITOWFE_R = crate::BitReader;
        ///Field `WFITOWFE` writer - RW,WFITOWFE
        pub type WFITOWFE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `SEVONPEND` reader - RW,SEVONPEND
        pub type SEVONPEND_R = crate::BitReader;
        ///Field `SEVONPEND` writer - RW,SEVONPEND
        pub type SEVONPEND_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `SETEVENT` reader - WO,SETEVENT
        pub type SETEVENT_R = crate::BitReader;
        ///Field `SETEVENT` writer - WO,SETEVENT
        pub type SETEVENT_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 1 - RW,SLEEPONEXIT
            #[inline(always)]
            pub fn sleeponexit(&self) -> SLEEPONEXIT_R {
                SLEEPONEXIT_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RW,SLEEPDEEP
            #[inline(always)]
            pub fn sleepdeep(&self) -> SLEEPDEEP_R {
                SLEEPDEEP_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RW,WFITOWFE
            #[inline(always)]
            pub fn wfitowfe(&self) -> WFITOWFE_R {
                WFITOWFE_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RW,SEVONPEND
            #[inline(always)]
            pub fn sevonpend(&self) -> SEVONPEND_R {
                SEVONPEND_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - WO,SETEVENT
            #[inline(always)]
            pub fn setevent(&self) -> SETEVENT_R {
                SETEVENT_R::new(((self.bits >> 5) & 1) != 0)
            }
        }
        impl W {
            ///Bit 1 - RW,SLEEPONEXIT
            #[inline(always)]
            #[must_use]
            pub fn sleeponexit(&mut self) -> SLEEPONEXIT_W<SCTLR_SPEC> {
                SLEEPONEXIT_W::new(self, 1)
            }
            ///Bit 2 - RW,SLEEPDEEP
            #[inline(always)]
            #[must_use]
            pub fn sleepdeep(&mut self) -> SLEEPDEEP_W<SCTLR_SPEC> {
                SLEEPDEEP_W::new(self, 2)
            }
            ///Bit 3 - RW,WFITOWFE
            #[inline(always)]
            #[must_use]
            pub fn wfitowfe(&mut self) -> WFITOWFE_W<SCTLR_SPEC> {
                WFITOWFE_W::new(self, 3)
            }
            ///Bit 4 - RW,SEVONPEND
            #[inline(always)]
            #[must_use]
            pub fn sevonpend(&mut self) -> SEVONPEND_W<SCTLR_SPEC> {
                SEVONPEND_W::new(self, 4)
            }
            ///Bit 5 - WO,SETEVENT
            #[inline(always)]
            #[must_use]
            pub fn setevent(&mut self) -> SETEVENT_W<SCTLR_SPEC> {
                SETEVENT_W::new(self, 5)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///System Control Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`sctlr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`sctlr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct SCTLR_SPEC;
        impl crate::RegisterSpec for SCTLR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`sctlr::R`](R) reader structure
        impl crate::Readable for SCTLR_SPEC {}
        ///`write(|w| ..)` method takes [`sctlr::W`](W) writer structure
        impl crate::Writable for SCTLR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets SCTLR to value 0
        impl crate::Resettable for SCTLR_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///VTCTLR (rw) register accessor: System Control Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`vtctlr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`vtctlr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@vtctlr`]
    ///module
    pub type VTCTLR = crate::Reg<vtctlr::VTCTLR_SPEC>;
    ///System Control Register
    pub mod vtctlr {
        ///Register `VTCTLR` reader
        pub type R = crate::R<VTCTLR_SPEC>;
        ///Register `VTCTLR` writer
        pub type W = crate::W<VTCTLR_SPEC>;
        ///Field `VTADDR` reader - VTADDR
        pub type VTADDR_R = crate::BitReader;
        ///Field `VTADDR` writer - VTADDR
        pub type VTADDR_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - VTADDR
            #[inline(always)]
            pub fn vtaddr(&self) -> VTADDR_R {
                VTADDR_R::new((self.bits & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - VTADDR
            #[inline(always)]
            #[must_use]
            pub fn vtaddr(&mut self) -> VTADDR_W<VTCTLR_SPEC> {
                VTADDR_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///System Control Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`vtctlr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`vtctlr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct VTCTLR_SPEC;
        impl crate::RegisterSpec for VTCTLR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`vtctlr::R`](R) reader structure
        impl crate::Readable for VTCTLR_SPEC {}
        ///`write(|w| ..)` method takes [`vtctlr::W`](W) writer structure
        impl crate::Writable for VTCTLR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets VTCTLR to value 0
        impl crate::Resettable for VTCTLR_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
}
///Systick register
pub struct SYSTICK {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for SYSTICK {}
impl SYSTICK {
    ///Pointer to the register block
    pub const PTR: *const systick::RegisterBlock = 0xe000_f000 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const systick::RegisterBlock {
        Self::PTR
    }
    /// Steal an instance of this peripheral
    ///
    /// # Safety
    ///
    /// Ensure that the new instance of the peripheral cannot be used in a way
    /// that may race with any existing instances, for example by only
    /// accessing read-only or write-only registers, or by consuming the
    /// original peripheral and using critical sections to coordinate
    /// access between multiple new instances.
    ///
    /// Additionally, other software such as HALs may rely on only one
    /// peripheral instance existing to ensure memory safety; ensure
    /// no stolen instances are passed to such software.
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for SYSTICK {
    type Target = systick::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for SYSTICK {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("SYSTICK").finish()
    }
}
///Systick register
pub mod systick {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        stk_ctlr: STK_CTLR,
        stk_cntl: STK_CNTL,
        stk_cnth: STK_CNTH,
        stk_cmplr: STK_CMPLR,
        stk_cmphr: STK_CMPHR,
        stk_cntfg: STK_CNTFG,
    }
    impl RegisterBlock {
        ///0x00 - Systick counter control register
        #[inline(always)]
        pub const fn stk_ctlr(&self) -> &STK_CTLR {
            &self.stk_ctlr
        }
        ///0x04 - Systick counter low register
        #[inline(always)]
        pub const fn stk_cntl(&self) -> &STK_CNTL {
            &self.stk_cntl
        }
        ///0x08 - Systick counter high register
        #[inline(always)]
        pub const fn stk_cnth(&self) -> &STK_CNTH {
            &self.stk_cnth
        }
        ///0x0c - Systick compare low register
        #[inline(always)]
        pub const fn stk_cmplr(&self) -> &STK_CMPLR {
            &self.stk_cmplr
        }
        ///0x10 - Systick compare high register
        #[inline(always)]
        pub const fn stk_cmphr(&self) -> &STK_CMPHR {
            &self.stk_cmphr
        }
        ///0x14 - Systick counter flag
        #[inline(always)]
        pub const fn stk_cntfg(&self) -> &STK_CNTFG {
            &self.stk_cntfg
        }
    }
    ///STK_CTLR (rw) register accessor: Systick counter control register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`stk_ctlr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`stk_ctlr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@stk_ctlr`]
    ///module
    pub type STK_CTLR = crate::Reg<stk_ctlr::STK_CTLR_SPEC>;
    ///Systick counter control register
    pub mod stk_ctlr {
        ///Register `STK_CTLR` reader
        pub type R = crate::R<STK_CTLR_SPEC>;
        ///Register `STK_CTLR` writer
        pub type W = crate::W<STK_CTLR_SPEC>;
        ///Field `STE` reader - Systick counter enable
        pub type STE_R = crate::BitReader;
        ///Field `STE` writer - Systick counter enable
        pub type STE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `STIE` reader - Systick counter interrupt enable
        pub type STIE_R = crate::BitReader;
        ///Field `STIE` writer - Systick counter interrupt enable
        pub type STIE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `STCLK` reader - System counter clock Source selection
        pub type STCLK_R = crate::BitReader;
        ///Field `STCLK` writer - System counter clock Source selection
        pub type STCLK_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `STRELOAD` reader - System counter reload control
        pub type STRELOAD_R = crate::BitReader;
        ///Field `STRELOAD` writer - System counter reload control
        pub type STRELOAD_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - Systick counter enable
            #[inline(always)]
            pub fn ste(&self) -> STE_R {
                STE_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Systick counter interrupt enable
            #[inline(always)]
            pub fn stie(&self) -> STIE_R {
                STIE_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - System counter clock Source selection
            #[inline(always)]
            pub fn stclk(&self) -> STCLK_R {
                STCLK_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 8 - System counter reload control
            #[inline(always)]
            pub fn streload(&self) -> STRELOAD_R {
                STRELOAD_R::new(((self.bits >> 8) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - Systick counter enable
            #[inline(always)]
            #[must_use]
            pub fn ste(&mut self) -> STE_W<STK_CTLR_SPEC> {
                STE_W::new(self, 0)
            }
            ///Bit 1 - Systick counter interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn stie(&mut self) -> STIE_W<STK_CTLR_SPEC> {
                STIE_W::new(self, 1)
            }
            ///Bit 2 - System counter clock Source selection
            #[inline(always)]
            #[must_use]
            pub fn stclk(&mut self) -> STCLK_W<STK_CTLR_SPEC> {
                STCLK_W::new(self, 2)
            }
            ///Bit 8 - System counter reload control
            #[inline(always)]
            #[must_use]
            pub fn streload(&mut self) -> STRELOAD_W<STK_CTLR_SPEC> {
                STRELOAD_W::new(self, 8)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Systick counter control register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`stk_ctlr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`stk_ctlr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct STK_CTLR_SPEC;
        impl crate::RegisterSpec for STK_CTLR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`stk_ctlr::R`](R) reader structure
        impl crate::Readable for STK_CTLR_SPEC {}
        ///`write(|w| ..)` method takes [`stk_ctlr::W`](W) writer structure
        impl crate::Writable for STK_CTLR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets STK_CTLR to value 0
        impl crate::Resettable for STK_CTLR_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///STK_CNTL (rw) register accessor: Systick counter low register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`stk_cntl::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`stk_cntl::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@stk_cntl`]
    ///module
    pub type STK_CNTL = crate::Reg<stk_cntl::STK_CNTL_SPEC>;
    ///Systick counter low register
    pub mod stk_cntl {
        ///Register `STK_CNTL` reader
        pub type R = crate::R<STK_CNTL_SPEC>;
        ///Register `STK_CNTL` writer
        pub type W = crate::W<STK_CNTL_SPEC>;
        ///Field `CNTL` reader - RW,CNTL
        pub type CNTL_R = crate::FieldReader<u32>;
        ///Field `CNTL` writer - RW,CNTL
        pub type CNTL_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - RW,CNTL
            #[inline(always)]
            pub fn cntl(&self) -> CNTL_R {
                CNTL_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,CNTL
            #[inline(always)]
            #[must_use]
            pub fn cntl(&mut self) -> CNTL_W<STK_CNTL_SPEC> {
                CNTL_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Systick counter low register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`stk_cntl::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`stk_cntl::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct STK_CNTL_SPEC;
        impl crate::RegisterSpec for STK_CNTL_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`stk_cntl::R`](R) reader structure
        impl crate::Readable for STK_CNTL_SPEC {}
        ///`write(|w| ..)` method takes [`stk_cntl::W`](W) writer structure
        impl crate::Writable for STK_CNTL_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets STK_CNTL to value 0
        impl crate::Resettable for STK_CNTL_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///STK_CNTH (rw) register accessor: Systick counter high register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`stk_cnth::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`stk_cnth::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@stk_cnth`]
    ///module
    pub type STK_CNTH = crate::Reg<stk_cnth::STK_CNTH_SPEC>;
    ///Systick counter high register
    pub mod stk_cnth {
        ///Register `STK_CNTH` reader
        pub type R = crate::R<STK_CNTH_SPEC>;
        ///Register `STK_CNTH` writer
        pub type W = crate::W<STK_CNTH_SPEC>;
        ///Field `CNTH` reader - RW,CNTH
        pub type CNTH_R = crate::FieldReader<u32>;
        ///Field `CNTH` writer - RW,CNTH
        pub type CNTH_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - RW,CNTH
            #[inline(always)]
            pub fn cnth(&self) -> CNTH_R {
                CNTH_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,CNTH
            #[inline(always)]
            #[must_use]
            pub fn cnth(&mut self) -> CNTH_W<STK_CNTH_SPEC> {
                CNTH_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Systick counter high register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`stk_cnth::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`stk_cnth::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct STK_CNTH_SPEC;
        impl crate::RegisterSpec for STK_CNTH_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`stk_cnth::R`](R) reader structure
        impl crate::Readable for STK_CNTH_SPEC {}
        ///`write(|w| ..)` method takes [`stk_cnth::W`](W) writer structure
        impl crate::Writable for STK_CNTH_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets STK_CNTH to value 0
        impl crate::Resettable for STK_CNTH_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///STK_CMPLR (rw) register accessor: Systick compare low register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`stk_cmplr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`stk_cmplr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@stk_cmplr`]
    ///module
    pub type STK_CMPLR = crate::Reg<stk_cmplr::STK_CMPLR_SPEC>;
    ///Systick compare low register
    pub mod stk_cmplr {
        ///Register `STK_CMPLR` reader
        pub type R = crate::R<STK_CMPLR_SPEC>;
        ///Register `STK_CMPLR` writer
        pub type W = crate::W<STK_CMPLR_SPEC>;
        ///Field `CMPL` reader - RW,CMPL
        pub type CMPL_R = crate::FieldReader<u32>;
        ///Field `CMPL` writer - RW,CMPL
        pub type CMPL_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - RW,CMPL
            #[inline(always)]
            pub fn cmpl(&self) -> CMPL_R {
                CMPL_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,CMPL
            #[inline(always)]
            #[must_use]
            pub fn cmpl(&mut self) -> CMPL_W<STK_CMPLR_SPEC> {
                CMPL_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Systick compare low register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`stk_cmplr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`stk_cmplr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct STK_CMPLR_SPEC;
        impl crate::RegisterSpec for STK_CMPLR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`stk_cmplr::R`](R) reader structure
        impl crate::Readable for STK_CMPLR_SPEC {}
        ///`write(|w| ..)` method takes [`stk_cmplr::W`](W) writer structure
        impl crate::Writable for STK_CMPLR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets STK_CMPLR to value 0
        impl crate::Resettable for STK_CMPLR_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///STK_CMPHR (rw) register accessor: Systick compare high register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`stk_cmphr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`stk_cmphr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@stk_cmphr`]
    ///module
    pub type STK_CMPHR = crate::Reg<stk_cmphr::STK_CMPHR_SPEC>;
    ///Systick compare high register
    pub mod stk_cmphr {
        ///Register `STK_CMPHR` reader
        pub type R = crate::R<STK_CMPHR_SPEC>;
        ///Register `STK_CMPHR` writer
        pub type W = crate::W<STK_CMPHR_SPEC>;
        ///Field `CMPH` reader - RW,CMPH
        pub type CMPH_R = crate::FieldReader<u32>;
        ///Field `CMPH` writer - RW,CMPH
        pub type CMPH_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - RW,CMPH
            #[inline(always)]
            pub fn cmph(&self) -> CMPH_R {
                CMPH_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,CMPH
            #[inline(always)]
            #[must_use]
            pub fn cmph(&mut self) -> CMPH_W<STK_CMPHR_SPEC> {
                CMPH_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Systick compare high register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`stk_cmphr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`stk_cmphr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct STK_CMPHR_SPEC;
        impl crate::RegisterSpec for STK_CMPHR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`stk_cmphr::R`](R) reader structure
        impl crate::Readable for STK_CMPHR_SPEC {}
        ///`write(|w| ..)` method takes [`stk_cmphr::W`](W) writer structure
        impl crate::Writable for STK_CMPHR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets STK_CMPHR to value 0
        impl crate::Resettable for STK_CMPHR_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///STK_CNTFG (rw) register accessor: Systick counter flag
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`stk_cntfg::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`stk_cntfg::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@stk_cntfg`]
    ///module
    pub type STK_CNTFG = crate::Reg<stk_cntfg::STK_CNTFG_SPEC>;
    ///Systick counter flag
    pub mod stk_cntfg {
        ///Register `STK_CNTFG` reader
        pub type R = crate::R<STK_CNTFG_SPEC>;
        ///Register `STK_CNTFG` writer
        pub type W = crate::W<STK_CNTFG_SPEC>;
        ///Field `SWIE` reader - RW0,System soft interrupt enable
        pub type SWIE_R = crate::BitReader;
        ///Field `SWIE` writer - RW0,System soft interrupt enable
        pub type SWIE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CNTIF` reader - RW,Systick counter clear zero flag
        pub type CNTIF_R = crate::BitReader;
        ///Field `CNTIF` writer - RW,Systick counter clear zero flag
        pub type CNTIF_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - RW0,System soft interrupt enable
            #[inline(always)]
            pub fn swie(&self) -> SWIE_R {
                SWIE_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RW,Systick counter clear zero flag
            #[inline(always)]
            pub fn cntif(&self) -> CNTIF_R {
                CNTIF_R::new(((self.bits >> 1) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RW0,System soft interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn swie(&mut self) -> SWIE_W<STK_CNTFG_SPEC> {
                SWIE_W::new(self, 0)
            }
            ///Bit 1 - RW,Systick counter clear zero flag
            #[inline(always)]
            #[must_use]
            pub fn cntif(&mut self) -> CNTIF_W<STK_CNTFG_SPEC> {
                CNTIF_W::new(self, 1)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Systick counter flag
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`stk_cntfg::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`stk_cntfg::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct STK_CNTFG_SPEC;
        impl crate::RegisterSpec for STK_CNTFG_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`stk_cntfg::R`](R) reader structure
        impl crate::Readable for STK_CNTFG_SPEC {}
        ///`write(|w| ..)` method takes [`stk_cntfg::W`](W) writer structure
        impl crate::Writable for STK_CNTFG_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets STK_CNTFG to value 0
        impl crate::Resettable for STK_CNTFG_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
}
#[no_mangle]
static mut DEVICE_PERIPHERALS: bool = false;
/// All the peripherals.
#[allow(non_snake_case)]
pub struct Peripherals {
    ///SYS
    pub SYS: SYS,
    ///TMR0
    pub TMR0: TMR0,
    ///TMR1
    pub TMR1: TMR1,
    ///TMR2
    pub TMR2: TMR2,
    ///TMR3
    pub TMR3: TMR3,
    ///UART0
    pub UART0: UART0,
    ///UART1
    pub UART1: UART1,
    ///UART2
    pub UART2: UART2,
    ///UART3
    pub UART3: UART3,
    ///SPI0
    pub SPI0: SPI0,
    ///PWMx
    pub PWMX: PWMX,
    ///USB
    pub USB: USB,
    ///PFIC
    pub PFIC: PFIC,
    ///Systick
    pub SYSTICK: SYSTICK,
}
impl Peripherals {
    /// Returns all the peripherals *once*.
    #[cfg(feature = "critical-section")]
    #[inline]
    pub fn take() -> Option<Self> {
        critical_section::with(|_| {
            if unsafe { DEVICE_PERIPHERALS } {
                return None;
            }
            Some(unsafe { Peripherals::steal() })
        })
    }
    /// Unchecked version of `Peripherals::take`.
    ///
    /// # Safety
    ///
    /// Each of the returned peripherals must be used at most once.
    #[inline]
    pub unsafe fn steal() -> Self {
        DEVICE_PERIPHERALS = true;
        Peripherals {
            SYS: SYS {
                _marker: PhantomData,
            },
            TMR0: TMR0 {
                _marker: PhantomData,
            },
            TMR1: TMR1 {
                _marker: PhantomData,
            },
            TMR2: TMR2 {
                _marker: PhantomData,
            },
            TMR3: TMR3 {
                _marker: PhantomData,
            },
            UART0: UART0 {
                _marker: PhantomData,
            },
            UART1: UART1 {
                _marker: PhantomData,
            },
            UART2: UART2 {
                _marker: PhantomData,
            },
            UART3: UART3 {
                _marker: PhantomData,
            },
            SPI0: SPI0 {
                _marker: PhantomData,
            },
            PWMX: PWMX {
                _marker: PhantomData,
            },
            USB: USB {
                _marker: PhantomData,
            },
            PFIC: PFIC {
                _marker: PhantomData,
            },
            SYSTICK: SYSTICK {
                _marker: PhantomData,
            },
        }
    }
}
