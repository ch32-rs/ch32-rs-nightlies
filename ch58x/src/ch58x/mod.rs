//!Peripheral access API for CH583SFR microcontrollers (generated using svd2rust v0.31.5 ( ))
//!
//!You can find an overview of the generated API [here].
//!
//!API features to be included in the [next]
//!svd2rust release can be generated by cloning the svd2rust [repository], checking out the above commit, and running `cargo doc --open`.
//!
//![here]: https://docs.rs/svd2rust/0.31.5/svd2rust/#peripheral-api
//![next]: https://github.com/rust-embedded/svd2rust/blob/master/CHANGELOG.md#unreleased
//![repository]: https://github.com/rust-embedded/svd2rust
use core::marker::PhantomData;
use core::ops::Deref;
#[cfg(feature = "rt")]
extern "C" {
    fn TMR0();
    fn GPIOA();
    fn GPIOB();
    fn SPI0();
    fn BLEB();
    fn BLEL();
    fn USB();
    fn USB2();
    fn TMR1();
    fn TMR2();
    fn UART0();
    fn UART1();
    fn RTC();
    fn ADC();
    fn I2C();
    fn PWMX();
    fn TMR3();
    fn UART2();
    fn UART3();
    fn WDOG_BAT();
}
#[doc(hidden)]
#[repr(C)]
pub union Vector {
    pub _handler: unsafe extern "C" fn(),
    pub _reserved: usize,
}
#[cfg(feature = "rt")]
#[doc(hidden)]
#[no_mangle]
pub static __EXTERNAL_INTERRUPTS: [Vector; 36] = [
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _handler: TMR0 },
    Vector { _handler: GPIOA },
    Vector { _handler: GPIOB },
    Vector { _handler: SPI0 },
    Vector { _handler: BLEB },
    Vector { _handler: BLEL },
    Vector { _handler: USB },
    Vector { _handler: USB2 },
    Vector { _handler: TMR1 },
    Vector { _handler: TMR2 },
    Vector { _handler: UART0 },
    Vector { _handler: UART1 },
    Vector { _handler: RTC },
    Vector { _handler: ADC },
    Vector { _handler: I2C },
    Vector { _handler: PWMX },
    Vector { _handler: TMR3 },
    Vector { _handler: UART2 },
    Vector { _handler: UART3 },
    Vector { _handler: WDOG_BAT },
];
#[doc(hidden)]
pub mod interrupt {
    ///Enumeration of all the interrupts.
    #[derive(Copy, Clone, Debug, PartialEq, Eq)]
    #[repr(u16)]
    pub enum Interrupt {
        ///16 - TMR0_IRQHandler
        TMR0 = 16,
        ///17 - GPIOA
        GPIOA = 17,
        ///18 - GPIOB
        GPIOB = 18,
        ///19 - SPI0_IRQHandler
        SPI0 = 19,
        ///20 - BB_IRQHandler
        BLEB = 20,
        ///21 - LLE_IRQHandler
        BLEL = 21,
        ///22 - USB_IRQHandler
        USB = 22,
        ///23 - USB2_IRQHandler
        USB2 = 23,
        ///24 - TMR1_IRQHandler
        TMR1 = 24,
        ///25 - TMR2_IRQHandler
        TMR2 = 25,
        ///26 - UART0_IRQHandler
        UART0 = 26,
        ///27 - UART1_IRQHandler
        UART1 = 27,
        ///28 - RTC
        RTC = 28,
        ///29 - ADC
        ADC = 29,
        ///30 - I2C_IRQHandler
        I2C = 30,
        ///31 - PPWMX_SPI1_IRQHandler
        PWMX = 31,
        ///32 - TMR3_IRQHandler
        TMR3 = 32,
        ///33 - UART1_IRQHandler
        UART2 = 33,
        ///34 - UART3_IRQHandler
        UART3 = 34,
        ///35 - WDT_IRQHandler
        WDOG_BAT = 35,
    }
    /// TryFromInterruptError
    #[derive(Debug, Copy, Clone)]
    pub struct TryFromInterruptError(());
    impl Interrupt {
        /// Attempt to convert a given value into an `Interrupt`
        #[inline]
        pub fn try_from(value: u8) -> Result<Self, TryFromInterruptError> {
            match value {
                16 => Ok(Interrupt::TMR0),
                17 => Ok(Interrupt::GPIOA),
                18 => Ok(Interrupt::GPIOB),
                19 => Ok(Interrupt::SPI0),
                20 => Ok(Interrupt::BLEB),
                21 => Ok(Interrupt::BLEL),
                22 => Ok(Interrupt::USB),
                23 => Ok(Interrupt::USB2),
                24 => Ok(Interrupt::TMR1),
                25 => Ok(Interrupt::TMR2),
                26 => Ok(Interrupt::UART0),
                27 => Ok(Interrupt::UART1),
                28 => Ok(Interrupt::RTC),
                29 => Ok(Interrupt::ADC),
                30 => Ok(Interrupt::I2C),
                31 => Ok(Interrupt::PWMX),
                32 => Ok(Interrupt::TMR3),
                33 => Ok(Interrupt::UART2),
                34 => Ok(Interrupt::UART3),
                35 => Ok(Interrupt::WDOG_BAT),
                _ => Err(TryFromInterruptError(())),
            }
        }
    }
    #[cfg(feature = "rt")]
    #[macro_export]
    /// Assigns a handler to an interrupt
    ///
    /// This macro takes two arguments: the name of an interrupt and the path to the
    /// function that will be used as the handler of that interrupt. That function
    /// must have signature `fn()`.
    ///
    /// Optionally, a third argument may be used to declare interrupt local data.
    /// The handler will have exclusive access to these *local* variables on each
    /// invocation. If the third argument is used then the signature of the handler
    /// function must be `fn(&mut $NAME::Locals)` where `$NAME` is the first argument
    /// passed to the macro.
    ///
    /// # Example
    ///
    /// ``` ignore
    /// interrupt!(TIM2, periodic);
    ///
    /// fn periodic() {
    ///     print!(".");
    /// }
    ///
    /// interrupt!(TIM3, tick, locals: {
    ///     tick: bool = false;
    /// });
    ///
    /// fn tick(locals: &mut TIM3::Locals) {
    ///     locals.tick = !locals.tick;
    ///
    ///     if locals.tick {
    ///         println!("Tick");
    ///     } else {
    ///         println!("Tock");
    ///     }
    /// }
    /// ```
    macro_rules ! interrupt { ($ NAME : ident , $ path : path , locals : { $ ($ lvar : ident : $ lty : ty = $ lval : expr ;) * }) => { # [allow (non_snake_case)]
mod $ NAME { pub struct Locals { $ (pub $ lvar : $ lty ,) * } } # [allow (non_snake_case)]
# [no_mangle]
pub extern "C" fn $ NAME () { let _ = $ crate :: interrupt :: Interrupt :: $ NAME ; static mut LOCALS : self :: $ NAME :: Locals = self :: $ NAME :: Locals { $ ($ lvar : $ lval ,) * } ; let f : fn (& mut self :: $ NAME :: Locals) = $ path ; f (unsafe { & mut LOCALS }) ; } } ; ($ NAME : ident , $ path : path) => { # [allow (non_snake_case)]
# [no_mangle]
pub extern "C" fn $ NAME () { let _ = $ crate :: interrupt :: Interrupt :: $ NAME ; let f : fn () = $ path ; f () ; } } }
}
pub use self::interrupt::Interrupt;
///System Control Register
pub struct SYS {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for SYS {}
impl SYS {
    ///Pointer to the register block
    pub const PTR: *const sys::RegisterBlock = 0x4000_1000 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const sys::RegisterBlock {
        Self::PTR
    }
    /// Steal an instance of this peripheral
    ///
    /// # Safety
    ///
    /// Ensure that the new instance of the peripheral cannot be used in a way
    /// that may race with any existing instances, for example by only
    /// accessing read-only or write-only registers, or by consuming the
    /// original peripheral and using critical sections to coordinate
    /// access between multiple new instances.
    ///
    /// Additionally, other software such as HALs may rely on only one
    /// peripheral instance existing to ensure memory safety; ensure
    /// no stolen instances are passed to such software.
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for SYS {
    type Target = sys::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for SYS {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("SYS").finish()
    }
}
///System Control Register
pub mod sys {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        _reserved0: [u8; 0x08],
        clk_sys_cfg: CLK_SYS_CFG,
        hfck_pwr_ctrl: HFCK_PWR_CTRL,
        _reserved2: [u8; 0x01],
        slp_clk_off0: SLP_CLK_OFF0,
        slp_clk_off1: SLP_CLK_OFF1,
        slp_wake_ctrl: SLP_WAKE_CTRL,
        slp_power_ctrl: SLP_POWER_CTRL,
        _reserved6: [u8; 0x08],
        pin_alternate: PIN_ALTERNATE,
        pin_analog_ie: PIN_ANALOG_IE,
        _reserved8: [u8; 0x04],
        power_plan: POWER_PLAN,
        aux_power_adj: AUX_POWER_ADJ,
        _reserved10: [u8; 0x01],
        bat_det_ctrl: BAT_DET_CTRL,
        bat_det_cfg: BAT_DET_CFG,
        bat_status: BAT_STATUS,
        _reserved13: [u8; 0x05],
        int32k_tune: INT32K_TUNE,
        xt32k_tune: XT32K_TUNE,
        ck32k_config: CK32K_CONFIG,
        rtc_flag_ctrl: RTC_FLAG_CTRL,
        rtc_mode_ctrl: RTC_MODE_CTRL,
        _reserved18: [u8; 0x02],
        rtc_trig: RTC_TRIG,
        rtc_cnt_32k: RTC_CNT_32K,
        rtc_cnt_2s: RTC_CNT_2S,
        rtc_cnt_day: RTC_CNT_DAY,
        safe_access_sig: SAFE_ACCESS_SIG,
        chip_id: CHIP_ID,
        safe_access_id: SAFE_ACCESS_ID,
        wdog_count: WDOG_COUNT,
        reset_status__glob_rom_cfg: RESET_STATUS__GLOB_ROM_CFG,
        glob_cfg_info: GLOB_CFG_INFO,
        rst_wdog_ctrl: RST_WDOG_CTRL,
        glob_reset_keep: GLOB_RESET_KEEP,
        _reserved30: [u8; 0x03],
        pll_config: PLL_CONFIG,
        _reserved31: [u8; 0x02],
        xt32m_tune: XT32M_TUNE,
        _reserved32: [u8; 0x01],
        osc_cal_cnt: OSC_CAL_CNT,
        osc_cal_ov_cnt: OSC_CAL_OV_CNT,
        osc_cal_ctrl: OSC_CAL_CTRL,
        tkey_count: TKEY_COUNT,
        _reserved36: [u8; 0x01],
        tkey_convert: TKEY_CONVERT,
        tkey_cfg: TKEY_CFG,
        adc_channel: ADC_CHANNEL,
        adc_cfg: ADC_CFG,
        adc_convert: ADC_CONVERT,
        tem_sensor: TEM_SENSOR,
        adc_data: ADC_DATA,
        adc_int_flag: ADC_INT_FLAG,
        _reserved44: [u8; 0x01],
        adc_dma_ctrl: ADC_DMA_CTRL,
        adc_ctrl_dma: ADC_CTRL_DMA,
        adc_dma_if: ADC_DMA_IF,
        adc_auto_cycle: ADC_AUTO_CYCLE,
        adc_dma_now: ADC_DMA_NOW,
        _reserved49: [u8; 0x02],
        adc_dma_beg: ADC_DMA_BEG,
        _reserved50: [u8; 0x02],
        adc_dma_end: ADC_DMA_END,
        _reserved51: [u8; 0x22],
        pa_int_en: PA_INT_EN,
        pb_int_en: PB_INT_EN,
        pa_int_mode: PA_INT_MODE,
        pb_int_mode: PB_INT_MODE,
        _reserved55: [u8; 0x04],
        pa_int_if: PA_INT_IF,
        pb_int_if: PB_INT_IF,
        pa_dir: PA_DIR,
        pa_pin: PA_PIN,
        pa_out: PA_OUT,
        pa_clr: PA_CLR,
        pa_pu: PA_PU,
        pa_pd_drv: PA_PD_DRV,
        _reserved63: [u8; 0x08],
        pb_dir: PB_DIR,
        pb_pin: PB_PIN,
        pb_out: PB_OUT,
        pb_clr: PB_CLR,
        pb_pu: PB_PU,
        pb_pd_drv: PB_PD_DRV,
        _reserved69: [u8; 0x072f],
        flash_cfg: FLASH_CFG,
    }
    impl RegisterBlock {
        ///0x08 - RWA, system clock configuration, SAM
        #[inline(always)]
        pub const fn clk_sys_cfg(&self) -> &CLK_SYS_CFG {
            &self.clk_sys_cfg
        }
        ///0x0a - RWA, high frequency clock module power control, SAM
        #[inline(always)]
        pub const fn hfck_pwr_ctrl(&self) -> &HFCK_PWR_CTRL {
            &self.hfck_pwr_ctrl
        }
        ///0x0c - RWA, sleep clock off control byte 0, SAM
        #[inline(always)]
        pub const fn slp_clk_off0(&self) -> &SLP_CLK_OFF0 {
            &self.slp_clk_off0
        }
        ///0x0d - RWA, sleep clock off control byte 1, SAM
        #[inline(always)]
        pub const fn slp_clk_off1(&self) -> &SLP_CLK_OFF1 {
            &self.slp_clk_off1
        }
        ///0x0e - RWA, wake control, SAM
        #[inline(always)]
        pub const fn slp_wake_ctrl(&self) -> &SLP_WAKE_CTRL {
            &self.slp_wake_ctrl
        }
        ///0x0f - RWA, peripherals power down control, SAM
        #[inline(always)]
        pub const fn slp_power_ctrl(&self) -> &SLP_POWER_CTRL {
            &self.slp_power_ctrl
        }
        ///0x18 - RW, function pin alternate configuration
        #[inline(always)]
        pub const fn pin_alternate(&self) -> &PIN_ALTERNATE {
            &self.pin_alternate
        }
        ///0x1a - RW, analog pin enable and digital input disable
        #[inline(always)]
        pub const fn pin_analog_ie(&self) -> &PIN_ANALOG_IE {
            &self.pin_analog_ie
        }
        ///0x20 - RWA, power plan before sleep instruction, SAM
        #[inline(always)]
        pub const fn power_plan(&self) -> &POWER_PLAN {
            &self.power_plan
        }
        ///0x22 - RWA, aux power adjust control, SAM
        #[inline(always)]
        pub const fn aux_power_adj(&self) -> &AUX_POWER_ADJ {
            &self.aux_power_adj
        }
        ///0x24 - RWA, battery voltage detector control, SAM
        #[inline(always)]
        pub const fn bat_det_ctrl(&self) -> &BAT_DET_CTRL {
            &self.bat_det_ctrl
        }
        ///0x25 - RWA, battery voltage detector configuration, SAM
        #[inline(always)]
        pub const fn bat_det_cfg(&self) -> &BAT_DET_CFG {
            &self.bat_det_cfg
        }
        ///0x26 - RO, battery status
        #[inline(always)]
        pub const fn bat_status(&self) -> &BAT_STATUS {
            &self.bat_status
        }
        ///0x2c - RWA, internal 32KHz oscillator tune control, SAM
        #[inline(always)]
        pub const fn int32k_tune(&self) -> &INT32K_TUNE {
            &self.int32k_tune
        }
        ///0x2e - RWA, external 32KHz oscillator tune control, SAM
        #[inline(always)]
        pub const fn xt32k_tune(&self) -> &XT32K_TUNE {
            &self.xt32k_tune
        }
        ///0x2f - RWA, 32KHz oscillator configure
        #[inline(always)]
        pub const fn ck32k_config(&self) -> &CK32K_CONFIG {
            &self.ck32k_config
        }
        ///0x30 - RW, RTC flag and clear control
        #[inline(always)]
        pub const fn rtc_flag_ctrl(&self) -> &RTC_FLAG_CTRL {
            &self.rtc_flag_ctrl
        }
        ///0x31 - RWA, RTC mode control, SAM
        #[inline(always)]
        pub const fn rtc_mode_ctrl(&self) -> &RTC_MODE_CTRL {
            &self.rtc_mode_ctrl
        }
        ///0x34 - RWA, RTC trigger value, SAM
        #[inline(always)]
        pub const fn rtc_trig(&self) -> &RTC_TRIG {
            &self.rtc_trig
        }
        ///0x38 - RO, RTC count based 32KHz
        #[inline(always)]
        pub const fn rtc_cnt_32k(&self) -> &RTC_CNT_32K {
            &self.rtc_cnt_32k
        }
        ///0x3a - RO, RTC count based 2 second
        #[inline(always)]
        pub const fn rtc_cnt_2s(&self) -> &RTC_CNT_2S {
            &self.rtc_cnt_2s
        }
        ///0x3c - RO, RTC count based one day, only low 14 bit
        #[inline(always)]
        pub const fn rtc_cnt_day(&self) -> &RTC_CNT_DAY {
            &self.rtc_cnt_day
        }
        ///0x40 - WO, safe accessing sign register, must write SAFE_ACCESS_SIG1 then SAFE_ACCESS_SIG2 to enter safe accessing mode
        #[inline(always)]
        pub const fn safe_access_sig(&self) -> &SAFE_ACCESS_SIG {
            &self.safe_access_sig
        }
        ///0x41 - RF, chip ID register, always is ID_CH58*
        #[inline(always)]
        pub const fn chip_id(&self) -> &CHIP_ID {
            &self.chip_id
        }
        ///0x42 - RF, safe accessing ID register, always 0x0C
        #[inline(always)]
        pub const fn safe_access_id(&self) -> &SAFE_ACCESS_ID {
            &self.safe_access_id
        }
        ///0x43 - RW, watch-dog count, count by clock frequency Fsys/131072
        #[inline(always)]
        pub const fn wdog_count(&self) -> &WDOG_COUNT {
            &self.wdog_count
        }
        ///0x44 - RWA, reset status, SAM or flash ROM configuration
        #[inline(always)]
        pub const fn reset_status__glob_rom_cfg(&self) -> &RESET_STATUS__GLOB_ROM_CFG {
            &self.reset_status__glob_rom_cfg
        }
        ///0x45 - RO, global configuration information and status
        #[inline(always)]
        pub const fn glob_cfg_info(&self) -> &GLOB_CFG_INFO {
            &self.glob_cfg_info
        }
        ///0x46 - RWA, reset and watch-dog control, SAM
        #[inline(always)]
        pub const fn rst_wdog_ctrl(&self) -> &RST_WDOG_CTRL {
            &self.rst_wdog_ctrl
        }
        ///0x47 - RW, value keeper during global reset
        #[inline(always)]
        pub const fn glob_reset_keep(&self) -> &GLOB_RESET_KEEP {
            &self.glob_reset_keep
        }
        ///0x4b - RWA, PLL configuration control, SAM
        #[inline(always)]
        pub const fn pll_config(&self) -> &PLL_CONFIG {
            &self.pll_config
        }
        ///0x4e - RWA, external 32MHz oscillator tune control, SAM
        #[inline(always)]
        pub const fn xt32m_tune(&self) -> &XT32M_TUNE {
            &self.xt32m_tune
        }
        ///0x50 - RO, system clock count value for 32KHz multi-cycles
        #[inline(always)]
        pub const fn osc_cal_cnt(&self) -> &OSC_CAL_CNT {
            &self.osc_cal_cnt
        }
        ///0x52 - RO, oscillator frequency calibration overflow times
        #[inline(always)]
        pub const fn osc_cal_ov_cnt(&self) -> &OSC_CAL_OV_CNT {
            &self.osc_cal_ov_cnt
        }
        ///0x53 - RWA, oscillator frequency calibration control, SAM
        #[inline(always)]
        pub const fn osc_cal_ctrl(&self) -> &OSC_CAL_CTRL {
            &self.osc_cal_ctrl
        }
        ///0x54 - RW, Touchkey charge and discharge count
        #[inline(always)]
        pub const fn tkey_count(&self) -> &TKEY_COUNT {
            &self.tkey_count
        }
        ///0x56 - RW, Touchkey convert start control
        #[inline(always)]
        pub const fn tkey_convert(&self) -> &TKEY_CONVERT {
            &self.tkey_convert
        }
        ///0x57 - RW, Touchkey configure
        #[inline(always)]
        pub const fn tkey_cfg(&self) -> &TKEY_CFG {
            &self.tkey_cfg
        }
        ///0x58 - RW, ADC input channel selection
        #[inline(always)]
        pub const fn adc_channel(&self) -> &ADC_CHANNEL {
            &self.adc_channel
        }
        ///0x59 - RW, ADC configure
        #[inline(always)]
        pub const fn adc_cfg(&self) -> &ADC_CFG {
            &self.adc_cfg
        }
        ///0x5a - RW, ADC convert control
        #[inline(always)]
        pub const fn adc_convert(&self) -> &ADC_CONVERT {
            &self.adc_convert
        }
        ///0x5b - RW, temperature sensor control
        #[inline(always)]
        pub const fn tem_sensor(&self) -> &TEM_SENSOR {
            &self.tem_sensor
        }
        ///0x5c - RO, ADC data
        #[inline(always)]
        pub const fn adc_data(&self) -> &ADC_DATA {
            &self.adc_data
        }
        ///0x5e - RO, ADC interrupt flag register
        #[inline(always)]
        pub const fn adc_int_flag(&self) -> &ADC_INT_FLAG {
            &self.adc_int_flag
        }
        ///0x60 - RO, ADC DMA control and status register
        #[inline(always)]
        pub const fn adc_dma_ctrl(&self) -> &ADC_DMA_CTRL {
            &self.adc_dma_ctrl
        }
        ///0x61 - RW, ADC DMA control
        #[inline(always)]
        pub const fn adc_ctrl_dma(&self) -> &ADC_CTRL_DMA {
            &self.adc_ctrl_dma
        }
        ///0x62 - RO, ADC interrupt flag
        #[inline(always)]
        pub const fn adc_dma_if(&self) -> &ADC_DMA_IF {
            &self.adc_dma_if
        }
        ///0x63 - RO, ADC interrupt flag
        #[inline(always)]
        pub const fn adc_auto_cycle(&self) -> &ADC_AUTO_CYCLE {
            &self.adc_auto_cycle
        }
        ///0x64 - RO, ADC DMA current address
        #[inline(always)]
        pub const fn adc_dma_now(&self) -> &ADC_DMA_NOW {
            &self.adc_dma_now
        }
        ///0x68 - RW, ADC DMA begin address
        #[inline(always)]
        pub const fn adc_dma_beg(&self) -> &ADC_DMA_BEG {
            &self.adc_dma_beg
        }
        ///0x6c - RW, ADC DMA end address
        #[inline(always)]
        pub const fn adc_dma_end(&self) -> &ADC_DMA_END {
            &self.adc_dma_end
        }
        ///0x90 - RW, GPIO PA interrupt enable
        #[inline(always)]
        pub const fn pa_int_en(&self) -> &PA_INT_EN {
            &self.pa_int_en
        }
        ///0x92 - RW, GPIO PB interrupt enable
        #[inline(always)]
        pub const fn pb_int_en(&self) -> &PB_INT_EN {
            &self.pb_int_en
        }
        ///0x94 - RW, GPIO PA interrupt mode: 0=level action, 1=edge action
        #[inline(always)]
        pub const fn pa_int_mode(&self) -> &PA_INT_MODE {
            &self.pa_int_mode
        }
        ///0x96 - RW, GPIO PB interrupt mode: 0=level action, 1=edge action;RW, status for parallel slave read
        #[inline(always)]
        pub const fn pb_int_mode(&self) -> &PB_INT_MODE {
            &self.pb_int_mode
        }
        ///0x9c - RW1, GPIO PA interrupt flag
        #[inline(always)]
        pub const fn pa_int_if(&self) -> &PA_INT_IF {
            &self.pa_int_if
        }
        ///0x9e - RW1, GPIO PB interrupt flag
        #[inline(always)]
        pub const fn pb_int_if(&self) -> &PB_INT_IF {
            &self.pb_int_if
        }
        ///0xa0 - RW, GPIO PA I/O direction: 0=in, 1=out
        #[inline(always)]
        pub const fn pa_dir(&self) -> &PA_DIR {
            &self.pa_dir
        }
        ///0xa4 - RO, GPIO PA input
        #[inline(always)]
        pub const fn pa_pin(&self) -> &PA_PIN {
            &self.pa_pin
        }
        ///0xa8 - RW, GPIO PA output
        #[inline(always)]
        pub const fn pa_out(&self) -> &PA_OUT {
            &self.pa_out
        }
        ///0xac - WZ, GPIO PA clear output: 0=keep, 1=clear
        #[inline(always)]
        pub const fn pa_clr(&self) -> &PA_CLR {
            &self.pa_clr
        }
        ///0xb0 - RW, GPIO PA pullup resistance enable
        #[inline(always)]
        pub const fn pa_pu(&self) -> &PA_PU {
            &self.pa_pu
        }
        ///0xb4 - RW, PA pulldown for input or PA driving capability for output
        #[inline(always)]
        pub const fn pa_pd_drv(&self) -> &PA_PD_DRV {
            &self.pa_pd_drv
        }
        ///0xc0 - RW, GPIO PB I/O direction: 0=in, 1=out
        #[inline(always)]
        pub const fn pb_dir(&self) -> &PB_DIR {
            &self.pb_dir
        }
        ///0xc4 - RO, GPIO PB input
        #[inline(always)]
        pub const fn pb_pin(&self) -> &PB_PIN {
            &self.pb_pin
        }
        ///0xc8 - RW, GPIO PB output;RW, data for parallel slave read
        #[inline(always)]
        pub const fn pb_out(&self) -> &PB_OUT {
            &self.pb_out
        }
        ///0xcc - WZ, GPIO PB clear output: 0=keep, 1=clear
        #[inline(always)]
        pub const fn pb_clr(&self) -> &PB_CLR {
            &self.pb_clr
        }
        ///0xd0 - RW, GPIO PB pullup resistance enable
        #[inline(always)]
        pub const fn pb_pu(&self) -> &PB_PU {
            &self.pb_pu
        }
        ///0xd4 - RW, PB pulldown for input or PB driving capability for output
        #[inline(always)]
        pub const fn pb_pd_drv(&self) -> &PB_PD_DRV {
            &self.pb_pd_drv
        }
        ///0x807 - Flash configuration
        #[inline(always)]
        pub const fn flash_cfg(&self) -> &FLASH_CFG {
            &self.flash_cfg
        }
    }
    ///CLK_SYS_CFG (rw) register accessor: RWA, system clock configuration, SAM
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`clk_sys_cfg::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`clk_sys_cfg::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@clk_sys_cfg`]
    ///module
    pub type CLK_SYS_CFG = crate::Reg<clk_sys_cfg::CLK_SYS_CFG_SPEC>;
    ///RWA, system clock configuration, SAM
    pub mod clk_sys_cfg {
        ///Register `CLK_SYS_CFG` reader
        pub type R = crate::R<CLK_SYS_CFG_SPEC>;
        ///Register `CLK_SYS_CFG` writer
        pub type W = crate::W<CLK_SYS_CFG_SPEC>;
        ///Field `CLK_PLL_DIV` reader - RWA, output clock divider from PLL or CK32M
        pub type CLK_PLL_DIV_R = crate::FieldReader;
        ///Field `CLK_PLL_DIV` writer - RWA, output clock divider from PLL or CK32M
        pub type CLK_PLL_DIV_W<'a, REG> = crate::FieldWriter<'a, REG, 5>;
        ///Field `CLK_SYS_MOD` reader - RWA, system clock source mode: 00=divided from 32MHz, 01=divided from PLL-480MHz, 10=directly from 32MHz, 11=directly from 32KHz
        pub type CLK_SYS_MOD_R = crate::FieldReader;
        ///Field `CLK_SYS_MOD` writer - RWA, system clock source mode: 00=divided from 32MHz, 01=divided from PLL-480MHz, 10=directly from 32MHz, 11=directly from 32KHz
        pub type CLK_SYS_MOD_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        impl R {
            ///Bits 0:4 - RWA, output clock divider from PLL or CK32M
            #[inline(always)]
            pub fn clk_pll_div(&self) -> CLK_PLL_DIV_R {
                CLK_PLL_DIV_R::new((self.bits & 0x1f) as u8)
            }
            ///Bits 6:7 - RWA, system clock source mode: 00=divided from 32MHz, 01=divided from PLL-480MHz, 10=directly from 32MHz, 11=directly from 32KHz
            #[inline(always)]
            pub fn clk_sys_mod(&self) -> CLK_SYS_MOD_R {
                CLK_SYS_MOD_R::new(((self.bits >> 6) & 3) as u8)
            }
        }
        impl W {
            ///Bits 0:4 - RWA, output clock divider from PLL or CK32M
            #[inline(always)]
            #[must_use]
            pub fn clk_pll_div(&mut self) -> CLK_PLL_DIV_W<CLK_SYS_CFG_SPEC> {
                CLK_PLL_DIV_W::new(self, 0)
            }
            ///Bits 6:7 - RWA, system clock source mode: 00=divided from 32MHz, 01=divided from PLL-480MHz, 10=directly from 32MHz, 11=directly from 32KHz
            #[inline(always)]
            #[must_use]
            pub fn clk_sys_mod(&mut self) -> CLK_SYS_MOD_W<CLK_SYS_CFG_SPEC> {
                CLK_SYS_MOD_W::new(self, 6)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RWA, system clock configuration, SAM
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`clk_sys_cfg::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`clk_sys_cfg::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct CLK_SYS_CFG_SPEC;
        impl crate::RegisterSpec for CLK_SYS_CFG_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`clk_sys_cfg::R`](R) reader structure
        impl crate::Readable for CLK_SYS_CFG_SPEC {}
        ///`write(|w| ..)` method takes [`clk_sys_cfg::W`](W) writer structure
        impl crate::Writable for CLK_SYS_CFG_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets CLK_SYS_CFG to value 0x05
        impl crate::Resettable for CLK_SYS_CFG_SPEC {
            const RESET_VALUE: u16 = 0x05;
        }
    }
    ///HFCK_PWR_CTRL (rw) register accessor: RWA, high frequency clock module power control, SAM
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`hfck_pwr_ctrl::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`hfck_pwr_ctrl::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@hfck_pwr_ctrl`]
    ///module
    pub type HFCK_PWR_CTRL = crate::Reg<hfck_pwr_ctrl::HFCK_PWR_CTRL_SPEC>;
    ///RWA, high frequency clock module power control, SAM
    pub mod hfck_pwr_ctrl {
        ///Register `HFCK_PWR_CTRL` reader
        pub type R = crate::R<HFCK_PWR_CTRL_SPEC>;
        ///Register `HFCK_PWR_CTRL` writer
        pub type W = crate::W<HFCK_PWR_CTRL_SPEC>;
        ///Field `CLK_XT32M_PON` reader - RWA, external 32MHz oscillator power control: 0=power down, 1-power on
        pub type CLK_XT32M_PON_R = crate::BitReader;
        ///Field `CLK_XT32M_PON` writer - RWA, external 32MHz oscillator power control: 0=power down, 1-power on
        pub type CLK_XT32M_PON_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CLK_XT32M_KEEP` reader - RWA, external 32MHz oscillator power keep under halt mode: 0=auto stop, 1=keep running
        pub type CLK_XT32M_KEEP_R = crate::BitReader;
        ///Field `CLK_XT32M_KEEP` writer - RWA, external 32MHz oscillator power keep under halt mode: 0=auto stop, 1=keep running
        pub type CLK_XT32M_KEEP_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CLK_PLL_PON` reader - RWA, PLL power control: 0=power down, 1-power on
        pub type CLK_PLL_PON_R = crate::BitReader;
        ///Field `CLK_PLL_PON` writer - RWA, PLL power control: 0=power down, 1-power on
        pub type CLK_PLL_PON_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 2 - RWA, external 32MHz oscillator power control: 0=power down, 1-power on
            #[inline(always)]
            pub fn clk_xt32m_pon(&self) -> CLK_XT32M_PON_R {
                CLK_XT32M_PON_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RWA, external 32MHz oscillator power keep under halt mode: 0=auto stop, 1=keep running
            #[inline(always)]
            pub fn clk_xt32m_keep(&self) -> CLK_XT32M_KEEP_R {
                CLK_XT32M_KEEP_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RWA, PLL power control: 0=power down, 1-power on
            #[inline(always)]
            pub fn clk_pll_pon(&self) -> CLK_PLL_PON_R {
                CLK_PLL_PON_R::new(((self.bits >> 4) & 1) != 0)
            }
        }
        impl W {
            ///Bit 2 - RWA, external 32MHz oscillator power control: 0=power down, 1-power on
            #[inline(always)]
            #[must_use]
            pub fn clk_xt32m_pon(&mut self) -> CLK_XT32M_PON_W<HFCK_PWR_CTRL_SPEC> {
                CLK_XT32M_PON_W::new(self, 2)
            }
            ///Bit 3 - RWA, external 32MHz oscillator power keep under halt mode: 0=auto stop, 1=keep running
            #[inline(always)]
            #[must_use]
            pub fn clk_xt32m_keep(&mut self) -> CLK_XT32M_KEEP_W<HFCK_PWR_CTRL_SPEC> {
                CLK_XT32M_KEEP_W::new(self, 3)
            }
            ///Bit 4 - RWA, PLL power control: 0=power down, 1-power on
            #[inline(always)]
            #[must_use]
            pub fn clk_pll_pon(&mut self) -> CLK_PLL_PON_W<HFCK_PWR_CTRL_SPEC> {
                CLK_PLL_PON_W::new(self, 4)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RWA, high frequency clock module power control, SAM
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`hfck_pwr_ctrl::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`hfck_pwr_ctrl::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct HFCK_PWR_CTRL_SPEC;
        impl crate::RegisterSpec for HFCK_PWR_CTRL_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`hfck_pwr_ctrl::R`](R) reader structure
        impl crate::Readable for HFCK_PWR_CTRL_SPEC {}
        ///`write(|w| ..)` method takes [`hfck_pwr_ctrl::W`](W) writer structure
        impl crate::Writable for HFCK_PWR_CTRL_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets HFCK_PWR_CTRL to value 0x14
        impl crate::Resettable for HFCK_PWR_CTRL_SPEC {
            const RESET_VALUE: u8 = 0x14;
        }
    }
    ///SLP_CLK_OFF0 (rw) register accessor: RWA, sleep clock off control byte 0, SAM
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`slp_clk_off0::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`slp_clk_off0::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@slp_clk_off0`]
    ///module
    pub type SLP_CLK_OFF0 = crate::Reg<slp_clk_off0::SLP_CLK_OFF0_SPEC>;
    ///RWA, sleep clock off control byte 0, SAM
    pub mod slp_clk_off0 {
        ///Register `SLP_CLK_OFF0` reader
        pub type R = crate::R<SLP_CLK_OFF0_SPEC>;
        ///Register `SLP_CLK_OFF0` writer
        pub type W = crate::W<SLP_CLK_OFF0_SPEC>;
        ///Field `SLP_CLK_TMR0` reader - RWA, close TMR0 clock
        pub type SLP_CLK_TMR0_R = crate::BitReader;
        ///Field `SLP_CLK_TMR0` writer - RWA, close TMR0 clock
        pub type SLP_CLK_TMR0_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `SLP_CLK_TMR1` reader - RWA, close TMR1 clock
        pub type SLP_CLK_TMR1_R = crate::BitReader;
        ///Field `SLP_CLK_TMR1` writer - RWA, close TMR1 clock
        pub type SLP_CLK_TMR1_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `SLP_CLK_TMR2` reader - RWA, close TMR2 clock
        pub type SLP_CLK_TMR2_R = crate::BitReader;
        ///Field `SLP_CLK_TMR2` writer - RWA, close TMR2 clock
        pub type SLP_CLK_TMR2_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `SLP_CLK_TMR3` reader - RWA, close TMR3 clock
        pub type SLP_CLK_TMR3_R = crate::BitReader;
        ///Field `SLP_CLK_TMR3` writer - RWA, close TMR3 clock
        pub type SLP_CLK_TMR3_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `SLP_CLK_UART0` reader - RWA, close UART0 clock
        pub type SLP_CLK_UART0_R = crate::BitReader;
        ///Field `SLP_CLK_UART0` writer - RWA, close UART0 clock
        pub type SLP_CLK_UART0_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `SLP_CLK_UART1` reader - RWA, close UART1 clock
        pub type SLP_CLK_UART1_R = crate::BitReader;
        ///Field `SLP_CLK_UART1` writer - RWA, close UART1 clock
        pub type SLP_CLK_UART1_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `SLP_CLK_UART2` reader - RWA, close UART2 clock
        pub type SLP_CLK_UART2_R = crate::BitReader;
        ///Field `SLP_CLK_UART2` writer - RWA, close UART2 clock
        pub type SLP_CLK_UART2_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `SLP_CLK_UART3` reader - RWA, close UART3 clock
        pub type SLP_CLK_UART3_R = crate::BitReader;
        ///Field `SLP_CLK_UART3` writer - RWA, close UART3 clock
        pub type SLP_CLK_UART3_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - RWA, close TMR0 clock
            #[inline(always)]
            pub fn slp_clk_tmr0(&self) -> SLP_CLK_TMR0_R {
                SLP_CLK_TMR0_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RWA, close TMR1 clock
            #[inline(always)]
            pub fn slp_clk_tmr1(&self) -> SLP_CLK_TMR1_R {
                SLP_CLK_TMR1_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RWA, close TMR2 clock
            #[inline(always)]
            pub fn slp_clk_tmr2(&self) -> SLP_CLK_TMR2_R {
                SLP_CLK_TMR2_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RWA, close TMR3 clock
            #[inline(always)]
            pub fn slp_clk_tmr3(&self) -> SLP_CLK_TMR3_R {
                SLP_CLK_TMR3_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RWA, close UART0 clock
            #[inline(always)]
            pub fn slp_clk_uart0(&self) -> SLP_CLK_UART0_R {
                SLP_CLK_UART0_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - RWA, close UART1 clock
            #[inline(always)]
            pub fn slp_clk_uart1(&self) -> SLP_CLK_UART1_R {
                SLP_CLK_UART1_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - RWA, close UART2 clock
            #[inline(always)]
            pub fn slp_clk_uart2(&self) -> SLP_CLK_UART2_R {
                SLP_CLK_UART2_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - RWA, close UART3 clock
            #[inline(always)]
            pub fn slp_clk_uart3(&self) -> SLP_CLK_UART3_R {
                SLP_CLK_UART3_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RWA, close TMR0 clock
            #[inline(always)]
            #[must_use]
            pub fn slp_clk_tmr0(&mut self) -> SLP_CLK_TMR0_W<SLP_CLK_OFF0_SPEC> {
                SLP_CLK_TMR0_W::new(self, 0)
            }
            ///Bit 1 - RWA, close TMR1 clock
            #[inline(always)]
            #[must_use]
            pub fn slp_clk_tmr1(&mut self) -> SLP_CLK_TMR1_W<SLP_CLK_OFF0_SPEC> {
                SLP_CLK_TMR1_W::new(self, 1)
            }
            ///Bit 2 - RWA, close TMR2 clock
            #[inline(always)]
            #[must_use]
            pub fn slp_clk_tmr2(&mut self) -> SLP_CLK_TMR2_W<SLP_CLK_OFF0_SPEC> {
                SLP_CLK_TMR2_W::new(self, 2)
            }
            ///Bit 3 - RWA, close TMR3 clock
            #[inline(always)]
            #[must_use]
            pub fn slp_clk_tmr3(&mut self) -> SLP_CLK_TMR3_W<SLP_CLK_OFF0_SPEC> {
                SLP_CLK_TMR3_W::new(self, 3)
            }
            ///Bit 4 - RWA, close UART0 clock
            #[inline(always)]
            #[must_use]
            pub fn slp_clk_uart0(&mut self) -> SLP_CLK_UART0_W<SLP_CLK_OFF0_SPEC> {
                SLP_CLK_UART0_W::new(self, 4)
            }
            ///Bit 5 - RWA, close UART1 clock
            #[inline(always)]
            #[must_use]
            pub fn slp_clk_uart1(&mut self) -> SLP_CLK_UART1_W<SLP_CLK_OFF0_SPEC> {
                SLP_CLK_UART1_W::new(self, 5)
            }
            ///Bit 6 - RWA, close UART2 clock
            #[inline(always)]
            #[must_use]
            pub fn slp_clk_uart2(&mut self) -> SLP_CLK_UART2_W<SLP_CLK_OFF0_SPEC> {
                SLP_CLK_UART2_W::new(self, 6)
            }
            ///Bit 7 - RWA, close UART3 clock
            #[inline(always)]
            #[must_use]
            pub fn slp_clk_uart3(&mut self) -> SLP_CLK_UART3_W<SLP_CLK_OFF0_SPEC> {
                SLP_CLK_UART3_W::new(self, 7)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RWA, sleep clock off control byte 0, SAM
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`slp_clk_off0::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`slp_clk_off0::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct SLP_CLK_OFF0_SPEC;
        impl crate::RegisterSpec for SLP_CLK_OFF0_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`slp_clk_off0::R`](R) reader structure
        impl crate::Readable for SLP_CLK_OFF0_SPEC {}
        ///`write(|w| ..)` method takes [`slp_clk_off0::W`](W) writer structure
        impl crate::Writable for SLP_CLK_OFF0_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets SLP_CLK_OFF0 to value 0
        impl crate::Resettable for SLP_CLK_OFF0_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///SLP_CLK_OFF1 (rw) register accessor: RWA, sleep clock off control byte 1, SAM
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`slp_clk_off1::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`slp_clk_off1::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@slp_clk_off1`]
    ///module
    pub type SLP_CLK_OFF1 = crate::Reg<slp_clk_off1::SLP_CLK_OFF1_SPEC>;
    ///RWA, sleep clock off control byte 1, SAM
    pub mod slp_clk_off1 {
        ///Register `SLP_CLK_OFF1` reader
        pub type R = crate::R<SLP_CLK_OFF1_SPEC>;
        ///Register `SLP_CLK_OFF1` writer
        pub type W = crate::W<SLP_CLK_OFF1_SPEC>;
        ///Field `SLP_CLK_SPI0` reader - RWA, close SPI0 clock
        pub type SLP_CLK_SPI0_R = crate::BitReader;
        ///Field `SLP_CLK_SPI0` writer - RWA, close SPI0 clock
        pub type SLP_CLK_SPI0_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `SLP_CLK_SPI1` reader - RWA, close SPI1 clock
        pub type SLP_CLK_SPI1_R = crate::BitReader;
        ///Field `SLP_CLK_SPI1` writer - RWA, close SPI1 clock
        pub type SLP_CLK_SPI1_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `SLP_CLK_PWMX` reader - RWA, close PWMx clock
        pub type SLP_CLK_PWMX_R = crate::BitReader;
        ///Field `SLP_CLK_PWMX` writer - RWA, close PWMx clock
        pub type SLP_CLK_PWMX_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `SLP_CLK_I2C` reader - RWA, close I2C clock
        pub type SLP_CLK_I2C_R = crate::BitReader;
        ///Field `SLP_CLK_I2C` writer - RWA, close I2C clock
        pub type SLP_CLK_I2C_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `SLP_CLK_USB` reader - RWA, close USB clock
        pub type SLP_CLK_USB_R = crate::BitReader;
        ///Field `SLP_CLK_USB` writer - RWA, close USB clock
        pub type SLP_CLK_USB_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `SLP_CLK_BLE` reader - RWA, close BLE clock
        pub type SLP_CLK_BLE_R = crate::BitReader;
        ///Field `SLP_CLK_BLE` writer - RWA, close BLE clock
        pub type SLP_CLK_BLE_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - RWA, close SPI0 clock
            #[inline(always)]
            pub fn slp_clk_spi0(&self) -> SLP_CLK_SPI0_R {
                SLP_CLK_SPI0_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RWA, close SPI1 clock
            #[inline(always)]
            pub fn slp_clk_spi1(&self) -> SLP_CLK_SPI1_R {
                SLP_CLK_SPI1_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RWA, close PWMx clock
            #[inline(always)]
            pub fn slp_clk_pwmx(&self) -> SLP_CLK_PWMX_R {
                SLP_CLK_PWMX_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RWA, close I2C clock
            #[inline(always)]
            pub fn slp_clk_i2c(&self) -> SLP_CLK_I2C_R {
                SLP_CLK_I2C_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RWA, close USB clock
            #[inline(always)]
            pub fn slp_clk_usb(&self) -> SLP_CLK_USB_R {
                SLP_CLK_USB_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 7 - RWA, close BLE clock
            #[inline(always)]
            pub fn slp_clk_ble(&self) -> SLP_CLK_BLE_R {
                SLP_CLK_BLE_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RWA, close SPI0 clock
            #[inline(always)]
            #[must_use]
            pub fn slp_clk_spi0(&mut self) -> SLP_CLK_SPI0_W<SLP_CLK_OFF1_SPEC> {
                SLP_CLK_SPI0_W::new(self, 0)
            }
            ///Bit 1 - RWA, close SPI1 clock
            #[inline(always)]
            #[must_use]
            pub fn slp_clk_spi1(&mut self) -> SLP_CLK_SPI1_W<SLP_CLK_OFF1_SPEC> {
                SLP_CLK_SPI1_W::new(self, 1)
            }
            ///Bit 2 - RWA, close PWMx clock
            #[inline(always)]
            #[must_use]
            pub fn slp_clk_pwmx(&mut self) -> SLP_CLK_PWMX_W<SLP_CLK_OFF1_SPEC> {
                SLP_CLK_PWMX_W::new(self, 2)
            }
            ///Bit 3 - RWA, close I2C clock
            #[inline(always)]
            #[must_use]
            pub fn slp_clk_i2c(&mut self) -> SLP_CLK_I2C_W<SLP_CLK_OFF1_SPEC> {
                SLP_CLK_I2C_W::new(self, 3)
            }
            ///Bit 4 - RWA, close USB clock
            #[inline(always)]
            #[must_use]
            pub fn slp_clk_usb(&mut self) -> SLP_CLK_USB_W<SLP_CLK_OFF1_SPEC> {
                SLP_CLK_USB_W::new(self, 4)
            }
            ///Bit 7 - RWA, close BLE clock
            #[inline(always)]
            #[must_use]
            pub fn slp_clk_ble(&mut self) -> SLP_CLK_BLE_W<SLP_CLK_OFF1_SPEC> {
                SLP_CLK_BLE_W::new(self, 7)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RWA, sleep clock off control byte 1, SAM
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`slp_clk_off1::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`slp_clk_off1::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct SLP_CLK_OFF1_SPEC;
        impl crate::RegisterSpec for SLP_CLK_OFF1_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`slp_clk_off1::R`](R) reader structure
        impl crate::Readable for SLP_CLK_OFF1_SPEC {}
        ///`write(|w| ..)` method takes [`slp_clk_off1::W`](W) writer structure
        impl crate::Writable for SLP_CLK_OFF1_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets SLP_CLK_OFF1 to value 0
        impl crate::Resettable for SLP_CLK_OFF1_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///SLP_WAKE_CTRL (rw) register accessor: RWA, wake control, SAM
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`slp_wake_ctrl::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`slp_wake_ctrl::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@slp_wake_ctrl`]
    ///module
    pub type SLP_WAKE_CTRL = crate::Reg<slp_wake_ctrl::SLP_WAKE_CTRL_SPEC>;
    ///RWA, wake control, SAM
    pub mod slp_wake_ctrl {
        ///Register `SLP_WAKE_CTRL` reader
        pub type R = crate::R<SLP_WAKE_CTRL_SPEC>;
        ///Register `SLP_WAKE_CTRL` writer
        pub type W = crate::W<SLP_WAKE_CTRL_SPEC>;
        ///Field `SLP_USB_WAKE` reader - RWA, enable USB waking
        pub type SLP_USB_WAKE_R = crate::BitReader;
        ///Field `SLP_USB_WAKE` writer - RWA, enable USB waking
        pub type SLP_USB_WAKE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `SLP_USB2_WAKE` reader - RWA, enable USB2 waking
        pub type SLP_USB2_WAKE_R = crate::BitReader;
        ///Field `SLP_USB2_WAKE` writer - RWA, enable USB2 waking
        pub type SLP_USB2_WAKE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `SLP_RTC_WAKE` reader - RWA, enable RTC waking
        pub type SLP_RTC_WAKE_R = crate::BitReader;
        ///Field `SLP_RTC_WAKE` writer - RWA, enable RTC waking
        pub type SLP_RTC_WAKE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `SLP_GPIO_WAKE` reader - RWA, enable GPIO waking
        pub type SLP_GPIO_WAKE_R = crate::BitReader;
        ///Field `SLP_GPIO_WAKE` writer - RWA, enable GPIO waking
        pub type SLP_GPIO_WAKE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `SLP_BAT_WAKE` reader - RWA, enable BAT waking
        pub type SLP_BAT_WAKE_R = crate::BitReader;
        ///Field `SLP_BAT_WAKE` writer - RWA, enable BAT waking
        pub type SLP_BAT_WAKE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `WAKE_EV_MODE` reader - RWA, event wakeup mode
        pub type WAKE_EV_MODE_R = crate::BitReader;
        ///Field `WAKE_EV_MODE` writer - RWA, event wakeup mode
        pub type WAKE_EV_MODE_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - RWA, enable USB waking
            #[inline(always)]
            pub fn slp_usb_wake(&self) -> SLP_USB_WAKE_R {
                SLP_USB_WAKE_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RWA, enable USB2 waking
            #[inline(always)]
            pub fn slp_usb2_wake(&self) -> SLP_USB2_WAKE_R {
                SLP_USB2_WAKE_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 3 - RWA, enable RTC waking
            #[inline(always)]
            pub fn slp_rtc_wake(&self) -> SLP_RTC_WAKE_R {
                SLP_RTC_WAKE_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RWA, enable GPIO waking
            #[inline(always)]
            pub fn slp_gpio_wake(&self) -> SLP_GPIO_WAKE_R {
                SLP_GPIO_WAKE_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - RWA, enable BAT waking
            #[inline(always)]
            pub fn slp_bat_wake(&self) -> SLP_BAT_WAKE_R {
                SLP_BAT_WAKE_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - RWA, event wakeup mode
            #[inline(always)]
            pub fn wake_ev_mode(&self) -> WAKE_EV_MODE_R {
                WAKE_EV_MODE_R::new(((self.bits >> 6) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RWA, enable USB waking
            #[inline(always)]
            #[must_use]
            pub fn slp_usb_wake(&mut self) -> SLP_USB_WAKE_W<SLP_WAKE_CTRL_SPEC> {
                SLP_USB_WAKE_W::new(self, 0)
            }
            ///Bit 1 - RWA, enable USB2 waking
            #[inline(always)]
            #[must_use]
            pub fn slp_usb2_wake(&mut self) -> SLP_USB2_WAKE_W<SLP_WAKE_CTRL_SPEC> {
                SLP_USB2_WAKE_W::new(self, 1)
            }
            ///Bit 3 - RWA, enable RTC waking
            #[inline(always)]
            #[must_use]
            pub fn slp_rtc_wake(&mut self) -> SLP_RTC_WAKE_W<SLP_WAKE_CTRL_SPEC> {
                SLP_RTC_WAKE_W::new(self, 3)
            }
            ///Bit 4 - RWA, enable GPIO waking
            #[inline(always)]
            #[must_use]
            pub fn slp_gpio_wake(&mut self) -> SLP_GPIO_WAKE_W<SLP_WAKE_CTRL_SPEC> {
                SLP_GPIO_WAKE_W::new(self, 4)
            }
            ///Bit 5 - RWA, enable BAT waking
            #[inline(always)]
            #[must_use]
            pub fn slp_bat_wake(&mut self) -> SLP_BAT_WAKE_W<SLP_WAKE_CTRL_SPEC> {
                SLP_BAT_WAKE_W::new(self, 5)
            }
            ///Bit 6 - RWA, event wakeup mode
            #[inline(always)]
            #[must_use]
            pub fn wake_ev_mode(&mut self) -> WAKE_EV_MODE_W<SLP_WAKE_CTRL_SPEC> {
                WAKE_EV_MODE_W::new(self, 6)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RWA, wake control, SAM
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`slp_wake_ctrl::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`slp_wake_ctrl::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct SLP_WAKE_CTRL_SPEC;
        impl crate::RegisterSpec for SLP_WAKE_CTRL_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`slp_wake_ctrl::R`](R) reader structure
        impl crate::Readable for SLP_WAKE_CTRL_SPEC {}
        ///`write(|w| ..)` method takes [`slp_wake_ctrl::W`](W) writer structure
        impl crate::Writable for SLP_WAKE_CTRL_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets SLP_WAKE_CTRL to value 0x20
        impl crate::Resettable for SLP_WAKE_CTRL_SPEC {
            const RESET_VALUE: u8 = 0x20;
        }
    }
    ///SLP_POWER_CTRL (rw) register accessor: RWA, peripherals power down control, SAM
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`slp_power_ctrl::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`slp_power_ctrl::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@slp_power_ctrl`]
    ///module
    pub type SLP_POWER_CTRL = crate::Reg<slp_power_ctrl::SLP_POWER_CTRL_SPEC>;
    ///RWA, peripherals power down control, SAM
    pub mod slp_power_ctrl {
        ///Register `SLP_POWER_CTRL` reader
        pub type R = crate::R<SLP_POWER_CTRL_SPEC>;
        ///Register `SLP_POWER_CTRL` writer
        pub type W = crate::W<SLP_POWER_CTRL_SPEC>;
        ///Field `WAKE_DLY_MOD` reader - RWA, wakeup delay time selection
        pub type WAKE_DLY_MOD_R = crate::FieldReader;
        ///Field `WAKE_DLY_MOD` writer - RWA, wakeup delay time selection
        pub type WAKE_DLY_MOD_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `SLP_CLK_RAMX` reader - RWA, close main SRAM clock
        pub type SLP_CLK_RAMX_R = crate::BitReader;
        ///Field `SLP_CLK_RAMX` writer - RWA, close main SRAM clock
        pub type SLP_CLK_RAMX_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `SLP_CLK_RAM2K` reader - RWA, close retention 2KB SRAM clock
        pub type SLP_CLK_RAM2K_R = crate::BitReader;
        ///Field `SLP_CLK_RAM2K` writer - RWA, close retention 2KB SRAM clock
        pub type SLP_CLK_RAM2K_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `RAM_RET_LV` reader - RWA, SRAM retention voltage selection
        pub type RAM_RET_LV_R = crate::BitReader;
        ///Field `RAM_RET_LV` writer - RWA, SRAM retention voltage selection
        pub type RAM_RET_LV_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bits 0:1 - RWA, wakeup delay time selection
            #[inline(always)]
            pub fn wake_dly_mod(&self) -> WAKE_DLY_MOD_R {
                WAKE_DLY_MOD_R::new(self.bits & 3)
            }
            ///Bit 4 - RWA, close main SRAM clock
            #[inline(always)]
            pub fn slp_clk_ramx(&self) -> SLP_CLK_RAMX_R {
                SLP_CLK_RAMX_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - RWA, close retention 2KB SRAM clock
            #[inline(always)]
            pub fn slp_clk_ram2k(&self) -> SLP_CLK_RAM2K_R {
                SLP_CLK_RAM2K_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - RWA, SRAM retention voltage selection
            #[inline(always)]
            pub fn ram_ret_lv(&self) -> RAM_RET_LV_R {
                RAM_RET_LV_R::new(((self.bits >> 6) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:1 - RWA, wakeup delay time selection
            #[inline(always)]
            #[must_use]
            pub fn wake_dly_mod(&mut self) -> WAKE_DLY_MOD_W<SLP_POWER_CTRL_SPEC> {
                WAKE_DLY_MOD_W::new(self, 0)
            }
            ///Bit 4 - RWA, close main SRAM clock
            #[inline(always)]
            #[must_use]
            pub fn slp_clk_ramx(&mut self) -> SLP_CLK_RAMX_W<SLP_POWER_CTRL_SPEC> {
                SLP_CLK_RAMX_W::new(self, 4)
            }
            ///Bit 5 - RWA, close retention 2KB SRAM clock
            #[inline(always)]
            #[must_use]
            pub fn slp_clk_ram2k(&mut self) -> SLP_CLK_RAM2K_W<SLP_POWER_CTRL_SPEC> {
                SLP_CLK_RAM2K_W::new(self, 5)
            }
            ///Bit 6 - RWA, SRAM retention voltage selection
            #[inline(always)]
            #[must_use]
            pub fn ram_ret_lv(&mut self) -> RAM_RET_LV_W<SLP_POWER_CTRL_SPEC> {
                RAM_RET_LV_W::new(self, 6)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RWA, peripherals power down control, SAM
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`slp_power_ctrl::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`slp_power_ctrl::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct SLP_POWER_CTRL_SPEC;
        impl crate::RegisterSpec for SLP_POWER_CTRL_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`slp_power_ctrl::R`](R) reader structure
        impl crate::Readable for SLP_POWER_CTRL_SPEC {}
        ///`write(|w| ..)` method takes [`slp_power_ctrl::W`](W) writer structure
        impl crate::Writable for SLP_POWER_CTRL_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets SLP_POWER_CTRL to value 0
        impl crate::Resettable for SLP_POWER_CTRL_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///PIN_ALTERNATE (rw) register accessor: RW, function pin alternate configuration
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`pin_alternate::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pin_alternate::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@pin_alternate`]
    ///module
    pub type PIN_ALTERNATE = crate::Reg<pin_alternate::PIN_ALTERNATE_SPEC>;
    ///RW, function pin alternate configuration
    pub mod pin_alternate {
        ///Register `PIN_ALTERNATE` reader
        pub type R = crate::R<PIN_ALTERNATE_SPEC>;
        ///Register `PIN_ALTERNATE` writer
        pub type W = crate::W<PIN_ALTERNATE_SPEC>;
        ///Field `PIN_TMR0` reader - RW, TMR0 alternate pin enable
        pub type PIN_TMR0_R = crate::BitReader;
        ///Field `PIN_TMR0` writer - RW, TMR0 alternate pin enable
        pub type PIN_TMR0_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PIN_TMR1` reader - RW, TMR1 alternate pin enable
        pub type PIN_TMR1_R = crate::BitReader;
        ///Field `PIN_TMR1` writer - RW, TMR1 alternate pin enable
        pub type PIN_TMR1_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PIN_TMR2` reader - RW, TMR2 alternate pin enable
        pub type PIN_TMR2_R = crate::BitReader;
        ///Field `PIN_TMR2` writer - RW, TMR2 alternate pin enable
        pub type PIN_TMR2_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PIN_TMR3` reader - RW, TMR3 alternate pin enable
        pub type PIN_TMR3_R = crate::BitReader;
        ///Field `PIN_TMR3` writer - RW, TMR3 alternate pin enable
        pub type PIN_TMR3_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PIN_UART0` reader - RW, RXD0/TXD0 alternate pin enable
        pub type PIN_UART0_R = crate::BitReader;
        ///Field `PIN_UART0` writer - RW, RXD0/TXD0 alternate pin enable
        pub type PIN_UART0_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PIN_UART1` reader - RW, RXD1/TXD1 alternate pin enable
        pub type PIN_UART1_R = crate::BitReader;
        ///Field `PIN_UART1` writer - RW, RXD1/TXD1 alternate pin enable
        pub type PIN_UART1_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PIN_UART2` reader - RW, RXD2/TXD2 alternate pin enable
        pub type PIN_UART2_R = crate::BitReader;
        ///Field `PIN_UART2` writer - RW, RXD2/TXD2 alternate pin enable
        pub type PIN_UART2_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PIN_UART3` reader - RW, RXD3/TXD3 alternate pin enable
        pub type PIN_UART3_R = crate::BitReader;
        ///Field `PIN_UART3` writer - RW, RXD3/TXD3 alternate pin enable
        pub type PIN_UART3_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PIN_SPI0` reader - RW, SCS/SCK0/MOSI/MISO alternate pin enable
        pub type PIN_SPI0_R = crate::BitReader;
        ///Field `PIN_SPI0` writer - RW, SCS/SCK0/MOSI/MISO alternate pin enable
        pub type PIN_SPI0_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PIN_PWMX` reader - RW, PWM4/PWM5/PWM7/PWM8/PWM9 alternate pin enable
        pub type PIN_PWMX_R = crate::BitReader;
        ///Field `PIN_PWMX` writer - RW, PWM4/PWM5/PWM7/PWM8/PWM9 alternate pin enable
        pub type PIN_PWMX_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PIN_I2C` reader - RW, SCL/SDA alternate pin enable
        pub type PIN_I2C_R = crate::BitReader;
        ///Field `PIN_I2C` writer - RW, SCL/SDA alternate pin enable
        pub type PIN_I2C_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PIN_MODEM` reader - RW, DSR/DTR alternate pin enable
        pub type PIN_MODEM_R = crate::BitReader;
        ///Field `PIN_MODEM` writer - RW, DSR/DTR alternate pin enable
        pub type PIN_MODEM_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PIN_INTX` reader - RW, interrupt INT24/INT25 alternate pin enable
        pub type PIN_INTX_R = crate::BitReader;
        ///Field `PIN_INTX` writer - RW, interrupt INT24/INT25 alternate pin enable
        pub type PIN_INTX_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PIN_U0_INV` reader - RW, SCL/SDA alternRW, RXD0/RXD0_/TXD0/TXD0_ invert input/output enableate pin enable
        pub type PIN_U0_INV_R = crate::BitReader;
        ///Field `PIN_U0_INV` writer - RW, SCL/SDA alternRW, RXD0/RXD0_/TXD0/TXD0_ invert input/output enableate pin enable
        pub type PIN_U0_INV_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `RF_ANT_SW_EN` reader - RW, RF antenna switch control output enable
        pub type RF_ANT_SW_EN_R = crate::BitReader;
        ///Field `RF_ANT_SW_EN` writer - RW, RF antenna switch control output enable
        pub type RF_ANT_SW_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - RW, TMR0 alternate pin enable
            #[inline(always)]
            pub fn pin_tmr0(&self) -> PIN_TMR0_R {
                PIN_TMR0_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RW, TMR1 alternate pin enable
            #[inline(always)]
            pub fn pin_tmr1(&self) -> PIN_TMR1_R {
                PIN_TMR1_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RW, TMR2 alternate pin enable
            #[inline(always)]
            pub fn pin_tmr2(&self) -> PIN_TMR2_R {
                PIN_TMR2_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RW, TMR3 alternate pin enable
            #[inline(always)]
            pub fn pin_tmr3(&self) -> PIN_TMR3_R {
                PIN_TMR3_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RW, RXD0/TXD0 alternate pin enable
            #[inline(always)]
            pub fn pin_uart0(&self) -> PIN_UART0_R {
                PIN_UART0_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - RW, RXD1/TXD1 alternate pin enable
            #[inline(always)]
            pub fn pin_uart1(&self) -> PIN_UART1_R {
                PIN_UART1_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - RW, RXD2/TXD2 alternate pin enable
            #[inline(always)]
            pub fn pin_uart2(&self) -> PIN_UART2_R {
                PIN_UART2_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - RW, RXD3/TXD3 alternate pin enable
            #[inline(always)]
            pub fn pin_uart3(&self) -> PIN_UART3_R {
                PIN_UART3_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bit 8 - RW, SCS/SCK0/MOSI/MISO alternate pin enable
            #[inline(always)]
            pub fn pin_spi0(&self) -> PIN_SPI0_R {
                PIN_SPI0_R::new(((self.bits >> 8) & 1) != 0)
            }
            ///Bit 10 - RW, PWM4/PWM5/PWM7/PWM8/PWM9 alternate pin enable
            #[inline(always)]
            pub fn pin_pwmx(&self) -> PIN_PWMX_R {
                PIN_PWMX_R::new(((self.bits >> 10) & 1) != 0)
            }
            ///Bit 11 - RW, SCL/SDA alternate pin enable
            #[inline(always)]
            pub fn pin_i2c(&self) -> PIN_I2C_R {
                PIN_I2C_R::new(((self.bits >> 11) & 1) != 0)
            }
            ///Bit 12 - RW, DSR/DTR alternate pin enable
            #[inline(always)]
            pub fn pin_modem(&self) -> PIN_MODEM_R {
                PIN_MODEM_R::new(((self.bits >> 12) & 1) != 0)
            }
            ///Bit 13 - RW, interrupt INT24/INT25 alternate pin enable
            #[inline(always)]
            pub fn pin_intx(&self) -> PIN_INTX_R {
                PIN_INTX_R::new(((self.bits >> 13) & 1) != 0)
            }
            ///Bit 14 - RW, SCL/SDA alternRW, RXD0/RXD0_/TXD0/TXD0_ invert input/output enableate pin enable
            #[inline(always)]
            pub fn pin_u0_inv(&self) -> PIN_U0_INV_R {
                PIN_U0_INV_R::new(((self.bits >> 14) & 1) != 0)
            }
            ///Bit 15 - RW, RF antenna switch control output enable
            #[inline(always)]
            pub fn rf_ant_sw_en(&self) -> RF_ANT_SW_EN_R {
                RF_ANT_SW_EN_R::new(((self.bits >> 15) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RW, TMR0 alternate pin enable
            #[inline(always)]
            #[must_use]
            pub fn pin_tmr0(&mut self) -> PIN_TMR0_W<PIN_ALTERNATE_SPEC> {
                PIN_TMR0_W::new(self, 0)
            }
            ///Bit 1 - RW, TMR1 alternate pin enable
            #[inline(always)]
            #[must_use]
            pub fn pin_tmr1(&mut self) -> PIN_TMR1_W<PIN_ALTERNATE_SPEC> {
                PIN_TMR1_W::new(self, 1)
            }
            ///Bit 2 - RW, TMR2 alternate pin enable
            #[inline(always)]
            #[must_use]
            pub fn pin_tmr2(&mut self) -> PIN_TMR2_W<PIN_ALTERNATE_SPEC> {
                PIN_TMR2_W::new(self, 2)
            }
            ///Bit 3 - RW, TMR3 alternate pin enable
            #[inline(always)]
            #[must_use]
            pub fn pin_tmr3(&mut self) -> PIN_TMR3_W<PIN_ALTERNATE_SPEC> {
                PIN_TMR3_W::new(self, 3)
            }
            ///Bit 4 - RW, RXD0/TXD0 alternate pin enable
            #[inline(always)]
            #[must_use]
            pub fn pin_uart0(&mut self) -> PIN_UART0_W<PIN_ALTERNATE_SPEC> {
                PIN_UART0_W::new(self, 4)
            }
            ///Bit 5 - RW, RXD1/TXD1 alternate pin enable
            #[inline(always)]
            #[must_use]
            pub fn pin_uart1(&mut self) -> PIN_UART1_W<PIN_ALTERNATE_SPEC> {
                PIN_UART1_W::new(self, 5)
            }
            ///Bit 6 - RW, RXD2/TXD2 alternate pin enable
            #[inline(always)]
            #[must_use]
            pub fn pin_uart2(&mut self) -> PIN_UART2_W<PIN_ALTERNATE_SPEC> {
                PIN_UART2_W::new(self, 6)
            }
            ///Bit 7 - RW, RXD3/TXD3 alternate pin enable
            #[inline(always)]
            #[must_use]
            pub fn pin_uart3(&mut self) -> PIN_UART3_W<PIN_ALTERNATE_SPEC> {
                PIN_UART3_W::new(self, 7)
            }
            ///Bit 8 - RW, SCS/SCK0/MOSI/MISO alternate pin enable
            #[inline(always)]
            #[must_use]
            pub fn pin_spi0(&mut self) -> PIN_SPI0_W<PIN_ALTERNATE_SPEC> {
                PIN_SPI0_W::new(self, 8)
            }
            ///Bit 10 - RW, PWM4/PWM5/PWM7/PWM8/PWM9 alternate pin enable
            #[inline(always)]
            #[must_use]
            pub fn pin_pwmx(&mut self) -> PIN_PWMX_W<PIN_ALTERNATE_SPEC> {
                PIN_PWMX_W::new(self, 10)
            }
            ///Bit 11 - RW, SCL/SDA alternate pin enable
            #[inline(always)]
            #[must_use]
            pub fn pin_i2c(&mut self) -> PIN_I2C_W<PIN_ALTERNATE_SPEC> {
                PIN_I2C_W::new(self, 11)
            }
            ///Bit 12 - RW, DSR/DTR alternate pin enable
            #[inline(always)]
            #[must_use]
            pub fn pin_modem(&mut self) -> PIN_MODEM_W<PIN_ALTERNATE_SPEC> {
                PIN_MODEM_W::new(self, 12)
            }
            ///Bit 13 - RW, interrupt INT24/INT25 alternate pin enable
            #[inline(always)]
            #[must_use]
            pub fn pin_intx(&mut self) -> PIN_INTX_W<PIN_ALTERNATE_SPEC> {
                PIN_INTX_W::new(self, 13)
            }
            ///Bit 14 - RW, SCL/SDA alternRW, RXD0/RXD0_/TXD0/TXD0_ invert input/output enableate pin enable
            #[inline(always)]
            #[must_use]
            pub fn pin_u0_inv(&mut self) -> PIN_U0_INV_W<PIN_ALTERNATE_SPEC> {
                PIN_U0_INV_W::new(self, 14)
            }
            ///Bit 15 - RW, RF antenna switch control output enable
            #[inline(always)]
            #[must_use]
            pub fn rf_ant_sw_en(&mut self) -> RF_ANT_SW_EN_W<PIN_ALTERNATE_SPEC> {
                RF_ANT_SW_EN_W::new(self, 15)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW, function pin alternate configuration
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`pin_alternate::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pin_alternate::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct PIN_ALTERNATE_SPEC;
        impl crate::RegisterSpec for PIN_ALTERNATE_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`pin_alternate::R`](R) reader structure
        impl crate::Readable for PIN_ALTERNATE_SPEC {}
        ///`write(|w| ..)` method takes [`pin_alternate::W`](W) writer structure
        impl crate::Writable for PIN_ALTERNATE_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets PIN_ALTERNATE to value 0
        impl crate::Resettable for PIN_ALTERNATE_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///PIN_ANALOG_IE (rw) register accessor: RW, analog pin enable and digital input disable
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`pin_analog_ie::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pin_analog_ie::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@pin_analog_ie`]
    ///module
    pub type PIN_ANALOG_IE = crate::Reg<pin_analog_ie::PIN_ANALOG_IE_SPEC>;
    ///RW, analog pin enable and digital input disable
    pub mod pin_analog_ie {
        ///Register `PIN_ANALOG_IE` reader
        pub type R = crate::R<PIN_ANALOG_IE_SPEC>;
        ///Register `PIN_ANALOG_IE` writer
        pub type W = crate::W<PIN_ANALOG_IE_SPEC>;
        ///Field `PIN_ADC8_9_IE` reader - RW, ADC/TouchKey channel 9/8 digital input disable
        pub type PIN_ADC8_9_IE_R = crate::BitReader;
        ///Field `PIN_ADC8_9_IE` writer - RW, ADC/TouchKey channel 9/8 digital input disable
        pub type PIN_ADC8_9_IE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PIN_ADC6_7_IE` reader - RW, ADC/TouchKey channel 7/6 digital input disable
        pub type PIN_ADC6_7_IE_R = crate::BitReader;
        ///Field `PIN_ADC6_7_IE` writer - RW, ADC/TouchKey channel 7/6 digital input disable
        pub type PIN_ADC6_7_IE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PIN_ADC10_IE` reader - RW, ADC/TouchKey channel 10 digital input disable
        pub type PIN_ADC10_IE_R = crate::BitReader;
        ///Field `PIN_ADC10_IE` writer - RW, ADC/TouchKey channel 10 digital input disable
        pub type PIN_ADC10_IE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PIN_ADC11_IE` reader - RW, ADC/TouchKey channel 11 digital input disable
        pub type PIN_ADC11_IE_R = crate::BitReader;
        ///Field `PIN_ADC11_IE` writer - RW, ADC/TouchKey channel 11 digital input disable
        pub type PIN_ADC11_IE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PIN_USB2_DP_PU` reader - RW,USB2 UDP internal pullup resistance enable
        pub type PIN_USB2_DP_PU_R = crate::BitReader;
        ///Field `PIN_USB2_DP_PU` writer - RW,USB2 UDP internal pullup resistance enable
        pub type PIN_USB2_DP_PU_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PIN_USB2_IE` reader - RW, USB analog I/O enable: 0=analog I/O disable, 1=analog I/O enable
        pub type PIN_USB2_IE_R = crate::BitReader;
        ///Field `PIN_USB2_IE` writer - RW, USB analog I/O enable: 0=analog I/O disable, 1=analog I/O enable
        pub type PIN_USB2_IE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PIN_USB_DP_PU` reader - RW,USB UDP internal pullup resistance enable
        pub type PIN_USB_DP_PU_R = crate::BitReader;
        ///Field `PIN_USB_DP_PU` writer - RW,USB UDP internal pullup resistance enable
        pub type PIN_USB_DP_PU_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PIN_USB_IE` reader - RW, USB analog I/O enable: 0=analog I/O disable, 1=analog I/O enable
        pub type PIN_USB_IE_R = crate::BitReader;
        ///Field `PIN_USB_IE` writer - RW, USB analog I/O enable: 0=analog I/O disable, 1=analog I/O enable
        pub type PIN_USB_IE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PIN_ADC0_IE` reader - RW, ADC/TouchKey channel0 digital input disable: 0=digital input enable, 1=digital input disable
        pub type PIN_ADC0_IE_R = crate::BitReader;
        ///Field `PIN_ADC0_IE` writer - RW, ADC/TouchKey channel0 digital input disable: 0=digital input enable, 1=digital input disable
        pub type PIN_ADC0_IE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PIN_ADC1_IE` reader - RW, ADC/TouchKey channel1 digital input disable: 0=digital input enable, 1=digital input disable
        pub type PIN_ADC1_IE_R = crate::BitReader;
        ///Field `PIN_ADC1_IE` writer - RW, ADC/TouchKey channel1 digital input disable: 0=digital input enable, 1=digital input disable
        pub type PIN_ADC1_IE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PIN_ADC12_IE` reader - RW, ADC/TouchKey channel12 digital input disable: 0=digital input enable, 1=digital input disable
        pub type PIN_ADC12_IE_R = crate::BitReader;
        ///Field `PIN_ADC12_IE` writer - RW, ADC/TouchKey channel12 digital input disable: 0=digital input enable, 1=digital input disable
        pub type PIN_ADC12_IE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PIN_ADC13_IE` reader - RW, ADC/TouchKey channel13 digital input disable: 0=digital input enable, 1=digital input disable
        pub type PIN_ADC13_IE_R = crate::BitReader;
        ///Field `PIN_ADC13_IE` writer - RW, ADC/TouchKey channel13 digital input disable: 0=digital input enable, 1=digital input disable
        pub type PIN_ADC13_IE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PIN_XT32K_IE` reader - RW, external 32KHz oscillator digital input disable: 0=digital input enable, 1=digital input disable
        pub type PIN_XT32K_IE_R = crate::BitReader;
        ///Field `PIN_XT32K_IE` writer - RW, external 32KHz oscillator digital input disable: 0=digital input enable, 1=digital input disable
        pub type PIN_XT32K_IE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PIN_ADC2_3_IE` reader - RW, ADC/TouchKey channel 2/3 digital input disable: 0=digital input enable, 1=digital input disable
        pub type PIN_ADC2_3_IE_R = crate::BitReader;
        ///Field `PIN_ADC2_3_IE` writer - RW, ADC/TouchKey channel 2/3 digital input disable: 0=digital input enable, 1=digital input disable
        pub type PIN_ADC2_3_IE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PIN_ADC4_5_IE` reader - RW, ADC/TouchKey channel 4/5 digital input disable: 0=digital input enable, 1=digital input disable
        pub type PIN_ADC4_5_IE_R = crate::BitReader;
        ///Field `PIN_ADC4_5_IE` writer - RW, ADC/TouchKey channel 4/5 digital input disable: 0=digital input enable, 1=digital input disable
        pub type PIN_ADC4_5_IE_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - RW, ADC/TouchKey channel 9/8 digital input disable
            #[inline(always)]
            pub fn pin_adc8_9_ie(&self) -> PIN_ADC8_9_IE_R {
                PIN_ADC8_9_IE_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RW, ADC/TouchKey channel 7/6 digital input disable
            #[inline(always)]
            pub fn pin_adc6_7_ie(&self) -> PIN_ADC6_7_IE_R {
                PIN_ADC6_7_IE_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RW, ADC/TouchKey channel 10 digital input disable
            #[inline(always)]
            pub fn pin_adc10_ie(&self) -> PIN_ADC10_IE_R {
                PIN_ADC10_IE_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RW, ADC/TouchKey channel 11 digital input disable
            #[inline(always)]
            pub fn pin_adc11_ie(&self) -> PIN_ADC11_IE_R {
                PIN_ADC11_IE_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RW,USB2 UDP internal pullup resistance enable
            #[inline(always)]
            pub fn pin_usb2_dp_pu(&self) -> PIN_USB2_DP_PU_R {
                PIN_USB2_DP_PU_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - RW, USB analog I/O enable: 0=analog I/O disable, 1=analog I/O enable
            #[inline(always)]
            pub fn pin_usb2_ie(&self) -> PIN_USB2_IE_R {
                PIN_USB2_IE_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - RW,USB UDP internal pullup resistance enable
            #[inline(always)]
            pub fn pin_usb_dp_pu(&self) -> PIN_USB_DP_PU_R {
                PIN_USB_DP_PU_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - RW, USB analog I/O enable: 0=analog I/O disable, 1=analog I/O enable
            #[inline(always)]
            pub fn pin_usb_ie(&self) -> PIN_USB_IE_R {
                PIN_USB_IE_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bit 9 - RW, ADC/TouchKey channel0 digital input disable: 0=digital input enable, 1=digital input disable
            #[inline(always)]
            pub fn pin_adc0_ie(&self) -> PIN_ADC0_IE_R {
                PIN_ADC0_IE_R::new(((self.bits >> 9) & 1) != 0)
            }
            ///Bit 10 - RW, ADC/TouchKey channel1 digital input disable: 0=digital input enable, 1=digital input disable
            #[inline(always)]
            pub fn pin_adc1_ie(&self) -> PIN_ADC1_IE_R {
                PIN_ADC1_IE_R::new(((self.bits >> 10) & 1) != 0)
            }
            ///Bit 11 - RW, ADC/TouchKey channel12 digital input disable: 0=digital input enable, 1=digital input disable
            #[inline(always)]
            pub fn pin_adc12_ie(&self) -> PIN_ADC12_IE_R {
                PIN_ADC12_IE_R::new(((self.bits >> 11) & 1) != 0)
            }
            ///Bit 12 - RW, ADC/TouchKey channel13 digital input disable: 0=digital input enable, 1=digital input disable
            #[inline(always)]
            pub fn pin_adc13_ie(&self) -> PIN_ADC13_IE_R {
                PIN_ADC13_IE_R::new(((self.bits >> 12) & 1) != 0)
            }
            ///Bit 13 - RW, external 32KHz oscillator digital input disable: 0=digital input enable, 1=digital input disable
            #[inline(always)]
            pub fn pin_xt32k_ie(&self) -> PIN_XT32K_IE_R {
                PIN_XT32K_IE_R::new(((self.bits >> 13) & 1) != 0)
            }
            ///Bit 14 - RW, ADC/TouchKey channel 2/3 digital input disable: 0=digital input enable, 1=digital input disable
            #[inline(always)]
            pub fn pin_adc2_3_ie(&self) -> PIN_ADC2_3_IE_R {
                PIN_ADC2_3_IE_R::new(((self.bits >> 14) & 1) != 0)
            }
            ///Bit 15 - RW, ADC/TouchKey channel 4/5 digital input disable: 0=digital input enable, 1=digital input disable
            #[inline(always)]
            pub fn pin_adc4_5_ie(&self) -> PIN_ADC4_5_IE_R {
                PIN_ADC4_5_IE_R::new(((self.bits >> 15) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RW, ADC/TouchKey channel 9/8 digital input disable
            #[inline(always)]
            #[must_use]
            pub fn pin_adc8_9_ie(&mut self) -> PIN_ADC8_9_IE_W<PIN_ANALOG_IE_SPEC> {
                PIN_ADC8_9_IE_W::new(self, 0)
            }
            ///Bit 1 - RW, ADC/TouchKey channel 7/6 digital input disable
            #[inline(always)]
            #[must_use]
            pub fn pin_adc6_7_ie(&mut self) -> PIN_ADC6_7_IE_W<PIN_ANALOG_IE_SPEC> {
                PIN_ADC6_7_IE_W::new(self, 1)
            }
            ///Bit 2 - RW, ADC/TouchKey channel 10 digital input disable
            #[inline(always)]
            #[must_use]
            pub fn pin_adc10_ie(&mut self) -> PIN_ADC10_IE_W<PIN_ANALOG_IE_SPEC> {
                PIN_ADC10_IE_W::new(self, 2)
            }
            ///Bit 3 - RW, ADC/TouchKey channel 11 digital input disable
            #[inline(always)]
            #[must_use]
            pub fn pin_adc11_ie(&mut self) -> PIN_ADC11_IE_W<PIN_ANALOG_IE_SPEC> {
                PIN_ADC11_IE_W::new(self, 3)
            }
            ///Bit 4 - RW,USB2 UDP internal pullup resistance enable
            #[inline(always)]
            #[must_use]
            pub fn pin_usb2_dp_pu(&mut self) -> PIN_USB2_DP_PU_W<PIN_ANALOG_IE_SPEC> {
                PIN_USB2_DP_PU_W::new(self, 4)
            }
            ///Bit 5 - RW, USB analog I/O enable: 0=analog I/O disable, 1=analog I/O enable
            #[inline(always)]
            #[must_use]
            pub fn pin_usb2_ie(&mut self) -> PIN_USB2_IE_W<PIN_ANALOG_IE_SPEC> {
                PIN_USB2_IE_W::new(self, 5)
            }
            ///Bit 6 - RW,USB UDP internal pullup resistance enable
            #[inline(always)]
            #[must_use]
            pub fn pin_usb_dp_pu(&mut self) -> PIN_USB_DP_PU_W<PIN_ANALOG_IE_SPEC> {
                PIN_USB_DP_PU_W::new(self, 6)
            }
            ///Bit 7 - RW, USB analog I/O enable: 0=analog I/O disable, 1=analog I/O enable
            #[inline(always)]
            #[must_use]
            pub fn pin_usb_ie(&mut self) -> PIN_USB_IE_W<PIN_ANALOG_IE_SPEC> {
                PIN_USB_IE_W::new(self, 7)
            }
            ///Bit 9 - RW, ADC/TouchKey channel0 digital input disable: 0=digital input enable, 1=digital input disable
            #[inline(always)]
            #[must_use]
            pub fn pin_adc0_ie(&mut self) -> PIN_ADC0_IE_W<PIN_ANALOG_IE_SPEC> {
                PIN_ADC0_IE_W::new(self, 9)
            }
            ///Bit 10 - RW, ADC/TouchKey channel1 digital input disable: 0=digital input enable, 1=digital input disable
            #[inline(always)]
            #[must_use]
            pub fn pin_adc1_ie(&mut self) -> PIN_ADC1_IE_W<PIN_ANALOG_IE_SPEC> {
                PIN_ADC1_IE_W::new(self, 10)
            }
            ///Bit 11 - RW, ADC/TouchKey channel12 digital input disable: 0=digital input enable, 1=digital input disable
            #[inline(always)]
            #[must_use]
            pub fn pin_adc12_ie(&mut self) -> PIN_ADC12_IE_W<PIN_ANALOG_IE_SPEC> {
                PIN_ADC12_IE_W::new(self, 11)
            }
            ///Bit 12 - RW, ADC/TouchKey channel13 digital input disable: 0=digital input enable, 1=digital input disable
            #[inline(always)]
            #[must_use]
            pub fn pin_adc13_ie(&mut self) -> PIN_ADC13_IE_W<PIN_ANALOG_IE_SPEC> {
                PIN_ADC13_IE_W::new(self, 12)
            }
            ///Bit 13 - RW, external 32KHz oscillator digital input disable: 0=digital input enable, 1=digital input disable
            #[inline(always)]
            #[must_use]
            pub fn pin_xt32k_ie(&mut self) -> PIN_XT32K_IE_W<PIN_ANALOG_IE_SPEC> {
                PIN_XT32K_IE_W::new(self, 13)
            }
            ///Bit 14 - RW, ADC/TouchKey channel 2/3 digital input disable: 0=digital input enable, 1=digital input disable
            #[inline(always)]
            #[must_use]
            pub fn pin_adc2_3_ie(&mut self) -> PIN_ADC2_3_IE_W<PIN_ANALOG_IE_SPEC> {
                PIN_ADC2_3_IE_W::new(self, 14)
            }
            ///Bit 15 - RW, ADC/TouchKey channel 4/5 digital input disable: 0=digital input enable, 1=digital input disable
            #[inline(always)]
            #[must_use]
            pub fn pin_adc4_5_ie(&mut self) -> PIN_ADC4_5_IE_W<PIN_ANALOG_IE_SPEC> {
                PIN_ADC4_5_IE_W::new(self, 15)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW, analog pin enable and digital input disable
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`pin_analog_ie::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pin_analog_ie::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct PIN_ANALOG_IE_SPEC;
        impl crate::RegisterSpec for PIN_ANALOG_IE_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`pin_analog_ie::R`](R) reader structure
        impl crate::Readable for PIN_ANALOG_IE_SPEC {}
        ///`write(|w| ..)` method takes [`pin_analog_ie::W`](W) writer structure
        impl crate::Writable for PIN_ANALOG_IE_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets PIN_ANALOG_IE to value 0
        impl crate::Resettable for PIN_ANALOG_IE_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///POWER_PLAN (rw) register accessor: RWA, power plan before sleep instruction, SAM
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`power_plan::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`power_plan::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@power_plan`]
    ///module
    pub type POWER_PLAN = crate::Reg<power_plan::POWER_PLAN_SPEC>;
    ///RWA, power plan before sleep instruction, SAM
    pub mod power_plan {
        ///Register `POWER_PLAN` reader
        pub type R = crate::R<POWER_PLAN_SPEC>;
        ///Register `POWER_PLAN` writer
        pub type W = crate::W<POWER_PLAN_SPEC>;
        ///Field `PWR_XROM` reader - RWA, power for retention 2KB SRAM
        pub type PWR_XROM_R = crate::BitReader;
        ///Field `PWR_XROM` writer - RWA, power for retention 2KB SRAM
        pub type PWR_XROM_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PWR_RAM2K` reader - RWA, power for retention 2KB SRAM
        pub type PWR_RAM2K_R = crate::BitReader;
        ///Field `PWR_RAM2K` writer - RWA, power for retention 2KB SRAM
        pub type PWR_RAM2K_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PWR_CORE` reader - RWA, power retention for core and base peripherals
        pub type PWR_CORE_R = crate::BitReader;
        ///Field `PWR_CORE` writer - RWA, power retention for core and base peripherals
        pub type PWR_CORE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PWR_EXTEND` reader - RWA, power retention for USB and BLE
        pub type PWR_EXTEND_R = crate::BitReader;
        ///Field `PWR_EXTEND` writer - RWA, power retention for USB and BLE
        pub type PWR_EXTEND_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PWR_RAM30K` reader - RWA, power for main SRAM
        pub type PWR_RAM30K_R = crate::BitReader;
        ///Field `PWR_RAM30K` writer - RWA, power for main SRAM
        pub type PWR_RAM30K_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PWR_SYS_EN` reader - RWA, power for system
        pub type PWR_SYS_EN_R = crate::BitReader;
        ///Field `PWR_SYS_EN` writer - RWA, power for system
        pub type PWR_SYS_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PWR_DCDC_EN` reader - RWA, DC/DC converter enable: 0=DC/DC disable and bypass, 1=DC/DC enable
        pub type PWR_DCDC_EN_R = crate::BitReader;
        ///Field `PWR_DCDC_EN` writer - RWA, DC/DC converter enable: 0=DC/DC disable and bypass, 1=DC/DC enable
        pub type PWR_DCDC_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PWR_DCDC_PRE` reader - RWA, DC/DC converter pre-enable
        pub type PWR_DCDC_PRE_R = crate::BitReader;
        ///Field `PWR_DCDC_PRE` writer - RWA, DC/DC converter pre-enable
        pub type PWR_DCDC_PRE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PWR_MUST_0010` reader - RWA, power plan enable, auto clear after sleep executed
        pub type PWR_MUST_0010_R = crate::FieldReader;
        ///Field `PWR_PLAN_EN` reader - RWA, must write 0010
        pub type PWR_PLAN_EN_R = crate::BitReader;
        impl R {
            ///Bit 0 - RWA, power for retention 2KB SRAM
            #[inline(always)]
            pub fn pwr_xrom(&self) -> PWR_XROM_R {
                PWR_XROM_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RWA, power for retention 2KB SRAM
            #[inline(always)]
            pub fn pwr_ram2k(&self) -> PWR_RAM2K_R {
                PWR_RAM2K_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RWA, power retention for core and base peripherals
            #[inline(always)]
            pub fn pwr_core(&self) -> PWR_CORE_R {
                PWR_CORE_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RWA, power retention for USB and BLE
            #[inline(always)]
            pub fn pwr_extend(&self) -> PWR_EXTEND_R {
                PWR_EXTEND_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RWA, power for main SRAM
            #[inline(always)]
            pub fn pwr_ram30k(&self) -> PWR_RAM30K_R {
                PWR_RAM30K_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 7 - RWA, power for system
            #[inline(always)]
            pub fn pwr_sys_en(&self) -> PWR_SYS_EN_R {
                PWR_SYS_EN_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bit 9 - RWA, DC/DC converter enable: 0=DC/DC disable and bypass, 1=DC/DC enable
            #[inline(always)]
            pub fn pwr_dcdc_en(&self) -> PWR_DCDC_EN_R {
                PWR_DCDC_EN_R::new(((self.bits >> 9) & 1) != 0)
            }
            ///Bit 10 - RWA, DC/DC converter pre-enable
            #[inline(always)]
            pub fn pwr_dcdc_pre(&self) -> PWR_DCDC_PRE_R {
                PWR_DCDC_PRE_R::new(((self.bits >> 10) & 1) != 0)
            }
            ///Bits 11:14 - RWA, power plan enable, auto clear after sleep executed
            #[inline(always)]
            pub fn pwr_must_0010(&self) -> PWR_MUST_0010_R {
                PWR_MUST_0010_R::new(((self.bits >> 11) & 0x0f) as u8)
            }
            ///Bit 15 - RWA, must write 0010
            #[inline(always)]
            pub fn pwr_plan_en(&self) -> PWR_PLAN_EN_R {
                PWR_PLAN_EN_R::new(((self.bits >> 15) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RWA, power for retention 2KB SRAM
            #[inline(always)]
            #[must_use]
            pub fn pwr_xrom(&mut self) -> PWR_XROM_W<POWER_PLAN_SPEC> {
                PWR_XROM_W::new(self, 0)
            }
            ///Bit 1 - RWA, power for retention 2KB SRAM
            #[inline(always)]
            #[must_use]
            pub fn pwr_ram2k(&mut self) -> PWR_RAM2K_W<POWER_PLAN_SPEC> {
                PWR_RAM2K_W::new(self, 1)
            }
            ///Bit 2 - RWA, power retention for core and base peripherals
            #[inline(always)]
            #[must_use]
            pub fn pwr_core(&mut self) -> PWR_CORE_W<POWER_PLAN_SPEC> {
                PWR_CORE_W::new(self, 2)
            }
            ///Bit 3 - RWA, power retention for USB and BLE
            #[inline(always)]
            #[must_use]
            pub fn pwr_extend(&mut self) -> PWR_EXTEND_W<POWER_PLAN_SPEC> {
                PWR_EXTEND_W::new(self, 3)
            }
            ///Bit 4 - RWA, power for main SRAM
            #[inline(always)]
            #[must_use]
            pub fn pwr_ram30k(&mut self) -> PWR_RAM30K_W<POWER_PLAN_SPEC> {
                PWR_RAM30K_W::new(self, 4)
            }
            ///Bit 7 - RWA, power for system
            #[inline(always)]
            #[must_use]
            pub fn pwr_sys_en(&mut self) -> PWR_SYS_EN_W<POWER_PLAN_SPEC> {
                PWR_SYS_EN_W::new(self, 7)
            }
            ///Bit 9 - RWA, DC/DC converter enable: 0=DC/DC disable and bypass, 1=DC/DC enable
            #[inline(always)]
            #[must_use]
            pub fn pwr_dcdc_en(&mut self) -> PWR_DCDC_EN_W<POWER_PLAN_SPEC> {
                PWR_DCDC_EN_W::new(self, 9)
            }
            ///Bit 10 - RWA, DC/DC converter pre-enable
            #[inline(always)]
            #[must_use]
            pub fn pwr_dcdc_pre(&mut self) -> PWR_DCDC_PRE_W<POWER_PLAN_SPEC> {
                PWR_DCDC_PRE_W::new(self, 10)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RWA, power plan before sleep instruction, SAM
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`power_plan::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`power_plan::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct POWER_PLAN_SPEC;
        impl crate::RegisterSpec for POWER_PLAN_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`power_plan::R`](R) reader structure
        impl crate::Readable for POWER_PLAN_SPEC {}
        ///`write(|w| ..)` method takes [`power_plan::W`](W) writer structure
        impl crate::Writable for POWER_PLAN_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets POWER_PLAN to value 0x11df
        impl crate::Resettable for POWER_PLAN_SPEC {
            const RESET_VALUE: u16 = 0x11df;
        }
    }
    ///AUX_POWER_ADJ (rw) register accessor: RWA, aux power adjust control, SAM
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`aux_power_adj::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`aux_power_adj::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@aux_power_adj`]
    ///module
    pub type AUX_POWER_ADJ = crate::Reg<aux_power_adj::AUX_POWER_ADJ_SPEC>;
    ///RWA, aux power adjust control, SAM
    pub mod aux_power_adj {
        ///Register `AUX_POWER_ADJ` reader
        pub type R = crate::R<AUX_POWER_ADJ_SPEC>;
        ///Register `AUX_POWER_ADJ` writer
        pub type W = crate::W<AUX_POWER_ADJ_SPEC>;
        ///Field `ULPLDO_ADJ` reader - RWA, Ultra-Low-Power LDO voltage adjust
        pub type ULPLDO_ADJ_R = crate::FieldReader;
        ///Field `ULPLDO_ADJ` writer - RWA, Ultra-Low-Power LDO voltage adjust
        pub type ULPLDO_ADJ_W<'a, REG> = crate::FieldWriter<'a, REG, 3>;
        ///Field `DCDC_CHARGE` reader - RWA, Ultra-Low-Power LDO voltage adjust
        pub type DCDC_CHARGE_R = crate::BitReader;
        ///Field `DCDC_CHARGE` writer - RWA, Ultra-Low-Power LDO voltage adjust
        pub type DCDC_CHARGE_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bits 0:2 - RWA, Ultra-Low-Power LDO voltage adjust
            #[inline(always)]
            pub fn ulpldo_adj(&self) -> ULPLDO_ADJ_R {
                ULPLDO_ADJ_R::new(self.bits & 7)
            }
            ///Bit 7 - RWA, Ultra-Low-Power LDO voltage adjust
            #[inline(always)]
            pub fn dcdc_charge(&self) -> DCDC_CHARGE_R {
                DCDC_CHARGE_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:2 - RWA, Ultra-Low-Power LDO voltage adjust
            #[inline(always)]
            #[must_use]
            pub fn ulpldo_adj(&mut self) -> ULPLDO_ADJ_W<AUX_POWER_ADJ_SPEC> {
                ULPLDO_ADJ_W::new(self, 0)
            }
            ///Bit 7 - RWA, Ultra-Low-Power LDO voltage adjust
            #[inline(always)]
            #[must_use]
            pub fn dcdc_charge(&mut self) -> DCDC_CHARGE_W<AUX_POWER_ADJ_SPEC> {
                DCDC_CHARGE_W::new(self, 7)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RWA, aux power adjust control, SAM
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`aux_power_adj::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`aux_power_adj::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct AUX_POWER_ADJ_SPEC;
        impl crate::RegisterSpec for AUX_POWER_ADJ_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`aux_power_adj::R`](R) reader structure
        impl crate::Readable for AUX_POWER_ADJ_SPEC {}
        ///`write(|w| ..)` method takes [`aux_power_adj::W`](W) writer structure
        impl crate::Writable for AUX_POWER_ADJ_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets AUX_POWER_ADJ to value 0
        impl crate::Resettable for AUX_POWER_ADJ_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///BAT_DET_CTRL (rw) register accessor: RWA, battery voltage detector control, SAM
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`bat_det_ctrl::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`bat_det_ctrl::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@bat_det_ctrl`]
    ///module
    pub type BAT_DET_CTRL = crate::Reg<bat_det_ctrl::BAT_DET_CTRL_SPEC>;
    ///RWA, battery voltage detector control, SAM
    pub mod bat_det_ctrl {
        ///Register `BAT_DET_CTRL` reader
        pub type R = crate::R<BAT_DET_CTRL_SPEC>;
        ///Register `BAT_DET_CTRL` writer
        pub type W = crate::W<BAT_DET_CTRL_SPEC>;
        ///Field `BAT_DET_EN__RB_BAT_LOW_VTHX` reader - RWA, battery voltage detector enable/select monitor threshold voltage
        pub type BAT_DET_EN__RB_BAT_LOW_VTHX_R = crate::BitReader;
        ///Field `BAT_DET_EN__RB_BAT_LOW_VTHX` writer - RWA, battery voltage detector enable/select monitor threshold voltage
        pub type BAT_DET_EN__RB_BAT_LOW_VTHX_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `BAT_MON_EN` reader - RWA, battery voltage monitor enable under sleep mode
        pub type BAT_MON_EN_R = crate::BitReader;
        ///Field `BAT_MON_EN` writer - RWA, battery voltage monitor enable under sleep mode
        pub type BAT_MON_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `BAT_LOWER_IE` reader - RWA, interrupt enable for battery lower voltage
        pub type BAT_LOWER_IE_R = crate::BitReader;
        ///Field `BAT_LOWER_IE` writer - RWA, interrupt enable for battery lower voltage
        pub type BAT_LOWER_IE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `BAT_LOW_IE` reader - RWA, interrupt enable for battery low voltage
        pub type BAT_LOW_IE_R = crate::BitReader;
        ///Field `BAT_LOW_IE` writer - RWA, interrupt enable for battery low voltage
        pub type BAT_LOW_IE_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - RWA, battery voltage detector enable/select monitor threshold voltage
            #[inline(always)]
            pub fn bat_det_en__rb_bat_low_vthx(&self) -> BAT_DET_EN__RB_BAT_LOW_VTHX_R {
                BAT_DET_EN__RB_BAT_LOW_VTHX_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RWA, battery voltage monitor enable under sleep mode
            #[inline(always)]
            pub fn bat_mon_en(&self) -> BAT_MON_EN_R {
                BAT_MON_EN_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RWA, interrupt enable for battery lower voltage
            #[inline(always)]
            pub fn bat_lower_ie(&self) -> BAT_LOWER_IE_R {
                BAT_LOWER_IE_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RWA, interrupt enable for battery low voltage
            #[inline(always)]
            pub fn bat_low_ie(&self) -> BAT_LOW_IE_R {
                BAT_LOW_IE_R::new(((self.bits >> 3) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RWA, battery voltage detector enable/select monitor threshold voltage
            #[inline(always)]
            #[must_use]
            pub fn bat_det_en__rb_bat_low_vthx(
                &mut self,
            ) -> BAT_DET_EN__RB_BAT_LOW_VTHX_W<BAT_DET_CTRL_SPEC> {
                BAT_DET_EN__RB_BAT_LOW_VTHX_W::new(self, 0)
            }
            ///Bit 1 - RWA, battery voltage monitor enable under sleep mode
            #[inline(always)]
            #[must_use]
            pub fn bat_mon_en(&mut self) -> BAT_MON_EN_W<BAT_DET_CTRL_SPEC> {
                BAT_MON_EN_W::new(self, 1)
            }
            ///Bit 2 - RWA, interrupt enable for battery lower voltage
            #[inline(always)]
            #[must_use]
            pub fn bat_lower_ie(&mut self) -> BAT_LOWER_IE_W<BAT_DET_CTRL_SPEC> {
                BAT_LOWER_IE_W::new(self, 2)
            }
            ///Bit 3 - RWA, interrupt enable for battery low voltage
            #[inline(always)]
            #[must_use]
            pub fn bat_low_ie(&mut self) -> BAT_LOW_IE_W<BAT_DET_CTRL_SPEC> {
                BAT_LOW_IE_W::new(self, 3)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RWA, battery voltage detector control, SAM
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`bat_det_ctrl::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`bat_det_ctrl::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct BAT_DET_CTRL_SPEC;
        impl crate::RegisterSpec for BAT_DET_CTRL_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`bat_det_ctrl::R`](R) reader structure
        impl crate::Readable for BAT_DET_CTRL_SPEC {}
        ///`write(|w| ..)` method takes [`bat_det_ctrl::W`](W) writer structure
        impl crate::Writable for BAT_DET_CTRL_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets BAT_DET_CTRL to value 0
        impl crate::Resettable for BAT_DET_CTRL_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///BAT_DET_CFG (rw) register accessor: RWA, battery voltage detector configuration, SAM
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`bat_det_cfg::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`bat_det_cfg::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@bat_det_cfg`]
    ///module
    pub type BAT_DET_CFG = crate::Reg<bat_det_cfg::BAT_DET_CFG_SPEC>;
    ///RWA, battery voltage detector configuration, SAM
    pub mod bat_det_cfg {
        ///Register `BAT_DET_CFG` reader
        pub type R = crate::R<BAT_DET_CFG_SPEC>;
        ///Register `BAT_DET_CFG` writer
        pub type W = crate::W<BAT_DET_CFG_SPEC>;
        ///Field `BAT_LOW_VTH` reader - RWA, select threshold voltage of battery voltage low
        pub type BAT_LOW_VTH_R = crate::FieldReader;
        ///Field `BAT_LOW_VTH` writer - RWA, select threshold voltage of battery voltage low
        pub type BAT_LOW_VTH_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        impl R {
            ///Bits 0:1 - RWA, select threshold voltage of battery voltage low
            #[inline(always)]
            pub fn bat_low_vth(&self) -> BAT_LOW_VTH_R {
                BAT_LOW_VTH_R::new(self.bits & 3)
            }
        }
        impl W {
            ///Bits 0:1 - RWA, select threshold voltage of battery voltage low
            #[inline(always)]
            #[must_use]
            pub fn bat_low_vth(&mut self) -> BAT_LOW_VTH_W<BAT_DET_CFG_SPEC> {
                BAT_LOW_VTH_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RWA, battery voltage detector configuration, SAM
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`bat_det_cfg::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`bat_det_cfg::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct BAT_DET_CFG_SPEC;
        impl crate::RegisterSpec for BAT_DET_CFG_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`bat_det_cfg::R`](R) reader structure
        impl crate::Readable for BAT_DET_CFG_SPEC {}
        ///`write(|w| ..)` method takes [`bat_det_cfg::W`](W) writer structure
        impl crate::Writable for BAT_DET_CFG_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets BAT_DET_CFG to value 0x01
        impl crate::Resettable for BAT_DET_CFG_SPEC {
            const RESET_VALUE: u8 = 0x01;
        }
    }
    ///BAT_STATUS (r) register accessor: RO, battery status
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`bat_status::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@bat_status`]
    ///module
    pub type BAT_STATUS = crate::Reg<bat_status::BAT_STATUS_SPEC>;
    ///RO, battery status
    pub mod bat_status {
        ///Register `BAT_STATUS` reader
        pub type R = crate::R<BAT_STATUS_SPEC>;
        ///Field `BAT_STAT_LOWER` reader - RO, battery lower voltage status, high action
        pub type BAT_STAT_LOWER_R = crate::BitReader;
        ///Field `BAT_STAT_LOW` reader - RO, battery low voltage status, high action
        pub type BAT_STAT_LOW_R = crate::BitReader;
        impl R {
            ///Bit 0 - RO, battery lower voltage status, high action
            #[inline(always)]
            pub fn bat_stat_lower(&self) -> BAT_STAT_LOWER_R {
                BAT_STAT_LOWER_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RO, battery low voltage status, high action
            #[inline(always)]
            pub fn bat_stat_low(&self) -> BAT_STAT_LOW_R {
                BAT_STAT_LOW_R::new(((self.bits >> 1) & 1) != 0)
            }
        }
        ///RO, battery status
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`bat_status::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct BAT_STATUS_SPEC;
        impl crate::RegisterSpec for BAT_STATUS_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`bat_status::R`](R) reader structure
        impl crate::Readable for BAT_STATUS_SPEC {}
        ///`reset()` method sets BAT_STATUS to value 0
        impl crate::Resettable for BAT_STATUS_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///INT32K_TUNE (rw) register accessor: RWA, internal 32KHz oscillator tune control, SAM
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`int32k_tune::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`int32k_tune::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@int32k_tune`]
    ///module
    pub type INT32K_TUNE = crate::Reg<int32k_tune::INT32K_TUNE_SPEC>;
    ///RWA, internal 32KHz oscillator tune control, SAM
    pub mod int32k_tune {
        ///Register `INT32K_TUNE` reader
        pub type R = crate::R<INT32K_TUNE_SPEC>;
        ///Register `INT32K_TUNE` writer
        pub type W = crate::W<INT32K_TUNE_SPEC>;
        ///Field `INT32K_TUNE` reader - RWA, internal 32KHz oscillator frequency tune
        pub type INT32K_TUNE_R = crate::FieldReader<u16>;
        ///Field `INT32K_TUNE` writer - RWA, internal 32KHz oscillator frequency tune
        pub type INT32K_TUNE_W<'a, REG> = crate::FieldWriter<'a, REG, 13, u16>;
        impl R {
            ///Bits 0:12 - RWA, internal 32KHz oscillator frequency tune
            #[inline(always)]
            pub fn int32k_tune(&self) -> INT32K_TUNE_R {
                INT32K_TUNE_R::new(self.bits & 0x1fff)
            }
        }
        impl W {
            ///Bits 0:12 - RWA, internal 32KHz oscillator frequency tune
            #[inline(always)]
            #[must_use]
            pub fn int32k_tune(&mut self) -> INT32K_TUNE_W<INT32K_TUNE_SPEC> {
                INT32K_TUNE_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RWA, internal 32KHz oscillator tune control, SAM
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`int32k_tune::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`int32k_tune::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct INT32K_TUNE_SPEC;
        impl crate::RegisterSpec for INT32K_TUNE_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`int32k_tune::R`](R) reader structure
        impl crate::Readable for INT32K_TUNE_SPEC {}
        ///`write(|w| ..)` method takes [`int32k_tune::W`](W) writer structure
        impl crate::Writable for INT32K_TUNE_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets INT32K_TUNE to value 0x1011
        impl crate::Resettable for INT32K_TUNE_SPEC {
            const RESET_VALUE: u16 = 0x1011;
        }
    }
    ///XT32K_TUNE (rw) register accessor: RWA, external 32KHz oscillator tune control, SAM
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`xt32k_tune::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`xt32k_tune::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@xt32k_tune`]
    ///module
    pub type XT32K_TUNE = crate::Reg<xt32k_tune::XT32K_TUNE_SPEC>;
    ///RWA, external 32KHz oscillator tune control, SAM
    pub mod xt32k_tune {
        ///Register `XT32K_TUNE` reader
        pub type R = crate::R<XT32K_TUNE_SPEC>;
        ///Register `XT32K_TUNE` writer
        pub type W = crate::W<XT32K_TUNE_SPEC>;
        ///Field `XT32K_I_TUNE` reader - RWA, external 32KHz oscillator current tune: 00=75% current, 01=standard current, 10=150% current, 11=200% current
        pub type XT32K_I_TUNE_R = crate::FieldReader;
        ///Field `XT32K_I_TUNE` writer - RWA, external 32KHz oscillator current tune: 00=75% current, 01=standard current, 10=150% current, 11=200% current
        pub type XT32K_I_TUNE_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `XT32K_C_LOAD` reader - RWA, external 32KHz oscillator load capacitor tune: Cap = RB_XT32K_C_LOAD + 12pF
        pub type XT32K_C_LOAD_R = crate::FieldReader;
        ///Field `XT32K_C_LOAD` writer - RWA, external 32KHz oscillator load capacitor tune: Cap = RB_XT32K_C_LOAD + 12pF
        pub type XT32K_C_LOAD_W<'a, REG> = crate::FieldWriter<'a, REG, 4>;
        impl R {
            ///Bits 0:1 - RWA, external 32KHz oscillator current tune: 00=75% current, 01=standard current, 10=150% current, 11=200% current
            #[inline(always)]
            pub fn xt32k_i_tune(&self) -> XT32K_I_TUNE_R {
                XT32K_I_TUNE_R::new(self.bits & 3)
            }
            ///Bits 4:7 - RWA, external 32KHz oscillator load capacitor tune: Cap = RB_XT32K_C_LOAD + 12pF
            #[inline(always)]
            pub fn xt32k_c_load(&self) -> XT32K_C_LOAD_R {
                XT32K_C_LOAD_R::new((self.bits >> 4) & 0x0f)
            }
        }
        impl W {
            ///Bits 0:1 - RWA, external 32KHz oscillator current tune: 00=75% current, 01=standard current, 10=150% current, 11=200% current
            #[inline(always)]
            #[must_use]
            pub fn xt32k_i_tune(&mut self) -> XT32K_I_TUNE_W<XT32K_TUNE_SPEC> {
                XT32K_I_TUNE_W::new(self, 0)
            }
            ///Bits 4:7 - RWA, external 32KHz oscillator load capacitor tune: Cap = RB_XT32K_C_LOAD + 12pF
            #[inline(always)]
            #[must_use]
            pub fn xt32k_c_load(&mut self) -> XT32K_C_LOAD_W<XT32K_TUNE_SPEC> {
                XT32K_C_LOAD_W::new(self, 4)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RWA, external 32KHz oscillator tune control, SAM
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`xt32k_tune::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`xt32k_tune::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct XT32K_TUNE_SPEC;
        impl crate::RegisterSpec for XT32K_TUNE_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`xt32k_tune::R`](R) reader structure
        impl crate::Readable for XT32K_TUNE_SPEC {}
        ///`write(|w| ..)` method takes [`xt32k_tune::W`](W) writer structure
        impl crate::Writable for XT32K_TUNE_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets XT32K_TUNE to value 0xc3
        impl crate::Resettable for XT32K_TUNE_SPEC {
            const RESET_VALUE: u8 = 0xc3;
        }
    }
    ///CK32K_CONFIG (rw) register accessor: RWA, 32KHz oscillator configure
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`ck32k_config::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ck32k_config::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@ck32k_config`]
    ///module
    pub type CK32K_CONFIG = crate::Reg<ck32k_config::CK32K_CONFIG_SPEC>;
    ///RWA, 32KHz oscillator configure
    pub mod ck32k_config {
        ///Register `CK32K_CONFIG` reader
        pub type R = crate::R<CK32K_CONFIG_SPEC>;
        ///Register `CK32K_CONFIG` writer
        pub type W = crate::W<CK32K_CONFIG_SPEC>;
        ///Field `CLK_XT32K_PON` reader - RWA, external 32KHz oscillator power on
        pub type CLK_XT32K_PON_R = crate::BitReader;
        ///Field `CLK_XT32K_PON` writer - RWA, external 32KHz oscillator power on
        pub type CLK_XT32K_PON_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CLK_INT32K_PON` reader - RWA, internal 32KHz oscillator power on
        pub type CLK_INT32K_PON_R = crate::BitReader;
        ///Field `CLK_INT32K_PON` writer - RWA, internal 32KHz oscillator power on
        pub type CLK_INT32K_PON_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CLK_OSC32K_XT` reader - RWA, 32KHz oscillator source selection: 0=RC, 1=XT
        pub type CLK_OSC32K_XT_R = crate::BitReader;
        ///Field `CLK_OSC32K_XT` writer - RWA, 32KHz oscillator source selection: 0=RC, 1=XT
        pub type CLK_OSC32K_XT_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CLK_OSC32K_FILT` reader - RWA, internal 32KHz oscillator low noise mode enable
        pub type CLK_OSC32K_FILT_R = crate::BitReader;
        ///Field `CLK_OSC32K_FILT` writer - RWA, internal 32KHz oscillator low noise mode enable
        pub type CLK_OSC32K_FILT_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `CLK_32K_PIN` reader - RO, 32KHz oscillator clock pin status
        pub type CLK_32K_PIN_R = crate::BitReader;
        impl R {
            ///Bit 0 - RWA, external 32KHz oscillator power on
            #[inline(always)]
            pub fn clk_xt32k_pon(&self) -> CLK_XT32K_PON_R {
                CLK_XT32K_PON_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RWA, internal 32KHz oscillator power on
            #[inline(always)]
            pub fn clk_int32k_pon(&self) -> CLK_INT32K_PON_R {
                CLK_INT32K_PON_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RWA, 32KHz oscillator source selection: 0=RC, 1=XT
            #[inline(always)]
            pub fn clk_osc32k_xt(&self) -> CLK_OSC32K_XT_R {
                CLK_OSC32K_XT_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RWA, internal 32KHz oscillator low noise mode enable
            #[inline(always)]
            pub fn clk_osc32k_filt(&self) -> CLK_OSC32K_FILT_R {
                CLK_OSC32K_FILT_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 7 - RO, 32KHz oscillator clock pin status
            #[inline(always)]
            pub fn clk_32k_pin(&self) -> CLK_32K_PIN_R {
                CLK_32K_PIN_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RWA, external 32KHz oscillator power on
            #[inline(always)]
            #[must_use]
            pub fn clk_xt32k_pon(&mut self) -> CLK_XT32K_PON_W<CK32K_CONFIG_SPEC> {
                CLK_XT32K_PON_W::new(self, 0)
            }
            ///Bit 1 - RWA, internal 32KHz oscillator power on
            #[inline(always)]
            #[must_use]
            pub fn clk_int32k_pon(&mut self) -> CLK_INT32K_PON_W<CK32K_CONFIG_SPEC> {
                CLK_INT32K_PON_W::new(self, 1)
            }
            ///Bit 2 - RWA, 32KHz oscillator source selection: 0=RC, 1=XT
            #[inline(always)]
            #[must_use]
            pub fn clk_osc32k_xt(&mut self) -> CLK_OSC32K_XT_W<CK32K_CONFIG_SPEC> {
                CLK_OSC32K_XT_W::new(self, 2)
            }
            ///Bit 3 - RWA, internal 32KHz oscillator low noise mode enable
            #[inline(always)]
            #[must_use]
            pub fn clk_osc32k_filt(&mut self) -> CLK_OSC32K_FILT_W<CK32K_CONFIG_SPEC> {
                CLK_OSC32K_FILT_W::new(self, 3)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RWA, 32KHz oscillator configure
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`ck32k_config::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ck32k_config::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct CK32K_CONFIG_SPEC;
        impl crate::RegisterSpec for CK32K_CONFIG_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`ck32k_config::R`](R) reader structure
        impl crate::Readable for CK32K_CONFIG_SPEC {}
        ///`write(|w| ..)` method takes [`ck32k_config::W`](W) writer structure
        impl crate::Writable for CK32K_CONFIG_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets CK32K_CONFIG to value 0x02
        impl crate::Resettable for CK32K_CONFIG_SPEC {
            const RESET_VALUE: u8 = 0x02;
        }
    }
    ///RTC_FLAG_CTRL (rw) register accessor: RW, RTC flag and clear control
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`rtc_flag_ctrl::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`rtc_flag_ctrl::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@rtc_flag_ctrl`]
    ///module
    pub type RTC_FLAG_CTRL = crate::Reg<rtc_flag_ctrl::RTC_FLAG_CTRL_SPEC>;
    ///RW, RTC flag and clear control
    pub mod rtc_flag_ctrl {
        ///Register `RTC_FLAG_CTRL` reader
        pub type R = crate::R<RTC_FLAG_CTRL_SPEC>;
        ///Register `RTC_FLAG_CTRL` writer
        pub type W = crate::W<RTC_FLAG_CTRL_SPEC>;
        ///Field `RTC_TMR_CLR` reader - RW, set 1 to clear RTC timer action flag, auto clear
        pub type RTC_TMR_CLR_R = crate::BitReader;
        ///Field `RTC_TMR_CLR` writer - RW, set 1 to clear RTC timer action flag, auto clear
        pub type RTC_TMR_CLR_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `RTC_TRIG_CLR` reader - RW, set 1 to clear RTC trigger action flag, auto clear
        pub type RTC_TRIG_CLR_R = crate::BitReader;
        ///Field `RTC_TRIG_CLR` writer - RW, set 1 to clear RTC trigger action flag, auto clear
        pub type RTC_TRIG_CLR_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `RTC_TMR_FLAG` reader - RO, RTC timer action flag
        pub type RTC_TMR_FLAG_R = crate::BitReader;
        ///Field `RTC_TRIG_FLAG` reader - RO, RTC trigger action flag
        pub type RTC_TRIG_FLAG_R = crate::BitReader;
        impl R {
            ///Bit 4 - RW, set 1 to clear RTC timer action flag, auto clear
            #[inline(always)]
            pub fn rtc_tmr_clr(&self) -> RTC_TMR_CLR_R {
                RTC_TMR_CLR_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - RW, set 1 to clear RTC trigger action flag, auto clear
            #[inline(always)]
            pub fn rtc_trig_clr(&self) -> RTC_TRIG_CLR_R {
                RTC_TRIG_CLR_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - RO, RTC timer action flag
            #[inline(always)]
            pub fn rtc_tmr_flag(&self) -> RTC_TMR_FLAG_R {
                RTC_TMR_FLAG_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - RO, RTC trigger action flag
            #[inline(always)]
            pub fn rtc_trig_flag(&self) -> RTC_TRIG_FLAG_R {
                RTC_TRIG_FLAG_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 4 - RW, set 1 to clear RTC timer action flag, auto clear
            #[inline(always)]
            #[must_use]
            pub fn rtc_tmr_clr(&mut self) -> RTC_TMR_CLR_W<RTC_FLAG_CTRL_SPEC> {
                RTC_TMR_CLR_W::new(self, 4)
            }
            ///Bit 5 - RW, set 1 to clear RTC trigger action flag, auto clear
            #[inline(always)]
            #[must_use]
            pub fn rtc_trig_clr(&mut self) -> RTC_TRIG_CLR_W<RTC_FLAG_CTRL_SPEC> {
                RTC_TRIG_CLR_W::new(self, 5)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW, RTC flag and clear control
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`rtc_flag_ctrl::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`rtc_flag_ctrl::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct RTC_FLAG_CTRL_SPEC;
        impl crate::RegisterSpec for RTC_FLAG_CTRL_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`rtc_flag_ctrl::R`](R) reader structure
        impl crate::Readable for RTC_FLAG_CTRL_SPEC {}
        ///`write(|w| ..)` method takes [`rtc_flag_ctrl::W`](W) writer structure
        impl crate::Writable for RTC_FLAG_CTRL_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets RTC_FLAG_CTRL to value 0x30
        impl crate::Resettable for RTC_FLAG_CTRL_SPEC {
            const RESET_VALUE: u8 = 0x30;
        }
    }
    ///RTC_MODE_CTRL (rw) register accessor: RWA, RTC mode control, SAM
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`rtc_mode_ctrl::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`rtc_mode_ctrl::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@rtc_mode_ctrl`]
    ///module
    pub type RTC_MODE_CTRL = crate::Reg<rtc_mode_ctrl::RTC_MODE_CTRL_SPEC>;
    ///RWA, RTC mode control, SAM
    pub mod rtc_mode_ctrl {
        ///Register `RTC_MODE_CTRL` reader
        pub type R = crate::R<RTC_MODE_CTRL_SPEC>;
        ///Register `RTC_MODE_CTRL` writer
        pub type W = crate::W<RTC_MODE_CTRL_SPEC>;
        ///Field `RTC_TMR_MODE` reader - RWA, RTC timer mode: 000=0.125S, 001=0.25S, 010=0.5S, 011=1S, 100=2S, 101=4S, 110=8S, 111=16S
        pub type RTC_TMR_MODE_R = crate::FieldReader;
        ///Field `RTC_TMR_MODE` writer - RWA, RTC timer mode: 000=0.125S, 001=0.25S, 010=0.5S, 011=1S, 100=2S, 101=4S, 110=8S, 111=16S
        pub type RTC_TMR_MODE_W<'a, REG> = crate::FieldWriter<'a, REG, 3>;
        ///Field `RTC_IGNORE_B0` reader - RWA, force ignore bit0 for trigger mode: 0=compare bit0, 1=ignore bit0
        pub type RTC_IGNORE_B0_R = crate::BitReader;
        ///Field `RTC_IGNORE_B0` writer - RWA, force ignore bit0 for trigger mode: 0=compare bit0, 1=ignore bit0
        pub type RTC_IGNORE_B0_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `RTC_TMR_EN` reader - RWA, RTC timer mode enable
        pub type RTC_TMR_EN_R = crate::BitReader;
        ///Field `RTC_TMR_EN` writer - RWA, RTC timer mode enable
        pub type RTC_TMR_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `RTC_TRIG_EN` reader - RWA, RTC trigger mode enable
        pub type RTC_TRIG_EN_R = crate::BitReader;
        ///Field `RTC_TRIG_EN` writer - RWA, RTC trigger mode enable
        pub type RTC_TRIG_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `RTC_LOAD_LO` reader - RWA, set 1 to load RTC count low word R32_RTC_CNT_32K, auto clear after loaded
        pub type RTC_LOAD_LO_R = crate::BitReader;
        ///Field `RTC_LOAD_LO` writer - RWA, set 1 to load RTC count low word R32_RTC_CNT_32K, auto clear after loaded
        pub type RTC_LOAD_LO_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `RTC_LOAD_HI` reader - RWA, set 1 to load RTC count high word R32_RTC_CNT_DAY, auto clear after loaded
        pub type RTC_LOAD_HI_R = crate::BitReader;
        ///Field `RTC_LOAD_HI` writer - RWA, set 1 to load RTC count high word R32_RTC_CNT_DAY, auto clear after loaded
        pub type RTC_LOAD_HI_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bits 0:2 - RWA, RTC timer mode: 000=0.125S, 001=0.25S, 010=0.5S, 011=1S, 100=2S, 101=4S, 110=8S, 111=16S
            #[inline(always)]
            pub fn rtc_tmr_mode(&self) -> RTC_TMR_MODE_R {
                RTC_TMR_MODE_R::new(self.bits & 7)
            }
            ///Bit 3 - RWA, force ignore bit0 for trigger mode: 0=compare bit0, 1=ignore bit0
            #[inline(always)]
            pub fn rtc_ignore_b0(&self) -> RTC_IGNORE_B0_R {
                RTC_IGNORE_B0_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RWA, RTC timer mode enable
            #[inline(always)]
            pub fn rtc_tmr_en(&self) -> RTC_TMR_EN_R {
                RTC_TMR_EN_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - RWA, RTC trigger mode enable
            #[inline(always)]
            pub fn rtc_trig_en(&self) -> RTC_TRIG_EN_R {
                RTC_TRIG_EN_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - RWA, set 1 to load RTC count low word R32_RTC_CNT_32K, auto clear after loaded
            #[inline(always)]
            pub fn rtc_load_lo(&self) -> RTC_LOAD_LO_R {
                RTC_LOAD_LO_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - RWA, set 1 to load RTC count high word R32_RTC_CNT_DAY, auto clear after loaded
            #[inline(always)]
            pub fn rtc_load_hi(&self) -> RTC_LOAD_HI_R {
                RTC_LOAD_HI_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:2 - RWA, RTC timer mode: 000=0.125S, 001=0.25S, 010=0.5S, 011=1S, 100=2S, 101=4S, 110=8S, 111=16S
            #[inline(always)]
            #[must_use]
            pub fn rtc_tmr_mode(&mut self) -> RTC_TMR_MODE_W<RTC_MODE_CTRL_SPEC> {
                RTC_TMR_MODE_W::new(self, 0)
            }
            ///Bit 3 - RWA, force ignore bit0 for trigger mode: 0=compare bit0, 1=ignore bit0
            #[inline(always)]
            #[must_use]
            pub fn rtc_ignore_b0(&mut self) -> RTC_IGNORE_B0_W<RTC_MODE_CTRL_SPEC> {
                RTC_IGNORE_B0_W::new(self, 3)
            }
            ///Bit 4 - RWA, RTC timer mode enable
            #[inline(always)]
            #[must_use]
            pub fn rtc_tmr_en(&mut self) -> RTC_TMR_EN_W<RTC_MODE_CTRL_SPEC> {
                RTC_TMR_EN_W::new(self, 4)
            }
            ///Bit 5 - RWA, RTC trigger mode enable
            #[inline(always)]
            #[must_use]
            pub fn rtc_trig_en(&mut self) -> RTC_TRIG_EN_W<RTC_MODE_CTRL_SPEC> {
                RTC_TRIG_EN_W::new(self, 5)
            }
            ///Bit 6 - RWA, set 1 to load RTC count low word R32_RTC_CNT_32K, auto clear after loaded
            #[inline(always)]
            #[must_use]
            pub fn rtc_load_lo(&mut self) -> RTC_LOAD_LO_W<RTC_MODE_CTRL_SPEC> {
                RTC_LOAD_LO_W::new(self, 6)
            }
            ///Bit 7 - RWA, set 1 to load RTC count high word R32_RTC_CNT_DAY, auto clear after loaded
            #[inline(always)]
            #[must_use]
            pub fn rtc_load_hi(&mut self) -> RTC_LOAD_HI_W<RTC_MODE_CTRL_SPEC> {
                RTC_LOAD_HI_W::new(self, 7)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RWA, RTC mode control, SAM
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`rtc_mode_ctrl::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`rtc_mode_ctrl::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct RTC_MODE_CTRL_SPEC;
        impl crate::RegisterSpec for RTC_MODE_CTRL_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`rtc_mode_ctrl::R`](R) reader structure
        impl crate::Readable for RTC_MODE_CTRL_SPEC {}
        ///`write(|w| ..)` method takes [`rtc_mode_ctrl::W`](W) writer structure
        impl crate::Writable for RTC_MODE_CTRL_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets RTC_MODE_CTRL to value 0x02
        impl crate::Resettable for RTC_MODE_CTRL_SPEC {
            const RESET_VALUE: u8 = 0x02;
        }
    }
    ///RTC_TRIG (rw) register accessor: RWA, RTC trigger value, SAM
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`rtc_trig::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`rtc_trig::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@rtc_trig`]
    ///module
    pub type RTC_TRIG = crate::Reg<rtc_trig::RTC_TRIG_SPEC>;
    ///RWA, RTC trigger value, SAM
    pub mod rtc_trig {
        ///Register `RTC_TRIG` reader
        pub type R = crate::R<RTC_TRIG_SPEC>;
        ///Register `RTC_TRIG` writer
        pub type W = crate::W<RTC_TRIG_SPEC>;
        ///Field `RTC_TRIG` reader - RWA, RTC trigger value
        pub type RTC_TRIG_R = crate::FieldReader<u32>;
        ///Field `RTC_TRIG` writer - RWA, RTC trigger value
        pub type RTC_TRIG_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - RWA, RTC trigger value
            #[inline(always)]
            pub fn rtc_trig(&self) -> RTC_TRIG_R {
                RTC_TRIG_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RWA, RTC trigger value
            #[inline(always)]
            #[must_use]
            pub fn rtc_trig(&mut self) -> RTC_TRIG_W<RTC_TRIG_SPEC> {
                RTC_TRIG_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RWA, RTC trigger value, SAM
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`rtc_trig::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`rtc_trig::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct RTC_TRIG_SPEC;
        impl crate::RegisterSpec for RTC_TRIG_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`rtc_trig::R`](R) reader structure
        impl crate::Readable for RTC_TRIG_SPEC {}
        ///`write(|w| ..)` method takes [`rtc_trig::W`](W) writer structure
        impl crate::Writable for RTC_TRIG_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets RTC_TRIG to value 0
        impl crate::Resettable for RTC_TRIG_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///RTC_CNT_32K (r) register accessor: RO, RTC count based 32KHz
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`rtc_cnt_32k::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@rtc_cnt_32k`]
    ///module
    pub type RTC_CNT_32K = crate::Reg<rtc_cnt_32k::RTC_CNT_32K_SPEC>;
    ///RO, RTC count based 32KHz
    pub mod rtc_cnt_32k {
        ///Register `RTC_CNT_32K` reader
        pub type R = crate::R<RTC_CNT_32K_SPEC>;
        ///Field `RTC_CNT_32K` reader - RWA,RTC count based 32KHz
        pub type RTC_CNT_32K_R = crate::FieldReader<u16>;
        impl R {
            ///Bits 0:15 - RWA,RTC count based 32KHz
            #[inline(always)]
            pub fn rtc_cnt_32k(&self) -> RTC_CNT_32K_R {
                RTC_CNT_32K_R::new(self.bits)
            }
        }
        ///RO, RTC count based 32KHz
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`rtc_cnt_32k::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct RTC_CNT_32K_SPEC;
        impl crate::RegisterSpec for RTC_CNT_32K_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`rtc_cnt_32k::R`](R) reader structure
        impl crate::Readable for RTC_CNT_32K_SPEC {}
        ///`reset()` method sets RTC_CNT_32K to value 0
        impl crate::Resettable for RTC_CNT_32K_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///RTC_CNT_2S (r) register accessor: RO, RTC count based 2 second
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`rtc_cnt_2s::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@rtc_cnt_2s`]
    ///module
    pub type RTC_CNT_2S = crate::Reg<rtc_cnt_2s::RTC_CNT_2S_SPEC>;
    ///RO, RTC count based 2 second
    pub mod rtc_cnt_2s {
        ///Register `RTC_CNT_2S` reader
        pub type R = crate::R<RTC_CNT_2S_SPEC>;
        ///Field `RTC_CNT_2S` reader - RO, RTC count based 2 second
        pub type RTC_CNT_2S_R = crate::FieldReader<u16>;
        impl R {
            ///Bits 0:15 - RO, RTC count based 2 second
            #[inline(always)]
            pub fn rtc_cnt_2s(&self) -> RTC_CNT_2S_R {
                RTC_CNT_2S_R::new(self.bits)
            }
        }
        ///RO, RTC count based 2 second
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`rtc_cnt_2s::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct RTC_CNT_2S_SPEC;
        impl crate::RegisterSpec for RTC_CNT_2S_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`rtc_cnt_2s::R`](R) reader structure
        impl crate::Readable for RTC_CNT_2S_SPEC {}
        ///`reset()` method sets RTC_CNT_2S to value 0
        impl crate::Resettable for RTC_CNT_2S_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///RTC_CNT_DAY (r) register accessor: RO, RTC count based one day, only low 14 bit
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`rtc_cnt_day::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@rtc_cnt_day`]
    ///module
    pub type RTC_CNT_DAY = crate::Reg<rtc_cnt_day::RTC_CNT_DAY_SPEC>;
    ///RO, RTC count based one day, only low 14 bit
    pub mod rtc_cnt_day {
        ///Register `RTC_CNT_DAY` reader
        pub type R = crate::R<RTC_CNT_DAY_SPEC>;
        ///Field `RTC_CNT_DAY` reader - RWA,RTC count based one day
        pub type RTC_CNT_DAY_R = crate::FieldReader<u16>;
        impl R {
            ///Bits 0:13 - RWA,RTC count based one day
            #[inline(always)]
            pub fn rtc_cnt_day(&self) -> RTC_CNT_DAY_R {
                RTC_CNT_DAY_R::new((self.bits & 0x3fff) as u16)
            }
        }
        ///RO, RTC count based one day, only low 14 bit
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`rtc_cnt_day::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct RTC_CNT_DAY_SPEC;
        impl crate::RegisterSpec for RTC_CNT_DAY_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`rtc_cnt_day::R`](R) reader structure
        impl crate::Readable for RTC_CNT_DAY_SPEC {}
        ///`reset()` method sets RTC_CNT_DAY to value 0
        impl crate::Resettable for RTC_CNT_DAY_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///SAFE_ACCESS_SIG (rw) register accessor: WO, safe accessing sign register, must write SAFE_ACCESS_SIG1 then SAFE_ACCESS_SIG2 to enter safe accessing mode
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`safe_access_sig::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`safe_access_sig::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@safe_access_sig`]
    ///module
    pub type SAFE_ACCESS_SIG = crate::Reg<safe_access_sig::SAFE_ACCESS_SIG_SPEC>;
    ///WO, safe accessing sign register, must write SAFE_ACCESS_SIG1 then SAFE_ACCESS_SIG2 to enter safe accessing mode
    pub mod safe_access_sig {
        ///Register `SAFE_ACCESS_SIG` reader
        pub type R = crate::R<SAFE_ACCESS_SIG_SPEC>;
        ///Register `SAFE_ACCESS_SIG` writer
        pub type W = crate::W<SAFE_ACCESS_SIG_SPEC>;
        ///Field `SAFE_ACC_MODE` reader - RO, current safe accessing mode: 11=safe unlocked (SAM), other=locked (00..01..10..11)
        pub type SAFE_ACC_MODE_R = crate::FieldReader;
        ///Field `SAFE_ACC_MODE` writer - RO, current safe accessing mode: 11=safe unlocked (SAM), other=locked (00..01..10..11)
        pub type SAFE_ACC_MODE_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `SAFE_ACCESS_SIG` reader - WO, safe accessing sign register, must write 0x57 then 0xA8 to enter safe accessing mode
        pub type SAFE_ACCESS_SIG_R = crate::FieldReader;
        ///Field `SAFE_ACCESS_SIG` writer - WO, safe accessing sign register, must write 0x57 then 0xA8 to enter safe accessing mode
        pub type SAFE_ACCESS_SIG_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        ///Field `SAFE_ACC_ACT` reader - RO, indicate safe accessing status now: 0=locked, read-only, 1=safe/unlocked (SAM), write enabled
        pub type SAFE_ACC_ACT_R = crate::BitReader;
        ///Field `SAFE_ACC_ACT` writer - RO, indicate safe accessing status now: 0=locked, read-only, 1=safe/unlocked (SAM), write enabled
        pub type SAFE_ACC_ACT_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `SAFE_ACC_TIMER` reader - RO, safe accessing timer bit mask (16*clock number)
        pub type SAFE_ACC_TIMER_R = crate::FieldReader;
        ///Field `SAFE_ACC_TIMER` writer - RO, safe accessing timer bit mask (16*clock number)
        pub type SAFE_ACC_TIMER_W<'a, REG> = crate::FieldWriter<'a, REG, 3>;
        impl R {
            ///Bits 0:1 - RO, current safe accessing mode: 11=safe unlocked (SAM), other=locked (00..01..10..11)
            #[inline(always)]
            pub fn safe_acc_mode(&self) -> SAFE_ACC_MODE_R {
                SAFE_ACC_MODE_R::new(self.bits & 3)
            }
            ///Bits 0:7 - WO, safe accessing sign register, must write 0x57 then 0xA8 to enter safe accessing mode
            #[inline(always)]
            pub fn safe_access_sig(&self) -> SAFE_ACCESS_SIG_R {
                SAFE_ACCESS_SIG_R::new(self.bits)
            }
            ///Bit 3 - RO, indicate safe accessing status now: 0=locked, read-only, 1=safe/unlocked (SAM), write enabled
            #[inline(always)]
            pub fn safe_acc_act(&self) -> SAFE_ACC_ACT_R {
                SAFE_ACC_ACT_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bits 4:6 - RO, safe accessing timer bit mask (16*clock number)
            #[inline(always)]
            pub fn safe_acc_timer(&self) -> SAFE_ACC_TIMER_R {
                SAFE_ACC_TIMER_R::new((self.bits >> 4) & 7)
            }
        }
        impl W {
            ///Bits 0:1 - RO, current safe accessing mode: 11=safe unlocked (SAM), other=locked (00..01..10..11)
            #[inline(always)]
            #[must_use]
            pub fn safe_acc_mode(&mut self) -> SAFE_ACC_MODE_W<SAFE_ACCESS_SIG_SPEC> {
                SAFE_ACC_MODE_W::new(self, 0)
            }
            ///Bits 0:7 - WO, safe accessing sign register, must write 0x57 then 0xA8 to enter safe accessing mode
            #[inline(always)]
            #[must_use]
            pub fn safe_access_sig(&mut self) -> SAFE_ACCESS_SIG_W<SAFE_ACCESS_SIG_SPEC> {
                SAFE_ACCESS_SIG_W::new(self, 0)
            }
            ///Bit 3 - RO, indicate safe accessing status now: 0=locked, read-only, 1=safe/unlocked (SAM), write enabled
            #[inline(always)]
            #[must_use]
            pub fn safe_acc_act(&mut self) -> SAFE_ACC_ACT_W<SAFE_ACCESS_SIG_SPEC> {
                SAFE_ACC_ACT_W::new(self, 3)
            }
            ///Bits 4:6 - RO, safe accessing timer bit mask (16*clock number)
            #[inline(always)]
            #[must_use]
            pub fn safe_acc_timer(&mut self) -> SAFE_ACC_TIMER_W<SAFE_ACCESS_SIG_SPEC> {
                SAFE_ACC_TIMER_W::new(self, 4)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///WO, safe accessing sign register, must write SAFE_ACCESS_SIG1 then SAFE_ACCESS_SIG2 to enter safe accessing mode
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`safe_access_sig::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`safe_access_sig::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct SAFE_ACCESS_SIG_SPEC;
        impl crate::RegisterSpec for SAFE_ACCESS_SIG_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`safe_access_sig::R`](R) reader structure
        impl crate::Readable for SAFE_ACCESS_SIG_SPEC {}
        ///`write(|w| ..)` method takes [`safe_access_sig::W`](W) writer structure
        impl crate::Writable for SAFE_ACCESS_SIG_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets SAFE_ACCESS_SIG to value 0
        impl crate::Resettable for SAFE_ACCESS_SIG_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///CHIP_ID (r) register accessor: RF, chip ID register, always is ID_CH58*
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`chip_id::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@chip_id`]
    ///module
    pub type CHIP_ID = crate::Reg<chip_id::CHIP_ID_SPEC>;
    ///RF, chip ID register, always is ID_CH58*
    pub mod chip_id {
        ///Register `CHIP_ID` reader
        pub type R = crate::R<CHIP_ID_SPEC>;
        ///Field `CHIP_ID` reader - RF,chip ID register
        pub type CHIP_ID_R = crate::FieldReader;
        impl R {
            ///Bits 0:7 - RF,chip ID register
            #[inline(always)]
            pub fn chip_id(&self) -> CHIP_ID_R {
                CHIP_ID_R::new(self.bits)
            }
        }
        ///RF, chip ID register, always is ID_CH58*
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`chip_id::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct CHIP_ID_SPEC;
        impl crate::RegisterSpec for CHIP_ID_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`chip_id::R`](R) reader structure
        impl crate::Readable for CHIP_ID_SPEC {}
        ///`reset()` method sets CHIP_ID to value 0x83
        impl crate::Resettable for CHIP_ID_SPEC {
            const RESET_VALUE: u8 = 0x83;
        }
    }
    ///SAFE_ACCESS_ID (r) register accessor: RF, safe accessing ID register, always 0x0C
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`safe_access_id::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@safe_access_id`]
    ///module
    pub type SAFE_ACCESS_ID = crate::Reg<safe_access_id::SAFE_ACCESS_ID_SPEC>;
    ///RF, safe accessing ID register, always 0x0C
    pub mod safe_access_id {
        ///Register `SAFE_ACCESS_ID` reader
        pub type R = crate::R<SAFE_ACCESS_ID_SPEC>;
        ///Field `SAFE_ACCESS_ID` reader - RF,safe accessing ID register
        pub type SAFE_ACCESS_ID_R = crate::FieldReader;
        impl R {
            ///Bits 0:7 - RF,safe accessing ID register
            #[inline(always)]
            pub fn safe_access_id(&self) -> SAFE_ACCESS_ID_R {
                SAFE_ACCESS_ID_R::new(self.bits)
            }
        }
        ///RF, safe accessing ID register, always 0x0C
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`safe_access_id::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct SAFE_ACCESS_ID_SPEC;
        impl crate::RegisterSpec for SAFE_ACCESS_ID_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`safe_access_id::R`](R) reader structure
        impl crate::Readable for SAFE_ACCESS_ID_SPEC {}
        ///`reset()` method sets SAFE_ACCESS_ID to value 0x0c
        impl crate::Resettable for SAFE_ACCESS_ID_SPEC {
            const RESET_VALUE: u8 = 0x0c;
        }
    }
    ///WDOG_COUNT (rw) register accessor: RW, watch-dog count, count by clock frequency Fsys/131072
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`wdog_count::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`wdog_count::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@wdog_count`]
    ///module
    pub type WDOG_COUNT = crate::Reg<wdog_count::WDOG_COUNT_SPEC>;
    ///RW, watch-dog count, count by clock frequency Fsys/131072
    pub mod wdog_count {
        ///Register `WDOG_COUNT` reader
        pub type R = crate::R<WDOG_COUNT_SPEC>;
        ///Register `WDOG_COUNT` writer
        pub type W = crate::W<WDOG_COUNT_SPEC>;
        ///Field `WDOG_COUNT` reader - RF,watch-dog count, count by clock frequency Fsys/131072
        pub type WDOG_COUNT_R = crate::FieldReader;
        ///Field `WDOG_COUNT` writer - RF,watch-dog count, count by clock frequency Fsys/131072
        pub type WDOG_COUNT_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            ///Bits 0:7 - RF,watch-dog count, count by clock frequency Fsys/131072
            #[inline(always)]
            pub fn wdog_count(&self) -> WDOG_COUNT_R {
                WDOG_COUNT_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:7 - RF,watch-dog count, count by clock frequency Fsys/131072
            #[inline(always)]
            #[must_use]
            pub fn wdog_count(&mut self) -> WDOG_COUNT_W<WDOG_COUNT_SPEC> {
                WDOG_COUNT_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW, watch-dog count, count by clock frequency Fsys/131072
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`wdog_count::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`wdog_count::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct WDOG_COUNT_SPEC;
        impl crate::RegisterSpec for WDOG_COUNT_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`wdog_count::R`](R) reader structure
        impl crate::Readable for WDOG_COUNT_SPEC {}
        ///`write(|w| ..)` method takes [`wdog_count::W`](W) writer structure
        impl crate::Writable for WDOG_COUNT_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets WDOG_COUNT to value 0
        impl crate::Resettable for WDOG_COUNT_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///RESET_STATUS__GLOB_ROM_CFG (r) register accessor: RWA, reset status, SAM or flash ROM configuration
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`reset_status__glob_rom_cfg::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@reset_status__glob_rom_cfg`]
    ///module
    pub type RESET_STATUS__GLOB_ROM_CFG =
        crate::Reg<reset_status__glob_rom_cfg::RESET_STATUS__GLOB_ROM_CFG_SPEC>;
    ///RWA, reset status, SAM or flash ROM configuration
    pub mod reset_status__glob_rom_cfg {
        ///Register `RESET_STATUS__GLOB_ROM_CFG` reader
        pub type R = crate::R<RESET_STATUS__GLOB_ROM_CFG_SPEC>;
        ///Field `RESET_FLAG` reader - RO, recent reset flag
        pub type RESET_FLAG_R = crate::FieldReader;
        ///Field `ROM_CODE_OFS` reader - RWA, code offset address selection in Flash ROM: 0=start address 0x000000, 1=start address 0x008000
        pub type ROM_CODE_OFS_R = crate::BitReader;
        ///Field `ROM_CTRL_EN` reader - RWA, enable flash ROM control interface enable
        pub type ROM_CTRL_EN_R = crate::BitReader;
        ///Field `ROM_DATA_WE` reader - RWA,enable flash ROM data and code area being erase/write
        pub type ROM_DATA_WE_R = crate::BitReader;
        ///Field `ROM_CODE_WE` reader - RWA, enable flash ROM code area being erase or write
        pub type ROM_CODE_WE_R = crate::BitReader;
        impl R {
            ///Bits 0:2 - RO, recent reset flag
            #[inline(always)]
            pub fn reset_flag(&self) -> RESET_FLAG_R {
                RESET_FLAG_R::new(self.bits & 7)
            }
            ///Bit 4 - RWA, code offset address selection in Flash ROM: 0=start address 0x000000, 1=start address 0x008000
            #[inline(always)]
            pub fn rom_code_ofs(&self) -> ROM_CODE_OFS_R {
                ROM_CODE_OFS_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - RWA, enable flash ROM control interface enable
            #[inline(always)]
            pub fn rom_ctrl_en(&self) -> ROM_CTRL_EN_R {
                ROM_CTRL_EN_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - RWA,enable flash ROM data and code area being erase/write
            #[inline(always)]
            pub fn rom_data_we(&self) -> ROM_DATA_WE_R {
                ROM_DATA_WE_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - RWA, enable flash ROM code area being erase or write
            #[inline(always)]
            pub fn rom_code_we(&self) -> ROM_CODE_WE_R {
                ROM_CODE_WE_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        ///RWA, reset status, SAM or flash ROM configuration
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`reset_status__glob_rom_cfg::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct RESET_STATUS__GLOB_ROM_CFG_SPEC;
        impl crate::RegisterSpec for RESET_STATUS__GLOB_ROM_CFG_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`reset_status__glob_rom_cfg::R`](R) reader structure
        impl crate::Readable for RESET_STATUS__GLOB_ROM_CFG_SPEC {}
        ///`reset()` method sets RESET_STATUS__GLOB_ROM_CFG to value 0x01
        impl crate::Resettable for RESET_STATUS__GLOB_ROM_CFG_SPEC {
            const RESET_VALUE: u8 = 0x01;
        }
    }
    ///GLOB_CFG_INFO (r) register accessor: RO, global configuration information and status
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`glob_cfg_info::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@glob_cfg_info`]
    ///module
    pub type GLOB_CFG_INFO = crate::Reg<glob_cfg_info::GLOB_CFG_INFO_SPEC>;
    ///RO, global configuration information and status
    pub mod glob_cfg_info {
        ///Register `GLOB_CFG_INFO` reader
        pub type R = crate::R<GLOB_CFG_INFO_SPEC>;
        ///Field `CFG_ROM_READ` reader - RO, indicate protected status of Flash ROM code and data: 0=reading protect, 1=enable read by external programmer
        pub type CFG_ROM_READ_R = crate::BitReader;
        ///Field `CFG_RESET_EN` reader - RO, manual reset input enable status
        pub type CFG_RESET_EN_R = crate::BitReader;
        ///Field `CFG_BOOT_EN` reader - RO, boot-loader enable status
        pub type CFG_BOOT_EN_R = crate::BitReader;
        ///Field `CFG_DEBUG_EN` reader - RO, debug enable status
        pub type CFG_DEBUG_EN_R = crate::BitReader;
        ///Field `BOOT_LOADER` reader - RO, indicate boot loader status: 0=application status (by software reset), 1=boot loader status
        pub type BOOT_LOADER_R = crate::BitReader;
        impl R {
            ///Bit 0 - RO, indicate protected status of Flash ROM code and data: 0=reading protect, 1=enable read by external programmer
            #[inline(always)]
            pub fn cfg_rom_read(&self) -> CFG_ROM_READ_R {
                CFG_ROM_READ_R::new((self.bits & 1) != 0)
            }
            ///Bit 2 - RO, manual reset input enable status
            #[inline(always)]
            pub fn cfg_reset_en(&self) -> CFG_RESET_EN_R {
                CFG_RESET_EN_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RO, boot-loader enable status
            #[inline(always)]
            pub fn cfg_boot_en(&self) -> CFG_BOOT_EN_R {
                CFG_BOOT_EN_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RO, debug enable status
            #[inline(always)]
            pub fn cfg_debug_en(&self) -> CFG_DEBUG_EN_R {
                CFG_DEBUG_EN_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - RO, indicate boot loader status: 0=application status (by software reset), 1=boot loader status
            #[inline(always)]
            pub fn boot_loader(&self) -> BOOT_LOADER_R {
                BOOT_LOADER_R::new(((self.bits >> 5) & 1) != 0)
            }
        }
        ///RO, global configuration information and status
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`glob_cfg_info::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct GLOB_CFG_INFO_SPEC;
        impl crate::RegisterSpec for GLOB_CFG_INFO_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`glob_cfg_info::R`](R) reader structure
        impl crate::Readable for GLOB_CFG_INFO_SPEC {}
        ///`reset()` method sets GLOB_CFG_INFO to value 0x0e
        impl crate::Resettable for GLOB_CFG_INFO_SPEC {
            const RESET_VALUE: u8 = 0x0e;
        }
    }
    ///RST_WDOG_CTRL (rw) register accessor: RWA, reset and watch-dog control, SAM
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`rst_wdog_ctrl::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`rst_wdog_ctrl::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@rst_wdog_ctrl`]
    ///module
    pub type RST_WDOG_CTRL = crate::Reg<rst_wdog_ctrl::RST_WDOG_CTRL_SPEC>;
    ///RWA, reset and watch-dog control, SAM
    pub mod rst_wdog_ctrl {
        ///Register `RST_WDOG_CTRL` reader
        pub type R = crate::R<RST_WDOG_CTRL_SPEC>;
        ///Register `RST_WDOG_CTRL` writer
        pub type W = crate::W<RST_WDOG_CTRL_SPEC>;
        ///Field `SOFTWARE_RESET` reader - WA or WZ, global software reset, high action, auto clear
        pub type SOFTWARE_RESET_R = crate::BitReader;
        ///Field `SOFTWARE_RESET` writer - WA or WZ, global software reset, high action, auto clear
        pub type SOFTWARE_RESET_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `WDOG_RST_EN` reader - RWA, enable watch-dog reset if watch-dog timer overflow: 0=as timer only, 1=enable reset if timer overflow
        pub type WDOG_RST_EN_R = crate::BitReader;
        ///Field `WDOG_RST_EN` writer - RWA, enable watch-dog reset if watch-dog timer overflow: 0=as timer only, 1=enable reset if timer overflow
        pub type WDOG_RST_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `WDOG_INT_EN` reader - RWA, watch-dog timer overflow interrupt enable: 0=disable, 1=enable
        pub type WDOG_INT_EN_R = crate::BitReader;
        ///Field `WDOG_INT_EN` writer - RWA, watch-dog timer overflow interrupt enable: 0=disable, 1=enable
        pub type WDOG_INT_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `WDOG_INT_FLAG` reader - RW1, watch-dog timer overflow interrupt flag, cleared by RW1 or reload watch-dog count or __SEV(Send-Event)
        pub type WDOG_INT_FLAG_R = crate::BitReader;
        ///Field `WDOG_INT_FLAG` writer - RW1, watch-dog timer overflow interrupt flag, cleared by RW1 or reload watch-dog count or __SEV(Send-Event)
        pub type WDOG_INT_FLAG_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - WA or WZ, global software reset, high action, auto clear
            #[inline(always)]
            pub fn software_reset(&self) -> SOFTWARE_RESET_R {
                SOFTWARE_RESET_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RWA, enable watch-dog reset if watch-dog timer overflow: 0=as timer only, 1=enable reset if timer overflow
            #[inline(always)]
            pub fn wdog_rst_en(&self) -> WDOG_RST_EN_R {
                WDOG_RST_EN_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RWA, watch-dog timer overflow interrupt enable: 0=disable, 1=enable
            #[inline(always)]
            pub fn wdog_int_en(&self) -> WDOG_INT_EN_R {
                WDOG_INT_EN_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 4 - RW1, watch-dog timer overflow interrupt flag, cleared by RW1 or reload watch-dog count or __SEV(Send-Event)
            #[inline(always)]
            pub fn wdog_int_flag(&self) -> WDOG_INT_FLAG_R {
                WDOG_INT_FLAG_R::new(((self.bits >> 4) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - WA or WZ, global software reset, high action, auto clear
            #[inline(always)]
            #[must_use]
            pub fn software_reset(&mut self) -> SOFTWARE_RESET_W<RST_WDOG_CTRL_SPEC> {
                SOFTWARE_RESET_W::new(self, 0)
            }
            ///Bit 1 - RWA, enable watch-dog reset if watch-dog timer overflow: 0=as timer only, 1=enable reset if timer overflow
            #[inline(always)]
            #[must_use]
            pub fn wdog_rst_en(&mut self) -> WDOG_RST_EN_W<RST_WDOG_CTRL_SPEC> {
                WDOG_RST_EN_W::new(self, 1)
            }
            ///Bit 2 - RWA, watch-dog timer overflow interrupt enable: 0=disable, 1=enable
            #[inline(always)]
            #[must_use]
            pub fn wdog_int_en(&mut self) -> WDOG_INT_EN_W<RST_WDOG_CTRL_SPEC> {
                WDOG_INT_EN_W::new(self, 2)
            }
            ///Bit 4 - RW1, watch-dog timer overflow interrupt flag, cleared by RW1 or reload watch-dog count or __SEV(Send-Event)
            #[inline(always)]
            #[must_use]
            pub fn wdog_int_flag(&mut self) -> WDOG_INT_FLAG_W<RST_WDOG_CTRL_SPEC> {
                WDOG_INT_FLAG_W::new(self, 4)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RWA, reset and watch-dog control, SAM
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`rst_wdog_ctrl::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`rst_wdog_ctrl::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct RST_WDOG_CTRL_SPEC;
        impl crate::RegisterSpec for RST_WDOG_CTRL_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`rst_wdog_ctrl::R`](R) reader structure
        impl crate::Readable for RST_WDOG_CTRL_SPEC {}
        ///`write(|w| ..)` method takes [`rst_wdog_ctrl::W`](W) writer structure
        impl crate::Writable for RST_WDOG_CTRL_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets RST_WDOG_CTRL to value 0
        impl crate::Resettable for RST_WDOG_CTRL_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///GLOB_RESET_KEEP (rw) register accessor: RW, value keeper during global reset
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`glob_reset_keep::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`glob_reset_keep::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@glob_reset_keep`]
    ///module
    pub type GLOB_RESET_KEEP = crate::Reg<glob_reset_keep::GLOB_RESET_KEEP_SPEC>;
    ///RW, value keeper during global reset
    pub mod glob_reset_keep {
        ///Register `GLOB_RESET_KEEP` reader
        pub type R = crate::R<GLOB_RESET_KEEP_SPEC>;
        ///Register `GLOB_RESET_KEEP` writer
        pub type W = crate::W<GLOB_RESET_KEEP_SPEC>;
        ///Field `GLOB_RESET_KEEP` reader - RW, value keeper during global reset
        pub type GLOB_RESET_KEEP_R = crate::FieldReader;
        ///Field `GLOB_RESET_KEEP` writer - RW, value keeper during global reset
        pub type GLOB_RESET_KEEP_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            ///Bits 0:7 - RW, value keeper during global reset
            #[inline(always)]
            pub fn glob_reset_keep(&self) -> GLOB_RESET_KEEP_R {
                GLOB_RESET_KEEP_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:7 - RW, value keeper during global reset
            #[inline(always)]
            #[must_use]
            pub fn glob_reset_keep(&mut self) -> GLOB_RESET_KEEP_W<GLOB_RESET_KEEP_SPEC> {
                GLOB_RESET_KEEP_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW, value keeper during global reset
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`glob_reset_keep::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`glob_reset_keep::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct GLOB_RESET_KEEP_SPEC;
        impl crate::RegisterSpec for GLOB_RESET_KEEP_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`glob_reset_keep::R`](R) reader structure
        impl crate::Readable for GLOB_RESET_KEEP_SPEC {}
        ///`write(|w| ..)` method takes [`glob_reset_keep::W`](W) writer structure
        impl crate::Writable for GLOB_RESET_KEEP_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets GLOB_RESET_KEEP to value 0
        impl crate::Resettable for GLOB_RESET_KEEP_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///PLL_CONFIG (rw) register accessor: RWA, PLL configuration control, SAM
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`pll_config::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pll_config::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@pll_config`]
    ///module
    pub type PLL_CONFIG = crate::Reg<pll_config::PLL_CONFIG_SPEC>;
    ///RWA, PLL configuration control, SAM
    pub mod pll_config {
        ///Register `PLL_CONFIG` reader
        pub type R = crate::R<PLL_CONFIG_SPEC>;
        ///Register `PLL_CONFIG` writer
        pub type W = crate::W<PLL_CONFIG_SPEC>;
        ///Field `PLL_CFG_DAT` reader - RWA, PLL configure data
        pub type PLL_CFG_DAT_R = crate::FieldReader;
        ///Field `PLL_CFG_DAT` writer - RWA, PLL configure data
        pub type PLL_CFG_DAT_W<'a, REG> = crate::FieldWriter<'a, REG, 7>;
        ///Field `FLASH_IO_MOD` reader - RWA, flash ROM interface mode
        pub type FLASH_IO_MOD_R = crate::BitReader;
        ///Field `FLASH_IO_MOD` writer - RWA, flash ROM interface mode
        pub type FLASH_IO_MOD_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bits 0:6 - RWA, PLL configure data
            #[inline(always)]
            pub fn pll_cfg_dat(&self) -> PLL_CFG_DAT_R {
                PLL_CFG_DAT_R::new(self.bits & 0x7f)
            }
            ///Bit 7 - RWA, flash ROM interface mode
            #[inline(always)]
            pub fn flash_io_mod(&self) -> FLASH_IO_MOD_R {
                FLASH_IO_MOD_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:6 - RWA, PLL configure data
            #[inline(always)]
            #[must_use]
            pub fn pll_cfg_dat(&mut self) -> PLL_CFG_DAT_W<PLL_CONFIG_SPEC> {
                PLL_CFG_DAT_W::new(self, 0)
            }
            ///Bit 7 - RWA, flash ROM interface mode
            #[inline(always)]
            #[must_use]
            pub fn flash_io_mod(&mut self) -> FLASH_IO_MOD_W<PLL_CONFIG_SPEC> {
                FLASH_IO_MOD_W::new(self, 7)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RWA, PLL configuration control, SAM
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`pll_config::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pll_config::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct PLL_CONFIG_SPEC;
        impl crate::RegisterSpec for PLL_CONFIG_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`pll_config::R`](R) reader structure
        impl crate::Readable for PLL_CONFIG_SPEC {}
        ///`write(|w| ..)` method takes [`pll_config::W`](W) writer structure
        impl crate::Writable for PLL_CONFIG_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets PLL_CONFIG to value 0x4a
        impl crate::Resettable for PLL_CONFIG_SPEC {
            const RESET_VALUE: u8 = 0x4a;
        }
    }
    ///XT32M_TUNE (rw) register accessor: RWA, external 32MHz oscillator tune control, SAM
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`xt32m_tune::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`xt32m_tune::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@xt32m_tune`]
    ///module
    pub type XT32M_TUNE = crate::Reg<xt32m_tune::XT32M_TUNE_SPEC>;
    ///RWA, external 32MHz oscillator tune control, SAM
    pub mod xt32m_tune {
        ///Register `XT32M_TUNE` reader
        pub type R = crate::R<XT32M_TUNE_SPEC>;
        ///Register `XT32M_TUNE` writer
        pub type W = crate::W<XT32M_TUNE_SPEC>;
        ///Field `XT32M_I_BIAS` reader - RWA, external 32MHz oscillator bias current tune: 00=75% current, 01=standard current, 10=125% current, 11=150% current
        pub type XT32M_I_BIAS_R = crate::FieldReader;
        ///Field `XT32M_I_BIAS` writer - RWA, external 32MHz oscillator bias current tune: 00=75% current, 01=standard current, 10=125% current, 11=150% current
        pub type XT32M_I_BIAS_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `XT32M_C_LOAD` reader - RWA, external 32MHz oscillator load capacitor tune: Cap = RB_XT32M_C_LOAD * 2 + 10pF
        pub type XT32M_C_LOAD_R = crate::FieldReader;
        ///Field `XT32M_C_LOAD` writer - RWA, external 32MHz oscillator load capacitor tune: Cap = RB_XT32M_C_LOAD * 2 + 10pF
        pub type XT32M_C_LOAD_W<'a, REG> = crate::FieldWriter<'a, REG, 3>;
        impl R {
            ///Bits 0:1 - RWA, external 32MHz oscillator bias current tune: 00=75% current, 01=standard current, 10=125% current, 11=150% current
            #[inline(always)]
            pub fn xt32m_i_bias(&self) -> XT32M_I_BIAS_R {
                XT32M_I_BIAS_R::new(self.bits & 3)
            }
            ///Bits 4:6 - RWA, external 32MHz oscillator load capacitor tune: Cap = RB_XT32M_C_LOAD * 2 + 10pF
            #[inline(always)]
            pub fn xt32m_c_load(&self) -> XT32M_C_LOAD_R {
                XT32M_C_LOAD_R::new((self.bits >> 4) & 7)
            }
        }
        impl W {
            ///Bits 0:1 - RWA, external 32MHz oscillator bias current tune: 00=75% current, 01=standard current, 10=125% current, 11=150% current
            #[inline(always)]
            #[must_use]
            pub fn xt32m_i_bias(&mut self) -> XT32M_I_BIAS_W<XT32M_TUNE_SPEC> {
                XT32M_I_BIAS_W::new(self, 0)
            }
            ///Bits 4:6 - RWA, external 32MHz oscillator load capacitor tune: Cap = RB_XT32M_C_LOAD * 2 + 10pF
            #[inline(always)]
            #[must_use]
            pub fn xt32m_c_load(&mut self) -> XT32M_C_LOAD_W<XT32M_TUNE_SPEC> {
                XT32M_C_LOAD_W::new(self, 4)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RWA, external 32MHz oscillator tune control, SAM
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`xt32m_tune::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`xt32m_tune::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct XT32M_TUNE_SPEC;
        impl crate::RegisterSpec for XT32M_TUNE_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`xt32m_tune::R`](R) reader structure
        impl crate::Readable for XT32M_TUNE_SPEC {}
        ///`write(|w| ..)` method takes [`xt32m_tune::W`](W) writer structure
        impl crate::Writable for XT32M_TUNE_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets XT32M_TUNE to value 0x32
        impl crate::Resettable for XT32M_TUNE_SPEC {
            const RESET_VALUE: u8 = 0x32;
        }
    }
    ///OSC_CAL_CNT (r) register accessor: RO, system clock count value for 32KHz multi-cycles
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`osc_cal_cnt::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@osc_cal_cnt`]
    ///module
    pub type OSC_CAL_CNT = crate::Reg<osc_cal_cnt::OSC_CAL_CNT_SPEC>;
    ///RO, system clock count value for 32KHz multi-cycles
    pub mod osc_cal_cnt {
        ///Register `OSC_CAL_CNT` reader
        pub type R = crate::R<OSC_CAL_CNT_SPEC>;
        ///Field `OSC_CAL_CNT` reader - RO, system clock count value for 32KHz multi-cycles
        pub type OSC_CAL_CNT_R = crate::FieldReader<u16>;
        ///Field `OSC_CAL_OV_CLR` reader - RW1, indicate R8_OSC_CAL_OV_CNT not zero, set 1 to clear R8_OSC_CAL_OV_CNT
        pub type OSC_CAL_OV_CLR_R = crate::BitReader;
        ///Field `OSC_CAL_IF` reader - RW1, interrupt flag for oscillator capture end, set 1 to clear
        pub type OSC_CAL_IF_R = crate::BitReader;
        impl R {
            ///Bits 0:13 - RO, system clock count value for 32KHz multi-cycles
            #[inline(always)]
            pub fn osc_cal_cnt(&self) -> OSC_CAL_CNT_R {
                OSC_CAL_CNT_R::new(self.bits & 0x3fff)
            }
            ///Bit 14 - RW1, indicate R8_OSC_CAL_OV_CNT not zero, set 1 to clear R8_OSC_CAL_OV_CNT
            #[inline(always)]
            pub fn osc_cal_ov_clr(&self) -> OSC_CAL_OV_CLR_R {
                OSC_CAL_OV_CLR_R::new(((self.bits >> 14) & 1) != 0)
            }
            ///Bit 15 - RW1, interrupt flag for oscillator capture end, set 1 to clear
            #[inline(always)]
            pub fn osc_cal_if(&self) -> OSC_CAL_IF_R {
                OSC_CAL_IF_R::new(((self.bits >> 15) & 1) != 0)
            }
        }
        ///RO, system clock count value for 32KHz multi-cycles
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`osc_cal_cnt::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct OSC_CAL_CNT_SPEC;
        impl crate::RegisterSpec for OSC_CAL_CNT_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`osc_cal_cnt::R`](R) reader structure
        impl crate::Readable for OSC_CAL_CNT_SPEC {}
        ///`reset()` method sets OSC_CAL_CNT to value 0
        impl crate::Resettable for OSC_CAL_CNT_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///OSC_CAL_CTRL (rw) register accessor: RWA, oscillator frequency calibration control, SAM
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`osc_cal_ctrl::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`osc_cal_ctrl::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@osc_cal_ctrl`]
    ///module
    pub type OSC_CAL_CTRL = crate::Reg<osc_cal_ctrl::OSC_CAL_CTRL_SPEC>;
    ///RWA, oscillator frequency calibration control, SAM
    pub mod osc_cal_ctrl {
        ///Register `OSC_CAL_CTRL` reader
        pub type R = crate::R<OSC_CAL_CTRL_SPEC>;
        ///Register `OSC_CAL_CTRL` writer
        pub type W = crate::W<OSC_CAL_CTRL_SPEC>;
        ///Field `OSC_CNT_TOTAL` reader - RWA, total cycles mode for oscillator capture
        pub type OSC_CNT_TOTAL_R = crate::FieldReader;
        ///Field `OSC_CNT_TOTAL` writer - RWA, total cycles mode for oscillator capture
        pub type OSC_CNT_TOTAL_W<'a, REG> = crate::FieldWriter<'a, REG, 3>;
        ///Field `OSC_CNT_HALT` reader - RO, calibration counter halt status: 0=counting, 1=halt for reading count value
        pub type OSC_CNT_HALT_R = crate::BitReader;
        ///Field `OSC_CAL_IE` reader - RWA, interrupt enable for oscillator capture end
        pub type OSC_CAL_IE_R = crate::BitReader;
        ///Field `OSC_CAL_IE` writer - RWA, interrupt enable for oscillator capture end
        pub type OSC_CAL_IE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `OSC_CNT_EN` reader - RWA, calibration counter enable
        pub type OSC_CNT_EN_R = crate::BitReader;
        ///Field `OSC_CNT_EN` writer - RWA, calibration counter enable
        pub type OSC_CNT_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `OSC_CNT_END` reader - RWA, select oscillator capture end mode: 0=normal, 1=append 2 cycles
        pub type OSC_CNT_END_R = crate::BitReader;
        ///Field `OSC_CNT_END` writer - RWA, select oscillator capture end mode: 0=normal, 1=append 2 cycles
        pub type OSC_CNT_END_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bits 0:2 - RWA, total cycles mode for oscillator capture
            #[inline(always)]
            pub fn osc_cnt_total(&self) -> OSC_CNT_TOTAL_R {
                OSC_CNT_TOTAL_R::new(self.bits & 7)
            }
            ///Bit 3 - RO, calibration counter halt status: 0=counting, 1=halt for reading count value
            #[inline(always)]
            pub fn osc_cnt_halt(&self) -> OSC_CNT_HALT_R {
                OSC_CNT_HALT_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RWA, interrupt enable for oscillator capture end
            #[inline(always)]
            pub fn osc_cal_ie(&self) -> OSC_CAL_IE_R {
                OSC_CAL_IE_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - RWA, calibration counter enable
            #[inline(always)]
            pub fn osc_cnt_en(&self) -> OSC_CNT_EN_R {
                OSC_CNT_EN_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - RWA, select oscillator capture end mode: 0=normal, 1=append 2 cycles
            #[inline(always)]
            pub fn osc_cnt_end(&self) -> OSC_CNT_END_R {
                OSC_CNT_END_R::new(((self.bits >> 6) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:2 - RWA, total cycles mode for oscillator capture
            #[inline(always)]
            #[must_use]
            pub fn osc_cnt_total(&mut self) -> OSC_CNT_TOTAL_W<OSC_CAL_CTRL_SPEC> {
                OSC_CNT_TOTAL_W::new(self, 0)
            }
            ///Bit 4 - RWA, interrupt enable for oscillator capture end
            #[inline(always)]
            #[must_use]
            pub fn osc_cal_ie(&mut self) -> OSC_CAL_IE_W<OSC_CAL_CTRL_SPEC> {
                OSC_CAL_IE_W::new(self, 4)
            }
            ///Bit 5 - RWA, calibration counter enable
            #[inline(always)]
            #[must_use]
            pub fn osc_cnt_en(&mut self) -> OSC_CNT_EN_W<OSC_CAL_CTRL_SPEC> {
                OSC_CNT_EN_W::new(self, 5)
            }
            ///Bit 6 - RWA, select oscillator capture end mode: 0=normal, 1=append 2 cycles
            #[inline(always)]
            #[must_use]
            pub fn osc_cnt_end(&mut self) -> OSC_CNT_END_W<OSC_CAL_CTRL_SPEC> {
                OSC_CNT_END_W::new(self, 6)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RWA, oscillator frequency calibration control, SAM
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`osc_cal_ctrl::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`osc_cal_ctrl::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct OSC_CAL_CTRL_SPEC;
        impl crate::RegisterSpec for OSC_CAL_CTRL_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`osc_cal_ctrl::R`](R) reader structure
        impl crate::Readable for OSC_CAL_CTRL_SPEC {}
        ///`write(|w| ..)` method takes [`osc_cal_ctrl::W`](W) writer structure
        impl crate::Writable for OSC_CAL_CTRL_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets OSC_CAL_CTRL to value 0x09
        impl crate::Resettable for OSC_CAL_CTRL_SPEC {
            const RESET_VALUE: u8 = 0x09;
        }
    }
    ///OSC_CAL_OV_CNT (r) register accessor: RO, oscillator frequency calibration overflow times
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`osc_cal_ov_cnt::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@osc_cal_ov_cnt`]
    ///module
    pub type OSC_CAL_OV_CNT = crate::Reg<osc_cal_ov_cnt::OSC_CAL_OV_CNT_SPEC>;
    ///RO, oscillator frequency calibration overflow times
    pub mod osc_cal_ov_cnt {
        ///Register `OSC_CAL_OV_CNT` reader
        pub type R = crate::R<OSC_CAL_OV_CNT_SPEC>;
        ///Field `OSC_CAL_OV_CNT` reader - RO, oscillator frequency calibration overflow times
        pub type OSC_CAL_OV_CNT_R = crate::FieldReader;
        impl R {
            ///Bits 0:7 - RO, oscillator frequency calibration overflow times
            #[inline(always)]
            pub fn osc_cal_ov_cnt(&self) -> OSC_CAL_OV_CNT_R {
                OSC_CAL_OV_CNT_R::new(self.bits)
            }
        }
        ///RO, oscillator frequency calibration overflow times
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`osc_cal_ov_cnt::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct OSC_CAL_OV_CNT_SPEC;
        impl crate::RegisterSpec for OSC_CAL_OV_CNT_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`osc_cal_ov_cnt::R`](R) reader structure
        impl crate::Readable for OSC_CAL_OV_CNT_SPEC {}
        ///`reset()` method sets OSC_CAL_OV_CNT to value 0
        impl crate::Resettable for OSC_CAL_OV_CNT_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///TKEY_COUNT (rw) register accessor: RW, Touchkey charge and discharge count
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`tkey_count::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`tkey_count::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@tkey_count`]
    ///module
    pub type TKEY_COUNT = crate::Reg<tkey_count::TKEY_COUNT_SPEC>;
    ///RW, Touchkey charge and discharge count
    pub mod tkey_count {
        ///Register `TKEY_COUNT` reader
        pub type R = crate::R<TKEY_COUNT_SPEC>;
        ///Register `TKEY_COUNT` writer
        pub type W = crate::W<TKEY_COUNT_SPEC>;
        ///Field `TKEY_CHARG_CNT` reader - RW, Touchkey charge count
        pub type TKEY_CHARG_CNT_R = crate::FieldReader;
        ///Field `TKEY_CHARG_CNT` writer - RW, Touchkey charge count
        pub type TKEY_CHARG_CNT_W<'a, REG> = crate::FieldWriter<'a, REG, 5>;
        ///Field `TKEY_DISCH_CNT` reader - RW, Touchkey discharge count
        pub type TKEY_DISCH_CNT_R = crate::FieldReader;
        ///Field `TKEY_DISCH_CNT` writer - RW, Touchkey discharge count
        pub type TKEY_DISCH_CNT_W<'a, REG> = crate::FieldWriter<'a, REG, 3>;
        impl R {
            ///Bits 0:4 - RW, Touchkey charge count
            #[inline(always)]
            pub fn tkey_charg_cnt(&self) -> TKEY_CHARG_CNT_R {
                TKEY_CHARG_CNT_R::new(self.bits & 0x1f)
            }
            ///Bits 5:7 - RW, Touchkey discharge count
            #[inline(always)]
            pub fn tkey_disch_cnt(&self) -> TKEY_DISCH_CNT_R {
                TKEY_DISCH_CNT_R::new((self.bits >> 5) & 7)
            }
        }
        impl W {
            ///Bits 0:4 - RW, Touchkey charge count
            #[inline(always)]
            #[must_use]
            pub fn tkey_charg_cnt(&mut self) -> TKEY_CHARG_CNT_W<TKEY_COUNT_SPEC> {
                TKEY_CHARG_CNT_W::new(self, 0)
            }
            ///Bits 5:7 - RW, Touchkey discharge count
            #[inline(always)]
            #[must_use]
            pub fn tkey_disch_cnt(&mut self) -> TKEY_DISCH_CNT_W<TKEY_COUNT_SPEC> {
                TKEY_DISCH_CNT_W::new(self, 5)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW, Touchkey charge and discharge count
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`tkey_count::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`tkey_count::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct TKEY_COUNT_SPEC;
        impl crate::RegisterSpec for TKEY_COUNT_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`tkey_count::R`](R) reader structure
        impl crate::Readable for TKEY_COUNT_SPEC {}
        ///`write(|w| ..)` method takes [`tkey_count::W`](W) writer structure
        impl crate::Writable for TKEY_COUNT_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets TKEY_COUNT to value 0
        impl crate::Resettable for TKEY_COUNT_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///TKEY_CONVERT (rw) register accessor: RW, Touchkey convert start control
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`tkey_convert::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`tkey_convert::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@tkey_convert`]
    ///module
    pub type TKEY_CONVERT = crate::Reg<tkey_convert::TKEY_CONVERT_SPEC>;
    ///RW, Touchkey convert start control
    pub mod tkey_convert {
        ///Register `TKEY_CONVERT` reader
        pub type R = crate::R<TKEY_CONVERT_SPEC>;
        ///Register `TKEY_CONVERT` writer
        pub type W = crate::W<TKEY_CONVERT_SPEC>;
        ///Field `TKEY_START` reader - RW, Touchkey convert start control
        pub type TKEY_START_R = crate::BitReader;
        ///Field `TKEY_START` writer - RW, Touchkey convert start control
        pub type TKEY_START_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - RW, Touchkey convert start control
            #[inline(always)]
            pub fn tkey_start(&self) -> TKEY_START_R {
                TKEY_START_R::new((self.bits & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RW, Touchkey convert start control
            #[inline(always)]
            #[must_use]
            pub fn tkey_start(&mut self) -> TKEY_START_W<TKEY_CONVERT_SPEC> {
                TKEY_START_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW, Touchkey convert start control
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`tkey_convert::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`tkey_convert::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct TKEY_CONVERT_SPEC;
        impl crate::RegisterSpec for TKEY_CONVERT_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`tkey_convert::R`](R) reader structure
        impl crate::Readable for TKEY_CONVERT_SPEC {}
        ///`write(|w| ..)` method takes [`tkey_convert::W`](W) writer structure
        impl crate::Writable for TKEY_CONVERT_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets TKEY_CONVERT to value 0
        impl crate::Resettable for TKEY_CONVERT_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///TKEY_CFG (rw) register accessor: RW, Touchkey configure
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`tkey_cfg::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`tkey_cfg::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@tkey_cfg`]
    ///module
    pub type TKEY_CFG = crate::Reg<tkey_cfg::TKEY_CFG_SPEC>;
    ///RW, Touchkey configure
    pub mod tkey_cfg {
        ///Register `TKEY_CFG` reader
        pub type R = crate::R<TKEY_CFG_SPEC>;
        ///Register `TKEY_CFG` writer
        pub type W = crate::W<TKEY_CFG_SPEC>;
        ///Field `TKEY_PWR_ON` reader - RW, Touchkey power on
        pub type TKEY_PWR_ON_R = crate::BitReader;
        ///Field `TKEY_PWR_ON` writer - RW, Touchkey power on
        pub type TKEY_PWR_ON_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TKEY_CURRENT` reader - RW, Touchkey charge current selection
        pub type TKEY_CURRENT_R = crate::BitReader;
        ///Field `TKEY_CURRENT` writer - RW, Touchkey charge current selection
        pub type TKEY_CURRENT_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TKEY_DRV_EN` reader - RW, Touchkey drive shield enable
        pub type TKEY_DRV_EN_R = crate::BitReader;
        ///Field `TKEY_DRV_EN` writer - RW, Touchkey drive shield enable
        pub type TKEY_DRV_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TKEY_PGA_ADJ` reader - RW, ADC input PGA speed selection
        pub type TKEY_PGA_ADJ_R = crate::BitReader;
        ///Field `TKEY_PGA_ADJ` writer - RW, ADC input PGA speed selection
        pub type TKEY_PGA_ADJ_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - RW, Touchkey power on
            #[inline(always)]
            pub fn tkey_pwr_on(&self) -> TKEY_PWR_ON_R {
                TKEY_PWR_ON_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RW, Touchkey charge current selection
            #[inline(always)]
            pub fn tkey_current(&self) -> TKEY_CURRENT_R {
                TKEY_CURRENT_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RW, Touchkey drive shield enable
            #[inline(always)]
            pub fn tkey_drv_en(&self) -> TKEY_DRV_EN_R {
                TKEY_DRV_EN_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RW, ADC input PGA speed selection
            #[inline(always)]
            pub fn tkey_pga_adj(&self) -> TKEY_PGA_ADJ_R {
                TKEY_PGA_ADJ_R::new(((self.bits >> 3) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RW, Touchkey power on
            #[inline(always)]
            #[must_use]
            pub fn tkey_pwr_on(&mut self) -> TKEY_PWR_ON_W<TKEY_CFG_SPEC> {
                TKEY_PWR_ON_W::new(self, 0)
            }
            ///Bit 1 - RW, Touchkey charge current selection
            #[inline(always)]
            #[must_use]
            pub fn tkey_current(&mut self) -> TKEY_CURRENT_W<TKEY_CFG_SPEC> {
                TKEY_CURRENT_W::new(self, 1)
            }
            ///Bit 2 - RW, Touchkey drive shield enable
            #[inline(always)]
            #[must_use]
            pub fn tkey_drv_en(&mut self) -> TKEY_DRV_EN_W<TKEY_CFG_SPEC> {
                TKEY_DRV_EN_W::new(self, 2)
            }
            ///Bit 3 - RW, ADC input PGA speed selection
            #[inline(always)]
            #[must_use]
            pub fn tkey_pga_adj(&mut self) -> TKEY_PGA_ADJ_W<TKEY_CFG_SPEC> {
                TKEY_PGA_ADJ_W::new(self, 3)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW, Touchkey configure
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`tkey_cfg::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`tkey_cfg::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct TKEY_CFG_SPEC;
        impl crate::RegisterSpec for TKEY_CFG_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`tkey_cfg::R`](R) reader structure
        impl crate::Readable for TKEY_CFG_SPEC {}
        ///`write(|w| ..)` method takes [`tkey_cfg::W`](W) writer structure
        impl crate::Writable for TKEY_CFG_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets TKEY_CFG to value 0
        impl crate::Resettable for TKEY_CFG_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///ADC_CHANNEL (rw) register accessor: RW, ADC input channel selection
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`adc_channel::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`adc_channel::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@adc_channel`]
    ///module
    pub type ADC_CHANNEL = crate::Reg<adc_channel::ADC_CHANNEL_SPEC>;
    ///RW, ADC input channel selection
    pub mod adc_channel {
        ///Register `ADC_CHANNEL` reader
        pub type R = crate::R<ADC_CHANNEL_SPEC>;
        ///Register `ADC_CHANNEL` writer
        pub type W = crate::W<ADC_CHANNEL_SPEC>;
        ///Field `ADC_CH_INX` reader - RW, ADC input channel index
        pub type ADC_CH_INX_R = crate::FieldReader;
        ///Field `ADC_CH_INX` writer - RW, ADC input channel index
        pub type ADC_CH_INX_W<'a, REG> = crate::FieldWriter<'a, REG, 4>;
        impl R {
            ///Bits 0:3 - RW, ADC input channel index
            #[inline(always)]
            pub fn adc_ch_inx(&self) -> ADC_CH_INX_R {
                ADC_CH_INX_R::new(self.bits & 0x0f)
            }
        }
        impl W {
            ///Bits 0:3 - RW, ADC input channel index
            #[inline(always)]
            #[must_use]
            pub fn adc_ch_inx(&mut self) -> ADC_CH_INX_W<ADC_CHANNEL_SPEC> {
                ADC_CH_INX_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW, ADC input channel selection
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`adc_channel::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`adc_channel::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct ADC_CHANNEL_SPEC;
        impl crate::RegisterSpec for ADC_CHANNEL_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`adc_channel::R`](R) reader structure
        impl crate::Readable for ADC_CHANNEL_SPEC {}
        ///`write(|w| ..)` method takes [`adc_channel::W`](W) writer structure
        impl crate::Writable for ADC_CHANNEL_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets ADC_CHANNEL to value 0x0f
        impl crate::Resettable for ADC_CHANNEL_SPEC {
            const RESET_VALUE: u8 = 0x0f;
        }
    }
    ///ADC_CFG (rw) register accessor: RW, ADC configure
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`adc_cfg::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`adc_cfg::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@adc_cfg`]
    ///module
    pub type ADC_CFG = crate::Reg<adc_cfg::ADC_CFG_SPEC>;
    ///RW, ADC configure
    pub mod adc_cfg {
        ///Register `ADC_CFG` reader
        pub type R = crate::R<ADC_CFG_SPEC>;
        ///Register `ADC_CFG` writer
        pub type W = crate::W<ADC_CFG_SPEC>;
        ///Field `ADC_POWER_ON` reader - RW, ADC power control: 0=power down, 1=power on
        pub type ADC_POWER_ON_R = crate::BitReader;
        ///Field `ADC_POWER_ON` writer - RW, ADC power control: 0=power down, 1=power on
        pub type ADC_POWER_ON_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `ADC_BUF_EN` reader - RW, ADC input buffer enable
        pub type ADC_BUF_EN_R = crate::BitReader;
        ///Field `ADC_BUF_EN` writer - RW, ADC input buffer enable
        pub type ADC_BUF_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `ADC_DIFF_EN` reader - RW, ADC input channel mode: 0=single-end, 1=differnetial
        pub type ADC_DIFF_EN_R = crate::BitReader;
        ///Field `ADC_DIFF_EN` writer - RW, ADC input channel mode: 0=single-end, 1=differnetial
        pub type ADC_DIFF_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `ADC_OFS_TEST` reader - RW, enable ADC offset test mode: 0=normal mode, 1=short to test offset
        pub type ADC_OFS_TEST_R = crate::BitReader;
        ///Field `ADC_OFS_TEST` writer - RW, enable ADC offset test mode: 0=normal mode, 1=short to test offset
        pub type ADC_OFS_TEST_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `ADC_PGA_GAIN` reader - RW, set ADC input PGA gain: 00=-12dB, 01=-6dB, 10=0dB, 11=6dB
        pub type ADC_PGA_GAIN_R = crate::FieldReader;
        ///Field `ADC_PGA_GAIN` writer - RW, set ADC input PGA gain: 00=-12dB, 01=-6dB, 10=0dB, 11=6dB
        pub type ADC_PGA_GAIN_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `ADC_CLK_DIV` reader - RW, select ADC clock frequency: 00=3.2MHz, 01=2.67MHz, 10=5.33MHz, 11=4MHz
        pub type ADC_CLK_DIV_R = crate::FieldReader;
        ///Field `ADC_CLK_DIV` writer - RW, select ADC clock frequency: 00=3.2MHz, 01=2.67MHz, 10=5.33MHz, 11=4MHz
        pub type ADC_CLK_DIV_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        impl R {
            ///Bit 0 - RW, ADC power control: 0=power down, 1=power on
            #[inline(always)]
            pub fn adc_power_on(&self) -> ADC_POWER_ON_R {
                ADC_POWER_ON_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RW, ADC input buffer enable
            #[inline(always)]
            pub fn adc_buf_en(&self) -> ADC_BUF_EN_R {
                ADC_BUF_EN_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RW, ADC input channel mode: 0=single-end, 1=differnetial
            #[inline(always)]
            pub fn adc_diff_en(&self) -> ADC_DIFF_EN_R {
                ADC_DIFF_EN_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RW, enable ADC offset test mode: 0=normal mode, 1=short to test offset
            #[inline(always)]
            pub fn adc_ofs_test(&self) -> ADC_OFS_TEST_R {
                ADC_OFS_TEST_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bits 4:5 - RW, set ADC input PGA gain: 00=-12dB, 01=-6dB, 10=0dB, 11=6dB
            #[inline(always)]
            pub fn adc_pga_gain(&self) -> ADC_PGA_GAIN_R {
                ADC_PGA_GAIN_R::new((self.bits >> 4) & 3)
            }
            ///Bits 6:7 - RW, select ADC clock frequency: 00=3.2MHz, 01=2.67MHz, 10=5.33MHz, 11=4MHz
            #[inline(always)]
            pub fn adc_clk_div(&self) -> ADC_CLK_DIV_R {
                ADC_CLK_DIV_R::new((self.bits >> 6) & 3)
            }
        }
        impl W {
            ///Bit 0 - RW, ADC power control: 0=power down, 1=power on
            #[inline(always)]
            #[must_use]
            pub fn adc_power_on(&mut self) -> ADC_POWER_ON_W<ADC_CFG_SPEC> {
                ADC_POWER_ON_W::new(self, 0)
            }
            ///Bit 1 - RW, ADC input buffer enable
            #[inline(always)]
            #[must_use]
            pub fn adc_buf_en(&mut self) -> ADC_BUF_EN_W<ADC_CFG_SPEC> {
                ADC_BUF_EN_W::new(self, 1)
            }
            ///Bit 2 - RW, ADC input channel mode: 0=single-end, 1=differnetial
            #[inline(always)]
            #[must_use]
            pub fn adc_diff_en(&mut self) -> ADC_DIFF_EN_W<ADC_CFG_SPEC> {
                ADC_DIFF_EN_W::new(self, 2)
            }
            ///Bit 3 - RW, enable ADC offset test mode: 0=normal mode, 1=short to test offset
            #[inline(always)]
            #[must_use]
            pub fn adc_ofs_test(&mut self) -> ADC_OFS_TEST_W<ADC_CFG_SPEC> {
                ADC_OFS_TEST_W::new(self, 3)
            }
            ///Bits 4:5 - RW, set ADC input PGA gain: 00=-12dB, 01=-6dB, 10=0dB, 11=6dB
            #[inline(always)]
            #[must_use]
            pub fn adc_pga_gain(&mut self) -> ADC_PGA_GAIN_W<ADC_CFG_SPEC> {
                ADC_PGA_GAIN_W::new(self, 4)
            }
            ///Bits 6:7 - RW, select ADC clock frequency: 00=3.2MHz, 01=2.67MHz, 10=5.33MHz, 11=4MHz
            #[inline(always)]
            #[must_use]
            pub fn adc_clk_div(&mut self) -> ADC_CLK_DIV_W<ADC_CFG_SPEC> {
                ADC_CLK_DIV_W::new(self, 6)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW, ADC configure
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`adc_cfg::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`adc_cfg::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct ADC_CFG_SPEC;
        impl crate::RegisterSpec for ADC_CFG_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`adc_cfg::R`](R) reader structure
        impl crate::Readable for ADC_CFG_SPEC {}
        ///`write(|w| ..)` method takes [`adc_cfg::W`](W) writer structure
        impl crate::Writable for ADC_CFG_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets ADC_CFG to value 0xa0
        impl crate::Resettable for ADC_CFG_SPEC {
            const RESET_VALUE: u8 = 0xa0;
        }
    }
    ///ADC_CONVERT (rw) register accessor: RW, ADC convert control
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`adc_convert::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`adc_convert::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@adc_convert`]
    ///module
    pub type ADC_CONVERT = crate::Reg<adc_convert::ADC_CONVERT_SPEC>;
    ///RW, ADC convert control
    pub mod adc_convert {
        ///Register `ADC_CONVERT` reader
        pub type R = crate::R<ADC_CONVERT_SPEC>;
        ///Register `ADC_CONVERT` writer
        pub type W = crate::W<ADC_CONVERT_SPEC>;
        ///Field `ADC_START` reader - RW, ADC convert start control: 0=stop ADC convert, 1=start an ADC convert, auto clear
        pub type ADC_START_R = crate::BitReader;
        ///Field `ADC_START` writer - RW, ADC convert start control: 0=stop ADC convert, 1=start an ADC convert, auto clear
        pub type ADC_START_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `ADC_EOC_X` reader - RO, end of ADC conversion flag
        pub type ADC_EOC_X_R = crate::BitReader;
        impl R {
            ///Bit 0 - RW, ADC convert start control: 0=stop ADC convert, 1=start an ADC convert, auto clear
            #[inline(always)]
            pub fn adc_start(&self) -> ADC_START_R {
                ADC_START_R::new((self.bits & 1) != 0)
            }
            ///Bit 7 - RO, end of ADC conversion flag
            #[inline(always)]
            pub fn adc_eoc_x(&self) -> ADC_EOC_X_R {
                ADC_EOC_X_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RW, ADC convert start control: 0=stop ADC convert, 1=start an ADC convert, auto clear
            #[inline(always)]
            #[must_use]
            pub fn adc_start(&mut self) -> ADC_START_W<ADC_CONVERT_SPEC> {
                ADC_START_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW, ADC convert control
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`adc_convert::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`adc_convert::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct ADC_CONVERT_SPEC;
        impl crate::RegisterSpec for ADC_CONVERT_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`adc_convert::R`](R) reader structure
        impl crate::Readable for ADC_CONVERT_SPEC {}
        ///`write(|w| ..)` method takes [`adc_convert::W`](W) writer structure
        impl crate::Writable for ADC_CONVERT_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets ADC_CONVERT to value 0
        impl crate::Resettable for ADC_CONVERT_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///TEM_SENSOR (rw) register accessor: RW, temperature sensor control
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`tem_sensor::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`tem_sensor::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@tem_sensor`]
    ///module
    pub type TEM_SENSOR = crate::Reg<tem_sensor::TEM_SENSOR_SPEC>;
    ///RW, temperature sensor control
    pub mod tem_sensor {
        ///Register `TEM_SENSOR` reader
        pub type R = crate::R<TEM_SENSOR_SPEC>;
        ///Register `TEM_SENSOR` writer
        pub type W = crate::W<TEM_SENSOR_SPEC>;
        ///Field `TEM_SEN_PWR_ON` reader - RW, temperature sensor power control: 0=power down, 1=power on
        pub type TEM_SEN_PWR_ON_R = crate::BitReader;
        ///Field `TEM_SEN_PWR_ON` writer - RW, temperature sensor power control: 0=power down, 1=power on
        pub type TEM_SEN_PWR_ON_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 7 - RW, temperature sensor power control: 0=power down, 1=power on
            #[inline(always)]
            pub fn tem_sen_pwr_on(&self) -> TEM_SEN_PWR_ON_R {
                TEM_SEN_PWR_ON_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 7 - RW, temperature sensor power control: 0=power down, 1=power on
            #[inline(always)]
            #[must_use]
            pub fn tem_sen_pwr_on(&mut self) -> TEM_SEN_PWR_ON_W<TEM_SENSOR_SPEC> {
                TEM_SEN_PWR_ON_W::new(self, 7)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW, temperature sensor control
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`tem_sensor::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`tem_sensor::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct TEM_SENSOR_SPEC;
        impl crate::RegisterSpec for TEM_SENSOR_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`tem_sensor::R`](R) reader structure
        impl crate::Readable for TEM_SENSOR_SPEC {}
        ///`write(|w| ..)` method takes [`tem_sensor::W`](W) writer structure
        impl crate::Writable for TEM_SENSOR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets TEM_SENSOR to value 0
        impl crate::Resettable for TEM_SENSOR_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///ADC_DATA (r) register accessor: RO, ADC data
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`adc_data::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@adc_data`]
    ///module
    pub type ADC_DATA = crate::Reg<adc_data::ADC_DATA_SPEC>;
    ///RO, ADC data
    pub mod adc_data {
        ///Register `ADC_DATA` reader
        pub type R = crate::R<ADC_DATA_SPEC>;
        ///Field `ADC_DATA` reader - RO, ADC conversion data
        pub type ADC_DATA_R = crate::FieldReader<u16>;
        impl R {
            ///Bits 0:11 - RO, ADC conversion data
            #[inline(always)]
            pub fn adc_data(&self) -> ADC_DATA_R {
                ADC_DATA_R::new(self.bits & 0x0fff)
            }
        }
        ///RO, ADC data
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`adc_data::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct ADC_DATA_SPEC;
        impl crate::RegisterSpec for ADC_DATA_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`adc_data::R`](R) reader structure
        impl crate::Readable for ADC_DATA_SPEC {}
        ///`reset()` method sets ADC_DATA to value 0
        impl crate::Resettable for ADC_DATA_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///ADC_INT_FLAG (r) register accessor: RO, ADC interrupt flag register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`adc_int_flag::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@adc_int_flag`]
    ///module
    pub type ADC_INT_FLAG = crate::Reg<adc_int_flag::ADC_INT_FLAG_SPEC>;
    ///RO, ADC interrupt flag register
    pub mod adc_int_flag {
        ///Register `ADC_INT_FLAG` reader
        pub type R = crate::R<ADC_INT_FLAG_SPEC>;
        ///Field `ADC_IF_EOC` reader - RO, ADC conversion interrupt flag: 0=free or converting, 1=end of conversion, interrupt action, write R8_ADC_CONVERT to clear flag
        pub type ADC_IF_EOC_R = crate::BitReader;
        impl R {
            ///Bit 7 - RO, ADC conversion interrupt flag: 0=free or converting, 1=end of conversion, interrupt action, write R8_ADC_CONVERT to clear flag
            #[inline(always)]
            pub fn adc_if_eoc(&self) -> ADC_IF_EOC_R {
                ADC_IF_EOC_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        ///RO, ADC interrupt flag register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`adc_int_flag::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct ADC_INT_FLAG_SPEC;
        impl crate::RegisterSpec for ADC_INT_FLAG_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`adc_int_flag::R`](R) reader structure
        impl crate::Readable for ADC_INT_FLAG_SPEC {}
        ///`reset()` method sets ADC_INT_FLAG to value 0
        impl crate::Resettable for ADC_INT_FLAG_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///ADC_DMA_CTRL (rw) register accessor: RO, ADC DMA control and status register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`adc_dma_ctrl::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`adc_dma_ctrl::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@adc_dma_ctrl`]
    ///module
    pub type ADC_DMA_CTRL = crate::Reg<adc_dma_ctrl::ADC_DMA_CTRL_SPEC>;
    ///RO, ADC DMA control and status register
    pub mod adc_dma_ctrl {
        ///Register `ADC_DMA_CTRL` reader
        pub type R = crate::R<ADC_DMA_CTRL_SPEC>;
        ///Register `ADC_DMA_CTRL` writer
        pub type W = crate::W<ADC_DMA_CTRL_SPEC>;
        ///Field `ADC_DMA_CTRL` reader - RW, ADC DMA enable
        pub type ADC_DMA_CTRL_R = crate::FieldReader;
        ///Field `ADC_DMA_CTRL` writer - RW, ADC DMA enable
        pub type ADC_DMA_CTRL_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            ///Bits 0:7 - RW, ADC DMA enable
            #[inline(always)]
            pub fn adc_dma_ctrl(&self) -> ADC_DMA_CTRL_R {
                ADC_DMA_CTRL_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:7 - RW, ADC DMA enable
            #[inline(always)]
            #[must_use]
            pub fn adc_dma_ctrl(&mut self) -> ADC_DMA_CTRL_W<ADC_DMA_CTRL_SPEC> {
                ADC_DMA_CTRL_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RO, ADC DMA control and status register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`adc_dma_ctrl::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`adc_dma_ctrl::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct ADC_DMA_CTRL_SPEC;
        impl crate::RegisterSpec for ADC_DMA_CTRL_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`adc_dma_ctrl::R`](R) reader structure
        impl crate::Readable for ADC_DMA_CTRL_SPEC {}
        ///`write(|w| ..)` method takes [`adc_dma_ctrl::W`](W) writer structure
        impl crate::Writable for ADC_DMA_CTRL_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets ADC_DMA_CTRL to value 0
        impl crate::Resettable for ADC_DMA_CTRL_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///ADC_CTRL_DMA (rw) register accessor: RW, ADC DMA control
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`adc_ctrl_dma::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`adc_ctrl_dma::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@adc_ctrl_dma`]
    ///module
    pub type ADC_CTRL_DMA = crate::Reg<adc_ctrl_dma::ADC_CTRL_DMA_SPEC>;
    ///RW, ADC DMA control
    pub mod adc_ctrl_dma {
        ///Register `ADC_CTRL_DMA` reader
        pub type R = crate::R<ADC_CTRL_DMA_SPEC>;
        ///Register `ADC_CTRL_DMA` writer
        pub type W = crate::W<ADC_CTRL_DMA_SPEC>;
        ///Field `ADC_DMA_ENABLE` reader - RW, ADC DMA enable
        pub type ADC_DMA_ENABLE_R = crate::BitReader;
        ///Field `ADC_DMA_ENABLE` writer - RW, ADC DMA enable
        pub type ADC_DMA_ENABLE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `ADC_DMA_LOOP` reader - RW, ADC DMA address loop enable
        pub type ADC_DMA_LOOP_R = crate::BitReader;
        ///Field `ADC_DMA_LOOP` writer - RW, ADC DMA address loop enable
        pub type ADC_DMA_LOOP_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `ADC_IE_DMA_END` reader - RW, enable interrupt for ADC DMA completion
        pub type ADC_IE_DMA_END_R = crate::BitReader;
        ///Field `ADC_IE_DMA_END` writer - RW, enable interrupt for ADC DMA completion
        pub type ADC_IE_DMA_END_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `ADC_IE_EOC` reader - RW, enable interrupt for end of ADC conversion
        pub type ADC_IE_EOC_R = crate::BitReader;
        ///Field `ADC_IE_EOC` writer - RW, enable interrupt for end of ADC conversion
        pub type ADC_IE_EOC_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `ADC_CONT_EN` reader - RW, enable contineous conversion ADC
        pub type ADC_CONT_EN_R = crate::BitReader;
        ///Field `ADC_CONT_EN` writer - RW, enable contineous conversion ADC
        pub type ADC_CONT_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `ADC_AUTO_EN` reader - RW, enable auto continuing ADC for DMA
        pub type ADC_AUTO_EN_R = crate::BitReader;
        ///Field `ADC_AUTO_EN` writer - RW, enable auto continuing ADC for DMA
        pub type ADC_AUTO_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - RW, ADC DMA enable
            #[inline(always)]
            pub fn adc_dma_enable(&self) -> ADC_DMA_ENABLE_R {
                ADC_DMA_ENABLE_R::new((self.bits & 1) != 0)
            }
            ///Bit 2 - RW, ADC DMA address loop enable
            #[inline(always)]
            pub fn adc_dma_loop(&self) -> ADC_DMA_LOOP_R {
                ADC_DMA_LOOP_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RW, enable interrupt for ADC DMA completion
            #[inline(always)]
            pub fn adc_ie_dma_end(&self) -> ADC_IE_DMA_END_R {
                ADC_IE_DMA_END_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RW, enable interrupt for end of ADC conversion
            #[inline(always)]
            pub fn adc_ie_eoc(&self) -> ADC_IE_EOC_R {
                ADC_IE_EOC_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 6 - RW, enable contineous conversion ADC
            #[inline(always)]
            pub fn adc_cont_en(&self) -> ADC_CONT_EN_R {
                ADC_CONT_EN_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - RW, enable auto continuing ADC for DMA
            #[inline(always)]
            pub fn adc_auto_en(&self) -> ADC_AUTO_EN_R {
                ADC_AUTO_EN_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RW, ADC DMA enable
            #[inline(always)]
            #[must_use]
            pub fn adc_dma_enable(&mut self) -> ADC_DMA_ENABLE_W<ADC_CTRL_DMA_SPEC> {
                ADC_DMA_ENABLE_W::new(self, 0)
            }
            ///Bit 2 - RW, ADC DMA address loop enable
            #[inline(always)]
            #[must_use]
            pub fn adc_dma_loop(&mut self) -> ADC_DMA_LOOP_W<ADC_CTRL_DMA_SPEC> {
                ADC_DMA_LOOP_W::new(self, 2)
            }
            ///Bit 3 - RW, enable interrupt for ADC DMA completion
            #[inline(always)]
            #[must_use]
            pub fn adc_ie_dma_end(&mut self) -> ADC_IE_DMA_END_W<ADC_CTRL_DMA_SPEC> {
                ADC_IE_DMA_END_W::new(self, 3)
            }
            ///Bit 4 - RW, enable interrupt for end of ADC conversion
            #[inline(always)]
            #[must_use]
            pub fn adc_ie_eoc(&mut self) -> ADC_IE_EOC_W<ADC_CTRL_DMA_SPEC> {
                ADC_IE_EOC_W::new(self, 4)
            }
            ///Bit 6 - RW, enable contineous conversion ADC
            #[inline(always)]
            #[must_use]
            pub fn adc_cont_en(&mut self) -> ADC_CONT_EN_W<ADC_CTRL_DMA_SPEC> {
                ADC_CONT_EN_W::new(self, 6)
            }
            ///Bit 7 - RW, enable auto continuing ADC for DMA
            #[inline(always)]
            #[must_use]
            pub fn adc_auto_en(&mut self) -> ADC_AUTO_EN_W<ADC_CTRL_DMA_SPEC> {
                ADC_AUTO_EN_W::new(self, 7)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW, ADC DMA control
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`adc_ctrl_dma::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`adc_ctrl_dma::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct ADC_CTRL_DMA_SPEC;
        impl crate::RegisterSpec for ADC_CTRL_DMA_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`adc_ctrl_dma::R`](R) reader structure
        impl crate::Readable for ADC_CTRL_DMA_SPEC {}
        ///`write(|w| ..)` method takes [`adc_ctrl_dma::W`](W) writer structure
        impl crate::Writable for ADC_CTRL_DMA_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets ADC_CTRL_DMA to value 0
        impl crate::Resettable for ADC_CTRL_DMA_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///ADC_DMA_IF (rw) register accessor: RO, ADC interrupt flag
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`adc_dma_if::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`adc_dma_if::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@adc_dma_if`]
    ///module
    pub type ADC_DMA_IF = crate::Reg<adc_dma_if::ADC_DMA_IF_SPEC>;
    ///RO, ADC interrupt flag
    pub mod adc_dma_if {
        ///Register `ADC_DMA_IF` reader
        pub type R = crate::R<ADC_DMA_IF_SPEC>;
        ///Register `ADC_DMA_IF` writer
        pub type W = crate::W<ADC_DMA_IF_SPEC>;
        ///Field `ADC_IF_DMA_END` reader - interrupt flag for ADC DMA completion
        pub type ADC_IF_DMA_END_R = crate::BitReader;
        ///Field `ADC_IF_DMA_END` writer - interrupt flag for ADC DMA completion
        pub type ADC_IF_DMA_END_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `ADC_IF_END_ADC` reader - interrupt flag for end of ADC conversion
        pub type ADC_IF_END_ADC_R = crate::BitReader;
        ///Field `ADC_IF_END_ADC` writer - interrupt flag for end of ADC conversion
        pub type ADC_IF_END_ADC_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 3 - interrupt flag for ADC DMA completion
            #[inline(always)]
            pub fn adc_if_dma_end(&self) -> ADC_IF_DMA_END_R {
                ADC_IF_DMA_END_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - interrupt flag for end of ADC conversion
            #[inline(always)]
            pub fn adc_if_end_adc(&self) -> ADC_IF_END_ADC_R {
                ADC_IF_END_ADC_R::new(((self.bits >> 4) & 1) != 0)
            }
        }
        impl W {
            ///Bit 3 - interrupt flag for ADC DMA completion
            #[inline(always)]
            #[must_use]
            pub fn adc_if_dma_end(&mut self) -> ADC_IF_DMA_END_W<ADC_DMA_IF_SPEC> {
                ADC_IF_DMA_END_W::new(self, 3)
            }
            ///Bit 4 - interrupt flag for end of ADC conversion
            #[inline(always)]
            #[must_use]
            pub fn adc_if_end_adc(&mut self) -> ADC_IF_END_ADC_W<ADC_DMA_IF_SPEC> {
                ADC_IF_END_ADC_W::new(self, 4)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RO, ADC interrupt flag
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`adc_dma_if::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`adc_dma_if::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct ADC_DMA_IF_SPEC;
        impl crate::RegisterSpec for ADC_DMA_IF_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`adc_dma_if::R`](R) reader structure
        impl crate::Readable for ADC_DMA_IF_SPEC {}
        ///`write(|w| ..)` method takes [`adc_dma_if::W`](W) writer structure
        impl crate::Writable for ADC_DMA_IF_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets ADC_DMA_IF to value 0
        impl crate::Resettable for ADC_DMA_IF_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///ADC_AUTO_CYCLE (rw) register accessor: RO, ADC interrupt flag
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`adc_auto_cycle::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`adc_auto_cycle::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@adc_auto_cycle`]
    ///module
    pub type ADC_AUTO_CYCLE = crate::Reg<adc_auto_cycle::ADC_AUTO_CYCLE_SPEC>;
    ///RO, ADC interrupt flag
    pub mod adc_auto_cycle {
        ///Register `ADC_AUTO_CYCLE` reader
        pub type R = crate::R<ADC_AUTO_CYCLE_SPEC>;
        ///Register `ADC_AUTO_CYCLE` writer
        pub type W = crate::W<ADC_AUTO_CYCLE_SPEC>;
        ///Field `ADC_AUTO_CYCLE` reader - auto ADC cycle value, unit is 16 Fsys
        pub type ADC_AUTO_CYCLE_R = crate::FieldReader;
        ///Field `ADC_AUTO_CYCLE` writer - auto ADC cycle value, unit is 16 Fsys
        pub type ADC_AUTO_CYCLE_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            ///Bits 0:7 - auto ADC cycle value, unit is 16 Fsys
            #[inline(always)]
            pub fn adc_auto_cycle(&self) -> ADC_AUTO_CYCLE_R {
                ADC_AUTO_CYCLE_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:7 - auto ADC cycle value, unit is 16 Fsys
            #[inline(always)]
            #[must_use]
            pub fn adc_auto_cycle(&mut self) -> ADC_AUTO_CYCLE_W<ADC_AUTO_CYCLE_SPEC> {
                ADC_AUTO_CYCLE_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RO, ADC interrupt flag
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`adc_auto_cycle::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`adc_auto_cycle::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct ADC_AUTO_CYCLE_SPEC;
        impl crate::RegisterSpec for ADC_AUTO_CYCLE_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`adc_auto_cycle::R`](R) reader structure
        impl crate::Readable for ADC_AUTO_CYCLE_SPEC {}
        ///`write(|w| ..)` method takes [`adc_auto_cycle::W`](W) writer structure
        impl crate::Writable for ADC_AUTO_CYCLE_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets ADC_AUTO_CYCLE to value 0
        impl crate::Resettable for ADC_AUTO_CYCLE_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///ADC_DMA_NOW (r) register accessor: RO, ADC DMA current address
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`adc_dma_now::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@adc_dma_now`]
    ///module
    pub type ADC_DMA_NOW = crate::Reg<adc_dma_now::ADC_DMA_NOW_SPEC>;
    ///RO, ADC DMA current address
    pub mod adc_dma_now {
        ///Register `ADC_DMA_NOW` reader
        pub type R = crate::R<ADC_DMA_NOW_SPEC>;
        ///Field `ADC_DMA_NOW` reader - ADC DMA current address
        pub type ADC_DMA_NOW_R = crate::FieldReader<u16>;
        impl R {
            ///Bits 0:15 - ADC DMA current address
            #[inline(always)]
            pub fn adc_dma_now(&self) -> ADC_DMA_NOW_R {
                ADC_DMA_NOW_R::new(self.bits)
            }
        }
        ///RO, ADC DMA current address
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`adc_dma_now::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct ADC_DMA_NOW_SPEC;
        impl crate::RegisterSpec for ADC_DMA_NOW_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`adc_dma_now::R`](R) reader structure
        impl crate::Readable for ADC_DMA_NOW_SPEC {}
        ///`reset()` method sets ADC_DMA_NOW to value 0
        impl crate::Resettable for ADC_DMA_NOW_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///ADC_DMA_BEG (rw) register accessor: RW, ADC DMA begin address
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`adc_dma_beg::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`adc_dma_beg::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@adc_dma_beg`]
    ///module
    pub type ADC_DMA_BEG = crate::Reg<adc_dma_beg::ADC_DMA_BEG_SPEC>;
    ///RW, ADC DMA begin address
    pub mod adc_dma_beg {
        ///Register `ADC_DMA_BEG` reader
        pub type R = crate::R<ADC_DMA_BEG_SPEC>;
        ///Register `ADC_DMA_BEG` writer
        pub type W = crate::W<ADC_DMA_BEG_SPEC>;
        ///Field `ADC_DMA_BEG` reader - ADC DMA begin address
        pub type ADC_DMA_BEG_R = crate::FieldReader<u16>;
        ///Field `ADC_DMA_BEG` writer - ADC DMA begin address
        pub type ADC_DMA_BEG_W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            ///Bits 0:15 - ADC DMA begin address
            #[inline(always)]
            pub fn adc_dma_beg(&self) -> ADC_DMA_BEG_R {
                ADC_DMA_BEG_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - ADC DMA begin address
            #[inline(always)]
            #[must_use]
            pub fn adc_dma_beg(&mut self) -> ADC_DMA_BEG_W<ADC_DMA_BEG_SPEC> {
                ADC_DMA_BEG_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW, ADC DMA begin address
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`adc_dma_beg::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`adc_dma_beg::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct ADC_DMA_BEG_SPEC;
        impl crate::RegisterSpec for ADC_DMA_BEG_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`adc_dma_beg::R`](R) reader structure
        impl crate::Readable for ADC_DMA_BEG_SPEC {}
        ///`write(|w| ..)` method takes [`adc_dma_beg::W`](W) writer structure
        impl crate::Writable for ADC_DMA_BEG_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets ADC_DMA_BEG to value 0
        impl crate::Resettable for ADC_DMA_BEG_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///ADC_DMA_END (rw) register accessor: RW, ADC DMA end address
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`adc_dma_end::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`adc_dma_end::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@adc_dma_end`]
    ///module
    pub type ADC_DMA_END = crate::Reg<adc_dma_end::ADC_DMA_END_SPEC>;
    ///RW, ADC DMA end address
    pub mod adc_dma_end {
        ///Register `ADC_DMA_END` reader
        pub type R = crate::R<ADC_DMA_END_SPEC>;
        ///Register `ADC_DMA_END` writer
        pub type W = crate::W<ADC_DMA_END_SPEC>;
        ///Field `ADC_DMA_END` reader - ADC DMA end address
        pub type ADC_DMA_END_R = crate::FieldReader<u16>;
        ///Field `ADC_DMA_END` writer - ADC DMA end address
        pub type ADC_DMA_END_W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            ///Bits 0:15 - ADC DMA end address
            #[inline(always)]
            pub fn adc_dma_end(&self) -> ADC_DMA_END_R {
                ADC_DMA_END_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - ADC DMA end address
            #[inline(always)]
            #[must_use]
            pub fn adc_dma_end(&mut self) -> ADC_DMA_END_W<ADC_DMA_END_SPEC> {
                ADC_DMA_END_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW, ADC DMA end address
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`adc_dma_end::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`adc_dma_end::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct ADC_DMA_END_SPEC;
        impl crate::RegisterSpec for ADC_DMA_END_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`adc_dma_end::R`](R) reader structure
        impl crate::Readable for ADC_DMA_END_SPEC {}
        ///`write(|w| ..)` method takes [`adc_dma_end::W`](W) writer structure
        impl crate::Writable for ADC_DMA_END_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets ADC_DMA_END to value 0
        impl crate::Resettable for ADC_DMA_END_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///PA_INT_EN (rw) register accessor: RW, GPIO PA interrupt enable
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`pa_int_en::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pa_int_en::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@pa_int_en`]
    ///module
    pub type PA_INT_EN = crate::Reg<pa_int_en::PA_INT_EN_SPEC>;
    ///RW, GPIO PA interrupt enable
    pub mod pa_int_en {
        ///Register `PA_INT_EN` reader
        pub type R = crate::R<PA_INT_EN_SPEC>;
        ///Register `PA_INT_EN` writer
        pub type W = crate::W<PA_INT_EN_SPEC>;
        ///Field `PA_INT_EN` reader - GPIO PA interrupt enable
        pub type PA_INT_EN_R = crate::FieldReader<u16>;
        ///Field `PA_INT_EN` writer - GPIO PA interrupt enable
        pub type PA_INT_EN_W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            ///Bits 0:15 - GPIO PA interrupt enable
            #[inline(always)]
            pub fn pa_int_en(&self) -> PA_INT_EN_R {
                PA_INT_EN_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - GPIO PA interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn pa_int_en(&mut self) -> PA_INT_EN_W<PA_INT_EN_SPEC> {
                PA_INT_EN_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW, GPIO PA interrupt enable
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`pa_int_en::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pa_int_en::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct PA_INT_EN_SPEC;
        impl crate::RegisterSpec for PA_INT_EN_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`pa_int_en::R`](R) reader structure
        impl crate::Readable for PA_INT_EN_SPEC {}
        ///`write(|w| ..)` method takes [`pa_int_en::W`](W) writer structure
        impl crate::Writable for PA_INT_EN_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets PA_INT_EN to value 0
        impl crate::Resettable for PA_INT_EN_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///PB_INT_EN (rw) register accessor: RW, GPIO PB interrupt enable
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`pb_int_en::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pb_int_en::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@pb_int_en`]
    ///module
    pub type PB_INT_EN = crate::Reg<pb_int_en::PB_INT_EN_SPEC>;
    ///RW, GPIO PB interrupt enable
    pub mod pb_int_en {
        ///Register `PB_INT_EN` reader
        pub type R = crate::R<PB_INT_EN_SPEC>;
        ///Register `PB_INT_EN` writer
        pub type W = crate::W<PB_INT_EN_SPEC>;
        ///Field `PB_INT_EN` reader - GPIO PB interrupt enable
        pub type PB_INT_EN_R = crate::FieldReader<u16>;
        ///Field `PB_INT_EN` writer - GPIO PB interrupt enable
        pub type PB_INT_EN_W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            ///Bits 0:15 - GPIO PB interrupt enable
            #[inline(always)]
            pub fn pb_int_en(&self) -> PB_INT_EN_R {
                PB_INT_EN_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - GPIO PB interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn pb_int_en(&mut self) -> PB_INT_EN_W<PB_INT_EN_SPEC> {
                PB_INT_EN_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW, GPIO PB interrupt enable
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`pb_int_en::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pb_int_en::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct PB_INT_EN_SPEC;
        impl crate::RegisterSpec for PB_INT_EN_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`pb_int_en::R`](R) reader structure
        impl crate::Readable for PB_INT_EN_SPEC {}
        ///`write(|w| ..)` method takes [`pb_int_en::W`](W) writer structure
        impl crate::Writable for PB_INT_EN_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets PB_INT_EN to value 0
        impl crate::Resettable for PB_INT_EN_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///PA_INT_MODE (rw) register accessor: RW, GPIO PA interrupt mode: 0=level action, 1=edge action
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`pa_int_mode::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pa_int_mode::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@pa_int_mode`]
    ///module
    pub type PA_INT_MODE = crate::Reg<pa_int_mode::PA_INT_MODE_SPEC>;
    ///RW, GPIO PA interrupt mode: 0=level action, 1=edge action
    pub mod pa_int_mode {
        ///Register `PA_INT_MODE` reader
        pub type R = crate::R<PA_INT_MODE_SPEC>;
        ///Register `PA_INT_MODE` writer
        pub type W = crate::W<PA_INT_MODE_SPEC>;
        ///Field `PA_INT_MODE` reader - GPIO PA interrupt mode
        pub type PA_INT_MODE_R = crate::FieldReader<u16>;
        ///Field `PA_INT_MODE` writer - GPIO PA interrupt mode
        pub type PA_INT_MODE_W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            ///Bits 0:15 - GPIO PA interrupt mode
            #[inline(always)]
            pub fn pa_int_mode(&self) -> PA_INT_MODE_R {
                PA_INT_MODE_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - GPIO PA interrupt mode
            #[inline(always)]
            #[must_use]
            pub fn pa_int_mode(&mut self) -> PA_INT_MODE_W<PA_INT_MODE_SPEC> {
                PA_INT_MODE_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW, GPIO PA interrupt mode: 0=level action, 1=edge action
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`pa_int_mode::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pa_int_mode::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct PA_INT_MODE_SPEC;
        impl crate::RegisterSpec for PA_INT_MODE_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`pa_int_mode::R`](R) reader structure
        impl crate::Readable for PA_INT_MODE_SPEC {}
        ///`write(|w| ..)` method takes [`pa_int_mode::W`](W) writer structure
        impl crate::Writable for PA_INT_MODE_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets PA_INT_MODE to value 0
        impl crate::Resettable for PA_INT_MODE_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///PB_INT_MODE (rw) register accessor: RW, GPIO PB interrupt mode: 0=level action, 1=edge action;RW, status for parallel slave read
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`pb_int_mode::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pb_int_mode::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@pb_int_mode`]
    ///module
    pub type PB_INT_MODE = crate::Reg<pb_int_mode::PB_INT_MODE_SPEC>;
    ///RW, GPIO PB interrupt mode: 0=level action, 1=edge action;RW, status for parallel slave read
    pub mod pb_int_mode {
        ///Register `PB_INT_MODE` reader
        pub type R = crate::R<PB_INT_MODE_SPEC>;
        ///Register `PB_INT_MODE` writer
        pub type W = crate::W<PB_INT_MODE_SPEC>;
        ///Field `PB_INT_MODE` reader - GPIO PB interrupt mode
        pub type PB_INT_MODE_R = crate::FieldReader<u16>;
        ///Field `PB_INT_MODE` writer - GPIO PB interrupt mode
        pub type PB_INT_MODE_W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            ///Bits 0:15 - GPIO PB interrupt mode
            #[inline(always)]
            pub fn pb_int_mode(&self) -> PB_INT_MODE_R {
                PB_INT_MODE_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - GPIO PB interrupt mode
            #[inline(always)]
            #[must_use]
            pub fn pb_int_mode(&mut self) -> PB_INT_MODE_W<PB_INT_MODE_SPEC> {
                PB_INT_MODE_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW, GPIO PB interrupt mode: 0=level action, 1=edge action;RW, status for parallel slave read
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`pb_int_mode::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pb_int_mode::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct PB_INT_MODE_SPEC;
        impl crate::RegisterSpec for PB_INT_MODE_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`pb_int_mode::R`](R) reader structure
        impl crate::Readable for PB_INT_MODE_SPEC {}
        ///`write(|w| ..)` method takes [`pb_int_mode::W`](W) writer structure
        impl crate::Writable for PB_INT_MODE_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets PB_INT_MODE to value 0
        impl crate::Resettable for PB_INT_MODE_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///PA_INT_IF (rw) register accessor: RW1, GPIO PA interrupt flag
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`pa_int_if::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pa_int_if::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@pa_int_if`]
    ///module
    pub type PA_INT_IF = crate::Reg<pa_int_if::PA_INT_IF_SPEC>;
    ///RW1, GPIO PA interrupt flag
    pub mod pa_int_if {
        ///Register `PA_INT_IF` reader
        pub type R = crate::R<PA_INT_IF_SPEC>;
        ///Register `PA_INT_IF` writer
        pub type W = crate::W<PA_INT_IF_SPEC>;
        ///Field `PA_INT_IF` reader - GPIO PA interrupt flag
        pub type PA_INT_IF_R = crate::FieldReader<u16>;
        ///Field `PA_INT_IF` writer - GPIO PA interrupt flag
        pub type PA_INT_IF_W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            ///Bits 0:15 - GPIO PA interrupt flag
            #[inline(always)]
            pub fn pa_int_if(&self) -> PA_INT_IF_R {
                PA_INT_IF_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - GPIO PA interrupt flag
            #[inline(always)]
            #[must_use]
            pub fn pa_int_if(&mut self) -> PA_INT_IF_W<PA_INT_IF_SPEC> {
                PA_INT_IF_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW1, GPIO PA interrupt flag
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`pa_int_if::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pa_int_if::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct PA_INT_IF_SPEC;
        impl crate::RegisterSpec for PA_INT_IF_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`pa_int_if::R`](R) reader structure
        impl crate::Readable for PA_INT_IF_SPEC {}
        ///`write(|w| ..)` method takes [`pa_int_if::W`](W) writer structure
        impl crate::Writable for PA_INT_IF_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets PA_INT_IF to value 0
        impl crate::Resettable for PA_INT_IF_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///PB_INT_IF (rw) register accessor: RW1, GPIO PB interrupt flag
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`pb_int_if::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pb_int_if::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@pb_int_if`]
    ///module
    pub type PB_INT_IF = crate::Reg<pb_int_if::PB_INT_IF_SPEC>;
    ///RW1, GPIO PB interrupt flag
    pub mod pb_int_if {
        ///Register `PB_INT_IF` reader
        pub type R = crate::R<PB_INT_IF_SPEC>;
        ///Register `PB_INT_IF` writer
        pub type W = crate::W<PB_INT_IF_SPEC>;
        ///Field `PB_INT_IF` reader - GPIO PB interrupt flag
        pub type PB_INT_IF_R = crate::FieldReader<u16>;
        ///Field `PB_INT_IF` writer - GPIO PB interrupt flag
        pub type PB_INT_IF_W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            ///Bits 0:15 - GPIO PB interrupt flag
            #[inline(always)]
            pub fn pb_int_if(&self) -> PB_INT_IF_R {
                PB_INT_IF_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - GPIO PB interrupt flag
            #[inline(always)]
            #[must_use]
            pub fn pb_int_if(&mut self) -> PB_INT_IF_W<PB_INT_IF_SPEC> {
                PB_INT_IF_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW1, GPIO PB interrupt flag
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`pb_int_if::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pb_int_if::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct PB_INT_IF_SPEC;
        impl crate::RegisterSpec for PB_INT_IF_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`pb_int_if::R`](R) reader structure
        impl crate::Readable for PB_INT_IF_SPEC {}
        ///`write(|w| ..)` method takes [`pb_int_if::W`](W) writer structure
        impl crate::Writable for PB_INT_IF_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets PB_INT_IF to value 0
        impl crate::Resettable for PB_INT_IF_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///PA_DIR (rw) register accessor: RW, GPIO PA I/O direction: 0=in, 1=out
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`pa_dir::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pa_dir::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@pa_dir`]
    ///module
    pub type PA_DIR = crate::Reg<pa_dir::PA_DIR_SPEC>;
    ///RW, GPIO PA I/O direction: 0=in, 1=out
    pub mod pa_dir {
        ///Register `PA_DIR` reader
        pub type R = crate::R<PA_DIR_SPEC>;
        ///Register `PA_DIR` writer
        pub type W = crate::W<PA_DIR_SPEC>;
        ///Field `PA_DIR_0` reader - GPIO PA I/O direction byte 0
        pub type PA_DIR_0_R = crate::FieldReader;
        ///Field `PA_DIR_0` writer - GPIO PA I/O direction byte 0
        pub type PA_DIR_0_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        ///Field `PA_DIR_1` reader - GPIO PA I/O direction byte 1
        pub type PA_DIR_1_R = crate::FieldReader;
        ///Field `PA_DIR_1` writer - GPIO PA I/O direction byte 1
        pub type PA_DIR_1_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            ///Bits 0:7 - GPIO PA I/O direction byte 0
            #[inline(always)]
            pub fn pa_dir_0(&self) -> PA_DIR_0_R {
                PA_DIR_0_R::new((self.bits & 0xff) as u8)
            }
            ///Bits 8:15 - GPIO PA I/O direction byte 1
            #[inline(always)]
            pub fn pa_dir_1(&self) -> PA_DIR_1_R {
                PA_DIR_1_R::new(((self.bits >> 8) & 0xff) as u8)
            }
        }
        impl W {
            ///Bits 0:7 - GPIO PA I/O direction byte 0
            #[inline(always)]
            #[must_use]
            pub fn pa_dir_0(&mut self) -> PA_DIR_0_W<PA_DIR_SPEC> {
                PA_DIR_0_W::new(self, 0)
            }
            ///Bits 8:15 - GPIO PA I/O direction byte 1
            #[inline(always)]
            #[must_use]
            pub fn pa_dir_1(&mut self) -> PA_DIR_1_W<PA_DIR_SPEC> {
                PA_DIR_1_W::new(self, 8)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW, GPIO PA I/O direction: 0=in, 1=out
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`pa_dir::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pa_dir::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct PA_DIR_SPEC;
        impl crate::RegisterSpec for PA_DIR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`pa_dir::R`](R) reader structure
        impl crate::Readable for PA_DIR_SPEC {}
        ///`write(|w| ..)` method takes [`pa_dir::W`](W) writer structure
        impl crate::Writable for PA_DIR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets PA_DIR to value 0
        impl crate::Resettable for PA_DIR_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///PA_PIN (r) register accessor: RO, GPIO PA input
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`pa_pin::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@pa_pin`]
    ///module
    pub type PA_PIN = crate::Reg<pa_pin::PA_PIN_SPEC>;
    ///RO, GPIO PA input
    pub mod pa_pin {
        ///Register `PA_PIN` reader
        pub type R = crate::R<PA_PIN_SPEC>;
        ///Field `PA_PIN_0` reader - GPIO PA input byte 0
        pub type PA_PIN_0_R = crate::FieldReader;
        ///Field `PA_PIN_1` reader - GPIO PA input byte 1
        pub type PA_PIN_1_R = crate::FieldReader;
        impl R {
            ///Bits 0:7 - GPIO PA input byte 0
            #[inline(always)]
            pub fn pa_pin_0(&self) -> PA_PIN_0_R {
                PA_PIN_0_R::new((self.bits & 0xff) as u8)
            }
            ///Bits 8:15 - GPIO PA input byte 1
            #[inline(always)]
            pub fn pa_pin_1(&self) -> PA_PIN_1_R {
                PA_PIN_1_R::new(((self.bits >> 8) & 0xff) as u8)
            }
        }
        ///RO, GPIO PA input
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`pa_pin::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct PA_PIN_SPEC;
        impl crate::RegisterSpec for PA_PIN_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`pa_pin::R`](R) reader structure
        impl crate::Readable for PA_PIN_SPEC {}
        ///`reset()` method sets PA_PIN to value 0
        impl crate::Resettable for PA_PIN_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///PA_OUT (rw) register accessor: RW, GPIO PA output
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`pa_out::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pa_out::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@pa_out`]
    ///module
    pub type PA_OUT = crate::Reg<pa_out::PA_OUT_SPEC>;
    ///RW, GPIO PA output
    pub mod pa_out {
        ///Register `PA_OUT` reader
        pub type R = crate::R<PA_OUT_SPEC>;
        ///Register `PA_OUT` writer
        pub type W = crate::W<PA_OUT_SPEC>;
        ///Field `PA_OUT_0` reader - GPIO PA output byte 0
        pub type PA_OUT_0_R = crate::FieldReader;
        ///Field `PA_OUT_0` writer - GPIO PA output byte 0
        pub type PA_OUT_0_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        ///Field `PA_OUT_1` reader - GPIO PA output byte 1
        pub type PA_OUT_1_R = crate::FieldReader;
        ///Field `PA_OUT_1` writer - GPIO PA output byte 1
        pub type PA_OUT_1_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            ///Bits 0:7 - GPIO PA output byte 0
            #[inline(always)]
            pub fn pa_out_0(&self) -> PA_OUT_0_R {
                PA_OUT_0_R::new((self.bits & 0xff) as u8)
            }
            ///Bits 8:15 - GPIO PA output byte 1
            #[inline(always)]
            pub fn pa_out_1(&self) -> PA_OUT_1_R {
                PA_OUT_1_R::new(((self.bits >> 8) & 0xff) as u8)
            }
        }
        impl W {
            ///Bits 0:7 - GPIO PA output byte 0
            #[inline(always)]
            #[must_use]
            pub fn pa_out_0(&mut self) -> PA_OUT_0_W<PA_OUT_SPEC> {
                PA_OUT_0_W::new(self, 0)
            }
            ///Bits 8:15 - GPIO PA output byte 1
            #[inline(always)]
            #[must_use]
            pub fn pa_out_1(&mut self) -> PA_OUT_1_W<PA_OUT_SPEC> {
                PA_OUT_1_W::new(self, 8)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW, GPIO PA output
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`pa_out::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pa_out::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct PA_OUT_SPEC;
        impl crate::RegisterSpec for PA_OUT_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`pa_out::R`](R) reader structure
        impl crate::Readable for PA_OUT_SPEC {}
        ///`write(|w| ..)` method takes [`pa_out::W`](W) writer structure
        impl crate::Writable for PA_OUT_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets PA_OUT to value 0
        impl crate::Resettable for PA_OUT_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///PA_CLR (rw) register accessor: WZ, GPIO PA clear output: 0=keep, 1=clear
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`pa_clr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pa_clr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@pa_clr`]
    ///module
    pub type PA_CLR = crate::Reg<pa_clr::PA_CLR_SPEC>;
    ///WZ, GPIO PA clear output: 0=keep, 1=clear
    pub mod pa_clr {
        ///Register `PA_CLR` reader
        pub type R = crate::R<PA_CLR_SPEC>;
        ///Register `PA_CLR` writer
        pub type W = crate::W<PA_CLR_SPEC>;
        ///Field `PA_CLR_0` reader - GPIO PA clear output byte 0
        pub type PA_CLR_0_R = crate::FieldReader;
        ///Field `PA_CLR_0` writer - GPIO PA clear output byte 0
        pub type PA_CLR_0_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        ///Field `PA_CLR_1` reader - GPIO PA clear output byte 1
        pub type PA_CLR_1_R = crate::FieldReader;
        ///Field `PA_CLR_1` writer - GPIO PA clear output byte 1
        pub type PA_CLR_1_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            ///Bits 0:7 - GPIO PA clear output byte 0
            #[inline(always)]
            pub fn pa_clr_0(&self) -> PA_CLR_0_R {
                PA_CLR_0_R::new((self.bits & 0xff) as u8)
            }
            ///Bits 8:15 - GPIO PA clear output byte 1
            #[inline(always)]
            pub fn pa_clr_1(&self) -> PA_CLR_1_R {
                PA_CLR_1_R::new(((self.bits >> 8) & 0xff) as u8)
            }
        }
        impl W {
            ///Bits 0:7 - GPIO PA clear output byte 0
            #[inline(always)]
            #[must_use]
            pub fn pa_clr_0(&mut self) -> PA_CLR_0_W<PA_CLR_SPEC> {
                PA_CLR_0_W::new(self, 0)
            }
            ///Bits 8:15 - GPIO PA clear output byte 1
            #[inline(always)]
            #[must_use]
            pub fn pa_clr_1(&mut self) -> PA_CLR_1_W<PA_CLR_SPEC> {
                PA_CLR_1_W::new(self, 8)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///WZ, GPIO PA clear output: 0=keep, 1=clear
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`pa_clr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pa_clr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct PA_CLR_SPEC;
        impl crate::RegisterSpec for PA_CLR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`pa_clr::R`](R) reader structure
        impl crate::Readable for PA_CLR_SPEC {}
        ///`write(|w| ..)` method takes [`pa_clr::W`](W) writer structure
        impl crate::Writable for PA_CLR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets PA_CLR to value 0
        impl crate::Resettable for PA_CLR_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///PA_PU (rw) register accessor: RW, GPIO PA pullup resistance enable
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`pa_pu::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pa_pu::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@pa_pu`]
    ///module
    pub type PA_PU = crate::Reg<pa_pu::PA_PU_SPEC>;
    ///RW, GPIO PA pullup resistance enable
    pub mod pa_pu {
        ///Register `PA_PU` reader
        pub type R = crate::R<PA_PU_SPEC>;
        ///Register `PA_PU` writer
        pub type W = crate::W<PA_PU_SPEC>;
        ///Field `PA_PU_0` reader - GPIO PA pullup resistance enable byte 0
        pub type PA_PU_0_R = crate::FieldReader;
        ///Field `PA_PU_0` writer - GPIO PA pullup resistance enable byte 0
        pub type PA_PU_0_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        ///Field `PA_PU_1` reader - GPIO PA pullup resistance enable byte 0
        pub type PA_PU_1_R = crate::FieldReader;
        ///Field `PA_PU_1` writer - GPIO PA pullup resistance enable byte 0
        pub type PA_PU_1_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            ///Bits 0:7 - GPIO PA pullup resistance enable byte 0
            #[inline(always)]
            pub fn pa_pu_0(&self) -> PA_PU_0_R {
                PA_PU_0_R::new((self.bits & 0xff) as u8)
            }
            ///Bits 8:15 - GPIO PA pullup resistance enable byte 0
            #[inline(always)]
            pub fn pa_pu_1(&self) -> PA_PU_1_R {
                PA_PU_1_R::new(((self.bits >> 8) & 0xff) as u8)
            }
        }
        impl W {
            ///Bits 0:7 - GPIO PA pullup resistance enable byte 0
            #[inline(always)]
            #[must_use]
            pub fn pa_pu_0(&mut self) -> PA_PU_0_W<PA_PU_SPEC> {
                PA_PU_0_W::new(self, 0)
            }
            ///Bits 8:15 - GPIO PA pullup resistance enable byte 0
            #[inline(always)]
            #[must_use]
            pub fn pa_pu_1(&mut self) -> PA_PU_1_W<PA_PU_SPEC> {
                PA_PU_1_W::new(self, 8)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW, GPIO PA pullup resistance enable
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`pa_pu::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pa_pu::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct PA_PU_SPEC;
        impl crate::RegisterSpec for PA_PU_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`pa_pu::R`](R) reader structure
        impl crate::Readable for PA_PU_SPEC {}
        ///`write(|w| ..)` method takes [`pa_pu::W`](W) writer structure
        impl crate::Writable for PA_PU_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets PA_PU to value 0
        impl crate::Resettable for PA_PU_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///PA_PD_DRV (rw) register accessor: RW, PA pulldown for input or PA driving capability for output
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`pa_pd_drv::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pa_pd_drv::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@pa_pd_drv`]
    ///module
    pub type PA_PD_DRV = crate::Reg<pa_pd_drv::PA_PD_DRV_SPEC>;
    ///RW, PA pulldown for input or PA driving capability for output
    pub mod pa_pd_drv {
        ///Register `PA_PD_DRV` reader
        pub type R = crate::R<PA_PD_DRV_SPEC>;
        ///Register `PA_PD_DRV` writer
        pub type W = crate::W<PA_PD_DRV_SPEC>;
        ///Field `PA_PD_DRV_0` reader - PA pulldown for input or PA driving capability for output byte 0
        pub type PA_PD_DRV_0_R = crate::FieldReader;
        ///Field `PA_PD_DRV_0` writer - PA pulldown for input or PA driving capability for output byte 0
        pub type PA_PD_DRV_0_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        ///Field `PA_PD_DRV_1` reader - PA pulldown for input or PA driving capability for output byte 1
        pub type PA_PD_DRV_1_R = crate::FieldReader;
        ///Field `PA_PD_DRV_1` writer - PA pulldown for input or PA driving capability for output byte 1
        pub type PA_PD_DRV_1_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            ///Bits 0:7 - PA pulldown for input or PA driving capability for output byte 0
            #[inline(always)]
            pub fn pa_pd_drv_0(&self) -> PA_PD_DRV_0_R {
                PA_PD_DRV_0_R::new((self.bits & 0xff) as u8)
            }
            ///Bits 8:15 - PA pulldown for input or PA driving capability for output byte 1
            #[inline(always)]
            pub fn pa_pd_drv_1(&self) -> PA_PD_DRV_1_R {
                PA_PD_DRV_1_R::new(((self.bits >> 8) & 0xff) as u8)
            }
        }
        impl W {
            ///Bits 0:7 - PA pulldown for input or PA driving capability for output byte 0
            #[inline(always)]
            #[must_use]
            pub fn pa_pd_drv_0(&mut self) -> PA_PD_DRV_0_W<PA_PD_DRV_SPEC> {
                PA_PD_DRV_0_W::new(self, 0)
            }
            ///Bits 8:15 - PA pulldown for input or PA driving capability for output byte 1
            #[inline(always)]
            #[must_use]
            pub fn pa_pd_drv_1(&mut self) -> PA_PD_DRV_1_W<PA_PD_DRV_SPEC> {
                PA_PD_DRV_1_W::new(self, 8)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW, PA pulldown for input or PA driving capability for output
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`pa_pd_drv::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pa_pd_drv::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct PA_PD_DRV_SPEC;
        impl crate::RegisterSpec for PA_PD_DRV_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`pa_pd_drv::R`](R) reader structure
        impl crate::Readable for PA_PD_DRV_SPEC {}
        ///`write(|w| ..)` method takes [`pa_pd_drv::W`](W) writer structure
        impl crate::Writable for PA_PD_DRV_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets PA_PD_DRV to value 0
        impl crate::Resettable for PA_PD_DRV_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///PB_DIR (rw) register accessor: RW, GPIO PB I/O direction: 0=in, 1=out
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`pb_dir::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pb_dir::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@pb_dir`]
    ///module
    pub type PB_DIR = crate::Reg<pb_dir::PB_DIR_SPEC>;
    ///RW, GPIO PB I/O direction: 0=in, 1=out
    pub mod pb_dir {
        ///Register `PB_DIR` reader
        pub type R = crate::R<PB_DIR_SPEC>;
        ///Register `PB_DIR` writer
        pub type W = crate::W<PB_DIR_SPEC>;
        ///Field `PB_DIR_0` reader - GPIO PB I/O direction byte 0
        pub type PB_DIR_0_R = crate::FieldReader;
        ///Field `PB_DIR_0` writer - GPIO PB I/O direction byte 0
        pub type PB_DIR_0_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        ///Field `PB_DIR_1` reader - GPIO PB I/O direction byte 1
        pub type PB_DIR_1_R = crate::FieldReader;
        ///Field `PB_DIR_1` writer - GPIO PB I/O direction byte 1
        pub type PB_DIR_1_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        ///Field `PB_DIR_2` reader - GPIO PB I/O direction byte 2
        pub type PB_DIR_2_R = crate::FieldReader;
        ///Field `PB_DIR_2` writer - GPIO PB I/O direction byte 2
        pub type PB_DIR_2_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            ///Bits 0:7 - GPIO PB I/O direction byte 0
            #[inline(always)]
            pub fn pb_dir_0(&self) -> PB_DIR_0_R {
                PB_DIR_0_R::new((self.bits & 0xff) as u8)
            }
            ///Bits 8:15 - GPIO PB I/O direction byte 1
            #[inline(always)]
            pub fn pb_dir_1(&self) -> PB_DIR_1_R {
                PB_DIR_1_R::new(((self.bits >> 8) & 0xff) as u8)
            }
            ///Bits 16:23 - GPIO PB I/O direction byte 2
            #[inline(always)]
            pub fn pb_dir_2(&self) -> PB_DIR_2_R {
                PB_DIR_2_R::new(((self.bits >> 16) & 0xff) as u8)
            }
        }
        impl W {
            ///Bits 0:7 - GPIO PB I/O direction byte 0
            #[inline(always)]
            #[must_use]
            pub fn pb_dir_0(&mut self) -> PB_DIR_0_W<PB_DIR_SPEC> {
                PB_DIR_0_W::new(self, 0)
            }
            ///Bits 8:15 - GPIO PB I/O direction byte 1
            #[inline(always)]
            #[must_use]
            pub fn pb_dir_1(&mut self) -> PB_DIR_1_W<PB_DIR_SPEC> {
                PB_DIR_1_W::new(self, 8)
            }
            ///Bits 16:23 - GPIO PB I/O direction byte 2
            #[inline(always)]
            #[must_use]
            pub fn pb_dir_2(&mut self) -> PB_DIR_2_W<PB_DIR_SPEC> {
                PB_DIR_2_W::new(self, 16)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW, GPIO PB I/O direction: 0=in, 1=out
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`pb_dir::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pb_dir::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct PB_DIR_SPEC;
        impl crate::RegisterSpec for PB_DIR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`pb_dir::R`](R) reader structure
        impl crate::Readable for PB_DIR_SPEC {}
        ///`write(|w| ..)` method takes [`pb_dir::W`](W) writer structure
        impl crate::Writable for PB_DIR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets PB_DIR to value 0
        impl crate::Resettable for PB_DIR_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///PB_PIN (r) register accessor: RO, GPIO PB input
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`pb_pin::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@pb_pin`]
    ///module
    pub type PB_PIN = crate::Reg<pb_pin::PB_PIN_SPEC>;
    ///RO, GPIO PB input
    pub mod pb_pin {
        ///Register `PB_PIN` reader
        pub type R = crate::R<PB_PIN_SPEC>;
        ///Field `PB_PIN_0` reader - GPIO PB input byte 0
        pub type PB_PIN_0_R = crate::FieldReader;
        ///Field `PB_PIN_1` reader - GPIO PB input byte 1
        pub type PB_PIN_1_R = crate::FieldReader;
        ///Field `PB_PIN_2` reader - GPIO PB input byte 2
        pub type PB_PIN_2_R = crate::FieldReader;
        impl R {
            ///Bits 0:7 - GPIO PB input byte 0
            #[inline(always)]
            pub fn pb_pin_0(&self) -> PB_PIN_0_R {
                PB_PIN_0_R::new((self.bits & 0xff) as u8)
            }
            ///Bits 8:15 - GPIO PB input byte 1
            #[inline(always)]
            pub fn pb_pin_1(&self) -> PB_PIN_1_R {
                PB_PIN_1_R::new(((self.bits >> 8) & 0xff) as u8)
            }
            ///Bits 16:23 - GPIO PB input byte 2
            #[inline(always)]
            pub fn pb_pin_2(&self) -> PB_PIN_2_R {
                PB_PIN_2_R::new(((self.bits >> 16) & 0xff) as u8)
            }
        }
        ///RO, GPIO PB input
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`pb_pin::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct PB_PIN_SPEC;
        impl crate::RegisterSpec for PB_PIN_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`pb_pin::R`](R) reader structure
        impl crate::Readable for PB_PIN_SPEC {}
        ///`reset()` method sets PB_PIN to value 0
        impl crate::Resettable for PB_PIN_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///PB_OUT (rw) register accessor: RW, GPIO PB output;RW, data for parallel slave read
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`pb_out::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pb_out::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@pb_out`]
    ///module
    pub type PB_OUT = crate::Reg<pb_out::PB_OUT_SPEC>;
    ///RW, GPIO PB output;RW, data for parallel slave read
    pub mod pb_out {
        ///Register `PB_OUT` reader
        pub type R = crate::R<PB_OUT_SPEC>;
        ///Register `PB_OUT` writer
        pub type W = crate::W<PB_OUT_SPEC>;
        ///Field `PB_OUT_0` reader - GPIO PB output byte 0
        pub type PB_OUT_0_R = crate::FieldReader;
        ///Field `PB_OUT_0` writer - GPIO PB output byte 0
        pub type PB_OUT_0_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        ///Field `PB_OUT_1` reader - GPIO PB output byte 1
        pub type PB_OUT_1_R = crate::FieldReader;
        ///Field `PB_OUT_1` writer - GPIO PB output byte 1
        pub type PB_OUT_1_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        ///Field `PB_OUT_2` reader - GPIO PB output byte 2
        pub type PB_OUT_2_R = crate::FieldReader;
        ///Field `PB_OUT_2` writer - GPIO PB output byte 2
        pub type PB_OUT_2_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            ///Bits 0:7 - GPIO PB output byte 0
            #[inline(always)]
            pub fn pb_out_0(&self) -> PB_OUT_0_R {
                PB_OUT_0_R::new((self.bits & 0xff) as u8)
            }
            ///Bits 8:15 - GPIO PB output byte 1
            #[inline(always)]
            pub fn pb_out_1(&self) -> PB_OUT_1_R {
                PB_OUT_1_R::new(((self.bits >> 8) & 0xff) as u8)
            }
            ///Bits 16:23 - GPIO PB output byte 2
            #[inline(always)]
            pub fn pb_out_2(&self) -> PB_OUT_2_R {
                PB_OUT_2_R::new(((self.bits >> 16) & 0xff) as u8)
            }
        }
        impl W {
            ///Bits 0:7 - GPIO PB output byte 0
            #[inline(always)]
            #[must_use]
            pub fn pb_out_0(&mut self) -> PB_OUT_0_W<PB_OUT_SPEC> {
                PB_OUT_0_W::new(self, 0)
            }
            ///Bits 8:15 - GPIO PB output byte 1
            #[inline(always)]
            #[must_use]
            pub fn pb_out_1(&mut self) -> PB_OUT_1_W<PB_OUT_SPEC> {
                PB_OUT_1_W::new(self, 8)
            }
            ///Bits 16:23 - GPIO PB output byte 2
            #[inline(always)]
            #[must_use]
            pub fn pb_out_2(&mut self) -> PB_OUT_2_W<PB_OUT_SPEC> {
                PB_OUT_2_W::new(self, 16)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW, GPIO PB output;RW, data for parallel slave read
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`pb_out::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pb_out::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct PB_OUT_SPEC;
        impl crate::RegisterSpec for PB_OUT_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`pb_out::R`](R) reader structure
        impl crate::Readable for PB_OUT_SPEC {}
        ///`write(|w| ..)` method takes [`pb_out::W`](W) writer structure
        impl crate::Writable for PB_OUT_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets PB_OUT to value 0
        impl crate::Resettable for PB_OUT_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///PB_CLR (rw) register accessor: WZ, GPIO PB clear output: 0=keep, 1=clear
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`pb_clr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pb_clr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@pb_clr`]
    ///module
    pub type PB_CLR = crate::Reg<pb_clr::PB_CLR_SPEC>;
    ///WZ, GPIO PB clear output: 0=keep, 1=clear
    pub mod pb_clr {
        ///Register `PB_CLR` reader
        pub type R = crate::R<PB_CLR_SPEC>;
        ///Register `PB_CLR` writer
        pub type W = crate::W<PB_CLR_SPEC>;
        ///Field `PB_CLR_0` reader - GPIO PB clear output byte 0
        pub type PB_CLR_0_R = crate::FieldReader;
        ///Field `PB_CLR_0` writer - GPIO PB clear output byte 0
        pub type PB_CLR_0_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        ///Field `PB_CLR_1` reader - GPIO PB clear output byte 1
        pub type PB_CLR_1_R = crate::FieldReader;
        ///Field `PB_CLR_1` writer - GPIO PB clear output byte 1
        pub type PB_CLR_1_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        ///Field `PB_CLR_2` reader - GPIO PB clear output byte 2
        pub type PB_CLR_2_R = crate::FieldReader;
        ///Field `PB_CLR_2` writer - GPIO PB clear output byte 2
        pub type PB_CLR_2_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            ///Bits 0:7 - GPIO PB clear output byte 0
            #[inline(always)]
            pub fn pb_clr_0(&self) -> PB_CLR_0_R {
                PB_CLR_0_R::new((self.bits & 0xff) as u8)
            }
            ///Bits 8:15 - GPIO PB clear output byte 1
            #[inline(always)]
            pub fn pb_clr_1(&self) -> PB_CLR_1_R {
                PB_CLR_1_R::new(((self.bits >> 8) & 0xff) as u8)
            }
            ///Bits 16:23 - GPIO PB clear output byte 2
            #[inline(always)]
            pub fn pb_clr_2(&self) -> PB_CLR_2_R {
                PB_CLR_2_R::new(((self.bits >> 16) & 0xff) as u8)
            }
        }
        impl W {
            ///Bits 0:7 - GPIO PB clear output byte 0
            #[inline(always)]
            #[must_use]
            pub fn pb_clr_0(&mut self) -> PB_CLR_0_W<PB_CLR_SPEC> {
                PB_CLR_0_W::new(self, 0)
            }
            ///Bits 8:15 - GPIO PB clear output byte 1
            #[inline(always)]
            #[must_use]
            pub fn pb_clr_1(&mut self) -> PB_CLR_1_W<PB_CLR_SPEC> {
                PB_CLR_1_W::new(self, 8)
            }
            ///Bits 16:23 - GPIO PB clear output byte 2
            #[inline(always)]
            #[must_use]
            pub fn pb_clr_2(&mut self) -> PB_CLR_2_W<PB_CLR_SPEC> {
                PB_CLR_2_W::new(self, 16)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///WZ, GPIO PB clear output: 0=keep, 1=clear
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`pb_clr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pb_clr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct PB_CLR_SPEC;
        impl crate::RegisterSpec for PB_CLR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`pb_clr::R`](R) reader structure
        impl crate::Readable for PB_CLR_SPEC {}
        ///`write(|w| ..)` method takes [`pb_clr::W`](W) writer structure
        impl crate::Writable for PB_CLR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets PB_CLR to value 0
        impl crate::Resettable for PB_CLR_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///PB_PU (rw) register accessor: RW, GPIO PB pullup resistance enable
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`pb_pu::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pb_pu::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@pb_pu`]
    ///module
    pub type PB_PU = crate::Reg<pb_pu::PB_PU_SPEC>;
    ///RW, GPIO PB pullup resistance enable
    pub mod pb_pu {
        ///Register `PB_PU` reader
        pub type R = crate::R<PB_PU_SPEC>;
        ///Register `PB_PU` writer
        pub type W = crate::W<PB_PU_SPEC>;
        ///Field `PB_PU_0` reader - GPIO PB pullup resistance enable byte 0
        pub type PB_PU_0_R = crate::FieldReader;
        ///Field `PB_PU_0` writer - GPIO PB pullup resistance enable byte 0
        pub type PB_PU_0_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        ///Field `PB_PU_1` reader - GPIO PB pullup resistance enable byte 1
        pub type PB_PU_1_R = crate::FieldReader;
        ///Field `PB_PU_1` writer - GPIO PB pullup resistance enable byte 1
        pub type PB_PU_1_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        ///Field `PB_PU_2` reader - GPIO PB pullup resistance enable byte 2
        pub type PB_PU_2_R = crate::FieldReader;
        ///Field `PB_PU_2` writer - GPIO PB pullup resistance enable byte 2
        pub type PB_PU_2_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            ///Bits 0:7 - GPIO PB pullup resistance enable byte 0
            #[inline(always)]
            pub fn pb_pu_0(&self) -> PB_PU_0_R {
                PB_PU_0_R::new((self.bits & 0xff) as u8)
            }
            ///Bits 8:15 - GPIO PB pullup resistance enable byte 1
            #[inline(always)]
            pub fn pb_pu_1(&self) -> PB_PU_1_R {
                PB_PU_1_R::new(((self.bits >> 8) & 0xff) as u8)
            }
            ///Bits 16:23 - GPIO PB pullup resistance enable byte 2
            #[inline(always)]
            pub fn pb_pu_2(&self) -> PB_PU_2_R {
                PB_PU_2_R::new(((self.bits >> 16) & 0xff) as u8)
            }
        }
        impl W {
            ///Bits 0:7 - GPIO PB pullup resistance enable byte 0
            #[inline(always)]
            #[must_use]
            pub fn pb_pu_0(&mut self) -> PB_PU_0_W<PB_PU_SPEC> {
                PB_PU_0_W::new(self, 0)
            }
            ///Bits 8:15 - GPIO PB pullup resistance enable byte 1
            #[inline(always)]
            #[must_use]
            pub fn pb_pu_1(&mut self) -> PB_PU_1_W<PB_PU_SPEC> {
                PB_PU_1_W::new(self, 8)
            }
            ///Bits 16:23 - GPIO PB pullup resistance enable byte 2
            #[inline(always)]
            #[must_use]
            pub fn pb_pu_2(&mut self) -> PB_PU_2_W<PB_PU_SPEC> {
                PB_PU_2_W::new(self, 16)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW, GPIO PB pullup resistance enable
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`pb_pu::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pb_pu::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct PB_PU_SPEC;
        impl crate::RegisterSpec for PB_PU_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`pb_pu::R`](R) reader structure
        impl crate::Readable for PB_PU_SPEC {}
        ///`write(|w| ..)` method takes [`pb_pu::W`](W) writer structure
        impl crate::Writable for PB_PU_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets PB_PU to value 0
        impl crate::Resettable for PB_PU_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///PB_PD_DRV (rw) register accessor: RW, PB pulldown for input or PB driving capability for output
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`pb_pd_drv::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pb_pd_drv::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@pb_pd_drv`]
    ///module
    pub type PB_PD_DRV = crate::Reg<pb_pd_drv::PB_PD_DRV_SPEC>;
    ///RW, PB pulldown for input or PB driving capability for output
    pub mod pb_pd_drv {
        ///Register `PB_PD_DRV` reader
        pub type R = crate::R<PB_PD_DRV_SPEC>;
        ///Register `PB_PD_DRV` writer
        pub type W = crate::W<PB_PD_DRV_SPEC>;
        ///Field `PB_PD_DRV_0` reader - PB pulldown for input or PB driving capability for output byte 0
        pub type PB_PD_DRV_0_R = crate::FieldReader;
        ///Field `PB_PD_DRV_0` writer - PB pulldown for input or PB driving capability for output byte 0
        pub type PB_PD_DRV_0_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        ///Field `PB_PD_DRV_1` reader - PB pulldown for input or PB driving capability for output byte 0
        pub type PB_PD_DRV_1_R = crate::FieldReader;
        ///Field `PB_PD_DRV_1` writer - PB pulldown for input or PB driving capability for output byte 0
        pub type PB_PD_DRV_1_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        ///Field `PB_PD_DRV_2` reader - PB pulldown for input or PB driving capability for output byte 0
        pub type PB_PD_DRV_2_R = crate::FieldReader;
        ///Field `PB_PD_DRV_2` writer - PB pulldown for input or PB driving capability for output byte 0
        pub type PB_PD_DRV_2_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            ///Bits 0:7 - PB pulldown for input or PB driving capability for output byte 0
            #[inline(always)]
            pub fn pb_pd_drv_0(&self) -> PB_PD_DRV_0_R {
                PB_PD_DRV_0_R::new((self.bits & 0xff) as u8)
            }
            ///Bits 8:15 - PB pulldown for input or PB driving capability for output byte 0
            #[inline(always)]
            pub fn pb_pd_drv_1(&self) -> PB_PD_DRV_1_R {
                PB_PD_DRV_1_R::new(((self.bits >> 8) & 0xff) as u8)
            }
            ///Bits 16:23 - PB pulldown for input or PB driving capability for output byte 0
            #[inline(always)]
            pub fn pb_pd_drv_2(&self) -> PB_PD_DRV_2_R {
                PB_PD_DRV_2_R::new(((self.bits >> 16) & 0xff) as u8)
            }
        }
        impl W {
            ///Bits 0:7 - PB pulldown for input or PB driving capability for output byte 0
            #[inline(always)]
            #[must_use]
            pub fn pb_pd_drv_0(&mut self) -> PB_PD_DRV_0_W<PB_PD_DRV_SPEC> {
                PB_PD_DRV_0_W::new(self, 0)
            }
            ///Bits 8:15 - PB pulldown for input or PB driving capability for output byte 0
            #[inline(always)]
            #[must_use]
            pub fn pb_pd_drv_1(&mut self) -> PB_PD_DRV_1_W<PB_PD_DRV_SPEC> {
                PB_PD_DRV_1_W::new(self, 8)
            }
            ///Bits 16:23 - PB pulldown for input or PB driving capability for output byte 0
            #[inline(always)]
            #[must_use]
            pub fn pb_pd_drv_2(&mut self) -> PB_PD_DRV_2_W<PB_PD_DRV_SPEC> {
                PB_PD_DRV_2_W::new(self, 16)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW, PB pulldown for input or PB driving capability for output
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`pb_pd_drv::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pb_pd_drv::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct PB_PD_DRV_SPEC;
        impl crate::RegisterSpec for PB_PD_DRV_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`pb_pd_drv::R`](R) reader structure
        impl crate::Readable for PB_PD_DRV_SPEC {}
        ///`write(|w| ..)` method takes [`pb_pd_drv::W`](W) writer structure
        impl crate::Writable for PB_PD_DRV_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets PB_PD_DRV to value 0
        impl crate::Resettable for PB_PD_DRV_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///FLASH_CFG (rw) register accessor: Flash configuration
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`flash_cfg::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`flash_cfg::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@flash_cfg`]
    ///module
    pub type FLASH_CFG = crate::Reg<flash_cfg::FLASH_CFG_SPEC>;
    ///Flash configuration
    pub mod flash_cfg {
        ///Register `FLASH_CFG` reader
        pub type R = crate::R<FLASH_CFG_SPEC>;
        ///Register `FLASH_CFG` writer
        pub type W = crate::W<FLASH_CFG_SPEC>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<FLASH_CFG_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                core::fmt::Debug::fmt(&self.read(), f)
            }
        }
        impl W {
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Flash configuration
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`flash_cfg::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`flash_cfg::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct FLASH_CFG_SPEC;
        impl crate::RegisterSpec for FLASH_CFG_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`flash_cfg::R`](R) reader structure
        impl crate::Readable for FLASH_CFG_SPEC {}
        ///`write(|w| ..)` method takes [`flash_cfg::W`](W) writer structure
        impl crate::Writable for FLASH_CFG_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets FLASH_CFG to value 0
        impl crate::Resettable for FLASH_CFG_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
}
///Timer0 register
pub struct TMR0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for TMR0 {}
impl TMR0 {
    ///Pointer to the register block
    pub const PTR: *const tmr0::RegisterBlock = 0x4000_2000 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const tmr0::RegisterBlock {
        Self::PTR
    }
    /// Steal an instance of this peripheral
    ///
    /// # Safety
    ///
    /// Ensure that the new instance of the peripheral cannot be used in a way
    /// that may race with any existing instances, for example by only
    /// accessing read-only or write-only registers, or by consuming the
    /// original peripheral and using critical sections to coordinate
    /// access between multiple new instances.
    ///
    /// Additionally, other software such as HALs may rely on only one
    /// peripheral instance existing to ensure memory safety; ensure
    /// no stolen instances are passed to such software.
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for TMR0 {
    type Target = tmr0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for TMR0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("TMR0").finish()
    }
}
///Timer0 register
pub mod tmr0 {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        ctrl_mod: CTRL_MOD,
        _reserved1: [u8; 0x01],
        inter_en: INTER_EN,
        _reserved2: [u8; 0x03],
        int_flag: INT_FLAG,
        fifo_count: FIFO_COUNT,
        count: COUNT,
        cnt_end: CNT_END,
        fifo: FIFO,
    }
    impl RegisterBlock {
        ///0x00 - RW, TMR0 mode control
        #[inline(always)]
        pub const fn ctrl_mod(&self) -> &CTRL_MOD {
            &self.ctrl_mod
        }
        ///0x02 - RW, TMR0 interrupt enable
        #[inline(always)]
        pub const fn inter_en(&self) -> &INTER_EN {
            &self.inter_en
        }
        ///0x06 - RW1, TMR0 interrupt flag
        #[inline(always)]
        pub const fn int_flag(&self) -> &INT_FLAG {
            &self.int_flag
        }
        ///0x07 - RO, TMR0 FIFO count status
        #[inline(always)]
        pub const fn fifo_count(&self) -> &FIFO_COUNT {
            &self.fifo_count
        }
        ///0x08 - RO, TMR0 current count
        #[inline(always)]
        pub const fn count(&self) -> &COUNT {
            &self.count
        }
        ///0x0c - RW, TMR0 end count value, only low 26 bit
        #[inline(always)]
        pub const fn cnt_end(&self) -> &CNT_END {
            &self.cnt_end
        }
        ///0x10 - RO/WO, TMR0 FIFO register, only low 26 bit
        #[inline(always)]
        pub const fn fifo(&self) -> &FIFO {
            &self.fifo
        }
    }
    ///CTRL_MOD (rw) register accessor: RW, TMR0 mode control
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`ctrl_mod::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ctrl_mod::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@ctrl_mod`]
    ///module
    pub type CTRL_MOD = crate::Reg<ctrl_mod::CTRL_MOD_SPEC>;
    ///RW, TMR0 mode control
    pub mod ctrl_mod {
        ///Register `CTRL_MOD` reader
        pub type R = crate::R<CTRL_MOD_SPEC>;
        ///Register `CTRL_MOD` writer
        pub type W = crate::W<CTRL_MOD_SPEC>;
        ///Field `TMR_MODE_IN` reader - RW, timer in mode: 0=timer/PWM, 1=capture/count
        pub type TMR_MODE_IN_R = crate::BitReader;
        ///Field `TMR_MODE_IN` writer - RW, timer in mode: 0=timer/PWM, 1=capture/count
        pub type TMR_MODE_IN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TMR_ALL_CLEAR` reader - RW, force clear timer FIFO and count
        pub type TMR_ALL_CLEAR_R = crate::BitReader;
        ///Field `TMR_ALL_CLEAR` writer - RW, force clear timer FIFO and count
        pub type TMR_ALL_CLEAR_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TMR_COUNT_EN` reader - RW, timer count enable
        pub type TMR_COUNT_EN_R = crate::BitReader;
        ///Field `TMR_COUNT_EN` writer - RW, timer count enable
        pub type TMR_COUNT_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TMR_OUT_EN` reader - RW, timer output enable
        pub type TMR_OUT_EN_R = crate::BitReader;
        ///Field `TMR_OUT_EN` writer - RW, timer output enable
        pub type TMR_OUT_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TMR_OUT_POLAR__RB_TMR_CAP_COUNT` reader - RW, timer PWM output polarity: 0=default low and high action, 1=default high and low action;RW, count sub-mode if RB_TMR_MODE_IN=1: 0=capture, 1=count
        pub type TMR_OUT_POLAR__RB_TMR_CAP_COUNT_R = crate::BitReader;
        ///Field `TMR_OUT_POLAR__RB_TMR_CAP_COUNT` writer - RW, timer PWM output polarity: 0=default low and high action, 1=default high and low action;RW, count sub-mode if RB_TMR_MODE_IN=1: 0=capture, 1=count
        pub type TMR_OUT_POLAR__RB_TMR_CAP_COUNT_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TMR_PWM_REPEAT__RB_TMR_CAP_EDGE` reader - RW, timer PWM repeat mode: 00=1, 01=4, 10=8, 11-16;RW, timer capture edge mode: 00=disable, 01=edge change, 10=fall to fall, 11-rise to rise
        pub type TMR_PWM_REPEAT__RB_TMR_CAP_EDGE_R = crate::FieldReader;
        ///Field `TMR_PWM_REPEAT__RB_TMR_CAP_EDGE` writer - RW, timer PWM repeat mode: 00=1, 01=4, 10=8, 11-16;RW, timer capture edge mode: 00=disable, 01=edge change, 10=fall to fall, 11-rise to rise
        pub type TMR_PWM_REPEAT__RB_TMR_CAP_EDGE_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        impl R {
            ///Bit 0 - RW, timer in mode: 0=timer/PWM, 1=capture/count
            #[inline(always)]
            pub fn tmr_mode_in(&self) -> TMR_MODE_IN_R {
                TMR_MODE_IN_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RW, force clear timer FIFO and count
            #[inline(always)]
            pub fn tmr_all_clear(&self) -> TMR_ALL_CLEAR_R {
                TMR_ALL_CLEAR_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RW, timer count enable
            #[inline(always)]
            pub fn tmr_count_en(&self) -> TMR_COUNT_EN_R {
                TMR_COUNT_EN_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RW, timer output enable
            #[inline(always)]
            pub fn tmr_out_en(&self) -> TMR_OUT_EN_R {
                TMR_OUT_EN_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RW, timer PWM output polarity: 0=default low and high action, 1=default high and low action;RW, count sub-mode if RB_TMR_MODE_IN=1: 0=capture, 1=count
            #[inline(always)]
            pub fn tmr_out_polar__rb_tmr_cap_count(&self) -> TMR_OUT_POLAR__RB_TMR_CAP_COUNT_R {
                TMR_OUT_POLAR__RB_TMR_CAP_COUNT_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bits 6:7 - RW, timer PWM repeat mode: 00=1, 01=4, 10=8, 11-16;RW, timer capture edge mode: 00=disable, 01=edge change, 10=fall to fall, 11-rise to rise
            #[inline(always)]
            pub fn tmr_pwm_repeat__rb_tmr_cap_edge(&self) -> TMR_PWM_REPEAT__RB_TMR_CAP_EDGE_R {
                TMR_PWM_REPEAT__RB_TMR_CAP_EDGE_R::new((self.bits >> 6) & 3)
            }
        }
        impl W {
            ///Bit 0 - RW, timer in mode: 0=timer/PWM, 1=capture/count
            #[inline(always)]
            #[must_use]
            pub fn tmr_mode_in(&mut self) -> TMR_MODE_IN_W<CTRL_MOD_SPEC> {
                TMR_MODE_IN_W::new(self, 0)
            }
            ///Bit 1 - RW, force clear timer FIFO and count
            #[inline(always)]
            #[must_use]
            pub fn tmr_all_clear(&mut self) -> TMR_ALL_CLEAR_W<CTRL_MOD_SPEC> {
                TMR_ALL_CLEAR_W::new(self, 1)
            }
            ///Bit 2 - RW, timer count enable
            #[inline(always)]
            #[must_use]
            pub fn tmr_count_en(&mut self) -> TMR_COUNT_EN_W<CTRL_MOD_SPEC> {
                TMR_COUNT_EN_W::new(self, 2)
            }
            ///Bit 3 - RW, timer output enable
            #[inline(always)]
            #[must_use]
            pub fn tmr_out_en(&mut self) -> TMR_OUT_EN_W<CTRL_MOD_SPEC> {
                TMR_OUT_EN_W::new(self, 3)
            }
            ///Bit 4 - RW, timer PWM output polarity: 0=default low and high action, 1=default high and low action;RW, count sub-mode if RB_TMR_MODE_IN=1: 0=capture, 1=count
            #[inline(always)]
            #[must_use]
            pub fn tmr_out_polar__rb_tmr_cap_count(
                &mut self,
            ) -> TMR_OUT_POLAR__RB_TMR_CAP_COUNT_W<CTRL_MOD_SPEC> {
                TMR_OUT_POLAR__RB_TMR_CAP_COUNT_W::new(self, 4)
            }
            ///Bits 6:7 - RW, timer PWM repeat mode: 00=1, 01=4, 10=8, 11-16;RW, timer capture edge mode: 00=disable, 01=edge change, 10=fall to fall, 11-rise to rise
            #[inline(always)]
            #[must_use]
            pub fn tmr_pwm_repeat__rb_tmr_cap_edge(
                &mut self,
            ) -> TMR_PWM_REPEAT__RB_TMR_CAP_EDGE_W<CTRL_MOD_SPEC> {
                TMR_PWM_REPEAT__RB_TMR_CAP_EDGE_W::new(self, 6)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW, TMR0 mode control
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`ctrl_mod::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ctrl_mod::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct CTRL_MOD_SPEC;
        impl crate::RegisterSpec for CTRL_MOD_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`ctrl_mod::R`](R) reader structure
        impl crate::Readable for CTRL_MOD_SPEC {}
        ///`write(|w| ..)` method takes [`ctrl_mod::W`](W) writer structure
        impl crate::Writable for CTRL_MOD_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets CTRL_MOD to value 0x02
        impl crate::Resettable for CTRL_MOD_SPEC {
            const RESET_VALUE: u8 = 0x02;
        }
    }
    ///INTER_EN (rw) register accessor: RW, TMR0 interrupt enable
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`inter_en::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`inter_en::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@inter_en`]
    ///module
    pub type INTER_EN = crate::Reg<inter_en::INTER_EN_SPEC>;
    ///RW, TMR0 interrupt enable
    pub mod inter_en {
        ///Register `INTER_EN` reader
        pub type R = crate::R<INTER_EN_SPEC>;
        ///Register `INTER_EN` writer
        pub type W = crate::W<INTER_EN_SPEC>;
        ///Field `TMR_IE_CYC_END` reader - RW, enable interrupt for timer capture count timeout or PWM cycle end
        pub type TMR_IE_CYC_END_R = crate::BitReader;
        ///Field `TMR_IE_CYC_END` writer - RW, enable interrupt for timer capture count timeout or PWM cycle end
        pub type TMR_IE_CYC_END_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TMR_IE_DATA_ACT` reader - RW, enable interrupt for timer capture input action or PWM trigger
        pub type TMR_IE_DATA_ACT_R = crate::BitReader;
        ///Field `TMR_IE_DATA_ACT` writer - RW, enable interrupt for timer capture input action or PWM trigger
        pub type TMR_IE_DATA_ACT_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TMR_IE_FIFO_HF` reader - RW, enable interrupt for timer FIFO half (capture fifo >=4 or PWM fifo less than 3)
        pub type TMR_IE_FIFO_HF_R = crate::BitReader;
        ///Field `TMR_IE_FIFO_HF` writer - RW, enable interrupt for timer FIFO half (capture fifo >=4 or PWM fifo less than 3)
        pub type TMR_IE_FIFO_HF_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TMR_IE_DMA_END` reader - RW, enable interrupt for timer1/2 DMA completion
        pub type TMR_IE_DMA_END_R = crate::BitReader;
        ///Field `TMR_IE_DMA_END` writer - RW, enable interrupt for timer1/2 DMA completion
        pub type TMR_IE_DMA_END_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TMR_IE_FIFO_OV` reader - RW, enable interrupt for timer FIFO overflow
        pub type TMR_IE_FIFO_OV_R = crate::BitReader;
        ///Field `TMR_IE_FIFO_OV` writer - RW, enable interrupt for timer FIFO overflow
        pub type TMR_IE_FIFO_OV_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - RW, enable interrupt for timer capture count timeout or PWM cycle end
            #[inline(always)]
            pub fn tmr_ie_cyc_end(&self) -> TMR_IE_CYC_END_R {
                TMR_IE_CYC_END_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RW, enable interrupt for timer capture input action or PWM trigger
            #[inline(always)]
            pub fn tmr_ie_data_act(&self) -> TMR_IE_DATA_ACT_R {
                TMR_IE_DATA_ACT_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RW, enable interrupt for timer FIFO half (capture fifo >=4 or PWM fifo less than 3)
            #[inline(always)]
            pub fn tmr_ie_fifo_hf(&self) -> TMR_IE_FIFO_HF_R {
                TMR_IE_FIFO_HF_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RW, enable interrupt for timer1/2 DMA completion
            #[inline(always)]
            pub fn tmr_ie_dma_end(&self) -> TMR_IE_DMA_END_R {
                TMR_IE_DMA_END_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RW, enable interrupt for timer FIFO overflow
            #[inline(always)]
            pub fn tmr_ie_fifo_ov(&self) -> TMR_IE_FIFO_OV_R {
                TMR_IE_FIFO_OV_R::new(((self.bits >> 4) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RW, enable interrupt for timer capture count timeout or PWM cycle end
            #[inline(always)]
            #[must_use]
            pub fn tmr_ie_cyc_end(&mut self) -> TMR_IE_CYC_END_W<INTER_EN_SPEC> {
                TMR_IE_CYC_END_W::new(self, 0)
            }
            ///Bit 1 - RW, enable interrupt for timer capture input action or PWM trigger
            #[inline(always)]
            #[must_use]
            pub fn tmr_ie_data_act(&mut self) -> TMR_IE_DATA_ACT_W<INTER_EN_SPEC> {
                TMR_IE_DATA_ACT_W::new(self, 1)
            }
            ///Bit 2 - RW, enable interrupt for timer FIFO half (capture fifo >=4 or PWM fifo less than 3)
            #[inline(always)]
            #[must_use]
            pub fn tmr_ie_fifo_hf(&mut self) -> TMR_IE_FIFO_HF_W<INTER_EN_SPEC> {
                TMR_IE_FIFO_HF_W::new(self, 2)
            }
            ///Bit 3 - RW, enable interrupt for timer1/2 DMA completion
            #[inline(always)]
            #[must_use]
            pub fn tmr_ie_dma_end(&mut self) -> TMR_IE_DMA_END_W<INTER_EN_SPEC> {
                TMR_IE_DMA_END_W::new(self, 3)
            }
            ///Bit 4 - RW, enable interrupt for timer FIFO overflow
            #[inline(always)]
            #[must_use]
            pub fn tmr_ie_fifo_ov(&mut self) -> TMR_IE_FIFO_OV_W<INTER_EN_SPEC> {
                TMR_IE_FIFO_OV_W::new(self, 4)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW, TMR0 interrupt enable
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`inter_en::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`inter_en::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct INTER_EN_SPEC;
        impl crate::RegisterSpec for INTER_EN_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`inter_en::R`](R) reader structure
        impl crate::Readable for INTER_EN_SPEC {}
        ///`write(|w| ..)` method takes [`inter_en::W`](W) writer structure
        impl crate::Writable for INTER_EN_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets INTER_EN to value 0
        impl crate::Resettable for INTER_EN_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///INT_FLAG (rw) register accessor: RW1, TMR0 interrupt flag
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`int_flag::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`int_flag::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@int_flag`]
    ///module
    pub type INT_FLAG = crate::Reg<int_flag::INT_FLAG_SPEC>;
    ///RW1, TMR0 interrupt flag
    pub mod int_flag {
        ///Register `INT_FLAG` reader
        pub type R = crate::R<INT_FLAG_SPEC>;
        ///Register `INT_FLAG` writer
        pub type W = crate::W<INT_FLAG_SPEC>;
        ///Field `TMR_IF_CYC_END` reader - RW1, interrupt flag for timer capture count timeout or PWM cycle end
        pub type TMR_IF_CYC_END_R = crate::BitReader;
        ///Field `TMR_IF_CYC_END` writer - RW1, interrupt flag for timer capture count timeout or PWM cycle end
        pub type TMR_IF_CYC_END_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TMR_IF_DATA_ACT` reader - RW1, interrupt flag for timer capture input action or PWM trigger
        pub type TMR_IF_DATA_ACT_R = crate::BitReader;
        ///Field `TMR_IF_DATA_ACT` writer - RW1, interrupt flag for timer capture input action or PWM trigger
        pub type TMR_IF_DATA_ACT_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TMR_IF_FIFO_HF` reader - RW1, interrupt flag for timer FIFO half (capture fifo >=4 or PWM fifo less than 3
        pub type TMR_IF_FIFO_HF_R = crate::BitReader;
        ///Field `TMR_IF_FIFO_HF` writer - RW1, interrupt flag for timer FIFO half (capture fifo >=4 or PWM fifo less than 3
        pub type TMR_IF_FIFO_HF_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TMR_IF_DMA_END` reader - RW1, interrupt flag for timer1/2 DMA completion
        pub type TMR_IF_DMA_END_R = crate::BitReader;
        ///Field `TMR_IF_DMA_END` writer - RW1, interrupt flag for timer1/2 DMA completion
        pub type TMR_IF_DMA_END_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TMR_IF_FIFO_OV` reader - RW1, interrupt flag for timer FIFO overflow
        pub type TMR_IF_FIFO_OV_R = crate::BitReader;
        ///Field `TMR_IF_FIFO_OV` writer - RW1, interrupt flag for timer FIFO overflow
        pub type TMR_IF_FIFO_OV_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - RW1, interrupt flag for timer capture count timeout or PWM cycle end
            #[inline(always)]
            pub fn tmr_if_cyc_end(&self) -> TMR_IF_CYC_END_R {
                TMR_IF_CYC_END_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RW1, interrupt flag for timer capture input action or PWM trigger
            #[inline(always)]
            pub fn tmr_if_data_act(&self) -> TMR_IF_DATA_ACT_R {
                TMR_IF_DATA_ACT_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RW1, interrupt flag for timer FIFO half (capture fifo >=4 or PWM fifo less than 3
            #[inline(always)]
            pub fn tmr_if_fifo_hf(&self) -> TMR_IF_FIFO_HF_R {
                TMR_IF_FIFO_HF_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RW1, interrupt flag for timer1/2 DMA completion
            #[inline(always)]
            pub fn tmr_if_dma_end(&self) -> TMR_IF_DMA_END_R {
                TMR_IF_DMA_END_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RW1, interrupt flag for timer FIFO overflow
            #[inline(always)]
            pub fn tmr_if_fifo_ov(&self) -> TMR_IF_FIFO_OV_R {
                TMR_IF_FIFO_OV_R::new(((self.bits >> 4) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RW1, interrupt flag for timer capture count timeout or PWM cycle end
            #[inline(always)]
            #[must_use]
            pub fn tmr_if_cyc_end(&mut self) -> TMR_IF_CYC_END_W<INT_FLAG_SPEC> {
                TMR_IF_CYC_END_W::new(self, 0)
            }
            ///Bit 1 - RW1, interrupt flag for timer capture input action or PWM trigger
            #[inline(always)]
            #[must_use]
            pub fn tmr_if_data_act(&mut self) -> TMR_IF_DATA_ACT_W<INT_FLAG_SPEC> {
                TMR_IF_DATA_ACT_W::new(self, 1)
            }
            ///Bit 2 - RW1, interrupt flag for timer FIFO half (capture fifo >=4 or PWM fifo less than 3
            #[inline(always)]
            #[must_use]
            pub fn tmr_if_fifo_hf(&mut self) -> TMR_IF_FIFO_HF_W<INT_FLAG_SPEC> {
                TMR_IF_FIFO_HF_W::new(self, 2)
            }
            ///Bit 3 - RW1, interrupt flag for timer1/2 DMA completion
            #[inline(always)]
            #[must_use]
            pub fn tmr_if_dma_end(&mut self) -> TMR_IF_DMA_END_W<INT_FLAG_SPEC> {
                TMR_IF_DMA_END_W::new(self, 3)
            }
            ///Bit 4 - RW1, interrupt flag for timer FIFO overflow
            #[inline(always)]
            #[must_use]
            pub fn tmr_if_fifo_ov(&mut self) -> TMR_IF_FIFO_OV_W<INT_FLAG_SPEC> {
                TMR_IF_FIFO_OV_W::new(self, 4)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW1, TMR0 interrupt flag
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`int_flag::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`int_flag::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct INT_FLAG_SPEC;
        impl crate::RegisterSpec for INT_FLAG_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`int_flag::R`](R) reader structure
        impl crate::Readable for INT_FLAG_SPEC {}
        ///`write(|w| ..)` method takes [`int_flag::W`](W) writer structure
        impl crate::Writable for INT_FLAG_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets INT_FLAG to value 0
        impl crate::Resettable for INT_FLAG_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///FIFO_COUNT (r) register accessor: RO, TMR0 FIFO count status
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`fifo_count::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@fifo_count`]
    ///module
    pub type FIFO_COUNT = crate::Reg<fifo_count::FIFO_COUNT_SPEC>;
    ///RO, TMR0 FIFO count status
    pub mod fifo_count {
        ///Register `FIFO_COUNT` reader
        pub type R = crate::R<FIFO_COUNT_SPEC>;
        ///Field `FIFO_COUNT` reader - RW1,TMR0 FIFO count status
        pub type FIFO_COUNT_R = crate::FieldReader;
        impl R {
            ///Bits 0:7 - RW1,TMR0 FIFO count status
            #[inline(always)]
            pub fn fifo_count(&self) -> FIFO_COUNT_R {
                FIFO_COUNT_R::new(self.bits)
            }
        }
        ///RO, TMR0 FIFO count status
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`fifo_count::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct FIFO_COUNT_SPEC;
        impl crate::RegisterSpec for FIFO_COUNT_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`fifo_count::R`](R) reader structure
        impl crate::Readable for FIFO_COUNT_SPEC {}
        ///`reset()` method sets FIFO_COUNT to value 0
        impl crate::Resettable for FIFO_COUNT_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///COUNT (r) register accessor: RO, TMR0 current count
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`count::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@count`]
    ///module
    pub type COUNT = crate::Reg<count::COUNT_SPEC>;
    ///RO, TMR0 current count
    pub mod count {
        ///Register `COUNT` reader
        pub type R = crate::R<COUNT_SPEC>;
        ///Field `COUNT` reader - RW1,TMR0 current count
        pub type COUNT_R = crate::FieldReader<u32>;
        impl R {
            ///Bits 0:31 - RW1,TMR0 current count
            #[inline(always)]
            pub fn count(&self) -> COUNT_R {
                COUNT_R::new(self.bits)
            }
        }
        ///RO, TMR0 current count
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`count::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct COUNT_SPEC;
        impl crate::RegisterSpec for COUNT_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`count::R`](R) reader structure
        impl crate::Readable for COUNT_SPEC {}
        ///`reset()` method sets COUNT to value 0
        impl crate::Resettable for COUNT_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///CNT_END (rw) register accessor: RW, TMR0 end count value, only low 26 bit
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`cnt_end::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cnt_end::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@cnt_end`]
    ///module
    pub type CNT_END = crate::Reg<cnt_end::CNT_END_SPEC>;
    ///RW, TMR0 end count value, only low 26 bit
    pub mod cnt_end {
        ///Register `CNT_END` reader
        pub type R = crate::R<CNT_END_SPEC>;
        ///Register `CNT_END` writer
        pub type W = crate::W<CNT_END_SPEC>;
        ///Field `CNT_END` reader - RW1,TMR0 end count value
        pub type CNT_END_R = crate::FieldReader<u32>;
        ///Field `CNT_END` writer - RW1,TMR0 end count value
        pub type CNT_END_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - RW1,TMR0 end count value
            #[inline(always)]
            pub fn cnt_end(&self) -> CNT_END_R {
                CNT_END_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW1,TMR0 end count value
            #[inline(always)]
            #[must_use]
            pub fn cnt_end(&mut self) -> CNT_END_W<CNT_END_SPEC> {
                CNT_END_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW, TMR0 end count value, only low 26 bit
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`cnt_end::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cnt_end::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct CNT_END_SPEC;
        impl crate::RegisterSpec for CNT_END_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`cnt_end::R`](R) reader structure
        impl crate::Readable for CNT_END_SPEC {}
        ///`write(|w| ..)` method takes [`cnt_end::W`](W) writer structure
        impl crate::Writable for CNT_END_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets CNT_END to value 0
        impl crate::Resettable for CNT_END_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///FIFO (r) register accessor: RO/WO, TMR0 FIFO register, only low 26 bit
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`fifo::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@fifo`]
    ///module
    pub type FIFO = crate::Reg<fifo::FIFO_SPEC>;
    ///RO/WO, TMR0 FIFO register, only low 26 bit
    pub mod fifo {
        ///Register `FIFO` reader
        pub type R = crate::R<FIFO_SPEC>;
        ///Field `FIFO` reader - RW1,TMR0 FIFO register
        pub type FIFO_R = crate::FieldReader<u32>;
        impl R {
            ///Bits 0:31 - RW1,TMR0 FIFO register
            #[inline(always)]
            pub fn fifo(&self) -> FIFO_R {
                FIFO_R::new(self.bits)
            }
        }
        ///RO/WO, TMR0 FIFO register, only low 26 bit
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`fifo::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct FIFO_SPEC;
        impl crate::RegisterSpec for FIFO_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`fifo::R`](R) reader structure
        impl crate::Readable for FIFO_SPEC {}
        ///`reset()` method sets FIFO to value 0
        impl crate::Resettable for FIFO_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
}
///Timer1 register
pub struct TMR1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for TMR1 {}
impl TMR1 {
    ///Pointer to the register block
    pub const PTR: *const tmr1::RegisterBlock = 0x4000_2400 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const tmr1::RegisterBlock {
        Self::PTR
    }
    /// Steal an instance of this peripheral
    ///
    /// # Safety
    ///
    /// Ensure that the new instance of the peripheral cannot be used in a way
    /// that may race with any existing instances, for example by only
    /// accessing read-only or write-only registers, or by consuming the
    /// original peripheral and using critical sections to coordinate
    /// access between multiple new instances.
    ///
    /// Additionally, other software such as HALs may rely on only one
    /// peripheral instance existing to ensure memory safety; ensure
    /// no stolen instances are passed to such software.
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for TMR1 {
    type Target = tmr1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for TMR1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("TMR1").finish()
    }
}
///Timer1 register
pub mod tmr1 {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        ctrl_mod: CTRL_MOD,
        ctrl_dma: CTRL_DMA,
        inter_en: INTER_EN,
        _reserved3: [u8; 0x03],
        int_flag: INT_FLAG,
        fifo_count: FIFO_COUNT,
        count: COUNT,
        cnt_end: CNT_END,
        fifo: FIFO,
        dma_now: DMA_NOW,
        _reserved9: [u8; 0x02],
        dma_beg: DMA_BEG,
        _reserved10: [u8; 0x02],
        dma_end: DMA_END,
    }
    impl RegisterBlock {
        ///0x00 - RW, TMR1 mode control
        #[inline(always)]
        pub const fn ctrl_mod(&self) -> &CTRL_MOD {
            &self.ctrl_mod
        }
        ///0x01 - RW, TMR1 DMA control
        #[inline(always)]
        pub const fn ctrl_dma(&self) -> &CTRL_DMA {
            &self.ctrl_dma
        }
        ///0x02 - RW, TMR1 interrupt enable
        #[inline(always)]
        pub const fn inter_en(&self) -> &INTER_EN {
            &self.inter_en
        }
        ///0x06 - RW1, TMR1 interrupt flag
        #[inline(always)]
        pub const fn int_flag(&self) -> &INT_FLAG {
            &self.int_flag
        }
        ///0x07 - RO, TMR1 FIFO count status
        #[inline(always)]
        pub const fn fifo_count(&self) -> &FIFO_COUNT {
            &self.fifo_count
        }
        ///0x08 - RO, TMR1 current count
        #[inline(always)]
        pub const fn count(&self) -> &COUNT {
            &self.count
        }
        ///0x0c - RW, TMR1 end count value, only low 26 bit
        #[inline(always)]
        pub const fn cnt_end(&self) -> &CNT_END {
            &self.cnt_end
        }
        ///0x10 - RO, TMR1 FIFO register, only low 26 bit
        #[inline(always)]
        pub const fn fifo(&self) -> &FIFO {
            &self.fifo
        }
        ///0x14 - RO, TMR1 DMA current address
        #[inline(always)]
        pub const fn dma_now(&self) -> &DMA_NOW {
            &self.dma_now
        }
        ///0x18 - RW, TMR1 DMA begin address
        #[inline(always)]
        pub const fn dma_beg(&self) -> &DMA_BEG {
            &self.dma_beg
        }
        ///0x1c - RW, TMR1 DMA end address
        #[inline(always)]
        pub const fn dma_end(&self) -> &DMA_END {
            &self.dma_end
        }
    }
    ///CTRL_MOD (rw) register accessor: RW, TMR1 mode control
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`ctrl_mod::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ctrl_mod::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@ctrl_mod`]
    ///module
    pub type CTRL_MOD = crate::Reg<ctrl_mod::CTRL_MOD_SPEC>;
    ///RW, TMR1 mode control
    pub mod ctrl_mod {
        ///Register `CTRL_MOD` reader
        pub type R = crate::R<CTRL_MOD_SPEC>;
        ///Register `CTRL_MOD` writer
        pub type W = crate::W<CTRL_MOD_SPEC>;
        ///Field `TMR_MODE_IN` reader - RW, timer in mode: 0=timer/PWM, 1=capture/count
        pub type TMR_MODE_IN_R = crate::BitReader;
        ///Field `TMR_MODE_IN` writer - RW, timer in mode: 0=timer/PWM, 1=capture/count
        pub type TMR_MODE_IN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TMR_ALL_CLEAR` reader - RW, force clear timer FIFO and count
        pub type TMR_ALL_CLEAR_R = crate::BitReader;
        ///Field `TMR_ALL_CLEAR` writer - RW, force clear timer FIFO and count
        pub type TMR_ALL_CLEAR_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TMR_COUNT_EN` reader - RW, timer count enable
        pub type TMR_COUNT_EN_R = crate::BitReader;
        ///Field `TMR_COUNT_EN` writer - RW, timer count enable
        pub type TMR_COUNT_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TMR_OUT_EN` reader - RW, timer output enable
        pub type TMR_OUT_EN_R = crate::BitReader;
        ///Field `TMR_OUT_EN` writer - RW, timer output enable
        pub type TMR_OUT_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TMR_OUT_POLAR__RB_TMR_CAP_COUNT` reader - RW, timer PWM output polarity: 0=default low and high action, 1=default high and low action;RW, count sub-mode if RB_TMR_MODE_IN=1: 0=capture, 1=count
        pub type TMR_OUT_POLAR__RB_TMR_CAP_COUNT_R = crate::BitReader;
        ///Field `TMR_OUT_POLAR__RB_TMR_CAP_COUNT` writer - RW, timer PWM output polarity: 0=default low and high action, 1=default high and low action;RW, count sub-mode if RB_TMR_MODE_IN=1: 0=capture, 1=count
        pub type TMR_OUT_POLAR__RB_TMR_CAP_COUNT_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TMR_PWM_REPEAT__RB_TMR_CAP_EDGE` reader - RW, timer PWM repeat mode: 00=1, 01=4, 10=8, 11-16;RW, timer capture edge mode: 00=disable, 01=edge change, 10=fall to fall, 11-rise to rise
        pub type TMR_PWM_REPEAT__RB_TMR_CAP_EDGE_R = crate::FieldReader;
        ///Field `TMR_PWM_REPEAT__RB_TMR_CAP_EDGE` writer - RW, timer PWM repeat mode: 00=1, 01=4, 10=8, 11-16;RW, timer capture edge mode: 00=disable, 01=edge change, 10=fall to fall, 11-rise to rise
        pub type TMR_PWM_REPEAT__RB_TMR_CAP_EDGE_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        impl R {
            ///Bit 0 - RW, timer in mode: 0=timer/PWM, 1=capture/count
            #[inline(always)]
            pub fn tmr_mode_in(&self) -> TMR_MODE_IN_R {
                TMR_MODE_IN_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RW, force clear timer FIFO and count
            #[inline(always)]
            pub fn tmr_all_clear(&self) -> TMR_ALL_CLEAR_R {
                TMR_ALL_CLEAR_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RW, timer count enable
            #[inline(always)]
            pub fn tmr_count_en(&self) -> TMR_COUNT_EN_R {
                TMR_COUNT_EN_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RW, timer output enable
            #[inline(always)]
            pub fn tmr_out_en(&self) -> TMR_OUT_EN_R {
                TMR_OUT_EN_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RW, timer PWM output polarity: 0=default low and high action, 1=default high and low action;RW, count sub-mode if RB_TMR_MODE_IN=1: 0=capture, 1=count
            #[inline(always)]
            pub fn tmr_out_polar__rb_tmr_cap_count(&self) -> TMR_OUT_POLAR__RB_TMR_CAP_COUNT_R {
                TMR_OUT_POLAR__RB_TMR_CAP_COUNT_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bits 6:7 - RW, timer PWM repeat mode: 00=1, 01=4, 10=8, 11-16;RW, timer capture edge mode: 00=disable, 01=edge change, 10=fall to fall, 11-rise to rise
            #[inline(always)]
            pub fn tmr_pwm_repeat__rb_tmr_cap_edge(&self) -> TMR_PWM_REPEAT__RB_TMR_CAP_EDGE_R {
                TMR_PWM_REPEAT__RB_TMR_CAP_EDGE_R::new((self.bits >> 6) & 3)
            }
        }
        impl W {
            ///Bit 0 - RW, timer in mode: 0=timer/PWM, 1=capture/count
            #[inline(always)]
            #[must_use]
            pub fn tmr_mode_in(&mut self) -> TMR_MODE_IN_W<CTRL_MOD_SPEC> {
                TMR_MODE_IN_W::new(self, 0)
            }
            ///Bit 1 - RW, force clear timer FIFO and count
            #[inline(always)]
            #[must_use]
            pub fn tmr_all_clear(&mut self) -> TMR_ALL_CLEAR_W<CTRL_MOD_SPEC> {
                TMR_ALL_CLEAR_W::new(self, 1)
            }
            ///Bit 2 - RW, timer count enable
            #[inline(always)]
            #[must_use]
            pub fn tmr_count_en(&mut self) -> TMR_COUNT_EN_W<CTRL_MOD_SPEC> {
                TMR_COUNT_EN_W::new(self, 2)
            }
            ///Bit 3 - RW, timer output enable
            #[inline(always)]
            #[must_use]
            pub fn tmr_out_en(&mut self) -> TMR_OUT_EN_W<CTRL_MOD_SPEC> {
                TMR_OUT_EN_W::new(self, 3)
            }
            ///Bit 4 - RW, timer PWM output polarity: 0=default low and high action, 1=default high and low action;RW, count sub-mode if RB_TMR_MODE_IN=1: 0=capture, 1=count
            #[inline(always)]
            #[must_use]
            pub fn tmr_out_polar__rb_tmr_cap_count(
                &mut self,
            ) -> TMR_OUT_POLAR__RB_TMR_CAP_COUNT_W<CTRL_MOD_SPEC> {
                TMR_OUT_POLAR__RB_TMR_CAP_COUNT_W::new(self, 4)
            }
            ///Bits 6:7 - RW, timer PWM repeat mode: 00=1, 01=4, 10=8, 11-16;RW, timer capture edge mode: 00=disable, 01=edge change, 10=fall to fall, 11-rise to rise
            #[inline(always)]
            #[must_use]
            pub fn tmr_pwm_repeat__rb_tmr_cap_edge(
                &mut self,
            ) -> TMR_PWM_REPEAT__RB_TMR_CAP_EDGE_W<CTRL_MOD_SPEC> {
                TMR_PWM_REPEAT__RB_TMR_CAP_EDGE_W::new(self, 6)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW, TMR1 mode control
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`ctrl_mod::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ctrl_mod::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct CTRL_MOD_SPEC;
        impl crate::RegisterSpec for CTRL_MOD_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`ctrl_mod::R`](R) reader structure
        impl crate::Readable for CTRL_MOD_SPEC {}
        ///`write(|w| ..)` method takes [`ctrl_mod::W`](W) writer structure
        impl crate::Writable for CTRL_MOD_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets CTRL_MOD to value 0x02
        impl crate::Resettable for CTRL_MOD_SPEC {
            const RESET_VALUE: u8 = 0x02;
        }
    }
    ///CTRL_DMA (rw) register accessor: RW, TMR1 DMA control
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`ctrl_dma::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ctrl_dma::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@ctrl_dma`]
    ///module
    pub type CTRL_DMA = crate::Reg<ctrl_dma::CTRL_DMA_SPEC>;
    ///RW, TMR1 DMA control
    pub mod ctrl_dma {
        ///Register `CTRL_DMA` reader
        pub type R = crate::R<CTRL_DMA_SPEC>;
        ///Register `CTRL_DMA` writer
        pub type W = crate::W<CTRL_DMA_SPEC>;
        ///Field `TMR_DMA_ENABLE` reader - RW, timer1/2 DMA enable
        pub type TMR_DMA_ENABLE_R = crate::BitReader;
        ///Field `TMR_DMA_ENABLE` writer - RW, timer1/2 DMA enable
        pub type TMR_DMA_ENABLE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TMR_DMA_LOOP` reader - RW, timer1/2 DMA address loop enable
        pub type TMR_DMA_LOOP_R = crate::BitReader;
        ///Field `TMR_DMA_LOOP` writer - RW, timer1/2 DMA address loop enable
        pub type TMR_DMA_LOOP_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - RW, timer1/2 DMA enable
            #[inline(always)]
            pub fn tmr_dma_enable(&self) -> TMR_DMA_ENABLE_R {
                TMR_DMA_ENABLE_R::new((self.bits & 1) != 0)
            }
            ///Bit 2 - RW, timer1/2 DMA address loop enable
            #[inline(always)]
            pub fn tmr_dma_loop(&self) -> TMR_DMA_LOOP_R {
                TMR_DMA_LOOP_R::new(((self.bits >> 2) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RW, timer1/2 DMA enable
            #[inline(always)]
            #[must_use]
            pub fn tmr_dma_enable(&mut self) -> TMR_DMA_ENABLE_W<CTRL_DMA_SPEC> {
                TMR_DMA_ENABLE_W::new(self, 0)
            }
            ///Bit 2 - RW, timer1/2 DMA address loop enable
            #[inline(always)]
            #[must_use]
            pub fn tmr_dma_loop(&mut self) -> TMR_DMA_LOOP_W<CTRL_DMA_SPEC> {
                TMR_DMA_LOOP_W::new(self, 2)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW, TMR1 DMA control
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`ctrl_dma::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ctrl_dma::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct CTRL_DMA_SPEC;
        impl crate::RegisterSpec for CTRL_DMA_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`ctrl_dma::R`](R) reader structure
        impl crate::Readable for CTRL_DMA_SPEC {}
        ///`write(|w| ..)` method takes [`ctrl_dma::W`](W) writer structure
        impl crate::Writable for CTRL_DMA_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets CTRL_DMA to value 0
        impl crate::Resettable for CTRL_DMA_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///INTER_EN (rw) register accessor: RW, TMR1 interrupt enable
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`inter_en::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`inter_en::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@inter_en`]
    ///module
    pub type INTER_EN = crate::Reg<inter_en::INTER_EN_SPEC>;
    ///RW, TMR1 interrupt enable
    pub mod inter_en {
        ///Register `INTER_EN` reader
        pub type R = crate::R<INTER_EN_SPEC>;
        ///Register `INTER_EN` writer
        pub type W = crate::W<INTER_EN_SPEC>;
        ///Field `TMR_IE_CYC_END` reader - RW, enable interrupt for timer capture count timeout or PWM cycle end
        pub type TMR_IE_CYC_END_R = crate::BitReader;
        ///Field `TMR_IE_CYC_END` writer - RW, enable interrupt for timer capture count timeout or PWM cycle end
        pub type TMR_IE_CYC_END_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TMR_IE_DATA_ACT` reader - RW, enable interrupt for timer capture input action or PWM trigger
        pub type TMR_IE_DATA_ACT_R = crate::BitReader;
        ///Field `TMR_IE_DATA_ACT` writer - RW, enable interrupt for timer capture input action or PWM trigger
        pub type TMR_IE_DATA_ACT_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TMR_IE_FIFO_HF` reader - RW, enable interrupt for timer FIFO half (capture fifo >=4 or PWM fifo less than 3)
        pub type TMR_IE_FIFO_HF_R = crate::BitReader;
        ///Field `TMR_IE_FIFO_HF` writer - RW, enable interrupt for timer FIFO half (capture fifo >=4 or PWM fifo less than 3)
        pub type TMR_IE_FIFO_HF_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TMR_IE_DMA_END` reader - RW, enable interrupt for timer1/2 DMA completion
        pub type TMR_IE_DMA_END_R = crate::BitReader;
        ///Field `TMR_IE_DMA_END` writer - RW, enable interrupt for timer1/2 DMA completion
        pub type TMR_IE_DMA_END_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TMR_IE_FIFO_OV` reader - RW, enable interrupt for timer FIFO overflow
        pub type TMR_IE_FIFO_OV_R = crate::BitReader;
        ///Field `TMR_IE_FIFO_OV` writer - RW, enable interrupt for timer FIFO overflow
        pub type TMR_IE_FIFO_OV_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - RW, enable interrupt for timer capture count timeout or PWM cycle end
            #[inline(always)]
            pub fn tmr_ie_cyc_end(&self) -> TMR_IE_CYC_END_R {
                TMR_IE_CYC_END_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RW, enable interrupt for timer capture input action or PWM trigger
            #[inline(always)]
            pub fn tmr_ie_data_act(&self) -> TMR_IE_DATA_ACT_R {
                TMR_IE_DATA_ACT_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RW, enable interrupt for timer FIFO half (capture fifo >=4 or PWM fifo less than 3)
            #[inline(always)]
            pub fn tmr_ie_fifo_hf(&self) -> TMR_IE_FIFO_HF_R {
                TMR_IE_FIFO_HF_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RW, enable interrupt for timer1/2 DMA completion
            #[inline(always)]
            pub fn tmr_ie_dma_end(&self) -> TMR_IE_DMA_END_R {
                TMR_IE_DMA_END_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RW, enable interrupt for timer FIFO overflow
            #[inline(always)]
            pub fn tmr_ie_fifo_ov(&self) -> TMR_IE_FIFO_OV_R {
                TMR_IE_FIFO_OV_R::new(((self.bits >> 4) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RW, enable interrupt for timer capture count timeout or PWM cycle end
            #[inline(always)]
            #[must_use]
            pub fn tmr_ie_cyc_end(&mut self) -> TMR_IE_CYC_END_W<INTER_EN_SPEC> {
                TMR_IE_CYC_END_W::new(self, 0)
            }
            ///Bit 1 - RW, enable interrupt for timer capture input action or PWM trigger
            #[inline(always)]
            #[must_use]
            pub fn tmr_ie_data_act(&mut self) -> TMR_IE_DATA_ACT_W<INTER_EN_SPEC> {
                TMR_IE_DATA_ACT_W::new(self, 1)
            }
            ///Bit 2 - RW, enable interrupt for timer FIFO half (capture fifo >=4 or PWM fifo less than 3)
            #[inline(always)]
            #[must_use]
            pub fn tmr_ie_fifo_hf(&mut self) -> TMR_IE_FIFO_HF_W<INTER_EN_SPEC> {
                TMR_IE_FIFO_HF_W::new(self, 2)
            }
            ///Bit 3 - RW, enable interrupt for timer1/2 DMA completion
            #[inline(always)]
            #[must_use]
            pub fn tmr_ie_dma_end(&mut self) -> TMR_IE_DMA_END_W<INTER_EN_SPEC> {
                TMR_IE_DMA_END_W::new(self, 3)
            }
            ///Bit 4 - RW, enable interrupt for timer FIFO overflow
            #[inline(always)]
            #[must_use]
            pub fn tmr_ie_fifo_ov(&mut self) -> TMR_IE_FIFO_OV_W<INTER_EN_SPEC> {
                TMR_IE_FIFO_OV_W::new(self, 4)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW, TMR1 interrupt enable
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`inter_en::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`inter_en::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct INTER_EN_SPEC;
        impl crate::RegisterSpec for INTER_EN_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`inter_en::R`](R) reader structure
        impl crate::Readable for INTER_EN_SPEC {}
        ///`write(|w| ..)` method takes [`inter_en::W`](W) writer structure
        impl crate::Writable for INTER_EN_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets INTER_EN to value 0
        impl crate::Resettable for INTER_EN_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///INT_FLAG (rw) register accessor: RW1, TMR1 interrupt flag
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`int_flag::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`int_flag::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@int_flag`]
    ///module
    pub type INT_FLAG = crate::Reg<int_flag::INT_FLAG_SPEC>;
    ///RW1, TMR1 interrupt flag
    pub mod int_flag {
        ///Register `INT_FLAG` reader
        pub type R = crate::R<INT_FLAG_SPEC>;
        ///Register `INT_FLAG` writer
        pub type W = crate::W<INT_FLAG_SPEC>;
        ///Field `TMR_IF_CYC_END` reader - RW1, interrupt flag for timer capture count timeout or PWM cycle end
        pub type TMR_IF_CYC_END_R = crate::BitReader;
        ///Field `TMR_IF_CYC_END` writer - RW1, interrupt flag for timer capture count timeout or PWM cycle end
        pub type TMR_IF_CYC_END_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TMR_IF_DATA_ACT` reader - RW1, interrupt flag for timer capture input action or PWM trigger
        pub type TMR_IF_DATA_ACT_R = crate::BitReader;
        ///Field `TMR_IF_DATA_ACT` writer - RW1, interrupt flag for timer capture input action or PWM trigger
        pub type TMR_IF_DATA_ACT_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TMR_IF_FIFO_HF` reader - RW1, interrupt flag for timer FIFO half (capture fifo >=4 or PWM fifo less than 3
        pub type TMR_IF_FIFO_HF_R = crate::BitReader;
        ///Field `TMR_IF_FIFO_HF` writer - RW1, interrupt flag for timer FIFO half (capture fifo >=4 or PWM fifo less than 3
        pub type TMR_IF_FIFO_HF_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TMR_IF_DMA_END` reader - RW1, interrupt flag for timer1/2 DMA completion
        pub type TMR_IF_DMA_END_R = crate::BitReader;
        ///Field `TMR_IF_DMA_END` writer - RW1, interrupt flag for timer1/2 DMA completion
        pub type TMR_IF_DMA_END_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TMR_IF_FIFO_OV` reader - RW1, interrupt flag for timer FIFO overflow
        pub type TMR_IF_FIFO_OV_R = crate::BitReader;
        ///Field `TMR_IF_FIFO_OV` writer - RW1, interrupt flag for timer FIFO overflow
        pub type TMR_IF_FIFO_OV_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - RW1, interrupt flag for timer capture count timeout or PWM cycle end
            #[inline(always)]
            pub fn tmr_if_cyc_end(&self) -> TMR_IF_CYC_END_R {
                TMR_IF_CYC_END_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RW1, interrupt flag for timer capture input action or PWM trigger
            #[inline(always)]
            pub fn tmr_if_data_act(&self) -> TMR_IF_DATA_ACT_R {
                TMR_IF_DATA_ACT_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RW1, interrupt flag for timer FIFO half (capture fifo >=4 or PWM fifo less than 3
            #[inline(always)]
            pub fn tmr_if_fifo_hf(&self) -> TMR_IF_FIFO_HF_R {
                TMR_IF_FIFO_HF_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RW1, interrupt flag for timer1/2 DMA completion
            #[inline(always)]
            pub fn tmr_if_dma_end(&self) -> TMR_IF_DMA_END_R {
                TMR_IF_DMA_END_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RW1, interrupt flag for timer FIFO overflow
            #[inline(always)]
            pub fn tmr_if_fifo_ov(&self) -> TMR_IF_FIFO_OV_R {
                TMR_IF_FIFO_OV_R::new(((self.bits >> 4) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RW1, interrupt flag for timer capture count timeout or PWM cycle end
            #[inline(always)]
            #[must_use]
            pub fn tmr_if_cyc_end(&mut self) -> TMR_IF_CYC_END_W<INT_FLAG_SPEC> {
                TMR_IF_CYC_END_W::new(self, 0)
            }
            ///Bit 1 - RW1, interrupt flag for timer capture input action or PWM trigger
            #[inline(always)]
            #[must_use]
            pub fn tmr_if_data_act(&mut self) -> TMR_IF_DATA_ACT_W<INT_FLAG_SPEC> {
                TMR_IF_DATA_ACT_W::new(self, 1)
            }
            ///Bit 2 - RW1, interrupt flag for timer FIFO half (capture fifo >=4 or PWM fifo less than 3
            #[inline(always)]
            #[must_use]
            pub fn tmr_if_fifo_hf(&mut self) -> TMR_IF_FIFO_HF_W<INT_FLAG_SPEC> {
                TMR_IF_FIFO_HF_W::new(self, 2)
            }
            ///Bit 3 - RW1, interrupt flag for timer1/2 DMA completion
            #[inline(always)]
            #[must_use]
            pub fn tmr_if_dma_end(&mut self) -> TMR_IF_DMA_END_W<INT_FLAG_SPEC> {
                TMR_IF_DMA_END_W::new(self, 3)
            }
            ///Bit 4 - RW1, interrupt flag for timer FIFO overflow
            #[inline(always)]
            #[must_use]
            pub fn tmr_if_fifo_ov(&mut self) -> TMR_IF_FIFO_OV_W<INT_FLAG_SPEC> {
                TMR_IF_FIFO_OV_W::new(self, 4)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW1, TMR1 interrupt flag
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`int_flag::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`int_flag::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct INT_FLAG_SPEC;
        impl crate::RegisterSpec for INT_FLAG_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`int_flag::R`](R) reader structure
        impl crate::Readable for INT_FLAG_SPEC {}
        ///`write(|w| ..)` method takes [`int_flag::W`](W) writer structure
        impl crate::Writable for INT_FLAG_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets INT_FLAG to value 0
        impl crate::Resettable for INT_FLAG_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///FIFO_COUNT (r) register accessor: RO, TMR1 FIFO count status
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`fifo_count::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@fifo_count`]
    ///module
    pub type FIFO_COUNT = crate::Reg<fifo_count::FIFO_COUNT_SPEC>;
    ///RO, TMR1 FIFO count status
    pub mod fifo_count {
        ///Register `FIFO_COUNT` reader
        pub type R = crate::R<FIFO_COUNT_SPEC>;
        ///Field `FIFO_COUNT` reader - RW1, TMR1 FIFO count status
        pub type FIFO_COUNT_R = crate::FieldReader;
        impl R {
            ///Bits 0:7 - RW1, TMR1 FIFO count status
            #[inline(always)]
            pub fn fifo_count(&self) -> FIFO_COUNT_R {
                FIFO_COUNT_R::new(self.bits)
            }
        }
        ///RO, TMR1 FIFO count status
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`fifo_count::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct FIFO_COUNT_SPEC;
        impl crate::RegisterSpec for FIFO_COUNT_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`fifo_count::R`](R) reader structure
        impl crate::Readable for FIFO_COUNT_SPEC {}
        ///`reset()` method sets FIFO_COUNT to value 0
        impl crate::Resettable for FIFO_COUNT_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///COUNT (r) register accessor: RO, TMR1 current count
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`count::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@count`]
    ///module
    pub type COUNT = crate::Reg<count::COUNT_SPEC>;
    ///RO, TMR1 current count
    pub mod count {
        ///Register `COUNT` reader
        pub type R = crate::R<COUNT_SPEC>;
        ///Field `COUNT` reader - RW1,TMR1 current count
        pub type COUNT_R = crate::FieldReader<u32>;
        impl R {
            ///Bits 0:31 - RW1,TMR1 current count
            #[inline(always)]
            pub fn count(&self) -> COUNT_R {
                COUNT_R::new(self.bits)
            }
        }
        ///RO, TMR1 current count
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`count::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct COUNT_SPEC;
        impl crate::RegisterSpec for COUNT_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`count::R`](R) reader structure
        impl crate::Readable for COUNT_SPEC {}
        ///`reset()` method sets COUNT to value 0
        impl crate::Resettable for COUNT_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///CNT_END (rw) register accessor: RW, TMR1 end count value, only low 26 bit
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`cnt_end::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cnt_end::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@cnt_end`]
    ///module
    pub type CNT_END = crate::Reg<cnt_end::CNT_END_SPEC>;
    ///RW, TMR1 end count value, only low 26 bit
    pub mod cnt_end {
        ///Register `CNT_END` reader
        pub type R = crate::R<CNT_END_SPEC>;
        ///Register `CNT_END` writer
        pub type W = crate::W<CNT_END_SPEC>;
        ///Field `CNT_END` reader - RW1,TMR1 end count value,
        pub type CNT_END_R = crate::FieldReader<u32>;
        ///Field `CNT_END` writer - RW1,TMR1 end count value,
        pub type CNT_END_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - RW1,TMR1 end count value,
            #[inline(always)]
            pub fn cnt_end(&self) -> CNT_END_R {
                CNT_END_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW1,TMR1 end count value,
            #[inline(always)]
            #[must_use]
            pub fn cnt_end(&mut self) -> CNT_END_W<CNT_END_SPEC> {
                CNT_END_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW, TMR1 end count value, only low 26 bit
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`cnt_end::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cnt_end::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct CNT_END_SPEC;
        impl crate::RegisterSpec for CNT_END_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`cnt_end::R`](R) reader structure
        impl crate::Readable for CNT_END_SPEC {}
        ///`write(|w| ..)` method takes [`cnt_end::W`](W) writer structure
        impl crate::Writable for CNT_END_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets CNT_END to value 0
        impl crate::Resettable for CNT_END_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///FIFO (r) register accessor: RO, TMR1 FIFO register, only low 26 bit
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`fifo::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@fifo`]
    ///module
    pub type FIFO = crate::Reg<fifo::FIFO_SPEC>;
    ///RO, TMR1 FIFO register, only low 26 bit
    pub mod fifo {
        ///Register `FIFO` reader
        pub type R = crate::R<FIFO_SPEC>;
        ///Field `FIFO` reader - RW1,TMR1 FIFO register
        pub type FIFO_R = crate::FieldReader<u32>;
        impl R {
            ///Bits 0:31 - RW1,TMR1 FIFO register
            #[inline(always)]
            pub fn fifo(&self) -> FIFO_R {
                FIFO_R::new(self.bits)
            }
        }
        ///RO, TMR1 FIFO register, only low 26 bit
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`fifo::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct FIFO_SPEC;
        impl crate::RegisterSpec for FIFO_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`fifo::R`](R) reader structure
        impl crate::Readable for FIFO_SPEC {}
        ///`reset()` method sets FIFO to value 0
        impl crate::Resettable for FIFO_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///DMA_NOW (r) register accessor: RO, TMR1 DMA current address
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`dma_now::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@dma_now`]
    ///module
    pub type DMA_NOW = crate::Reg<dma_now::DMA_NOW_SPEC>;
    ///RO, TMR1 DMA current address
    pub mod dma_now {
        ///Register `DMA_NOW` reader
        pub type R = crate::R<DMA_NOW_SPEC>;
        ///Field `DMA_NOW` reader - RW1,TMR1 FIFO register
        pub type DMA_NOW_R = crate::FieldReader<u16>;
        impl R {
            ///Bits 0:15 - RW1,TMR1 FIFO register
            #[inline(always)]
            pub fn dma_now(&self) -> DMA_NOW_R {
                DMA_NOW_R::new(self.bits)
            }
        }
        ///RO, TMR1 DMA current address
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`dma_now::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct DMA_NOW_SPEC;
        impl crate::RegisterSpec for DMA_NOW_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`dma_now::R`](R) reader structure
        impl crate::Readable for DMA_NOW_SPEC {}
        ///`reset()` method sets DMA_NOW to value 0
        impl crate::Resettable for DMA_NOW_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///DMA_BEG (rw) register accessor: RW, TMR1 DMA begin address
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`dma_beg::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dma_beg::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@dma_beg`]
    ///module
    pub type DMA_BEG = crate::Reg<dma_beg::DMA_BEG_SPEC>;
    ///RW, TMR1 DMA begin address
    pub mod dma_beg {
        ///Register `DMA_BEG` reader
        pub type R = crate::R<DMA_BEG_SPEC>;
        ///Register `DMA_BEG` writer
        pub type W = crate::W<DMA_BEG_SPEC>;
        ///Field `DMA_BEG` reader - RW1,TMR1 FIFO register
        pub type DMA_BEG_R = crate::FieldReader<u16>;
        ///Field `DMA_BEG` writer - RW1,TMR1 FIFO register
        pub type DMA_BEG_W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            ///Bits 0:15 - RW1,TMR1 FIFO register
            #[inline(always)]
            pub fn dma_beg(&self) -> DMA_BEG_R {
                DMA_BEG_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - RW1,TMR1 FIFO register
            #[inline(always)]
            #[must_use]
            pub fn dma_beg(&mut self) -> DMA_BEG_W<DMA_BEG_SPEC> {
                DMA_BEG_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW, TMR1 DMA begin address
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`dma_beg::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dma_beg::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct DMA_BEG_SPEC;
        impl crate::RegisterSpec for DMA_BEG_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`dma_beg::R`](R) reader structure
        impl crate::Readable for DMA_BEG_SPEC {}
        ///`write(|w| ..)` method takes [`dma_beg::W`](W) writer structure
        impl crate::Writable for DMA_BEG_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets DMA_BEG to value 0
        impl crate::Resettable for DMA_BEG_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///DMA_END (rw) register accessor: RW, TMR1 DMA end address
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`dma_end::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dma_end::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@dma_end`]
    ///module
    pub type DMA_END = crate::Reg<dma_end::DMA_END_SPEC>;
    ///RW, TMR1 DMA end address
    pub mod dma_end {
        ///Register `DMA_END` reader
        pub type R = crate::R<DMA_END_SPEC>;
        ///Register `DMA_END` writer
        pub type W = crate::W<DMA_END_SPEC>;
        ///Field `DMA_END` reader - RW1,TMR1 FIFO register
        pub type DMA_END_R = crate::FieldReader<u16>;
        ///Field `DMA_END` writer - RW1,TMR1 FIFO register
        pub type DMA_END_W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            ///Bits 0:15 - RW1,TMR1 FIFO register
            #[inline(always)]
            pub fn dma_end(&self) -> DMA_END_R {
                DMA_END_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - RW1,TMR1 FIFO register
            #[inline(always)]
            #[must_use]
            pub fn dma_end(&mut self) -> DMA_END_W<DMA_END_SPEC> {
                DMA_END_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW, TMR1 DMA end address
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`dma_end::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dma_end::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct DMA_END_SPEC;
        impl crate::RegisterSpec for DMA_END_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`dma_end::R`](R) reader structure
        impl crate::Readable for DMA_END_SPEC {}
        ///`write(|w| ..)` method takes [`dma_end::W`](W) writer structure
        impl crate::Writable for DMA_END_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets DMA_END to value 0
        impl crate::Resettable for DMA_END_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
}
///Timer2 register
pub struct TMR2 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for TMR2 {}
impl TMR2 {
    ///Pointer to the register block
    pub const PTR: *const tmr1::RegisterBlock = 0x4000_2800 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const tmr1::RegisterBlock {
        Self::PTR
    }
    /// Steal an instance of this peripheral
    ///
    /// # Safety
    ///
    /// Ensure that the new instance of the peripheral cannot be used in a way
    /// that may race with any existing instances, for example by only
    /// accessing read-only or write-only registers, or by consuming the
    /// original peripheral and using critical sections to coordinate
    /// access between multiple new instances.
    ///
    /// Additionally, other software such as HALs may rely on only one
    /// peripheral instance existing to ensure memory safety; ensure
    /// no stolen instances are passed to such software.
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for TMR2 {
    type Target = tmr1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for TMR2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("TMR2").finish()
    }
}
///Timer2 register
pub use self::tmr1 as tmr2;
///Timer3 register
pub struct TMR3 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for TMR3 {}
impl TMR3 {
    ///Pointer to the register block
    pub const PTR: *const tmr0::RegisterBlock = 0x4000_2c00 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const tmr0::RegisterBlock {
        Self::PTR
    }
    /// Steal an instance of this peripheral
    ///
    /// # Safety
    ///
    /// Ensure that the new instance of the peripheral cannot be used in a way
    /// that may race with any existing instances, for example by only
    /// accessing read-only or write-only registers, or by consuming the
    /// original peripheral and using critical sections to coordinate
    /// access between multiple new instances.
    ///
    /// Additionally, other software such as HALs may rely on only one
    /// peripheral instance existing to ensure memory safety; ensure
    /// no stolen instances are passed to such software.
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for TMR3 {
    type Target = tmr0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for TMR3 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("TMR3").finish()
    }
}
///Timer3 register
pub use self::tmr0 as tmr3;
///UART0 register
pub struct UART0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for UART0 {}
impl UART0 {
    ///Pointer to the register block
    pub const PTR: *const uart0::RegisterBlock = 0x4000_3000 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const uart0::RegisterBlock {
        Self::PTR
    }
    /// Steal an instance of this peripheral
    ///
    /// # Safety
    ///
    /// Ensure that the new instance of the peripheral cannot be used in a way
    /// that may race with any existing instances, for example by only
    /// accessing read-only or write-only registers, or by consuming the
    /// original peripheral and using critical sections to coordinate
    /// access between multiple new instances.
    ///
    /// Additionally, other software such as HALs may rely on only one
    /// peripheral instance existing to ensure memory safety; ensure
    /// no stolen instances are passed to such software.
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for UART0 {
    type Target = uart0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for UART0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("UART0").finish()
    }
}
///UART0 register
pub mod uart0 {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        mcr: MCR,
        ier: IER,
        fcr: FCR,
        lcr: LCR,
        iir: IIR,
        lsr: LSR,
        msr: MSR,
        _reserved7: [u8; 0x01],
        _reserved_7_rbr: [u8; 0x01],
        _reserved8: [u8; 0x01],
        rfc: RFC,
        tfc: TFC,
        dl: DL,
        div: DIV,
        adr: ADR,
    }
    impl RegisterBlock {
        ///0x00 - RW, UART0 modem control
        #[inline(always)]
        pub const fn mcr(&self) -> &MCR {
            &self.mcr
        }
        ///0x01 - RW, UART0 interrupt enable
        #[inline(always)]
        pub const fn ier(&self) -> &IER {
            &self.ier
        }
        ///0x02 - RW, UART0 FIFO control
        #[inline(always)]
        pub const fn fcr(&self) -> &FCR {
            &self.fcr
        }
        ///0x03 - RW, UART0 line control
        #[inline(always)]
        pub const fn lcr(&self) -> &LCR {
            &self.lcr
        }
        ///0x04 - RO, UART0 interrupt identification
        #[inline(always)]
        pub const fn iir(&self) -> &IIR {
            &self.iir
        }
        ///0x05 - RO, UART0 line status
        #[inline(always)]
        pub const fn lsr(&self) -> &LSR {
            &self.lsr
        }
        ///0x06 - RO, UART0 modem status
        #[inline(always)]
        pub const fn msr(&self) -> &MSR {
            &self.msr
        }
        ///0x08 - WO, UART0 transmitter holding, transmittal byte
        #[inline(always)]
        pub const fn thr(&self) -> &THR {
            unsafe { &*(self as *const Self).cast::<u8>().add(8).cast() }
        }
        ///0x08 - RO, UART0 receiver buffer, receiving byte
        #[inline(always)]
        pub const fn rbr(&self) -> &RBR {
            unsafe { &*(self as *const Self).cast::<u8>().add(8).cast() }
        }
        ///0x0a - RO, UART0 receiver FIFO count
        #[inline(always)]
        pub const fn rfc(&self) -> &RFC {
            &self.rfc
        }
        ///0x0b - RO, UART0 transmitter FIFO count
        #[inline(always)]
        pub const fn tfc(&self) -> &TFC {
            &self.tfc
        }
        ///0x0c - RW, UART0 divisor latch
        #[inline(always)]
        pub const fn dl(&self) -> &DL {
            &self.dl
        }
        ///0x0e - RW, UART0 pre-divisor latch byte, only low 7 bit, from 1 to 0/128
        #[inline(always)]
        pub const fn div(&self) -> &DIV {
            &self.div
        }
        ///0x0f - RW, UART0 slave address: 0xFF=disable, other=enable
        #[inline(always)]
        pub const fn adr(&self) -> &ADR {
            &self.adr
        }
    }
    ///MCR (rw) register accessor: RW, UART0 modem control
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`mcr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`mcr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@mcr`]
    ///module
    pub type MCR = crate::Reg<mcr::MCR_SPEC>;
    ///RW, UART0 modem control
    pub mod mcr {
        ///Register `MCR` reader
        pub type R = crate::R<MCR_SPEC>;
        ///Register `MCR` writer
        pub type W = crate::W<MCR_SPEC>;
        ///Field `DTR` reader - RW, UART0 control DTR
        pub type DTR_R = crate::BitReader;
        ///Field `DTR` writer - RW, UART0 control DTR
        pub type DTR_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `RTS` reader - RW, UART0 control RTS
        pub type RTS_R = crate::BitReader;
        ///Field `RTS` writer - RW, UART0 control RTS
        pub type RTS_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `OUT1` reader - RW, UART0 control OUT1
        pub type OUT1_R = crate::BitReader;
        ///Field `OUT1` writer - RW, UART0 control OUT1
        pub type OUT1_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `OUT2__RB_MCR_INT_OE` reader - RW, UART control OUT2/ UART interrupt output enable
        pub type OUT2__RB_MCR_INT_OE_R = crate::BitReader;
        ///Field `OUT2__RB_MCR_INT_OE` writer - RW, UART control OUT2/ UART interrupt output enable
        pub type OUT2__RB_MCR_INT_OE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `LOOP` reader - RW, UART0 enable local loop back
        pub type LOOP_R = crate::BitReader;
        ///Field `LOOP` writer - RW, UART0 enable local loop back
        pub type LOOP_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `AU_FLOW_EN` reader - RW, UART0 enable autoflow control
        pub type AU_FLOW_EN_R = crate::BitReader;
        ///Field `AU_FLOW_EN` writer - RW, UART0 enable autoflow control
        pub type AU_FLOW_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TNOW` reader - RW, UART0 enable TNOW output on DTR pin
        pub type TNOW_R = crate::BitReader;
        ///Field `TNOW` writer - RW, UART0 enable TNOW output on DTR pin
        pub type TNOW_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `HALF` reader - RW, UART0 enable half-duplex
        pub type HALF_R = crate::BitReader;
        ///Field `HALF` writer - RW, UART0 enable half-duplex
        pub type HALF_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - RW, UART0 control DTR
            #[inline(always)]
            pub fn dtr(&self) -> DTR_R {
                DTR_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RW, UART0 control RTS
            #[inline(always)]
            pub fn rts(&self) -> RTS_R {
                RTS_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RW, UART0 control OUT1
            #[inline(always)]
            pub fn out1(&self) -> OUT1_R {
                OUT1_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RW, UART control OUT2/ UART interrupt output enable
            #[inline(always)]
            pub fn out2__rb_mcr_int_oe(&self) -> OUT2__RB_MCR_INT_OE_R {
                OUT2__RB_MCR_INT_OE_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RW, UART0 enable local loop back
            #[inline(always)]
            pub fn loop_(&self) -> LOOP_R {
                LOOP_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - RW, UART0 enable autoflow control
            #[inline(always)]
            pub fn au_flow_en(&self) -> AU_FLOW_EN_R {
                AU_FLOW_EN_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - RW, UART0 enable TNOW output on DTR pin
            #[inline(always)]
            pub fn tnow(&self) -> TNOW_R {
                TNOW_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - RW, UART0 enable half-duplex
            #[inline(always)]
            pub fn half(&self) -> HALF_R {
                HALF_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RW, UART0 control DTR
            #[inline(always)]
            #[must_use]
            pub fn dtr(&mut self) -> DTR_W<MCR_SPEC> {
                DTR_W::new(self, 0)
            }
            ///Bit 1 - RW, UART0 control RTS
            #[inline(always)]
            #[must_use]
            pub fn rts(&mut self) -> RTS_W<MCR_SPEC> {
                RTS_W::new(self, 1)
            }
            ///Bit 2 - RW, UART0 control OUT1
            #[inline(always)]
            #[must_use]
            pub fn out1(&mut self) -> OUT1_W<MCR_SPEC> {
                OUT1_W::new(self, 2)
            }
            ///Bit 3 - RW, UART control OUT2/ UART interrupt output enable
            #[inline(always)]
            #[must_use]
            pub fn out2__rb_mcr_int_oe(&mut self) -> OUT2__RB_MCR_INT_OE_W<MCR_SPEC> {
                OUT2__RB_MCR_INT_OE_W::new(self, 3)
            }
            ///Bit 4 - RW, UART0 enable local loop back
            #[inline(always)]
            #[must_use]
            pub fn loop_(&mut self) -> LOOP_W<MCR_SPEC> {
                LOOP_W::new(self, 4)
            }
            ///Bit 5 - RW, UART0 enable autoflow control
            #[inline(always)]
            #[must_use]
            pub fn au_flow_en(&mut self) -> AU_FLOW_EN_W<MCR_SPEC> {
                AU_FLOW_EN_W::new(self, 5)
            }
            ///Bit 6 - RW, UART0 enable TNOW output on DTR pin
            #[inline(always)]
            #[must_use]
            pub fn tnow(&mut self) -> TNOW_W<MCR_SPEC> {
                TNOW_W::new(self, 6)
            }
            ///Bit 7 - RW, UART0 enable half-duplex
            #[inline(always)]
            #[must_use]
            pub fn half(&mut self) -> HALF_W<MCR_SPEC> {
                HALF_W::new(self, 7)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW, UART0 modem control
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`mcr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`mcr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct MCR_SPEC;
        impl crate::RegisterSpec for MCR_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`mcr::R`](R) reader structure
        impl crate::Readable for MCR_SPEC {}
        ///`write(|w| ..)` method takes [`mcr::W`](W) writer structure
        impl crate::Writable for MCR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets MCR to value 0
        impl crate::Resettable for MCR_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///IER (rw) register accessor: RW, UART0 interrupt enable
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`ier::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ier::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@ier`]
    ///module
    pub type IER = crate::Reg<ier::IER_SPEC>;
    ///RW, UART0 interrupt enable
    pub mod ier {
        ///Register `IER` reader
        pub type R = crate::R<IER_SPEC>;
        ///Register `IER` writer
        pub type W = crate::W<IER_SPEC>;
        ///Field `RECV_RDY` reader - RW, UART interrupt enable for receiver data ready
        pub type RECV_RDY_R = crate::BitReader;
        ///Field `RECV_RDY` writer - RW, UART interrupt enable for receiver data ready
        pub type RECV_RDY_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `THR_EMPTY` reader - RW, UART interrupt enable for THR empty
        pub type THR_EMPTY_R = crate::BitReader;
        ///Field `THR_EMPTY` writer - RW, UART interrupt enable for THR empty
        pub type THR_EMPTY_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `LINE_STAT` reader - RW, UART interrupt enable for receiver line status
        pub type LINE_STAT_R = crate::BitReader;
        ///Field `LINE_STAT` writer - RW, UART interrupt enable for receiver line status
        pub type LINE_STAT_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `MODEM_CHG` reader - RW, UART0 interrupt enable for modem status change
        pub type MODEM_CHG_R = crate::BitReader;
        ///Field `MODEM_CHG` writer - RW, UART0 interrupt enable for modem status change
        pub type MODEM_CHG_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `DTR_EN` reader - RW, UART0 DTR/TNOW output pin enable
        pub type DTR_EN_R = crate::BitReader;
        ///Field `DTR_EN` writer - RW, UART0 DTR/TNOW output pin enable
        pub type DTR_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `RTS_EN` reader - RW, UART0 RTS output pin enable
        pub type RTS_EN_R = crate::BitReader;
        ///Field `RTS_EN` writer - RW, UART0 RTS output pin enable
        pub type RTS_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TXD_EN` reader - RW, UART TXD pin enable
        pub type TXD_EN_R = crate::BitReader;
        ///Field `TXD_EN` writer - RW, UART TXD pin enable
        pub type TXD_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `RESET` reader - WZ, UART software reset control, high action, auto clear
        pub type RESET_R = crate::BitReader;
        ///Field `RESET` writer - WZ, UART software reset control, high action, auto clear
        pub type RESET_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - RW, UART interrupt enable for receiver data ready
            #[inline(always)]
            pub fn recv_rdy(&self) -> RECV_RDY_R {
                RECV_RDY_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RW, UART interrupt enable for THR empty
            #[inline(always)]
            pub fn thr_empty(&self) -> THR_EMPTY_R {
                THR_EMPTY_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RW, UART interrupt enable for receiver line status
            #[inline(always)]
            pub fn line_stat(&self) -> LINE_STAT_R {
                LINE_STAT_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RW, UART0 interrupt enable for modem status change
            #[inline(always)]
            pub fn modem_chg(&self) -> MODEM_CHG_R {
                MODEM_CHG_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RW, UART0 DTR/TNOW output pin enable
            #[inline(always)]
            pub fn dtr_en(&self) -> DTR_EN_R {
                DTR_EN_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - RW, UART0 RTS output pin enable
            #[inline(always)]
            pub fn rts_en(&self) -> RTS_EN_R {
                RTS_EN_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - RW, UART TXD pin enable
            #[inline(always)]
            pub fn txd_en(&self) -> TXD_EN_R {
                TXD_EN_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - WZ, UART software reset control, high action, auto clear
            #[inline(always)]
            pub fn reset(&self) -> RESET_R {
                RESET_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RW, UART interrupt enable for receiver data ready
            #[inline(always)]
            #[must_use]
            pub fn recv_rdy(&mut self) -> RECV_RDY_W<IER_SPEC> {
                RECV_RDY_W::new(self, 0)
            }
            ///Bit 1 - RW, UART interrupt enable for THR empty
            #[inline(always)]
            #[must_use]
            pub fn thr_empty(&mut self) -> THR_EMPTY_W<IER_SPEC> {
                THR_EMPTY_W::new(self, 1)
            }
            ///Bit 2 - RW, UART interrupt enable for receiver line status
            #[inline(always)]
            #[must_use]
            pub fn line_stat(&mut self) -> LINE_STAT_W<IER_SPEC> {
                LINE_STAT_W::new(self, 2)
            }
            ///Bit 3 - RW, UART0 interrupt enable for modem status change
            #[inline(always)]
            #[must_use]
            pub fn modem_chg(&mut self) -> MODEM_CHG_W<IER_SPEC> {
                MODEM_CHG_W::new(self, 3)
            }
            ///Bit 4 - RW, UART0 DTR/TNOW output pin enable
            #[inline(always)]
            #[must_use]
            pub fn dtr_en(&mut self) -> DTR_EN_W<IER_SPEC> {
                DTR_EN_W::new(self, 4)
            }
            ///Bit 5 - RW, UART0 RTS output pin enable
            #[inline(always)]
            #[must_use]
            pub fn rts_en(&mut self) -> RTS_EN_W<IER_SPEC> {
                RTS_EN_W::new(self, 5)
            }
            ///Bit 6 - RW, UART TXD pin enable
            #[inline(always)]
            #[must_use]
            pub fn txd_en(&mut self) -> TXD_EN_W<IER_SPEC> {
                TXD_EN_W::new(self, 6)
            }
            ///Bit 7 - WZ, UART software reset control, high action, auto clear
            #[inline(always)]
            #[must_use]
            pub fn reset(&mut self) -> RESET_W<IER_SPEC> {
                RESET_W::new(self, 7)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW, UART0 interrupt enable
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`ier::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ier::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IER_SPEC;
        impl crate::RegisterSpec for IER_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`ier::R`](R) reader structure
        impl crate::Readable for IER_SPEC {}
        ///`write(|w| ..)` method takes [`ier::W`](W) writer structure
        impl crate::Writable for IER_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets IER to value 0
        impl crate::Resettable for IER_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///FCR (rw) register accessor: RW, UART0 FIFO control
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`fcr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`fcr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@fcr`]
    ///module
    pub type FCR = crate::Reg<fcr::FCR_SPEC>;
    ///RW, UART0 FIFO control
    pub mod fcr {
        ///Register `FCR` reader
        pub type R = crate::R<FCR_SPEC>;
        ///Register `FCR` writer
        pub type W = crate::W<FCR_SPEC>;
        ///Field `FIFO_EN` reader - RW, UART FIFO enable
        pub type FIFO_EN_R = crate::BitReader;
        ///Field `FIFO_EN` writer - RW, UART FIFO enable
        pub type FIFO_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `RX_FIFO_CLR` reader - WZ, clear UART receiver FIFO, high action, auto clear
        pub type RX_FIFO_CLR_R = crate::BitReader;
        ///Field `RX_FIFO_CLR` writer - WZ, clear UART receiver FIFO, high action, auto clear
        pub type RX_FIFO_CLR_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TX_FIFO_CLR` reader - WZ, clear UART transmitter FIFO, high action, auto clear
        pub type TX_FIFO_CLR_R = crate::BitReader;
        ///Field `TX_FIFO_CLR` writer - WZ, clear UART transmitter FIFO, high action, auto clear
        pub type TX_FIFO_CLR_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FIFO_TRIG` reader - RW, UART receiver FIFO trigger level: 00-1byte, 01-2bytes, 10-4bytes, 11-7bytes
        pub type FIFO_TRIG_R = crate::FieldReader;
        ///Field `FIFO_TRIG` writer - RW, UART receiver FIFO trigger level: 00-1byte, 01-2bytes, 10-4bytes, 11-7bytes
        pub type FIFO_TRIG_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        impl R {
            ///Bit 0 - RW, UART FIFO enable
            #[inline(always)]
            pub fn fifo_en(&self) -> FIFO_EN_R {
                FIFO_EN_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - WZ, clear UART receiver FIFO, high action, auto clear
            #[inline(always)]
            pub fn rx_fifo_clr(&self) -> RX_FIFO_CLR_R {
                RX_FIFO_CLR_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - WZ, clear UART transmitter FIFO, high action, auto clear
            #[inline(always)]
            pub fn tx_fifo_clr(&self) -> TX_FIFO_CLR_R {
                TX_FIFO_CLR_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bits 6:7 - RW, UART receiver FIFO trigger level: 00-1byte, 01-2bytes, 10-4bytes, 11-7bytes
            #[inline(always)]
            pub fn fifo_trig(&self) -> FIFO_TRIG_R {
                FIFO_TRIG_R::new((self.bits >> 6) & 3)
            }
        }
        impl W {
            ///Bit 0 - RW, UART FIFO enable
            #[inline(always)]
            #[must_use]
            pub fn fifo_en(&mut self) -> FIFO_EN_W<FCR_SPEC> {
                FIFO_EN_W::new(self, 0)
            }
            ///Bit 1 - WZ, clear UART receiver FIFO, high action, auto clear
            #[inline(always)]
            #[must_use]
            pub fn rx_fifo_clr(&mut self) -> RX_FIFO_CLR_W<FCR_SPEC> {
                RX_FIFO_CLR_W::new(self, 1)
            }
            ///Bit 2 - WZ, clear UART transmitter FIFO, high action, auto clear
            #[inline(always)]
            #[must_use]
            pub fn tx_fifo_clr(&mut self) -> TX_FIFO_CLR_W<FCR_SPEC> {
                TX_FIFO_CLR_W::new(self, 2)
            }
            ///Bits 6:7 - RW, UART receiver FIFO trigger level: 00-1byte, 01-2bytes, 10-4bytes, 11-7bytes
            #[inline(always)]
            #[must_use]
            pub fn fifo_trig(&mut self) -> FIFO_TRIG_W<FCR_SPEC> {
                FIFO_TRIG_W::new(self, 6)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW, UART0 FIFO control
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`fcr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`fcr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct FCR_SPEC;
        impl crate::RegisterSpec for FCR_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`fcr::R`](R) reader structure
        impl crate::Readable for FCR_SPEC {}
        ///`write(|w| ..)` method takes [`fcr::W`](W) writer structure
        impl crate::Writable for FCR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets FCR to value 0
        impl crate::Resettable for FCR_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///LCR (rw) register accessor: RW, UART0 line control
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`lcr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`lcr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@lcr`]
    ///module
    pub type LCR = crate::Reg<lcr::LCR_SPEC>;
    ///RW, UART0 line control
    pub mod lcr {
        ///Register `LCR` reader
        pub type R = crate::R<LCR_SPEC>;
        ///Register `LCR` writer
        pub type W = crate::W<LCR_SPEC>;
        ///Field `WORD_SZ` reader - RW, UART word bit length: 00-5bit, 01-6bit, 10-7bit, 11-8bit
        pub type WORD_SZ_R = crate::FieldReader;
        ///Field `WORD_SZ` writer - RW, UART word bit length: 00-5bit, 01-6bit, 10-7bit, 11-8bit
        pub type WORD_SZ_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `STOP_BIT` reader - RW, UART stop bit length: 0-1bit, 1-2bit
        pub type STOP_BIT_R = crate::BitReader;
        ///Field `STOP_BIT` writer - RW, UART stop bit length: 0-1bit, 1-2bit
        pub type STOP_BIT_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PAR_EN` reader - RW, UART parity enable
        pub type PAR_EN_R = crate::BitReader;
        ///Field `PAR_EN` writer - RW, UART parity enable
        pub type PAR_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PAR_MOD` reader - RW, UART parity mode: 00-odd, 01-even, 10-mark, 11-space
        pub type PAR_MOD_R = crate::FieldReader;
        ///Field `PAR_MOD` writer - RW, UART parity mode: 00-odd, 01-even, 10-mark, 11-space
        pub type PAR_MOD_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `BREAK_EN` reader - RW, UART break control enable
        pub type BREAK_EN_R = crate::BitReader;
        ///Field `BREAK_EN` writer - RW, UART break control enable
        pub type BREAK_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `GP_BIT__RB_LCR_DLAB` reader - RW, UART general purpose bit;RW, UART reserved bit
        pub type GP_BIT__RB_LCR_DLAB_R = crate::BitReader;
        ///Field `GP_BIT__RB_LCR_DLAB` writer - RW, UART general purpose bit;RW, UART reserved bit
        pub type GP_BIT__RB_LCR_DLAB_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `LCR_DLAB` reader - Divisor Latch Access Bit
        pub type LCR_DLAB_R = crate::BitReader;
        ///Field `LCR_DLAB` writer - Divisor Latch Access Bit
        pub type LCR_DLAB_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `LCR_GP_BIT` reader - General Purpose Bit
        pub type LCR_GP_BIT_R = crate::BitReader;
        ///Field `LCR_GP_BIT` writer - General Purpose Bit
        pub type LCR_GP_BIT_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bits 0:1 - RW, UART word bit length: 00-5bit, 01-6bit, 10-7bit, 11-8bit
            #[inline(always)]
            pub fn word_sz(&self) -> WORD_SZ_R {
                WORD_SZ_R::new(self.bits & 3)
            }
            ///Bit 2 - RW, UART stop bit length: 0-1bit, 1-2bit
            #[inline(always)]
            pub fn stop_bit(&self) -> STOP_BIT_R {
                STOP_BIT_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RW, UART parity enable
            #[inline(always)]
            pub fn par_en(&self) -> PAR_EN_R {
                PAR_EN_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bits 4:5 - RW, UART parity mode: 00-odd, 01-even, 10-mark, 11-space
            #[inline(always)]
            pub fn par_mod(&self) -> PAR_MOD_R {
                PAR_MOD_R::new((self.bits >> 4) & 3)
            }
            ///Bit 6 - RW, UART break control enable
            #[inline(always)]
            pub fn break_en(&self) -> BREAK_EN_R {
                BREAK_EN_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - RW, UART general purpose bit;RW, UART reserved bit
            #[inline(always)]
            pub fn gp_bit__rb_lcr_dlab(&self) -> GP_BIT__RB_LCR_DLAB_R {
                GP_BIT__RB_LCR_DLAB_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bit 7 - Divisor Latch Access Bit
            #[inline(always)]
            pub fn lcr_dlab(&self) -> LCR_DLAB_R {
                LCR_DLAB_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bit 7 - General Purpose Bit
            #[inline(always)]
            pub fn lcr_gp_bit(&self) -> LCR_GP_BIT_R {
                LCR_GP_BIT_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:1 - RW, UART word bit length: 00-5bit, 01-6bit, 10-7bit, 11-8bit
            #[inline(always)]
            #[must_use]
            pub fn word_sz(&mut self) -> WORD_SZ_W<LCR_SPEC> {
                WORD_SZ_W::new(self, 0)
            }
            ///Bit 2 - RW, UART stop bit length: 0-1bit, 1-2bit
            #[inline(always)]
            #[must_use]
            pub fn stop_bit(&mut self) -> STOP_BIT_W<LCR_SPEC> {
                STOP_BIT_W::new(self, 2)
            }
            ///Bit 3 - RW, UART parity enable
            #[inline(always)]
            #[must_use]
            pub fn par_en(&mut self) -> PAR_EN_W<LCR_SPEC> {
                PAR_EN_W::new(self, 3)
            }
            ///Bits 4:5 - RW, UART parity mode: 00-odd, 01-even, 10-mark, 11-space
            #[inline(always)]
            #[must_use]
            pub fn par_mod(&mut self) -> PAR_MOD_W<LCR_SPEC> {
                PAR_MOD_W::new(self, 4)
            }
            ///Bit 6 - RW, UART break control enable
            #[inline(always)]
            #[must_use]
            pub fn break_en(&mut self) -> BREAK_EN_W<LCR_SPEC> {
                BREAK_EN_W::new(self, 6)
            }
            ///Bit 7 - RW, UART general purpose bit;RW, UART reserved bit
            #[inline(always)]
            #[must_use]
            pub fn gp_bit__rb_lcr_dlab(&mut self) -> GP_BIT__RB_LCR_DLAB_W<LCR_SPEC> {
                GP_BIT__RB_LCR_DLAB_W::new(self, 7)
            }
            ///Bit 7 - Divisor Latch Access Bit
            #[inline(always)]
            #[must_use]
            pub fn lcr_dlab(&mut self) -> LCR_DLAB_W<LCR_SPEC> {
                LCR_DLAB_W::new(self, 7)
            }
            ///Bit 7 - General Purpose Bit
            #[inline(always)]
            #[must_use]
            pub fn lcr_gp_bit(&mut self) -> LCR_GP_BIT_W<LCR_SPEC> {
                LCR_GP_BIT_W::new(self, 7)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW, UART0 line control
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`lcr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`lcr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct LCR_SPEC;
        impl crate::RegisterSpec for LCR_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`lcr::R`](R) reader structure
        impl crate::Readable for LCR_SPEC {}
        ///`write(|w| ..)` method takes [`lcr::W`](W) writer structure
        impl crate::Writable for LCR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets LCR to value 0
        impl crate::Resettable for LCR_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///IIR (r) register accessor: RO, UART0 interrupt identification
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iir::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iir`]
    ///module
    pub type IIR = crate::Reg<iir::IIR_SPEC>;
    ///RO, UART0 interrupt identification
    pub mod iir {
        ///Register `IIR` reader
        pub type R = crate::R<IIR_SPEC>;
        ///Field `NO_INT` reader - RO, UART no interrupt flag: 0=interrupt action, 1=no interrupt
        pub type NO_INT_R = crate::BitReader;
        ///Field `INT_MASK` reader - RO, UART interrupt flag bit mask
        pub type INT_MASK_R = crate::FieldReader;
        ///Field `FIFO_ID` reader - RO, UART FIFO enabled flag
        pub type FIFO_ID_R = crate::FieldReader;
        impl R {
            ///Bit 0 - RO, UART no interrupt flag: 0=interrupt action, 1=no interrupt
            #[inline(always)]
            pub fn no_int(&self) -> NO_INT_R {
                NO_INT_R::new((self.bits & 1) != 0)
            }
            ///Bits 0:3 - RO, UART interrupt flag bit mask
            #[inline(always)]
            pub fn int_mask(&self) -> INT_MASK_R {
                INT_MASK_R::new(self.bits & 0x0f)
            }
            ///Bits 6:7 - RO, UART FIFO enabled flag
            #[inline(always)]
            pub fn fifo_id(&self) -> FIFO_ID_R {
                FIFO_ID_R::new((self.bits >> 6) & 3)
            }
        }
        ///RO, UART0 interrupt identification
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iir::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IIR_SPEC;
        impl crate::RegisterSpec for IIR_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`iir::R`](R) reader structure
        impl crate::Readable for IIR_SPEC {}
        ///`reset()` method sets IIR to value 0x01
        impl crate::Resettable for IIR_SPEC {
            const RESET_VALUE: u8 = 0x01;
        }
    }
    ///LSR (r) register accessor: RO, UART0 line status
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`lsr::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@lsr`]
    ///module
    pub type LSR = crate::Reg<lsr::LSR_SPEC>;
    ///RO, UART0 line status
    pub mod lsr {
        ///Register `LSR` reader
        pub type R = crate::R<LSR_SPEC>;
        ///Field `DATA_RDY` reader - RO, UART receiver fifo data ready status
        pub type DATA_RDY_R = crate::BitReader;
        ///Field `OVER_ERR` reader - RZ, UART receiver overrun error
        pub type OVER_ERR_R = crate::BitReader;
        ///Field `PAR_ERR` reader - RZ, UART receiver parity error
        pub type PAR_ERR_R = crate::BitReader;
        ///Field `FRAME_ERR` reader - RZ, UART receiver frame error
        pub type FRAME_ERR_R = crate::BitReader;
        ///Field `BREAK_ERR` reader - RZ, UART receiver break error
        pub type BREAK_ERR_R = crate::BitReader;
        ///Field `TX_FIFO_EMP` reader - RO, UART transmitter fifo empty status
        pub type TX_FIFO_EMP_R = crate::BitReader;
        ///Field `TX_ALL_EMP` reader - RO, UART transmitter all empty status
        pub type TX_ALL_EMP_R = crate::BitReader;
        ///Field `ERR_RX_FIFO` reader - RO, indicate error in UART receiver fifo
        pub type ERR_RX_FIFO_R = crate::BitReader;
        impl R {
            ///Bit 0 - RO, UART receiver fifo data ready status
            #[inline(always)]
            pub fn data_rdy(&self) -> DATA_RDY_R {
                DATA_RDY_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RZ, UART receiver overrun error
            #[inline(always)]
            pub fn over_err(&self) -> OVER_ERR_R {
                OVER_ERR_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RZ, UART receiver parity error
            #[inline(always)]
            pub fn par_err(&self) -> PAR_ERR_R {
                PAR_ERR_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RZ, UART receiver frame error
            #[inline(always)]
            pub fn frame_err(&self) -> FRAME_ERR_R {
                FRAME_ERR_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RZ, UART receiver break error
            #[inline(always)]
            pub fn break_err(&self) -> BREAK_ERR_R {
                BREAK_ERR_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - RO, UART transmitter fifo empty status
            #[inline(always)]
            pub fn tx_fifo_emp(&self) -> TX_FIFO_EMP_R {
                TX_FIFO_EMP_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - RO, UART transmitter all empty status
            #[inline(always)]
            pub fn tx_all_emp(&self) -> TX_ALL_EMP_R {
                TX_ALL_EMP_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - RO, indicate error in UART receiver fifo
            #[inline(always)]
            pub fn err_rx_fifo(&self) -> ERR_RX_FIFO_R {
                ERR_RX_FIFO_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        ///RO, UART0 line status
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`lsr::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct LSR_SPEC;
        impl crate::RegisterSpec for LSR_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`lsr::R`](R) reader structure
        impl crate::Readable for LSR_SPEC {}
        ///`reset()` method sets LSR to value 0x60
        impl crate::Resettable for LSR_SPEC {
            const RESET_VALUE: u8 = 0x60;
        }
    }
    ///MSR (r) register accessor: RO, UART0 modem status
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`msr::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@msr`]
    ///module
    pub type MSR = crate::Reg<msr::MSR_SPEC>;
    ///RO, UART0 modem status
    pub mod msr {
        ///Register `MSR` reader
        pub type R = crate::R<MSR_SPEC>;
        ///Field `CTS_CHG` reader - RZ, UART0 CTS changed status, high action
        pub type CTS_CHG_R = crate::BitReader;
        ///Field `DSR_CHG` reader - RZ, UART0 DSR changed status, high action
        pub type DSR_CHG_R = crate::BitReader;
        ///Field `RI_CHG` reader - RZ, UART0 RI changed status, high action
        pub type RI_CHG_R = crate::BitReader;
        ///Field `DCD_CHG` reader - RZ, UART0 DCD changed status, high action
        pub type DCD_CHG_R = crate::BitReader;
        ///Field `CTS` reader - RO, UART0 CTS action status
        pub type CTS_R = crate::BitReader;
        ///Field `DSR` reader - RO, UART0 DSR action statusv
        pub type DSR_R = crate::BitReader;
        ///Field `RI` reader - RO, UART0 RI action status
        pub type RI_R = crate::BitReader;
        ///Field `DCD` reader - RO, UART0 DCD action status
        pub type DCD_R = crate::BitReader;
        impl R {
            ///Bit 0 - RZ, UART0 CTS changed status, high action
            #[inline(always)]
            pub fn cts_chg(&self) -> CTS_CHG_R {
                CTS_CHG_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RZ, UART0 DSR changed status, high action
            #[inline(always)]
            pub fn dsr_chg(&self) -> DSR_CHG_R {
                DSR_CHG_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RZ, UART0 RI changed status, high action
            #[inline(always)]
            pub fn ri_chg(&self) -> RI_CHG_R {
                RI_CHG_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RZ, UART0 DCD changed status, high action
            #[inline(always)]
            pub fn dcd_chg(&self) -> DCD_CHG_R {
                DCD_CHG_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RO, UART0 CTS action status
            #[inline(always)]
            pub fn cts(&self) -> CTS_R {
                CTS_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - RO, UART0 DSR action statusv
            #[inline(always)]
            pub fn dsr(&self) -> DSR_R {
                DSR_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - RO, UART0 RI action status
            #[inline(always)]
            pub fn ri(&self) -> RI_R {
                RI_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - RO, UART0 DCD action status
            #[inline(always)]
            pub fn dcd(&self) -> DCD_R {
                DCD_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        ///RO, UART0 modem status
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`msr::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct MSR_SPEC;
        impl crate::RegisterSpec for MSR_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`msr::R`](R) reader structure
        impl crate::Readable for MSR_SPEC {}
        ///`reset()` method sets MSR to value 0
        impl crate::Resettable for MSR_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///RBR (r) register accessor: RO, UART0 receiver buffer, receiving byte
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`rbr::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@rbr`]
    ///module
    pub type RBR = crate::Reg<rbr::RBR_SPEC>;
    ///RO, UART0 receiver buffer, receiving byte
    pub mod rbr {
        ///Register `RBR` reader
        pub type R = crate::R<RBR_SPEC>;
        ///Field `RBR` reader - RO, UART0 receiver buffer, receiving byte
        pub type RBR_R = crate::FieldReader;
        impl R {
            ///Bits 0:7 - RO, UART0 receiver buffer, receiving byte
            #[inline(always)]
            pub fn rbr(&self) -> RBR_R {
                RBR_R::new(self.bits)
            }
        }
        ///RO, UART0 receiver buffer, receiving byte
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`rbr::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct RBR_SPEC;
        impl crate::RegisterSpec for RBR_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`rbr::R`](R) reader structure
        impl crate::Readable for RBR_SPEC {}
        ///`reset()` method sets RBR to value 0
        impl crate::Resettable for RBR_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///THR (w) register accessor: WO, UART0 transmitter holding, transmittal byte
    ///
    ///You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`thr::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@thr`]
    ///module
    pub type THR = crate::Reg<thr::THR_SPEC>;
    ///WO, UART0 transmitter holding, transmittal byte
    pub mod thr {
        ///Register `THR` writer
        pub type W = crate::W<THR_SPEC>;
        ///Field `THR` writer - RO, UART0 transmitter holding, transmittal byte
        pub type THR_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl W {
            ///Bits 0:7 - RO, UART0 transmitter holding, transmittal byte
            #[inline(always)]
            #[must_use]
            pub fn thr(&mut self) -> THR_W<THR_SPEC> {
                THR_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///WO, UART0 transmitter holding, transmittal byte
        ///
        ///You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`thr::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct THR_SPEC;
        impl crate::RegisterSpec for THR_SPEC {
            type Ux = u8;
        }
        ///`write(|w| ..)` method takes [`thr::W`](W) writer structure
        impl crate::Writable for THR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets THR to value 0
        impl crate::Resettable for THR_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///RFC (r) register accessor: RO, UART0 receiver FIFO count
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`rfc::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@rfc`]
    ///module
    pub type RFC = crate::Reg<rfc::RFC_SPEC>;
    ///RO, UART0 receiver FIFO count
    pub mod rfc {
        ///Register `RFC` reader
        pub type R = crate::R<RFC_SPEC>;
        ///Field `RFC` reader - RO, UART0 receiver FIFO count
        pub type RFC_R = crate::FieldReader;
        impl R {
            ///Bits 0:7 - RO, UART0 receiver FIFO count
            #[inline(always)]
            pub fn rfc(&self) -> RFC_R {
                RFC_R::new(self.bits)
            }
        }
        ///RO, UART0 receiver FIFO count
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`rfc::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct RFC_SPEC;
        impl crate::RegisterSpec for RFC_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`rfc::R`](R) reader structure
        impl crate::Readable for RFC_SPEC {}
        ///`reset()` method sets RFC to value 0
        impl crate::Resettable for RFC_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///TFC (r) register accessor: RO, UART0 transmitter FIFO count
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`tfc::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@tfc`]
    ///module
    pub type TFC = crate::Reg<tfc::TFC_SPEC>;
    ///RO, UART0 transmitter FIFO count
    pub mod tfc {
        ///Register `TFC` reader
        pub type R = crate::R<TFC_SPEC>;
        ///Field `TFC` reader - RO, UART0 transmitter FIFO count
        pub type TFC_R = crate::FieldReader;
        impl R {
            ///Bits 0:7 - RO, UART0 transmitter FIFO count
            #[inline(always)]
            pub fn tfc(&self) -> TFC_R {
                TFC_R::new(self.bits)
            }
        }
        ///RO, UART0 transmitter FIFO count
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`tfc::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct TFC_SPEC;
        impl crate::RegisterSpec for TFC_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`tfc::R`](R) reader structure
        impl crate::Readable for TFC_SPEC {}
        ///`reset()` method sets TFC to value 0
        impl crate::Resettable for TFC_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///DL (rw) register accessor: RW, UART0 divisor latch
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`dl::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dl::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@dl`]
    ///module
    pub type DL = crate::Reg<dl::DL_SPEC>;
    ///RW, UART0 divisor latch
    pub mod dl {
        ///Register `DL` reader
        pub type R = crate::R<DL_SPEC>;
        ///Register `DL` writer
        pub type W = crate::W<DL_SPEC>;
        ///Field `DL` reader - RW, UART0 divisor latch
        pub type DL_R = crate::FieldReader<u16>;
        ///Field `DL` writer - RW, UART0 divisor latch
        pub type DL_W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            ///Bits 0:15 - RW, UART0 divisor latch
            #[inline(always)]
            pub fn dl(&self) -> DL_R {
                DL_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - RW, UART0 divisor latch
            #[inline(always)]
            #[must_use]
            pub fn dl(&mut self) -> DL_W<DL_SPEC> {
                DL_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW, UART0 divisor latch
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`dl::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dl::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct DL_SPEC;
        impl crate::RegisterSpec for DL_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`dl::R`](R) reader structure
        impl crate::Readable for DL_SPEC {}
        ///`write(|w| ..)` method takes [`dl::W`](W) writer structure
        impl crate::Writable for DL_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets DL to value 0
        impl crate::Resettable for DL_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///DIV (rw) register accessor: RW, UART0 pre-divisor latch byte, only low 7 bit, from 1 to 0/128
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`div::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`div::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@div`]
    ///module
    pub type DIV = crate::Reg<div::DIV_SPEC>;
    ///RW, UART0 pre-divisor latch byte, only low 7 bit, from 1 to 0/128
    pub mod div {
        ///Register `DIV` reader
        pub type R = crate::R<DIV_SPEC>;
        ///Register `DIV` writer
        pub type W = crate::W<DIV_SPEC>;
        ///Field `DIV` reader - RW,UART0 pre-divisor latch byte, only low 7 bit, from 1 to 0/128
        pub type DIV_R = crate::FieldReader;
        ///Field `DIV` writer - RW,UART0 pre-divisor latch byte, only low 7 bit, from 1 to 0/128
        pub type DIV_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            ///Bits 0:7 - RW,UART0 pre-divisor latch byte, only low 7 bit, from 1 to 0/128
            #[inline(always)]
            pub fn div(&self) -> DIV_R {
                DIV_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:7 - RW,UART0 pre-divisor latch byte, only low 7 bit, from 1 to 0/128
            #[inline(always)]
            #[must_use]
            pub fn div(&mut self) -> DIV_W<DIV_SPEC> {
                DIV_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW, UART0 pre-divisor latch byte, only low 7 bit, from 1 to 0/128
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`div::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`div::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct DIV_SPEC;
        impl crate::RegisterSpec for DIV_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`div::R`](R) reader structure
        impl crate::Readable for DIV_SPEC {}
        ///`write(|w| ..)` method takes [`div::W`](W) writer structure
        impl crate::Writable for DIV_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets DIV to value 0
        impl crate::Resettable for DIV_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///ADR (rw) register accessor: RW, UART0 slave address: 0xFF=disable, other=enable
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`adr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`adr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@adr`]
    ///module
    pub type ADR = crate::Reg<adr::ADR_SPEC>;
    ///RW, UART0 slave address: 0xFF=disable, other=enable
    pub mod adr {
        ///Register `ADR` reader
        pub type R = crate::R<ADR_SPEC>;
        ///Register `ADR` writer
        pub type W = crate::W<ADR_SPEC>;
        ///Field `ADR` reader - RW,UART0 slave address: 0xFF=disable, other=enable
        pub type ADR_R = crate::FieldReader;
        ///Field `ADR` writer - RW,UART0 slave address: 0xFF=disable, other=enable
        pub type ADR_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            ///Bits 0:7 - RW,UART0 slave address: 0xFF=disable, other=enable
            #[inline(always)]
            pub fn adr(&self) -> ADR_R {
                ADR_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:7 - RW,UART0 slave address: 0xFF=disable, other=enable
            #[inline(always)]
            #[must_use]
            pub fn adr(&mut self) -> ADR_W<ADR_SPEC> {
                ADR_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW, UART0 slave address: 0xFF=disable, other=enable
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`adr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`adr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct ADR_SPEC;
        impl crate::RegisterSpec for ADR_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`adr::R`](R) reader structure
        impl crate::Readable for ADR_SPEC {}
        ///`write(|w| ..)` method takes [`adr::W`](W) writer structure
        impl crate::Writable for ADR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets ADR to value 0xff
        impl crate::Resettable for ADR_SPEC {
            const RESET_VALUE: u8 = 0xff;
        }
    }
}
///UART1 register
pub struct UART1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for UART1 {}
impl UART1 {
    ///Pointer to the register block
    pub const PTR: *const uart0::RegisterBlock = 0x4000_3400 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const uart0::RegisterBlock {
        Self::PTR
    }
    /// Steal an instance of this peripheral
    ///
    /// # Safety
    ///
    /// Ensure that the new instance of the peripheral cannot be used in a way
    /// that may race with any existing instances, for example by only
    /// accessing read-only or write-only registers, or by consuming the
    /// original peripheral and using critical sections to coordinate
    /// access between multiple new instances.
    ///
    /// Additionally, other software such as HALs may rely on only one
    /// peripheral instance existing to ensure memory safety; ensure
    /// no stolen instances are passed to such software.
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for UART1 {
    type Target = uart0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for UART1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("UART1").finish()
    }
}
///UART1 register
pub use self::uart0 as uart1;
///UART2 register
pub struct UART2 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for UART2 {}
impl UART2 {
    ///Pointer to the register block
    pub const PTR: *const uart0::RegisterBlock = 0x4000_3800 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const uart0::RegisterBlock {
        Self::PTR
    }
    /// Steal an instance of this peripheral
    ///
    /// # Safety
    ///
    /// Ensure that the new instance of the peripheral cannot be used in a way
    /// that may race with any existing instances, for example by only
    /// accessing read-only or write-only registers, or by consuming the
    /// original peripheral and using critical sections to coordinate
    /// access between multiple new instances.
    ///
    /// Additionally, other software such as HALs may rely on only one
    /// peripheral instance existing to ensure memory safety; ensure
    /// no stolen instances are passed to such software.
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for UART2 {
    type Target = uart0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for UART2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("UART2").finish()
    }
}
///UART2 register
pub use self::uart0 as uart2;
///UART3 register
pub struct UART3 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for UART3 {}
impl UART3 {
    ///Pointer to the register block
    pub const PTR: *const uart0::RegisterBlock = 0x4000_3c00 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const uart0::RegisterBlock {
        Self::PTR
    }
    /// Steal an instance of this peripheral
    ///
    /// # Safety
    ///
    /// Ensure that the new instance of the peripheral cannot be used in a way
    /// that may race with any existing instances, for example by only
    /// accessing read-only or write-only registers, or by consuming the
    /// original peripheral and using critical sections to coordinate
    /// access between multiple new instances.
    ///
    /// Additionally, other software such as HALs may rely on only one
    /// peripheral instance existing to ensure memory safety; ensure
    /// no stolen instances are passed to such software.
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for UART3 {
    type Target = uart0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for UART3 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("UART3").finish()
    }
}
///UART3 register
pub use self::uart0 as uart3;
///SPI0 register
pub struct SPI0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for SPI0 {}
impl SPI0 {
    ///Pointer to the register block
    pub const PTR: *const spi0::RegisterBlock = 0x4000_4000 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const spi0::RegisterBlock {
        Self::PTR
    }
    /// Steal an instance of this peripheral
    ///
    /// # Safety
    ///
    /// Ensure that the new instance of the peripheral cannot be used in a way
    /// that may race with any existing instances, for example by only
    /// accessing read-only or write-only registers, or by consuming the
    /// original peripheral and using critical sections to coordinate
    /// access between multiple new instances.
    ///
    /// Additionally, other software such as HALs may rely on only one
    /// peripheral instance existing to ensure memory safety; ensure
    /// no stolen instances are passed to such software.
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for SPI0 {
    type Target = spi0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for SPI0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("SPI0").finish()
    }
}
///SPI0 register
pub mod spi0 {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        ctrl_mod: CTRL_MOD,
        ctrl_cfg: CTRL_CFG,
        inter_en: INTER_EN,
        _reserved_3_clock_div: [u8; 0x01],
        buffer: BUFFER,
        run_flag: RUN_FLAG,
        int_flag: INT_FLAG,
        fifo_count: FIFO_COUNT,
        _reserved8: [u8; 0x04],
        total_cnt: TOTAL_CNT,
        _reserved9: [u8; 0x02],
        fifo: FIFO,
        _reserved10: [u8; 0x02],
        fifo_count1: FIFO_COUNT1,
        dma_now: DMA_NOW,
        _reserved12: [u8; 0x02],
        dma_beg: DMA_BEG,
        _reserved13: [u8; 0x02],
        dma_end: DMA_END,
    }
    impl RegisterBlock {
        ///0x00 - RW, SPI0 mode control
        #[inline(always)]
        pub const fn ctrl_mod(&self) -> &CTRL_MOD {
            &self.ctrl_mod
        }
        ///0x01 - RW, SPI0 configuration control
        #[inline(always)]
        pub const fn ctrl_cfg(&self) -> &CTRL_CFG {
            &self.ctrl_cfg
        }
        ///0x02 - RW, SPI0 interrupt enable
        #[inline(always)]
        pub const fn inter_en(&self) -> &INTER_EN {
            &self.inter_en
        }
        ///0x03 - SPI slave prescaler
        #[inline(always)]
        pub const fn slave_pre(&self) -> &SLAVE_PRE {
            unsafe { &*(self as *const Self).cast::<u8>().add(3).cast() }
        }
        ///0x03 - SPI clock divider
        #[inline(always)]
        pub const fn clock_div(&self) -> &CLOCK_DIV {
            unsafe { &*(self as *const Self).cast::<u8>().add(3).cast() }
        }
        ///0x04 - RW, SPI0 data buffer
        #[inline(always)]
        pub const fn buffer(&self) -> &BUFFER {
            &self.buffer
        }
        ///0x05 - RO, SPI0 work flag
        #[inline(always)]
        pub const fn run_flag(&self) -> &RUN_FLAG {
            &self.run_flag
        }
        ///0x06 - RW1, SPI0 interrupt flag
        #[inline(always)]
        pub const fn int_flag(&self) -> &INT_FLAG {
            &self.int_flag
        }
        ///0x07 - RO, SPI0 FIFO count status
        #[inline(always)]
        pub const fn fifo_count(&self) -> &FIFO_COUNT {
            &self.fifo_count
        }
        ///0x0c - RW, SPI0 total byte count, only low 12 bit
        #[inline(always)]
        pub const fn total_cnt(&self) -> &TOTAL_CNT {
            &self.total_cnt
        }
        ///0x10 - RO/WO, SPI0 FIFO register
        #[inline(always)]
        pub const fn fifo(&self) -> &FIFO {
            &self.fifo
        }
        ///0x13 - RO, SPI0 FIFO count status
        #[inline(always)]
        pub const fn fifo_count1(&self) -> &FIFO_COUNT1 {
            &self.fifo_count1
        }
        ///0x14 - RW, SPI0 DMA current address
        #[inline(always)]
        pub const fn dma_now(&self) -> &DMA_NOW {
            &self.dma_now
        }
        ///0x18 - RW, SPI0 DMA begin address
        #[inline(always)]
        pub const fn dma_beg(&self) -> &DMA_BEG {
            &self.dma_beg
        }
        ///0x1c - RW, SPI0 DMA end address
        #[inline(always)]
        pub const fn dma_end(&self) -> &DMA_END {
            &self.dma_end
        }
    }
    ///CTRL_MOD (rw) register accessor: RW, SPI0 mode control
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`ctrl_mod::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ctrl_mod::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@ctrl_mod`]
    ///module
    pub type CTRL_MOD = crate::Reg<ctrl_mod::CTRL_MOD_SPEC>;
    ///RW, SPI0 mode control
    pub mod ctrl_mod {
        ///Register `CTRL_MOD` reader
        pub type R = crate::R<CTRL_MOD_SPEC>;
        ///Register `CTRL_MOD` writer
        pub type W = crate::W<CTRL_MOD_SPEC>;
        ///Field `MODE_SLAVE` reader - RW, SPI0 slave mode: 0=master or host, 1=slave or device
        pub type MODE_SLAVE_R = crate::BitReader;
        ///Field `MODE_SLAVE` writer - RW, SPI0 slave mode: 0=master or host, 1=slave or device
        pub type MODE_SLAVE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `ALL_CLEAR` reader - RW, force clear SPI FIFO and count
        pub type ALL_CLEAR_R = crate::BitReader;
        ///Field `ALL_CLEAR` writer - RW, force clear SPI FIFO and count
        pub type ALL_CLEAR_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TWO_WIRE_MODE` reader - RW, SPI0 enable 2 wire mode for slave: 0=3wire(SCK0,MOSI,MISO), 1=2wire(SCK0,MISO=MXSX)
        pub type TWO_WIRE_MODE_R = crate::BitReader;
        ///Field `TWO_WIRE_MODE` writer - RW, SPI0 enable 2 wire mode for slave: 0=3wire(SCK0,MOSI,MISO), 1=2wire(SCK0,MISO=MXSX)
        pub type TWO_WIRE_MODE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `MST_SCK_MOD` reader - RW, SPI master clock mode: 0=mode 0, 1=mode 3;RW, SPI0 slave command mode: 0=byte stream, 1=first byte command
        pub type MST_SCK_MOD_R = crate::BitReader;
        ///Field `MST_SCK_MOD` writer - RW, SPI master clock mode: 0=mode 0, 1=mode 3;RW, SPI0 slave command mode: 0=byte stream, 1=first byte command
        pub type MST_SCK_MOD_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `SLV_CMD_MOD` reader - SPI slave command mode
        pub type SLV_CMD_MOD_R = crate::BitReader;
        ///Field `SLV_CMD_MOD` writer - SPI slave command mode
        pub type SLV_CMD_MOD_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FIFO_DIR` reader - RW, SPI FIFO direction: 0=out(write @master mode), 1=in(read @master mode)
        pub type FIFO_DIR_R = crate::BitReader;
        ///Field `FIFO_DIR` writer - RW, SPI FIFO direction: 0=out(write @master mode), 1=in(read @master mode)
        pub type FIFO_DIR_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `SCK_OE` reader - RW, SPI SCK output enable
        pub type SCK_OE_R = crate::BitReader;
        ///Field `SCK_OE` writer - RW, SPI SCK output enable
        pub type SCK_OE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `MOSI_OE` reader - RW, SPI MOSI output enable
        pub type MOSI_OE_R = crate::BitReader;
        ///Field `MOSI_OE` writer - RW, SPI MOSI output enable
        pub type MOSI_OE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `MISO_OE` reader - RW, SPI MISO output enable
        pub type MISO_OE_R = crate::BitReader;
        ///Field `MISO_OE` writer - RW, SPI MISO output enable
        pub type MISO_OE_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - RW, SPI0 slave mode: 0=master or host, 1=slave or device
            #[inline(always)]
            pub fn mode_slave(&self) -> MODE_SLAVE_R {
                MODE_SLAVE_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RW, force clear SPI FIFO and count
            #[inline(always)]
            pub fn all_clear(&self) -> ALL_CLEAR_R {
                ALL_CLEAR_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RW, SPI0 enable 2 wire mode for slave: 0=3wire(SCK0,MOSI,MISO), 1=2wire(SCK0,MISO=MXSX)
            #[inline(always)]
            pub fn two_wire_mode(&self) -> TWO_WIRE_MODE_R {
                TWO_WIRE_MODE_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RW, SPI master clock mode: 0=mode 0, 1=mode 3;RW, SPI0 slave command mode: 0=byte stream, 1=first byte command
            #[inline(always)]
            pub fn mst_sck_mod(&self) -> MST_SCK_MOD_R {
                MST_SCK_MOD_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 3 - SPI slave command mode
            #[inline(always)]
            pub fn slv_cmd_mod(&self) -> SLV_CMD_MOD_R {
                SLV_CMD_MOD_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RW, SPI FIFO direction: 0=out(write @master mode), 1=in(read @master mode)
            #[inline(always)]
            pub fn fifo_dir(&self) -> FIFO_DIR_R {
                FIFO_DIR_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - RW, SPI SCK output enable
            #[inline(always)]
            pub fn sck_oe(&self) -> SCK_OE_R {
                SCK_OE_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - RW, SPI MOSI output enable
            #[inline(always)]
            pub fn mosi_oe(&self) -> MOSI_OE_R {
                MOSI_OE_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - RW, SPI MISO output enable
            #[inline(always)]
            pub fn miso_oe(&self) -> MISO_OE_R {
                MISO_OE_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RW, SPI0 slave mode: 0=master or host, 1=slave or device
            #[inline(always)]
            #[must_use]
            pub fn mode_slave(&mut self) -> MODE_SLAVE_W<CTRL_MOD_SPEC> {
                MODE_SLAVE_W::new(self, 0)
            }
            ///Bit 1 - RW, force clear SPI FIFO and count
            #[inline(always)]
            #[must_use]
            pub fn all_clear(&mut self) -> ALL_CLEAR_W<CTRL_MOD_SPEC> {
                ALL_CLEAR_W::new(self, 1)
            }
            ///Bit 2 - RW, SPI0 enable 2 wire mode for slave: 0=3wire(SCK0,MOSI,MISO), 1=2wire(SCK0,MISO=MXSX)
            #[inline(always)]
            #[must_use]
            pub fn two_wire_mode(&mut self) -> TWO_WIRE_MODE_W<CTRL_MOD_SPEC> {
                TWO_WIRE_MODE_W::new(self, 2)
            }
            ///Bit 3 - RW, SPI master clock mode: 0=mode 0, 1=mode 3;RW, SPI0 slave command mode: 0=byte stream, 1=first byte command
            #[inline(always)]
            #[must_use]
            pub fn mst_sck_mod(&mut self) -> MST_SCK_MOD_W<CTRL_MOD_SPEC> {
                MST_SCK_MOD_W::new(self, 3)
            }
            ///Bit 3 - SPI slave command mode
            #[inline(always)]
            #[must_use]
            pub fn slv_cmd_mod(&mut self) -> SLV_CMD_MOD_W<CTRL_MOD_SPEC> {
                SLV_CMD_MOD_W::new(self, 3)
            }
            ///Bit 4 - RW, SPI FIFO direction: 0=out(write @master mode), 1=in(read @master mode)
            #[inline(always)]
            #[must_use]
            pub fn fifo_dir(&mut self) -> FIFO_DIR_W<CTRL_MOD_SPEC> {
                FIFO_DIR_W::new(self, 4)
            }
            ///Bit 5 - RW, SPI SCK output enable
            #[inline(always)]
            #[must_use]
            pub fn sck_oe(&mut self) -> SCK_OE_W<CTRL_MOD_SPEC> {
                SCK_OE_W::new(self, 5)
            }
            ///Bit 6 - RW, SPI MOSI output enable
            #[inline(always)]
            #[must_use]
            pub fn mosi_oe(&mut self) -> MOSI_OE_W<CTRL_MOD_SPEC> {
                MOSI_OE_W::new(self, 6)
            }
            ///Bit 7 - RW, SPI MISO output enable
            #[inline(always)]
            #[must_use]
            pub fn miso_oe(&mut self) -> MISO_OE_W<CTRL_MOD_SPEC> {
                MISO_OE_W::new(self, 7)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW, SPI0 mode control
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`ctrl_mod::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ctrl_mod::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct CTRL_MOD_SPEC;
        impl crate::RegisterSpec for CTRL_MOD_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`ctrl_mod::R`](R) reader structure
        impl crate::Readable for CTRL_MOD_SPEC {}
        ///`write(|w| ..)` method takes [`ctrl_mod::W`](W) writer structure
        impl crate::Writable for CTRL_MOD_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets CTRL_MOD to value 0x02
        impl crate::Resettable for CTRL_MOD_SPEC {
            const RESET_VALUE: u8 = 0x02;
        }
    }
    ///CTRL_CFG (rw) register accessor: RW, SPI0 configuration control
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`ctrl_cfg::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ctrl_cfg::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@ctrl_cfg`]
    ///module
    pub type CTRL_CFG = crate::Reg<ctrl_cfg::CTRL_CFG_SPEC>;
    ///RW, SPI0 configuration control
    pub mod ctrl_cfg {
        ///Register `CTRL_CFG` reader
        pub type R = crate::R<CTRL_CFG_SPEC>;
        ///Register `CTRL_CFG` writer
        pub type W = crate::W<CTRL_CFG_SPEC>;
        ///Field `DMA_ENABLE` reader - RW, SPI0 DMA enable
        pub type DMA_ENABLE_R = crate::BitReader;
        ///Field `DMA_ENABLE` writer - RW, SPI0 DMA enable
        pub type DMA_ENABLE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `DMA_LOOP` reader - RW, SPI0 DMA address loop enable
        pub type DMA_LOOP_R = crate::BitReader;
        ///Field `DMA_LOOP` writer - RW, SPI0 DMA address loop enable
        pub type DMA_LOOP_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `AUTO_IF` reader - RW, enable buffer/FIFO accessing to auto clear RB_SPI_IF_BYTE_END interrupt flag
        pub type AUTO_IF_R = crate::BitReader;
        ///Field `AUTO_IF` writer - RW, enable buffer/FIFO accessing to auto clear RB_SPI_IF_BYTE_END interrupt flag
        pub type AUTO_IF_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `BIT_ORDER` reader - RW, SPI bit data order: 0=MSB first, 1=LSB first
        pub type BIT_ORDER_R = crate::BitReader;
        ///Field `BIT_ORDER` writer - RW, SPI bit data order: 0=MSB first, 1=LSB first
        pub type BIT_ORDER_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `MST_DLY_EN` reader - RW, SPI master input delay enable
        pub type MST_DLY_EN_R = crate::BitReader;
        ///Field `MST_DLY_EN` writer - RW, SPI master input delay enable
        pub type MST_DLY_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - RW, SPI0 DMA enable
            #[inline(always)]
            pub fn dma_enable(&self) -> DMA_ENABLE_R {
                DMA_ENABLE_R::new((self.bits & 1) != 0)
            }
            ///Bit 2 - RW, SPI0 DMA address loop enable
            #[inline(always)]
            pub fn dma_loop(&self) -> DMA_LOOP_R {
                DMA_LOOP_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 4 - RW, enable buffer/FIFO accessing to auto clear RB_SPI_IF_BYTE_END interrupt flag
            #[inline(always)]
            pub fn auto_if(&self) -> AUTO_IF_R {
                AUTO_IF_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - RW, SPI bit data order: 0=MSB first, 1=LSB first
            #[inline(always)]
            pub fn bit_order(&self) -> BIT_ORDER_R {
                BIT_ORDER_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - RW, SPI master input delay enable
            #[inline(always)]
            pub fn mst_dly_en(&self) -> MST_DLY_EN_R {
                MST_DLY_EN_R::new(((self.bits >> 6) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RW, SPI0 DMA enable
            #[inline(always)]
            #[must_use]
            pub fn dma_enable(&mut self) -> DMA_ENABLE_W<CTRL_CFG_SPEC> {
                DMA_ENABLE_W::new(self, 0)
            }
            ///Bit 2 - RW, SPI0 DMA address loop enable
            #[inline(always)]
            #[must_use]
            pub fn dma_loop(&mut self) -> DMA_LOOP_W<CTRL_CFG_SPEC> {
                DMA_LOOP_W::new(self, 2)
            }
            ///Bit 4 - RW, enable buffer/FIFO accessing to auto clear RB_SPI_IF_BYTE_END interrupt flag
            #[inline(always)]
            #[must_use]
            pub fn auto_if(&mut self) -> AUTO_IF_W<CTRL_CFG_SPEC> {
                AUTO_IF_W::new(self, 4)
            }
            ///Bit 5 - RW, SPI bit data order: 0=MSB first, 1=LSB first
            #[inline(always)]
            #[must_use]
            pub fn bit_order(&mut self) -> BIT_ORDER_W<CTRL_CFG_SPEC> {
                BIT_ORDER_W::new(self, 5)
            }
            ///Bit 6 - RW, SPI master input delay enable
            #[inline(always)]
            #[must_use]
            pub fn mst_dly_en(&mut self) -> MST_DLY_EN_W<CTRL_CFG_SPEC> {
                MST_DLY_EN_W::new(self, 6)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW, SPI0 configuration control
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`ctrl_cfg::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ctrl_cfg::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct CTRL_CFG_SPEC;
        impl crate::RegisterSpec for CTRL_CFG_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`ctrl_cfg::R`](R) reader structure
        impl crate::Readable for CTRL_CFG_SPEC {}
        ///`write(|w| ..)` method takes [`ctrl_cfg::W`](W) writer structure
        impl crate::Writable for CTRL_CFG_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets CTRL_CFG to value 0
        impl crate::Resettable for CTRL_CFG_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///INTER_EN (rw) register accessor: RW, SPI0 interrupt enable
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`inter_en::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`inter_en::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@inter_en`]
    ///module
    pub type INTER_EN = crate::Reg<inter_en::INTER_EN_SPEC>;
    ///RW, SPI0 interrupt enable
    pub mod inter_en {
        ///Register `INTER_EN` reader
        pub type R = crate::R<INTER_EN_SPEC>;
        ///Register `INTER_EN` writer
        pub type W = crate::W<INTER_EN_SPEC>;
        ///Field `IE_CNT_END` reader - RW, enable interrupt for SPI total byte count end
        pub type IE_CNT_END_R = crate::BitReader;
        ///Field `IE_CNT_END` writer - RW, enable interrupt for SPI total byte count end
        pub type IE_CNT_END_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `IE_BYTE_END` reader - RW, enable interrupt for SPI byte exchanged
        pub type IE_BYTE_END_R = crate::BitReader;
        ///Field `IE_BYTE_END` writer - RW, enable interrupt for SPI byte exchanged
        pub type IE_BYTE_END_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `IE_FIFO_HF` reader - RW, enable interrupt for SPI FIFO half
        pub type IE_FIFO_HF_R = crate::BitReader;
        ///Field `IE_FIFO_HF` writer - RW, enable interrupt for SPI FIFO half
        pub type IE_FIFO_HF_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `IE_DMA_END` reader - RW, enable interrupt for SPI0 DMA completion
        pub type IE_DMA_END_R = crate::BitReader;
        ///Field `IE_DMA_END` writer - RW, enable interrupt for SPI0 DMA completion
        pub type IE_DMA_END_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `IE_FIFO_OV` reader - RW, enable interrupt for SPI0 FIFO overflow
        pub type IE_FIFO_OV_R = crate::BitReader;
        ///Field `IE_FIFO_OV` writer - RW, enable interrupt for SPI0 FIFO overflow
        pub type IE_FIFO_OV_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `IE_FST_BYTE` reader - RW, enable interrupt for SPI0 slave mode first byte received
        pub type IE_FST_BYTE_R = crate::BitReader;
        ///Field `IE_FST_BYTE` writer - RW, enable interrupt for SPI0 slave mode first byte received
        pub type IE_FST_BYTE_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - RW, enable interrupt for SPI total byte count end
            #[inline(always)]
            pub fn ie_cnt_end(&self) -> IE_CNT_END_R {
                IE_CNT_END_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RW, enable interrupt for SPI byte exchanged
            #[inline(always)]
            pub fn ie_byte_end(&self) -> IE_BYTE_END_R {
                IE_BYTE_END_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RW, enable interrupt for SPI FIFO half
            #[inline(always)]
            pub fn ie_fifo_hf(&self) -> IE_FIFO_HF_R {
                IE_FIFO_HF_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RW, enable interrupt for SPI0 DMA completion
            #[inline(always)]
            pub fn ie_dma_end(&self) -> IE_DMA_END_R {
                IE_DMA_END_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RW, enable interrupt for SPI0 FIFO overflow
            #[inline(always)]
            pub fn ie_fifo_ov(&self) -> IE_FIFO_OV_R {
                IE_FIFO_OV_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 7 - RW, enable interrupt for SPI0 slave mode first byte received
            #[inline(always)]
            pub fn ie_fst_byte(&self) -> IE_FST_BYTE_R {
                IE_FST_BYTE_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RW, enable interrupt for SPI total byte count end
            #[inline(always)]
            #[must_use]
            pub fn ie_cnt_end(&mut self) -> IE_CNT_END_W<INTER_EN_SPEC> {
                IE_CNT_END_W::new(self, 0)
            }
            ///Bit 1 - RW, enable interrupt for SPI byte exchanged
            #[inline(always)]
            #[must_use]
            pub fn ie_byte_end(&mut self) -> IE_BYTE_END_W<INTER_EN_SPEC> {
                IE_BYTE_END_W::new(self, 1)
            }
            ///Bit 2 - RW, enable interrupt for SPI FIFO half
            #[inline(always)]
            #[must_use]
            pub fn ie_fifo_hf(&mut self) -> IE_FIFO_HF_W<INTER_EN_SPEC> {
                IE_FIFO_HF_W::new(self, 2)
            }
            ///Bit 3 - RW, enable interrupt for SPI0 DMA completion
            #[inline(always)]
            #[must_use]
            pub fn ie_dma_end(&mut self) -> IE_DMA_END_W<INTER_EN_SPEC> {
                IE_DMA_END_W::new(self, 3)
            }
            ///Bit 4 - RW, enable interrupt for SPI0 FIFO overflow
            #[inline(always)]
            #[must_use]
            pub fn ie_fifo_ov(&mut self) -> IE_FIFO_OV_W<INTER_EN_SPEC> {
                IE_FIFO_OV_W::new(self, 4)
            }
            ///Bit 7 - RW, enable interrupt for SPI0 slave mode first byte received
            #[inline(always)]
            #[must_use]
            pub fn ie_fst_byte(&mut self) -> IE_FST_BYTE_W<INTER_EN_SPEC> {
                IE_FST_BYTE_W::new(self, 7)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW, SPI0 interrupt enable
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`inter_en::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`inter_en::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct INTER_EN_SPEC;
        impl crate::RegisterSpec for INTER_EN_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`inter_en::R`](R) reader structure
        impl crate::Readable for INTER_EN_SPEC {}
        ///`write(|w| ..)` method takes [`inter_en::W`](W) writer structure
        impl crate::Writable for INTER_EN_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets INTER_EN to value 0
        impl crate::Resettable for INTER_EN_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///BUFFER (rw) register accessor: RW, SPI0 data buffer
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`buffer::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`buffer::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@buffer`]
    ///module
    pub type BUFFER = crate::Reg<buffer::BUFFER_SPEC>;
    ///RW, SPI0 data buffer
    pub mod buffer {
        ///Register `BUFFER` reader
        pub type R = crate::R<BUFFER_SPEC>;
        ///Register `BUFFER` writer
        pub type W = crate::W<BUFFER_SPEC>;
        ///Field `BUFFER` reader - RW, SPI0 data buffer
        pub type BUFFER_R = crate::FieldReader;
        ///Field `BUFFER` writer - RW, SPI0 data buffer
        pub type BUFFER_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            ///Bits 0:7 - RW, SPI0 data buffer
            #[inline(always)]
            pub fn buffer(&self) -> BUFFER_R {
                BUFFER_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:7 - RW, SPI0 data buffer
            #[inline(always)]
            #[must_use]
            pub fn buffer(&mut self) -> BUFFER_W<BUFFER_SPEC> {
                BUFFER_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW, SPI0 data buffer
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`buffer::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`buffer::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct BUFFER_SPEC;
        impl crate::RegisterSpec for BUFFER_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`buffer::R`](R) reader structure
        impl crate::Readable for BUFFER_SPEC {}
        ///`write(|w| ..)` method takes [`buffer::W`](W) writer structure
        impl crate::Writable for BUFFER_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets BUFFER to value 0
        impl crate::Resettable for BUFFER_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///RUN_FLAG (r) register accessor: RO, SPI0 work flag
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`run_flag::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@run_flag`]
    ///module
    pub type RUN_FLAG = crate::Reg<run_flag::RUN_FLAG_SPEC>;
    ///RO, SPI0 work flag
    pub mod run_flag {
        ///Register `RUN_FLAG` reader
        pub type R = crate::R<RUN_FLAG_SPEC>;
        ///Field `SLV_CMD_ACT` reader - RO, SPI0 slave first byte or command flag
        pub type SLV_CMD_ACT_R = crate::BitReader;
        ///Field `FIFO_READY` reader - RO, SPI FIFO ready status
        pub type FIFO_READY_R = crate::BitReader;
        ///Field `SLV_CS_LOAD` reader - RO, SPI0 slave chip-select loading status
        pub type SLV_CS_LOAD_R = crate::BitReader;
        ///Field `SLV_SELECT` reader - RO, SPI0 slave selection status
        pub type SLV_SELECT_R = crate::BitReader;
        impl R {
            ///Bit 4 - RO, SPI0 slave first byte or command flag
            #[inline(always)]
            pub fn slv_cmd_act(&self) -> SLV_CMD_ACT_R {
                SLV_CMD_ACT_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - RO, SPI FIFO ready status
            #[inline(always)]
            pub fn fifo_ready(&self) -> FIFO_READY_R {
                FIFO_READY_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - RO, SPI0 slave chip-select loading status
            #[inline(always)]
            pub fn slv_cs_load(&self) -> SLV_CS_LOAD_R {
                SLV_CS_LOAD_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - RO, SPI0 slave selection status
            #[inline(always)]
            pub fn slv_select(&self) -> SLV_SELECT_R {
                SLV_SELECT_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        ///RO, SPI0 work flag
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`run_flag::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct RUN_FLAG_SPEC;
        impl crate::RegisterSpec for RUN_FLAG_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`run_flag::R`](R) reader structure
        impl crate::Readable for RUN_FLAG_SPEC {}
        ///`reset()` method sets RUN_FLAG to value 0
        impl crate::Resettable for RUN_FLAG_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///INT_FLAG (rw) register accessor: RW1, SPI0 interrupt flag
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`int_flag::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`int_flag::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@int_flag`]
    ///module
    pub type INT_FLAG = crate::Reg<int_flag::INT_FLAG_SPEC>;
    ///RW1, SPI0 interrupt flag
    pub mod int_flag {
        ///Register `INT_FLAG` reader
        pub type R = crate::R<INT_FLAG_SPEC>;
        ///Register `INT_FLAG` writer
        pub type W = crate::W<INT_FLAG_SPEC>;
        ///Field `IF_CNT_END` reader - RW1, interrupt flag for SPI total byte count end
        pub type IF_CNT_END_R = crate::BitReader;
        ///Field `IF_CNT_END` writer - RW1, interrupt flag for SPI total byte count end
        pub type IF_CNT_END_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `IF_BYTE_END` reader - RW1, interrupt flag for SPI byte exchanged
        pub type IF_BYTE_END_R = crate::BitReader;
        ///Field `IF_BYTE_END` writer - RW1, interrupt flag for SPI byte exchanged
        pub type IF_BYTE_END_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `IF_FIFO_HF` reader - RW1, interrupt flag for SPI FIFO half
        pub type IF_FIFO_HF_R = crate::BitReader;
        ///Field `IF_FIFO_HF` writer - RW1, interrupt flag for SPI FIFO half
        pub type IF_FIFO_HF_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `IF_DMA_END` reader - RW1, interrupt flag for SPI0 DMA completion
        pub type IF_DMA_END_R = crate::BitReader;
        ///Field `IF_DMA_END` writer - RW1, interrupt flag for SPI0 DMA completion
        pub type IF_DMA_END_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `IF_FIFO_OV` reader - RW1, interrupt flag for SPI0 FIFO overflow
        pub type IF_FIFO_OV_R = crate::BitReader;
        ///Field `IF_FIFO_OV` writer - RW1, interrupt flag for SPI0 FIFO overflow
        pub type IF_FIFO_OV_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FREE` reader - RO, current SPI free status
        pub type FREE_R = crate::BitReader;
        ///Field `FREE` writer - RO, current SPI free status
        pub type FREE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `IF_FST_BYTE` reader - RW1, interrupt flag for SPI0 slave mode first byte received
        pub type IF_FST_BYTE_R = crate::BitReader;
        ///Field `IF_FST_BYTE` writer - RW1, interrupt flag for SPI0 slave mode first byte received
        pub type IF_FST_BYTE_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - RW1, interrupt flag for SPI total byte count end
            #[inline(always)]
            pub fn if_cnt_end(&self) -> IF_CNT_END_R {
                IF_CNT_END_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RW1, interrupt flag for SPI byte exchanged
            #[inline(always)]
            pub fn if_byte_end(&self) -> IF_BYTE_END_R {
                IF_BYTE_END_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RW1, interrupt flag for SPI FIFO half
            #[inline(always)]
            pub fn if_fifo_hf(&self) -> IF_FIFO_HF_R {
                IF_FIFO_HF_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RW1, interrupt flag for SPI0 DMA completion
            #[inline(always)]
            pub fn if_dma_end(&self) -> IF_DMA_END_R {
                IF_DMA_END_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RW1, interrupt flag for SPI0 FIFO overflow
            #[inline(always)]
            pub fn if_fifo_ov(&self) -> IF_FIFO_OV_R {
                IF_FIFO_OV_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 6 - RO, current SPI free status
            #[inline(always)]
            pub fn free(&self) -> FREE_R {
                FREE_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - RW1, interrupt flag for SPI0 slave mode first byte received
            #[inline(always)]
            pub fn if_fst_byte(&self) -> IF_FST_BYTE_R {
                IF_FST_BYTE_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RW1, interrupt flag for SPI total byte count end
            #[inline(always)]
            #[must_use]
            pub fn if_cnt_end(&mut self) -> IF_CNT_END_W<INT_FLAG_SPEC> {
                IF_CNT_END_W::new(self, 0)
            }
            ///Bit 1 - RW1, interrupt flag for SPI byte exchanged
            #[inline(always)]
            #[must_use]
            pub fn if_byte_end(&mut self) -> IF_BYTE_END_W<INT_FLAG_SPEC> {
                IF_BYTE_END_W::new(self, 1)
            }
            ///Bit 2 - RW1, interrupt flag for SPI FIFO half
            #[inline(always)]
            #[must_use]
            pub fn if_fifo_hf(&mut self) -> IF_FIFO_HF_W<INT_FLAG_SPEC> {
                IF_FIFO_HF_W::new(self, 2)
            }
            ///Bit 3 - RW1, interrupt flag for SPI0 DMA completion
            #[inline(always)]
            #[must_use]
            pub fn if_dma_end(&mut self) -> IF_DMA_END_W<INT_FLAG_SPEC> {
                IF_DMA_END_W::new(self, 3)
            }
            ///Bit 4 - RW1, interrupt flag for SPI0 FIFO overflow
            #[inline(always)]
            #[must_use]
            pub fn if_fifo_ov(&mut self) -> IF_FIFO_OV_W<INT_FLAG_SPEC> {
                IF_FIFO_OV_W::new(self, 4)
            }
            ///Bit 6 - RO, current SPI free status
            #[inline(always)]
            #[must_use]
            pub fn free(&mut self) -> FREE_W<INT_FLAG_SPEC> {
                FREE_W::new(self, 6)
            }
            ///Bit 7 - RW1, interrupt flag for SPI0 slave mode first byte received
            #[inline(always)]
            #[must_use]
            pub fn if_fst_byte(&mut self) -> IF_FST_BYTE_W<INT_FLAG_SPEC> {
                IF_FST_BYTE_W::new(self, 7)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW1, SPI0 interrupt flag
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`int_flag::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`int_flag::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct INT_FLAG_SPEC;
        impl crate::RegisterSpec for INT_FLAG_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`int_flag::R`](R) reader structure
        impl crate::Readable for INT_FLAG_SPEC {}
        ///`write(|w| ..)` method takes [`int_flag::W`](W) writer structure
        impl crate::Writable for INT_FLAG_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets INT_FLAG to value 0x40
        impl crate::Resettable for INT_FLAG_SPEC {
            const RESET_VALUE: u8 = 0x40;
        }
    }
    ///FIFO_COUNT (r) register accessor: RO, SPI0 FIFO count status
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`fifo_count::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@fifo_count`]
    ///module
    pub type FIFO_COUNT = crate::Reg<fifo_count::FIFO_COUNT_SPEC>;
    ///RO, SPI0 FIFO count status
    pub mod fifo_count {
        ///Register `FIFO_COUNT` reader
        pub type R = crate::R<FIFO_COUNT_SPEC>;
        ///Field `FIFO_COUNT` reader - RO, SPI0 FIFO count status
        pub type FIFO_COUNT_R = crate::FieldReader;
        impl R {
            ///Bits 0:7 - RO, SPI0 FIFO count status
            #[inline(always)]
            pub fn fifo_count(&self) -> FIFO_COUNT_R {
                FIFO_COUNT_R::new(self.bits)
            }
        }
        ///RO, SPI0 FIFO count status
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`fifo_count::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct FIFO_COUNT_SPEC;
        impl crate::RegisterSpec for FIFO_COUNT_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`fifo_count::R`](R) reader structure
        impl crate::Readable for FIFO_COUNT_SPEC {}
        ///`reset()` method sets FIFO_COUNT to value 0
        impl crate::Resettable for FIFO_COUNT_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///TOTAL_CNT (rw) register accessor: RW, SPI0 total byte count, only low 12 bit
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`total_cnt::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`total_cnt::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@total_cnt`]
    ///module
    pub type TOTAL_CNT = crate::Reg<total_cnt::TOTAL_CNT_SPEC>;
    ///RW, SPI0 total byte count, only low 12 bit
    pub mod total_cnt {
        ///Register `TOTAL_CNT` reader
        pub type R = crate::R<TOTAL_CNT_SPEC>;
        ///Register `TOTAL_CNT` writer
        pub type W = crate::W<TOTAL_CNT_SPEC>;
        ///Field `TOTAL_CNT` reader - RW, SPI0 total byte count, only low 12 bit
        pub type TOTAL_CNT_R = crate::FieldReader<u16>;
        ///Field `TOTAL_CNT` writer - RW, SPI0 total byte count, only low 12 bit
        pub type TOTAL_CNT_W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            ///Bits 0:15 - RW, SPI0 total byte count, only low 12 bit
            #[inline(always)]
            pub fn total_cnt(&self) -> TOTAL_CNT_R {
                TOTAL_CNT_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - RW, SPI0 total byte count, only low 12 bit
            #[inline(always)]
            #[must_use]
            pub fn total_cnt(&mut self) -> TOTAL_CNT_W<TOTAL_CNT_SPEC> {
                TOTAL_CNT_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW, SPI0 total byte count, only low 12 bit
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`total_cnt::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`total_cnt::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct TOTAL_CNT_SPEC;
        impl crate::RegisterSpec for TOTAL_CNT_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`total_cnt::R`](R) reader structure
        impl crate::Readable for TOTAL_CNT_SPEC {}
        ///`write(|w| ..)` method takes [`total_cnt::W`](W) writer structure
        impl crate::Writable for TOTAL_CNT_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets TOTAL_CNT to value 0
        impl crate::Resettable for TOTAL_CNT_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///FIFO (rw) register accessor: RO/WO, SPI0 FIFO register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`fifo::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`fifo::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@fifo`]
    ///module
    pub type FIFO = crate::Reg<fifo::FIFO_SPEC>;
    ///RO/WO, SPI0 FIFO register
    pub mod fifo {
        ///Register `FIFO` reader
        pub type R = crate::R<FIFO_SPEC>;
        ///Register `FIFO` writer
        pub type W = crate::W<FIFO_SPEC>;
        ///Field `FIFO` reader - RO/WO, SPI0 FIFO register
        pub type FIFO_R = crate::FieldReader;
        ///Field `FIFO` writer - RO/WO, SPI0 FIFO register
        pub type FIFO_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            ///Bits 0:7 - RO/WO, SPI0 FIFO register
            #[inline(always)]
            pub fn fifo(&self) -> FIFO_R {
                FIFO_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:7 - RO/WO, SPI0 FIFO register
            #[inline(always)]
            #[must_use]
            pub fn fifo(&mut self) -> FIFO_W<FIFO_SPEC> {
                FIFO_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RO/WO, SPI0 FIFO register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`fifo::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`fifo::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct FIFO_SPEC;
        impl crate::RegisterSpec for FIFO_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`fifo::R`](R) reader structure
        impl crate::Readable for FIFO_SPEC {}
        ///`write(|w| ..)` method takes [`fifo::W`](W) writer structure
        impl crate::Writable for FIFO_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets FIFO to value 0
        impl crate::Resettable for FIFO_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///FIFO_COUNT1 (r) register accessor: RO, SPI0 FIFO count status
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`fifo_count1::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@fifo_count1`]
    ///module
    pub type FIFO_COUNT1 = crate::Reg<fifo_count1::FIFO_COUNT1_SPEC>;
    ///RO, SPI0 FIFO count status
    pub mod fifo_count1 {
        ///Register `FIFO_COUNT1` reader
        pub type R = crate::R<FIFO_COUNT1_SPEC>;
        ///Field `FIFO_COUNT1` reader - RO, SPI0 FIFO count status
        pub type FIFO_COUNT1_R = crate::FieldReader;
        impl R {
            ///Bits 0:7 - RO, SPI0 FIFO count status
            #[inline(always)]
            pub fn fifo_count1(&self) -> FIFO_COUNT1_R {
                FIFO_COUNT1_R::new(self.bits)
            }
        }
        ///RO, SPI0 FIFO count status
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`fifo_count1::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct FIFO_COUNT1_SPEC;
        impl crate::RegisterSpec for FIFO_COUNT1_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`fifo_count1::R`](R) reader structure
        impl crate::Readable for FIFO_COUNT1_SPEC {}
        ///`reset()` method sets FIFO_COUNT1 to value 0
        impl crate::Resettable for FIFO_COUNT1_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///DMA_NOW (rw) register accessor: RW, SPI0 DMA current address
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`dma_now::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dma_now::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@dma_now`]
    ///module
    pub type DMA_NOW = crate::Reg<dma_now::DMA_NOW_SPEC>;
    ///RW, SPI0 DMA current address
    pub mod dma_now {
        ///Register `DMA_NOW` reader
        pub type R = crate::R<DMA_NOW_SPEC>;
        ///Register `DMA_NOW` writer
        pub type W = crate::W<DMA_NOW_SPEC>;
        ///Field `DMA_NOW` reader - RW, SPI0 DMA current address
        pub type DMA_NOW_R = crate::FieldReader<u16>;
        ///Field `DMA_NOW` writer - RW, SPI0 DMA current address
        pub type DMA_NOW_W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            ///Bits 0:15 - RW, SPI0 DMA current address
            #[inline(always)]
            pub fn dma_now(&self) -> DMA_NOW_R {
                DMA_NOW_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - RW, SPI0 DMA current address
            #[inline(always)]
            #[must_use]
            pub fn dma_now(&mut self) -> DMA_NOW_W<DMA_NOW_SPEC> {
                DMA_NOW_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW, SPI0 DMA current address
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`dma_now::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dma_now::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct DMA_NOW_SPEC;
        impl crate::RegisterSpec for DMA_NOW_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`dma_now::R`](R) reader structure
        impl crate::Readable for DMA_NOW_SPEC {}
        ///`write(|w| ..)` method takes [`dma_now::W`](W) writer structure
        impl crate::Writable for DMA_NOW_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets DMA_NOW to value 0
        impl crate::Resettable for DMA_NOW_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///DMA_BEG (rw) register accessor: RW, SPI0 DMA begin address
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`dma_beg::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dma_beg::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@dma_beg`]
    ///module
    pub type DMA_BEG = crate::Reg<dma_beg::DMA_BEG_SPEC>;
    ///RW, SPI0 DMA begin address
    pub mod dma_beg {
        ///Register `DMA_BEG` reader
        pub type R = crate::R<DMA_BEG_SPEC>;
        ///Register `DMA_BEG` writer
        pub type W = crate::W<DMA_BEG_SPEC>;
        ///Field `DMA_BEG` reader - RW, SPI0 DMA begin address
        pub type DMA_BEG_R = crate::FieldReader<u16>;
        ///Field `DMA_BEG` writer - RW, SPI0 DMA begin address
        pub type DMA_BEG_W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            ///Bits 0:15 - RW, SPI0 DMA begin address
            #[inline(always)]
            pub fn dma_beg(&self) -> DMA_BEG_R {
                DMA_BEG_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - RW, SPI0 DMA begin address
            #[inline(always)]
            #[must_use]
            pub fn dma_beg(&mut self) -> DMA_BEG_W<DMA_BEG_SPEC> {
                DMA_BEG_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW, SPI0 DMA begin address
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`dma_beg::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dma_beg::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct DMA_BEG_SPEC;
        impl crate::RegisterSpec for DMA_BEG_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`dma_beg::R`](R) reader structure
        impl crate::Readable for DMA_BEG_SPEC {}
        ///`write(|w| ..)` method takes [`dma_beg::W`](W) writer structure
        impl crate::Writable for DMA_BEG_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets DMA_BEG to value 0
        impl crate::Resettable for DMA_BEG_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///DMA_END (rw) register accessor: RW, SPI0 DMA end address
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`dma_end::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dma_end::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@dma_end`]
    ///module
    pub type DMA_END = crate::Reg<dma_end::DMA_END_SPEC>;
    ///RW, SPI0 DMA end address
    pub mod dma_end {
        ///Register `DMA_END` reader
        pub type R = crate::R<DMA_END_SPEC>;
        ///Register `DMA_END` writer
        pub type W = crate::W<DMA_END_SPEC>;
        ///Field `DMA_END` reader - RW, SPI0 DMA end address
        pub type DMA_END_R = crate::FieldReader<u16>;
        ///Field `DMA_END` writer - RW, SPI0 DMA end address
        pub type DMA_END_W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            ///Bits 0:15 - RW, SPI0 DMA end address
            #[inline(always)]
            pub fn dma_end(&self) -> DMA_END_R {
                DMA_END_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - RW, SPI0 DMA end address
            #[inline(always)]
            #[must_use]
            pub fn dma_end(&mut self) -> DMA_END_W<DMA_END_SPEC> {
                DMA_END_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW, SPI0 DMA end address
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`dma_end::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dma_end::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct DMA_END_SPEC;
        impl crate::RegisterSpec for DMA_END_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`dma_end::R`](R) reader structure
        impl crate::Readable for DMA_END_SPEC {}
        ///`write(|w| ..)` method takes [`dma_end::W`](W) writer structure
        impl crate::Writable for DMA_END_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets DMA_END to value 0
        impl crate::Resettable for DMA_END_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///CLOCK_DIV (rw) register accessor: SPI clock divider
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`clock_div::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`clock_div::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@clock_div`]
    ///module
    pub type CLOCK_DIV = crate::Reg<clock_div::CLOCK_DIV_SPEC>;
    ///SPI clock divider
    pub mod clock_div {
        ///Register `CLOCK_DIV` reader
        pub type R = crate::R<CLOCK_DIV_SPEC>;
        ///Register `CLOCK_DIV` writer
        pub type W = crate::W<CLOCK_DIV_SPEC>;
        ///Field `CLOCK_DIV` reader - SPI clock divider in master mode
        pub type CLOCK_DIV_R = crate::FieldReader;
        ///Field `CLOCK_DIV` writer - SPI clock divider in master mode
        pub type CLOCK_DIV_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            ///Bits 0:7 - SPI clock divider in master mode
            #[inline(always)]
            pub fn clock_div(&self) -> CLOCK_DIV_R {
                CLOCK_DIV_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:7 - SPI clock divider in master mode
            #[inline(always)]
            #[must_use]
            pub fn clock_div(&mut self) -> CLOCK_DIV_W<CLOCK_DIV_SPEC> {
                CLOCK_DIV_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///SPI clock divider
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`clock_div::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`clock_div::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct CLOCK_DIV_SPEC;
        impl crate::RegisterSpec for CLOCK_DIV_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`clock_div::R`](R) reader structure
        impl crate::Readable for CLOCK_DIV_SPEC {}
        ///`write(|w| ..)` method takes [`clock_div::W`](W) writer structure
        impl crate::Writable for CLOCK_DIV_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets CLOCK_DIV to value 0
        impl crate::Resettable for CLOCK_DIV_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///SLAVE_PRE (rw) register accessor: SPI slave prescaler
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`slave_pre::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`slave_pre::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@slave_pre`]
    ///module
    pub type SLAVE_PRE = crate::Reg<slave_pre::SLAVE_PRE_SPEC>;
    ///SPI slave prescaler
    pub mod slave_pre {
        ///Register `SLAVE_PRE` reader
        pub type R = crate::R<SLAVE_PRE_SPEC>;
        ///Register `SLAVE_PRE` writer
        pub type W = crate::W<SLAVE_PRE_SPEC>;
        ///Field `SLAVE_PRE` reader - SPI slave prescaler
        pub type SLAVE_PRE_R = crate::FieldReader;
        ///Field `SLAVE_PRE` writer - SPI slave prescaler
        pub type SLAVE_PRE_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            ///Bits 0:7 - SPI slave prescaler
            #[inline(always)]
            pub fn slave_pre(&self) -> SLAVE_PRE_R {
                SLAVE_PRE_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:7 - SPI slave prescaler
            #[inline(always)]
            #[must_use]
            pub fn slave_pre(&mut self) -> SLAVE_PRE_W<SLAVE_PRE_SPEC> {
                SLAVE_PRE_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///SPI slave prescaler
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`slave_pre::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`slave_pre::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct SLAVE_PRE_SPEC;
        impl crate::RegisterSpec for SLAVE_PRE_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`slave_pre::R`](R) reader structure
        impl crate::Readable for SLAVE_PRE_SPEC {}
        ///`write(|w| ..)` method takes [`slave_pre::W`](W) writer structure
        impl crate::Writable for SLAVE_PRE_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets SLAVE_PRE to value 0
        impl crate::Resettable for SLAVE_PRE_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
}
///SPI1 register
pub struct SPI1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for SPI1 {}
impl SPI1 {
    ///Pointer to the register block
    pub const PTR: *const spi1::RegisterBlock = 0x4000_4400 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const spi1::RegisterBlock {
        Self::PTR
    }
    /// Steal an instance of this peripheral
    ///
    /// # Safety
    ///
    /// Ensure that the new instance of the peripheral cannot be used in a way
    /// that may race with any existing instances, for example by only
    /// accessing read-only or write-only registers, or by consuming the
    /// original peripheral and using critical sections to coordinate
    /// access between multiple new instances.
    ///
    /// Additionally, other software such as HALs may rely on only one
    /// peripheral instance existing to ensure memory safety; ensure
    /// no stolen instances are passed to such software.
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for SPI1 {
    type Target = spi1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for SPI1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("SPI1").finish()
    }
}
///SPI1 register
pub mod spi1 {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        ctrl_mod: CTRL_MOD,
        ctrl_cfg: CTRL_CFG,
        inter_en: INTER_EN,
        clock_div: CLOCK_DIV,
        buffer: BUFFER,
        run_flag: RUN_FLAG,
        int_flag: INT_FLAG,
        fifo_count: FIFO_COUNT,
        _reserved8: [u8; 0x04],
        total_cnt: TOTAL_CNT,
        _reserved9: [u8; 0x02],
        fifo: FIFO,
        _reserved10: [u8; 0x02],
        fifo_count1: FIFO_COUNT1,
    }
    impl RegisterBlock {
        ///0x00 - RW, SPI1 mode control
        #[inline(always)]
        pub const fn ctrl_mod(&self) -> &CTRL_MOD {
            &self.ctrl_mod
        }
        ///0x01 - RW, SPI1 configuration control
        #[inline(always)]
        pub const fn ctrl_cfg(&self) -> &CTRL_CFG {
            &self.ctrl_cfg
        }
        ///0x02 - RW, SPI1 interrupt enable
        #[inline(always)]
        pub const fn inter_en(&self) -> &INTER_EN {
            &self.inter_en
        }
        ///0x03 - RW, SPI1 master clock divisor;
        #[inline(always)]
        pub const fn clock_div(&self) -> &CLOCK_DIV {
            &self.clock_div
        }
        ///0x04 - RW, SPI1 data buffer
        #[inline(always)]
        pub const fn buffer(&self) -> &BUFFER {
            &self.buffer
        }
        ///0x05 - RO, SPI1 work flag
        #[inline(always)]
        pub const fn run_flag(&self) -> &RUN_FLAG {
            &self.run_flag
        }
        ///0x06 - RW1, SPI1 interrupt flag
        #[inline(always)]
        pub const fn int_flag(&self) -> &INT_FLAG {
            &self.int_flag
        }
        ///0x07 - RO, SPI1 FIFO count status
        #[inline(always)]
        pub const fn fifo_count(&self) -> &FIFO_COUNT {
            &self.fifo_count
        }
        ///0x0c - RW, SPI1 total byte count, only low 12 bit
        #[inline(always)]
        pub const fn total_cnt(&self) -> &TOTAL_CNT {
            &self.total_cnt
        }
        ///0x10 - RO/WO, SPI1 FIFO register
        #[inline(always)]
        pub const fn fifo(&self) -> &FIFO {
            &self.fifo
        }
        ///0x13 - RO, SPI1 FIFO count status
        #[inline(always)]
        pub const fn fifo_count1(&self) -> &FIFO_COUNT1 {
            &self.fifo_count1
        }
    }
    ///CTRL_MOD (rw) register accessor: RW, SPI1 mode control
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`ctrl_mod::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ctrl_mod::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@ctrl_mod`]
    ///module
    pub type CTRL_MOD = crate::Reg<ctrl_mod::CTRL_MOD_SPEC>;
    ///RW, SPI1 mode control
    pub mod ctrl_mod {
        ///Register `CTRL_MOD` reader
        pub type R = crate::R<CTRL_MOD_SPEC>;
        ///Register `CTRL_MOD` writer
        pub type W = crate::W<CTRL_MOD_SPEC>;
        ///Field `MODE_SLAVE` reader - RW, SPI0 slave mode: 0=master or host, 1=slave or device
        pub type MODE_SLAVE_R = crate::BitReader;
        ///Field `MODE_SLAVE` writer - RW, SPI0 slave mode: 0=master or host, 1=slave or device
        pub type MODE_SLAVE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `ALL_CLEAR` reader - RW, force clear SPI FIFO and count
        pub type ALL_CLEAR_R = crate::BitReader;
        ///Field `ALL_CLEAR` writer - RW, force clear SPI FIFO and count
        pub type ALL_CLEAR_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TWO_WIRE_MODE` reader - RW, SPI0 enable 2 wire mode for slave: 0=3wire(SCK0,MOSI,MISO), 1=2wire(SCK0,MISO=MXSX)
        pub type TWO_WIRE_MODE_R = crate::BitReader;
        ///Field `TWO_WIRE_MODE` writer - RW, SPI0 enable 2 wire mode for slave: 0=3wire(SCK0,MOSI,MISO), 1=2wire(SCK0,MISO=MXSX)
        pub type TWO_WIRE_MODE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `MST_SCK_MOD` reader - RW, SPI master clock mode: 0=mode 0, 1=mode 3;RW, SPI0 slave command mode: 0=byte stream, 1=first byte command
        pub type MST_SCK_MOD_R = crate::BitReader;
        ///Field `MST_SCK_MOD` writer - RW, SPI master clock mode: 0=mode 0, 1=mode 3;RW, SPI0 slave command mode: 0=byte stream, 1=first byte command
        pub type MST_SCK_MOD_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `SLV_CMD_MOD` reader - SPI slave command mode
        pub type SLV_CMD_MOD_R = crate::BitReader;
        ///Field `SLV_CMD_MOD` writer - SPI slave command mode
        pub type SLV_CMD_MOD_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FIFO_DIR` reader - RW, SPI FIFO direction: 0=out(write @master mode), 1=in(read @master mode)
        pub type FIFO_DIR_R = crate::BitReader;
        ///Field `FIFO_DIR` writer - RW, SPI FIFO direction: 0=out(write @master mode), 1=in(read @master mode)
        pub type FIFO_DIR_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `SCK_OE` reader - RW, SPI SCK output enable
        pub type SCK_OE_R = crate::BitReader;
        ///Field `SCK_OE` writer - RW, SPI SCK output enable
        pub type SCK_OE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `MOSI_OE` reader - RW, SPI MOSI output enable
        pub type MOSI_OE_R = crate::BitReader;
        ///Field `MOSI_OE` writer - RW, SPI MOSI output enable
        pub type MOSI_OE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `MISO_OE` reader - RW, SPI MISO output enable
        pub type MISO_OE_R = crate::BitReader;
        ///Field `MISO_OE` writer - RW, SPI MISO output enable
        pub type MISO_OE_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - RW, SPI0 slave mode: 0=master or host, 1=slave or device
            #[inline(always)]
            pub fn mode_slave(&self) -> MODE_SLAVE_R {
                MODE_SLAVE_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RW, force clear SPI FIFO and count
            #[inline(always)]
            pub fn all_clear(&self) -> ALL_CLEAR_R {
                ALL_CLEAR_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RW, SPI0 enable 2 wire mode for slave: 0=3wire(SCK0,MOSI,MISO), 1=2wire(SCK0,MISO=MXSX)
            #[inline(always)]
            pub fn two_wire_mode(&self) -> TWO_WIRE_MODE_R {
                TWO_WIRE_MODE_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RW, SPI master clock mode: 0=mode 0, 1=mode 3;RW, SPI0 slave command mode: 0=byte stream, 1=first byte command
            #[inline(always)]
            pub fn mst_sck_mod(&self) -> MST_SCK_MOD_R {
                MST_SCK_MOD_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 3 - SPI slave command mode
            #[inline(always)]
            pub fn slv_cmd_mod(&self) -> SLV_CMD_MOD_R {
                SLV_CMD_MOD_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RW, SPI FIFO direction: 0=out(write @master mode), 1=in(read @master mode)
            #[inline(always)]
            pub fn fifo_dir(&self) -> FIFO_DIR_R {
                FIFO_DIR_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - RW, SPI SCK output enable
            #[inline(always)]
            pub fn sck_oe(&self) -> SCK_OE_R {
                SCK_OE_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - RW, SPI MOSI output enable
            #[inline(always)]
            pub fn mosi_oe(&self) -> MOSI_OE_R {
                MOSI_OE_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - RW, SPI MISO output enable
            #[inline(always)]
            pub fn miso_oe(&self) -> MISO_OE_R {
                MISO_OE_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RW, SPI0 slave mode: 0=master or host, 1=slave or device
            #[inline(always)]
            #[must_use]
            pub fn mode_slave(&mut self) -> MODE_SLAVE_W<CTRL_MOD_SPEC> {
                MODE_SLAVE_W::new(self, 0)
            }
            ///Bit 1 - RW, force clear SPI FIFO and count
            #[inline(always)]
            #[must_use]
            pub fn all_clear(&mut self) -> ALL_CLEAR_W<CTRL_MOD_SPEC> {
                ALL_CLEAR_W::new(self, 1)
            }
            ///Bit 2 - RW, SPI0 enable 2 wire mode for slave: 0=3wire(SCK0,MOSI,MISO), 1=2wire(SCK0,MISO=MXSX)
            #[inline(always)]
            #[must_use]
            pub fn two_wire_mode(&mut self) -> TWO_WIRE_MODE_W<CTRL_MOD_SPEC> {
                TWO_WIRE_MODE_W::new(self, 2)
            }
            ///Bit 3 - RW, SPI master clock mode: 0=mode 0, 1=mode 3;RW, SPI0 slave command mode: 0=byte stream, 1=first byte command
            #[inline(always)]
            #[must_use]
            pub fn mst_sck_mod(&mut self) -> MST_SCK_MOD_W<CTRL_MOD_SPEC> {
                MST_SCK_MOD_W::new(self, 3)
            }
            ///Bit 3 - SPI slave command mode
            #[inline(always)]
            #[must_use]
            pub fn slv_cmd_mod(&mut self) -> SLV_CMD_MOD_W<CTRL_MOD_SPEC> {
                SLV_CMD_MOD_W::new(self, 3)
            }
            ///Bit 4 - RW, SPI FIFO direction: 0=out(write @master mode), 1=in(read @master mode)
            #[inline(always)]
            #[must_use]
            pub fn fifo_dir(&mut self) -> FIFO_DIR_W<CTRL_MOD_SPEC> {
                FIFO_DIR_W::new(self, 4)
            }
            ///Bit 5 - RW, SPI SCK output enable
            #[inline(always)]
            #[must_use]
            pub fn sck_oe(&mut self) -> SCK_OE_W<CTRL_MOD_SPEC> {
                SCK_OE_W::new(self, 5)
            }
            ///Bit 6 - RW, SPI MOSI output enable
            #[inline(always)]
            #[must_use]
            pub fn mosi_oe(&mut self) -> MOSI_OE_W<CTRL_MOD_SPEC> {
                MOSI_OE_W::new(self, 6)
            }
            ///Bit 7 - RW, SPI MISO output enable
            #[inline(always)]
            #[must_use]
            pub fn miso_oe(&mut self) -> MISO_OE_W<CTRL_MOD_SPEC> {
                MISO_OE_W::new(self, 7)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW, SPI1 mode control
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`ctrl_mod::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ctrl_mod::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct CTRL_MOD_SPEC;
        impl crate::RegisterSpec for CTRL_MOD_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`ctrl_mod::R`](R) reader structure
        impl crate::Readable for CTRL_MOD_SPEC {}
        ///`write(|w| ..)` method takes [`ctrl_mod::W`](W) writer structure
        impl crate::Writable for CTRL_MOD_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets CTRL_MOD to value 0x02
        impl crate::Resettable for CTRL_MOD_SPEC {
            const RESET_VALUE: u8 = 0x02;
        }
    }
    ///CTRL_CFG (rw) register accessor: RW, SPI1 configuration control
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`ctrl_cfg::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ctrl_cfg::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@ctrl_cfg`]
    ///module
    pub type CTRL_CFG = crate::Reg<ctrl_cfg::CTRL_CFG_SPEC>;
    ///RW, SPI1 configuration control
    pub mod ctrl_cfg {
        ///Register `CTRL_CFG` reader
        pub type R = crate::R<CTRL_CFG_SPEC>;
        ///Register `CTRL_CFG` writer
        pub type W = crate::W<CTRL_CFG_SPEC>;
        ///Field `DMA_ENABLE` reader - RW, SPI0 DMA enable
        pub type DMA_ENABLE_R = crate::BitReader;
        ///Field `DMA_ENABLE` writer - RW, SPI0 DMA enable
        pub type DMA_ENABLE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `DMA_LOOP` reader - RW, SPI0 DMA address loop enable
        pub type DMA_LOOP_R = crate::BitReader;
        ///Field `DMA_LOOP` writer - RW, SPI0 DMA address loop enable
        pub type DMA_LOOP_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `AUTO_IF` reader - RW, enable buffer/FIFO accessing to auto clear RB_SPI_IF_BYTE_END interrupt flag
        pub type AUTO_IF_R = crate::BitReader;
        ///Field `AUTO_IF` writer - RW, enable buffer/FIFO accessing to auto clear RB_SPI_IF_BYTE_END interrupt flag
        pub type AUTO_IF_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `BIT_ORDER` reader - RW, SPI bit data order: 0=MSB first, 1=LSB first
        pub type BIT_ORDER_R = crate::BitReader;
        ///Field `BIT_ORDER` writer - RW, SPI bit data order: 0=MSB first, 1=LSB first
        pub type BIT_ORDER_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `MST_DLY_EN` reader - RW, SPI master input delay enable
        pub type MST_DLY_EN_R = crate::BitReader;
        ///Field `MST_DLY_EN` writer - RW, SPI master input delay enable
        pub type MST_DLY_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - RW, SPI0 DMA enable
            #[inline(always)]
            pub fn dma_enable(&self) -> DMA_ENABLE_R {
                DMA_ENABLE_R::new((self.bits & 1) != 0)
            }
            ///Bit 2 - RW, SPI0 DMA address loop enable
            #[inline(always)]
            pub fn dma_loop(&self) -> DMA_LOOP_R {
                DMA_LOOP_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 4 - RW, enable buffer/FIFO accessing to auto clear RB_SPI_IF_BYTE_END interrupt flag
            #[inline(always)]
            pub fn auto_if(&self) -> AUTO_IF_R {
                AUTO_IF_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - RW, SPI bit data order: 0=MSB first, 1=LSB first
            #[inline(always)]
            pub fn bit_order(&self) -> BIT_ORDER_R {
                BIT_ORDER_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - RW, SPI master input delay enable
            #[inline(always)]
            pub fn mst_dly_en(&self) -> MST_DLY_EN_R {
                MST_DLY_EN_R::new(((self.bits >> 6) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RW, SPI0 DMA enable
            #[inline(always)]
            #[must_use]
            pub fn dma_enable(&mut self) -> DMA_ENABLE_W<CTRL_CFG_SPEC> {
                DMA_ENABLE_W::new(self, 0)
            }
            ///Bit 2 - RW, SPI0 DMA address loop enable
            #[inline(always)]
            #[must_use]
            pub fn dma_loop(&mut self) -> DMA_LOOP_W<CTRL_CFG_SPEC> {
                DMA_LOOP_W::new(self, 2)
            }
            ///Bit 4 - RW, enable buffer/FIFO accessing to auto clear RB_SPI_IF_BYTE_END interrupt flag
            #[inline(always)]
            #[must_use]
            pub fn auto_if(&mut self) -> AUTO_IF_W<CTRL_CFG_SPEC> {
                AUTO_IF_W::new(self, 4)
            }
            ///Bit 5 - RW, SPI bit data order: 0=MSB first, 1=LSB first
            #[inline(always)]
            #[must_use]
            pub fn bit_order(&mut self) -> BIT_ORDER_W<CTRL_CFG_SPEC> {
                BIT_ORDER_W::new(self, 5)
            }
            ///Bit 6 - RW, SPI master input delay enable
            #[inline(always)]
            #[must_use]
            pub fn mst_dly_en(&mut self) -> MST_DLY_EN_W<CTRL_CFG_SPEC> {
                MST_DLY_EN_W::new(self, 6)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW, SPI1 configuration control
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`ctrl_cfg::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ctrl_cfg::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct CTRL_CFG_SPEC;
        impl crate::RegisterSpec for CTRL_CFG_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`ctrl_cfg::R`](R) reader structure
        impl crate::Readable for CTRL_CFG_SPEC {}
        ///`write(|w| ..)` method takes [`ctrl_cfg::W`](W) writer structure
        impl crate::Writable for CTRL_CFG_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets CTRL_CFG to value 0
        impl crate::Resettable for CTRL_CFG_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///INTER_EN (rw) register accessor: RW, SPI1 interrupt enable
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`inter_en::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`inter_en::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@inter_en`]
    ///module
    pub type INTER_EN = crate::Reg<inter_en::INTER_EN_SPEC>;
    ///RW, SPI1 interrupt enable
    pub mod inter_en {
        ///Register `INTER_EN` reader
        pub type R = crate::R<INTER_EN_SPEC>;
        ///Register `INTER_EN` writer
        pub type W = crate::W<INTER_EN_SPEC>;
        ///Field `IE_CNT_END` reader - RW, enable interrupt for SPI total byte count end
        pub type IE_CNT_END_R = crate::BitReader;
        ///Field `IE_CNT_END` writer - RW, enable interrupt for SPI total byte count end
        pub type IE_CNT_END_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `IE_BYTE_END` reader - RW, enable interrupt for SPI byte exchanged
        pub type IE_BYTE_END_R = crate::BitReader;
        ///Field `IE_BYTE_END` writer - RW, enable interrupt for SPI byte exchanged
        pub type IE_BYTE_END_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `IE_FIFO_HF` reader - RW, enable interrupt for SPI FIFO half
        pub type IE_FIFO_HF_R = crate::BitReader;
        ///Field `IE_FIFO_HF` writer - RW, enable interrupt for SPI FIFO half
        pub type IE_FIFO_HF_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `IE_DMA_END` reader - RW, enable interrupt for SPI0 DMA completion
        pub type IE_DMA_END_R = crate::BitReader;
        ///Field `IE_DMA_END` writer - RW, enable interrupt for SPI0 DMA completion
        pub type IE_DMA_END_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `IE_FIFO_OV` reader - RW, enable interrupt for SPI0 FIFO overflow
        pub type IE_FIFO_OV_R = crate::BitReader;
        ///Field `IE_FIFO_OV` writer - RW, enable interrupt for SPI0 FIFO overflow
        pub type IE_FIFO_OV_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `IE_FST_BYTE` reader - RW, enable interrupt for SPI0 slave mode first byte received
        pub type IE_FST_BYTE_R = crate::BitReader;
        ///Field `IE_FST_BYTE` writer - RW, enable interrupt for SPI0 slave mode first byte received
        pub type IE_FST_BYTE_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - RW, enable interrupt for SPI total byte count end
            #[inline(always)]
            pub fn ie_cnt_end(&self) -> IE_CNT_END_R {
                IE_CNT_END_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RW, enable interrupt for SPI byte exchanged
            #[inline(always)]
            pub fn ie_byte_end(&self) -> IE_BYTE_END_R {
                IE_BYTE_END_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RW, enable interrupt for SPI FIFO half
            #[inline(always)]
            pub fn ie_fifo_hf(&self) -> IE_FIFO_HF_R {
                IE_FIFO_HF_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RW, enable interrupt for SPI0 DMA completion
            #[inline(always)]
            pub fn ie_dma_end(&self) -> IE_DMA_END_R {
                IE_DMA_END_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RW, enable interrupt for SPI0 FIFO overflow
            #[inline(always)]
            pub fn ie_fifo_ov(&self) -> IE_FIFO_OV_R {
                IE_FIFO_OV_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 7 - RW, enable interrupt for SPI0 slave mode first byte received
            #[inline(always)]
            pub fn ie_fst_byte(&self) -> IE_FST_BYTE_R {
                IE_FST_BYTE_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RW, enable interrupt for SPI total byte count end
            #[inline(always)]
            #[must_use]
            pub fn ie_cnt_end(&mut self) -> IE_CNT_END_W<INTER_EN_SPEC> {
                IE_CNT_END_W::new(self, 0)
            }
            ///Bit 1 - RW, enable interrupt for SPI byte exchanged
            #[inline(always)]
            #[must_use]
            pub fn ie_byte_end(&mut self) -> IE_BYTE_END_W<INTER_EN_SPEC> {
                IE_BYTE_END_W::new(self, 1)
            }
            ///Bit 2 - RW, enable interrupt for SPI FIFO half
            #[inline(always)]
            #[must_use]
            pub fn ie_fifo_hf(&mut self) -> IE_FIFO_HF_W<INTER_EN_SPEC> {
                IE_FIFO_HF_W::new(self, 2)
            }
            ///Bit 3 - RW, enable interrupt for SPI0 DMA completion
            #[inline(always)]
            #[must_use]
            pub fn ie_dma_end(&mut self) -> IE_DMA_END_W<INTER_EN_SPEC> {
                IE_DMA_END_W::new(self, 3)
            }
            ///Bit 4 - RW, enable interrupt for SPI0 FIFO overflow
            #[inline(always)]
            #[must_use]
            pub fn ie_fifo_ov(&mut self) -> IE_FIFO_OV_W<INTER_EN_SPEC> {
                IE_FIFO_OV_W::new(self, 4)
            }
            ///Bit 7 - RW, enable interrupt for SPI0 slave mode first byte received
            #[inline(always)]
            #[must_use]
            pub fn ie_fst_byte(&mut self) -> IE_FST_BYTE_W<INTER_EN_SPEC> {
                IE_FST_BYTE_W::new(self, 7)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW, SPI1 interrupt enable
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`inter_en::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`inter_en::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct INTER_EN_SPEC;
        impl crate::RegisterSpec for INTER_EN_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`inter_en::R`](R) reader structure
        impl crate::Readable for INTER_EN_SPEC {}
        ///`write(|w| ..)` method takes [`inter_en::W`](W) writer structure
        impl crate::Writable for INTER_EN_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets INTER_EN to value 0
        impl crate::Resettable for INTER_EN_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///CLOCK_DIV (rw) register accessor: RW, SPI1 master clock divisor;
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`clock_div::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`clock_div::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@clock_div`]
    ///module
    pub type CLOCK_DIV = crate::Reg<clock_div::CLOCK_DIV_SPEC>;
    ///RW, SPI1 master clock divisor;
    pub mod clock_div {
        ///Register `CLOCK_DIV` reader
        pub type R = crate::R<CLOCK_DIV_SPEC>;
        ///Register `CLOCK_DIV` writer
        pub type W = crate::W<CLOCK_DIV_SPEC>;
        ///Field `CLOCK_DIV__R8_SPI0_SLAVE_PRE` reader - RW, SPI0 master clock divisor;RW, SPI0 slave preset value
        pub type CLOCK_DIV__R8_SPI0_SLAVE_PRE_R = crate::FieldReader;
        ///Field `CLOCK_DIV__R8_SPI0_SLAVE_PRE` writer - RW, SPI0 master clock divisor;RW, SPI0 slave preset value
        pub type CLOCK_DIV__R8_SPI0_SLAVE_PRE_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            ///Bits 0:7 - RW, SPI0 master clock divisor;RW, SPI0 slave preset value
            #[inline(always)]
            pub fn clock_div__r8_spi0_slave_pre(&self) -> CLOCK_DIV__R8_SPI0_SLAVE_PRE_R {
                CLOCK_DIV__R8_SPI0_SLAVE_PRE_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:7 - RW, SPI0 master clock divisor;RW, SPI0 slave preset value
            #[inline(always)]
            #[must_use]
            pub fn clock_div__r8_spi0_slave_pre(
                &mut self,
            ) -> CLOCK_DIV__R8_SPI0_SLAVE_PRE_W<CLOCK_DIV_SPEC> {
                CLOCK_DIV__R8_SPI0_SLAVE_PRE_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW, SPI1 master clock divisor;
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`clock_div::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`clock_div::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct CLOCK_DIV_SPEC;
        impl crate::RegisterSpec for CLOCK_DIV_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`clock_div::R`](R) reader structure
        impl crate::Readable for CLOCK_DIV_SPEC {}
        ///`write(|w| ..)` method takes [`clock_div::W`](W) writer structure
        impl crate::Writable for CLOCK_DIV_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets CLOCK_DIV to value 0x10
        impl crate::Resettable for CLOCK_DIV_SPEC {
            const RESET_VALUE: u8 = 0x10;
        }
    }
    ///BUFFER (rw) register accessor: RW, SPI1 data buffer
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`buffer::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`buffer::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@buffer`]
    ///module
    pub type BUFFER = crate::Reg<buffer::BUFFER_SPEC>;
    ///RW, SPI1 data buffer
    pub mod buffer {
        ///Register `BUFFER` reader
        pub type R = crate::R<BUFFER_SPEC>;
        ///Register `BUFFER` writer
        pub type W = crate::W<BUFFER_SPEC>;
        ///Field `BUFFER` reader - RW, SPI1 data buffer
        pub type BUFFER_R = crate::FieldReader;
        ///Field `BUFFER` writer - RW, SPI1 data buffer
        pub type BUFFER_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            ///Bits 0:7 - RW, SPI1 data buffer
            #[inline(always)]
            pub fn buffer(&self) -> BUFFER_R {
                BUFFER_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:7 - RW, SPI1 data buffer
            #[inline(always)]
            #[must_use]
            pub fn buffer(&mut self) -> BUFFER_W<BUFFER_SPEC> {
                BUFFER_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW, SPI1 data buffer
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`buffer::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`buffer::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct BUFFER_SPEC;
        impl crate::RegisterSpec for BUFFER_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`buffer::R`](R) reader structure
        impl crate::Readable for BUFFER_SPEC {}
        ///`write(|w| ..)` method takes [`buffer::W`](W) writer structure
        impl crate::Writable for BUFFER_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets BUFFER to value 0
        impl crate::Resettable for BUFFER_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///RUN_FLAG (r) register accessor: RO, SPI1 work flag
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`run_flag::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@run_flag`]
    ///module
    pub type RUN_FLAG = crate::Reg<run_flag::RUN_FLAG_SPEC>;
    ///RO, SPI1 work flag
    pub mod run_flag {
        ///Register `RUN_FLAG` reader
        pub type R = crate::R<RUN_FLAG_SPEC>;
        ///Field `SLV_CMD_ACT` reader - RO, SPI0 slave first byte or command flag
        pub type SLV_CMD_ACT_R = crate::BitReader;
        ///Field `FIFO_READY` reader - RO, SPI FIFO ready status
        pub type FIFO_READY_R = crate::BitReader;
        ///Field `SLV_CS_LOAD` reader - RO, SPI0 slave chip-select loading status
        pub type SLV_CS_LOAD_R = crate::BitReader;
        ///Field `SLV_SELECT` reader - RO, SPI0 slave selection status
        pub type SLV_SELECT_R = crate::BitReader;
        impl R {
            ///Bit 4 - RO, SPI0 slave first byte or command flag
            #[inline(always)]
            pub fn slv_cmd_act(&self) -> SLV_CMD_ACT_R {
                SLV_CMD_ACT_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - RO, SPI FIFO ready status
            #[inline(always)]
            pub fn fifo_ready(&self) -> FIFO_READY_R {
                FIFO_READY_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - RO, SPI0 slave chip-select loading status
            #[inline(always)]
            pub fn slv_cs_load(&self) -> SLV_CS_LOAD_R {
                SLV_CS_LOAD_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - RO, SPI0 slave selection status
            #[inline(always)]
            pub fn slv_select(&self) -> SLV_SELECT_R {
                SLV_SELECT_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        ///RO, SPI1 work flag
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`run_flag::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct RUN_FLAG_SPEC;
        impl crate::RegisterSpec for RUN_FLAG_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`run_flag::R`](R) reader structure
        impl crate::Readable for RUN_FLAG_SPEC {}
        ///`reset()` method sets RUN_FLAG to value 0
        impl crate::Resettable for RUN_FLAG_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///INT_FLAG (rw) register accessor: RW1, SPI1 interrupt flag
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`int_flag::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`int_flag::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@int_flag`]
    ///module
    pub type INT_FLAG = crate::Reg<int_flag::INT_FLAG_SPEC>;
    ///RW1, SPI1 interrupt flag
    pub mod int_flag {
        ///Register `INT_FLAG` reader
        pub type R = crate::R<INT_FLAG_SPEC>;
        ///Register `INT_FLAG` writer
        pub type W = crate::W<INT_FLAG_SPEC>;
        ///Field `IF_CNT_END` reader - RW1, interrupt flag for SPI total byte count end
        pub type IF_CNT_END_R = crate::BitReader;
        ///Field `IF_CNT_END` writer - RW1, interrupt flag for SPI total byte count end
        pub type IF_CNT_END_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `IF_BYTE_END` reader - RW1, interrupt flag for SPI byte exchanged
        pub type IF_BYTE_END_R = crate::BitReader;
        ///Field `IF_BYTE_END` writer - RW1, interrupt flag for SPI byte exchanged
        pub type IF_BYTE_END_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `IF_FIFO_HF` reader - RW1, interrupt flag for SPI FIFO half
        pub type IF_FIFO_HF_R = crate::BitReader;
        ///Field `IF_FIFO_HF` writer - RW1, interrupt flag for SPI FIFO half
        pub type IF_FIFO_HF_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `IF_DMA_END` reader - RW1, interrupt flag for SPI0 DMA completion
        pub type IF_DMA_END_R = crate::BitReader;
        ///Field `IF_DMA_END` writer - RW1, interrupt flag for SPI0 DMA completion
        pub type IF_DMA_END_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `IF_FIFO_OV` reader - RW1, interrupt flag for SPI0 FIFO overflow
        pub type IF_FIFO_OV_R = crate::BitReader;
        ///Field `IF_FIFO_OV` writer - RW1, interrupt flag for SPI0 FIFO overflow
        pub type IF_FIFO_OV_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `FREE` reader - RO, current SPI free status
        pub type FREE_R = crate::BitReader;
        ///Field `FREE` writer - RO, current SPI free status
        pub type FREE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `IF_FST_BYTE` reader - RW1, interrupt flag for SPI0 slave mode first byte received
        pub type IF_FST_BYTE_R = crate::BitReader;
        ///Field `IF_FST_BYTE` writer - RW1, interrupt flag for SPI0 slave mode first byte received
        pub type IF_FST_BYTE_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - RW1, interrupt flag for SPI total byte count end
            #[inline(always)]
            pub fn if_cnt_end(&self) -> IF_CNT_END_R {
                IF_CNT_END_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RW1, interrupt flag for SPI byte exchanged
            #[inline(always)]
            pub fn if_byte_end(&self) -> IF_BYTE_END_R {
                IF_BYTE_END_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RW1, interrupt flag for SPI FIFO half
            #[inline(always)]
            pub fn if_fifo_hf(&self) -> IF_FIFO_HF_R {
                IF_FIFO_HF_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RW1, interrupt flag for SPI0 DMA completion
            #[inline(always)]
            pub fn if_dma_end(&self) -> IF_DMA_END_R {
                IF_DMA_END_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RW1, interrupt flag for SPI0 FIFO overflow
            #[inline(always)]
            pub fn if_fifo_ov(&self) -> IF_FIFO_OV_R {
                IF_FIFO_OV_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 6 - RO, current SPI free status
            #[inline(always)]
            pub fn free(&self) -> FREE_R {
                FREE_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - RW1, interrupt flag for SPI0 slave mode first byte received
            #[inline(always)]
            pub fn if_fst_byte(&self) -> IF_FST_BYTE_R {
                IF_FST_BYTE_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RW1, interrupt flag for SPI total byte count end
            #[inline(always)]
            #[must_use]
            pub fn if_cnt_end(&mut self) -> IF_CNT_END_W<INT_FLAG_SPEC> {
                IF_CNT_END_W::new(self, 0)
            }
            ///Bit 1 - RW1, interrupt flag for SPI byte exchanged
            #[inline(always)]
            #[must_use]
            pub fn if_byte_end(&mut self) -> IF_BYTE_END_W<INT_FLAG_SPEC> {
                IF_BYTE_END_W::new(self, 1)
            }
            ///Bit 2 - RW1, interrupt flag for SPI FIFO half
            #[inline(always)]
            #[must_use]
            pub fn if_fifo_hf(&mut self) -> IF_FIFO_HF_W<INT_FLAG_SPEC> {
                IF_FIFO_HF_W::new(self, 2)
            }
            ///Bit 3 - RW1, interrupt flag for SPI0 DMA completion
            #[inline(always)]
            #[must_use]
            pub fn if_dma_end(&mut self) -> IF_DMA_END_W<INT_FLAG_SPEC> {
                IF_DMA_END_W::new(self, 3)
            }
            ///Bit 4 - RW1, interrupt flag for SPI0 FIFO overflow
            #[inline(always)]
            #[must_use]
            pub fn if_fifo_ov(&mut self) -> IF_FIFO_OV_W<INT_FLAG_SPEC> {
                IF_FIFO_OV_W::new(self, 4)
            }
            ///Bit 6 - RO, current SPI free status
            #[inline(always)]
            #[must_use]
            pub fn free(&mut self) -> FREE_W<INT_FLAG_SPEC> {
                FREE_W::new(self, 6)
            }
            ///Bit 7 - RW1, interrupt flag for SPI0 slave mode first byte received
            #[inline(always)]
            #[must_use]
            pub fn if_fst_byte(&mut self) -> IF_FST_BYTE_W<INT_FLAG_SPEC> {
                IF_FST_BYTE_W::new(self, 7)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW1, SPI1 interrupt flag
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`int_flag::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`int_flag::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct INT_FLAG_SPEC;
        impl crate::RegisterSpec for INT_FLAG_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`int_flag::R`](R) reader structure
        impl crate::Readable for INT_FLAG_SPEC {}
        ///`write(|w| ..)` method takes [`int_flag::W`](W) writer structure
        impl crate::Writable for INT_FLAG_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets INT_FLAG to value 0x40
        impl crate::Resettable for INT_FLAG_SPEC {
            const RESET_VALUE: u8 = 0x40;
        }
    }
    ///FIFO_COUNT (r) register accessor: RO, SPI1 FIFO count status
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`fifo_count::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@fifo_count`]
    ///module
    pub type FIFO_COUNT = crate::Reg<fifo_count::FIFO_COUNT_SPEC>;
    ///RO, SPI1 FIFO count status
    pub mod fifo_count {
        ///Register `FIFO_COUNT` reader
        pub type R = crate::R<FIFO_COUNT_SPEC>;
        ///Field `FIFO_COUNT` reader - RO, SPI0 FIFO count status
        pub type FIFO_COUNT_R = crate::FieldReader;
        impl R {
            ///Bits 0:7 - RO, SPI0 FIFO count status
            #[inline(always)]
            pub fn fifo_count(&self) -> FIFO_COUNT_R {
                FIFO_COUNT_R::new(self.bits)
            }
        }
        ///RO, SPI1 FIFO count status
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`fifo_count::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct FIFO_COUNT_SPEC;
        impl crate::RegisterSpec for FIFO_COUNT_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`fifo_count::R`](R) reader structure
        impl crate::Readable for FIFO_COUNT_SPEC {}
        ///`reset()` method sets FIFO_COUNT to value 0
        impl crate::Resettable for FIFO_COUNT_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///TOTAL_CNT (rw) register accessor: RW, SPI1 total byte count, only low 12 bit
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`total_cnt::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`total_cnt::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@total_cnt`]
    ///module
    pub type TOTAL_CNT = crate::Reg<total_cnt::TOTAL_CNT_SPEC>;
    ///RW, SPI1 total byte count, only low 12 bit
    pub mod total_cnt {
        ///Register `TOTAL_CNT` reader
        pub type R = crate::R<TOTAL_CNT_SPEC>;
        ///Register `TOTAL_CNT` writer
        pub type W = crate::W<TOTAL_CNT_SPEC>;
        ///Field `TOTAL_CNT` reader - RW, SPI1 total byte count, only low 12 bit
        pub type TOTAL_CNT_R = crate::FieldReader<u16>;
        ///Field `TOTAL_CNT` writer - RW, SPI1 total byte count, only low 12 bit
        pub type TOTAL_CNT_W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            ///Bits 0:15 - RW, SPI1 total byte count, only low 12 bit
            #[inline(always)]
            pub fn total_cnt(&self) -> TOTAL_CNT_R {
                TOTAL_CNT_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - RW, SPI1 total byte count, only low 12 bit
            #[inline(always)]
            #[must_use]
            pub fn total_cnt(&mut self) -> TOTAL_CNT_W<TOTAL_CNT_SPEC> {
                TOTAL_CNT_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW, SPI1 total byte count, only low 12 bit
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`total_cnt::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`total_cnt::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct TOTAL_CNT_SPEC;
        impl crate::RegisterSpec for TOTAL_CNT_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`total_cnt::R`](R) reader structure
        impl crate::Readable for TOTAL_CNT_SPEC {}
        ///`write(|w| ..)` method takes [`total_cnt::W`](W) writer structure
        impl crate::Writable for TOTAL_CNT_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets TOTAL_CNT to value 0
        impl crate::Resettable for TOTAL_CNT_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///FIFO (rw) register accessor: RO/WO, SPI1 FIFO register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`fifo::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`fifo::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@fifo`]
    ///module
    pub type FIFO = crate::Reg<fifo::FIFO_SPEC>;
    ///RO/WO, SPI1 FIFO register
    pub mod fifo {
        ///Register `FIFO` reader
        pub type R = crate::R<FIFO_SPEC>;
        ///Register `FIFO` writer
        pub type W = crate::W<FIFO_SPEC>;
        ///Field `FIFO` reader - RO/WO, SPI1 FIFO register
        pub type FIFO_R = crate::FieldReader;
        ///Field `FIFO` writer - RO/WO, SPI1 FIFO register
        pub type FIFO_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            ///Bits 0:7 - RO/WO, SPI1 FIFO register
            #[inline(always)]
            pub fn fifo(&self) -> FIFO_R {
                FIFO_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:7 - RO/WO, SPI1 FIFO register
            #[inline(always)]
            #[must_use]
            pub fn fifo(&mut self) -> FIFO_W<FIFO_SPEC> {
                FIFO_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RO/WO, SPI1 FIFO register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`fifo::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`fifo::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct FIFO_SPEC;
        impl crate::RegisterSpec for FIFO_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`fifo::R`](R) reader structure
        impl crate::Readable for FIFO_SPEC {}
        ///`write(|w| ..)` method takes [`fifo::W`](W) writer structure
        impl crate::Writable for FIFO_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets FIFO to value 0
        impl crate::Resettable for FIFO_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///FIFO_COUNT1 (r) register accessor: RO, SPI1 FIFO count status
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`fifo_count1::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@fifo_count1`]
    ///module
    pub type FIFO_COUNT1 = crate::Reg<fifo_count1::FIFO_COUNT1_SPEC>;
    ///RO, SPI1 FIFO count status
    pub mod fifo_count1 {
        ///Register `FIFO_COUNT1` reader
        pub type R = crate::R<FIFO_COUNT1_SPEC>;
        ///Field `FIFO_COUNT1` reader - RO, SPI1 FIFO count status
        pub type FIFO_COUNT1_R = crate::FieldReader;
        impl R {
            ///Bits 0:7 - RO, SPI1 FIFO count status
            #[inline(always)]
            pub fn fifo_count1(&self) -> FIFO_COUNT1_R {
                FIFO_COUNT1_R::new(self.bits)
            }
        }
        ///RO, SPI1 FIFO count status
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`fifo_count1::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct FIFO_COUNT1_SPEC;
        impl crate::RegisterSpec for FIFO_COUNT1_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`fifo_count1::R`](R) reader structure
        impl crate::Readable for FIFO_COUNT1_SPEC {}
        ///`reset()` method sets FIFO_COUNT1 to value 0
        impl crate::Resettable for FIFO_COUNT1_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
}
///I2C register
pub struct I2C {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for I2C {}
impl I2C {
    ///Pointer to the register block
    pub const PTR: *const i2c::RegisterBlock = 0x4000_4800 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const i2c::RegisterBlock {
        Self::PTR
    }
    /// Steal an instance of this peripheral
    ///
    /// # Safety
    ///
    /// Ensure that the new instance of the peripheral cannot be used in a way
    /// that may race with any existing instances, for example by only
    /// accessing read-only or write-only registers, or by consuming the
    /// original peripheral and using critical sections to coordinate
    /// access between multiple new instances.
    ///
    /// Additionally, other software such as HALs may rely on only one
    /// peripheral instance existing to ensure memory safety; ensure
    /// no stolen instances are passed to such software.
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for I2C {
    type Target = i2c::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for I2C {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("I2C").finish()
    }
}
///I2C register
pub mod i2c {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        ctrl1: CTRL1,
        _reserved1: [u8; 0x02],
        ctrl2: CTRL2,
        _reserved2: [u8; 0x02],
        oaddr1: OADDR1,
        _reserved3: [u8; 0x02],
        oaddr2: OADDR2,
        _reserved4: [u8; 0x02],
        datar: DATAR,
        _reserved5: [u8; 0x02],
        star1: STAR1,
        _reserved6: [u8; 0x02],
        star2: STAR2,
        _reserved7: [u8; 0x02],
        ckcfgr: CKCFGR,
        _reserved8: [u8; 0x02],
        rtr: RTR,
    }
    impl RegisterBlock {
        ///0x00 - RW, I2C control 1
        #[inline(always)]
        pub const fn ctrl1(&self) -> &CTRL1 {
            &self.ctrl1
        }
        ///0x04 - RW, I2C control 2
        #[inline(always)]
        pub const fn ctrl2(&self) -> &CTRL2 {
            &self.ctrl2
        }
        ///0x08 - RW, I2C own address register 1
        #[inline(always)]
        pub const fn oaddr1(&self) -> &OADDR1 {
            &self.oaddr1
        }
        ///0x0c - RW, I2C own address register 2
        #[inline(always)]
        pub const fn oaddr2(&self) -> &OADDR2 {
            &self.oaddr2
        }
        ///0x10 - RW, I2C data register
        #[inline(always)]
        pub const fn datar(&self) -> &DATAR {
            &self.datar
        }
        ///0x14 - R0, I2C stauts register 1
        #[inline(always)]
        pub const fn star1(&self) -> &STAR1 {
            &self.star1
        }
        ///0x18 - R0, I2C status register 2
        #[inline(always)]
        pub const fn star2(&self) -> &STAR2 {
            &self.star2
        }
        ///0x1c - RW, I2C clock control register
        #[inline(always)]
        pub const fn ckcfgr(&self) -> &CKCFGR {
            &self.ckcfgr
        }
        ///0x20 - RW, I2C trise register
        #[inline(always)]
        pub const fn rtr(&self) -> &RTR {
            &self.rtr
        }
    }
    ///CTRL1 (rw) register accessor: RW, I2C control 1
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`ctrl1::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ctrl1::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@ctrl1`]
    ///module
    pub type CTRL1 = crate::Reg<ctrl1::CTRL1_SPEC>;
    ///RW, I2C control 1
    pub mod ctrl1 {
        ///Register `CTRL1` reader
        pub type R = crate::R<CTRL1_SPEC>;
        ///Register `CTRL1` writer
        pub type W = crate::W<CTRL1_SPEC>;
        ///Field `PE` reader - RW, Peripheral enable
        pub type PE_R = crate::BitReader;
        ///Field `PE` writer - RW, Peripheral enable
        pub type PE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `SMBUS` reader - RW, SMBUS mode: 0=I2C mode, 1=SMBUS mode
        pub type SMBUS_R = crate::BitReader;
        ///Field `SMBUS` writer - RW, SMBUS mode: 0=I2C mode, 1=SMBUS mode
        pub type SMBUS_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `SMBTYPE` reader - RW, SMBus type: 0=Device, 1=Host
        pub type SMBTYPE_R = crate::BitReader;
        ///Field `SMBTYPE` writer - RW, SMBus type: 0=Device, 1=Host
        pub type SMBTYPE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `EBARP` reader - RW, ARP enable
        pub type EBARP_R = crate::BitReader;
        ///Field `EBARP` writer - RW, ARP enable
        pub type EBARP_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `ENPEC` reader - RW, PEC ebable
        pub type ENPEC_R = crate::BitReader;
        ///Field `ENPEC` writer - RW, PEC ebable
        pub type ENPEC_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `ENGC` reader - RW, General call enable
        pub type ENGC_R = crate::BitReader;
        ///Field `ENGC` writer - RW, General call enable
        pub type ENGC_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `NOSTRETCH` reader - RW, Clock stretching disable (Slave mode)
        pub type NOSTRETCH_R = crate::BitReader;
        ///Field `NOSTRETCH` writer - RW, Clock stretching disable (Slave mode)
        pub type NOSTRETCH_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `START` reader - RW, Start generation: master mode: 0=no start, 1=repeated start; slave mode: 0=no start, 1=start at bus free
        pub type START_R = crate::BitReader;
        ///Field `START` writer - RW, Start generation: master mode: 0=no start, 1=repeated start; slave mode: 0=no start, 1=start at bus free
        pub type START_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `STOP` reader - RW, Stop generation: master mode: 0=no stop, 1=stop after the current byte transfer or after the current Start condition is sent; slave mode: 0=no stop, 1=Release the SCL and SDA lines after the current byte transfer
        pub type STOP_R = crate::BitReader;
        ///Field `STOP` writer - RW, Stop generation: master mode: 0=no stop, 1=stop after the current byte transfer or after the current Start condition is sent; slave mode: 0=no stop, 1=Release the SCL and SDA lines after the current byte transfer
        pub type STOP_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `ACK` reader - RW, Acknowledge enable
        pub type ACK_R = crate::BitReader;
        ///Field `ACK` writer - RW, Acknowledge enable
        pub type ACK_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `POS` reader - RW, Acknowledge/PEC Position (for data reception)
        pub type POS_R = crate::BitReader;
        ///Field `POS` writer - RW, Acknowledge/PEC Position (for data reception)
        pub type POS_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PEC` reader - RW, Packet error checking: 0=No PEC transfer, 1=PEC transfer (in Tx or Rx mode)
        pub type PEC_R = crate::BitReader;
        ///Field `PEC` writer - RW, Packet error checking: 0=No PEC transfer, 1=PEC transfer (in Tx or Rx mode)
        pub type PEC_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `ALERT` reader - RW, SMBus alert: 0=Releases SMBA pin high, 1=Drives SMBA pin low.
        pub type ALERT_R = crate::BitReader;
        ///Field `ALERT` writer - RW, SMBus alert: 0=Releases SMBA pin high, 1=Drives SMBA pin low.
        pub type ALERT_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `SWRST` reader - RW, Software reset
        pub type SWRST_R = crate::BitReader;
        ///Field `SWRST` writer - RW, Software reset
        pub type SWRST_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - RW, Peripheral enable
            #[inline(always)]
            pub fn pe(&self) -> PE_R {
                PE_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RW, SMBUS mode: 0=I2C mode, 1=SMBUS mode
            #[inline(always)]
            pub fn smbus(&self) -> SMBUS_R {
                SMBUS_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 3 - RW, SMBus type: 0=Device, 1=Host
            #[inline(always)]
            pub fn smbtype(&self) -> SMBTYPE_R {
                SMBTYPE_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RW, ARP enable
            #[inline(always)]
            pub fn ebarp(&self) -> EBARP_R {
                EBARP_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - RW, PEC ebable
            #[inline(always)]
            pub fn enpec(&self) -> ENPEC_R {
                ENPEC_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - RW, General call enable
            #[inline(always)]
            pub fn engc(&self) -> ENGC_R {
                ENGC_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - RW, Clock stretching disable (Slave mode)
            #[inline(always)]
            pub fn nostretch(&self) -> NOSTRETCH_R {
                NOSTRETCH_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bit 8 - RW, Start generation: master mode: 0=no start, 1=repeated start; slave mode: 0=no start, 1=start at bus free
            #[inline(always)]
            pub fn start(&self) -> START_R {
                START_R::new(((self.bits >> 8) & 1) != 0)
            }
            ///Bit 9 - RW, Stop generation: master mode: 0=no stop, 1=stop after the current byte transfer or after the current Start condition is sent; slave mode: 0=no stop, 1=Release the SCL and SDA lines after the current byte transfer
            #[inline(always)]
            pub fn stop(&self) -> STOP_R {
                STOP_R::new(((self.bits >> 9) & 1) != 0)
            }
            ///Bit 10 - RW, Acknowledge enable
            #[inline(always)]
            pub fn ack(&self) -> ACK_R {
                ACK_R::new(((self.bits >> 10) & 1) != 0)
            }
            ///Bit 11 - RW, Acknowledge/PEC Position (for data reception)
            #[inline(always)]
            pub fn pos(&self) -> POS_R {
                POS_R::new(((self.bits >> 11) & 1) != 0)
            }
            ///Bit 12 - RW, Packet error checking: 0=No PEC transfer, 1=PEC transfer (in Tx or Rx mode)
            #[inline(always)]
            pub fn pec(&self) -> PEC_R {
                PEC_R::new(((self.bits >> 12) & 1) != 0)
            }
            ///Bit 13 - RW, SMBus alert: 0=Releases SMBA pin high, 1=Drives SMBA pin low.
            #[inline(always)]
            pub fn alert(&self) -> ALERT_R {
                ALERT_R::new(((self.bits >> 13) & 1) != 0)
            }
            ///Bit 15 - RW, Software reset
            #[inline(always)]
            pub fn swrst(&self) -> SWRST_R {
                SWRST_R::new(((self.bits >> 15) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RW, Peripheral enable
            #[inline(always)]
            #[must_use]
            pub fn pe(&mut self) -> PE_W<CTRL1_SPEC> {
                PE_W::new(self, 0)
            }
            ///Bit 1 - RW, SMBUS mode: 0=I2C mode, 1=SMBUS mode
            #[inline(always)]
            #[must_use]
            pub fn smbus(&mut self) -> SMBUS_W<CTRL1_SPEC> {
                SMBUS_W::new(self, 1)
            }
            ///Bit 3 - RW, SMBus type: 0=Device, 1=Host
            #[inline(always)]
            #[must_use]
            pub fn smbtype(&mut self) -> SMBTYPE_W<CTRL1_SPEC> {
                SMBTYPE_W::new(self, 3)
            }
            ///Bit 4 - RW, ARP enable
            #[inline(always)]
            #[must_use]
            pub fn ebarp(&mut self) -> EBARP_W<CTRL1_SPEC> {
                EBARP_W::new(self, 4)
            }
            ///Bit 5 - RW, PEC ebable
            #[inline(always)]
            #[must_use]
            pub fn enpec(&mut self) -> ENPEC_W<CTRL1_SPEC> {
                ENPEC_W::new(self, 5)
            }
            ///Bit 6 - RW, General call enable
            #[inline(always)]
            #[must_use]
            pub fn engc(&mut self) -> ENGC_W<CTRL1_SPEC> {
                ENGC_W::new(self, 6)
            }
            ///Bit 7 - RW, Clock stretching disable (Slave mode)
            #[inline(always)]
            #[must_use]
            pub fn nostretch(&mut self) -> NOSTRETCH_W<CTRL1_SPEC> {
                NOSTRETCH_W::new(self, 7)
            }
            ///Bit 8 - RW, Start generation: master mode: 0=no start, 1=repeated start; slave mode: 0=no start, 1=start at bus free
            #[inline(always)]
            #[must_use]
            pub fn start(&mut self) -> START_W<CTRL1_SPEC> {
                START_W::new(self, 8)
            }
            ///Bit 9 - RW, Stop generation: master mode: 0=no stop, 1=stop after the current byte transfer or after the current Start condition is sent; slave mode: 0=no stop, 1=Release the SCL and SDA lines after the current byte transfer
            #[inline(always)]
            #[must_use]
            pub fn stop(&mut self) -> STOP_W<CTRL1_SPEC> {
                STOP_W::new(self, 9)
            }
            ///Bit 10 - RW, Acknowledge enable
            #[inline(always)]
            #[must_use]
            pub fn ack(&mut self) -> ACK_W<CTRL1_SPEC> {
                ACK_W::new(self, 10)
            }
            ///Bit 11 - RW, Acknowledge/PEC Position (for data reception)
            #[inline(always)]
            #[must_use]
            pub fn pos(&mut self) -> POS_W<CTRL1_SPEC> {
                POS_W::new(self, 11)
            }
            ///Bit 12 - RW, Packet error checking: 0=No PEC transfer, 1=PEC transfer (in Tx or Rx mode)
            #[inline(always)]
            #[must_use]
            pub fn pec(&mut self) -> PEC_W<CTRL1_SPEC> {
                PEC_W::new(self, 12)
            }
            ///Bit 13 - RW, SMBus alert: 0=Releases SMBA pin high, 1=Drives SMBA pin low.
            #[inline(always)]
            #[must_use]
            pub fn alert(&mut self) -> ALERT_W<CTRL1_SPEC> {
                ALERT_W::new(self, 13)
            }
            ///Bit 15 - RW, Software reset
            #[inline(always)]
            #[must_use]
            pub fn swrst(&mut self) -> SWRST_W<CTRL1_SPEC> {
                SWRST_W::new(self, 15)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW, I2C control 1
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`ctrl1::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ctrl1::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct CTRL1_SPEC;
        impl crate::RegisterSpec for CTRL1_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`ctrl1::R`](R) reader structure
        impl crate::Readable for CTRL1_SPEC {}
        ///`write(|w| ..)` method takes [`ctrl1::W`](W) writer structure
        impl crate::Writable for CTRL1_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets CTRL1 to value 0
        impl crate::Resettable for CTRL1_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///CTRL2 (rw) register accessor: RW, I2C control 2
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`ctrl2::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ctrl2::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@ctrl2`]
    ///module
    pub type CTRL2 = crate::Reg<ctrl2::CTRL2_SPEC>;
    ///RW, I2C control 2
    pub mod ctrl2 {
        ///Register `CTRL2` reader
        pub type R = crate::R<CTRL2_SPEC>;
        ///Register `CTRL2` writer
        pub type W = crate::W<CTRL2_SPEC>;
        ///Field `FREQ` reader - RW, Peripheral clock frequency, The minimum allowed frequency is 2 MHz,the maximum frequency is 36 MHz
        pub type FREQ_R = crate::FieldReader;
        ///Field `FREQ` writer - RW, Peripheral clock frequency, The minimum allowed frequency is 2 MHz,the maximum frequency is 36 MHz
        pub type FREQ_W<'a, REG> = crate::FieldWriter<'a, REG, 6>;
        ///Field `ITERREN` reader - RW, Error interrupt enable
        pub type ITERREN_R = crate::BitReader;
        ///Field `ITERREN` writer - RW, Error interrupt enable
        pub type ITERREN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `ITEVTEN` reader - RW, Event interrupt enable
        pub type ITEVTEN_R = crate::BitReader;
        ///Field `ITEVTEN` writer - RW, Event interrupt enable
        pub type ITEVTEN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `ITBUFEN` reader - RW, Buffer interrupt enable
        pub type ITBUFEN_R = crate::BitReader;
        ///Field `ITBUFEN` writer - RW, Buffer interrupt enable
        pub type ITBUFEN_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bits 0:5 - RW, Peripheral clock frequency, The minimum allowed frequency is 2 MHz,the maximum frequency is 36 MHz
            #[inline(always)]
            pub fn freq(&self) -> FREQ_R {
                FREQ_R::new((self.bits & 0x3f) as u8)
            }
            ///Bit 8 - RW, Error interrupt enable
            #[inline(always)]
            pub fn iterren(&self) -> ITERREN_R {
                ITERREN_R::new(((self.bits >> 8) & 1) != 0)
            }
            ///Bit 9 - RW, Event interrupt enable
            #[inline(always)]
            pub fn itevten(&self) -> ITEVTEN_R {
                ITEVTEN_R::new(((self.bits >> 9) & 1) != 0)
            }
            ///Bit 10 - RW, Buffer interrupt enable
            #[inline(always)]
            pub fn itbufen(&self) -> ITBUFEN_R {
                ITBUFEN_R::new(((self.bits >> 10) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:5 - RW, Peripheral clock frequency, The minimum allowed frequency is 2 MHz,the maximum frequency is 36 MHz
            #[inline(always)]
            #[must_use]
            pub fn freq(&mut self) -> FREQ_W<CTRL2_SPEC> {
                FREQ_W::new(self, 0)
            }
            ///Bit 8 - RW, Error interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn iterren(&mut self) -> ITERREN_W<CTRL2_SPEC> {
                ITERREN_W::new(self, 8)
            }
            ///Bit 9 - RW, Event interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn itevten(&mut self) -> ITEVTEN_W<CTRL2_SPEC> {
                ITEVTEN_W::new(self, 9)
            }
            ///Bit 10 - RW, Buffer interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn itbufen(&mut self) -> ITBUFEN_W<CTRL2_SPEC> {
                ITBUFEN_W::new(self, 10)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW, I2C control 2
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`ctrl2::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ctrl2::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct CTRL2_SPEC;
        impl crate::RegisterSpec for CTRL2_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`ctrl2::R`](R) reader structure
        impl crate::Readable for CTRL2_SPEC {}
        ///`write(|w| ..)` method takes [`ctrl2::W`](W) writer structure
        impl crate::Writable for CTRL2_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets CTRL2 to value 0
        impl crate::Resettable for CTRL2_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///OADDR1 (rw) register accessor: RW, I2C own address register 1
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`oaddr1::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`oaddr1::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@oaddr1`]
    ///module
    pub type OADDR1 = crate::Reg<oaddr1::OADDR1_SPEC>;
    ///RW, I2C own address register 1
    pub mod oaddr1 {
        ///Register `OADDR1` reader
        pub type R = crate::R<OADDR1_SPEC>;
        ///Register `OADDR1` writer
        pub type W = crate::W<OADDR1_SPEC>;
        ///Field `ADD0` reader - RW, bit0 of address in 10-bit addressing mode
        pub type ADD0_R = crate::BitReader;
        ///Field `ADD0` writer - RW, bit0 of address in 10-bit addressing mode
        pub type ADD0_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `ADD7_1` reader - RW, bit\[7:1\]
        ///of address
        pub type ADD7_1_R = crate::FieldReader;
        ///Field `ADD7_1` writer - RW, bit\[7:1\]
        ///of address
        pub type ADD7_1_W<'a, REG> = crate::FieldWriter<'a, REG, 7>;
        ///Field `ADD9_8` reader - RW, bit\[9:8\]
        ///of address in 10-bit addressing mode
        pub type ADD9_8_R = crate::FieldReader;
        ///Field `ADD9_8` writer - RW, bit\[9:8\]
        ///of address in 10-bit addressing mode
        pub type ADD9_8_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `MUST1` reader - RW, Should always be kept at 1
        pub type MUST1_R = crate::BitReader;
        ///Field `MUST1` writer - RW, Should always be kept at 1
        pub type MUST1_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `ADDMODE` reader - RW, Addressing mode (slave mode): 0=7-bit slave address, 1=10-bit slave address
        pub type ADDMODE_R = crate::BitReader;
        ///Field `ADDMODE` writer - RW, Addressing mode (slave mode): 0=7-bit slave address, 1=10-bit slave address
        pub type ADDMODE_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - RW, bit0 of address in 10-bit addressing mode
            #[inline(always)]
            pub fn add0(&self) -> ADD0_R {
                ADD0_R::new((self.bits & 1) != 0)
            }
            ///Bits 1:7 - RW, bit\[7:1\]
            ///of address
            #[inline(always)]
            pub fn add7_1(&self) -> ADD7_1_R {
                ADD7_1_R::new(((self.bits >> 1) & 0x7f) as u8)
            }
            ///Bits 8:9 - RW, bit\[9:8\]
            ///of address in 10-bit addressing mode
            #[inline(always)]
            pub fn add9_8(&self) -> ADD9_8_R {
                ADD9_8_R::new(((self.bits >> 8) & 3) as u8)
            }
            ///Bit 14 - RW, Should always be kept at 1
            #[inline(always)]
            pub fn must1(&self) -> MUST1_R {
                MUST1_R::new(((self.bits >> 14) & 1) != 0)
            }
            ///Bit 15 - RW, Addressing mode (slave mode): 0=7-bit slave address, 1=10-bit slave address
            #[inline(always)]
            pub fn addmode(&self) -> ADDMODE_R {
                ADDMODE_R::new(((self.bits >> 15) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RW, bit0 of address in 10-bit addressing mode
            #[inline(always)]
            #[must_use]
            pub fn add0(&mut self) -> ADD0_W<OADDR1_SPEC> {
                ADD0_W::new(self, 0)
            }
            ///Bits 1:7 - RW, bit\[7:1\]
            ///of address
            #[inline(always)]
            #[must_use]
            pub fn add7_1(&mut self) -> ADD7_1_W<OADDR1_SPEC> {
                ADD7_1_W::new(self, 1)
            }
            ///Bits 8:9 - RW, bit\[9:8\]
            ///of address in 10-bit addressing mode
            #[inline(always)]
            #[must_use]
            pub fn add9_8(&mut self) -> ADD9_8_W<OADDR1_SPEC> {
                ADD9_8_W::new(self, 8)
            }
            ///Bit 14 - RW, Should always be kept at 1
            #[inline(always)]
            #[must_use]
            pub fn must1(&mut self) -> MUST1_W<OADDR1_SPEC> {
                MUST1_W::new(self, 14)
            }
            ///Bit 15 - RW, Addressing mode (slave mode): 0=7-bit slave address, 1=10-bit slave address
            #[inline(always)]
            #[must_use]
            pub fn addmode(&mut self) -> ADDMODE_W<OADDR1_SPEC> {
                ADDMODE_W::new(self, 15)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW, I2C own address register 1
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`oaddr1::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`oaddr1::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct OADDR1_SPEC;
        impl crate::RegisterSpec for OADDR1_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`oaddr1::R`](R) reader structure
        impl crate::Readable for OADDR1_SPEC {}
        ///`write(|w| ..)` method takes [`oaddr1::W`](W) writer structure
        impl crate::Writable for OADDR1_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets OADDR1 to value 0
        impl crate::Resettable for OADDR1_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///OADDR2 (rw) register accessor: RW, I2C own address register 2
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`oaddr2::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`oaddr2::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@oaddr2`]
    ///module
    pub type OADDR2 = crate::Reg<oaddr2::OADDR2_SPEC>;
    ///RW, I2C own address register 2
    pub mod oaddr2 {
        ///Register `OADDR2` reader
        pub type R = crate::R<OADDR2_SPEC>;
        ///Register `OADDR2` writer
        pub type W = crate::W<OADDR2_SPEC>;
        ///Field `ENDUAL` reader - RW, Dual addressing mode enable
        pub type ENDUAL_R = crate::BitReader;
        ///Field `ENDUAL` writer - RW, Dual addressing mode enable
        pub type ENDUAL_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `ADD2` reader - RW, bit\[7:1\]
        ///of address2
        pub type ADD2_R = crate::FieldReader;
        ///Field `ADD2` writer - RW, bit\[7:1\]
        ///of address2
        pub type ADD2_W<'a, REG> = crate::FieldWriter<'a, REG, 7>;
        impl R {
            ///Bit 0 - RW, Dual addressing mode enable
            #[inline(always)]
            pub fn endual(&self) -> ENDUAL_R {
                ENDUAL_R::new((self.bits & 1) != 0)
            }
            ///Bits 1:7 - RW, bit\[7:1\]
            ///of address2
            #[inline(always)]
            pub fn add2(&self) -> ADD2_R {
                ADD2_R::new(((self.bits >> 1) & 0x7f) as u8)
            }
        }
        impl W {
            ///Bit 0 - RW, Dual addressing mode enable
            #[inline(always)]
            #[must_use]
            pub fn endual(&mut self) -> ENDUAL_W<OADDR2_SPEC> {
                ENDUAL_W::new(self, 0)
            }
            ///Bits 1:7 - RW, bit\[7:1\]
            ///of address2
            #[inline(always)]
            #[must_use]
            pub fn add2(&mut self) -> ADD2_W<OADDR2_SPEC> {
                ADD2_W::new(self, 1)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW, I2C own address register 2
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`oaddr2::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`oaddr2::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct OADDR2_SPEC;
        impl crate::RegisterSpec for OADDR2_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`oaddr2::R`](R) reader structure
        impl crate::Readable for OADDR2_SPEC {}
        ///`write(|w| ..)` method takes [`oaddr2::W`](W) writer structure
        impl crate::Writable for OADDR2_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets OADDR2 to value 0
        impl crate::Resettable for OADDR2_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///DATAR (rw) register accessor: RW, I2C data register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`datar::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`datar::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@datar`]
    ///module
    pub type DATAR = crate::Reg<datar::DATAR_SPEC>;
    ///RW, I2C data register
    pub mod datar {
        ///Register `DATAR` reader
        pub type R = crate::R<DATAR_SPEC>;
        ///Register `DATAR` writer
        pub type W = crate::W<DATAR_SPEC>;
        ///Field `DATAR` reader - RW, I2C data register
        pub type DATAR_R = crate::FieldReader;
        ///Field `DATAR` writer - RW, I2C data register
        pub type DATAR_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            ///Bits 0:7 - RW, I2C data register
            #[inline(always)]
            pub fn datar(&self) -> DATAR_R {
                DATAR_R::new((self.bits & 0xff) as u8)
            }
        }
        impl W {
            ///Bits 0:7 - RW, I2C data register
            #[inline(always)]
            #[must_use]
            pub fn datar(&mut self) -> DATAR_W<DATAR_SPEC> {
                DATAR_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW, I2C data register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`datar::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`datar::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct DATAR_SPEC;
        impl crate::RegisterSpec for DATAR_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`datar::R`](R) reader structure
        impl crate::Readable for DATAR_SPEC {}
        ///`write(|w| ..)` method takes [`datar::W`](W) writer structure
        impl crate::Writable for DATAR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets DATAR to value 0
        impl crate::Resettable for DATAR_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///STAR1 (rw) register accessor: R0, I2C stauts register 1
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`star1::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`star1::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@star1`]
    ///module
    pub type STAR1 = crate::Reg<star1::STAR1_SPEC>;
    ///R0, I2C stauts register 1
    pub mod star1 {
        ///Register `STAR1` reader
        pub type R = crate::R<STAR1_SPEC>;
        ///Register `STAR1` writer
        pub type W = crate::W<STAR1_SPEC>;
        ///Field `SB` reader - RW0, Start bit flag (Master mode)
        pub type SB_R = crate::BitReader;
        ///Field `SB` writer - RW0, Start bit flag (Master mode)
        pub type SB_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `ADDR` reader - RW0, Address sent (master mode)/matched (slave mode) flag
        pub type ADDR_R = crate::BitReader;
        ///Field `ADDR` writer - RW0, Address sent (master mode)/matched (slave mode) flag
        pub type ADDR_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `BTF` reader - RO, Byte transfer finished flag
        pub type BTF_R = crate::BitReader;
        ///Field `BTF` writer - RO, Byte transfer finished flag
        pub type BTF_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `ADD10` reader - RO, 10-bit header sent flag (Master mode)
        pub type ADD10_R = crate::BitReader;
        ///Field `ADD10` writer - RO, 10-bit header sent flag (Master mode)
        pub type ADD10_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `STOPF` reader - RO, Stop detection flag (slave mode)
        pub type STOPF_R = crate::BitReader;
        ///Field `STOPF` writer - RO, Stop detection flag (slave mode)
        pub type STOPF_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `RxNE` reader - RO, Data register not empty flag (receivers)
        pub type RX_NE_R = crate::BitReader;
        ///Field `RxNE` writer - RO, Data register not empty flag (receivers)
        pub type RX_NE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TxE` reader - RO, Data register empty flag (transmitters)
        pub type TX_E_R = crate::BitReader;
        ///Field `TxE` writer - RO, Data register empty flag (transmitters)
        pub type TX_E_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `BERR` reader - RW0, Bus error flag
        pub type BERR_R = crate::BitReader;
        ///Field `BERR` writer - RW0, Bus error flag
        pub type BERR_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `ARLO` reader - RW0, Arbitration lost flag (master mode)
        pub type ARLO_R = crate::BitReader;
        ///Field `ARLO` writer - RW0, Arbitration lost flag (master mode)
        pub type ARLO_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `AF` reader - RW0, Acknowledge failure flag
        pub type AF_R = crate::BitReader;
        ///Field `AF` writer - RW0, Acknowledge failure flag
        pub type AF_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `OVR` reader - RW0, Overrun/Underrun flag
        pub type OVR_R = crate::BitReader;
        ///Field `OVR` writer - RW0, Overrun/Underrun flag
        pub type OVR_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PECERR` reader - RW0, PEC Error flag in reception
        pub type PECERR_R = crate::BitReader;
        ///Field `PECERR` writer - RW0, PEC Error flag in reception
        pub type PECERR_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TIMEOUT` reader - RW0, Timeout or Tlow error flag
        pub type TIMEOUT_R = crate::BitReader;
        ///Field `TIMEOUT` writer - RW0, Timeout or Tlow error flag
        pub type TIMEOUT_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `SMBALERT` reader - RW0, SMBus alert flag
        pub type SMBALERT_R = crate::BitReader;
        ///Field `SMBALERT` writer - RW0, SMBus alert flag
        pub type SMBALERT_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - RW0, Start bit flag (Master mode)
            #[inline(always)]
            pub fn sb(&self) -> SB_R {
                SB_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RW0, Address sent (master mode)/matched (slave mode) flag
            #[inline(always)]
            pub fn addr(&self) -> ADDR_R {
                ADDR_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RO, Byte transfer finished flag
            #[inline(always)]
            pub fn btf(&self) -> BTF_R {
                BTF_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RO, 10-bit header sent flag (Master mode)
            #[inline(always)]
            pub fn add10(&self) -> ADD10_R {
                ADD10_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RO, Stop detection flag (slave mode)
            #[inline(always)]
            pub fn stopf(&self) -> STOPF_R {
                STOPF_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 6 - RO, Data register not empty flag (receivers)
            #[inline(always)]
            pub fn rx_ne(&self) -> RX_NE_R {
                RX_NE_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - RO, Data register empty flag (transmitters)
            #[inline(always)]
            pub fn tx_e(&self) -> TX_E_R {
                TX_E_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bit 8 - RW0, Bus error flag
            #[inline(always)]
            pub fn berr(&self) -> BERR_R {
                BERR_R::new(((self.bits >> 8) & 1) != 0)
            }
            ///Bit 9 - RW0, Arbitration lost flag (master mode)
            #[inline(always)]
            pub fn arlo(&self) -> ARLO_R {
                ARLO_R::new(((self.bits >> 9) & 1) != 0)
            }
            ///Bit 10 - RW0, Acknowledge failure flag
            #[inline(always)]
            pub fn af(&self) -> AF_R {
                AF_R::new(((self.bits >> 10) & 1) != 0)
            }
            ///Bit 11 - RW0, Overrun/Underrun flag
            #[inline(always)]
            pub fn ovr(&self) -> OVR_R {
                OVR_R::new(((self.bits >> 11) & 1) != 0)
            }
            ///Bit 12 - RW0, PEC Error flag in reception
            #[inline(always)]
            pub fn pecerr(&self) -> PECERR_R {
                PECERR_R::new(((self.bits >> 12) & 1) != 0)
            }
            ///Bit 13 - RW0, Timeout or Tlow error flag
            #[inline(always)]
            pub fn timeout(&self) -> TIMEOUT_R {
                TIMEOUT_R::new(((self.bits >> 13) & 1) != 0)
            }
            ///Bit 15 - RW0, SMBus alert flag
            #[inline(always)]
            pub fn smbalert(&self) -> SMBALERT_R {
                SMBALERT_R::new(((self.bits >> 15) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RW0, Start bit flag (Master mode)
            #[inline(always)]
            #[must_use]
            pub fn sb(&mut self) -> SB_W<STAR1_SPEC> {
                SB_W::new(self, 0)
            }
            ///Bit 1 - RW0, Address sent (master mode)/matched (slave mode) flag
            #[inline(always)]
            #[must_use]
            pub fn addr(&mut self) -> ADDR_W<STAR1_SPEC> {
                ADDR_W::new(self, 1)
            }
            ///Bit 2 - RO, Byte transfer finished flag
            #[inline(always)]
            #[must_use]
            pub fn btf(&mut self) -> BTF_W<STAR1_SPEC> {
                BTF_W::new(self, 2)
            }
            ///Bit 3 - RO, 10-bit header sent flag (Master mode)
            #[inline(always)]
            #[must_use]
            pub fn add10(&mut self) -> ADD10_W<STAR1_SPEC> {
                ADD10_W::new(self, 3)
            }
            ///Bit 4 - RO, Stop detection flag (slave mode)
            #[inline(always)]
            #[must_use]
            pub fn stopf(&mut self) -> STOPF_W<STAR1_SPEC> {
                STOPF_W::new(self, 4)
            }
            ///Bit 6 - RO, Data register not empty flag (receivers)
            #[inline(always)]
            #[must_use]
            pub fn rx_ne(&mut self) -> RX_NE_W<STAR1_SPEC> {
                RX_NE_W::new(self, 6)
            }
            ///Bit 7 - RO, Data register empty flag (transmitters)
            #[inline(always)]
            #[must_use]
            pub fn tx_e(&mut self) -> TX_E_W<STAR1_SPEC> {
                TX_E_W::new(self, 7)
            }
            ///Bit 8 - RW0, Bus error flag
            #[inline(always)]
            #[must_use]
            pub fn berr(&mut self) -> BERR_W<STAR1_SPEC> {
                BERR_W::new(self, 8)
            }
            ///Bit 9 - RW0, Arbitration lost flag (master mode)
            #[inline(always)]
            #[must_use]
            pub fn arlo(&mut self) -> ARLO_W<STAR1_SPEC> {
                ARLO_W::new(self, 9)
            }
            ///Bit 10 - RW0, Acknowledge failure flag
            #[inline(always)]
            #[must_use]
            pub fn af(&mut self) -> AF_W<STAR1_SPEC> {
                AF_W::new(self, 10)
            }
            ///Bit 11 - RW0, Overrun/Underrun flag
            #[inline(always)]
            #[must_use]
            pub fn ovr(&mut self) -> OVR_W<STAR1_SPEC> {
                OVR_W::new(self, 11)
            }
            ///Bit 12 - RW0, PEC Error flag in reception
            #[inline(always)]
            #[must_use]
            pub fn pecerr(&mut self) -> PECERR_W<STAR1_SPEC> {
                PECERR_W::new(self, 12)
            }
            ///Bit 13 - RW0, Timeout or Tlow error flag
            #[inline(always)]
            #[must_use]
            pub fn timeout(&mut self) -> TIMEOUT_W<STAR1_SPEC> {
                TIMEOUT_W::new(self, 13)
            }
            ///Bit 15 - RW0, SMBus alert flag
            #[inline(always)]
            #[must_use]
            pub fn smbalert(&mut self) -> SMBALERT_W<STAR1_SPEC> {
                SMBALERT_W::new(self, 15)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///R0, I2C stauts register 1
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`star1::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`star1::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct STAR1_SPEC;
        impl crate::RegisterSpec for STAR1_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`star1::R`](R) reader structure
        impl crate::Readable for STAR1_SPEC {}
        ///`write(|w| ..)` method takes [`star1::W`](W) writer structure
        impl crate::Writable for STAR1_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets STAR1 to value 0
        impl crate::Resettable for STAR1_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///STAR2 (r) register accessor: R0, I2C status register 2
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`star2::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@star2`]
    ///module
    pub type STAR2 = crate::Reg<star2::STAR2_SPEC>;
    ///R0, I2C status register 2
    pub mod star2 {
        ///Register `STAR2` reader
        pub type R = crate::R<STAR2_SPEC>;
        ///Field `MSL` reader - RO, Mode statu: 0=Slave mode, 1=Master mode
        pub type MSL_R = crate::BitReader;
        ///Field `BUSY` reader - RO, Bus busy flag
        pub type BUSY_R = crate::BitReader;
        ///Field `TRA` reader - RO, Trans flag: 0=data bytes received, 1=data bytes transmitted
        pub type TRA_R = crate::BitReader;
        ///Field `GENCALL` reader - RO, General call address (Slave mode) received flag
        pub type GENCALL_R = crate::BitReader;
        ///Field `SMBDEFAULT` reader - RO, SMBus device default address (Slave mode) received flag
        pub type SMBDEFAULT_R = crate::BitReader;
        ///Field `SMBHOST` reader - RO, SMBus host header (Slave mode) received flag
        pub type SMBHOST_R = crate::BitReader;
        ///Field `DUALF` reader - RO, Dual flag (Slave mode): 0=Received address matched with OAR1, 1=Received address matched with OAR2
        pub type DUALF_R = crate::BitReader;
        ///Field `PECX` reader - RO, Packet error checking register
        pub type PECX_R = crate::FieldReader;
        impl R {
            ///Bit 0 - RO, Mode statu: 0=Slave mode, 1=Master mode
            #[inline(always)]
            pub fn msl(&self) -> MSL_R {
                MSL_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RO, Bus busy flag
            #[inline(always)]
            pub fn busy(&self) -> BUSY_R {
                BUSY_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RO, Trans flag: 0=data bytes received, 1=data bytes transmitted
            #[inline(always)]
            pub fn tra(&self) -> TRA_R {
                TRA_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 4 - RO, General call address (Slave mode) received flag
            #[inline(always)]
            pub fn gencall(&self) -> GENCALL_R {
                GENCALL_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - RO, SMBus device default address (Slave mode) received flag
            #[inline(always)]
            pub fn smbdefault(&self) -> SMBDEFAULT_R {
                SMBDEFAULT_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - RO, SMBus host header (Slave mode) received flag
            #[inline(always)]
            pub fn smbhost(&self) -> SMBHOST_R {
                SMBHOST_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - RO, Dual flag (Slave mode): 0=Received address matched with OAR1, 1=Received address matched with OAR2
            #[inline(always)]
            pub fn dualf(&self) -> DUALF_R {
                DUALF_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bits 8:15 - RO, Packet error checking register
            #[inline(always)]
            pub fn pecx(&self) -> PECX_R {
                PECX_R::new(((self.bits >> 8) & 0xff) as u8)
            }
        }
        ///R0, I2C status register 2
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`star2::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct STAR2_SPEC;
        impl crate::RegisterSpec for STAR2_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`star2::R`](R) reader structure
        impl crate::Readable for STAR2_SPEC {}
        ///`reset()` method sets STAR2 to value 0
        impl crate::Resettable for STAR2_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///CKCFGR (rw) register accessor: RW, I2C clock control register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`ckcfgr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ckcfgr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@ckcfgr`]
    ///module
    pub type CKCFGR = crate::Reg<ckcfgr::CKCFGR_SPEC>;
    ///RW, I2C clock control register
    pub mod ckcfgr {
        ///Register `CKCFGR` reader
        pub type R = crate::R<CKCFGR_SPEC>;
        ///Register `CKCFGR` writer
        pub type W = crate::W<CKCFGR_SPEC>;
        ///Field `CCR` reader - RW, Controls the SCL clock in Fm/Sm mode (Master mode)
        pub type CCR_R = crate::FieldReader<u16>;
        ///Field `CCR` writer - RW, Controls the SCL clock in Fm/Sm mode (Master mode)
        pub type CCR_W<'a, REG> = crate::FieldWriter<'a, REG, 12, u16>;
        ///Field `DUTY` reader - RW, Fm mode duty cycle: 0=L/H=2, 1=L/H=16/9
        pub type DUTY_R = crate::BitReader;
        ///Field `DUTY` writer - RW, Fm mode duty cycle: 0=L/H=2, 1=L/H=16/9
        pub type DUTY_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `F_S` reader - RW, I2C master mode selection: 0=standard mode, 1=fast mode
        pub type F_S_R = crate::BitReader;
        ///Field `F_S` writer - RW, I2C master mode selection: 0=standard mode, 1=fast mode
        pub type F_S_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bits 0:11 - RW, Controls the SCL clock in Fm/Sm mode (Master mode)
            #[inline(always)]
            pub fn ccr(&self) -> CCR_R {
                CCR_R::new(self.bits & 0x0fff)
            }
            ///Bit 14 - RW, Fm mode duty cycle: 0=L/H=2, 1=L/H=16/9
            #[inline(always)]
            pub fn duty(&self) -> DUTY_R {
                DUTY_R::new(((self.bits >> 14) & 1) != 0)
            }
            ///Bit 15 - RW, I2C master mode selection: 0=standard mode, 1=fast mode
            #[inline(always)]
            pub fn f_s(&self) -> F_S_R {
                F_S_R::new(((self.bits >> 15) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:11 - RW, Controls the SCL clock in Fm/Sm mode (Master mode)
            #[inline(always)]
            #[must_use]
            pub fn ccr(&mut self) -> CCR_W<CKCFGR_SPEC> {
                CCR_W::new(self, 0)
            }
            ///Bit 14 - RW, Fm mode duty cycle: 0=L/H=2, 1=L/H=16/9
            #[inline(always)]
            #[must_use]
            pub fn duty(&mut self) -> DUTY_W<CKCFGR_SPEC> {
                DUTY_W::new(self, 14)
            }
            ///Bit 15 - RW, I2C master mode selection: 0=standard mode, 1=fast mode
            #[inline(always)]
            #[must_use]
            pub fn f_s(&mut self) -> F_S_W<CKCFGR_SPEC> {
                F_S_W::new(self, 15)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW, I2C clock control register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`ckcfgr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ckcfgr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct CKCFGR_SPEC;
        impl crate::RegisterSpec for CKCFGR_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`ckcfgr::R`](R) reader structure
        impl crate::Readable for CKCFGR_SPEC {}
        ///`write(|w| ..)` method takes [`ckcfgr::W`](W) writer structure
        impl crate::Writable for CKCFGR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets CKCFGR to value 0
        impl crate::Resettable for CKCFGR_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///RTR (rw) register accessor: RW, I2C trise register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`rtr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`rtr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@rtr`]
    ///module
    pub type RTR = crate::Reg<rtr::RTR_SPEC>;
    ///RW, I2C trise register
    pub mod rtr {
        ///Register `RTR` reader
        pub type R = crate::R<RTR_SPEC>;
        ///Register `RTR` writer
        pub type W = crate::W<RTR_SPEC>;
        ///Field `TRISE` reader - RW, Maximum rise time in Fm/Sm mode (Master mode)
        pub type TRISE_R = crate::FieldReader;
        ///Field `TRISE` writer - RW, Maximum rise time in Fm/Sm mode (Master mode)
        pub type TRISE_W<'a, REG> = crate::FieldWriter<'a, REG, 6>;
        impl R {
            ///Bits 0:5 - RW, Maximum rise time in Fm/Sm mode (Master mode)
            #[inline(always)]
            pub fn trise(&self) -> TRISE_R {
                TRISE_R::new((self.bits & 0x3f) as u8)
            }
        }
        impl W {
            ///Bits 0:5 - RW, Maximum rise time in Fm/Sm mode (Master mode)
            #[inline(always)]
            #[must_use]
            pub fn trise(&mut self) -> TRISE_W<RTR_SPEC> {
                TRISE_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW, I2C trise register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`rtr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`rtr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct RTR_SPEC;
        impl crate::RegisterSpec for RTR_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`rtr::R`](R) reader structure
        impl crate::Readable for RTR_SPEC {}
        ///`write(|w| ..)` method takes [`rtr::W`](W) writer structure
        impl crate::Writable for RTR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets RTR to value 0x02
        impl crate::Resettable for RTR_SPEC {
            const RESET_VALUE: u16 = 0x02;
        }
    }
}
///PWMx register
pub struct PWMX {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for PWMX {}
impl PWMX {
    ///Pointer to the register block
    pub const PTR: *const pwmx::RegisterBlock = 0x4000_5000 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const pwmx::RegisterBlock {
        Self::PTR
    }
    /// Steal an instance of this peripheral
    ///
    /// # Safety
    ///
    /// Ensure that the new instance of the peripheral cannot be used in a way
    /// that may race with any existing instances, for example by only
    /// accessing read-only or write-only registers, or by consuming the
    /// original peripheral and using critical sections to coordinate
    /// access between multiple new instances.
    ///
    /// Additionally, other software such as HALs may rely on only one
    /// peripheral instance existing to ensure memory safety; ensure
    /// no stolen instances are passed to such software.
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for PWMX {
    type Target = pwmx::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for PWMX {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("PWMX").finish()
    }
}
///PWMx register
pub mod pwmx {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        pwm_out_en: PWM_OUT_EN,
        pwm_polar: PWM_POLAR,
        pwm_config: PWM_CONFIG,
        pwm_clock_div: PWM_CLOCK_DIV,
        pwm4_data: PWM4_DATA,
        pwm5_data: PWM5_DATA,
        pwm6_data: PWM6_DATA,
        pwm7_data: PWM7_DATA,
        pwm8_data: PWM8_DATA,
        pwm9_data: PWM9_DATA,
        pwm10_data: PWM10_DATA,
        pwm11_data: PWM11_DATA,
        pwm_int_ctrl: PWM_INT_CTRL,
    }
    impl RegisterBlock {
        ///0x00 - RW, PWM output enable control
        #[inline(always)]
        pub const fn pwm_out_en(&self) -> &PWM_OUT_EN {
            &self.pwm_out_en
        }
        ///0x01 - RW, PWM output polarity control
        #[inline(always)]
        pub const fn pwm_polar(&self) -> &PWM_POLAR {
            &self.pwm_polar
        }
        ///0x02 - RW, PWM configuration
        #[inline(always)]
        pub const fn pwm_config(&self) -> &PWM_CONFIG {
            &self.pwm_config
        }
        ///0x03 - RW, PWM clock divisor
        #[inline(always)]
        pub const fn pwm_clock_div(&self) -> &PWM_CLOCK_DIV {
            &self.pwm_clock_div
        }
        ///0x04 - RW, PWM4 data holding
        #[inline(always)]
        pub const fn pwm4_data(&self) -> &PWM4_DATA {
            &self.pwm4_data
        }
        ///0x05 - RW, PWM5 data holding
        #[inline(always)]
        pub const fn pwm5_data(&self) -> &PWM5_DATA {
            &self.pwm5_data
        }
        ///0x06 - RW, PWM6 data holding
        #[inline(always)]
        pub const fn pwm6_data(&self) -> &PWM6_DATA {
            &self.pwm6_data
        }
        ///0x07 - RW, PWM7 data holding
        #[inline(always)]
        pub const fn pwm7_data(&self) -> &PWM7_DATA {
            &self.pwm7_data
        }
        ///0x08 - RW, PWM8 data holding
        #[inline(always)]
        pub const fn pwm8_data(&self) -> &PWM8_DATA {
            &self.pwm8_data
        }
        ///0x09 - RW, PWM9 data holding
        #[inline(always)]
        pub const fn pwm9_data(&self) -> &PWM9_DATA {
            &self.pwm9_data
        }
        ///0x0a - RW, PWM10 data holding
        #[inline(always)]
        pub const fn pwm10_data(&self) -> &PWM10_DATA {
            &self.pwm10_data
        }
        ///0x0b - RW, PWM11 data holding
        #[inline(always)]
        pub const fn pwm11_data(&self) -> &PWM11_DATA {
            &self.pwm11_data
        }
        ///0x0c - RW, PWM interrupt control
        #[inline(always)]
        pub const fn pwm_int_ctrl(&self) -> &PWM_INT_CTRL {
            &self.pwm_int_ctrl
        }
    }
    ///PWM_OUT_EN (rw) register accessor: RW, PWM output enable control
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`pwm_out_en::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pwm_out_en::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@pwm_out_en`]
    ///module
    pub type PWM_OUT_EN = crate::Reg<pwm_out_en::PWM_OUT_EN_SPEC>;
    ///RW, PWM output enable control
    pub mod pwm_out_en {
        ///Register `PWM_OUT_EN` reader
        pub type R = crate::R<PWM_OUT_EN_SPEC>;
        ///Register `PWM_OUT_EN` writer
        pub type W = crate::W<PWM_OUT_EN_SPEC>;
        ///Field `PWM4_OUT_EN` reader - RW, PWM4 output enable
        pub type PWM4_OUT_EN_R = crate::BitReader;
        ///Field `PWM4_OUT_EN` writer - RW, PWM4 output enable
        pub type PWM4_OUT_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PWM5_OUT_EN` reader - RW, PWM5 output enable
        pub type PWM5_OUT_EN_R = crate::BitReader;
        ///Field `PWM5_OUT_EN` writer - RW, PWM5 output enable
        pub type PWM5_OUT_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PWM6_OUT_EN` reader - RW, PWM6 output enable
        pub type PWM6_OUT_EN_R = crate::BitReader;
        ///Field `PWM6_OUT_EN` writer - RW, PWM6 output enable
        pub type PWM6_OUT_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PWM7_OUT_EN` reader - RW, PWM7 output enable
        pub type PWM7_OUT_EN_R = crate::BitReader;
        ///Field `PWM7_OUT_EN` writer - RW, PWM7 output enable
        pub type PWM7_OUT_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PWM8_OUT_EN` reader - RW, PWM8 output enable
        pub type PWM8_OUT_EN_R = crate::BitReader;
        ///Field `PWM8_OUT_EN` writer - RW, PWM8 output enable
        pub type PWM8_OUT_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PWM9_OUT_EN` reader - RW, PWM9 output enable
        pub type PWM9_OUT_EN_R = crate::BitReader;
        ///Field `PWM9_OUT_EN` writer - RW, PWM9 output enable
        pub type PWM9_OUT_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PWM10_OUT_EN` reader - RW, PWM10 output enable
        pub type PWM10_OUT_EN_R = crate::BitReader;
        ///Field `PWM10_OUT_EN` writer - RW, PWM10 output enable
        pub type PWM10_OUT_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PWM11_OUT_EN` reader - RW, PWM11 output enable
        pub type PWM11_OUT_EN_R = crate::BitReader;
        ///Field `PWM11_OUT_EN` writer - RW, PWM11 output enable
        pub type PWM11_OUT_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - RW, PWM4 output enable
            #[inline(always)]
            pub fn pwm4_out_en(&self) -> PWM4_OUT_EN_R {
                PWM4_OUT_EN_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RW, PWM5 output enable
            #[inline(always)]
            pub fn pwm5_out_en(&self) -> PWM5_OUT_EN_R {
                PWM5_OUT_EN_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RW, PWM6 output enable
            #[inline(always)]
            pub fn pwm6_out_en(&self) -> PWM6_OUT_EN_R {
                PWM6_OUT_EN_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RW, PWM7 output enable
            #[inline(always)]
            pub fn pwm7_out_en(&self) -> PWM7_OUT_EN_R {
                PWM7_OUT_EN_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RW, PWM8 output enable
            #[inline(always)]
            pub fn pwm8_out_en(&self) -> PWM8_OUT_EN_R {
                PWM8_OUT_EN_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - RW, PWM9 output enable
            #[inline(always)]
            pub fn pwm9_out_en(&self) -> PWM9_OUT_EN_R {
                PWM9_OUT_EN_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - RW, PWM10 output enable
            #[inline(always)]
            pub fn pwm10_out_en(&self) -> PWM10_OUT_EN_R {
                PWM10_OUT_EN_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - RW, PWM11 output enable
            #[inline(always)]
            pub fn pwm11_out_en(&self) -> PWM11_OUT_EN_R {
                PWM11_OUT_EN_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RW, PWM4 output enable
            #[inline(always)]
            #[must_use]
            pub fn pwm4_out_en(&mut self) -> PWM4_OUT_EN_W<PWM_OUT_EN_SPEC> {
                PWM4_OUT_EN_W::new(self, 0)
            }
            ///Bit 1 - RW, PWM5 output enable
            #[inline(always)]
            #[must_use]
            pub fn pwm5_out_en(&mut self) -> PWM5_OUT_EN_W<PWM_OUT_EN_SPEC> {
                PWM5_OUT_EN_W::new(self, 1)
            }
            ///Bit 2 - RW, PWM6 output enable
            #[inline(always)]
            #[must_use]
            pub fn pwm6_out_en(&mut self) -> PWM6_OUT_EN_W<PWM_OUT_EN_SPEC> {
                PWM6_OUT_EN_W::new(self, 2)
            }
            ///Bit 3 - RW, PWM7 output enable
            #[inline(always)]
            #[must_use]
            pub fn pwm7_out_en(&mut self) -> PWM7_OUT_EN_W<PWM_OUT_EN_SPEC> {
                PWM7_OUT_EN_W::new(self, 3)
            }
            ///Bit 4 - RW, PWM8 output enable
            #[inline(always)]
            #[must_use]
            pub fn pwm8_out_en(&mut self) -> PWM8_OUT_EN_W<PWM_OUT_EN_SPEC> {
                PWM8_OUT_EN_W::new(self, 4)
            }
            ///Bit 5 - RW, PWM9 output enable
            #[inline(always)]
            #[must_use]
            pub fn pwm9_out_en(&mut self) -> PWM9_OUT_EN_W<PWM_OUT_EN_SPEC> {
                PWM9_OUT_EN_W::new(self, 5)
            }
            ///Bit 6 - RW, PWM10 output enable
            #[inline(always)]
            #[must_use]
            pub fn pwm10_out_en(&mut self) -> PWM10_OUT_EN_W<PWM_OUT_EN_SPEC> {
                PWM10_OUT_EN_W::new(self, 6)
            }
            ///Bit 7 - RW, PWM11 output enable
            #[inline(always)]
            #[must_use]
            pub fn pwm11_out_en(&mut self) -> PWM11_OUT_EN_W<PWM_OUT_EN_SPEC> {
                PWM11_OUT_EN_W::new(self, 7)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW, PWM output enable control
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`pwm_out_en::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pwm_out_en::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct PWM_OUT_EN_SPEC;
        impl crate::RegisterSpec for PWM_OUT_EN_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`pwm_out_en::R`](R) reader structure
        impl crate::Readable for PWM_OUT_EN_SPEC {}
        ///`write(|w| ..)` method takes [`pwm_out_en::W`](W) writer structure
        impl crate::Writable for PWM_OUT_EN_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets PWM_OUT_EN to value 0
        impl crate::Resettable for PWM_OUT_EN_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///PWM_POLAR (rw) register accessor: RW, PWM output polarity control
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`pwm_polar::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pwm_polar::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@pwm_polar`]
    ///module
    pub type PWM_POLAR = crate::Reg<pwm_polar::PWM_POLAR_SPEC>;
    ///RW, PWM output polarity control
    pub mod pwm_polar {
        ///Register `PWM_POLAR` reader
        pub type R = crate::R<PWM_POLAR_SPEC>;
        ///Register `PWM_POLAR` writer
        pub type W = crate::W<PWM_POLAR_SPEC>;
        ///Field `PWM4_POLAR` reader - RW, PWM4 output polarity: 0=default low and high action, 1=default high and low action
        pub type PWM4_POLAR_R = crate::BitReader;
        ///Field `PWM4_POLAR` writer - RW, PWM4 output polarity: 0=default low and high action, 1=default high and low action
        pub type PWM4_POLAR_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PWM5_POLAR` reader - RW, PWM5 output polarity: 0=default low and high action, 1=default high and low action
        pub type PWM5_POLAR_R = crate::BitReader;
        ///Field `PWM5_POLAR` writer - RW, PWM5 output polarity: 0=default low and high action, 1=default high and low action
        pub type PWM5_POLAR_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PWM6_POLAR` reader - RW, PWM6 output polarity: 0=default low and high action, 1=default high and low action
        pub type PWM6_POLAR_R = crate::BitReader;
        ///Field `PWM6_POLAR` writer - RW, PWM6 output polarity: 0=default low and high action, 1=default high and low action
        pub type PWM6_POLAR_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PWM7_POLAR` reader - RW, PWM7 output polarity: 0=default low and high action, 1=default high and low action
        pub type PWM7_POLAR_R = crate::BitReader;
        ///Field `PWM7_POLAR` writer - RW, PWM7 output polarity: 0=default low and high action, 1=default high and low action
        pub type PWM7_POLAR_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PWM8_POLAR` reader - RW, PWM8 output polarity: 0=default low and high action, 1=default high and low action
        pub type PWM8_POLAR_R = crate::BitReader;
        ///Field `PWM8_POLAR` writer - RW, PWM8 output polarity: 0=default low and high action, 1=default high and low action
        pub type PWM8_POLAR_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PWM9_POLAR` reader - RW, PWM9 output polarity: 0=default low and high action, 1=default high and low action
        pub type PWM9_POLAR_R = crate::BitReader;
        ///Field `PWM9_POLAR` writer - RW, PWM9 output polarity: 0=default low and high action, 1=default high and low action
        pub type PWM9_POLAR_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PWM10_POLAR` reader - RW, PWM10 output polarity: 0=default low and high action, 1=default high and low action
        pub type PWM10_POLAR_R = crate::BitReader;
        ///Field `PWM10_POLAR` writer - RW, PWM10 output polarity: 0=default low and high action, 1=default high and low action
        pub type PWM10_POLAR_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PWM11_POLAR` reader - RW, PWM11 output polarity: 0=default low and high action, 1=default high and low action
        pub type PWM11_POLAR_R = crate::BitReader;
        ///Field `PWM11_POLAR` writer - RW, PWM11 output polarity: 0=default low and high action, 1=default high and low action
        pub type PWM11_POLAR_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - RW, PWM4 output polarity: 0=default low and high action, 1=default high and low action
            #[inline(always)]
            pub fn pwm4_polar(&self) -> PWM4_POLAR_R {
                PWM4_POLAR_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RW, PWM5 output polarity: 0=default low and high action, 1=default high and low action
            #[inline(always)]
            pub fn pwm5_polar(&self) -> PWM5_POLAR_R {
                PWM5_POLAR_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RW, PWM6 output polarity: 0=default low and high action, 1=default high and low action
            #[inline(always)]
            pub fn pwm6_polar(&self) -> PWM6_POLAR_R {
                PWM6_POLAR_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RW, PWM7 output polarity: 0=default low and high action, 1=default high and low action
            #[inline(always)]
            pub fn pwm7_polar(&self) -> PWM7_POLAR_R {
                PWM7_POLAR_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RW, PWM8 output polarity: 0=default low and high action, 1=default high and low action
            #[inline(always)]
            pub fn pwm8_polar(&self) -> PWM8_POLAR_R {
                PWM8_POLAR_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - RW, PWM9 output polarity: 0=default low and high action, 1=default high and low action
            #[inline(always)]
            pub fn pwm9_polar(&self) -> PWM9_POLAR_R {
                PWM9_POLAR_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - RW, PWM10 output polarity: 0=default low and high action, 1=default high and low action
            #[inline(always)]
            pub fn pwm10_polar(&self) -> PWM10_POLAR_R {
                PWM10_POLAR_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - RW, PWM11 output polarity: 0=default low and high action, 1=default high and low action
            #[inline(always)]
            pub fn pwm11_polar(&self) -> PWM11_POLAR_R {
                PWM11_POLAR_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RW, PWM4 output polarity: 0=default low and high action, 1=default high and low action
            #[inline(always)]
            #[must_use]
            pub fn pwm4_polar(&mut self) -> PWM4_POLAR_W<PWM_POLAR_SPEC> {
                PWM4_POLAR_W::new(self, 0)
            }
            ///Bit 1 - RW, PWM5 output polarity: 0=default low and high action, 1=default high and low action
            #[inline(always)]
            #[must_use]
            pub fn pwm5_polar(&mut self) -> PWM5_POLAR_W<PWM_POLAR_SPEC> {
                PWM5_POLAR_W::new(self, 1)
            }
            ///Bit 2 - RW, PWM6 output polarity: 0=default low and high action, 1=default high and low action
            #[inline(always)]
            #[must_use]
            pub fn pwm6_polar(&mut self) -> PWM6_POLAR_W<PWM_POLAR_SPEC> {
                PWM6_POLAR_W::new(self, 2)
            }
            ///Bit 3 - RW, PWM7 output polarity: 0=default low and high action, 1=default high and low action
            #[inline(always)]
            #[must_use]
            pub fn pwm7_polar(&mut self) -> PWM7_POLAR_W<PWM_POLAR_SPEC> {
                PWM7_POLAR_W::new(self, 3)
            }
            ///Bit 4 - RW, PWM8 output polarity: 0=default low and high action, 1=default high and low action
            #[inline(always)]
            #[must_use]
            pub fn pwm8_polar(&mut self) -> PWM8_POLAR_W<PWM_POLAR_SPEC> {
                PWM8_POLAR_W::new(self, 4)
            }
            ///Bit 5 - RW, PWM9 output polarity: 0=default low and high action, 1=default high and low action
            #[inline(always)]
            #[must_use]
            pub fn pwm9_polar(&mut self) -> PWM9_POLAR_W<PWM_POLAR_SPEC> {
                PWM9_POLAR_W::new(self, 5)
            }
            ///Bit 6 - RW, PWM10 output polarity: 0=default low and high action, 1=default high and low action
            #[inline(always)]
            #[must_use]
            pub fn pwm10_polar(&mut self) -> PWM10_POLAR_W<PWM_POLAR_SPEC> {
                PWM10_POLAR_W::new(self, 6)
            }
            ///Bit 7 - RW, PWM11 output polarity: 0=default low and high action, 1=default high and low action
            #[inline(always)]
            #[must_use]
            pub fn pwm11_polar(&mut self) -> PWM11_POLAR_W<PWM_POLAR_SPEC> {
                PWM11_POLAR_W::new(self, 7)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW, PWM output polarity control
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`pwm_polar::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pwm_polar::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct PWM_POLAR_SPEC;
        impl crate::RegisterSpec for PWM_POLAR_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`pwm_polar::R`](R) reader structure
        impl crate::Readable for PWM_POLAR_SPEC {}
        ///`write(|w| ..)` method takes [`pwm_polar::W`](W) writer structure
        impl crate::Writable for PWM_POLAR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets PWM_POLAR to value 0
        impl crate::Resettable for PWM_POLAR_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///PWM_CONFIG (rw) register accessor: RW, PWM configuration
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`pwm_config::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pwm_config::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@pwm_config`]
    ///module
    pub type PWM_CONFIG = crate::Reg<pwm_config::PWM_CONFIG_SPEC>;
    ///RW, PWM configuration
    pub mod pwm_config {
        ///Register `PWM_CONFIG` reader
        pub type R = crate::R<PWM_CONFIG_SPEC>;
        ///Register `PWM_CONFIG` writer
        pub type W = crate::W<PWM_CONFIG_SPEC>;
        ///Field `PWM_CYCLE_SEL` reader - RW, PWM cycle selection: 0=256;128;64;32 clocks, 1=255;127;63;31 clocks
        pub type PWM_CYCLE_SEL_R = crate::BitReader;
        ///Field `PWM_CYCLE_SEL` writer - RW, PWM cycle selection: 0=256;128;64;32 clocks, 1=255;127;63;31 clocks
        pub type PWM_CYCLE_SEL_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PWM_STAG_ST` reader - RO, PWM stagger cycle status
        pub type PWM_STAG_ST_R = crate::BitReader;
        ///Field `PWM_CYC_MOD` reader - RW, PWM data width mode: 00=8 bits data, 01=7 bits data, 10=6 bits data, 11=5 bits data
        pub type PWM_CYC_MOD_R = crate::FieldReader;
        ///Field `PWM_CYC_MOD` writer - RW, PWM data width mode: 00=8 bits data, 01=7 bits data, 10=6 bits data, 11=5 bits data
        pub type PWM_CYC_MOD_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `PWM4_5_STAG_EN` reader - RW, PWM4/5 stagger output enable: 0=independent output, 1=stagger output
        pub type PWM4_5_STAG_EN_R = crate::BitReader;
        ///Field `PWM4_5_STAG_EN` writer - RW, PWM4/5 stagger output enable: 0=independent output, 1=stagger output
        pub type PWM4_5_STAG_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PWM6_7_STAG_EN` reader - RW, PWM6/7 stagger output enable: 0=independent output, 1=stagger output
        pub type PWM6_7_STAG_EN_R = crate::BitReader;
        ///Field `PWM6_7_STAG_EN` writer - RW, PWM6/7 stagger output enable: 0=independent output, 1=stagger output
        pub type PWM6_7_STAG_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PWM8_9_STAG_EN` reader - RW, PWM8/9 stagger output enable: 0=independent output, 1=stagger output
        pub type PWM8_9_STAG_EN_R = crate::BitReader;
        ///Field `PWM8_9_STAG_EN` writer - RW, PWM8/9 stagger output enable: 0=independent output, 1=stagger output
        pub type PWM8_9_STAG_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PWM10_11_STAG_EN` reader - RW, PWM10/11 stagger output enable: 0=independent output, 1=stagger output
        pub type PWM10_11_STAG_EN_R = crate::BitReader;
        ///Field `PWM10_11_STAG_EN` writer - RW, PWM10/11 stagger output enable: 0=independent output, 1=stagger output
        pub type PWM10_11_STAG_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - RW, PWM cycle selection: 0=256;128;64;32 clocks, 1=255;127;63;31 clocks
            #[inline(always)]
            pub fn pwm_cycle_sel(&self) -> PWM_CYCLE_SEL_R {
                PWM_CYCLE_SEL_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RO, PWM stagger cycle status
            #[inline(always)]
            pub fn pwm_stag_st(&self) -> PWM_STAG_ST_R {
                PWM_STAG_ST_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bits 2:3 - RW, PWM data width mode: 00=8 bits data, 01=7 bits data, 10=6 bits data, 11=5 bits data
            #[inline(always)]
            pub fn pwm_cyc_mod(&self) -> PWM_CYC_MOD_R {
                PWM_CYC_MOD_R::new((self.bits >> 2) & 3)
            }
            ///Bit 4 - RW, PWM4/5 stagger output enable: 0=independent output, 1=stagger output
            #[inline(always)]
            pub fn pwm4_5_stag_en(&self) -> PWM4_5_STAG_EN_R {
                PWM4_5_STAG_EN_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - RW, PWM6/7 stagger output enable: 0=independent output, 1=stagger output
            #[inline(always)]
            pub fn pwm6_7_stag_en(&self) -> PWM6_7_STAG_EN_R {
                PWM6_7_STAG_EN_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - RW, PWM8/9 stagger output enable: 0=independent output, 1=stagger output
            #[inline(always)]
            pub fn pwm8_9_stag_en(&self) -> PWM8_9_STAG_EN_R {
                PWM8_9_STAG_EN_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - RW, PWM10/11 stagger output enable: 0=independent output, 1=stagger output
            #[inline(always)]
            pub fn pwm10_11_stag_en(&self) -> PWM10_11_STAG_EN_R {
                PWM10_11_STAG_EN_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RW, PWM cycle selection: 0=256;128;64;32 clocks, 1=255;127;63;31 clocks
            #[inline(always)]
            #[must_use]
            pub fn pwm_cycle_sel(&mut self) -> PWM_CYCLE_SEL_W<PWM_CONFIG_SPEC> {
                PWM_CYCLE_SEL_W::new(self, 0)
            }
            ///Bits 2:3 - RW, PWM data width mode: 00=8 bits data, 01=7 bits data, 10=6 bits data, 11=5 bits data
            #[inline(always)]
            #[must_use]
            pub fn pwm_cyc_mod(&mut self) -> PWM_CYC_MOD_W<PWM_CONFIG_SPEC> {
                PWM_CYC_MOD_W::new(self, 2)
            }
            ///Bit 4 - RW, PWM4/5 stagger output enable: 0=independent output, 1=stagger output
            #[inline(always)]
            #[must_use]
            pub fn pwm4_5_stag_en(&mut self) -> PWM4_5_STAG_EN_W<PWM_CONFIG_SPEC> {
                PWM4_5_STAG_EN_W::new(self, 4)
            }
            ///Bit 5 - RW, PWM6/7 stagger output enable: 0=independent output, 1=stagger output
            #[inline(always)]
            #[must_use]
            pub fn pwm6_7_stag_en(&mut self) -> PWM6_7_STAG_EN_W<PWM_CONFIG_SPEC> {
                PWM6_7_STAG_EN_W::new(self, 5)
            }
            ///Bit 6 - RW, PWM8/9 stagger output enable: 0=independent output, 1=stagger output
            #[inline(always)]
            #[must_use]
            pub fn pwm8_9_stag_en(&mut self) -> PWM8_9_STAG_EN_W<PWM_CONFIG_SPEC> {
                PWM8_9_STAG_EN_W::new(self, 6)
            }
            ///Bit 7 - RW, PWM10/11 stagger output enable: 0=independent output, 1=stagger output
            #[inline(always)]
            #[must_use]
            pub fn pwm10_11_stag_en(&mut self) -> PWM10_11_STAG_EN_W<PWM_CONFIG_SPEC> {
                PWM10_11_STAG_EN_W::new(self, 7)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW, PWM configuration
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`pwm_config::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pwm_config::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct PWM_CONFIG_SPEC;
        impl crate::RegisterSpec for PWM_CONFIG_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`pwm_config::R`](R) reader structure
        impl crate::Readable for PWM_CONFIG_SPEC {}
        ///`write(|w| ..)` method takes [`pwm_config::W`](W) writer structure
        impl crate::Writable for PWM_CONFIG_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets PWM_CONFIG to value 0
        impl crate::Resettable for PWM_CONFIG_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///PWM_CLOCK_DIV (rw) register accessor: RW, PWM clock divisor
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`pwm_clock_div::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pwm_clock_div::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@pwm_clock_div`]
    ///module
    pub type PWM_CLOCK_DIV = crate::Reg<pwm_clock_div::PWM_CLOCK_DIV_SPEC>;
    ///RW, PWM clock divisor
    pub mod pwm_clock_div {
        ///Register `PWM_CLOCK_DIV` reader
        pub type R = crate::R<PWM_CLOCK_DIV_SPEC>;
        ///Register `PWM_CLOCK_DIV` writer
        pub type W = crate::W<PWM_CLOCK_DIV_SPEC>;
        ///Field `PWM_CLOCK_DIV` reader - RW, PWM clock divisor
        pub type PWM_CLOCK_DIV_R = crate::FieldReader;
        ///Field `PWM_CLOCK_DIV` writer - RW, PWM clock divisor
        pub type PWM_CLOCK_DIV_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            ///Bits 0:7 - RW, PWM clock divisor
            #[inline(always)]
            pub fn pwm_clock_div(&self) -> PWM_CLOCK_DIV_R {
                PWM_CLOCK_DIV_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:7 - RW, PWM clock divisor
            #[inline(always)]
            #[must_use]
            pub fn pwm_clock_div(&mut self) -> PWM_CLOCK_DIV_W<PWM_CLOCK_DIV_SPEC> {
                PWM_CLOCK_DIV_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW, PWM clock divisor
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`pwm_clock_div::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pwm_clock_div::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct PWM_CLOCK_DIV_SPEC;
        impl crate::RegisterSpec for PWM_CLOCK_DIV_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`pwm_clock_div::R`](R) reader structure
        impl crate::Readable for PWM_CLOCK_DIV_SPEC {}
        ///`write(|w| ..)` method takes [`pwm_clock_div::W`](W) writer structure
        impl crate::Writable for PWM_CLOCK_DIV_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets PWM_CLOCK_DIV to value 0
        impl crate::Resettable for PWM_CLOCK_DIV_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///PWM4_DATA (rw) register accessor: RW, PWM4 data holding
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`pwm4_data::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pwm4_data::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@pwm4_data`]
    ///module
    pub type PWM4_DATA = crate::Reg<pwm4_data::PWM4_DATA_SPEC>;
    ///RW, PWM4 data holding
    pub mod pwm4_data {
        ///Register `PWM4_DATA` reader
        pub type R = crate::R<PWM4_DATA_SPEC>;
        ///Register `PWM4_DATA` writer
        pub type W = crate::W<PWM4_DATA_SPEC>;
        ///Field `PWM4_DATA` reader - RW, PWM4 data holding
        pub type PWM4_DATA_R = crate::FieldReader;
        ///Field `PWM4_DATA` writer - RW, PWM4 data holding
        pub type PWM4_DATA_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            ///Bits 0:7 - RW, PWM4 data holding
            #[inline(always)]
            pub fn pwm4_data(&self) -> PWM4_DATA_R {
                PWM4_DATA_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:7 - RW, PWM4 data holding
            #[inline(always)]
            #[must_use]
            pub fn pwm4_data(&mut self) -> PWM4_DATA_W<PWM4_DATA_SPEC> {
                PWM4_DATA_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW, PWM4 data holding
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`pwm4_data::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pwm4_data::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct PWM4_DATA_SPEC;
        impl crate::RegisterSpec for PWM4_DATA_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`pwm4_data::R`](R) reader structure
        impl crate::Readable for PWM4_DATA_SPEC {}
        ///`write(|w| ..)` method takes [`pwm4_data::W`](W) writer structure
        impl crate::Writable for PWM4_DATA_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets PWM4_DATA to value 0
        impl crate::Resettable for PWM4_DATA_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///PWM5_DATA (rw) register accessor: RW, PWM5 data holding
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`pwm5_data::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pwm5_data::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@pwm5_data`]
    ///module
    pub type PWM5_DATA = crate::Reg<pwm5_data::PWM5_DATA_SPEC>;
    ///RW, PWM5 data holding
    pub mod pwm5_data {
        ///Register `PWM5_DATA` reader
        pub type R = crate::R<PWM5_DATA_SPEC>;
        ///Register `PWM5_DATA` writer
        pub type W = crate::W<PWM5_DATA_SPEC>;
        ///Field `PWM5_DATA` reader - RW, PWM5 data holding
        pub type PWM5_DATA_R = crate::FieldReader;
        ///Field `PWM5_DATA` writer - RW, PWM5 data holding
        pub type PWM5_DATA_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            ///Bits 0:7 - RW, PWM5 data holding
            #[inline(always)]
            pub fn pwm5_data(&self) -> PWM5_DATA_R {
                PWM5_DATA_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:7 - RW, PWM5 data holding
            #[inline(always)]
            #[must_use]
            pub fn pwm5_data(&mut self) -> PWM5_DATA_W<PWM5_DATA_SPEC> {
                PWM5_DATA_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW, PWM5 data holding
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`pwm5_data::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pwm5_data::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct PWM5_DATA_SPEC;
        impl crate::RegisterSpec for PWM5_DATA_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`pwm5_data::R`](R) reader structure
        impl crate::Readable for PWM5_DATA_SPEC {}
        ///`write(|w| ..)` method takes [`pwm5_data::W`](W) writer structure
        impl crate::Writable for PWM5_DATA_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets PWM5_DATA to value 0
        impl crate::Resettable for PWM5_DATA_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///PWM6_DATA (rw) register accessor: RW, PWM6 data holding
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`pwm6_data::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pwm6_data::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@pwm6_data`]
    ///module
    pub type PWM6_DATA = crate::Reg<pwm6_data::PWM6_DATA_SPEC>;
    ///RW, PWM6 data holding
    pub mod pwm6_data {
        ///Register `PWM6_DATA` reader
        pub type R = crate::R<PWM6_DATA_SPEC>;
        ///Register `PWM6_DATA` writer
        pub type W = crate::W<PWM6_DATA_SPEC>;
        ///Field `PWM6_DATA` reader - RW, PWM6 data holding
        pub type PWM6_DATA_R = crate::FieldReader;
        ///Field `PWM6_DATA` writer - RW, PWM6 data holding
        pub type PWM6_DATA_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            ///Bits 0:7 - RW, PWM6 data holding
            #[inline(always)]
            pub fn pwm6_data(&self) -> PWM6_DATA_R {
                PWM6_DATA_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:7 - RW, PWM6 data holding
            #[inline(always)]
            #[must_use]
            pub fn pwm6_data(&mut self) -> PWM6_DATA_W<PWM6_DATA_SPEC> {
                PWM6_DATA_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW, PWM6 data holding
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`pwm6_data::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pwm6_data::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct PWM6_DATA_SPEC;
        impl crate::RegisterSpec for PWM6_DATA_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`pwm6_data::R`](R) reader structure
        impl crate::Readable for PWM6_DATA_SPEC {}
        ///`write(|w| ..)` method takes [`pwm6_data::W`](W) writer structure
        impl crate::Writable for PWM6_DATA_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets PWM6_DATA to value 0
        impl crate::Resettable for PWM6_DATA_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///PWM7_DATA (rw) register accessor: RW, PWM7 data holding
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`pwm7_data::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pwm7_data::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@pwm7_data`]
    ///module
    pub type PWM7_DATA = crate::Reg<pwm7_data::PWM7_DATA_SPEC>;
    ///RW, PWM7 data holding
    pub mod pwm7_data {
        ///Register `PWM7_DATA` reader
        pub type R = crate::R<PWM7_DATA_SPEC>;
        ///Register `PWM7_DATA` writer
        pub type W = crate::W<PWM7_DATA_SPEC>;
        ///Field `PWM7_DATA` reader - RW, PWM7 data holding
        pub type PWM7_DATA_R = crate::FieldReader;
        ///Field `PWM7_DATA` writer - RW, PWM7 data holding
        pub type PWM7_DATA_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            ///Bits 0:7 - RW, PWM7 data holding
            #[inline(always)]
            pub fn pwm7_data(&self) -> PWM7_DATA_R {
                PWM7_DATA_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:7 - RW, PWM7 data holding
            #[inline(always)]
            #[must_use]
            pub fn pwm7_data(&mut self) -> PWM7_DATA_W<PWM7_DATA_SPEC> {
                PWM7_DATA_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW, PWM7 data holding
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`pwm7_data::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pwm7_data::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct PWM7_DATA_SPEC;
        impl crate::RegisterSpec for PWM7_DATA_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`pwm7_data::R`](R) reader structure
        impl crate::Readable for PWM7_DATA_SPEC {}
        ///`write(|w| ..)` method takes [`pwm7_data::W`](W) writer structure
        impl crate::Writable for PWM7_DATA_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets PWM7_DATA to value 0
        impl crate::Resettable for PWM7_DATA_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///PWM8_DATA (rw) register accessor: RW, PWM8 data holding
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`pwm8_data::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pwm8_data::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@pwm8_data`]
    ///module
    pub type PWM8_DATA = crate::Reg<pwm8_data::PWM8_DATA_SPEC>;
    ///RW, PWM8 data holding
    pub mod pwm8_data {
        ///Register `PWM8_DATA` reader
        pub type R = crate::R<PWM8_DATA_SPEC>;
        ///Register `PWM8_DATA` writer
        pub type W = crate::W<PWM8_DATA_SPEC>;
        ///Field `PWM8_DATA` reader - RW, PWM8 data holding
        pub type PWM8_DATA_R = crate::FieldReader;
        ///Field `PWM8_DATA` writer - RW, PWM8 data holding
        pub type PWM8_DATA_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            ///Bits 0:7 - RW, PWM8 data holding
            #[inline(always)]
            pub fn pwm8_data(&self) -> PWM8_DATA_R {
                PWM8_DATA_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:7 - RW, PWM8 data holding
            #[inline(always)]
            #[must_use]
            pub fn pwm8_data(&mut self) -> PWM8_DATA_W<PWM8_DATA_SPEC> {
                PWM8_DATA_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW, PWM8 data holding
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`pwm8_data::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pwm8_data::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct PWM8_DATA_SPEC;
        impl crate::RegisterSpec for PWM8_DATA_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`pwm8_data::R`](R) reader structure
        impl crate::Readable for PWM8_DATA_SPEC {}
        ///`write(|w| ..)` method takes [`pwm8_data::W`](W) writer structure
        impl crate::Writable for PWM8_DATA_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets PWM8_DATA to value 0
        impl crate::Resettable for PWM8_DATA_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///PWM9_DATA (rw) register accessor: RW, PWM9 data holding
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`pwm9_data::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pwm9_data::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@pwm9_data`]
    ///module
    pub type PWM9_DATA = crate::Reg<pwm9_data::PWM9_DATA_SPEC>;
    ///RW, PWM9 data holding
    pub mod pwm9_data {
        ///Register `PWM9_DATA` reader
        pub type R = crate::R<PWM9_DATA_SPEC>;
        ///Register `PWM9_DATA` writer
        pub type W = crate::W<PWM9_DATA_SPEC>;
        ///Field `PWM9_DATA` reader - RW, PWM9 data holding
        pub type PWM9_DATA_R = crate::FieldReader;
        ///Field `PWM9_DATA` writer - RW, PWM9 data holding
        pub type PWM9_DATA_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            ///Bits 0:7 - RW, PWM9 data holding
            #[inline(always)]
            pub fn pwm9_data(&self) -> PWM9_DATA_R {
                PWM9_DATA_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:7 - RW, PWM9 data holding
            #[inline(always)]
            #[must_use]
            pub fn pwm9_data(&mut self) -> PWM9_DATA_W<PWM9_DATA_SPEC> {
                PWM9_DATA_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW, PWM9 data holding
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`pwm9_data::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pwm9_data::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct PWM9_DATA_SPEC;
        impl crate::RegisterSpec for PWM9_DATA_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`pwm9_data::R`](R) reader structure
        impl crate::Readable for PWM9_DATA_SPEC {}
        ///`write(|w| ..)` method takes [`pwm9_data::W`](W) writer structure
        impl crate::Writable for PWM9_DATA_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets PWM9_DATA to value 0
        impl crate::Resettable for PWM9_DATA_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///PWM10_DATA (rw) register accessor: RW, PWM10 data holding
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`pwm10_data::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pwm10_data::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@pwm10_data`]
    ///module
    pub type PWM10_DATA = crate::Reg<pwm10_data::PWM10_DATA_SPEC>;
    ///RW, PWM10 data holding
    pub mod pwm10_data {
        ///Register `PWM10_DATA` reader
        pub type R = crate::R<PWM10_DATA_SPEC>;
        ///Register `PWM10_DATA` writer
        pub type W = crate::W<PWM10_DATA_SPEC>;
        ///Field `PWM10_DATA` reader - RW, PWM10 data holding
        pub type PWM10_DATA_R = crate::FieldReader;
        ///Field `PWM10_DATA` writer - RW, PWM10 data holding
        pub type PWM10_DATA_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            ///Bits 0:7 - RW, PWM10 data holding
            #[inline(always)]
            pub fn pwm10_data(&self) -> PWM10_DATA_R {
                PWM10_DATA_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:7 - RW, PWM10 data holding
            #[inline(always)]
            #[must_use]
            pub fn pwm10_data(&mut self) -> PWM10_DATA_W<PWM10_DATA_SPEC> {
                PWM10_DATA_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW, PWM10 data holding
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`pwm10_data::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pwm10_data::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct PWM10_DATA_SPEC;
        impl crate::RegisterSpec for PWM10_DATA_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`pwm10_data::R`](R) reader structure
        impl crate::Readable for PWM10_DATA_SPEC {}
        ///`write(|w| ..)` method takes [`pwm10_data::W`](W) writer structure
        impl crate::Writable for PWM10_DATA_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets PWM10_DATA to value 0
        impl crate::Resettable for PWM10_DATA_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///PWM11_DATA (rw) register accessor: RW, PWM11 data holding
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`pwm11_data::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pwm11_data::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@pwm11_data`]
    ///module
    pub type PWM11_DATA = crate::Reg<pwm11_data::PWM11_DATA_SPEC>;
    ///RW, PWM11 data holding
    pub mod pwm11_data {
        ///Register `PWM11_DATA` reader
        pub type R = crate::R<PWM11_DATA_SPEC>;
        ///Register `PWM11_DATA` writer
        pub type W = crate::W<PWM11_DATA_SPEC>;
        ///Field `PWM11_DATA` reader - RW, PWM11 data holding
        pub type PWM11_DATA_R = crate::FieldReader;
        ///Field `PWM11_DATA` writer - RW, PWM11 data holding
        pub type PWM11_DATA_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            ///Bits 0:7 - RW, PWM11 data holding
            #[inline(always)]
            pub fn pwm11_data(&self) -> PWM11_DATA_R {
                PWM11_DATA_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:7 - RW, PWM11 data holding
            #[inline(always)]
            #[must_use]
            pub fn pwm11_data(&mut self) -> PWM11_DATA_W<PWM11_DATA_SPEC> {
                PWM11_DATA_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW, PWM11 data holding
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`pwm11_data::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pwm11_data::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct PWM11_DATA_SPEC;
        impl crate::RegisterSpec for PWM11_DATA_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`pwm11_data::R`](R) reader structure
        impl crate::Readable for PWM11_DATA_SPEC {}
        ///`write(|w| ..)` method takes [`pwm11_data::W`](W) writer structure
        impl crate::Writable for PWM11_DATA_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets PWM11_DATA to value 0
        impl crate::Resettable for PWM11_DATA_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///PWM_INT_CTRL (rw) register accessor: RW, PWM interrupt control
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`pwm_int_ctrl::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pwm_int_ctrl::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@pwm_int_ctrl`]
    ///module
    pub type PWM_INT_CTRL = crate::Reg<pwm_int_ctrl::PWM_INT_CTRL_SPEC>;
    ///RW, PWM interrupt control
    pub mod pwm_int_ctrl {
        ///Register `PWM_INT_CTRL` reader
        pub type R = crate::R<PWM_INT_CTRL_SPEC>;
        ///Register `PWM_INT_CTRL` writer
        pub type W = crate::W<PWM_INT_CTRL_SPEC>;
        ///Field `PWM_IE_CYC` reader - RW, enable interrupt for PWM cycle end
        pub type PWM_IE_CYC_R = crate::BitReader;
        ///Field `PWM_IE_CYC` writer - RW, enable interrupt for PWM cycle end
        pub type PWM_IE_CYC_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PWM_CYC_PRE` reader - RW, select PWM cycle interrupt point
        pub type PWM_CYC_PRE_R = crate::BitReader;
        ///Field `PWM_CYC_PRE` writer - RW, select PWM cycle interrupt point
        pub type PWM_CYC_PRE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PWM_IF_CYC` reader - RW1, interrupt flag for PWM cycle end
        pub type PWM_IF_CYC_R = crate::BitReader;
        ///Field `PWM_IF_CYC` writer - RW1, interrupt flag for PWM cycle end
        pub type PWM_IF_CYC_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - RW, enable interrupt for PWM cycle end
            #[inline(always)]
            pub fn pwm_ie_cyc(&self) -> PWM_IE_CYC_R {
                PWM_IE_CYC_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RW, select PWM cycle interrupt point
            #[inline(always)]
            pub fn pwm_cyc_pre(&self) -> PWM_CYC_PRE_R {
                PWM_CYC_PRE_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 7 - RW1, interrupt flag for PWM cycle end
            #[inline(always)]
            pub fn pwm_if_cyc(&self) -> PWM_IF_CYC_R {
                PWM_IF_CYC_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RW, enable interrupt for PWM cycle end
            #[inline(always)]
            #[must_use]
            pub fn pwm_ie_cyc(&mut self) -> PWM_IE_CYC_W<PWM_INT_CTRL_SPEC> {
                PWM_IE_CYC_W::new(self, 0)
            }
            ///Bit 1 - RW, select PWM cycle interrupt point
            #[inline(always)]
            #[must_use]
            pub fn pwm_cyc_pre(&mut self) -> PWM_CYC_PRE_W<PWM_INT_CTRL_SPEC> {
                PWM_CYC_PRE_W::new(self, 1)
            }
            ///Bit 7 - RW1, interrupt flag for PWM cycle end
            #[inline(always)]
            #[must_use]
            pub fn pwm_if_cyc(&mut self) -> PWM_IF_CYC_W<PWM_INT_CTRL_SPEC> {
                PWM_IF_CYC_W::new(self, 7)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW, PWM interrupt control
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`pwm_int_ctrl::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pwm_int_ctrl::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct PWM_INT_CTRL_SPEC;
        impl crate::RegisterSpec for PWM_INT_CTRL_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`pwm_int_ctrl::R`](R) reader structure
        impl crate::Readable for PWM_INT_CTRL_SPEC {}
        ///`write(|w| ..)` method takes [`pwm_int_ctrl::W`](W) writer structure
        impl crate::Writable for PWM_INT_CTRL_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets PWM_INT_CTRL to value 0
        impl crate::Resettable for PWM_INT_CTRL_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
}
///USB register
pub struct USB {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for USB {}
impl USB {
    ///Pointer to the register block
    pub const PTR: *const usb::RegisterBlock = 0x4000_8000 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const usb::RegisterBlock {
        Self::PTR
    }
    /// Steal an instance of this peripheral
    ///
    /// # Safety
    ///
    /// Ensure that the new instance of the peripheral cannot be used in a way
    /// that may race with any existing instances, for example by only
    /// accessing read-only or write-only registers, or by consuming the
    /// original peripheral and using critical sections to coordinate
    /// access between multiple new instances.
    ///
    /// Additionally, other software such as HALs may rely on only one
    /// peripheral instance existing to ensure memory safety; ensure
    /// no stolen instances are passed to such software.
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for USB {
    type Target = usb::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for USB {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("USB").finish()
    }
}
///USB register
pub mod usb {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        ctrl: CTRL,
        udev_ctrl__r8_uhost_ctrl: UDEV_CTRL__R8_UHOST_CTRL,
        int_en: INT_EN,
        dev_ad: DEV_AD,
        _reserved4: [u8; 0x01],
        mis_st: MIS_ST,
        int_fg: INT_FG,
        int_st: INT_ST,
        rx_len: RX_LEN,
        _reserved8: [u8; 0x03],
        uep4_1_mod: UEP4_1_MOD,
        uep2_3_mod__r8_uh_ep_mod: UEP2_3_MOD__R8_UH_EP_MOD,
        uep567_mod: UEP567_MOD,
        _reserved11: [u8; 0x01],
        uep0_dma: UEP0_DMA,
        _reserved12: [u8; 0x02],
        uep1_dma: UEP1_DMA,
        _reserved13: [u8; 0x02],
        uep2_dma__r16_uh_rx_dma: UEP2_DMA__R16_UH_RX_DMA,
        _reserved14: [u8; 0x02],
        uep3_dma__r16_uh_tx_dma: UEP3_DMA__R16_UH_TX_DMA,
        _reserved15: [u8; 0x02],
        uep0_t_len: UEP0_T_LEN,
        _reserved16: [u8; 0x01],
        uep0_ctrl: UEP0_CTRL,
        _reserved17: [u8; 0x01],
        uep1_t_len: UEP1_T_LEN,
        _reserved18: [u8; 0x01],
        uep1_ctrl__r8_uh_setup: UEP1_CTRL__R8_UH_SETUP,
        _reserved19: [u8; 0x01],
        uep2_t_len_r8_uh_ep_pid: UEP2_T_LEN_R8_UH_EP_PID,
        _reserved20: [u8; 0x01],
        uep2_ctrl_r8_uh_rx_ctrl: UEP2_CTRL_R8_UH_RX_CTRL,
        _reserved21: [u8; 0x01],
        uep3_t_len__r8_uh_tx_len: UEP3_T_LEN__R8_UH_TX_LEN,
        _reserved22: [u8; 0x01],
        uep3_ctrl__r8_uh_tx_ctrl: UEP3_CTRL__R8_UH_TX_CTRL,
        _reserved23: [u8; 0x01],
        uep4_t_len: UEP4_T_LEN,
        _reserved24: [u8; 0x01],
        uep4_ctrl: UEP4_CTRL,
        _reserved25: [u8; 0x21],
        uep5_dma: UEP5_DMA,
        _reserved26: [u8; 0x02],
        uep6_dma: UEP6_DMA,
        _reserved27: [u8; 0x02],
        uep7_dma: UEP7_DMA,
        _reserved28: [u8; 0x06],
        uep5_t_len: UEP5_T_LEN,
        _reserved29: [u8; 0x01],
        uep5_ctrl: UEP5_CTRL,
        _reserved30: [u8; 0x01],
        uep6_t_len: UEP6_T_LEN,
        _reserved31: [u8; 0x01],
        uep6_ctrl: UEP6_CTRL,
        _reserved32: [u8; 0x01],
        uep7_t_len: UEP7_T_LEN,
        _reserved33: [u8; 0x01],
        uep7_ctrl: UEP7_CTRL,
    }
    impl RegisterBlock {
        ///0x00 - USB base control
        #[inline(always)]
        pub const fn ctrl(&self) -> &CTRL {
            &self.ctrl
        }
        ///0x01 - USB device physical prot control
        #[inline(always)]
        pub const fn udev_ctrl__r8_uhost_ctrl(&self) -> &UDEV_CTRL__R8_UHOST_CTRL {
            &self.udev_ctrl__r8_uhost_ctrl
        }
        ///0x02 - USB interrupt enable
        #[inline(always)]
        pub const fn int_en(&self) -> &INT_EN {
            &self.int_en
        }
        ///0x03 - USB device address
        #[inline(always)]
        pub const fn dev_ad(&self) -> &DEV_AD {
            &self.dev_ad
        }
        ///0x05 - USB miscellaneous status
        #[inline(always)]
        pub const fn mis_st(&self) -> &MIS_ST {
            &self.mis_st
        }
        ///0x06 - USB interrupt flag
        #[inline(always)]
        pub const fn int_fg(&self) -> &INT_FG {
            &self.int_fg
        }
        ///0x07 - USB interrupt status
        #[inline(always)]
        pub const fn int_st(&self) -> &INT_ST {
            &self.int_st
        }
        ///0x08 - USB receiving length
        #[inline(always)]
        pub const fn rx_len(&self) -> &RX_LEN {
            &self.rx_len
        }
        ///0x0c - endpoint 4/1 mode
        #[inline(always)]
        pub const fn uep4_1_mod(&self) -> &UEP4_1_MOD {
            &self.uep4_1_mod
        }
        ///0x0d - endpoint 2_3 mode;host endpoint mode
        #[inline(always)]
        pub const fn uep2_3_mod__r8_uh_ep_mod(&self) -> &UEP2_3_MOD__R8_UH_EP_MOD {
            &self.uep2_3_mod__r8_uh_ep_mod
        }
        ///0x0e - endpoint 5/6/7 mode
        #[inline(always)]
        pub const fn uep567_mod(&self) -> &UEP567_MOD {
            &self.uep567_mod
        }
        ///0x10 - endpoint 0 DMA buffer address
        #[inline(always)]
        pub const fn uep0_dma(&self) -> &UEP0_DMA {
            &self.uep0_dma
        }
        ///0x14 - endpoint 1 DMA buffer address
        #[inline(always)]
        pub const fn uep1_dma(&self) -> &UEP1_DMA {
            &self.uep1_dma
        }
        ///0x18 - endpoint 2 DMA buffer address;host rx endpoint buffer high address
        #[inline(always)]
        pub const fn uep2_dma__r16_uh_rx_dma(&self) -> &UEP2_DMA__R16_UH_RX_DMA {
            &self.uep2_dma__r16_uh_rx_dma
        }
        ///0x1c - endpoint 3 DMA buffer address;host tx endpoint buffer high address
        #[inline(always)]
        pub const fn uep3_dma__r16_uh_tx_dma(&self) -> &UEP3_DMA__R16_UH_TX_DMA {
            &self.uep3_dma__r16_uh_tx_dma
        }
        ///0x20 - endpoint 0 transmittal length
        #[inline(always)]
        pub const fn uep0_t_len(&self) -> &UEP0_T_LEN {
            &self.uep0_t_len
        }
        ///0x22 - endpoint 0 control
        #[inline(always)]
        pub const fn uep0_ctrl(&self) -> &UEP0_CTRL {
            &self.uep0_ctrl
        }
        ///0x24 - endpoint 1 transmittal length
        #[inline(always)]
        pub const fn uep1_t_len(&self) -> &UEP1_T_LEN {
            &self.uep1_t_len
        }
        ///0x26 - endpoint 1 control;host aux setup
        #[inline(always)]
        pub const fn uep1_ctrl__r8_uh_setup(&self) -> &UEP1_CTRL__R8_UH_SETUP {
            &self.uep1_ctrl__r8_uh_setup
        }
        ///0x28 - endpoint 2 transmittal length;host endpoint and PID
        #[inline(always)]
        pub const fn uep2_t_len_r8_uh_ep_pid(&self) -> &UEP2_T_LEN_R8_UH_EP_PID {
            &self.uep2_t_len_r8_uh_ep_pid
        }
        ///0x2a - endpoint 2 control;host receiver endpoint control
        #[inline(always)]
        pub const fn uep2_ctrl_r8_uh_rx_ctrl(&self) -> &UEP2_CTRL_R8_UH_RX_CTRL {
            &self.uep2_ctrl_r8_uh_rx_ctrl
        }
        ///0x2c - endpoint 3 transmittal length;host transmittal endpoint transmittal length
        #[inline(always)]
        pub const fn uep3_t_len__r8_uh_tx_len(&self) -> &UEP3_T_LEN__R8_UH_TX_LEN {
            &self.uep3_t_len__r8_uh_tx_len
        }
        ///0x2e - endpoint 3 control;host transmittal endpoint control
        #[inline(always)]
        pub const fn uep3_ctrl__r8_uh_tx_ctrl(&self) -> &UEP3_CTRL__R8_UH_TX_CTRL {
            &self.uep3_ctrl__r8_uh_tx_ctrl
        }
        ///0x30 - endpoint 4 transmittal length
        #[inline(always)]
        pub const fn uep4_t_len(&self) -> &UEP4_T_LEN {
            &self.uep4_t_len
        }
        ///0x32 - endpoint 4 control
        #[inline(always)]
        pub const fn uep4_ctrl(&self) -> &UEP4_CTRL {
            &self.uep4_ctrl
        }
        ///0x54 - endpoint 5 DMA buffer address
        #[inline(always)]
        pub const fn uep5_dma(&self) -> &UEP5_DMA {
            &self.uep5_dma
        }
        ///0x58 - endpoint 6 DMA buffer address
        #[inline(always)]
        pub const fn uep6_dma(&self) -> &UEP6_DMA {
            &self.uep6_dma
        }
        ///0x5c - endpoint 7 DMA buffer address
        #[inline(always)]
        pub const fn uep7_dma(&self) -> &UEP7_DMA {
            &self.uep7_dma
        }
        ///0x64 - endpoint 5 transmittal length
        #[inline(always)]
        pub const fn uep5_t_len(&self) -> &UEP5_T_LEN {
            &self.uep5_t_len
        }
        ///0x66 - endpoint 5 control
        #[inline(always)]
        pub const fn uep5_ctrl(&self) -> &UEP5_CTRL {
            &self.uep5_ctrl
        }
        ///0x68 - endpoint 6 transmittal length
        #[inline(always)]
        pub const fn uep6_t_len(&self) -> &UEP6_T_LEN {
            &self.uep6_t_len
        }
        ///0x6a - endpoint 6 control
        #[inline(always)]
        pub const fn uep6_ctrl(&self) -> &UEP6_CTRL {
            &self.uep6_ctrl
        }
        ///0x6c - endpoint 7 transmittal length
        #[inline(always)]
        pub const fn uep7_t_len(&self) -> &UEP7_T_LEN {
            &self.uep7_t_len
        }
        ///0x6e - endpoint 7 control
        #[inline(always)]
        pub const fn uep7_ctrl(&self) -> &UEP7_CTRL {
            &self.uep7_ctrl
        }
    }
    ///CTRL (rw) register accessor: USB base control
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`ctrl::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ctrl::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@ctrl`]
    ///module
    pub type CTRL = crate::Reg<ctrl::CTRL_SPEC>;
    ///USB base control
    pub mod ctrl {
        ///Register `CTRL` reader
        pub type R = crate::R<CTRL_SPEC>;
        ///Register `CTRL` writer
        pub type W = crate::W<CTRL_SPEC>;
        ///Field `UC_DMA_EN` reader - DMA enable and DMA interrupt enable for USB
        pub type UC_DMA_EN_R = crate::BitReader;
        ///Field `UC_DMA_EN` writer - DMA enable and DMA interrupt enable for USB
        pub type UC_DMA_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UC_CLR_ALL` reader - force clear FIFO and count of USB
        pub type UC_CLR_ALL_R = crate::BitReader;
        ///Field `UC_CLR_ALL` writer - force clear FIFO and count of USB
        pub type UC_CLR_ALL_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UC_RESET_SIE` reader - force reset USB SIE, need software clear
        pub type UC_RESET_SIE_R = crate::BitReader;
        ///Field `UC_RESET_SIE` writer - force reset USB SIE, need software clear
        pub type UC_RESET_SIE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UC_INT_BUSY` reader - enable automatic responding busy for device mode or automatic pause for host mode during interrupt flag UIF_TRANSFER valid
        pub type UC_INT_BUSY_R = crate::BitReader;
        ///Field `UC_INT_BUSY` writer - enable automatic responding busy for device mode or automatic pause for host mode during interrupt flag UIF_TRANSFER valid
        pub type UC_INT_BUSY_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `MASK_UC_SYS_CTRL` reader - bit mask of USB system control
        pub type MASK_UC_SYS_CTRL_R = crate::FieldReader;
        ///Field `MASK_UC_SYS_CTRL` writer - bit mask of USB system control
        pub type MASK_UC_SYS_CTRL_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `UC_DEV_PU_EN` reader - USB device enable and internal pullup resistance enable
        pub type UC_DEV_PU_EN_R = crate::BitReader;
        ///Field `UC_DEV_PU_EN` writer - USB device enable and internal pullup resistance enable
        pub type UC_DEV_PU_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UC_LOW_SPEED` reader - enable USB low speed: 0=12Mbps, 1=1.5Mbps
        pub type UC_LOW_SPEED_R = crate::BitReader;
        ///Field `UC_LOW_SPEED` writer - enable USB low speed: 0=12Mbps, 1=1.5Mbps
        pub type UC_LOW_SPEED_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UC_HOST_MODE` reader - enable USB host mode: 0=device mode, 1=host mode
        pub type UC_HOST_MODE_R = crate::BitReader;
        ///Field `UC_HOST_MODE` writer - enable USB host mode: 0=device mode, 1=host mode
        pub type UC_HOST_MODE_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - DMA enable and DMA interrupt enable for USB
            #[inline(always)]
            pub fn uc_dma_en(&self) -> UC_DMA_EN_R {
                UC_DMA_EN_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - force clear FIFO and count of USB
            #[inline(always)]
            pub fn uc_clr_all(&self) -> UC_CLR_ALL_R {
                UC_CLR_ALL_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - force reset USB SIE, need software clear
            #[inline(always)]
            pub fn uc_reset_sie(&self) -> UC_RESET_SIE_R {
                UC_RESET_SIE_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - enable automatic responding busy for device mode or automatic pause for host mode during interrupt flag UIF_TRANSFER valid
            #[inline(always)]
            pub fn uc_int_busy(&self) -> UC_INT_BUSY_R {
                UC_INT_BUSY_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bits 4:5 - bit mask of USB system control
            #[inline(always)]
            pub fn mask_uc_sys_ctrl(&self) -> MASK_UC_SYS_CTRL_R {
                MASK_UC_SYS_CTRL_R::new((self.bits >> 4) & 3)
            }
            ///Bit 5 - USB device enable and internal pullup resistance enable
            #[inline(always)]
            pub fn uc_dev_pu_en(&self) -> UC_DEV_PU_EN_R {
                UC_DEV_PU_EN_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - enable USB low speed: 0=12Mbps, 1=1.5Mbps
            #[inline(always)]
            pub fn uc_low_speed(&self) -> UC_LOW_SPEED_R {
                UC_LOW_SPEED_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - enable USB host mode: 0=device mode, 1=host mode
            #[inline(always)]
            pub fn uc_host_mode(&self) -> UC_HOST_MODE_R {
                UC_HOST_MODE_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - DMA enable and DMA interrupt enable for USB
            #[inline(always)]
            #[must_use]
            pub fn uc_dma_en(&mut self) -> UC_DMA_EN_W<CTRL_SPEC> {
                UC_DMA_EN_W::new(self, 0)
            }
            ///Bit 1 - force clear FIFO and count of USB
            #[inline(always)]
            #[must_use]
            pub fn uc_clr_all(&mut self) -> UC_CLR_ALL_W<CTRL_SPEC> {
                UC_CLR_ALL_W::new(self, 1)
            }
            ///Bit 2 - force reset USB SIE, need software clear
            #[inline(always)]
            #[must_use]
            pub fn uc_reset_sie(&mut self) -> UC_RESET_SIE_W<CTRL_SPEC> {
                UC_RESET_SIE_W::new(self, 2)
            }
            ///Bit 3 - enable automatic responding busy for device mode or automatic pause for host mode during interrupt flag UIF_TRANSFER valid
            #[inline(always)]
            #[must_use]
            pub fn uc_int_busy(&mut self) -> UC_INT_BUSY_W<CTRL_SPEC> {
                UC_INT_BUSY_W::new(self, 3)
            }
            ///Bits 4:5 - bit mask of USB system control
            #[inline(always)]
            #[must_use]
            pub fn mask_uc_sys_ctrl(&mut self) -> MASK_UC_SYS_CTRL_W<CTRL_SPEC> {
                MASK_UC_SYS_CTRL_W::new(self, 4)
            }
            ///Bit 5 - USB device enable and internal pullup resistance enable
            #[inline(always)]
            #[must_use]
            pub fn uc_dev_pu_en(&mut self) -> UC_DEV_PU_EN_W<CTRL_SPEC> {
                UC_DEV_PU_EN_W::new(self, 5)
            }
            ///Bit 6 - enable USB low speed: 0=12Mbps, 1=1.5Mbps
            #[inline(always)]
            #[must_use]
            pub fn uc_low_speed(&mut self) -> UC_LOW_SPEED_W<CTRL_SPEC> {
                UC_LOW_SPEED_W::new(self, 6)
            }
            ///Bit 7 - enable USB host mode: 0=device mode, 1=host mode
            #[inline(always)]
            #[must_use]
            pub fn uc_host_mode(&mut self) -> UC_HOST_MODE_W<CTRL_SPEC> {
                UC_HOST_MODE_W::new(self, 7)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///USB base control
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`ctrl::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ctrl::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct CTRL_SPEC;
        impl crate::RegisterSpec for CTRL_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`ctrl::R`](R) reader structure
        impl crate::Readable for CTRL_SPEC {}
        ///`write(|w| ..)` method takes [`ctrl::W`](W) writer structure
        impl crate::Writable for CTRL_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets CTRL to value 0x06
        impl crate::Resettable for CTRL_SPEC {
            const RESET_VALUE: u8 = 0x06;
        }
    }
    ///UDEV_CTRL__R8_UHOST_CTRL (rw) register accessor: USB device physical prot control
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`udev_ctrl__r8_uhost_ctrl::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`udev_ctrl__r8_uhost_ctrl::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@udev_ctrl__r8_uhost_ctrl`]
    ///module
    pub type UDEV_CTRL__R8_UHOST_CTRL =
        crate::Reg<udev_ctrl__r8_uhost_ctrl::UDEV_CTRL__R8_UHOST_CTRL_SPEC>;
    ///USB device physical prot control
    pub mod udev_ctrl__r8_uhost_ctrl {
        ///Register `UDEV_CTRL__R8_UHOST_CTRL` reader
        pub type R = crate::R<UDEV_CTRL__R8_UHOST_CTRL_SPEC>;
        ///Register `UDEV_CTRL__R8_UHOST_CTRL` writer
        pub type W = crate::W<UDEV_CTRL__R8_UHOST_CTRL_SPEC>;
        ///Field `UD_PORT_EN__RB_UH_PORT_EN` reader - enable USB physical port I-O: 0=disable, 1=enable;enable USB port: 0=disable, 1=enable port, automatic disabled if USB device detached
        pub type UD_PORT_EN__RB_UH_PORT_EN_R = crate::BitReader;
        ///Field `UD_PORT_EN__RB_UH_PORT_EN` writer - enable USB physical port I-O: 0=disable, 1=enable;enable USB port: 0=disable, 1=enable port, automatic disabled if USB device detached
        pub type UD_PORT_EN__RB_UH_PORT_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UD_GP_BIT__RB_UH_BUS_RESET` reader - general purpose bit;control USB bus reset: 0=normal, 1=force bus reset
        pub type UD_GP_BIT__RB_UH_BUS_RESET_R = crate::BitReader;
        ///Field `UD_GP_BIT__RB_UH_BUS_RESET` writer - general purpose bit;control USB bus reset: 0=normal, 1=force bus reset
        pub type UD_GP_BIT__RB_UH_BUS_RESET_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UD_LOW_SPEED__RB_UH_LOW_SPEED` reader - enable USB physical port low speed: 0=full speed, 1=low speed;enable USB port low speed: 0=full speed, 1=low speed
        pub type UD_LOW_SPEED__RB_UH_LOW_SPEED_R = crate::BitReader;
        ///Field `UD_LOW_SPEED__RB_UH_LOW_SPEED` writer - enable USB physical port low speed: 0=full speed, 1=low speed;enable USB port low speed: 0=full speed, 1=low speed
        pub type UD_LOW_SPEED__RB_UH_LOW_SPEED_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UD_DM_PIN__RB_UH_DM_PIN` reader - ReadOnly: indicate current UDM pin level
        pub type UD_DM_PIN__RB_UH_DM_PIN_R = crate::BitReader;
        ///Field `UD_DP_PIN__RB_UH_DP_PIN` reader - ReadOnly: indicate current UDP pin level
        pub type UD_DP_PIN__RB_UH_DP_PIN_R = crate::BitReader;
        ///Field `UD_PD_DIS__RB_UH_PD_DIS` reader - disable USB UDP-UDM pulldown resistance: 0=enable pulldown, 1=disable
        pub type UD_PD_DIS__RB_UH_PD_DIS_R = crate::BitReader;
        impl R {
            ///Bit 0 - enable USB physical port I-O: 0=disable, 1=enable;enable USB port: 0=disable, 1=enable port, automatic disabled if USB device detached
            #[inline(always)]
            pub fn ud_port_en__rb_uh_port_en(&self) -> UD_PORT_EN__RB_UH_PORT_EN_R {
                UD_PORT_EN__RB_UH_PORT_EN_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - general purpose bit;control USB bus reset: 0=normal, 1=force bus reset
            #[inline(always)]
            pub fn ud_gp_bit__rb_uh_bus_reset(&self) -> UD_GP_BIT__RB_UH_BUS_RESET_R {
                UD_GP_BIT__RB_UH_BUS_RESET_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - enable USB physical port low speed: 0=full speed, 1=low speed;enable USB port low speed: 0=full speed, 1=low speed
            #[inline(always)]
            pub fn ud_low_speed__rb_uh_low_speed(&self) -> UD_LOW_SPEED__RB_UH_LOW_SPEED_R {
                UD_LOW_SPEED__RB_UH_LOW_SPEED_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 4 - ReadOnly: indicate current UDM pin level
            #[inline(always)]
            pub fn ud_dm_pin__rb_uh_dm_pin(&self) -> UD_DM_PIN__RB_UH_DM_PIN_R {
                UD_DM_PIN__RB_UH_DM_PIN_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - ReadOnly: indicate current UDP pin level
            #[inline(always)]
            pub fn ud_dp_pin__rb_uh_dp_pin(&self) -> UD_DP_PIN__RB_UH_DP_PIN_R {
                UD_DP_PIN__RB_UH_DP_PIN_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 7 - disable USB UDP-UDM pulldown resistance: 0=enable pulldown, 1=disable
            #[inline(always)]
            pub fn ud_pd_dis__rb_uh_pd_dis(&self) -> UD_PD_DIS__RB_UH_PD_DIS_R {
                UD_PD_DIS__RB_UH_PD_DIS_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - enable USB physical port I-O: 0=disable, 1=enable;enable USB port: 0=disable, 1=enable port, automatic disabled if USB device detached
            #[inline(always)]
            #[must_use]
            pub fn ud_port_en__rb_uh_port_en(
                &mut self,
            ) -> UD_PORT_EN__RB_UH_PORT_EN_W<UDEV_CTRL__R8_UHOST_CTRL_SPEC> {
                UD_PORT_EN__RB_UH_PORT_EN_W::new(self, 0)
            }
            ///Bit 1 - general purpose bit;control USB bus reset: 0=normal, 1=force bus reset
            #[inline(always)]
            #[must_use]
            pub fn ud_gp_bit__rb_uh_bus_reset(
                &mut self,
            ) -> UD_GP_BIT__RB_UH_BUS_RESET_W<UDEV_CTRL__R8_UHOST_CTRL_SPEC> {
                UD_GP_BIT__RB_UH_BUS_RESET_W::new(self, 1)
            }
            ///Bit 2 - enable USB physical port low speed: 0=full speed, 1=low speed;enable USB port low speed: 0=full speed, 1=low speed
            #[inline(always)]
            #[must_use]
            pub fn ud_low_speed__rb_uh_low_speed(
                &mut self,
            ) -> UD_LOW_SPEED__RB_UH_LOW_SPEED_W<UDEV_CTRL__R8_UHOST_CTRL_SPEC> {
                UD_LOW_SPEED__RB_UH_LOW_SPEED_W::new(self, 2)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///USB device physical prot control
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`udev_ctrl__r8_uhost_ctrl::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`udev_ctrl__r8_uhost_ctrl::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct UDEV_CTRL__R8_UHOST_CTRL_SPEC;
        impl crate::RegisterSpec for UDEV_CTRL__R8_UHOST_CTRL_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`udev_ctrl__r8_uhost_ctrl::R`](R) reader structure
        impl crate::Readable for UDEV_CTRL__R8_UHOST_CTRL_SPEC {}
        ///`write(|w| ..)` method takes [`udev_ctrl__r8_uhost_ctrl::W`](W) writer structure
        impl crate::Writable for UDEV_CTRL__R8_UHOST_CTRL_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets UDEV_CTRL__R8_UHOST_CTRL to value 0
        impl crate::Resettable for UDEV_CTRL__R8_UHOST_CTRL_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///INT_EN (rw) register accessor: USB interrupt enable
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`int_en::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`int_en::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@int_en`]
    ///module
    pub type INT_EN = crate::Reg<int_en::INT_EN_SPEC>;
    ///USB interrupt enable
    pub mod int_en {
        ///Register `INT_EN` reader
        pub type R = crate::R<INT_EN_SPEC>;
        ///Register `INT_EN` writer
        pub type W = crate::W<INT_EN_SPEC>;
        ///Field `UIE_BUS_RST__RB_UIE_DETECT` reader - enable interrupt for USB bus reset event for USB device mode;enable interrupt for USB device detected event for USB host mode
        pub type UIE_BUS_RST__RB_UIE_DETECT_R = crate::BitReader;
        ///Field `UIE_BUS_RST__RB_UIE_DETECT` writer - enable interrupt for USB bus reset event for USB device mode;enable interrupt for USB device detected event for USB host mode
        pub type UIE_BUS_RST__RB_UIE_DETECT_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UIE_TRANSFER` reader - enable interrupt for USB transfer completion
        pub type UIE_TRANSFER_R = crate::BitReader;
        ///Field `UIE_TRANSFER` writer - enable interrupt for USB transfer completion
        pub type UIE_TRANSFER_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UIE_SUSPEND` reader - enable interrupt for USB suspend or resume event
        pub type UIE_SUSPEND_R = crate::BitReader;
        ///Field `UIE_SUSPEND` writer - enable interrupt for USB suspend or resume event
        pub type UIE_SUSPEND_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UIE_HST_SOF` reader - enable interrupt for host SOF timer action for USB host mode
        pub type UIE_HST_SOF_R = crate::BitReader;
        ///Field `UIE_HST_SOF` writer - enable interrupt for host SOF timer action for USB host mode
        pub type UIE_HST_SOF_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UIE_FIFO_OV` reader - enable interrupt for FIFO overflow
        pub type UIE_FIFO_OV_R = crate::BitReader;
        ///Field `UIE_FIFO_OV` writer - enable interrupt for FIFO overflow
        pub type UIE_FIFO_OV_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UIE_DEV_NAK` reader - enable interrupt for NAK responded for USB device mode
        pub type UIE_DEV_NAK_R = crate::BitReader;
        ///Field `UIE_DEV_NAK` writer - enable interrupt for NAK responded for USB device mode
        pub type UIE_DEV_NAK_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UIE_DEV_SOF` reader - enable interrupt for SOF received for USB device mode
        pub type UIE_DEV_SOF_R = crate::BitReader;
        ///Field `UIE_DEV_SOF` writer - enable interrupt for SOF received for USB device mode
        pub type UIE_DEV_SOF_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - enable interrupt for USB bus reset event for USB device mode;enable interrupt for USB device detected event for USB host mode
            #[inline(always)]
            pub fn uie_bus_rst__rb_uie_detect(&self) -> UIE_BUS_RST__RB_UIE_DETECT_R {
                UIE_BUS_RST__RB_UIE_DETECT_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - enable interrupt for USB transfer completion
            #[inline(always)]
            pub fn uie_transfer(&self) -> UIE_TRANSFER_R {
                UIE_TRANSFER_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - enable interrupt for USB suspend or resume event
            #[inline(always)]
            pub fn uie_suspend(&self) -> UIE_SUSPEND_R {
                UIE_SUSPEND_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - enable interrupt for host SOF timer action for USB host mode
            #[inline(always)]
            pub fn uie_hst_sof(&self) -> UIE_HST_SOF_R {
                UIE_HST_SOF_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - enable interrupt for FIFO overflow
            #[inline(always)]
            pub fn uie_fifo_ov(&self) -> UIE_FIFO_OV_R {
                UIE_FIFO_OV_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 6 - enable interrupt for NAK responded for USB device mode
            #[inline(always)]
            pub fn uie_dev_nak(&self) -> UIE_DEV_NAK_R {
                UIE_DEV_NAK_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - enable interrupt for SOF received for USB device mode
            #[inline(always)]
            pub fn uie_dev_sof(&self) -> UIE_DEV_SOF_R {
                UIE_DEV_SOF_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - enable interrupt for USB bus reset event for USB device mode;enable interrupt for USB device detected event for USB host mode
            #[inline(always)]
            #[must_use]
            pub fn uie_bus_rst__rb_uie_detect(
                &mut self,
            ) -> UIE_BUS_RST__RB_UIE_DETECT_W<INT_EN_SPEC> {
                UIE_BUS_RST__RB_UIE_DETECT_W::new(self, 0)
            }
            ///Bit 1 - enable interrupt for USB transfer completion
            #[inline(always)]
            #[must_use]
            pub fn uie_transfer(&mut self) -> UIE_TRANSFER_W<INT_EN_SPEC> {
                UIE_TRANSFER_W::new(self, 1)
            }
            ///Bit 2 - enable interrupt for USB suspend or resume event
            #[inline(always)]
            #[must_use]
            pub fn uie_suspend(&mut self) -> UIE_SUSPEND_W<INT_EN_SPEC> {
                UIE_SUSPEND_W::new(self, 2)
            }
            ///Bit 3 - enable interrupt for host SOF timer action for USB host mode
            #[inline(always)]
            #[must_use]
            pub fn uie_hst_sof(&mut self) -> UIE_HST_SOF_W<INT_EN_SPEC> {
                UIE_HST_SOF_W::new(self, 3)
            }
            ///Bit 4 - enable interrupt for FIFO overflow
            #[inline(always)]
            #[must_use]
            pub fn uie_fifo_ov(&mut self) -> UIE_FIFO_OV_W<INT_EN_SPEC> {
                UIE_FIFO_OV_W::new(self, 4)
            }
            ///Bit 6 - enable interrupt for NAK responded for USB device mode
            #[inline(always)]
            #[must_use]
            pub fn uie_dev_nak(&mut self) -> UIE_DEV_NAK_W<INT_EN_SPEC> {
                UIE_DEV_NAK_W::new(self, 6)
            }
            ///Bit 7 - enable interrupt for SOF received for USB device mode
            #[inline(always)]
            #[must_use]
            pub fn uie_dev_sof(&mut self) -> UIE_DEV_SOF_W<INT_EN_SPEC> {
                UIE_DEV_SOF_W::new(self, 7)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///USB interrupt enable
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`int_en::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`int_en::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct INT_EN_SPEC;
        impl crate::RegisterSpec for INT_EN_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`int_en::R`](R) reader structure
        impl crate::Readable for INT_EN_SPEC {}
        ///`write(|w| ..)` method takes [`int_en::W`](W) writer structure
        impl crate::Writable for INT_EN_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets INT_EN to value 0
        impl crate::Resettable for INT_EN_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///DEV_AD (rw) register accessor: USB device address
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`dev_ad::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dev_ad::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@dev_ad`]
    ///module
    pub type DEV_AD = crate::Reg<dev_ad::DEV_AD_SPEC>;
    ///USB device address
    pub mod dev_ad {
        ///Register `DEV_AD` reader
        pub type R = crate::R<DEV_AD_SPEC>;
        ///Register `DEV_AD` writer
        pub type W = crate::W<DEV_AD_SPEC>;
        ///Field `MASK_USB_ADDR` reader - bit mask for USB device address
        pub type MASK_USB_ADDR_R = crate::FieldReader;
        ///Field `MASK_USB_ADDR` writer - bit mask for USB device address
        pub type MASK_USB_ADDR_W<'a, REG> = crate::FieldWriter<'a, REG, 7>;
        ///Field `UDA_GP_BIT` reader - general purpose bit
        pub type UDA_GP_BIT_R = crate::BitReader;
        ///Field `UDA_GP_BIT` writer - general purpose bit
        pub type UDA_GP_BIT_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bits 0:6 - bit mask for USB device address
            #[inline(always)]
            pub fn mask_usb_addr(&self) -> MASK_USB_ADDR_R {
                MASK_USB_ADDR_R::new(self.bits & 0x7f)
            }
            ///Bit 7 - general purpose bit
            #[inline(always)]
            pub fn uda_gp_bit(&self) -> UDA_GP_BIT_R {
                UDA_GP_BIT_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:6 - bit mask for USB device address
            #[inline(always)]
            #[must_use]
            pub fn mask_usb_addr(&mut self) -> MASK_USB_ADDR_W<DEV_AD_SPEC> {
                MASK_USB_ADDR_W::new(self, 0)
            }
            ///Bit 7 - general purpose bit
            #[inline(always)]
            #[must_use]
            pub fn uda_gp_bit(&mut self) -> UDA_GP_BIT_W<DEV_AD_SPEC> {
                UDA_GP_BIT_W::new(self, 7)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///USB device address
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`dev_ad::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dev_ad::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct DEV_AD_SPEC;
        impl crate::RegisterSpec for DEV_AD_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`dev_ad::R`](R) reader structure
        impl crate::Readable for DEV_AD_SPEC {}
        ///`write(|w| ..)` method takes [`dev_ad::W`](W) writer structure
        impl crate::Writable for DEV_AD_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets DEV_AD to value 0
        impl crate::Resettable for DEV_AD_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///MIS_ST (r) register accessor: USB miscellaneous status
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`mis_st::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@mis_st`]
    ///module
    pub type MIS_ST = crate::Reg<mis_st::MIS_ST_SPEC>;
    ///USB miscellaneous status
    pub mod mis_st {
        ///Register `MIS_ST` reader
        pub type R = crate::R<MIS_ST_SPEC>;
        ///Field `UMS_DEV_ATTACH` reader - RO, indicate device attached status on USB host
        pub type UMS_DEV_ATTACH_R = crate::BitReader;
        ///Field `UMS_DM_LEVEL` reader - RO, indicate UDM level saved at device attached to USB host
        pub type UMS_DM_LEVEL_R = crate::BitReader;
        ///Field `UMS_SUSPEND` reader - RO, indicate USB suspend status
        pub type UMS_SUSPEND_R = crate::BitReader;
        ///Field `UMS_BUS_RESET` reader - RO, indicate USB bus reset status
        pub type UMS_BUS_RESET_R = crate::BitReader;
        ///Field `UMS_R_FIFO_RDY` reader - RO, indicate USB receiving FIFO ready status (not empty)
        pub type UMS_R_FIFO_RDY_R = crate::BitReader;
        ///Field `UMS_SIE_FREE` reader - RO, indicate USB SIE free status
        pub type UMS_SIE_FREE_R = crate::BitReader;
        ///Field `UMS_SOF_ACT` reader - RO, indicate host SOF timer action status for USB host
        pub type UMS_SOF_ACT_R = crate::BitReader;
        ///Field `UMS_SOF_PRES` reader - RO, indicate host SOF timer presage status
        pub type UMS_SOF_PRES_R = crate::BitReader;
        impl R {
            ///Bit 0 - RO, indicate device attached status on USB host
            #[inline(always)]
            pub fn ums_dev_attach(&self) -> UMS_DEV_ATTACH_R {
                UMS_DEV_ATTACH_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RO, indicate UDM level saved at device attached to USB host
            #[inline(always)]
            pub fn ums_dm_level(&self) -> UMS_DM_LEVEL_R {
                UMS_DM_LEVEL_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RO, indicate USB suspend status
            #[inline(always)]
            pub fn ums_suspend(&self) -> UMS_SUSPEND_R {
                UMS_SUSPEND_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RO, indicate USB bus reset status
            #[inline(always)]
            pub fn ums_bus_reset(&self) -> UMS_BUS_RESET_R {
                UMS_BUS_RESET_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RO, indicate USB receiving FIFO ready status (not empty)
            #[inline(always)]
            pub fn ums_r_fifo_rdy(&self) -> UMS_R_FIFO_RDY_R {
                UMS_R_FIFO_RDY_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - RO, indicate USB SIE free status
            #[inline(always)]
            pub fn ums_sie_free(&self) -> UMS_SIE_FREE_R {
                UMS_SIE_FREE_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - RO, indicate host SOF timer action status for USB host
            #[inline(always)]
            pub fn ums_sof_act(&self) -> UMS_SOF_ACT_R {
                UMS_SOF_ACT_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - RO, indicate host SOF timer presage status
            #[inline(always)]
            pub fn ums_sof_pres(&self) -> UMS_SOF_PRES_R {
                UMS_SOF_PRES_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        ///USB miscellaneous status
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`mis_st::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct MIS_ST_SPEC;
        impl crate::RegisterSpec for MIS_ST_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`mis_st::R`](R) reader structure
        impl crate::Readable for MIS_ST_SPEC {}
        ///`reset()` method sets MIS_ST to value 0
        impl crate::Resettable for MIS_ST_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///INT_FG (rw) register accessor: USB interrupt flag
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`int_fg::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`int_fg::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@int_fg`]
    ///module
    pub type INT_FG = crate::Reg<int_fg::INT_FG_SPEC>;
    ///USB interrupt flag
    pub mod int_fg {
        ///Register `INT_FG` reader
        pub type R = crate::R<INT_FG_SPEC>;
        ///Register `INT_FG` writer
        pub type W = crate::W<INT_FG_SPEC>;
        ///Field `UIF_BUS_RST__RB_UIF_DETECT` reader - RW,bus reset event interrupt flag for USB device mode, direct bit address clear or write 1 to clear;device detected event interrupt flag for USB host mode, direct bit address clear or write 1 to clear
        pub type UIF_BUS_RST__RB_UIF_DETECT_R = crate::BitReader;
        ///Field `UIF_BUS_RST__RB_UIF_DETECT` writer - RW,bus reset event interrupt flag for USB device mode, direct bit address clear or write 1 to clear;device detected event interrupt flag for USB host mode, direct bit address clear or write 1 to clear
        pub type UIF_BUS_RST__RB_UIF_DETECT_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UIF_TRANSFER` reader - RW,USB transfer completion interrupt flag, direct bit address clear or write 1 to clear
        pub type UIF_TRANSFER_R = crate::BitReader;
        ///Field `UIF_TRANSFER` writer - RW,USB transfer completion interrupt flag, direct bit address clear or write 1 to clear
        pub type UIF_TRANSFER_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UIF_SUSPEND` reader - RW,USB suspend or resume event interrupt flag, direct bit address clear or write 1 to clear
        pub type UIF_SUSPEND_R = crate::BitReader;
        ///Field `UIF_SUSPEND` writer - RW,USB suspend or resume event interrupt flag, direct bit address clear or write 1 to clear
        pub type UIF_SUSPEND_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UIF_HST_SOF` reader - RW,host SOF timer interrupt flag for USB host, direct bit address clear or write 1 to clear
        pub type UIF_HST_SOF_R = crate::BitReader;
        ///Field `UIF_HST_SOF` writer - RW,host SOF timer interrupt flag for USB host, direct bit address clear or write 1 to clear
        pub type UIF_HST_SOF_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UIF_FIFO_OV` reader - RW,FIFO overflow interrupt flag for USB, direct bit address clear or write 1 to clear
        pub type UIF_FIFO_OV_R = crate::BitReader;
        ///Field `UIF_FIFO_OV` writer - RW,FIFO overflow interrupt flag for USB, direct bit address clear or write 1 to clear
        pub type UIF_FIFO_OV_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `U_SIE_FREE` reader - RO, indicate USB SIE free status
        pub type U_SIE_FREE_R = crate::BitReader;
        ///Field `U_TOG_OK` reader - RO, indicate current USB transfer toggle is OK
        pub type U_TOG_OK_R = crate::BitReader;
        ///Field `U_IS_NAK` reader - RO, indicate current USB transfer is NAK received
        pub type U_IS_NAK_R = crate::BitReader;
        impl R {
            ///Bit 0 - RW,bus reset event interrupt flag for USB device mode, direct bit address clear or write 1 to clear;device detected event interrupt flag for USB host mode, direct bit address clear or write 1 to clear
            #[inline(always)]
            pub fn uif_bus_rst__rb_uif_detect(&self) -> UIF_BUS_RST__RB_UIF_DETECT_R {
                UIF_BUS_RST__RB_UIF_DETECT_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RW,USB transfer completion interrupt flag, direct bit address clear or write 1 to clear
            #[inline(always)]
            pub fn uif_transfer(&self) -> UIF_TRANSFER_R {
                UIF_TRANSFER_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RW,USB suspend or resume event interrupt flag, direct bit address clear or write 1 to clear
            #[inline(always)]
            pub fn uif_suspend(&self) -> UIF_SUSPEND_R {
                UIF_SUSPEND_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RW,host SOF timer interrupt flag for USB host, direct bit address clear or write 1 to clear
            #[inline(always)]
            pub fn uif_hst_sof(&self) -> UIF_HST_SOF_R {
                UIF_HST_SOF_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RW,FIFO overflow interrupt flag for USB, direct bit address clear or write 1 to clear
            #[inline(always)]
            pub fn uif_fifo_ov(&self) -> UIF_FIFO_OV_R {
                UIF_FIFO_OV_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - RO, indicate USB SIE free status
            #[inline(always)]
            pub fn u_sie_free(&self) -> U_SIE_FREE_R {
                U_SIE_FREE_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - RO, indicate current USB transfer toggle is OK
            #[inline(always)]
            pub fn u_tog_ok(&self) -> U_TOG_OK_R {
                U_TOG_OK_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - RO, indicate current USB transfer is NAK received
            #[inline(always)]
            pub fn u_is_nak(&self) -> U_IS_NAK_R {
                U_IS_NAK_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RW,bus reset event interrupt flag for USB device mode, direct bit address clear or write 1 to clear;device detected event interrupt flag for USB host mode, direct bit address clear or write 1 to clear
            #[inline(always)]
            #[must_use]
            pub fn uif_bus_rst__rb_uif_detect(
                &mut self,
            ) -> UIF_BUS_RST__RB_UIF_DETECT_W<INT_FG_SPEC> {
                UIF_BUS_RST__RB_UIF_DETECT_W::new(self, 0)
            }
            ///Bit 1 - RW,USB transfer completion interrupt flag, direct bit address clear or write 1 to clear
            #[inline(always)]
            #[must_use]
            pub fn uif_transfer(&mut self) -> UIF_TRANSFER_W<INT_FG_SPEC> {
                UIF_TRANSFER_W::new(self, 1)
            }
            ///Bit 2 - RW,USB suspend or resume event interrupt flag, direct bit address clear or write 1 to clear
            #[inline(always)]
            #[must_use]
            pub fn uif_suspend(&mut self) -> UIF_SUSPEND_W<INT_FG_SPEC> {
                UIF_SUSPEND_W::new(self, 2)
            }
            ///Bit 3 - RW,host SOF timer interrupt flag for USB host, direct bit address clear or write 1 to clear
            #[inline(always)]
            #[must_use]
            pub fn uif_hst_sof(&mut self) -> UIF_HST_SOF_W<INT_FG_SPEC> {
                UIF_HST_SOF_W::new(self, 3)
            }
            ///Bit 4 - RW,FIFO overflow interrupt flag for USB, direct bit address clear or write 1 to clear
            #[inline(always)]
            #[must_use]
            pub fn uif_fifo_ov(&mut self) -> UIF_FIFO_OV_W<INT_FG_SPEC> {
                UIF_FIFO_OV_W::new(self, 4)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///USB interrupt flag
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`int_fg::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`int_fg::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct INT_FG_SPEC;
        impl crate::RegisterSpec for INT_FG_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`int_fg::R`](R) reader structure
        impl crate::Readable for INT_FG_SPEC {}
        ///`write(|w| ..)` method takes [`int_fg::W`](W) writer structure
        impl crate::Writable for INT_FG_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets INT_FG to value 0x20
        impl crate::Resettable for INT_FG_SPEC {
            const RESET_VALUE: u8 = 0x20;
        }
    }
    ///INT_ST (r) register accessor: USB interrupt status
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`int_st::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@int_st`]
    ///module
    pub type INT_ST = crate::Reg<int_st::INT_ST_SPEC>;
    ///USB interrupt status
    pub mod int_st {
        ///Register `INT_ST` reader
        pub type R = crate::R<INT_ST_SPEC>;
        ///Field `MASK_UIS_H_RES__MASK_UIS_ENDP` reader - RO, bit mask of current transfer handshake response for USB host mode: 0000=no response, time out from device, others=handshake response PID received;RO, bit mask of current transfer endpoint number for USB device mode
        pub type MASK_UIS_H_RES__MASK_UIS_ENDP_R = crate::FieldReader;
        ///Field `MASK_UIS_TOKEN` reader - RO, bit mask of current token PID code received for USB device mode
        pub type MASK_UIS_TOKEN_R = crate::FieldReader;
        ///Field `UIS_TOG_OK` reader - RO, indicate current USB transfer toggle is OK
        pub type UIS_TOG_OK_R = crate::BitReader;
        ///Field `UIS_SETUP_ACT` reader - RO, indicate current USB transfer is NAK received for USB device mode
        pub type UIS_SETUP_ACT_R = crate::BitReader;
        impl R {
            ///Bits 0:3 - RO, bit mask of current transfer handshake response for USB host mode: 0000=no response, time out from device, others=handshake response PID received;RO, bit mask of current transfer endpoint number for USB device mode
            #[inline(always)]
            pub fn mask_uis_h_res__mask_uis_endp(&self) -> MASK_UIS_H_RES__MASK_UIS_ENDP_R {
                MASK_UIS_H_RES__MASK_UIS_ENDP_R::new(self.bits & 0x0f)
            }
            ///Bits 4:5 - RO, bit mask of current token PID code received for USB device mode
            #[inline(always)]
            pub fn mask_uis_token(&self) -> MASK_UIS_TOKEN_R {
                MASK_UIS_TOKEN_R::new((self.bits >> 4) & 3)
            }
            ///Bit 6 - RO, indicate current USB transfer toggle is OK
            #[inline(always)]
            pub fn uis_tog_ok(&self) -> UIS_TOG_OK_R {
                UIS_TOG_OK_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - RO, indicate current USB transfer is NAK received for USB device mode
            #[inline(always)]
            pub fn uis_setup_act(&self) -> UIS_SETUP_ACT_R {
                UIS_SETUP_ACT_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        ///USB interrupt status
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`int_st::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct INT_ST_SPEC;
        impl crate::RegisterSpec for INT_ST_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`int_st::R`](R) reader structure
        impl crate::Readable for INT_ST_SPEC {}
        ///`reset()` method sets INT_ST to value 0
        impl crate::Resettable for INT_ST_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///RX_LEN (r) register accessor: USB receiving length
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`rx_len::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@rx_len`]
    ///module
    pub type RX_LEN = crate::Reg<rx_len::RX_LEN_SPEC>;
    ///USB receiving length
    pub mod rx_len {
        ///Register `RX_LEN` reader
        pub type R = crate::R<RX_LEN_SPEC>;
        ///Field `USB_RX_LEN` reader - RO,USB receiving length
        pub type USB_RX_LEN_R = crate::FieldReader;
        impl R {
            ///Bits 0:7 - RO,USB receiving length
            #[inline(always)]
            pub fn usb_rx_len(&self) -> USB_RX_LEN_R {
                USB_RX_LEN_R::new(self.bits)
            }
        }
        ///USB receiving length
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`rx_len::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct RX_LEN_SPEC;
        impl crate::RegisterSpec for RX_LEN_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`rx_len::R`](R) reader structure
        impl crate::Readable for RX_LEN_SPEC {}
        ///`reset()` method sets RX_LEN to value 0
        impl crate::Resettable for RX_LEN_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///UEP4_1_MOD (rw) register accessor: endpoint 4/1 mode
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`uep4_1_mod::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep4_1_mod::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@uep4_1_mod`]
    ///module
    pub type UEP4_1_MOD = crate::Reg<uep4_1_mod::UEP4_1_MOD_SPEC>;
    ///endpoint 4/1 mode
    pub mod uep4_1_mod {
        ///Register `UEP4_1_MOD` reader
        pub type R = crate::R<UEP4_1_MOD_SPEC>;
        ///Register `UEP4_1_MOD` writer
        pub type W = crate::W<UEP4_1_MOD_SPEC>;
        ///Field `UEP4_TX_EN` reader - enable USB endpoint 4 transmittal (IN)
        pub type UEP4_TX_EN_R = crate::BitReader;
        ///Field `UEP4_TX_EN` writer - enable USB endpoint 4 transmittal (IN)
        pub type UEP4_TX_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UEP4_RX_EN` reader - enable USB endpoint 4 receiving (OUT)
        pub type UEP4_RX_EN_R = crate::BitReader;
        ///Field `UEP4_RX_EN` writer - enable USB endpoint 4 receiving (OUT)
        pub type UEP4_RX_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UEP1_BUF_MOD` reader - buffer mode of USB endpoint 1
        pub type UEP1_BUF_MOD_R = crate::BitReader;
        ///Field `UEP1_BUF_MOD` writer - buffer mode of USB endpoint 1
        pub type UEP1_BUF_MOD_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UEP1_TX_EN` reader - enable USB endpoint 1 transmittal (IN)
        pub type UEP1_TX_EN_R = crate::BitReader;
        ///Field `UEP1_TX_EN` writer - enable USB endpoint 1 transmittal (IN)
        pub type UEP1_TX_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UEP1_RX_EN` reader - enable USB endpoint 1 receiving (OUT)
        pub type UEP1_RX_EN_R = crate::BitReader;
        ///Field `UEP1_RX_EN` writer - enable USB endpoint 1 receiving (OUT)
        pub type UEP1_RX_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 2 - enable USB endpoint 4 transmittal (IN)
            #[inline(always)]
            pub fn uep4_tx_en(&self) -> UEP4_TX_EN_R {
                UEP4_TX_EN_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - enable USB endpoint 4 receiving (OUT)
            #[inline(always)]
            pub fn uep4_rx_en(&self) -> UEP4_RX_EN_R {
                UEP4_RX_EN_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - buffer mode of USB endpoint 1
            #[inline(always)]
            pub fn uep1_buf_mod(&self) -> UEP1_BUF_MOD_R {
                UEP1_BUF_MOD_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 6 - enable USB endpoint 1 transmittal (IN)
            #[inline(always)]
            pub fn uep1_tx_en(&self) -> UEP1_TX_EN_R {
                UEP1_TX_EN_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - enable USB endpoint 1 receiving (OUT)
            #[inline(always)]
            pub fn uep1_rx_en(&self) -> UEP1_RX_EN_R {
                UEP1_RX_EN_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 2 - enable USB endpoint 4 transmittal (IN)
            #[inline(always)]
            #[must_use]
            pub fn uep4_tx_en(&mut self) -> UEP4_TX_EN_W<UEP4_1_MOD_SPEC> {
                UEP4_TX_EN_W::new(self, 2)
            }
            ///Bit 3 - enable USB endpoint 4 receiving (OUT)
            #[inline(always)]
            #[must_use]
            pub fn uep4_rx_en(&mut self) -> UEP4_RX_EN_W<UEP4_1_MOD_SPEC> {
                UEP4_RX_EN_W::new(self, 3)
            }
            ///Bit 4 - buffer mode of USB endpoint 1
            #[inline(always)]
            #[must_use]
            pub fn uep1_buf_mod(&mut self) -> UEP1_BUF_MOD_W<UEP4_1_MOD_SPEC> {
                UEP1_BUF_MOD_W::new(self, 4)
            }
            ///Bit 6 - enable USB endpoint 1 transmittal (IN)
            #[inline(always)]
            #[must_use]
            pub fn uep1_tx_en(&mut self) -> UEP1_TX_EN_W<UEP4_1_MOD_SPEC> {
                UEP1_TX_EN_W::new(self, 6)
            }
            ///Bit 7 - enable USB endpoint 1 receiving (OUT)
            #[inline(always)]
            #[must_use]
            pub fn uep1_rx_en(&mut self) -> UEP1_RX_EN_W<UEP4_1_MOD_SPEC> {
                UEP1_RX_EN_W::new(self, 7)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///endpoint 4/1 mode
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`uep4_1_mod::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep4_1_mod::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct UEP4_1_MOD_SPEC;
        impl crate::RegisterSpec for UEP4_1_MOD_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`uep4_1_mod::R`](R) reader structure
        impl crate::Readable for UEP4_1_MOD_SPEC {}
        ///`write(|w| ..)` method takes [`uep4_1_mod::W`](W) writer structure
        impl crate::Writable for UEP4_1_MOD_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets UEP4_1_MOD to value 0
        impl crate::Resettable for UEP4_1_MOD_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///UEP2_3_MOD__R8_UH_EP_MOD (rw) register accessor: endpoint 2_3 mode;host endpoint mode
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`uep2_3_mod__r8_uh_ep_mod::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep2_3_mod__r8_uh_ep_mod::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@uep2_3_mod__r8_uh_ep_mod`]
    ///module
    pub type UEP2_3_MOD__R8_UH_EP_MOD =
        crate::Reg<uep2_3_mod__r8_uh_ep_mod::UEP2_3_MOD__R8_UH_EP_MOD_SPEC>;
    ///endpoint 2_3 mode;host endpoint mode
    pub mod uep2_3_mod__r8_uh_ep_mod {
        ///Register `UEP2_3_MOD__R8_UH_EP_MOD` reader
        pub type R = crate::R<UEP2_3_MOD__R8_UH_EP_MOD_SPEC>;
        ///Register `UEP2_3_MOD__R8_UH_EP_MOD` writer
        pub type W = crate::W<UEP2_3_MOD__R8_UH_EP_MOD_SPEC>;
        ///Field `UEP2_BUF_MOD__RB_UH_EP_RBUF_MOD` reader - buffer mode of USB endpoint 2;buffer mode of USB host IN endpoint
        pub type UEP2_BUF_MOD__RB_UH_EP_RBUF_MOD_R = crate::BitReader;
        ///Field `UEP2_BUF_MOD__RB_UH_EP_RBUF_MOD` writer - buffer mode of USB endpoint 2;buffer mode of USB host IN endpoint
        pub type UEP2_BUF_MOD__RB_UH_EP_RBUF_MOD_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UEP2_TX_EN` reader - enable USB endpoint 2 transmittal (IN)
        pub type UEP2_TX_EN_R = crate::BitReader;
        ///Field `UEP2_TX_EN` writer - enable USB endpoint 2 transmittal (IN)
        pub type UEP2_TX_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UEP2_RX_EN__RB_UH_EP_RX_EN` reader - enable USB endpoint 2 receiving (OUT);enable USB host IN endpoint receiving
        pub type UEP2_RX_EN__RB_UH_EP_RX_EN_R = crate::BitReader;
        ///Field `UEP2_RX_EN__RB_UH_EP_RX_EN` writer - enable USB endpoint 2 receiving (OUT);enable USB host IN endpoint receiving
        pub type UEP2_RX_EN__RB_UH_EP_RX_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UEP3_BUF_MOD__RB_UH_EP_TBUF_MOD` reader - buffer mode of USB endpoint 3;buffer mode of USB host OUT endpoint
        pub type UEP3_BUF_MOD__RB_UH_EP_TBUF_MOD_R = crate::BitReader;
        ///Field `UEP3_BUF_MOD__RB_UH_EP_TBUF_MOD` writer - buffer mode of USB endpoint 3;buffer mode of USB host OUT endpoint
        pub type UEP3_BUF_MOD__RB_UH_EP_TBUF_MOD_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UEP3_TX_EN__RB_UH_EP_TX_EN` reader - enable USB endpoint 3 transmittal (IN);enable USB host OUT endpoint transmittal
        pub type UEP3_TX_EN__RB_UH_EP_TX_EN_R = crate::BitReader;
        ///Field `UEP3_TX_EN__RB_UH_EP_TX_EN` writer - enable USB endpoint 3 transmittal (IN);enable USB host OUT endpoint transmittal
        pub type UEP3_TX_EN__RB_UH_EP_TX_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UEP3_RX_EN` reader - enable USB endpoint 3 receiving (OUT)
        pub type UEP3_RX_EN_R = crate::BitReader;
        ///Field `UEP3_RX_EN` writer - enable USB endpoint 3 receiving (OUT)
        pub type UEP3_RX_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - buffer mode of USB endpoint 2;buffer mode of USB host IN endpoint
            #[inline(always)]
            pub fn uep2_buf_mod__rb_uh_ep_rbuf_mod(&self) -> UEP2_BUF_MOD__RB_UH_EP_RBUF_MOD_R {
                UEP2_BUF_MOD__RB_UH_EP_RBUF_MOD_R::new((self.bits & 1) != 0)
            }
            ///Bit 2 - enable USB endpoint 2 transmittal (IN)
            #[inline(always)]
            pub fn uep2_tx_en(&self) -> UEP2_TX_EN_R {
                UEP2_TX_EN_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - enable USB endpoint 2 receiving (OUT);enable USB host IN endpoint receiving
            #[inline(always)]
            pub fn uep2_rx_en__rb_uh_ep_rx_en(&self) -> UEP2_RX_EN__RB_UH_EP_RX_EN_R {
                UEP2_RX_EN__RB_UH_EP_RX_EN_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - buffer mode of USB endpoint 3;buffer mode of USB host OUT endpoint
            #[inline(always)]
            pub fn uep3_buf_mod__rb_uh_ep_tbuf_mod(&self) -> UEP3_BUF_MOD__RB_UH_EP_TBUF_MOD_R {
                UEP3_BUF_MOD__RB_UH_EP_TBUF_MOD_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 6 - enable USB endpoint 3 transmittal (IN);enable USB host OUT endpoint transmittal
            #[inline(always)]
            pub fn uep3_tx_en__rb_uh_ep_tx_en(&self) -> UEP3_TX_EN__RB_UH_EP_TX_EN_R {
                UEP3_TX_EN__RB_UH_EP_TX_EN_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - enable USB endpoint 3 receiving (OUT)
            #[inline(always)]
            pub fn uep3_rx_en(&self) -> UEP3_RX_EN_R {
                UEP3_RX_EN_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - buffer mode of USB endpoint 2;buffer mode of USB host IN endpoint
            #[inline(always)]
            #[must_use]
            pub fn uep2_buf_mod__rb_uh_ep_rbuf_mod(
                &mut self,
            ) -> UEP2_BUF_MOD__RB_UH_EP_RBUF_MOD_W<UEP2_3_MOD__R8_UH_EP_MOD_SPEC> {
                UEP2_BUF_MOD__RB_UH_EP_RBUF_MOD_W::new(self, 0)
            }
            ///Bit 2 - enable USB endpoint 2 transmittal (IN)
            #[inline(always)]
            #[must_use]
            pub fn uep2_tx_en(&mut self) -> UEP2_TX_EN_W<UEP2_3_MOD__R8_UH_EP_MOD_SPEC> {
                UEP2_TX_EN_W::new(self, 2)
            }
            ///Bit 3 - enable USB endpoint 2 receiving (OUT);enable USB host IN endpoint receiving
            #[inline(always)]
            #[must_use]
            pub fn uep2_rx_en__rb_uh_ep_rx_en(
                &mut self,
            ) -> UEP2_RX_EN__RB_UH_EP_RX_EN_W<UEP2_3_MOD__R8_UH_EP_MOD_SPEC> {
                UEP2_RX_EN__RB_UH_EP_RX_EN_W::new(self, 3)
            }
            ///Bit 4 - buffer mode of USB endpoint 3;buffer mode of USB host OUT endpoint
            #[inline(always)]
            #[must_use]
            pub fn uep3_buf_mod__rb_uh_ep_tbuf_mod(
                &mut self,
            ) -> UEP3_BUF_MOD__RB_UH_EP_TBUF_MOD_W<UEP2_3_MOD__R8_UH_EP_MOD_SPEC> {
                UEP3_BUF_MOD__RB_UH_EP_TBUF_MOD_W::new(self, 4)
            }
            ///Bit 6 - enable USB endpoint 3 transmittal (IN);enable USB host OUT endpoint transmittal
            #[inline(always)]
            #[must_use]
            pub fn uep3_tx_en__rb_uh_ep_tx_en(
                &mut self,
            ) -> UEP3_TX_EN__RB_UH_EP_TX_EN_W<UEP2_3_MOD__R8_UH_EP_MOD_SPEC> {
                UEP3_TX_EN__RB_UH_EP_TX_EN_W::new(self, 6)
            }
            ///Bit 7 - enable USB endpoint 3 receiving (OUT)
            #[inline(always)]
            #[must_use]
            pub fn uep3_rx_en(&mut self) -> UEP3_RX_EN_W<UEP2_3_MOD__R8_UH_EP_MOD_SPEC> {
                UEP3_RX_EN_W::new(self, 7)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///endpoint 2_3 mode;host endpoint mode
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`uep2_3_mod__r8_uh_ep_mod::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep2_3_mod__r8_uh_ep_mod::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct UEP2_3_MOD__R8_UH_EP_MOD_SPEC;
        impl crate::RegisterSpec for UEP2_3_MOD__R8_UH_EP_MOD_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`uep2_3_mod__r8_uh_ep_mod::R`](R) reader structure
        impl crate::Readable for UEP2_3_MOD__R8_UH_EP_MOD_SPEC {}
        ///`write(|w| ..)` method takes [`uep2_3_mod__r8_uh_ep_mod::W`](W) writer structure
        impl crate::Writable for UEP2_3_MOD__R8_UH_EP_MOD_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets UEP2_3_MOD__R8_UH_EP_MOD to value 0
        impl crate::Resettable for UEP2_3_MOD__R8_UH_EP_MOD_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///UEP567_MOD (rw) register accessor: endpoint 5/6/7 mode
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`uep567_mod::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep567_mod::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@uep567_mod`]
    ///module
    pub type UEP567_MOD = crate::Reg<uep567_mod::UEP567_MOD_SPEC>;
    ///endpoint 5/6/7 mode
    pub mod uep567_mod {
        ///Register `UEP567_MOD` reader
        pub type R = crate::R<UEP567_MOD_SPEC>;
        ///Register `UEP567_MOD` writer
        pub type W = crate::W<UEP567_MOD_SPEC>;
        ///Field `UEP5_TX_EN` reader - enable USB endpoint 5 transmittal (IN)
        pub type UEP5_TX_EN_R = crate::BitReader;
        ///Field `UEP5_TX_EN` writer - enable USB endpoint 5 transmittal (IN)
        pub type UEP5_TX_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UEP5_RX_EN` reader - enable USB endpoint 5 receiving (OUT)
        pub type UEP5_RX_EN_R = crate::BitReader;
        ///Field `UEP5_RX_EN` writer - enable USB endpoint 5 receiving (OUT)
        pub type UEP5_RX_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UEP6_TX_EN` reader - enable USB endpoint 6 transmittal (IN)
        pub type UEP6_TX_EN_R = crate::BitReader;
        ///Field `UEP6_TX_EN` writer - enable USB endpoint 6 transmittal (IN)
        pub type UEP6_TX_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UEP6_RX_EN` reader - enable USB endpoint 6 receiving (OUT)
        pub type UEP6_RX_EN_R = crate::BitReader;
        ///Field `UEP6_RX_EN` writer - enable USB endpoint 6 receiving (OUT)
        pub type UEP6_RX_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UEP7_TX_EN` reader - enable USB endpoint 7 transmittal (IN)
        pub type UEP7_TX_EN_R = crate::BitReader;
        ///Field `UEP7_TX_EN` writer - enable USB endpoint 7 transmittal (IN)
        pub type UEP7_TX_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UEP7_RX_EN` reader - enable USB endpoint 7 receiving (OUT)
        pub type UEP7_RX_EN_R = crate::BitReader;
        ///Field `UEP7_RX_EN` writer - enable USB endpoint 7 receiving (OUT)
        pub type UEP7_RX_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - enable USB endpoint 5 transmittal (IN)
            #[inline(always)]
            pub fn uep5_tx_en(&self) -> UEP5_TX_EN_R {
                UEP5_TX_EN_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - enable USB endpoint 5 receiving (OUT)
            #[inline(always)]
            pub fn uep5_rx_en(&self) -> UEP5_RX_EN_R {
                UEP5_RX_EN_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - enable USB endpoint 6 transmittal (IN)
            #[inline(always)]
            pub fn uep6_tx_en(&self) -> UEP6_TX_EN_R {
                UEP6_TX_EN_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - enable USB endpoint 6 receiving (OUT)
            #[inline(always)]
            pub fn uep6_rx_en(&self) -> UEP6_RX_EN_R {
                UEP6_RX_EN_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - enable USB endpoint 7 transmittal (IN)
            #[inline(always)]
            pub fn uep7_tx_en(&self) -> UEP7_TX_EN_R {
                UEP7_TX_EN_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - enable USB endpoint 7 receiving (OUT)
            #[inline(always)]
            pub fn uep7_rx_en(&self) -> UEP7_RX_EN_R {
                UEP7_RX_EN_R::new(((self.bits >> 5) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - enable USB endpoint 5 transmittal (IN)
            #[inline(always)]
            #[must_use]
            pub fn uep5_tx_en(&mut self) -> UEP5_TX_EN_W<UEP567_MOD_SPEC> {
                UEP5_TX_EN_W::new(self, 0)
            }
            ///Bit 1 - enable USB endpoint 5 receiving (OUT)
            #[inline(always)]
            #[must_use]
            pub fn uep5_rx_en(&mut self) -> UEP5_RX_EN_W<UEP567_MOD_SPEC> {
                UEP5_RX_EN_W::new(self, 1)
            }
            ///Bit 2 - enable USB endpoint 6 transmittal (IN)
            #[inline(always)]
            #[must_use]
            pub fn uep6_tx_en(&mut self) -> UEP6_TX_EN_W<UEP567_MOD_SPEC> {
                UEP6_TX_EN_W::new(self, 2)
            }
            ///Bit 3 - enable USB endpoint 6 receiving (OUT)
            #[inline(always)]
            #[must_use]
            pub fn uep6_rx_en(&mut self) -> UEP6_RX_EN_W<UEP567_MOD_SPEC> {
                UEP6_RX_EN_W::new(self, 3)
            }
            ///Bit 4 - enable USB endpoint 7 transmittal (IN)
            #[inline(always)]
            #[must_use]
            pub fn uep7_tx_en(&mut self) -> UEP7_TX_EN_W<UEP567_MOD_SPEC> {
                UEP7_TX_EN_W::new(self, 4)
            }
            ///Bit 5 - enable USB endpoint 7 receiving (OUT)
            #[inline(always)]
            #[must_use]
            pub fn uep7_rx_en(&mut self) -> UEP7_RX_EN_W<UEP567_MOD_SPEC> {
                UEP7_RX_EN_W::new(self, 5)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///endpoint 5/6/7 mode
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`uep567_mod::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep567_mod::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct UEP567_MOD_SPEC;
        impl crate::RegisterSpec for UEP567_MOD_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`uep567_mod::R`](R) reader structure
        impl crate::Readable for UEP567_MOD_SPEC {}
        ///`write(|w| ..)` method takes [`uep567_mod::W`](W) writer structure
        impl crate::Writable for UEP567_MOD_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets UEP567_MOD to value 0
        impl crate::Resettable for UEP567_MOD_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///UEP0_DMA (rw) register accessor: endpoint 0 DMA buffer address
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`uep0_dma::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep0_dma::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@uep0_dma`]
    ///module
    pub type UEP0_DMA = crate::Reg<uep0_dma::UEP0_DMA_SPEC>;
    ///endpoint 0 DMA buffer address
    pub mod uep0_dma {
        ///Register `UEP0_DMA` reader
        pub type R = crate::R<UEP0_DMA_SPEC>;
        ///Register `UEP0_DMA` writer
        pub type W = crate::W<UEP0_DMA_SPEC>;
        ///Field `UEP0_DMA` reader - RW,endpoint 0 DMA buffer address
        pub type UEP0_DMA_R = crate::FieldReader<u16>;
        ///Field `UEP0_DMA` writer - RW,endpoint 0 DMA buffer address
        pub type UEP0_DMA_W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            ///Bits 0:15 - RW,endpoint 0 DMA buffer address
            #[inline(always)]
            pub fn uep0_dma(&self) -> UEP0_DMA_R {
                UEP0_DMA_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - RW,endpoint 0 DMA buffer address
            #[inline(always)]
            #[must_use]
            pub fn uep0_dma(&mut self) -> UEP0_DMA_W<UEP0_DMA_SPEC> {
                UEP0_DMA_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///endpoint 0 DMA buffer address
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`uep0_dma::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep0_dma::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct UEP0_DMA_SPEC;
        impl crate::RegisterSpec for UEP0_DMA_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`uep0_dma::R`](R) reader structure
        impl crate::Readable for UEP0_DMA_SPEC {}
        ///`write(|w| ..)` method takes [`uep0_dma::W`](W) writer structure
        impl crate::Writable for UEP0_DMA_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets UEP0_DMA to value 0
        impl crate::Resettable for UEP0_DMA_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///UEP1_DMA (rw) register accessor: endpoint 1 DMA buffer address
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`uep1_dma::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep1_dma::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@uep1_dma`]
    ///module
    pub type UEP1_DMA = crate::Reg<uep1_dma::UEP1_DMA_SPEC>;
    ///endpoint 1 DMA buffer address
    pub mod uep1_dma {
        ///Register `UEP1_DMA` reader
        pub type R = crate::R<UEP1_DMA_SPEC>;
        ///Register `UEP1_DMA` writer
        pub type W = crate::W<UEP1_DMA_SPEC>;
        ///Field `UEP1_DMA` reader - RW,endpoint 1 DMA buffer address
        pub type UEP1_DMA_R = crate::FieldReader<u16>;
        ///Field `UEP1_DMA` writer - RW,endpoint 1 DMA buffer address
        pub type UEP1_DMA_W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            ///Bits 0:15 - RW,endpoint 1 DMA buffer address
            #[inline(always)]
            pub fn uep1_dma(&self) -> UEP1_DMA_R {
                UEP1_DMA_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - RW,endpoint 1 DMA buffer address
            #[inline(always)]
            #[must_use]
            pub fn uep1_dma(&mut self) -> UEP1_DMA_W<UEP1_DMA_SPEC> {
                UEP1_DMA_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///endpoint 1 DMA buffer address
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`uep1_dma::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep1_dma::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct UEP1_DMA_SPEC;
        impl crate::RegisterSpec for UEP1_DMA_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`uep1_dma::R`](R) reader structure
        impl crate::Readable for UEP1_DMA_SPEC {}
        ///`write(|w| ..)` method takes [`uep1_dma::W`](W) writer structure
        impl crate::Writable for UEP1_DMA_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets UEP1_DMA to value 0
        impl crate::Resettable for UEP1_DMA_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///UEP2_DMA__R16_UH_RX_DMA (rw) register accessor: endpoint 2 DMA buffer address;host rx endpoint buffer high address
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`uep2_dma__r16_uh_rx_dma::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep2_dma__r16_uh_rx_dma::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@uep2_dma__r16_uh_rx_dma`]
    ///module
    pub type UEP2_DMA__R16_UH_RX_DMA =
        crate::Reg<uep2_dma__r16_uh_rx_dma::UEP2_DMA__R16_UH_RX_DMA_SPEC>;
    ///endpoint 2 DMA buffer address;host rx endpoint buffer high address
    pub mod uep2_dma__r16_uh_rx_dma {
        ///Register `UEP2_DMA__R16_UH_RX_DMA` reader
        pub type R = crate::R<UEP2_DMA__R16_UH_RX_DMA_SPEC>;
        ///Register `UEP2_DMA__R16_UH_RX_DMA` writer
        pub type W = crate::W<UEP2_DMA__R16_UH_RX_DMA_SPEC>;
        ///Field `UEP2_DMA` reader - RW,endpoint 2 DMA buffer address;host rx endpoint buffer high address
        pub type UEP2_DMA_R = crate::FieldReader<u16>;
        ///Field `UEP2_DMA` writer - RW,endpoint 2 DMA buffer address;host rx endpoint buffer high address
        pub type UEP2_DMA_W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            ///Bits 0:15 - RW,endpoint 2 DMA buffer address;host rx endpoint buffer high address
            #[inline(always)]
            pub fn uep2_dma(&self) -> UEP2_DMA_R {
                UEP2_DMA_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - RW,endpoint 2 DMA buffer address;host rx endpoint buffer high address
            #[inline(always)]
            #[must_use]
            pub fn uep2_dma(&mut self) -> UEP2_DMA_W<UEP2_DMA__R16_UH_RX_DMA_SPEC> {
                UEP2_DMA_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///endpoint 2 DMA buffer address;host rx endpoint buffer high address
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`uep2_dma__r16_uh_rx_dma::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep2_dma__r16_uh_rx_dma::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct UEP2_DMA__R16_UH_RX_DMA_SPEC;
        impl crate::RegisterSpec for UEP2_DMA__R16_UH_RX_DMA_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`uep2_dma__r16_uh_rx_dma::R`](R) reader structure
        impl crate::Readable for UEP2_DMA__R16_UH_RX_DMA_SPEC {}
        ///`write(|w| ..)` method takes [`uep2_dma__r16_uh_rx_dma::W`](W) writer structure
        impl crate::Writable for UEP2_DMA__R16_UH_RX_DMA_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets UEP2_DMA__R16_UH_RX_DMA to value 0
        impl crate::Resettable for UEP2_DMA__R16_UH_RX_DMA_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///UEP3_DMA__R16_UH_TX_DMA (rw) register accessor: endpoint 3 DMA buffer address;host tx endpoint buffer high address
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`uep3_dma__r16_uh_tx_dma::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep3_dma__r16_uh_tx_dma::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@uep3_dma__r16_uh_tx_dma`]
    ///module
    pub type UEP3_DMA__R16_UH_TX_DMA =
        crate::Reg<uep3_dma__r16_uh_tx_dma::UEP3_DMA__R16_UH_TX_DMA_SPEC>;
    ///endpoint 3 DMA buffer address;host tx endpoint buffer high address
    pub mod uep3_dma__r16_uh_tx_dma {
        ///Register `UEP3_DMA__R16_UH_TX_DMA` reader
        pub type R = crate::R<UEP3_DMA__R16_UH_TX_DMA_SPEC>;
        ///Register `UEP3_DMA__R16_UH_TX_DMA` writer
        pub type W = crate::W<UEP3_DMA__R16_UH_TX_DMA_SPEC>;
        ///Field `UEP3_DMA` reader - RW,endpoint 3 DMA buffer address;host rx endpoint buffer high address
        pub type UEP3_DMA_R = crate::FieldReader<u16>;
        ///Field `UEP3_DMA` writer - RW,endpoint 3 DMA buffer address;host rx endpoint buffer high address
        pub type UEP3_DMA_W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            ///Bits 0:15 - RW,endpoint 3 DMA buffer address;host rx endpoint buffer high address
            #[inline(always)]
            pub fn uep3_dma(&self) -> UEP3_DMA_R {
                UEP3_DMA_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - RW,endpoint 3 DMA buffer address;host rx endpoint buffer high address
            #[inline(always)]
            #[must_use]
            pub fn uep3_dma(&mut self) -> UEP3_DMA_W<UEP3_DMA__R16_UH_TX_DMA_SPEC> {
                UEP3_DMA_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///endpoint 3 DMA buffer address;host tx endpoint buffer high address
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`uep3_dma__r16_uh_tx_dma::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep3_dma__r16_uh_tx_dma::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct UEP3_DMA__R16_UH_TX_DMA_SPEC;
        impl crate::RegisterSpec for UEP3_DMA__R16_UH_TX_DMA_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`uep3_dma__r16_uh_tx_dma::R`](R) reader structure
        impl crate::Readable for UEP3_DMA__R16_UH_TX_DMA_SPEC {}
        ///`write(|w| ..)` method takes [`uep3_dma__r16_uh_tx_dma::W`](W) writer structure
        impl crate::Writable for UEP3_DMA__R16_UH_TX_DMA_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets UEP3_DMA__R16_UH_TX_DMA to value 0
        impl crate::Resettable for UEP3_DMA__R16_UH_TX_DMA_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///UEP5_DMA (rw) register accessor: endpoint 5 DMA buffer address
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`uep5_dma::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep5_dma::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@uep5_dma`]
    ///module
    pub type UEP5_DMA = crate::Reg<uep5_dma::UEP5_DMA_SPEC>;
    ///endpoint 5 DMA buffer address
    pub mod uep5_dma {
        ///Register `UEP5_DMA` reader
        pub type R = crate::R<UEP5_DMA_SPEC>;
        ///Register `UEP5_DMA` writer
        pub type W = crate::W<UEP5_DMA_SPEC>;
        ///Field `UEP5_DMA` reader - RW,endpoint 5 DMA buffer address;host rx endpoint buffer high address
        pub type UEP5_DMA_R = crate::FieldReader<u16>;
        ///Field `UEP5_DMA` writer - RW,endpoint 5 DMA buffer address;host rx endpoint buffer high address
        pub type UEP5_DMA_W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            ///Bits 0:15 - RW,endpoint 5 DMA buffer address;host rx endpoint buffer high address
            #[inline(always)]
            pub fn uep5_dma(&self) -> UEP5_DMA_R {
                UEP5_DMA_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - RW,endpoint 5 DMA buffer address;host rx endpoint buffer high address
            #[inline(always)]
            #[must_use]
            pub fn uep5_dma(&mut self) -> UEP5_DMA_W<UEP5_DMA_SPEC> {
                UEP5_DMA_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///endpoint 5 DMA buffer address
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`uep5_dma::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep5_dma::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct UEP5_DMA_SPEC;
        impl crate::RegisterSpec for UEP5_DMA_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`uep5_dma::R`](R) reader structure
        impl crate::Readable for UEP5_DMA_SPEC {}
        ///`write(|w| ..)` method takes [`uep5_dma::W`](W) writer structure
        impl crate::Writable for UEP5_DMA_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets UEP5_DMA to value 0
        impl crate::Resettable for UEP5_DMA_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///UEP6_DMA (rw) register accessor: endpoint 6 DMA buffer address
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`uep6_dma::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep6_dma::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@uep6_dma`]
    ///module
    pub type UEP6_DMA = crate::Reg<uep6_dma::UEP6_DMA_SPEC>;
    ///endpoint 6 DMA buffer address
    pub mod uep6_dma {
        ///Register `UEP6_DMA` reader
        pub type R = crate::R<UEP6_DMA_SPEC>;
        ///Register `UEP6_DMA` writer
        pub type W = crate::W<UEP6_DMA_SPEC>;
        ///Field `UEP6_DMA` reader - RW,endpoint 6 DMA buffer address;host rx endpoint buffer high address
        pub type UEP6_DMA_R = crate::FieldReader<u16>;
        ///Field `UEP6_DMA` writer - RW,endpoint 6 DMA buffer address;host rx endpoint buffer high address
        pub type UEP6_DMA_W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            ///Bits 0:15 - RW,endpoint 6 DMA buffer address;host rx endpoint buffer high address
            #[inline(always)]
            pub fn uep6_dma(&self) -> UEP6_DMA_R {
                UEP6_DMA_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - RW,endpoint 6 DMA buffer address;host rx endpoint buffer high address
            #[inline(always)]
            #[must_use]
            pub fn uep6_dma(&mut self) -> UEP6_DMA_W<UEP6_DMA_SPEC> {
                UEP6_DMA_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///endpoint 6 DMA buffer address
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`uep6_dma::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep6_dma::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct UEP6_DMA_SPEC;
        impl crate::RegisterSpec for UEP6_DMA_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`uep6_dma::R`](R) reader structure
        impl crate::Readable for UEP6_DMA_SPEC {}
        ///`write(|w| ..)` method takes [`uep6_dma::W`](W) writer structure
        impl crate::Writable for UEP6_DMA_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets UEP6_DMA to value 0
        impl crate::Resettable for UEP6_DMA_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///UEP7_DMA (rw) register accessor: endpoint 7 DMA buffer address
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`uep7_dma::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep7_dma::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@uep7_dma`]
    ///module
    pub type UEP7_DMA = crate::Reg<uep7_dma::UEP7_DMA_SPEC>;
    ///endpoint 7 DMA buffer address
    pub mod uep7_dma {
        ///Register `UEP7_DMA` reader
        pub type R = crate::R<UEP7_DMA_SPEC>;
        ///Register `UEP7_DMA` writer
        pub type W = crate::W<UEP7_DMA_SPEC>;
        ///Field `UEP7_DMA` reader - RW,endpoint 7 DMA buffer address;host rx endpoint buffer high address
        pub type UEP7_DMA_R = crate::FieldReader<u16>;
        ///Field `UEP7_DMA` writer - RW,endpoint 7 DMA buffer address;host rx endpoint buffer high address
        pub type UEP7_DMA_W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            ///Bits 0:15 - RW,endpoint 7 DMA buffer address;host rx endpoint buffer high address
            #[inline(always)]
            pub fn uep7_dma(&self) -> UEP7_DMA_R {
                UEP7_DMA_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - RW,endpoint 7 DMA buffer address;host rx endpoint buffer high address
            #[inline(always)]
            #[must_use]
            pub fn uep7_dma(&mut self) -> UEP7_DMA_W<UEP7_DMA_SPEC> {
                UEP7_DMA_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///endpoint 7 DMA buffer address
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`uep7_dma::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep7_dma::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct UEP7_DMA_SPEC;
        impl crate::RegisterSpec for UEP7_DMA_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`uep7_dma::R`](R) reader structure
        impl crate::Readable for UEP7_DMA_SPEC {}
        ///`write(|w| ..)` method takes [`uep7_dma::W`](W) writer structure
        impl crate::Writable for UEP7_DMA_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets UEP7_DMA to value 0
        impl crate::Resettable for UEP7_DMA_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///UEP0_T_LEN (rw) register accessor: endpoint 0 transmittal length
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`uep0_t_len::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep0_t_len::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@uep0_t_len`]
    ///module
    pub type UEP0_T_LEN = crate::Reg<uep0_t_len::UEP0_T_LEN_SPEC>;
    ///endpoint 0 transmittal length
    pub mod uep0_t_len {
        ///Register `UEP0_T_LEN` reader
        pub type R = crate::R<UEP0_T_LEN_SPEC>;
        ///Register `UEP0_T_LEN` writer
        pub type W = crate::W<UEP0_T_LEN_SPEC>;
        ///Field `UEP0_T_LEN` reader - endpoint 0 transmittal length
        pub type UEP0_T_LEN_R = crate::FieldReader;
        ///Field `UEP0_T_LEN` writer - endpoint 0 transmittal length
        pub type UEP0_T_LEN_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            ///Bits 0:7 - endpoint 0 transmittal length
            #[inline(always)]
            pub fn uep0_t_len(&self) -> UEP0_T_LEN_R {
                UEP0_T_LEN_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:7 - endpoint 0 transmittal length
            #[inline(always)]
            #[must_use]
            pub fn uep0_t_len(&mut self) -> UEP0_T_LEN_W<UEP0_T_LEN_SPEC> {
                UEP0_T_LEN_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///endpoint 0 transmittal length
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`uep0_t_len::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep0_t_len::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct UEP0_T_LEN_SPEC;
        impl crate::RegisterSpec for UEP0_T_LEN_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`uep0_t_len::R`](R) reader structure
        impl crate::Readable for UEP0_T_LEN_SPEC {}
        ///`write(|w| ..)` method takes [`uep0_t_len::W`](W) writer structure
        impl crate::Writable for UEP0_T_LEN_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets UEP0_T_LEN to value 0
        impl crate::Resettable for UEP0_T_LEN_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///UEP0_CTRL (rw) register accessor: endpoint 0 control
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`uep0_ctrl::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep0_ctrl::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@uep0_ctrl`]
    ///module
    pub type UEP0_CTRL = crate::Reg<uep0_ctrl::UEP0_CTRL_SPEC>;
    ///endpoint 0 control
    pub mod uep0_ctrl {
        ///Register `UEP0_CTRL` reader
        pub type R = crate::R<UEP0_CTRL_SPEC>;
        ///Register `UEP0_CTRL` writer
        pub type W = crate::W<UEP0_CTRL_SPEC>;
        ///Field `MASK_UEP_T_RES` reader - bit mask of handshake response type for USB endpoint X transmittal (IN)
        pub type MASK_UEP_T_RES_R = crate::FieldReader;
        ///Field `MASK_UEP_T_RES` writer - bit mask of handshake response type for USB endpoint X transmittal (IN)
        pub type MASK_UEP_T_RES_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `MASK_UEP_R_RES` reader - bit mask of handshake response type for USB endpoint X receiving (OUT)
        pub type MASK_UEP_R_RES_R = crate::FieldReader;
        ///Field `MASK_UEP_R_RES` writer - bit mask of handshake response type for USB endpoint X receiving (OUT)
        pub type MASK_UEP_R_RES_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `UEP_AUTO_TOG` reader - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
        pub type UEP_AUTO_TOG_R = crate::BitReader;
        ///Field `UEP_AUTO_TOG` writer - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
        pub type UEP_AUTO_TOG_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UEP_T_TOG` reader - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
        pub type UEP_T_TOG_R = crate::BitReader;
        ///Field `UEP_T_TOG` writer - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
        pub type UEP_T_TOG_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UEP_R_TOG` reader - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
        pub type UEP_R_TOG_R = crate::BitReader;
        ///Field `UEP_R_TOG` writer - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
        pub type UEP_R_TOG_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)
            #[inline(always)]
            pub fn mask_uep_t_res(&self) -> MASK_UEP_T_RES_R {
                MASK_UEP_T_RES_R::new(self.bits & 3)
            }
            ///Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)
            #[inline(always)]
            pub fn mask_uep_r_res(&self) -> MASK_UEP_R_RES_R {
                MASK_UEP_R_RES_R::new((self.bits >> 2) & 3)
            }
            ///Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
            #[inline(always)]
            pub fn uep_auto_tog(&self) -> UEP_AUTO_TOG_R {
                UEP_AUTO_TOG_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
            #[inline(always)]
            pub fn uep_t_tog(&self) -> UEP_T_TOG_R {
                UEP_T_TOG_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
            #[inline(always)]
            pub fn uep_r_tog(&self) -> UEP_R_TOG_R {
                UEP_R_TOG_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)
            #[inline(always)]
            #[must_use]
            pub fn mask_uep_t_res(&mut self) -> MASK_UEP_T_RES_W<UEP0_CTRL_SPEC> {
                MASK_UEP_T_RES_W::new(self, 0)
            }
            ///Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)
            #[inline(always)]
            #[must_use]
            pub fn mask_uep_r_res(&mut self) -> MASK_UEP_R_RES_W<UEP0_CTRL_SPEC> {
                MASK_UEP_R_RES_W::new(self, 2)
            }
            ///Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
            #[inline(always)]
            #[must_use]
            pub fn uep_auto_tog(&mut self) -> UEP_AUTO_TOG_W<UEP0_CTRL_SPEC> {
                UEP_AUTO_TOG_W::new(self, 4)
            }
            ///Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
            #[inline(always)]
            #[must_use]
            pub fn uep_t_tog(&mut self) -> UEP_T_TOG_W<UEP0_CTRL_SPEC> {
                UEP_T_TOG_W::new(self, 6)
            }
            ///Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
            #[inline(always)]
            #[must_use]
            pub fn uep_r_tog(&mut self) -> UEP_R_TOG_W<UEP0_CTRL_SPEC> {
                UEP_R_TOG_W::new(self, 7)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///endpoint 0 control
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`uep0_ctrl::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep0_ctrl::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct UEP0_CTRL_SPEC;
        impl crate::RegisterSpec for UEP0_CTRL_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`uep0_ctrl::R`](R) reader structure
        impl crate::Readable for UEP0_CTRL_SPEC {}
        ///`write(|w| ..)` method takes [`uep0_ctrl::W`](W) writer structure
        impl crate::Writable for UEP0_CTRL_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets UEP0_CTRL to value 0
        impl crate::Resettable for UEP0_CTRL_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///UEP1_T_LEN (rw) register accessor: endpoint 1 transmittal length
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`uep1_t_len::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep1_t_len::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@uep1_t_len`]
    ///module
    pub type UEP1_T_LEN = crate::Reg<uep1_t_len::UEP1_T_LEN_SPEC>;
    ///endpoint 1 transmittal length
    pub mod uep1_t_len {
        ///Register `UEP1_T_LEN` reader
        pub type R = crate::R<UEP1_T_LEN_SPEC>;
        ///Register `UEP1_T_LEN` writer
        pub type W = crate::W<UEP1_T_LEN_SPEC>;
        ///Field `UEP1_T_LEN` reader - endpoint 1 transmittal length
        pub type UEP1_T_LEN_R = crate::FieldReader;
        ///Field `UEP1_T_LEN` writer - endpoint 1 transmittal length
        pub type UEP1_T_LEN_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            ///Bits 0:7 - endpoint 1 transmittal length
            #[inline(always)]
            pub fn uep1_t_len(&self) -> UEP1_T_LEN_R {
                UEP1_T_LEN_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:7 - endpoint 1 transmittal length
            #[inline(always)]
            #[must_use]
            pub fn uep1_t_len(&mut self) -> UEP1_T_LEN_W<UEP1_T_LEN_SPEC> {
                UEP1_T_LEN_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///endpoint 1 transmittal length
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`uep1_t_len::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep1_t_len::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct UEP1_T_LEN_SPEC;
        impl crate::RegisterSpec for UEP1_T_LEN_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`uep1_t_len::R`](R) reader structure
        impl crate::Readable for UEP1_T_LEN_SPEC {}
        ///`write(|w| ..)` method takes [`uep1_t_len::W`](W) writer structure
        impl crate::Writable for UEP1_T_LEN_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets UEP1_T_LEN to value 0
        impl crate::Resettable for UEP1_T_LEN_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///UEP1_CTRL__R8_UH_SETUP (rw) register accessor: endpoint 1 control;host aux setup
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`uep1_ctrl__r8_uh_setup::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep1_ctrl__r8_uh_setup::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@uep1_ctrl__r8_uh_setup`]
    ///module
    pub type UEP1_CTRL__R8_UH_SETUP =
        crate::Reg<uep1_ctrl__r8_uh_setup::UEP1_CTRL__R8_UH_SETUP_SPEC>;
    ///endpoint 1 control;host aux setup
    pub mod uep1_ctrl__r8_uh_setup {
        ///Register `UEP1_CTRL__R8_UH_SETUP` reader
        pub type R = crate::R<UEP1_CTRL__R8_UH_SETUP_SPEC>;
        ///Register `UEP1_CTRL__R8_UH_SETUP` writer
        pub type W = crate::W<UEP1_CTRL__R8_UH_SETUP_SPEC>;
        ///Field `MASK_UEP_T_RES` reader - bit mask of handshake response type for USB endpoint X transmittal (IN)
        pub type MASK_UEP_T_RES_R = crate::FieldReader;
        ///Field `MASK_UEP_T_RES` writer - bit mask of handshake response type for USB endpoint X transmittal (IN)
        pub type MASK_UEP_T_RES_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `MASK_UEP_R_RES` reader - bit mask of handshake response type for USB endpoint X receiving (OUT)
        pub type MASK_UEP_R_RES_R = crate::FieldReader;
        ///Field `MASK_UEP_R_RES` writer - bit mask of handshake response type for USB endpoint X receiving (OUT)
        pub type MASK_UEP_R_RES_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `UEP_AUTO_TOG` reader - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
        pub type UEP_AUTO_TOG_R = crate::BitReader;
        ///Field `UEP_AUTO_TOG` writer - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
        pub type UEP_AUTO_TOG_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UEP_T_TOG__RB_UH_SOF_EN` reader - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1;USB host automatic SOF enable
        pub type UEP_T_TOG__RB_UH_SOF_EN_R = crate::BitReader;
        ///Field `UEP_T_TOG__RB_UH_SOF_EN` writer - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1;USB host automatic SOF enable
        pub type UEP_T_TOG__RB_UH_SOF_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UEP_R_TOG__RB_UH_PRE_PID_EN` reader - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1;RB_UH_PRE_PID_EN;USB host PRE PID enable for low speed device via hub
        pub type UEP_R_TOG__RB_UH_PRE_PID_EN_R = crate::BitReader;
        ///Field `UEP_R_TOG__RB_UH_PRE_PID_EN` writer - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1;RB_UH_PRE_PID_EN;USB host PRE PID enable for low speed device via hub
        pub type UEP_R_TOG__RB_UH_PRE_PID_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)
            #[inline(always)]
            pub fn mask_uep_t_res(&self) -> MASK_UEP_T_RES_R {
                MASK_UEP_T_RES_R::new(self.bits & 3)
            }
            ///Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)
            #[inline(always)]
            pub fn mask_uep_r_res(&self) -> MASK_UEP_R_RES_R {
                MASK_UEP_R_RES_R::new((self.bits >> 2) & 3)
            }
            ///Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
            #[inline(always)]
            pub fn uep_auto_tog(&self) -> UEP_AUTO_TOG_R {
                UEP_AUTO_TOG_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1;USB host automatic SOF enable
            #[inline(always)]
            pub fn uep_t_tog__rb_uh_sof_en(&self) -> UEP_T_TOG__RB_UH_SOF_EN_R {
                UEP_T_TOG__RB_UH_SOF_EN_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1;RB_UH_PRE_PID_EN;USB host PRE PID enable for low speed device via hub
            #[inline(always)]
            pub fn uep_r_tog__rb_uh_pre_pid_en(&self) -> UEP_R_TOG__RB_UH_PRE_PID_EN_R {
                UEP_R_TOG__RB_UH_PRE_PID_EN_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)
            #[inline(always)]
            #[must_use]
            pub fn mask_uep_t_res(&mut self) -> MASK_UEP_T_RES_W<UEP1_CTRL__R8_UH_SETUP_SPEC> {
                MASK_UEP_T_RES_W::new(self, 0)
            }
            ///Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)
            #[inline(always)]
            #[must_use]
            pub fn mask_uep_r_res(&mut self) -> MASK_UEP_R_RES_W<UEP1_CTRL__R8_UH_SETUP_SPEC> {
                MASK_UEP_R_RES_W::new(self, 2)
            }
            ///Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
            #[inline(always)]
            #[must_use]
            pub fn uep_auto_tog(&mut self) -> UEP_AUTO_TOG_W<UEP1_CTRL__R8_UH_SETUP_SPEC> {
                UEP_AUTO_TOG_W::new(self, 4)
            }
            ///Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1;USB host automatic SOF enable
            #[inline(always)]
            #[must_use]
            pub fn uep_t_tog__rb_uh_sof_en(
                &mut self,
            ) -> UEP_T_TOG__RB_UH_SOF_EN_W<UEP1_CTRL__R8_UH_SETUP_SPEC> {
                UEP_T_TOG__RB_UH_SOF_EN_W::new(self, 6)
            }
            ///Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1;RB_UH_PRE_PID_EN;USB host PRE PID enable for low speed device via hub
            #[inline(always)]
            #[must_use]
            pub fn uep_r_tog__rb_uh_pre_pid_en(
                &mut self,
            ) -> UEP_R_TOG__RB_UH_PRE_PID_EN_W<UEP1_CTRL__R8_UH_SETUP_SPEC> {
                UEP_R_TOG__RB_UH_PRE_PID_EN_W::new(self, 7)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///endpoint 1 control;host aux setup
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`uep1_ctrl__r8_uh_setup::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep1_ctrl__r8_uh_setup::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct UEP1_CTRL__R8_UH_SETUP_SPEC;
        impl crate::RegisterSpec for UEP1_CTRL__R8_UH_SETUP_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`uep1_ctrl__r8_uh_setup::R`](R) reader structure
        impl crate::Readable for UEP1_CTRL__R8_UH_SETUP_SPEC {}
        ///`write(|w| ..)` method takes [`uep1_ctrl__r8_uh_setup::W`](W) writer structure
        impl crate::Writable for UEP1_CTRL__R8_UH_SETUP_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets UEP1_CTRL__R8_UH_SETUP to value 0
        impl crate::Resettable for UEP1_CTRL__R8_UH_SETUP_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///UEP2_T_LEN_R8_UH_EP_PID (rw) register accessor: endpoint 2 transmittal length;host endpoint and PID
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`uep2_t_len_r8_uh_ep_pid::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep2_t_len_r8_uh_ep_pid::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@uep2_t_len_r8_uh_ep_pid`]
    ///module
    pub type UEP2_T_LEN_R8_UH_EP_PID =
        crate::Reg<uep2_t_len_r8_uh_ep_pid::UEP2_T_LEN_R8_UH_EP_PID_SPEC>;
    ///endpoint 2 transmittal length;host endpoint and PID
    pub mod uep2_t_len_r8_uh_ep_pid {
        ///Register `UEP2_T_LEN_R8_UH_EP_PID` reader
        pub type R = crate::R<UEP2_T_LEN_R8_UH_EP_PID_SPEC>;
        ///Register `UEP2_T_LEN_R8_UH_EP_PID` writer
        pub type W = crate::W<UEP2_T_LEN_R8_UH_EP_PID_SPEC>;
        ///Field `MASK_UH_ENDP` reader - bit mask of endpoint number for USB host transfer
        pub type MASK_UH_ENDP_R = crate::FieldReader;
        ///Field `MASK_UH_ENDP` writer - bit mask of endpoint number for USB host transfer
        pub type MASK_UH_ENDP_W<'a, REG> = crate::FieldWriter<'a, REG, 4>;
        ///Field `UEP2_T_LEN` reader - endpoint 2 transmittal length;
        pub type UEP2_T_LEN_R = crate::FieldReader;
        ///Field `UEP2_T_LEN` writer - endpoint 2 transmittal length;
        pub type UEP2_T_LEN_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        ///Field `MASK_UH_TOKEN` reader - bit mask of token PID for USB host transfer
        pub type MASK_UH_TOKEN_R = crate::FieldReader;
        ///Field `MASK_UH_TOKEN` writer - bit mask of token PID for USB host transfer
        pub type MASK_UH_TOKEN_W<'a, REG> = crate::FieldWriter<'a, REG, 4>;
        impl R {
            ///Bits 0:3 - bit mask of endpoint number for USB host transfer
            #[inline(always)]
            pub fn mask_uh_endp(&self) -> MASK_UH_ENDP_R {
                MASK_UH_ENDP_R::new(self.bits & 0x0f)
            }
            ///Bits 0:7 - endpoint 2 transmittal length;
            #[inline(always)]
            pub fn uep2_t_len(&self) -> UEP2_T_LEN_R {
                UEP2_T_LEN_R::new(self.bits)
            }
            ///Bits 4:7 - bit mask of token PID for USB host transfer
            #[inline(always)]
            pub fn mask_uh_token(&self) -> MASK_UH_TOKEN_R {
                MASK_UH_TOKEN_R::new((self.bits >> 4) & 0x0f)
            }
        }
        impl W {
            ///Bits 0:3 - bit mask of endpoint number for USB host transfer
            #[inline(always)]
            #[must_use]
            pub fn mask_uh_endp(&mut self) -> MASK_UH_ENDP_W<UEP2_T_LEN_R8_UH_EP_PID_SPEC> {
                MASK_UH_ENDP_W::new(self, 0)
            }
            ///Bits 0:7 - endpoint 2 transmittal length;
            #[inline(always)]
            #[must_use]
            pub fn uep2_t_len(&mut self) -> UEP2_T_LEN_W<UEP2_T_LEN_R8_UH_EP_PID_SPEC> {
                UEP2_T_LEN_W::new(self, 0)
            }
            ///Bits 4:7 - bit mask of token PID for USB host transfer
            #[inline(always)]
            #[must_use]
            pub fn mask_uh_token(&mut self) -> MASK_UH_TOKEN_W<UEP2_T_LEN_R8_UH_EP_PID_SPEC> {
                MASK_UH_TOKEN_W::new(self, 4)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///endpoint 2 transmittal length;host endpoint and PID
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`uep2_t_len_r8_uh_ep_pid::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep2_t_len_r8_uh_ep_pid::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct UEP2_T_LEN_R8_UH_EP_PID_SPEC;
        impl crate::RegisterSpec for UEP2_T_LEN_R8_UH_EP_PID_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`uep2_t_len_r8_uh_ep_pid::R`](R) reader structure
        impl crate::Readable for UEP2_T_LEN_R8_UH_EP_PID_SPEC {}
        ///`write(|w| ..)` method takes [`uep2_t_len_r8_uh_ep_pid::W`](W) writer structure
        impl crate::Writable for UEP2_T_LEN_R8_UH_EP_PID_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets UEP2_T_LEN_R8_UH_EP_PID to value 0
        impl crate::Resettable for UEP2_T_LEN_R8_UH_EP_PID_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///UEP2_CTRL_R8_UH_RX_CTRL (rw) register accessor: endpoint 2 control;host receiver endpoint control
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`uep2_ctrl_r8_uh_rx_ctrl::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep2_ctrl_r8_uh_rx_ctrl::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@uep2_ctrl_r8_uh_rx_ctrl`]
    ///module
    pub type UEP2_CTRL_R8_UH_RX_CTRL =
        crate::Reg<uep2_ctrl_r8_uh_rx_ctrl::UEP2_CTRL_R8_UH_RX_CTRL_SPEC>;
    ///endpoint 2 control;host receiver endpoint control
    pub mod uep2_ctrl_r8_uh_rx_ctrl {
        ///Register `UEP2_CTRL_R8_UH_RX_CTRL` reader
        pub type R = crate::R<UEP2_CTRL_R8_UH_RX_CTRL_SPEC>;
        ///Register `UEP2_CTRL_R8_UH_RX_CTRL` writer
        pub type W = crate::W<UEP2_CTRL_R8_UH_RX_CTRL_SPEC>;
        ///Field `MASK_UEP_T_RES` reader - bit mask of handshake response type for USB endpoint X transmittal (IN)
        pub type MASK_UEP_T_RES_R = crate::FieldReader;
        ///Field `MASK_UEP_T_RES` writer - bit mask of handshake response type for USB endpoint X transmittal (IN)
        pub type MASK_UEP_T_RES_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `MASK_UH_R_RES` reader - bit mask of handshake response type for USB endpoint X receiving (OUT)
        pub type MASK_UH_R_RES_R = crate::BitReader;
        ///Field `MASK_UH_R_RES` writer - bit mask of handshake response type for USB endpoint X receiving (OUT)
        pub type MASK_UH_R_RES_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `MASK_UEP_R_RES` reader - bit mask of handshake response type for USB endpoint X receiving (OUT)
        pub type MASK_UEP_R_RES_R = crate::FieldReader;
        ///Field `MASK_UEP_R_RES` writer - bit mask of handshake response type for USB endpoint X receiving (OUT)
        pub type MASK_UEP_R_RES_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `UEP_AUTO_TOG__RB_UH_R_AUTO_TOG` reader - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle;enable automatic toggle after successful transfer completion: 0=manual toggle, 1=automatic toggle
        pub type UEP_AUTO_TOG__RB_UH_R_AUTO_TOG_R = crate::BitReader;
        ///Field `UEP_AUTO_TOG__RB_UH_R_AUTO_TOG` writer - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle;enable automatic toggle after successful transfer completion: 0=manual toggle, 1=automatic toggle
        pub type UEP_AUTO_TOG__RB_UH_R_AUTO_TOG_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UEP_T_TOG` reader - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
        pub type UEP_T_TOG_R = crate::BitReader;
        ///Field `UEP_T_TOG` writer - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
        pub type UEP_T_TOG_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UEP_R_TOG__RB_UH_R_TOG` reader - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1;expected data toggle flag of host receiving (IN): 0=DATA0, 1=DATA1
        pub type UEP_R_TOG__RB_UH_R_TOG_R = crate::BitReader;
        ///Field `UEP_R_TOG__RB_UH_R_TOG` writer - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1;expected data toggle flag of host receiving (IN): 0=DATA0, 1=DATA1
        pub type UEP_R_TOG__RB_UH_R_TOG_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)
            #[inline(always)]
            pub fn mask_uep_t_res(&self) -> MASK_UEP_T_RES_R {
                MASK_UEP_T_RES_R::new(self.bits & 3)
            }
            ///Bit 2 - bit mask of handshake response type for USB endpoint X receiving (OUT)
            #[inline(always)]
            pub fn mask_uh_r_res(&self) -> MASK_UH_R_RES_R {
                MASK_UH_R_RES_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)
            #[inline(always)]
            pub fn mask_uep_r_res(&self) -> MASK_UEP_R_RES_R {
                MASK_UEP_R_RES_R::new((self.bits >> 2) & 3)
            }
            ///Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle;enable automatic toggle after successful transfer completion: 0=manual toggle, 1=automatic toggle
            #[inline(always)]
            pub fn uep_auto_tog__rb_uh_r_auto_tog(&self) -> UEP_AUTO_TOG__RB_UH_R_AUTO_TOG_R {
                UEP_AUTO_TOG__RB_UH_R_AUTO_TOG_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
            #[inline(always)]
            pub fn uep_t_tog(&self) -> UEP_T_TOG_R {
                UEP_T_TOG_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1;expected data toggle flag of host receiving (IN): 0=DATA0, 1=DATA1
            #[inline(always)]
            pub fn uep_r_tog__rb_uh_r_tog(&self) -> UEP_R_TOG__RB_UH_R_TOG_R {
                UEP_R_TOG__RB_UH_R_TOG_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)
            #[inline(always)]
            #[must_use]
            pub fn mask_uep_t_res(&mut self) -> MASK_UEP_T_RES_W<UEP2_CTRL_R8_UH_RX_CTRL_SPEC> {
                MASK_UEP_T_RES_W::new(self, 0)
            }
            ///Bit 2 - bit mask of handshake response type for USB endpoint X receiving (OUT)
            #[inline(always)]
            #[must_use]
            pub fn mask_uh_r_res(&mut self) -> MASK_UH_R_RES_W<UEP2_CTRL_R8_UH_RX_CTRL_SPEC> {
                MASK_UH_R_RES_W::new(self, 2)
            }
            ///Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)
            #[inline(always)]
            #[must_use]
            pub fn mask_uep_r_res(&mut self) -> MASK_UEP_R_RES_W<UEP2_CTRL_R8_UH_RX_CTRL_SPEC> {
                MASK_UEP_R_RES_W::new(self, 2)
            }
            ///Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle;enable automatic toggle after successful transfer completion: 0=manual toggle, 1=automatic toggle
            #[inline(always)]
            #[must_use]
            pub fn uep_auto_tog__rb_uh_r_auto_tog(
                &mut self,
            ) -> UEP_AUTO_TOG__RB_UH_R_AUTO_TOG_W<UEP2_CTRL_R8_UH_RX_CTRL_SPEC> {
                UEP_AUTO_TOG__RB_UH_R_AUTO_TOG_W::new(self, 4)
            }
            ///Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
            #[inline(always)]
            #[must_use]
            pub fn uep_t_tog(&mut self) -> UEP_T_TOG_W<UEP2_CTRL_R8_UH_RX_CTRL_SPEC> {
                UEP_T_TOG_W::new(self, 6)
            }
            ///Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1;expected data toggle flag of host receiving (IN): 0=DATA0, 1=DATA1
            #[inline(always)]
            #[must_use]
            pub fn uep_r_tog__rb_uh_r_tog(
                &mut self,
            ) -> UEP_R_TOG__RB_UH_R_TOG_W<UEP2_CTRL_R8_UH_RX_CTRL_SPEC> {
                UEP_R_TOG__RB_UH_R_TOG_W::new(self, 7)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///endpoint 2 control;host receiver endpoint control
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`uep2_ctrl_r8_uh_rx_ctrl::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep2_ctrl_r8_uh_rx_ctrl::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct UEP2_CTRL_R8_UH_RX_CTRL_SPEC;
        impl crate::RegisterSpec for UEP2_CTRL_R8_UH_RX_CTRL_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`uep2_ctrl_r8_uh_rx_ctrl::R`](R) reader structure
        impl crate::Readable for UEP2_CTRL_R8_UH_RX_CTRL_SPEC {}
        ///`write(|w| ..)` method takes [`uep2_ctrl_r8_uh_rx_ctrl::W`](W) writer structure
        impl crate::Writable for UEP2_CTRL_R8_UH_RX_CTRL_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets UEP2_CTRL_R8_UH_RX_CTRL to value 0
        impl crate::Resettable for UEP2_CTRL_R8_UH_RX_CTRL_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///UEP3_T_LEN__R8_UH_TX_LEN (rw) register accessor: endpoint 3 transmittal length;host transmittal endpoint transmittal length
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`uep3_t_len__r8_uh_tx_len::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep3_t_len__r8_uh_tx_len::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@uep3_t_len__r8_uh_tx_len`]
    ///module
    pub type UEP3_T_LEN__R8_UH_TX_LEN =
        crate::Reg<uep3_t_len__r8_uh_tx_len::UEP3_T_LEN__R8_UH_TX_LEN_SPEC>;
    ///endpoint 3 transmittal length;host transmittal endpoint transmittal length
    pub mod uep3_t_len__r8_uh_tx_len {
        ///Register `UEP3_T_LEN__R8_UH_TX_LEN` reader
        pub type R = crate::R<UEP3_T_LEN__R8_UH_TX_LEN_SPEC>;
        ///Register `UEP3_T_LEN__R8_UH_TX_LEN` writer
        pub type W = crate::W<UEP3_T_LEN__R8_UH_TX_LEN_SPEC>;
        ///Field `UEP3_T_LEN__R8_UH_TX_LEN` reader - endpoint 1 transmittal length
        pub type UEP3_T_LEN__R8_UH_TX_LEN_R = crate::FieldReader;
        ///Field `UEP3_T_LEN__R8_UH_TX_LEN` writer - endpoint 1 transmittal length
        pub type UEP3_T_LEN__R8_UH_TX_LEN_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            ///Bits 0:7 - endpoint 1 transmittal length
            #[inline(always)]
            pub fn uep3_t_len__r8_uh_tx_len(&self) -> UEP3_T_LEN__R8_UH_TX_LEN_R {
                UEP3_T_LEN__R8_UH_TX_LEN_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:7 - endpoint 1 transmittal length
            #[inline(always)]
            #[must_use]
            pub fn uep3_t_len__r8_uh_tx_len(
                &mut self,
            ) -> UEP3_T_LEN__R8_UH_TX_LEN_W<UEP3_T_LEN__R8_UH_TX_LEN_SPEC> {
                UEP3_T_LEN__R8_UH_TX_LEN_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///endpoint 3 transmittal length;host transmittal endpoint transmittal length
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`uep3_t_len__r8_uh_tx_len::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep3_t_len__r8_uh_tx_len::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct UEP3_T_LEN__R8_UH_TX_LEN_SPEC;
        impl crate::RegisterSpec for UEP3_T_LEN__R8_UH_TX_LEN_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`uep3_t_len__r8_uh_tx_len::R`](R) reader structure
        impl crate::Readable for UEP3_T_LEN__R8_UH_TX_LEN_SPEC {}
        ///`write(|w| ..)` method takes [`uep3_t_len__r8_uh_tx_len::W`](W) writer structure
        impl crate::Writable for UEP3_T_LEN__R8_UH_TX_LEN_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets UEP3_T_LEN__R8_UH_TX_LEN to value 0
        impl crate::Resettable for UEP3_T_LEN__R8_UH_TX_LEN_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///UEP3_CTRL__R8_UH_TX_CTRL (rw) register accessor: endpoint 3 control;host transmittal endpoint control
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`uep3_ctrl__r8_uh_tx_ctrl::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep3_ctrl__r8_uh_tx_ctrl::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@uep3_ctrl__r8_uh_tx_ctrl`]
    ///module
    pub type UEP3_CTRL__R8_UH_TX_CTRL =
        crate::Reg<uep3_ctrl__r8_uh_tx_ctrl::UEP3_CTRL__R8_UH_TX_CTRL_SPEC>;
    ///endpoint 3 control;host transmittal endpoint control
    pub mod uep3_ctrl__r8_uh_tx_ctrl {
        ///Register `UEP3_CTRL__R8_UH_TX_CTRL` reader
        pub type R = crate::R<UEP3_CTRL__R8_UH_TX_CTRL_SPEC>;
        ///Register `UEP3_CTRL__R8_UH_TX_CTRL` writer
        pub type W = crate::W<UEP3_CTRL__R8_UH_TX_CTRL_SPEC>;
        ///Field `UH_T_RES` reader - bit mask of handshake response type for USB endpoint X transmittal (IN)
        pub type UH_T_RES_R = crate::FieldReader;
        ///Field `UH_T_RES` writer - bit mask of handshake response type for USB endpoint X transmittal (IN)
        pub type UH_T_RES_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `MASK_UEP_T_RES` reader - bit mask of handshake response type for USB endpoint X transmittal (IN)
        pub type MASK_UEP_T_RES_R = crate::FieldReader;
        ///Field `MASK_UEP_T_RES` writer - bit mask of handshake response type for USB endpoint X transmittal (IN)
        pub type MASK_UEP_T_RES_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `MASK_UEP_R_RES` reader - bit mask of handshake response type for USB endpoint X receiving (OUT)
        pub type MASK_UEP_R_RES_R = crate::FieldReader;
        ///Field `MASK_UEP_R_RES` writer - bit mask of handshake response type for USB endpoint X receiving (OUT)
        pub type MASK_UEP_R_RES_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `UEP_AUTO_TOG_RB_UH_T_AUTO_TOG` reader - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
        pub type UEP_AUTO_TOG_RB_UH_T_AUTO_TOG_R = crate::BitReader;
        ///Field `UEP_AUTO_TOG_RB_UH_T_AUTO_TOG` writer - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
        pub type UEP_AUTO_TOG_RB_UH_T_AUTO_TOG_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UEP_T_TOG_RB_UH_T_TOG` reader - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
        pub type UEP_T_TOG_RB_UH_T_TOG_R = crate::BitReader;
        ///Field `UEP_T_TOG_RB_UH_T_TOG` writer - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
        pub type UEP_T_TOG_RB_UH_T_TOG_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UEP_R_TOG` reader - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
        pub type UEP_R_TOG_R = crate::BitReader;
        ///Field `UEP_R_TOG` writer - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
        pub type UEP_R_TOG_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)
            #[inline(always)]
            pub fn uh_t_res(&self) -> UH_T_RES_R {
                UH_T_RES_R::new(self.bits & 3)
            }
            ///Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)
            #[inline(always)]
            pub fn mask_uep_t_res(&self) -> MASK_UEP_T_RES_R {
                MASK_UEP_T_RES_R::new(self.bits & 3)
            }
            ///Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)
            #[inline(always)]
            pub fn mask_uep_r_res(&self) -> MASK_UEP_R_RES_R {
                MASK_UEP_R_RES_R::new((self.bits >> 2) & 3)
            }
            ///Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
            #[inline(always)]
            pub fn uep_auto_tog_rb_uh_t_auto_tog(&self) -> UEP_AUTO_TOG_RB_UH_T_AUTO_TOG_R {
                UEP_AUTO_TOG_RB_UH_T_AUTO_TOG_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
            #[inline(always)]
            pub fn uep_t_tog_rb_uh_t_tog(&self) -> UEP_T_TOG_RB_UH_T_TOG_R {
                UEP_T_TOG_RB_UH_T_TOG_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
            #[inline(always)]
            pub fn uep_r_tog(&self) -> UEP_R_TOG_R {
                UEP_R_TOG_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)
            #[inline(always)]
            #[must_use]
            pub fn uh_t_res(&mut self) -> UH_T_RES_W<UEP3_CTRL__R8_UH_TX_CTRL_SPEC> {
                UH_T_RES_W::new(self, 0)
            }
            ///Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)
            #[inline(always)]
            #[must_use]
            pub fn mask_uep_t_res(&mut self) -> MASK_UEP_T_RES_W<UEP3_CTRL__R8_UH_TX_CTRL_SPEC> {
                MASK_UEP_T_RES_W::new(self, 0)
            }
            ///Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)
            #[inline(always)]
            #[must_use]
            pub fn mask_uep_r_res(&mut self) -> MASK_UEP_R_RES_W<UEP3_CTRL__R8_UH_TX_CTRL_SPEC> {
                MASK_UEP_R_RES_W::new(self, 2)
            }
            ///Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
            #[inline(always)]
            #[must_use]
            pub fn uep_auto_tog_rb_uh_t_auto_tog(
                &mut self,
            ) -> UEP_AUTO_TOG_RB_UH_T_AUTO_TOG_W<UEP3_CTRL__R8_UH_TX_CTRL_SPEC> {
                UEP_AUTO_TOG_RB_UH_T_AUTO_TOG_W::new(self, 4)
            }
            ///Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
            #[inline(always)]
            #[must_use]
            pub fn uep_t_tog_rb_uh_t_tog(
                &mut self,
            ) -> UEP_T_TOG_RB_UH_T_TOG_W<UEP3_CTRL__R8_UH_TX_CTRL_SPEC> {
                UEP_T_TOG_RB_UH_T_TOG_W::new(self, 6)
            }
            ///Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
            #[inline(always)]
            #[must_use]
            pub fn uep_r_tog(&mut self) -> UEP_R_TOG_W<UEP3_CTRL__R8_UH_TX_CTRL_SPEC> {
                UEP_R_TOG_W::new(self, 7)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///endpoint 3 control;host transmittal endpoint control
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`uep3_ctrl__r8_uh_tx_ctrl::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep3_ctrl__r8_uh_tx_ctrl::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct UEP3_CTRL__R8_UH_TX_CTRL_SPEC;
        impl crate::RegisterSpec for UEP3_CTRL__R8_UH_TX_CTRL_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`uep3_ctrl__r8_uh_tx_ctrl::R`](R) reader structure
        impl crate::Readable for UEP3_CTRL__R8_UH_TX_CTRL_SPEC {}
        ///`write(|w| ..)` method takes [`uep3_ctrl__r8_uh_tx_ctrl::W`](W) writer structure
        impl crate::Writable for UEP3_CTRL__R8_UH_TX_CTRL_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets UEP3_CTRL__R8_UH_TX_CTRL to value 0
        impl crate::Resettable for UEP3_CTRL__R8_UH_TX_CTRL_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///UEP4_T_LEN (rw) register accessor: endpoint 4 transmittal length
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`uep4_t_len::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep4_t_len::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@uep4_t_len`]
    ///module
    pub type UEP4_T_LEN = crate::Reg<uep4_t_len::UEP4_T_LEN_SPEC>;
    ///endpoint 4 transmittal length
    pub mod uep4_t_len {
        ///Register `UEP4_T_LEN` reader
        pub type R = crate::R<UEP4_T_LEN_SPEC>;
        ///Register `UEP4_T_LEN` writer
        pub type W = crate::W<UEP4_T_LEN_SPEC>;
        ///Field `UEP4_T_LEN` reader - endpoint 4 transmittal length
        pub type UEP4_T_LEN_R = crate::FieldReader;
        ///Field `UEP4_T_LEN` writer - endpoint 4 transmittal length
        pub type UEP4_T_LEN_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            ///Bits 0:7 - endpoint 4 transmittal length
            #[inline(always)]
            pub fn uep4_t_len(&self) -> UEP4_T_LEN_R {
                UEP4_T_LEN_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:7 - endpoint 4 transmittal length
            #[inline(always)]
            #[must_use]
            pub fn uep4_t_len(&mut self) -> UEP4_T_LEN_W<UEP4_T_LEN_SPEC> {
                UEP4_T_LEN_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///endpoint 4 transmittal length
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`uep4_t_len::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep4_t_len::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct UEP4_T_LEN_SPEC;
        impl crate::RegisterSpec for UEP4_T_LEN_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`uep4_t_len::R`](R) reader structure
        impl crate::Readable for UEP4_T_LEN_SPEC {}
        ///`write(|w| ..)` method takes [`uep4_t_len::W`](W) writer structure
        impl crate::Writable for UEP4_T_LEN_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets UEP4_T_LEN to value 0
        impl crate::Resettable for UEP4_T_LEN_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///UEP4_CTRL (rw) register accessor: endpoint 4 control
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`uep4_ctrl::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep4_ctrl::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@uep4_ctrl`]
    ///module
    pub type UEP4_CTRL = crate::Reg<uep4_ctrl::UEP4_CTRL_SPEC>;
    ///endpoint 4 control
    pub mod uep4_ctrl {
        ///Register `UEP4_CTRL` reader
        pub type R = crate::R<UEP4_CTRL_SPEC>;
        ///Register `UEP4_CTRL` writer
        pub type W = crate::W<UEP4_CTRL_SPEC>;
        ///Field `MASK_UEP_T_RES` reader - bit mask of handshake response type for USB endpoint X transmittal (IN)
        pub type MASK_UEP_T_RES_R = crate::FieldReader;
        ///Field `MASK_UEP_T_RES` writer - bit mask of handshake response type for USB endpoint X transmittal (IN)
        pub type MASK_UEP_T_RES_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `MASK_UEP_R_RES` reader - bit mask of handshake response type for USB endpoint X receiving (OUT)
        pub type MASK_UEP_R_RES_R = crate::FieldReader;
        ///Field `MASK_UEP_R_RES` writer - bit mask of handshake response type for USB endpoint X receiving (OUT)
        pub type MASK_UEP_R_RES_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `UEP_AUTO_TOG` reader - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
        pub type UEP_AUTO_TOG_R = crate::BitReader;
        ///Field `UEP_AUTO_TOG` writer - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
        pub type UEP_AUTO_TOG_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UEP_T_TOG` reader - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
        pub type UEP_T_TOG_R = crate::BitReader;
        ///Field `UEP_T_TOG` writer - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
        pub type UEP_T_TOG_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UEP_R_TOG` reader - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
        pub type UEP_R_TOG_R = crate::BitReader;
        ///Field `UEP_R_TOG` writer - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
        pub type UEP_R_TOG_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)
            #[inline(always)]
            pub fn mask_uep_t_res(&self) -> MASK_UEP_T_RES_R {
                MASK_UEP_T_RES_R::new(self.bits & 3)
            }
            ///Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)
            #[inline(always)]
            pub fn mask_uep_r_res(&self) -> MASK_UEP_R_RES_R {
                MASK_UEP_R_RES_R::new((self.bits >> 2) & 3)
            }
            ///Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
            #[inline(always)]
            pub fn uep_auto_tog(&self) -> UEP_AUTO_TOG_R {
                UEP_AUTO_TOG_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
            #[inline(always)]
            pub fn uep_t_tog(&self) -> UEP_T_TOG_R {
                UEP_T_TOG_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
            #[inline(always)]
            pub fn uep_r_tog(&self) -> UEP_R_TOG_R {
                UEP_R_TOG_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)
            #[inline(always)]
            #[must_use]
            pub fn mask_uep_t_res(&mut self) -> MASK_UEP_T_RES_W<UEP4_CTRL_SPEC> {
                MASK_UEP_T_RES_W::new(self, 0)
            }
            ///Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)
            #[inline(always)]
            #[must_use]
            pub fn mask_uep_r_res(&mut self) -> MASK_UEP_R_RES_W<UEP4_CTRL_SPEC> {
                MASK_UEP_R_RES_W::new(self, 2)
            }
            ///Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
            #[inline(always)]
            #[must_use]
            pub fn uep_auto_tog(&mut self) -> UEP_AUTO_TOG_W<UEP4_CTRL_SPEC> {
                UEP_AUTO_TOG_W::new(self, 4)
            }
            ///Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
            #[inline(always)]
            #[must_use]
            pub fn uep_t_tog(&mut self) -> UEP_T_TOG_W<UEP4_CTRL_SPEC> {
                UEP_T_TOG_W::new(self, 6)
            }
            ///Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
            #[inline(always)]
            #[must_use]
            pub fn uep_r_tog(&mut self) -> UEP_R_TOG_W<UEP4_CTRL_SPEC> {
                UEP_R_TOG_W::new(self, 7)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///endpoint 4 control
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`uep4_ctrl::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep4_ctrl::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct UEP4_CTRL_SPEC;
        impl crate::RegisterSpec for UEP4_CTRL_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`uep4_ctrl::R`](R) reader structure
        impl crate::Readable for UEP4_CTRL_SPEC {}
        ///`write(|w| ..)` method takes [`uep4_ctrl::W`](W) writer structure
        impl crate::Writable for UEP4_CTRL_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets UEP4_CTRL to value 0
        impl crate::Resettable for UEP4_CTRL_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///UEP5_T_LEN (rw) register accessor: endpoint 5 transmittal length
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`uep5_t_len::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep5_t_len::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@uep5_t_len`]
    ///module
    pub type UEP5_T_LEN = crate::Reg<uep5_t_len::UEP5_T_LEN_SPEC>;
    ///endpoint 5 transmittal length
    pub mod uep5_t_len {
        ///Register `UEP5_T_LEN` reader
        pub type R = crate::R<UEP5_T_LEN_SPEC>;
        ///Register `UEP5_T_LEN` writer
        pub type W = crate::W<UEP5_T_LEN_SPEC>;
        ///Field `UEP5_T_LEN` reader - endpoint 5 transmittal length
        pub type UEP5_T_LEN_R = crate::FieldReader;
        ///Field `UEP5_T_LEN` writer - endpoint 5 transmittal length
        pub type UEP5_T_LEN_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            ///Bits 0:7 - endpoint 5 transmittal length
            #[inline(always)]
            pub fn uep5_t_len(&self) -> UEP5_T_LEN_R {
                UEP5_T_LEN_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:7 - endpoint 5 transmittal length
            #[inline(always)]
            #[must_use]
            pub fn uep5_t_len(&mut self) -> UEP5_T_LEN_W<UEP5_T_LEN_SPEC> {
                UEP5_T_LEN_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///endpoint 5 transmittal length
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`uep5_t_len::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep5_t_len::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct UEP5_T_LEN_SPEC;
        impl crate::RegisterSpec for UEP5_T_LEN_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`uep5_t_len::R`](R) reader structure
        impl crate::Readable for UEP5_T_LEN_SPEC {}
        ///`write(|w| ..)` method takes [`uep5_t_len::W`](W) writer structure
        impl crate::Writable for UEP5_T_LEN_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets UEP5_T_LEN to value 0
        impl crate::Resettable for UEP5_T_LEN_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///UEP5_CTRL (rw) register accessor: endpoint 5 control
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`uep5_ctrl::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep5_ctrl::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@uep5_ctrl`]
    ///module
    pub type UEP5_CTRL = crate::Reg<uep5_ctrl::UEP5_CTRL_SPEC>;
    ///endpoint 5 control
    pub mod uep5_ctrl {
        ///Register `UEP5_CTRL` reader
        pub type R = crate::R<UEP5_CTRL_SPEC>;
        ///Register `UEP5_CTRL` writer
        pub type W = crate::W<UEP5_CTRL_SPEC>;
        ///Field `MASK_UEP_T_RES` reader - bit mask of handshake response type for USB endpoint X transmittal (IN)
        pub type MASK_UEP_T_RES_R = crate::FieldReader;
        ///Field `MASK_UEP_T_RES` writer - bit mask of handshake response type for USB endpoint X transmittal (IN)
        pub type MASK_UEP_T_RES_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `MASK_UEP_R_RES` reader - bit mask of handshake response type for USB endpoint X receiving (OUT)
        pub type MASK_UEP_R_RES_R = crate::FieldReader;
        ///Field `MASK_UEP_R_RES` writer - bit mask of handshake response type for USB endpoint X receiving (OUT)
        pub type MASK_UEP_R_RES_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `UEP_AUTO_TOG` reader - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
        pub type UEP_AUTO_TOG_R = crate::BitReader;
        ///Field `UEP_AUTO_TOG` writer - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
        pub type UEP_AUTO_TOG_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UEP_T_TOG` reader - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
        pub type UEP_T_TOG_R = crate::BitReader;
        ///Field `UEP_T_TOG` writer - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
        pub type UEP_T_TOG_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UEP_R_TOG` reader - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
        pub type UEP_R_TOG_R = crate::BitReader;
        ///Field `UEP_R_TOG` writer - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
        pub type UEP_R_TOG_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)
            #[inline(always)]
            pub fn mask_uep_t_res(&self) -> MASK_UEP_T_RES_R {
                MASK_UEP_T_RES_R::new(self.bits & 3)
            }
            ///Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)
            #[inline(always)]
            pub fn mask_uep_r_res(&self) -> MASK_UEP_R_RES_R {
                MASK_UEP_R_RES_R::new((self.bits >> 2) & 3)
            }
            ///Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
            #[inline(always)]
            pub fn uep_auto_tog(&self) -> UEP_AUTO_TOG_R {
                UEP_AUTO_TOG_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
            #[inline(always)]
            pub fn uep_t_tog(&self) -> UEP_T_TOG_R {
                UEP_T_TOG_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
            #[inline(always)]
            pub fn uep_r_tog(&self) -> UEP_R_TOG_R {
                UEP_R_TOG_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)
            #[inline(always)]
            #[must_use]
            pub fn mask_uep_t_res(&mut self) -> MASK_UEP_T_RES_W<UEP5_CTRL_SPEC> {
                MASK_UEP_T_RES_W::new(self, 0)
            }
            ///Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)
            #[inline(always)]
            #[must_use]
            pub fn mask_uep_r_res(&mut self) -> MASK_UEP_R_RES_W<UEP5_CTRL_SPEC> {
                MASK_UEP_R_RES_W::new(self, 2)
            }
            ///Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
            #[inline(always)]
            #[must_use]
            pub fn uep_auto_tog(&mut self) -> UEP_AUTO_TOG_W<UEP5_CTRL_SPEC> {
                UEP_AUTO_TOG_W::new(self, 4)
            }
            ///Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
            #[inline(always)]
            #[must_use]
            pub fn uep_t_tog(&mut self) -> UEP_T_TOG_W<UEP5_CTRL_SPEC> {
                UEP_T_TOG_W::new(self, 6)
            }
            ///Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
            #[inline(always)]
            #[must_use]
            pub fn uep_r_tog(&mut self) -> UEP_R_TOG_W<UEP5_CTRL_SPEC> {
                UEP_R_TOG_W::new(self, 7)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///endpoint 5 control
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`uep5_ctrl::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep5_ctrl::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct UEP5_CTRL_SPEC;
        impl crate::RegisterSpec for UEP5_CTRL_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`uep5_ctrl::R`](R) reader structure
        impl crate::Readable for UEP5_CTRL_SPEC {}
        ///`write(|w| ..)` method takes [`uep5_ctrl::W`](W) writer structure
        impl crate::Writable for UEP5_CTRL_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets UEP5_CTRL to value 0
        impl crate::Resettable for UEP5_CTRL_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///UEP6_T_LEN (rw) register accessor: endpoint 6 transmittal length
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`uep6_t_len::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep6_t_len::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@uep6_t_len`]
    ///module
    pub type UEP6_T_LEN = crate::Reg<uep6_t_len::UEP6_T_LEN_SPEC>;
    ///endpoint 6 transmittal length
    pub mod uep6_t_len {
        ///Register `UEP6_T_LEN` reader
        pub type R = crate::R<UEP6_T_LEN_SPEC>;
        ///Register `UEP6_T_LEN` writer
        pub type W = crate::W<UEP6_T_LEN_SPEC>;
        ///Field `UEP6_T_LEN` reader - endpoint 6 transmittal length
        pub type UEP6_T_LEN_R = crate::FieldReader;
        ///Field `UEP6_T_LEN` writer - endpoint 6 transmittal length
        pub type UEP6_T_LEN_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            ///Bits 0:7 - endpoint 6 transmittal length
            #[inline(always)]
            pub fn uep6_t_len(&self) -> UEP6_T_LEN_R {
                UEP6_T_LEN_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:7 - endpoint 6 transmittal length
            #[inline(always)]
            #[must_use]
            pub fn uep6_t_len(&mut self) -> UEP6_T_LEN_W<UEP6_T_LEN_SPEC> {
                UEP6_T_LEN_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///endpoint 6 transmittal length
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`uep6_t_len::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep6_t_len::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct UEP6_T_LEN_SPEC;
        impl crate::RegisterSpec for UEP6_T_LEN_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`uep6_t_len::R`](R) reader structure
        impl crate::Readable for UEP6_T_LEN_SPEC {}
        ///`write(|w| ..)` method takes [`uep6_t_len::W`](W) writer structure
        impl crate::Writable for UEP6_T_LEN_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets UEP6_T_LEN to value 0
        impl crate::Resettable for UEP6_T_LEN_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///UEP6_CTRL (rw) register accessor: endpoint 6 control
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`uep6_ctrl::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep6_ctrl::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@uep6_ctrl`]
    ///module
    pub type UEP6_CTRL = crate::Reg<uep6_ctrl::UEP6_CTRL_SPEC>;
    ///endpoint 6 control
    pub mod uep6_ctrl {
        ///Register `UEP6_CTRL` reader
        pub type R = crate::R<UEP6_CTRL_SPEC>;
        ///Register `UEP6_CTRL` writer
        pub type W = crate::W<UEP6_CTRL_SPEC>;
        ///Field `MASK_UEP_T_RES` reader - bit mask of handshake response type for USB endpoint X transmittal (IN)
        pub type MASK_UEP_T_RES_R = crate::FieldReader;
        ///Field `MASK_UEP_T_RES` writer - bit mask of handshake response type for USB endpoint X transmittal (IN)
        pub type MASK_UEP_T_RES_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `MASK_UEP_R_RES` reader - bit mask of handshake response type for USB endpoint X receiving (OUT)
        pub type MASK_UEP_R_RES_R = crate::FieldReader;
        ///Field `MASK_UEP_R_RES` writer - bit mask of handshake response type for USB endpoint X receiving (OUT)
        pub type MASK_UEP_R_RES_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `UEP_AUTO_TOG` reader - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
        pub type UEP_AUTO_TOG_R = crate::BitReader;
        ///Field `UEP_AUTO_TOG` writer - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
        pub type UEP_AUTO_TOG_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UEP_T_TOG` reader - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
        pub type UEP_T_TOG_R = crate::BitReader;
        ///Field `UEP_T_TOG` writer - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
        pub type UEP_T_TOG_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UEP_R_TOG` reader - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
        pub type UEP_R_TOG_R = crate::BitReader;
        ///Field `UEP_R_TOG` writer - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
        pub type UEP_R_TOG_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)
            #[inline(always)]
            pub fn mask_uep_t_res(&self) -> MASK_UEP_T_RES_R {
                MASK_UEP_T_RES_R::new(self.bits & 3)
            }
            ///Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)
            #[inline(always)]
            pub fn mask_uep_r_res(&self) -> MASK_UEP_R_RES_R {
                MASK_UEP_R_RES_R::new((self.bits >> 2) & 3)
            }
            ///Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
            #[inline(always)]
            pub fn uep_auto_tog(&self) -> UEP_AUTO_TOG_R {
                UEP_AUTO_TOG_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
            #[inline(always)]
            pub fn uep_t_tog(&self) -> UEP_T_TOG_R {
                UEP_T_TOG_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
            #[inline(always)]
            pub fn uep_r_tog(&self) -> UEP_R_TOG_R {
                UEP_R_TOG_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)
            #[inline(always)]
            #[must_use]
            pub fn mask_uep_t_res(&mut self) -> MASK_UEP_T_RES_W<UEP6_CTRL_SPEC> {
                MASK_UEP_T_RES_W::new(self, 0)
            }
            ///Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)
            #[inline(always)]
            #[must_use]
            pub fn mask_uep_r_res(&mut self) -> MASK_UEP_R_RES_W<UEP6_CTRL_SPEC> {
                MASK_UEP_R_RES_W::new(self, 2)
            }
            ///Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
            #[inline(always)]
            #[must_use]
            pub fn uep_auto_tog(&mut self) -> UEP_AUTO_TOG_W<UEP6_CTRL_SPEC> {
                UEP_AUTO_TOG_W::new(self, 4)
            }
            ///Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
            #[inline(always)]
            #[must_use]
            pub fn uep_t_tog(&mut self) -> UEP_T_TOG_W<UEP6_CTRL_SPEC> {
                UEP_T_TOG_W::new(self, 6)
            }
            ///Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
            #[inline(always)]
            #[must_use]
            pub fn uep_r_tog(&mut self) -> UEP_R_TOG_W<UEP6_CTRL_SPEC> {
                UEP_R_TOG_W::new(self, 7)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///endpoint 6 control
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`uep6_ctrl::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep6_ctrl::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct UEP6_CTRL_SPEC;
        impl crate::RegisterSpec for UEP6_CTRL_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`uep6_ctrl::R`](R) reader structure
        impl crate::Readable for UEP6_CTRL_SPEC {}
        ///`write(|w| ..)` method takes [`uep6_ctrl::W`](W) writer structure
        impl crate::Writable for UEP6_CTRL_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets UEP6_CTRL to value 0
        impl crate::Resettable for UEP6_CTRL_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///UEP7_T_LEN (rw) register accessor: endpoint 7 transmittal length
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`uep7_t_len::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep7_t_len::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@uep7_t_len`]
    ///module
    pub type UEP7_T_LEN = crate::Reg<uep7_t_len::UEP7_T_LEN_SPEC>;
    ///endpoint 7 transmittal length
    pub mod uep7_t_len {
        ///Register `UEP7_T_LEN` reader
        pub type R = crate::R<UEP7_T_LEN_SPEC>;
        ///Register `UEP7_T_LEN` writer
        pub type W = crate::W<UEP7_T_LEN_SPEC>;
        ///Field `UEP7_T_LEN` reader - endpoint 7 transmittal length
        pub type UEP7_T_LEN_R = crate::FieldReader;
        ///Field `UEP7_T_LEN` writer - endpoint 7 transmittal length
        pub type UEP7_T_LEN_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            ///Bits 0:7 - endpoint 7 transmittal length
            #[inline(always)]
            pub fn uep7_t_len(&self) -> UEP7_T_LEN_R {
                UEP7_T_LEN_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:7 - endpoint 7 transmittal length
            #[inline(always)]
            #[must_use]
            pub fn uep7_t_len(&mut self) -> UEP7_T_LEN_W<UEP7_T_LEN_SPEC> {
                UEP7_T_LEN_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///endpoint 7 transmittal length
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`uep7_t_len::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep7_t_len::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct UEP7_T_LEN_SPEC;
        impl crate::RegisterSpec for UEP7_T_LEN_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`uep7_t_len::R`](R) reader structure
        impl crate::Readable for UEP7_T_LEN_SPEC {}
        ///`write(|w| ..)` method takes [`uep7_t_len::W`](W) writer structure
        impl crate::Writable for UEP7_T_LEN_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets UEP7_T_LEN to value 0
        impl crate::Resettable for UEP7_T_LEN_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///UEP7_CTRL (rw) register accessor: endpoint 7 control
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`uep7_ctrl::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep7_ctrl::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@uep7_ctrl`]
    ///module
    pub type UEP7_CTRL = crate::Reg<uep7_ctrl::UEP7_CTRL_SPEC>;
    ///endpoint 7 control
    pub mod uep7_ctrl {
        ///Register `UEP7_CTRL` reader
        pub type R = crate::R<UEP7_CTRL_SPEC>;
        ///Register `UEP7_CTRL` writer
        pub type W = crate::W<UEP7_CTRL_SPEC>;
        ///Field `MASK_UEP_T_RES` reader - bit mask of handshake response type for USB endpoint X transmittal (IN)
        pub type MASK_UEP_T_RES_R = crate::FieldReader;
        ///Field `MASK_UEP_T_RES` writer - bit mask of handshake response type for USB endpoint X transmittal (IN)
        pub type MASK_UEP_T_RES_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `MASK_UEP_R_RES` reader - bit mask of handshake response type for USB endpoint X receiving (OUT)
        pub type MASK_UEP_R_RES_R = crate::FieldReader;
        ///Field `MASK_UEP_R_RES` writer - bit mask of handshake response type for USB endpoint X receiving (OUT)
        pub type MASK_UEP_R_RES_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `UEP_AUTO_TOG` reader - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
        pub type UEP_AUTO_TOG_R = crate::BitReader;
        ///Field `UEP_AUTO_TOG` writer - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
        pub type UEP_AUTO_TOG_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UEP_T_TOG` reader - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
        pub type UEP_T_TOG_R = crate::BitReader;
        ///Field `UEP_T_TOG` writer - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
        pub type UEP_T_TOG_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UEP_R_TOG` reader - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
        pub type UEP_R_TOG_R = crate::BitReader;
        ///Field `UEP_R_TOG` writer - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
        pub type UEP_R_TOG_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)
            #[inline(always)]
            pub fn mask_uep_t_res(&self) -> MASK_UEP_T_RES_R {
                MASK_UEP_T_RES_R::new(self.bits & 3)
            }
            ///Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)
            #[inline(always)]
            pub fn mask_uep_r_res(&self) -> MASK_UEP_R_RES_R {
                MASK_UEP_R_RES_R::new((self.bits >> 2) & 3)
            }
            ///Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
            #[inline(always)]
            pub fn uep_auto_tog(&self) -> UEP_AUTO_TOG_R {
                UEP_AUTO_TOG_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
            #[inline(always)]
            pub fn uep_t_tog(&self) -> UEP_T_TOG_R {
                UEP_T_TOG_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
            #[inline(always)]
            pub fn uep_r_tog(&self) -> UEP_R_TOG_R {
                UEP_R_TOG_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)
            #[inline(always)]
            #[must_use]
            pub fn mask_uep_t_res(&mut self) -> MASK_UEP_T_RES_W<UEP7_CTRL_SPEC> {
                MASK_UEP_T_RES_W::new(self, 0)
            }
            ///Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)
            #[inline(always)]
            #[must_use]
            pub fn mask_uep_r_res(&mut self) -> MASK_UEP_R_RES_W<UEP7_CTRL_SPEC> {
                MASK_UEP_R_RES_W::new(self, 2)
            }
            ///Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
            #[inline(always)]
            #[must_use]
            pub fn uep_auto_tog(&mut self) -> UEP_AUTO_TOG_W<UEP7_CTRL_SPEC> {
                UEP_AUTO_TOG_W::new(self, 4)
            }
            ///Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
            #[inline(always)]
            #[must_use]
            pub fn uep_t_tog(&mut self) -> UEP_T_TOG_W<UEP7_CTRL_SPEC> {
                UEP_T_TOG_W::new(self, 6)
            }
            ///Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
            #[inline(always)]
            #[must_use]
            pub fn uep_r_tog(&mut self) -> UEP_R_TOG_W<UEP7_CTRL_SPEC> {
                UEP_R_TOG_W::new(self, 7)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///endpoint 7 control
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`uep7_ctrl::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uep7_ctrl::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct UEP7_CTRL_SPEC;
        impl crate::RegisterSpec for UEP7_CTRL_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`uep7_ctrl::R`](R) reader structure
        impl crate::Readable for UEP7_CTRL_SPEC {}
        ///`write(|w| ..)` method takes [`uep7_ctrl::W`](W) writer structure
        impl crate::Writable for UEP7_CTRL_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets UEP7_CTRL to value 0
        impl crate::Resettable for UEP7_CTRL_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
}
///USB2 register
pub struct USB2 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for USB2 {}
impl USB2 {
    ///Pointer to the register block
    pub const PTR: *const usb2::RegisterBlock = 0x4000_8400 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const usb2::RegisterBlock {
        Self::PTR
    }
    /// Steal an instance of this peripheral
    ///
    /// # Safety
    ///
    /// Ensure that the new instance of the peripheral cannot be used in a way
    /// that may race with any existing instances, for example by only
    /// accessing read-only or write-only registers, or by consuming the
    /// original peripheral and using critical sections to coordinate
    /// access between multiple new instances.
    ///
    /// Additionally, other software such as HALs may rely on only one
    /// peripheral instance existing to ensure memory safety; ensure
    /// no stolen instances are passed to such software.
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for USB2 {
    type Target = usb2::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for USB2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("USB2").finish()
    }
}
///USB2 register
pub mod usb2 {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        ctrl: CTRL,
        dev_ctrl__r8_u2host_ctrl: DEV_CTRL__R8_U2HOST_CTRL,
        int_en: INT_EN,
        dev_ad: DEV_AD,
        _reserved4: [u8; 0x01],
        mis_st: MIS_ST,
        int_fg: INT_FG,
        int_st: INT_ST,
        rx_len: RX_LEN,
        _reserved8: [u8; 0x03],
        ep4_1_mod: EP4_1_MOD,
        ep2_3_mod__r8_u2h_ep_mod: EP2_3_MOD__R8_U2H_EP_MOD,
        ep567_mod: EP567_MOD,
        _reserved11: [u8; 0x01],
        ep0_dma: EP0_DMA,
        _reserved12: [u8; 0x02],
        ep1_dma: EP1_DMA,
        _reserved13: [u8; 0x02],
        ep2_dma__r16_u2h_rx_dma: EP2_DMA__R16_U2H_RX_DMA,
        _reserved14: [u8; 0x02],
        ep3_dma__r16_u2h_tx_dma: EP3_DMA__R16_U2H_TX_DMA,
        _reserved15: [u8; 0x02],
        ep0_t_len: EP0_T_LEN,
        _reserved16: [u8; 0x01],
        ep0_ctrl: EP0_CTRL,
        _reserved17: [u8; 0x01],
        ep1_t_len: EP1_T_LEN,
        _reserved18: [u8; 0x01],
        ep1_ctrl__r8_u2h_setup: EP1_CTRL__R8_U2H_SETUP,
        _reserved19: [u8; 0x01],
        ep2_t_len_r8_u2h_ep_pid: EP2_T_LEN_R8_U2H_EP_PID,
        _reserved20: [u8; 0x01],
        ep2_ctrl_r8_u2h_rx_ctrl: EP2_CTRL_R8_U2H_RX_CTRL,
        _reserved21: [u8; 0x01],
        ep3_t_len__r8_u2h_tx_len: EP3_T_LEN__R8_U2H_TX_LEN,
        _reserved22: [u8; 0x01],
        ep3_ctrl__r8_u2h_tx_ctrl: EP3_CTRL__R8_U2H_TX_CTRL,
        _reserved23: [u8; 0x01],
        ep4_t_len: EP4_T_LEN,
        _reserved24: [u8; 0x01],
        ep4_ctrl: EP4_CTRL,
        _reserved25: [u8; 0x21],
        ep5_dma: EP5_DMA,
        _reserved26: [u8; 0x02],
        ep6_dma: EP6_DMA,
        _reserved27: [u8; 0x02],
        ep7_dma: EP7_DMA,
        _reserved28: [u8; 0x06],
        ep5_t_len: EP5_T_LEN,
        _reserved29: [u8; 0x01],
        ep5_ctrl: EP5_CTRL,
        _reserved30: [u8; 0x01],
        ep6_t_len: EP6_T_LEN,
        _reserved31: [u8; 0x01],
        ep6_ctrl: EP6_CTRL,
        _reserved32: [u8; 0x01],
        ep7_t_len: EP7_T_LEN,
        _reserved33: [u8; 0x01],
        ep7_ctrl: EP7_CTRL,
    }
    impl RegisterBlock {
        ///0x00 - USB2 base control
        #[inline(always)]
        pub const fn ctrl(&self) -> &CTRL {
            &self.ctrl
        }
        ///0x01 - USB2 device physical prot control
        #[inline(always)]
        pub const fn dev_ctrl__r8_u2host_ctrl(&self) -> &DEV_CTRL__R8_U2HOST_CTRL {
            &self.dev_ctrl__r8_u2host_ctrl
        }
        ///0x02 - USB2 interrupt enable
        #[inline(always)]
        pub const fn int_en(&self) -> &INT_EN {
            &self.int_en
        }
        ///0x03 - USB2 device address
        #[inline(always)]
        pub const fn dev_ad(&self) -> &DEV_AD {
            &self.dev_ad
        }
        ///0x05 - USB2 miscellaneous status
        #[inline(always)]
        pub const fn mis_st(&self) -> &MIS_ST {
            &self.mis_st
        }
        ///0x06 - USB2 interrupt flag
        #[inline(always)]
        pub const fn int_fg(&self) -> &INT_FG {
            &self.int_fg
        }
        ///0x07 - USB2 interrupt status
        #[inline(always)]
        pub const fn int_st(&self) -> &INT_ST {
            &self.int_st
        }
        ///0x08 - USB2 receiving length
        #[inline(always)]
        pub const fn rx_len(&self) -> &RX_LEN {
            &self.rx_len
        }
        ///0x0c - endpoint 4/1 mode
        #[inline(always)]
        pub const fn ep4_1_mod(&self) -> &EP4_1_MOD {
            &self.ep4_1_mod
        }
        ///0x0d - endpoint 2_3 mode;host endpoint mode
        #[inline(always)]
        pub const fn ep2_3_mod__r8_u2h_ep_mod(&self) -> &EP2_3_MOD__R8_U2H_EP_MOD {
            &self.ep2_3_mod__r8_u2h_ep_mod
        }
        ///0x0e - USB2 endpoint 5/6/7 mode
        #[inline(always)]
        pub const fn ep567_mod(&self) -> &EP567_MOD {
            &self.ep567_mod
        }
        ///0x10 - endpoint 0 DMA buffer address
        #[inline(always)]
        pub const fn ep0_dma(&self) -> &EP0_DMA {
            &self.ep0_dma
        }
        ///0x14 - USB2 endpoint 1 DMA buffer address
        #[inline(always)]
        pub const fn ep1_dma(&self) -> &EP1_DMA {
            &self.ep1_dma
        }
        ///0x18 - USB2 endpoint 2 DMA buffer address;host rx endpoint buffer high address
        #[inline(always)]
        pub const fn ep2_dma__r16_u2h_rx_dma(&self) -> &EP2_DMA__R16_U2H_RX_DMA {
            &self.ep2_dma__r16_u2h_rx_dma
        }
        ///0x1c - USB2 endpoint 3 DMA buffer address;host tx endpoint buffer high address
        #[inline(always)]
        pub const fn ep3_dma__r16_u2h_tx_dma(&self) -> &EP3_DMA__R16_U2H_TX_DMA {
            &self.ep3_dma__r16_u2h_tx_dma
        }
        ///0x20 - USB2 endpoint 0 transmittal length
        #[inline(always)]
        pub const fn ep0_t_len(&self) -> &EP0_T_LEN {
            &self.ep0_t_len
        }
        ///0x22 - USB2 endpoint 0 control
        #[inline(always)]
        pub const fn ep0_ctrl(&self) -> &EP0_CTRL {
            &self.ep0_ctrl
        }
        ///0x24 - USB2 endpoint 1 transmittal length
        #[inline(always)]
        pub const fn ep1_t_len(&self) -> &EP1_T_LEN {
            &self.ep1_t_len
        }
        ///0x26 - USB2 endpoint 1 control;host aux setup
        #[inline(always)]
        pub const fn ep1_ctrl__r8_u2h_setup(&self) -> &EP1_CTRL__R8_U2H_SETUP {
            &self.ep1_ctrl__r8_u2h_setup
        }
        ///0x28 - USB2 endpoint 2 transmittal length;host endpoint and PID
        #[inline(always)]
        pub const fn ep2_t_len_r8_u2h_ep_pid(&self) -> &EP2_T_LEN_R8_U2H_EP_PID {
            &self.ep2_t_len_r8_u2h_ep_pid
        }
        ///0x2a - USB2 endpoint 2 control;host receiver endpoint control
        #[inline(always)]
        pub const fn ep2_ctrl_r8_u2h_rx_ctrl(&self) -> &EP2_CTRL_R8_U2H_RX_CTRL {
            &self.ep2_ctrl_r8_u2h_rx_ctrl
        }
        ///0x2c - USB2 endpoint 3 transmittal length;host transmittal endpoint transmittal length
        #[inline(always)]
        pub const fn ep3_t_len__r8_u2h_tx_len(&self) -> &EP3_T_LEN__R8_U2H_TX_LEN {
            &self.ep3_t_len__r8_u2h_tx_len
        }
        ///0x2e - USB2 endpoint 3 control;host transmittal endpoint control
        #[inline(always)]
        pub const fn ep3_ctrl__r8_u2h_tx_ctrl(&self) -> &EP3_CTRL__R8_U2H_TX_CTRL {
            &self.ep3_ctrl__r8_u2h_tx_ctrl
        }
        ///0x30 - USB2 endpoint 4 transmittal length
        #[inline(always)]
        pub const fn ep4_t_len(&self) -> &EP4_T_LEN {
            &self.ep4_t_len
        }
        ///0x32 - USB2 endpoint 4 control
        #[inline(always)]
        pub const fn ep4_ctrl(&self) -> &EP4_CTRL {
            &self.ep4_ctrl
        }
        ///0x54 - USB2 endpoint 5 DMA buffer address
        #[inline(always)]
        pub const fn ep5_dma(&self) -> &EP5_DMA {
            &self.ep5_dma
        }
        ///0x58 - USB2 endpoint 6 DMA buffer address
        #[inline(always)]
        pub const fn ep6_dma(&self) -> &EP6_DMA {
            &self.ep6_dma
        }
        ///0x5c - USB2 endpoint 7 DMA buffer address
        #[inline(always)]
        pub const fn ep7_dma(&self) -> &EP7_DMA {
            &self.ep7_dma
        }
        ///0x64 - USB2 endpoint 5 transmittal length
        #[inline(always)]
        pub const fn ep5_t_len(&self) -> &EP5_T_LEN {
            &self.ep5_t_len
        }
        ///0x66 - USB2 endpoint 5 control
        #[inline(always)]
        pub const fn ep5_ctrl(&self) -> &EP5_CTRL {
            &self.ep5_ctrl
        }
        ///0x68 - USB2 endpoint 6 transmittal length
        #[inline(always)]
        pub const fn ep6_t_len(&self) -> &EP6_T_LEN {
            &self.ep6_t_len
        }
        ///0x6a - USB2 endpoint 6 control
        #[inline(always)]
        pub const fn ep6_ctrl(&self) -> &EP6_CTRL {
            &self.ep6_ctrl
        }
        ///0x6c - USB2 endpoint 7 transmittal length
        #[inline(always)]
        pub const fn ep7_t_len(&self) -> &EP7_T_LEN {
            &self.ep7_t_len
        }
        ///0x6e - USB2 endpoint 7 control
        #[inline(always)]
        pub const fn ep7_ctrl(&self) -> &EP7_CTRL {
            &self.ep7_ctrl
        }
    }
    ///CTRL (rw) register accessor: USB2 base control
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`ctrl::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ctrl::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@ctrl`]
    ///module
    pub type CTRL = crate::Reg<ctrl::CTRL_SPEC>;
    ///USB2 base control
    pub mod ctrl {
        ///Register `CTRL` reader
        pub type R = crate::R<CTRL_SPEC>;
        ///Register `CTRL` writer
        pub type W = crate::W<CTRL_SPEC>;
        ///Field `UC_DMA_EN` reader - DMA enable and DMA interrupt enable for USB
        pub type UC_DMA_EN_R = crate::BitReader;
        ///Field `UC_DMA_EN` writer - DMA enable and DMA interrupt enable for USB
        pub type UC_DMA_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UC_CLR_ALL` reader - force clear FIFO and count of USB
        pub type UC_CLR_ALL_R = crate::BitReader;
        ///Field `UC_CLR_ALL` writer - force clear FIFO and count of USB
        pub type UC_CLR_ALL_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UC_RESET_SIE` reader - force reset USB SIE, need software clear
        pub type UC_RESET_SIE_R = crate::BitReader;
        ///Field `UC_RESET_SIE` writer - force reset USB SIE, need software clear
        pub type UC_RESET_SIE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UC_INT_BUSY` reader - enable automatic responding busy for device mode or automatic pause for host mode during interrupt flag UIF_TRANSFER valid
        pub type UC_INT_BUSY_R = crate::BitReader;
        ///Field `UC_INT_BUSY` writer - enable automatic responding busy for device mode or automatic pause for host mode during interrupt flag UIF_TRANSFER valid
        pub type UC_INT_BUSY_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `MASK_UC_SYS_CTRL` reader - bit mask of USB system control
        pub type MASK_UC_SYS_CTRL_R = crate::FieldReader;
        ///Field `MASK_UC_SYS_CTRL` writer - bit mask of USB system control
        pub type MASK_UC_SYS_CTRL_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `UC_DEV_PU_EN` reader - USB device enable and internal pullup resistance enable
        pub type UC_DEV_PU_EN_R = crate::BitReader;
        ///Field `UC_DEV_PU_EN` writer - USB device enable and internal pullup resistance enable
        pub type UC_DEV_PU_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UC_LOW_SPEED` reader - enable USB low speed: 0=12Mbps, 1=1.5Mbps
        pub type UC_LOW_SPEED_R = crate::BitReader;
        ///Field `UC_LOW_SPEED` writer - enable USB low speed: 0=12Mbps, 1=1.5Mbps
        pub type UC_LOW_SPEED_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UC_HOST_MODE` reader - enable USB host mode: 0=device mode, 1=host mode
        pub type UC_HOST_MODE_R = crate::BitReader;
        ///Field `UC_HOST_MODE` writer - enable USB host mode: 0=device mode, 1=host mode
        pub type UC_HOST_MODE_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - DMA enable and DMA interrupt enable for USB
            #[inline(always)]
            pub fn uc_dma_en(&self) -> UC_DMA_EN_R {
                UC_DMA_EN_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - force clear FIFO and count of USB
            #[inline(always)]
            pub fn uc_clr_all(&self) -> UC_CLR_ALL_R {
                UC_CLR_ALL_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - force reset USB SIE, need software clear
            #[inline(always)]
            pub fn uc_reset_sie(&self) -> UC_RESET_SIE_R {
                UC_RESET_SIE_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - enable automatic responding busy for device mode or automatic pause for host mode during interrupt flag UIF_TRANSFER valid
            #[inline(always)]
            pub fn uc_int_busy(&self) -> UC_INT_BUSY_R {
                UC_INT_BUSY_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bits 4:5 - bit mask of USB system control
            #[inline(always)]
            pub fn mask_uc_sys_ctrl(&self) -> MASK_UC_SYS_CTRL_R {
                MASK_UC_SYS_CTRL_R::new((self.bits >> 4) & 3)
            }
            ///Bit 5 - USB device enable and internal pullup resistance enable
            #[inline(always)]
            pub fn uc_dev_pu_en(&self) -> UC_DEV_PU_EN_R {
                UC_DEV_PU_EN_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - enable USB low speed: 0=12Mbps, 1=1.5Mbps
            #[inline(always)]
            pub fn uc_low_speed(&self) -> UC_LOW_SPEED_R {
                UC_LOW_SPEED_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - enable USB host mode: 0=device mode, 1=host mode
            #[inline(always)]
            pub fn uc_host_mode(&self) -> UC_HOST_MODE_R {
                UC_HOST_MODE_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - DMA enable and DMA interrupt enable for USB
            #[inline(always)]
            #[must_use]
            pub fn uc_dma_en(&mut self) -> UC_DMA_EN_W<CTRL_SPEC> {
                UC_DMA_EN_W::new(self, 0)
            }
            ///Bit 1 - force clear FIFO and count of USB
            #[inline(always)]
            #[must_use]
            pub fn uc_clr_all(&mut self) -> UC_CLR_ALL_W<CTRL_SPEC> {
                UC_CLR_ALL_W::new(self, 1)
            }
            ///Bit 2 - force reset USB SIE, need software clear
            #[inline(always)]
            #[must_use]
            pub fn uc_reset_sie(&mut self) -> UC_RESET_SIE_W<CTRL_SPEC> {
                UC_RESET_SIE_W::new(self, 2)
            }
            ///Bit 3 - enable automatic responding busy for device mode or automatic pause for host mode during interrupt flag UIF_TRANSFER valid
            #[inline(always)]
            #[must_use]
            pub fn uc_int_busy(&mut self) -> UC_INT_BUSY_W<CTRL_SPEC> {
                UC_INT_BUSY_W::new(self, 3)
            }
            ///Bits 4:5 - bit mask of USB system control
            #[inline(always)]
            #[must_use]
            pub fn mask_uc_sys_ctrl(&mut self) -> MASK_UC_SYS_CTRL_W<CTRL_SPEC> {
                MASK_UC_SYS_CTRL_W::new(self, 4)
            }
            ///Bit 5 - USB device enable and internal pullup resistance enable
            #[inline(always)]
            #[must_use]
            pub fn uc_dev_pu_en(&mut self) -> UC_DEV_PU_EN_W<CTRL_SPEC> {
                UC_DEV_PU_EN_W::new(self, 5)
            }
            ///Bit 6 - enable USB low speed: 0=12Mbps, 1=1.5Mbps
            #[inline(always)]
            #[must_use]
            pub fn uc_low_speed(&mut self) -> UC_LOW_SPEED_W<CTRL_SPEC> {
                UC_LOW_SPEED_W::new(self, 6)
            }
            ///Bit 7 - enable USB host mode: 0=device mode, 1=host mode
            #[inline(always)]
            #[must_use]
            pub fn uc_host_mode(&mut self) -> UC_HOST_MODE_W<CTRL_SPEC> {
                UC_HOST_MODE_W::new(self, 7)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///USB2 base control
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`ctrl::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ctrl::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct CTRL_SPEC;
        impl crate::RegisterSpec for CTRL_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`ctrl::R`](R) reader structure
        impl crate::Readable for CTRL_SPEC {}
        ///`write(|w| ..)` method takes [`ctrl::W`](W) writer structure
        impl crate::Writable for CTRL_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets CTRL to value 0x06
        impl crate::Resettable for CTRL_SPEC {
            const RESET_VALUE: u8 = 0x06;
        }
    }
    ///DEV_CTRL__R8_U2HOST_CTRL (rw) register accessor: USB2 device physical prot control
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`dev_ctrl__r8_u2host_ctrl::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dev_ctrl__r8_u2host_ctrl::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@dev_ctrl__r8_u2host_ctrl`]
    ///module
    pub type DEV_CTRL__R8_U2HOST_CTRL =
        crate::Reg<dev_ctrl__r8_u2host_ctrl::DEV_CTRL__R8_U2HOST_CTRL_SPEC>;
    ///USB2 device physical prot control
    pub mod dev_ctrl__r8_u2host_ctrl {
        ///Register `DEV_CTRL__R8_U2HOST_CTRL` reader
        pub type R = crate::R<DEV_CTRL__R8_U2HOST_CTRL_SPEC>;
        ///Register `DEV_CTRL__R8_U2HOST_CTRL` writer
        pub type W = crate::W<DEV_CTRL__R8_U2HOST_CTRL_SPEC>;
        ///Field `UD_PORT_EN__RB_UH_PORT_EN` reader - enable USB physical port I-O: 0=disable, 1=enable;enable USB port: 0=disable, 1=enable port, automatic disabled if USB device detached
        pub type UD_PORT_EN__RB_UH_PORT_EN_R = crate::BitReader;
        ///Field `UD_PORT_EN__RB_UH_PORT_EN` writer - enable USB physical port I-O: 0=disable, 1=enable;enable USB port: 0=disable, 1=enable port, automatic disabled if USB device detached
        pub type UD_PORT_EN__RB_UH_PORT_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UD_GP_BIT__RB_UH_BUS_RESET` reader - general purpose bit;control USB bus reset: 0=normal, 1=force bus reset
        pub type UD_GP_BIT__RB_UH_BUS_RESET_R = crate::BitReader;
        ///Field `UD_GP_BIT__RB_UH_BUS_RESET` writer - general purpose bit;control USB bus reset: 0=normal, 1=force bus reset
        pub type UD_GP_BIT__RB_UH_BUS_RESET_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UD_LOW_SPEED__RB_UH_LOW_SPEED` reader - enable USB physical port low speed: 0=full speed, 1=low speed;enable USB port low speed: 0=full speed, 1=low speed
        pub type UD_LOW_SPEED__RB_UH_LOW_SPEED_R = crate::BitReader;
        ///Field `UD_LOW_SPEED__RB_UH_LOW_SPEED` writer - enable USB physical port low speed: 0=full speed, 1=low speed;enable USB port low speed: 0=full speed, 1=low speed
        pub type UD_LOW_SPEED__RB_UH_LOW_SPEED_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UD_DM_PIN__RB_UH_DM_PIN` reader - ReadOnly: indicate current UDM pin level
        pub type UD_DM_PIN__RB_UH_DM_PIN_R = crate::BitReader;
        ///Field `UD_DP_PIN__RB_UH_DP_PIN` reader - ReadOnly: indicate current UDP pin level
        pub type UD_DP_PIN__RB_UH_DP_PIN_R = crate::BitReader;
        ///Field `UD_PD_DIS__RB_UH_PD_DIS` reader - disable USB UDP-UDM pulldown resistance: 0=enable pulldown, 1=disable
        pub type UD_PD_DIS__RB_UH_PD_DIS_R = crate::BitReader;
        impl R {
            ///Bit 0 - enable USB physical port I-O: 0=disable, 1=enable;enable USB port: 0=disable, 1=enable port, automatic disabled if USB device detached
            #[inline(always)]
            pub fn ud_port_en__rb_uh_port_en(&self) -> UD_PORT_EN__RB_UH_PORT_EN_R {
                UD_PORT_EN__RB_UH_PORT_EN_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - general purpose bit;control USB bus reset: 0=normal, 1=force bus reset
            #[inline(always)]
            pub fn ud_gp_bit__rb_uh_bus_reset(&self) -> UD_GP_BIT__RB_UH_BUS_RESET_R {
                UD_GP_BIT__RB_UH_BUS_RESET_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - enable USB physical port low speed: 0=full speed, 1=low speed;enable USB port low speed: 0=full speed, 1=low speed
            #[inline(always)]
            pub fn ud_low_speed__rb_uh_low_speed(&self) -> UD_LOW_SPEED__RB_UH_LOW_SPEED_R {
                UD_LOW_SPEED__RB_UH_LOW_SPEED_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 4 - ReadOnly: indicate current UDM pin level
            #[inline(always)]
            pub fn ud_dm_pin__rb_uh_dm_pin(&self) -> UD_DM_PIN__RB_UH_DM_PIN_R {
                UD_DM_PIN__RB_UH_DM_PIN_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - ReadOnly: indicate current UDP pin level
            #[inline(always)]
            pub fn ud_dp_pin__rb_uh_dp_pin(&self) -> UD_DP_PIN__RB_UH_DP_PIN_R {
                UD_DP_PIN__RB_UH_DP_PIN_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 7 - disable USB UDP-UDM pulldown resistance: 0=enable pulldown, 1=disable
            #[inline(always)]
            pub fn ud_pd_dis__rb_uh_pd_dis(&self) -> UD_PD_DIS__RB_UH_PD_DIS_R {
                UD_PD_DIS__RB_UH_PD_DIS_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - enable USB physical port I-O: 0=disable, 1=enable;enable USB port: 0=disable, 1=enable port, automatic disabled if USB device detached
            #[inline(always)]
            #[must_use]
            pub fn ud_port_en__rb_uh_port_en(
                &mut self,
            ) -> UD_PORT_EN__RB_UH_PORT_EN_W<DEV_CTRL__R8_U2HOST_CTRL_SPEC> {
                UD_PORT_EN__RB_UH_PORT_EN_W::new(self, 0)
            }
            ///Bit 1 - general purpose bit;control USB bus reset: 0=normal, 1=force bus reset
            #[inline(always)]
            #[must_use]
            pub fn ud_gp_bit__rb_uh_bus_reset(
                &mut self,
            ) -> UD_GP_BIT__RB_UH_BUS_RESET_W<DEV_CTRL__R8_U2HOST_CTRL_SPEC> {
                UD_GP_BIT__RB_UH_BUS_RESET_W::new(self, 1)
            }
            ///Bit 2 - enable USB physical port low speed: 0=full speed, 1=low speed;enable USB port low speed: 0=full speed, 1=low speed
            #[inline(always)]
            #[must_use]
            pub fn ud_low_speed__rb_uh_low_speed(
                &mut self,
            ) -> UD_LOW_SPEED__RB_UH_LOW_SPEED_W<DEV_CTRL__R8_U2HOST_CTRL_SPEC> {
                UD_LOW_SPEED__RB_UH_LOW_SPEED_W::new(self, 2)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///USB2 device physical prot control
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`dev_ctrl__r8_u2host_ctrl::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dev_ctrl__r8_u2host_ctrl::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct DEV_CTRL__R8_U2HOST_CTRL_SPEC;
        impl crate::RegisterSpec for DEV_CTRL__R8_U2HOST_CTRL_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`dev_ctrl__r8_u2host_ctrl::R`](R) reader structure
        impl crate::Readable for DEV_CTRL__R8_U2HOST_CTRL_SPEC {}
        ///`write(|w| ..)` method takes [`dev_ctrl__r8_u2host_ctrl::W`](W) writer structure
        impl crate::Writable for DEV_CTRL__R8_U2HOST_CTRL_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets DEV_CTRL__R8_U2HOST_CTRL to value 0
        impl crate::Resettable for DEV_CTRL__R8_U2HOST_CTRL_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///INT_EN (rw) register accessor: USB2 interrupt enable
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`int_en::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`int_en::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@int_en`]
    ///module
    pub type INT_EN = crate::Reg<int_en::INT_EN_SPEC>;
    ///USB2 interrupt enable
    pub mod int_en {
        ///Register `INT_EN` reader
        pub type R = crate::R<INT_EN_SPEC>;
        ///Register `INT_EN` writer
        pub type W = crate::W<INT_EN_SPEC>;
        ///Field `UIE_BUS_RST__RB_UIE_DETECT` reader - enable interrupt for USB bus reset event for USB device mode;enable interrupt for USB device detected event for USB host mode
        pub type UIE_BUS_RST__RB_UIE_DETECT_R = crate::BitReader;
        ///Field `UIE_BUS_RST__RB_UIE_DETECT` writer - enable interrupt for USB bus reset event for USB device mode;enable interrupt for USB device detected event for USB host mode
        pub type UIE_BUS_RST__RB_UIE_DETECT_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UIE_TRANSFER` reader - enable interrupt for USB transfer completion
        pub type UIE_TRANSFER_R = crate::BitReader;
        ///Field `UIE_TRANSFER` writer - enable interrupt for USB transfer completion
        pub type UIE_TRANSFER_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UIE_SUSPEND` reader - enable interrupt for USB suspend or resume event
        pub type UIE_SUSPEND_R = crate::BitReader;
        ///Field `UIE_SUSPEND` writer - enable interrupt for USB suspend or resume event
        pub type UIE_SUSPEND_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UIE_HST_SOF` reader - enable interrupt for host SOF timer action for USB host mode
        pub type UIE_HST_SOF_R = crate::BitReader;
        ///Field `UIE_HST_SOF` writer - enable interrupt for host SOF timer action for USB host mode
        pub type UIE_HST_SOF_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UIE_FIFO_OV` reader - enable interrupt for FIFO overflow
        pub type UIE_FIFO_OV_R = crate::BitReader;
        ///Field `UIE_FIFO_OV` writer - enable interrupt for FIFO overflow
        pub type UIE_FIFO_OV_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UIE_DEV_NAK` reader - enable interrupt for NAK responded for USB device mode
        pub type UIE_DEV_NAK_R = crate::BitReader;
        ///Field `UIE_DEV_NAK` writer - enable interrupt for NAK responded for USB device mode
        pub type UIE_DEV_NAK_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UIE_DEV_SOF` reader - enable interrupt for SOF received for USB device mode
        pub type UIE_DEV_SOF_R = crate::BitReader;
        ///Field `UIE_DEV_SOF` writer - enable interrupt for SOF received for USB device mode
        pub type UIE_DEV_SOF_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - enable interrupt for USB bus reset event for USB device mode;enable interrupt for USB device detected event for USB host mode
            #[inline(always)]
            pub fn uie_bus_rst__rb_uie_detect(&self) -> UIE_BUS_RST__RB_UIE_DETECT_R {
                UIE_BUS_RST__RB_UIE_DETECT_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - enable interrupt for USB transfer completion
            #[inline(always)]
            pub fn uie_transfer(&self) -> UIE_TRANSFER_R {
                UIE_TRANSFER_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - enable interrupt for USB suspend or resume event
            #[inline(always)]
            pub fn uie_suspend(&self) -> UIE_SUSPEND_R {
                UIE_SUSPEND_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - enable interrupt for host SOF timer action for USB host mode
            #[inline(always)]
            pub fn uie_hst_sof(&self) -> UIE_HST_SOF_R {
                UIE_HST_SOF_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - enable interrupt for FIFO overflow
            #[inline(always)]
            pub fn uie_fifo_ov(&self) -> UIE_FIFO_OV_R {
                UIE_FIFO_OV_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 6 - enable interrupt for NAK responded for USB device mode
            #[inline(always)]
            pub fn uie_dev_nak(&self) -> UIE_DEV_NAK_R {
                UIE_DEV_NAK_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - enable interrupt for SOF received for USB device mode
            #[inline(always)]
            pub fn uie_dev_sof(&self) -> UIE_DEV_SOF_R {
                UIE_DEV_SOF_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - enable interrupt for USB bus reset event for USB device mode;enable interrupt for USB device detected event for USB host mode
            #[inline(always)]
            #[must_use]
            pub fn uie_bus_rst__rb_uie_detect(
                &mut self,
            ) -> UIE_BUS_RST__RB_UIE_DETECT_W<INT_EN_SPEC> {
                UIE_BUS_RST__RB_UIE_DETECT_W::new(self, 0)
            }
            ///Bit 1 - enable interrupt for USB transfer completion
            #[inline(always)]
            #[must_use]
            pub fn uie_transfer(&mut self) -> UIE_TRANSFER_W<INT_EN_SPEC> {
                UIE_TRANSFER_W::new(self, 1)
            }
            ///Bit 2 - enable interrupt for USB suspend or resume event
            #[inline(always)]
            #[must_use]
            pub fn uie_suspend(&mut self) -> UIE_SUSPEND_W<INT_EN_SPEC> {
                UIE_SUSPEND_W::new(self, 2)
            }
            ///Bit 3 - enable interrupt for host SOF timer action for USB host mode
            #[inline(always)]
            #[must_use]
            pub fn uie_hst_sof(&mut self) -> UIE_HST_SOF_W<INT_EN_SPEC> {
                UIE_HST_SOF_W::new(self, 3)
            }
            ///Bit 4 - enable interrupt for FIFO overflow
            #[inline(always)]
            #[must_use]
            pub fn uie_fifo_ov(&mut self) -> UIE_FIFO_OV_W<INT_EN_SPEC> {
                UIE_FIFO_OV_W::new(self, 4)
            }
            ///Bit 6 - enable interrupt for NAK responded for USB device mode
            #[inline(always)]
            #[must_use]
            pub fn uie_dev_nak(&mut self) -> UIE_DEV_NAK_W<INT_EN_SPEC> {
                UIE_DEV_NAK_W::new(self, 6)
            }
            ///Bit 7 - enable interrupt for SOF received for USB device mode
            #[inline(always)]
            #[must_use]
            pub fn uie_dev_sof(&mut self) -> UIE_DEV_SOF_W<INT_EN_SPEC> {
                UIE_DEV_SOF_W::new(self, 7)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///USB2 interrupt enable
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`int_en::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`int_en::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct INT_EN_SPEC;
        impl crate::RegisterSpec for INT_EN_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`int_en::R`](R) reader structure
        impl crate::Readable for INT_EN_SPEC {}
        ///`write(|w| ..)` method takes [`int_en::W`](W) writer structure
        impl crate::Writable for INT_EN_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets INT_EN to value 0
        impl crate::Resettable for INT_EN_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///DEV_AD (rw) register accessor: USB2 device address
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`dev_ad::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dev_ad::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@dev_ad`]
    ///module
    pub type DEV_AD = crate::Reg<dev_ad::DEV_AD_SPEC>;
    ///USB2 device address
    pub mod dev_ad {
        ///Register `DEV_AD` reader
        pub type R = crate::R<DEV_AD_SPEC>;
        ///Register `DEV_AD` writer
        pub type W = crate::W<DEV_AD_SPEC>;
        ///Field `MASK_USB_ADDR` reader - bit mask for USB device address
        pub type MASK_USB_ADDR_R = crate::FieldReader;
        ///Field `MASK_USB_ADDR` writer - bit mask for USB device address
        pub type MASK_USB_ADDR_W<'a, REG> = crate::FieldWriter<'a, REG, 7>;
        ///Field `UDA_GP_BIT` reader - general purpose bit
        pub type UDA_GP_BIT_R = crate::BitReader;
        ///Field `UDA_GP_BIT` writer - general purpose bit
        pub type UDA_GP_BIT_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bits 0:6 - bit mask for USB device address
            #[inline(always)]
            pub fn mask_usb_addr(&self) -> MASK_USB_ADDR_R {
                MASK_USB_ADDR_R::new(self.bits & 0x7f)
            }
            ///Bit 7 - general purpose bit
            #[inline(always)]
            pub fn uda_gp_bit(&self) -> UDA_GP_BIT_R {
                UDA_GP_BIT_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:6 - bit mask for USB device address
            #[inline(always)]
            #[must_use]
            pub fn mask_usb_addr(&mut self) -> MASK_USB_ADDR_W<DEV_AD_SPEC> {
                MASK_USB_ADDR_W::new(self, 0)
            }
            ///Bit 7 - general purpose bit
            #[inline(always)]
            #[must_use]
            pub fn uda_gp_bit(&mut self) -> UDA_GP_BIT_W<DEV_AD_SPEC> {
                UDA_GP_BIT_W::new(self, 7)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///USB2 device address
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`dev_ad::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dev_ad::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct DEV_AD_SPEC;
        impl crate::RegisterSpec for DEV_AD_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`dev_ad::R`](R) reader structure
        impl crate::Readable for DEV_AD_SPEC {}
        ///`write(|w| ..)` method takes [`dev_ad::W`](W) writer structure
        impl crate::Writable for DEV_AD_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets DEV_AD to value 0
        impl crate::Resettable for DEV_AD_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///MIS_ST (r) register accessor: USB2 miscellaneous status
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`mis_st::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@mis_st`]
    ///module
    pub type MIS_ST = crate::Reg<mis_st::MIS_ST_SPEC>;
    ///USB2 miscellaneous status
    pub mod mis_st {
        ///Register `MIS_ST` reader
        pub type R = crate::R<MIS_ST_SPEC>;
        ///Field `UMS_DEV_ATTACH` reader - RO, indicate device attached status on USB host
        pub type UMS_DEV_ATTACH_R = crate::BitReader;
        ///Field `UMS_DM_LEVEL` reader - RO, indicate UDM level saved at device attached to USB host
        pub type UMS_DM_LEVEL_R = crate::BitReader;
        ///Field `UMS_SUSPEND` reader - RO, indicate USB suspend status
        pub type UMS_SUSPEND_R = crate::BitReader;
        ///Field `UMS_BUS_RESET` reader - RO, indicate USB bus reset status
        pub type UMS_BUS_RESET_R = crate::BitReader;
        ///Field `UMS_R_FIFO_RDY` reader - RO, indicate USB receiving FIFO ready status (not empty)
        pub type UMS_R_FIFO_RDY_R = crate::BitReader;
        ///Field `UMS_SIE_FREE` reader - RO, indicate USB SIE free status
        pub type UMS_SIE_FREE_R = crate::BitReader;
        ///Field `UMS_SOF_ACT` reader - RO, indicate host SOF timer action status for USB host
        pub type UMS_SOF_ACT_R = crate::BitReader;
        ///Field `UMS_SOF_PRES` reader - RO, indicate host SOF timer presage status
        pub type UMS_SOF_PRES_R = crate::BitReader;
        impl R {
            ///Bit 0 - RO, indicate device attached status on USB host
            #[inline(always)]
            pub fn ums_dev_attach(&self) -> UMS_DEV_ATTACH_R {
                UMS_DEV_ATTACH_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RO, indicate UDM level saved at device attached to USB host
            #[inline(always)]
            pub fn ums_dm_level(&self) -> UMS_DM_LEVEL_R {
                UMS_DM_LEVEL_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RO, indicate USB suspend status
            #[inline(always)]
            pub fn ums_suspend(&self) -> UMS_SUSPEND_R {
                UMS_SUSPEND_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RO, indicate USB bus reset status
            #[inline(always)]
            pub fn ums_bus_reset(&self) -> UMS_BUS_RESET_R {
                UMS_BUS_RESET_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RO, indicate USB receiving FIFO ready status (not empty)
            #[inline(always)]
            pub fn ums_r_fifo_rdy(&self) -> UMS_R_FIFO_RDY_R {
                UMS_R_FIFO_RDY_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - RO, indicate USB SIE free status
            #[inline(always)]
            pub fn ums_sie_free(&self) -> UMS_SIE_FREE_R {
                UMS_SIE_FREE_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - RO, indicate host SOF timer action status for USB host
            #[inline(always)]
            pub fn ums_sof_act(&self) -> UMS_SOF_ACT_R {
                UMS_SOF_ACT_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - RO, indicate host SOF timer presage status
            #[inline(always)]
            pub fn ums_sof_pres(&self) -> UMS_SOF_PRES_R {
                UMS_SOF_PRES_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        ///USB2 miscellaneous status
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`mis_st::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct MIS_ST_SPEC;
        impl crate::RegisterSpec for MIS_ST_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`mis_st::R`](R) reader structure
        impl crate::Readable for MIS_ST_SPEC {}
        ///`reset()` method sets MIS_ST to value 0
        impl crate::Resettable for MIS_ST_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///INT_FG (rw) register accessor: USB2 interrupt flag
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`int_fg::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`int_fg::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@int_fg`]
    ///module
    pub type INT_FG = crate::Reg<int_fg::INT_FG_SPEC>;
    ///USB2 interrupt flag
    pub mod int_fg {
        ///Register `INT_FG` reader
        pub type R = crate::R<INT_FG_SPEC>;
        ///Register `INT_FG` writer
        pub type W = crate::W<INT_FG_SPEC>;
        ///Field `UIF_BUS_RST__RB_UIF_DETECT` reader - RW,bus reset event interrupt flag for USB device mode, direct bit address clear or write 1 to clear;device detected event interrupt flag for USB host mode, direct bit address clear or write 1 to clear
        pub type UIF_BUS_RST__RB_UIF_DETECT_R = crate::BitReader;
        ///Field `UIF_BUS_RST__RB_UIF_DETECT` writer - RW,bus reset event interrupt flag for USB device mode, direct bit address clear or write 1 to clear;device detected event interrupt flag for USB host mode, direct bit address clear or write 1 to clear
        pub type UIF_BUS_RST__RB_UIF_DETECT_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UIF_TRANSFER` reader - RW,USB transfer completion interrupt flag, direct bit address clear or write 1 to clear
        pub type UIF_TRANSFER_R = crate::BitReader;
        ///Field `UIF_TRANSFER` writer - RW,USB transfer completion interrupt flag, direct bit address clear or write 1 to clear
        pub type UIF_TRANSFER_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UIF_SUSPEND` reader - RW,USB suspend or resume event interrupt flag, direct bit address clear or write 1 to clear
        pub type UIF_SUSPEND_R = crate::BitReader;
        ///Field `UIF_SUSPEND` writer - RW,USB suspend or resume event interrupt flag, direct bit address clear or write 1 to clear
        pub type UIF_SUSPEND_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UIF_HST_SOF` reader - RW,host SOF timer interrupt flag for USB host, direct bit address clear or write 1 to clear
        pub type UIF_HST_SOF_R = crate::BitReader;
        ///Field `UIF_HST_SOF` writer - RW,host SOF timer interrupt flag for USB host, direct bit address clear or write 1 to clear
        pub type UIF_HST_SOF_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UIF_FIFO_OV` reader - RW,FIFO overflow interrupt flag for USB, direct bit address clear or write 1 to clear
        pub type UIF_FIFO_OV_R = crate::BitReader;
        ///Field `UIF_FIFO_OV` writer - RW,FIFO overflow interrupt flag for USB, direct bit address clear or write 1 to clear
        pub type UIF_FIFO_OV_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `U_SIE_FREE` reader - RO, indicate USB SIE free status
        pub type U_SIE_FREE_R = crate::BitReader;
        ///Field `U_TOG_OK` reader - RO, indicate current USB transfer toggle is OK
        pub type U_TOG_OK_R = crate::BitReader;
        ///Field `U_IS_NAK` reader - RO, indicate current USB transfer is NAK received
        pub type U_IS_NAK_R = crate::BitReader;
        impl R {
            ///Bit 0 - RW,bus reset event interrupt flag for USB device mode, direct bit address clear or write 1 to clear;device detected event interrupt flag for USB host mode, direct bit address clear or write 1 to clear
            #[inline(always)]
            pub fn uif_bus_rst__rb_uif_detect(&self) -> UIF_BUS_RST__RB_UIF_DETECT_R {
                UIF_BUS_RST__RB_UIF_DETECT_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RW,USB transfer completion interrupt flag, direct bit address clear or write 1 to clear
            #[inline(always)]
            pub fn uif_transfer(&self) -> UIF_TRANSFER_R {
                UIF_TRANSFER_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RW,USB suspend or resume event interrupt flag, direct bit address clear or write 1 to clear
            #[inline(always)]
            pub fn uif_suspend(&self) -> UIF_SUSPEND_R {
                UIF_SUSPEND_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RW,host SOF timer interrupt flag for USB host, direct bit address clear or write 1 to clear
            #[inline(always)]
            pub fn uif_hst_sof(&self) -> UIF_HST_SOF_R {
                UIF_HST_SOF_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RW,FIFO overflow interrupt flag for USB, direct bit address clear or write 1 to clear
            #[inline(always)]
            pub fn uif_fifo_ov(&self) -> UIF_FIFO_OV_R {
                UIF_FIFO_OV_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - RO, indicate USB SIE free status
            #[inline(always)]
            pub fn u_sie_free(&self) -> U_SIE_FREE_R {
                U_SIE_FREE_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - RO, indicate current USB transfer toggle is OK
            #[inline(always)]
            pub fn u_tog_ok(&self) -> U_TOG_OK_R {
                U_TOG_OK_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - RO, indicate current USB transfer is NAK received
            #[inline(always)]
            pub fn u_is_nak(&self) -> U_IS_NAK_R {
                U_IS_NAK_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RW,bus reset event interrupt flag for USB device mode, direct bit address clear or write 1 to clear;device detected event interrupt flag for USB host mode, direct bit address clear or write 1 to clear
            #[inline(always)]
            #[must_use]
            pub fn uif_bus_rst__rb_uif_detect(
                &mut self,
            ) -> UIF_BUS_RST__RB_UIF_DETECT_W<INT_FG_SPEC> {
                UIF_BUS_RST__RB_UIF_DETECT_W::new(self, 0)
            }
            ///Bit 1 - RW,USB transfer completion interrupt flag, direct bit address clear or write 1 to clear
            #[inline(always)]
            #[must_use]
            pub fn uif_transfer(&mut self) -> UIF_TRANSFER_W<INT_FG_SPEC> {
                UIF_TRANSFER_W::new(self, 1)
            }
            ///Bit 2 - RW,USB suspend or resume event interrupt flag, direct bit address clear or write 1 to clear
            #[inline(always)]
            #[must_use]
            pub fn uif_suspend(&mut self) -> UIF_SUSPEND_W<INT_FG_SPEC> {
                UIF_SUSPEND_W::new(self, 2)
            }
            ///Bit 3 - RW,host SOF timer interrupt flag for USB host, direct bit address clear or write 1 to clear
            #[inline(always)]
            #[must_use]
            pub fn uif_hst_sof(&mut self) -> UIF_HST_SOF_W<INT_FG_SPEC> {
                UIF_HST_SOF_W::new(self, 3)
            }
            ///Bit 4 - RW,FIFO overflow interrupt flag for USB, direct bit address clear or write 1 to clear
            #[inline(always)]
            #[must_use]
            pub fn uif_fifo_ov(&mut self) -> UIF_FIFO_OV_W<INT_FG_SPEC> {
                UIF_FIFO_OV_W::new(self, 4)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///USB2 interrupt flag
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`int_fg::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`int_fg::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct INT_FG_SPEC;
        impl crate::RegisterSpec for INT_FG_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`int_fg::R`](R) reader structure
        impl crate::Readable for INT_FG_SPEC {}
        ///`write(|w| ..)` method takes [`int_fg::W`](W) writer structure
        impl crate::Writable for INT_FG_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets INT_FG to value 0x20
        impl crate::Resettable for INT_FG_SPEC {
            const RESET_VALUE: u8 = 0x20;
        }
    }
    ///INT_ST (r) register accessor: USB2 interrupt status
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`int_st::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@int_st`]
    ///module
    pub type INT_ST = crate::Reg<int_st::INT_ST_SPEC>;
    ///USB2 interrupt status
    pub mod int_st {
        ///Register `INT_ST` reader
        pub type R = crate::R<INT_ST_SPEC>;
        ///Field `MASK_UIS_H_RES__MASK_UIS_ENDP` reader - RO, bit mask of current transfer handshake response for USB host mode: 0000=no response, time out from device, others=handshake response PID received;RO, bit mask of current transfer endpoint number for USB device mode
        pub type MASK_UIS_H_RES__MASK_UIS_ENDP_R = crate::FieldReader;
        ///Field `MASK_UIS_TOKEN` reader - RO, bit mask of current token PID code received for USB device mode
        pub type MASK_UIS_TOKEN_R = crate::FieldReader;
        ///Field `UIS_TOG_OK` reader - RO, indicate current USB transfer toggle is OK
        pub type UIS_TOG_OK_R = crate::BitReader;
        ///Field `UIS_SETUP_ACT` reader - RO, indicate current USB transfer is NAK received for USB device mode
        pub type UIS_SETUP_ACT_R = crate::BitReader;
        impl R {
            ///Bits 0:3 - RO, bit mask of current transfer handshake response for USB host mode: 0000=no response, time out from device, others=handshake response PID received;RO, bit mask of current transfer endpoint number for USB device mode
            #[inline(always)]
            pub fn mask_uis_h_res__mask_uis_endp(&self) -> MASK_UIS_H_RES__MASK_UIS_ENDP_R {
                MASK_UIS_H_RES__MASK_UIS_ENDP_R::new(self.bits & 0x0f)
            }
            ///Bits 4:5 - RO, bit mask of current token PID code received for USB device mode
            #[inline(always)]
            pub fn mask_uis_token(&self) -> MASK_UIS_TOKEN_R {
                MASK_UIS_TOKEN_R::new((self.bits >> 4) & 3)
            }
            ///Bit 6 - RO, indicate current USB transfer toggle is OK
            #[inline(always)]
            pub fn uis_tog_ok(&self) -> UIS_TOG_OK_R {
                UIS_TOG_OK_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - RO, indicate current USB transfer is NAK received for USB device mode
            #[inline(always)]
            pub fn uis_setup_act(&self) -> UIS_SETUP_ACT_R {
                UIS_SETUP_ACT_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        ///USB2 interrupt status
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`int_st::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct INT_ST_SPEC;
        impl crate::RegisterSpec for INT_ST_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`int_st::R`](R) reader structure
        impl crate::Readable for INT_ST_SPEC {}
        ///`reset()` method sets INT_ST to value 0
        impl crate::Resettable for INT_ST_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///RX_LEN (r) register accessor: USB2 receiving length
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`rx_len::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@rx_len`]
    ///module
    pub type RX_LEN = crate::Reg<rx_len::RX_LEN_SPEC>;
    ///USB2 receiving length
    pub mod rx_len {
        ///Register `RX_LEN` reader
        pub type R = crate::R<RX_LEN_SPEC>;
        ///Field `USB_RX_LEN` reader - RO,USB receiving length
        pub type USB_RX_LEN_R = crate::FieldReader;
        impl R {
            ///Bits 0:7 - RO,USB receiving length
            #[inline(always)]
            pub fn usb_rx_len(&self) -> USB_RX_LEN_R {
                USB_RX_LEN_R::new(self.bits)
            }
        }
        ///USB2 receiving length
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`rx_len::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct RX_LEN_SPEC;
        impl crate::RegisterSpec for RX_LEN_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`rx_len::R`](R) reader structure
        impl crate::Readable for RX_LEN_SPEC {}
        ///`reset()` method sets RX_LEN to value 0
        impl crate::Resettable for RX_LEN_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///EP4_1_MOD (rw) register accessor: endpoint 4/1 mode
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`ep4_1_mod::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ep4_1_mod::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@ep4_1_mod`]
    ///module
    pub type EP4_1_MOD = crate::Reg<ep4_1_mod::EP4_1_MOD_SPEC>;
    ///endpoint 4/1 mode
    pub mod ep4_1_mod {
        ///Register `EP4_1_MOD` reader
        pub type R = crate::R<EP4_1_MOD_SPEC>;
        ///Register `EP4_1_MOD` writer
        pub type W = crate::W<EP4_1_MOD_SPEC>;
        ///Field `UEP4_TX_EN` reader - enable USB endpoint 4 transmittal (IN)
        pub type UEP4_TX_EN_R = crate::BitReader;
        ///Field `UEP4_TX_EN` writer - enable USB endpoint 4 transmittal (IN)
        pub type UEP4_TX_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UEP4_RX_EN` reader - enable USB endpoint 4 receiving (OUT)
        pub type UEP4_RX_EN_R = crate::BitReader;
        ///Field `UEP4_RX_EN` writer - enable USB endpoint 4 receiving (OUT)
        pub type UEP4_RX_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UEP1_BUF_MOD` reader - buffer mode of USB endpoint 1
        pub type UEP1_BUF_MOD_R = crate::BitReader;
        ///Field `UEP1_BUF_MOD` writer - buffer mode of USB endpoint 1
        pub type UEP1_BUF_MOD_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UEP1_TX_EN` reader - enable USB endpoint 1 transmittal (IN)
        pub type UEP1_TX_EN_R = crate::BitReader;
        ///Field `UEP1_TX_EN` writer - enable USB endpoint 1 transmittal (IN)
        pub type UEP1_TX_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UEP1_RX_EN` reader - enable USB endpoint 1 receiving (OUT)
        pub type UEP1_RX_EN_R = crate::BitReader;
        ///Field `UEP1_RX_EN` writer - enable USB endpoint 1 receiving (OUT)
        pub type UEP1_RX_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 2 - enable USB endpoint 4 transmittal (IN)
            #[inline(always)]
            pub fn uep4_tx_en(&self) -> UEP4_TX_EN_R {
                UEP4_TX_EN_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - enable USB endpoint 4 receiving (OUT)
            #[inline(always)]
            pub fn uep4_rx_en(&self) -> UEP4_RX_EN_R {
                UEP4_RX_EN_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - buffer mode of USB endpoint 1
            #[inline(always)]
            pub fn uep1_buf_mod(&self) -> UEP1_BUF_MOD_R {
                UEP1_BUF_MOD_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 6 - enable USB endpoint 1 transmittal (IN)
            #[inline(always)]
            pub fn uep1_tx_en(&self) -> UEP1_TX_EN_R {
                UEP1_TX_EN_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - enable USB endpoint 1 receiving (OUT)
            #[inline(always)]
            pub fn uep1_rx_en(&self) -> UEP1_RX_EN_R {
                UEP1_RX_EN_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 2 - enable USB endpoint 4 transmittal (IN)
            #[inline(always)]
            #[must_use]
            pub fn uep4_tx_en(&mut self) -> UEP4_TX_EN_W<EP4_1_MOD_SPEC> {
                UEP4_TX_EN_W::new(self, 2)
            }
            ///Bit 3 - enable USB endpoint 4 receiving (OUT)
            #[inline(always)]
            #[must_use]
            pub fn uep4_rx_en(&mut self) -> UEP4_RX_EN_W<EP4_1_MOD_SPEC> {
                UEP4_RX_EN_W::new(self, 3)
            }
            ///Bit 4 - buffer mode of USB endpoint 1
            #[inline(always)]
            #[must_use]
            pub fn uep1_buf_mod(&mut self) -> UEP1_BUF_MOD_W<EP4_1_MOD_SPEC> {
                UEP1_BUF_MOD_W::new(self, 4)
            }
            ///Bit 6 - enable USB endpoint 1 transmittal (IN)
            #[inline(always)]
            #[must_use]
            pub fn uep1_tx_en(&mut self) -> UEP1_TX_EN_W<EP4_1_MOD_SPEC> {
                UEP1_TX_EN_W::new(self, 6)
            }
            ///Bit 7 - enable USB endpoint 1 receiving (OUT)
            #[inline(always)]
            #[must_use]
            pub fn uep1_rx_en(&mut self) -> UEP1_RX_EN_W<EP4_1_MOD_SPEC> {
                UEP1_RX_EN_W::new(self, 7)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///endpoint 4/1 mode
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`ep4_1_mod::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ep4_1_mod::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct EP4_1_MOD_SPEC;
        impl crate::RegisterSpec for EP4_1_MOD_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`ep4_1_mod::R`](R) reader structure
        impl crate::Readable for EP4_1_MOD_SPEC {}
        ///`write(|w| ..)` method takes [`ep4_1_mod::W`](W) writer structure
        impl crate::Writable for EP4_1_MOD_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets EP4_1_MOD to value 0
        impl crate::Resettable for EP4_1_MOD_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///EP2_3_MOD__R8_U2H_EP_MOD (rw) register accessor: endpoint 2_3 mode;host endpoint mode
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`ep2_3_mod__r8_u2h_ep_mod::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ep2_3_mod__r8_u2h_ep_mod::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@ep2_3_mod__r8_u2h_ep_mod`]
    ///module
    pub type EP2_3_MOD__R8_U2H_EP_MOD =
        crate::Reg<ep2_3_mod__r8_u2h_ep_mod::EP2_3_MOD__R8_U2H_EP_MOD_SPEC>;
    ///endpoint 2_3 mode;host endpoint mode
    pub mod ep2_3_mod__r8_u2h_ep_mod {
        ///Register `EP2_3_MOD__R8_U2H_EP_MOD` reader
        pub type R = crate::R<EP2_3_MOD__R8_U2H_EP_MOD_SPEC>;
        ///Register `EP2_3_MOD__R8_U2H_EP_MOD` writer
        pub type W = crate::W<EP2_3_MOD__R8_U2H_EP_MOD_SPEC>;
        ///Field `UEP2_BUF_MOD__RB_UH_EP_RBUF_MOD` reader - buffer mode of USB endpoint 2;buffer mode of USB host IN endpoint
        pub type UEP2_BUF_MOD__RB_UH_EP_RBUF_MOD_R = crate::BitReader;
        ///Field `UEP2_BUF_MOD__RB_UH_EP_RBUF_MOD` writer - buffer mode of USB endpoint 2;buffer mode of USB host IN endpoint
        pub type UEP2_BUF_MOD__RB_UH_EP_RBUF_MOD_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UEP2_TX_EN` reader - enable USB endpoint 2 transmittal (IN)
        pub type UEP2_TX_EN_R = crate::BitReader;
        ///Field `UEP2_TX_EN` writer - enable USB endpoint 2 transmittal (IN)
        pub type UEP2_TX_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UEP2_RX_EN__RB_UH_EP_RX_EN` reader - enable USB endpoint 2 receiving (OUT);enable USB host IN endpoint receiving
        pub type UEP2_RX_EN__RB_UH_EP_RX_EN_R = crate::BitReader;
        ///Field `UEP2_RX_EN__RB_UH_EP_RX_EN` writer - enable USB endpoint 2 receiving (OUT);enable USB host IN endpoint receiving
        pub type UEP2_RX_EN__RB_UH_EP_RX_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UEP3_BUF_MOD__RB_UH_EP_TBUF_MOD` reader - buffer mode of USB endpoint 3;buffer mode of USB host OUT endpoint
        pub type UEP3_BUF_MOD__RB_UH_EP_TBUF_MOD_R = crate::BitReader;
        ///Field `UEP3_BUF_MOD__RB_UH_EP_TBUF_MOD` writer - buffer mode of USB endpoint 3;buffer mode of USB host OUT endpoint
        pub type UEP3_BUF_MOD__RB_UH_EP_TBUF_MOD_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UEP3_TX_EN__RB_UH_EP_TX_EN` reader - enable USB endpoint 3 transmittal (IN);enable USB host OUT endpoint transmittal
        pub type UEP3_TX_EN__RB_UH_EP_TX_EN_R = crate::BitReader;
        ///Field `UEP3_TX_EN__RB_UH_EP_TX_EN` writer - enable USB endpoint 3 transmittal (IN);enable USB host OUT endpoint transmittal
        pub type UEP3_TX_EN__RB_UH_EP_TX_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UEP3_RX_EN` reader - enable USB endpoint 3 receiving (OUT)
        pub type UEP3_RX_EN_R = crate::BitReader;
        ///Field `UEP3_RX_EN` writer - enable USB endpoint 3 receiving (OUT)
        pub type UEP3_RX_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - buffer mode of USB endpoint 2;buffer mode of USB host IN endpoint
            #[inline(always)]
            pub fn uep2_buf_mod__rb_uh_ep_rbuf_mod(&self) -> UEP2_BUF_MOD__RB_UH_EP_RBUF_MOD_R {
                UEP2_BUF_MOD__RB_UH_EP_RBUF_MOD_R::new((self.bits & 1) != 0)
            }
            ///Bit 2 - enable USB endpoint 2 transmittal (IN)
            #[inline(always)]
            pub fn uep2_tx_en(&self) -> UEP2_TX_EN_R {
                UEP2_TX_EN_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - enable USB endpoint 2 receiving (OUT);enable USB host IN endpoint receiving
            #[inline(always)]
            pub fn uep2_rx_en__rb_uh_ep_rx_en(&self) -> UEP2_RX_EN__RB_UH_EP_RX_EN_R {
                UEP2_RX_EN__RB_UH_EP_RX_EN_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - buffer mode of USB endpoint 3;buffer mode of USB host OUT endpoint
            #[inline(always)]
            pub fn uep3_buf_mod__rb_uh_ep_tbuf_mod(&self) -> UEP3_BUF_MOD__RB_UH_EP_TBUF_MOD_R {
                UEP3_BUF_MOD__RB_UH_EP_TBUF_MOD_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 6 - enable USB endpoint 3 transmittal (IN);enable USB host OUT endpoint transmittal
            #[inline(always)]
            pub fn uep3_tx_en__rb_uh_ep_tx_en(&self) -> UEP3_TX_EN__RB_UH_EP_TX_EN_R {
                UEP3_TX_EN__RB_UH_EP_TX_EN_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - enable USB endpoint 3 receiving (OUT)
            #[inline(always)]
            pub fn uep3_rx_en(&self) -> UEP3_RX_EN_R {
                UEP3_RX_EN_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - buffer mode of USB endpoint 2;buffer mode of USB host IN endpoint
            #[inline(always)]
            #[must_use]
            pub fn uep2_buf_mod__rb_uh_ep_rbuf_mod(
                &mut self,
            ) -> UEP2_BUF_MOD__RB_UH_EP_RBUF_MOD_W<EP2_3_MOD__R8_U2H_EP_MOD_SPEC> {
                UEP2_BUF_MOD__RB_UH_EP_RBUF_MOD_W::new(self, 0)
            }
            ///Bit 2 - enable USB endpoint 2 transmittal (IN)
            #[inline(always)]
            #[must_use]
            pub fn uep2_tx_en(&mut self) -> UEP2_TX_EN_W<EP2_3_MOD__R8_U2H_EP_MOD_SPEC> {
                UEP2_TX_EN_W::new(self, 2)
            }
            ///Bit 3 - enable USB endpoint 2 receiving (OUT);enable USB host IN endpoint receiving
            #[inline(always)]
            #[must_use]
            pub fn uep2_rx_en__rb_uh_ep_rx_en(
                &mut self,
            ) -> UEP2_RX_EN__RB_UH_EP_RX_EN_W<EP2_3_MOD__R8_U2H_EP_MOD_SPEC> {
                UEP2_RX_EN__RB_UH_EP_RX_EN_W::new(self, 3)
            }
            ///Bit 4 - buffer mode of USB endpoint 3;buffer mode of USB host OUT endpoint
            #[inline(always)]
            #[must_use]
            pub fn uep3_buf_mod__rb_uh_ep_tbuf_mod(
                &mut self,
            ) -> UEP3_BUF_MOD__RB_UH_EP_TBUF_MOD_W<EP2_3_MOD__R8_U2H_EP_MOD_SPEC> {
                UEP3_BUF_MOD__RB_UH_EP_TBUF_MOD_W::new(self, 4)
            }
            ///Bit 6 - enable USB endpoint 3 transmittal (IN);enable USB host OUT endpoint transmittal
            #[inline(always)]
            #[must_use]
            pub fn uep3_tx_en__rb_uh_ep_tx_en(
                &mut self,
            ) -> UEP3_TX_EN__RB_UH_EP_TX_EN_W<EP2_3_MOD__R8_U2H_EP_MOD_SPEC> {
                UEP3_TX_EN__RB_UH_EP_TX_EN_W::new(self, 6)
            }
            ///Bit 7 - enable USB endpoint 3 receiving (OUT)
            #[inline(always)]
            #[must_use]
            pub fn uep3_rx_en(&mut self) -> UEP3_RX_EN_W<EP2_3_MOD__R8_U2H_EP_MOD_SPEC> {
                UEP3_RX_EN_W::new(self, 7)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///endpoint 2_3 mode;host endpoint mode
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`ep2_3_mod__r8_u2h_ep_mod::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ep2_3_mod__r8_u2h_ep_mod::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct EP2_3_MOD__R8_U2H_EP_MOD_SPEC;
        impl crate::RegisterSpec for EP2_3_MOD__R8_U2H_EP_MOD_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`ep2_3_mod__r8_u2h_ep_mod::R`](R) reader structure
        impl crate::Readable for EP2_3_MOD__R8_U2H_EP_MOD_SPEC {}
        ///`write(|w| ..)` method takes [`ep2_3_mod__r8_u2h_ep_mod::W`](W) writer structure
        impl crate::Writable for EP2_3_MOD__R8_U2H_EP_MOD_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets EP2_3_MOD__R8_U2H_EP_MOD to value 0
        impl crate::Resettable for EP2_3_MOD__R8_U2H_EP_MOD_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///EP567_MOD (rw) register accessor: USB2 endpoint 5/6/7 mode
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`ep567_mod::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ep567_mod::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@ep567_mod`]
    ///module
    pub type EP567_MOD = crate::Reg<ep567_mod::EP567_MOD_SPEC>;
    ///USB2 endpoint 5/6/7 mode
    pub mod ep567_mod {
        ///Register `EP567_MOD` reader
        pub type R = crate::R<EP567_MOD_SPEC>;
        ///Register `EP567_MOD` writer
        pub type W = crate::W<EP567_MOD_SPEC>;
        ///Field `UEP5_TX_EN` reader - enable USB endpoint 5 transmittal (IN)
        pub type UEP5_TX_EN_R = crate::BitReader;
        ///Field `UEP5_TX_EN` writer - enable USB endpoint 5 transmittal (IN)
        pub type UEP5_TX_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UEP5_RX_EN` reader - enable USB endpoint 5 receiving (OUT)
        pub type UEP5_RX_EN_R = crate::BitReader;
        ///Field `UEP5_RX_EN` writer - enable USB endpoint 5 receiving (OUT)
        pub type UEP5_RX_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UEP6_TX_EN` reader - enable USB endpoint 6 transmittal (IN)
        pub type UEP6_TX_EN_R = crate::BitReader;
        ///Field `UEP6_TX_EN` writer - enable USB endpoint 6 transmittal (IN)
        pub type UEP6_TX_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UEP6_RX_EN` reader - enable USB endpoint 6 receiving (OUT)
        pub type UEP6_RX_EN_R = crate::BitReader;
        ///Field `UEP6_RX_EN` writer - enable USB endpoint 6 receiving (OUT)
        pub type UEP6_RX_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UEP7_TX_EN` reader - enable USB endpoint 7 transmittal (IN)
        pub type UEP7_TX_EN_R = crate::BitReader;
        ///Field `UEP7_TX_EN` writer - enable USB endpoint 7 transmittal (IN)
        pub type UEP7_TX_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UEP7_RX_EN` reader - enable USB endpoint 7 receiving (OUT)
        pub type UEP7_RX_EN_R = crate::BitReader;
        ///Field `UEP7_RX_EN` writer - enable USB endpoint 7 receiving (OUT)
        pub type UEP7_RX_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - enable USB endpoint 5 transmittal (IN)
            #[inline(always)]
            pub fn uep5_tx_en(&self) -> UEP5_TX_EN_R {
                UEP5_TX_EN_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - enable USB endpoint 5 receiving (OUT)
            #[inline(always)]
            pub fn uep5_rx_en(&self) -> UEP5_RX_EN_R {
                UEP5_RX_EN_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - enable USB endpoint 6 transmittal (IN)
            #[inline(always)]
            pub fn uep6_tx_en(&self) -> UEP6_TX_EN_R {
                UEP6_TX_EN_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - enable USB endpoint 6 receiving (OUT)
            #[inline(always)]
            pub fn uep6_rx_en(&self) -> UEP6_RX_EN_R {
                UEP6_RX_EN_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - enable USB endpoint 7 transmittal (IN)
            #[inline(always)]
            pub fn uep7_tx_en(&self) -> UEP7_TX_EN_R {
                UEP7_TX_EN_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - enable USB endpoint 7 receiving (OUT)
            #[inline(always)]
            pub fn uep7_rx_en(&self) -> UEP7_RX_EN_R {
                UEP7_RX_EN_R::new(((self.bits >> 5) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - enable USB endpoint 5 transmittal (IN)
            #[inline(always)]
            #[must_use]
            pub fn uep5_tx_en(&mut self) -> UEP5_TX_EN_W<EP567_MOD_SPEC> {
                UEP5_TX_EN_W::new(self, 0)
            }
            ///Bit 1 - enable USB endpoint 5 receiving (OUT)
            #[inline(always)]
            #[must_use]
            pub fn uep5_rx_en(&mut self) -> UEP5_RX_EN_W<EP567_MOD_SPEC> {
                UEP5_RX_EN_W::new(self, 1)
            }
            ///Bit 2 - enable USB endpoint 6 transmittal (IN)
            #[inline(always)]
            #[must_use]
            pub fn uep6_tx_en(&mut self) -> UEP6_TX_EN_W<EP567_MOD_SPEC> {
                UEP6_TX_EN_W::new(self, 2)
            }
            ///Bit 3 - enable USB endpoint 6 receiving (OUT)
            #[inline(always)]
            #[must_use]
            pub fn uep6_rx_en(&mut self) -> UEP6_RX_EN_W<EP567_MOD_SPEC> {
                UEP6_RX_EN_W::new(self, 3)
            }
            ///Bit 4 - enable USB endpoint 7 transmittal (IN)
            #[inline(always)]
            #[must_use]
            pub fn uep7_tx_en(&mut self) -> UEP7_TX_EN_W<EP567_MOD_SPEC> {
                UEP7_TX_EN_W::new(self, 4)
            }
            ///Bit 5 - enable USB endpoint 7 receiving (OUT)
            #[inline(always)]
            #[must_use]
            pub fn uep7_rx_en(&mut self) -> UEP7_RX_EN_W<EP567_MOD_SPEC> {
                UEP7_RX_EN_W::new(self, 5)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///USB2 endpoint 5/6/7 mode
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`ep567_mod::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ep567_mod::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct EP567_MOD_SPEC;
        impl crate::RegisterSpec for EP567_MOD_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`ep567_mod::R`](R) reader structure
        impl crate::Readable for EP567_MOD_SPEC {}
        ///`write(|w| ..)` method takes [`ep567_mod::W`](W) writer structure
        impl crate::Writable for EP567_MOD_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets EP567_MOD to value 0
        impl crate::Resettable for EP567_MOD_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///EP0_DMA (rw) register accessor: endpoint 0 DMA buffer address
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`ep0_dma::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ep0_dma::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@ep0_dma`]
    ///module
    pub type EP0_DMA = crate::Reg<ep0_dma::EP0_DMA_SPEC>;
    ///endpoint 0 DMA buffer address
    pub mod ep0_dma {
        ///Register `EP0_DMA` reader
        pub type R = crate::R<EP0_DMA_SPEC>;
        ///Register `EP0_DMA` writer
        pub type W = crate::W<EP0_DMA_SPEC>;
        ///Field `UEP0_DMA` reader - RW,endpoint 0 DMA buffer address
        pub type UEP0_DMA_R = crate::FieldReader<u16>;
        ///Field `UEP0_DMA` writer - RW,endpoint 0 DMA buffer address
        pub type UEP0_DMA_W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            ///Bits 0:15 - RW,endpoint 0 DMA buffer address
            #[inline(always)]
            pub fn uep0_dma(&self) -> UEP0_DMA_R {
                UEP0_DMA_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - RW,endpoint 0 DMA buffer address
            #[inline(always)]
            #[must_use]
            pub fn uep0_dma(&mut self) -> UEP0_DMA_W<EP0_DMA_SPEC> {
                UEP0_DMA_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///endpoint 0 DMA buffer address
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`ep0_dma::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ep0_dma::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct EP0_DMA_SPEC;
        impl crate::RegisterSpec for EP0_DMA_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`ep0_dma::R`](R) reader structure
        impl crate::Readable for EP0_DMA_SPEC {}
        ///`write(|w| ..)` method takes [`ep0_dma::W`](W) writer structure
        impl crate::Writable for EP0_DMA_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets EP0_DMA to value 0
        impl crate::Resettable for EP0_DMA_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///EP1_DMA (rw) register accessor: USB2 endpoint 1 DMA buffer address
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`ep1_dma::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ep1_dma::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@ep1_dma`]
    ///module
    pub type EP1_DMA = crate::Reg<ep1_dma::EP1_DMA_SPEC>;
    ///USB2 endpoint 1 DMA buffer address
    pub mod ep1_dma {
        ///Register `EP1_DMA` reader
        pub type R = crate::R<EP1_DMA_SPEC>;
        ///Register `EP1_DMA` writer
        pub type W = crate::W<EP1_DMA_SPEC>;
        ///Field `UEP1_DMA` reader - RW,endpoint 1 DMA buffer address
        pub type UEP1_DMA_R = crate::FieldReader<u16>;
        ///Field `UEP1_DMA` writer - RW,endpoint 1 DMA buffer address
        pub type UEP1_DMA_W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            ///Bits 0:15 - RW,endpoint 1 DMA buffer address
            #[inline(always)]
            pub fn uep1_dma(&self) -> UEP1_DMA_R {
                UEP1_DMA_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - RW,endpoint 1 DMA buffer address
            #[inline(always)]
            #[must_use]
            pub fn uep1_dma(&mut self) -> UEP1_DMA_W<EP1_DMA_SPEC> {
                UEP1_DMA_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///USB2 endpoint 1 DMA buffer address
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`ep1_dma::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ep1_dma::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct EP1_DMA_SPEC;
        impl crate::RegisterSpec for EP1_DMA_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`ep1_dma::R`](R) reader structure
        impl crate::Readable for EP1_DMA_SPEC {}
        ///`write(|w| ..)` method takes [`ep1_dma::W`](W) writer structure
        impl crate::Writable for EP1_DMA_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets EP1_DMA to value 0
        impl crate::Resettable for EP1_DMA_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///EP2_DMA__R16_U2H_RX_DMA (rw) register accessor: USB2 endpoint 2 DMA buffer address;host rx endpoint buffer high address
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`ep2_dma__r16_u2h_rx_dma::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ep2_dma__r16_u2h_rx_dma::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@ep2_dma__r16_u2h_rx_dma`]
    ///module
    pub type EP2_DMA__R16_U2H_RX_DMA =
        crate::Reg<ep2_dma__r16_u2h_rx_dma::EP2_DMA__R16_U2H_RX_DMA_SPEC>;
    ///USB2 endpoint 2 DMA buffer address;host rx endpoint buffer high address
    pub mod ep2_dma__r16_u2h_rx_dma {
        ///Register `EP2_DMA__R16_U2H_RX_DMA` reader
        pub type R = crate::R<EP2_DMA__R16_U2H_RX_DMA_SPEC>;
        ///Register `EP2_DMA__R16_U2H_RX_DMA` writer
        pub type W = crate::W<EP2_DMA__R16_U2H_RX_DMA_SPEC>;
        ///Field `UEP2_DMA` reader - RW,endpoint 2 DMA buffer address;host rx endpoint buffer high address
        pub type UEP2_DMA_R = crate::FieldReader<u16>;
        ///Field `UEP2_DMA` writer - RW,endpoint 2 DMA buffer address;host rx endpoint buffer high address
        pub type UEP2_DMA_W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            ///Bits 0:15 - RW,endpoint 2 DMA buffer address;host rx endpoint buffer high address
            #[inline(always)]
            pub fn uep2_dma(&self) -> UEP2_DMA_R {
                UEP2_DMA_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - RW,endpoint 2 DMA buffer address;host rx endpoint buffer high address
            #[inline(always)]
            #[must_use]
            pub fn uep2_dma(&mut self) -> UEP2_DMA_W<EP2_DMA__R16_U2H_RX_DMA_SPEC> {
                UEP2_DMA_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///USB2 endpoint 2 DMA buffer address;host rx endpoint buffer high address
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`ep2_dma__r16_u2h_rx_dma::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ep2_dma__r16_u2h_rx_dma::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct EP2_DMA__R16_U2H_RX_DMA_SPEC;
        impl crate::RegisterSpec for EP2_DMA__R16_U2H_RX_DMA_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`ep2_dma__r16_u2h_rx_dma::R`](R) reader structure
        impl crate::Readable for EP2_DMA__R16_U2H_RX_DMA_SPEC {}
        ///`write(|w| ..)` method takes [`ep2_dma__r16_u2h_rx_dma::W`](W) writer structure
        impl crate::Writable for EP2_DMA__R16_U2H_RX_DMA_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets EP2_DMA__R16_U2H_RX_DMA to value 0
        impl crate::Resettable for EP2_DMA__R16_U2H_RX_DMA_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///EP3_DMA__R16_U2H_TX_DMA (rw) register accessor: USB2 endpoint 3 DMA buffer address;host tx endpoint buffer high address
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`ep3_dma__r16_u2h_tx_dma::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ep3_dma__r16_u2h_tx_dma::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@ep3_dma__r16_u2h_tx_dma`]
    ///module
    pub type EP3_DMA__R16_U2H_TX_DMA =
        crate::Reg<ep3_dma__r16_u2h_tx_dma::EP3_DMA__R16_U2H_TX_DMA_SPEC>;
    ///USB2 endpoint 3 DMA buffer address;host tx endpoint buffer high address
    pub mod ep3_dma__r16_u2h_tx_dma {
        ///Register `EP3_DMA__R16_U2H_TX_DMA` reader
        pub type R = crate::R<EP3_DMA__R16_U2H_TX_DMA_SPEC>;
        ///Register `EP3_DMA__R16_U2H_TX_DMA` writer
        pub type W = crate::W<EP3_DMA__R16_U2H_TX_DMA_SPEC>;
        ///Field `UEP3_DMA` reader - RW,endpoint 3 DMA buffer address;host rx endpoint buffer high address
        pub type UEP3_DMA_R = crate::FieldReader<u16>;
        ///Field `UEP3_DMA` writer - RW,endpoint 3 DMA buffer address;host rx endpoint buffer high address
        pub type UEP3_DMA_W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            ///Bits 0:15 - RW,endpoint 3 DMA buffer address;host rx endpoint buffer high address
            #[inline(always)]
            pub fn uep3_dma(&self) -> UEP3_DMA_R {
                UEP3_DMA_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - RW,endpoint 3 DMA buffer address;host rx endpoint buffer high address
            #[inline(always)]
            #[must_use]
            pub fn uep3_dma(&mut self) -> UEP3_DMA_W<EP3_DMA__R16_U2H_TX_DMA_SPEC> {
                UEP3_DMA_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///USB2 endpoint 3 DMA buffer address;host tx endpoint buffer high address
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`ep3_dma__r16_u2h_tx_dma::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ep3_dma__r16_u2h_tx_dma::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct EP3_DMA__R16_U2H_TX_DMA_SPEC;
        impl crate::RegisterSpec for EP3_DMA__R16_U2H_TX_DMA_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`ep3_dma__r16_u2h_tx_dma::R`](R) reader structure
        impl crate::Readable for EP3_DMA__R16_U2H_TX_DMA_SPEC {}
        ///`write(|w| ..)` method takes [`ep3_dma__r16_u2h_tx_dma::W`](W) writer structure
        impl crate::Writable for EP3_DMA__R16_U2H_TX_DMA_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets EP3_DMA__R16_U2H_TX_DMA to value 0
        impl crate::Resettable for EP3_DMA__R16_U2H_TX_DMA_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///EP5_DMA (rw) register accessor: USB2 endpoint 5 DMA buffer address
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`ep5_dma::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ep5_dma::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@ep5_dma`]
    ///module
    pub type EP5_DMA = crate::Reg<ep5_dma::EP5_DMA_SPEC>;
    ///USB2 endpoint 5 DMA buffer address
    pub mod ep5_dma {
        ///Register `EP5_DMA` reader
        pub type R = crate::R<EP5_DMA_SPEC>;
        ///Register `EP5_DMA` writer
        pub type W = crate::W<EP5_DMA_SPEC>;
        ///Field `UEP5_DMA` reader - RW,endpoint 5 DMA buffer address;host rx endpoint buffer high address
        pub type UEP5_DMA_R = crate::FieldReader<u16>;
        ///Field `UEP5_DMA` writer - RW,endpoint 5 DMA buffer address;host rx endpoint buffer high address
        pub type UEP5_DMA_W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            ///Bits 0:15 - RW,endpoint 5 DMA buffer address;host rx endpoint buffer high address
            #[inline(always)]
            pub fn uep5_dma(&self) -> UEP5_DMA_R {
                UEP5_DMA_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - RW,endpoint 5 DMA buffer address;host rx endpoint buffer high address
            #[inline(always)]
            #[must_use]
            pub fn uep5_dma(&mut self) -> UEP5_DMA_W<EP5_DMA_SPEC> {
                UEP5_DMA_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///USB2 endpoint 5 DMA buffer address
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`ep5_dma::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ep5_dma::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct EP5_DMA_SPEC;
        impl crate::RegisterSpec for EP5_DMA_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`ep5_dma::R`](R) reader structure
        impl crate::Readable for EP5_DMA_SPEC {}
        ///`write(|w| ..)` method takes [`ep5_dma::W`](W) writer structure
        impl crate::Writable for EP5_DMA_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets EP5_DMA to value 0
        impl crate::Resettable for EP5_DMA_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///EP6_DMA (rw) register accessor: USB2 endpoint 6 DMA buffer address
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`ep6_dma::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ep6_dma::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@ep6_dma`]
    ///module
    pub type EP6_DMA = crate::Reg<ep6_dma::EP6_DMA_SPEC>;
    ///USB2 endpoint 6 DMA buffer address
    pub mod ep6_dma {
        ///Register `EP6_DMA` reader
        pub type R = crate::R<EP6_DMA_SPEC>;
        ///Register `EP6_DMA` writer
        pub type W = crate::W<EP6_DMA_SPEC>;
        ///Field `UEP6_DMA` reader - RW,endpoint 6 DMA buffer address;host rx endpoint buffer high address
        pub type UEP6_DMA_R = crate::FieldReader<u16>;
        ///Field `UEP6_DMA` writer - RW,endpoint 6 DMA buffer address;host rx endpoint buffer high address
        pub type UEP6_DMA_W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            ///Bits 0:15 - RW,endpoint 6 DMA buffer address;host rx endpoint buffer high address
            #[inline(always)]
            pub fn uep6_dma(&self) -> UEP6_DMA_R {
                UEP6_DMA_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - RW,endpoint 6 DMA buffer address;host rx endpoint buffer high address
            #[inline(always)]
            #[must_use]
            pub fn uep6_dma(&mut self) -> UEP6_DMA_W<EP6_DMA_SPEC> {
                UEP6_DMA_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///USB2 endpoint 6 DMA buffer address
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`ep6_dma::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ep6_dma::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct EP6_DMA_SPEC;
        impl crate::RegisterSpec for EP6_DMA_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`ep6_dma::R`](R) reader structure
        impl crate::Readable for EP6_DMA_SPEC {}
        ///`write(|w| ..)` method takes [`ep6_dma::W`](W) writer structure
        impl crate::Writable for EP6_DMA_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets EP6_DMA to value 0
        impl crate::Resettable for EP6_DMA_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///EP7_DMA (rw) register accessor: USB2 endpoint 7 DMA buffer address
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`ep7_dma::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ep7_dma::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@ep7_dma`]
    ///module
    pub type EP7_DMA = crate::Reg<ep7_dma::EP7_DMA_SPEC>;
    ///USB2 endpoint 7 DMA buffer address
    pub mod ep7_dma {
        ///Register `EP7_DMA` reader
        pub type R = crate::R<EP7_DMA_SPEC>;
        ///Register `EP7_DMA` writer
        pub type W = crate::W<EP7_DMA_SPEC>;
        ///Field `UEP7_DMA` reader - RW,endpoint 7 DMA buffer address;host rx endpoint buffer high address
        pub type UEP7_DMA_R = crate::FieldReader<u16>;
        ///Field `UEP7_DMA` writer - RW,endpoint 7 DMA buffer address;host rx endpoint buffer high address
        pub type UEP7_DMA_W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            ///Bits 0:15 - RW,endpoint 7 DMA buffer address;host rx endpoint buffer high address
            #[inline(always)]
            pub fn uep7_dma(&self) -> UEP7_DMA_R {
                UEP7_DMA_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - RW,endpoint 7 DMA buffer address;host rx endpoint buffer high address
            #[inline(always)]
            #[must_use]
            pub fn uep7_dma(&mut self) -> UEP7_DMA_W<EP7_DMA_SPEC> {
                UEP7_DMA_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///USB2 endpoint 7 DMA buffer address
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`ep7_dma::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ep7_dma::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct EP7_DMA_SPEC;
        impl crate::RegisterSpec for EP7_DMA_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`ep7_dma::R`](R) reader structure
        impl crate::Readable for EP7_DMA_SPEC {}
        ///`write(|w| ..)` method takes [`ep7_dma::W`](W) writer structure
        impl crate::Writable for EP7_DMA_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets EP7_DMA to value 0
        impl crate::Resettable for EP7_DMA_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///EP0_T_LEN (rw) register accessor: USB2 endpoint 0 transmittal length
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`ep0_t_len::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ep0_t_len::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@ep0_t_len`]
    ///module
    pub type EP0_T_LEN = crate::Reg<ep0_t_len::EP0_T_LEN_SPEC>;
    ///USB2 endpoint 0 transmittal length
    pub mod ep0_t_len {
        ///Register `EP0_T_LEN` reader
        pub type R = crate::R<EP0_T_LEN_SPEC>;
        ///Register `EP0_T_LEN` writer
        pub type W = crate::W<EP0_T_LEN_SPEC>;
        ///Field `UEP0_T_LEN` reader - endpoint 0 transmittal length
        pub type UEP0_T_LEN_R = crate::FieldReader;
        ///Field `UEP0_T_LEN` writer - endpoint 0 transmittal length
        pub type UEP0_T_LEN_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            ///Bits 0:7 - endpoint 0 transmittal length
            #[inline(always)]
            pub fn uep0_t_len(&self) -> UEP0_T_LEN_R {
                UEP0_T_LEN_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:7 - endpoint 0 transmittal length
            #[inline(always)]
            #[must_use]
            pub fn uep0_t_len(&mut self) -> UEP0_T_LEN_W<EP0_T_LEN_SPEC> {
                UEP0_T_LEN_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///USB2 endpoint 0 transmittal length
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`ep0_t_len::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ep0_t_len::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct EP0_T_LEN_SPEC;
        impl crate::RegisterSpec for EP0_T_LEN_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`ep0_t_len::R`](R) reader structure
        impl crate::Readable for EP0_T_LEN_SPEC {}
        ///`write(|w| ..)` method takes [`ep0_t_len::W`](W) writer structure
        impl crate::Writable for EP0_T_LEN_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets EP0_T_LEN to value 0
        impl crate::Resettable for EP0_T_LEN_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///EP0_CTRL (rw) register accessor: USB2 endpoint 0 control
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`ep0_ctrl::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ep0_ctrl::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@ep0_ctrl`]
    ///module
    pub type EP0_CTRL = crate::Reg<ep0_ctrl::EP0_CTRL_SPEC>;
    ///USB2 endpoint 0 control
    pub mod ep0_ctrl {
        ///Register `EP0_CTRL` reader
        pub type R = crate::R<EP0_CTRL_SPEC>;
        ///Register `EP0_CTRL` writer
        pub type W = crate::W<EP0_CTRL_SPEC>;
        ///Field `MASK_UEP_T_RES` reader - bit mask of handshake response type for USB endpoint X transmittal (IN)
        pub type MASK_UEP_T_RES_R = crate::FieldReader;
        ///Field `MASK_UEP_T_RES` writer - bit mask of handshake response type for USB endpoint X transmittal (IN)
        pub type MASK_UEP_T_RES_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `MASK_UEP_R_RES` reader - bit mask of handshake response type for USB endpoint X receiving (OUT)
        pub type MASK_UEP_R_RES_R = crate::FieldReader;
        ///Field `MASK_UEP_R_RES` writer - bit mask of handshake response type for USB endpoint X receiving (OUT)
        pub type MASK_UEP_R_RES_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `UEP_AUTO_TOG` reader - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
        pub type UEP_AUTO_TOG_R = crate::BitReader;
        ///Field `UEP_AUTO_TOG` writer - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
        pub type UEP_AUTO_TOG_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UEP_T_TOG` reader - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
        pub type UEP_T_TOG_R = crate::BitReader;
        ///Field `UEP_T_TOG` writer - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
        pub type UEP_T_TOG_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UEP_R_TOG` reader - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
        pub type UEP_R_TOG_R = crate::BitReader;
        ///Field `UEP_R_TOG` writer - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
        pub type UEP_R_TOG_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)
            #[inline(always)]
            pub fn mask_uep_t_res(&self) -> MASK_UEP_T_RES_R {
                MASK_UEP_T_RES_R::new(self.bits & 3)
            }
            ///Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)
            #[inline(always)]
            pub fn mask_uep_r_res(&self) -> MASK_UEP_R_RES_R {
                MASK_UEP_R_RES_R::new((self.bits >> 2) & 3)
            }
            ///Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
            #[inline(always)]
            pub fn uep_auto_tog(&self) -> UEP_AUTO_TOG_R {
                UEP_AUTO_TOG_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
            #[inline(always)]
            pub fn uep_t_tog(&self) -> UEP_T_TOG_R {
                UEP_T_TOG_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
            #[inline(always)]
            pub fn uep_r_tog(&self) -> UEP_R_TOG_R {
                UEP_R_TOG_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)
            #[inline(always)]
            #[must_use]
            pub fn mask_uep_t_res(&mut self) -> MASK_UEP_T_RES_W<EP0_CTRL_SPEC> {
                MASK_UEP_T_RES_W::new(self, 0)
            }
            ///Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)
            #[inline(always)]
            #[must_use]
            pub fn mask_uep_r_res(&mut self) -> MASK_UEP_R_RES_W<EP0_CTRL_SPEC> {
                MASK_UEP_R_RES_W::new(self, 2)
            }
            ///Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
            #[inline(always)]
            #[must_use]
            pub fn uep_auto_tog(&mut self) -> UEP_AUTO_TOG_W<EP0_CTRL_SPEC> {
                UEP_AUTO_TOG_W::new(self, 4)
            }
            ///Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
            #[inline(always)]
            #[must_use]
            pub fn uep_t_tog(&mut self) -> UEP_T_TOG_W<EP0_CTRL_SPEC> {
                UEP_T_TOG_W::new(self, 6)
            }
            ///Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
            #[inline(always)]
            #[must_use]
            pub fn uep_r_tog(&mut self) -> UEP_R_TOG_W<EP0_CTRL_SPEC> {
                UEP_R_TOG_W::new(self, 7)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///USB2 endpoint 0 control
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`ep0_ctrl::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ep0_ctrl::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct EP0_CTRL_SPEC;
        impl crate::RegisterSpec for EP0_CTRL_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`ep0_ctrl::R`](R) reader structure
        impl crate::Readable for EP0_CTRL_SPEC {}
        ///`write(|w| ..)` method takes [`ep0_ctrl::W`](W) writer structure
        impl crate::Writable for EP0_CTRL_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets EP0_CTRL to value 0
        impl crate::Resettable for EP0_CTRL_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///EP1_T_LEN (rw) register accessor: USB2 endpoint 1 transmittal length
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`ep1_t_len::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ep1_t_len::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@ep1_t_len`]
    ///module
    pub type EP1_T_LEN = crate::Reg<ep1_t_len::EP1_T_LEN_SPEC>;
    ///USB2 endpoint 1 transmittal length
    pub mod ep1_t_len {
        ///Register `EP1_T_LEN` reader
        pub type R = crate::R<EP1_T_LEN_SPEC>;
        ///Register `EP1_T_LEN` writer
        pub type W = crate::W<EP1_T_LEN_SPEC>;
        ///Field `UEP1_T_LEN` reader - endpoint 1 transmittal length
        pub type UEP1_T_LEN_R = crate::FieldReader;
        ///Field `UEP1_T_LEN` writer - endpoint 1 transmittal length
        pub type UEP1_T_LEN_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            ///Bits 0:7 - endpoint 1 transmittal length
            #[inline(always)]
            pub fn uep1_t_len(&self) -> UEP1_T_LEN_R {
                UEP1_T_LEN_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:7 - endpoint 1 transmittal length
            #[inline(always)]
            #[must_use]
            pub fn uep1_t_len(&mut self) -> UEP1_T_LEN_W<EP1_T_LEN_SPEC> {
                UEP1_T_LEN_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///USB2 endpoint 1 transmittal length
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`ep1_t_len::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ep1_t_len::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct EP1_T_LEN_SPEC;
        impl crate::RegisterSpec for EP1_T_LEN_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`ep1_t_len::R`](R) reader structure
        impl crate::Readable for EP1_T_LEN_SPEC {}
        ///`write(|w| ..)` method takes [`ep1_t_len::W`](W) writer structure
        impl crate::Writable for EP1_T_LEN_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets EP1_T_LEN to value 0
        impl crate::Resettable for EP1_T_LEN_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///EP1_CTRL__R8_U2H_SETUP (rw) register accessor: USB2 endpoint 1 control;host aux setup
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`ep1_ctrl__r8_u2h_setup::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ep1_ctrl__r8_u2h_setup::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@ep1_ctrl__r8_u2h_setup`]
    ///module
    pub type EP1_CTRL__R8_U2H_SETUP =
        crate::Reg<ep1_ctrl__r8_u2h_setup::EP1_CTRL__R8_U2H_SETUP_SPEC>;
    ///USB2 endpoint 1 control;host aux setup
    pub mod ep1_ctrl__r8_u2h_setup {
        ///Register `EP1_CTRL__R8_U2H_SETUP` reader
        pub type R = crate::R<EP1_CTRL__R8_U2H_SETUP_SPEC>;
        ///Register `EP1_CTRL__R8_U2H_SETUP` writer
        pub type W = crate::W<EP1_CTRL__R8_U2H_SETUP_SPEC>;
        ///Field `MASK_UEP_T_RES` reader - bit mask of handshake response type for USB endpoint X transmittal (IN)
        pub type MASK_UEP_T_RES_R = crate::FieldReader;
        ///Field `MASK_UEP_T_RES` writer - bit mask of handshake response type for USB endpoint X transmittal (IN)
        pub type MASK_UEP_T_RES_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `MASK_UEP_R_RES` reader - bit mask of handshake response type for USB endpoint X receiving (OUT)
        pub type MASK_UEP_R_RES_R = crate::FieldReader;
        ///Field `MASK_UEP_R_RES` writer - bit mask of handshake response type for USB endpoint X receiving (OUT)
        pub type MASK_UEP_R_RES_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `UEP_AUTO_TOG` reader - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
        pub type UEP_AUTO_TOG_R = crate::BitReader;
        ///Field `UEP_AUTO_TOG` writer - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
        pub type UEP_AUTO_TOG_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UEP_T_TOG__RB_UH_SOF_EN` reader - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1;USB host automatic SOF enable
        pub type UEP_T_TOG__RB_UH_SOF_EN_R = crate::BitReader;
        ///Field `UEP_T_TOG__RB_UH_SOF_EN` writer - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1;USB host automatic SOF enable
        pub type UEP_T_TOG__RB_UH_SOF_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UEP_R_TOG__RB_UH_PRE_PID_EN` reader - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1;RB_UH_PRE_PID_EN;USB host PRE PID enable for low speed device via hub
        pub type UEP_R_TOG__RB_UH_PRE_PID_EN_R = crate::BitReader;
        ///Field `UEP_R_TOG__RB_UH_PRE_PID_EN` writer - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1;RB_UH_PRE_PID_EN;USB host PRE PID enable for low speed device via hub
        pub type UEP_R_TOG__RB_UH_PRE_PID_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)
            #[inline(always)]
            pub fn mask_uep_t_res(&self) -> MASK_UEP_T_RES_R {
                MASK_UEP_T_RES_R::new(self.bits & 3)
            }
            ///Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)
            #[inline(always)]
            pub fn mask_uep_r_res(&self) -> MASK_UEP_R_RES_R {
                MASK_UEP_R_RES_R::new((self.bits >> 2) & 3)
            }
            ///Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
            #[inline(always)]
            pub fn uep_auto_tog(&self) -> UEP_AUTO_TOG_R {
                UEP_AUTO_TOG_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1;USB host automatic SOF enable
            #[inline(always)]
            pub fn uep_t_tog__rb_uh_sof_en(&self) -> UEP_T_TOG__RB_UH_SOF_EN_R {
                UEP_T_TOG__RB_UH_SOF_EN_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1;RB_UH_PRE_PID_EN;USB host PRE PID enable for low speed device via hub
            #[inline(always)]
            pub fn uep_r_tog__rb_uh_pre_pid_en(&self) -> UEP_R_TOG__RB_UH_PRE_PID_EN_R {
                UEP_R_TOG__RB_UH_PRE_PID_EN_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)
            #[inline(always)]
            #[must_use]
            pub fn mask_uep_t_res(&mut self) -> MASK_UEP_T_RES_W<EP1_CTRL__R8_U2H_SETUP_SPEC> {
                MASK_UEP_T_RES_W::new(self, 0)
            }
            ///Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)
            #[inline(always)]
            #[must_use]
            pub fn mask_uep_r_res(&mut self) -> MASK_UEP_R_RES_W<EP1_CTRL__R8_U2H_SETUP_SPEC> {
                MASK_UEP_R_RES_W::new(self, 2)
            }
            ///Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
            #[inline(always)]
            #[must_use]
            pub fn uep_auto_tog(&mut self) -> UEP_AUTO_TOG_W<EP1_CTRL__R8_U2H_SETUP_SPEC> {
                UEP_AUTO_TOG_W::new(self, 4)
            }
            ///Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1;USB host automatic SOF enable
            #[inline(always)]
            #[must_use]
            pub fn uep_t_tog__rb_uh_sof_en(
                &mut self,
            ) -> UEP_T_TOG__RB_UH_SOF_EN_W<EP1_CTRL__R8_U2H_SETUP_SPEC> {
                UEP_T_TOG__RB_UH_SOF_EN_W::new(self, 6)
            }
            ///Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1;RB_UH_PRE_PID_EN;USB host PRE PID enable for low speed device via hub
            #[inline(always)]
            #[must_use]
            pub fn uep_r_tog__rb_uh_pre_pid_en(
                &mut self,
            ) -> UEP_R_TOG__RB_UH_PRE_PID_EN_W<EP1_CTRL__R8_U2H_SETUP_SPEC> {
                UEP_R_TOG__RB_UH_PRE_PID_EN_W::new(self, 7)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///USB2 endpoint 1 control;host aux setup
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`ep1_ctrl__r8_u2h_setup::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ep1_ctrl__r8_u2h_setup::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct EP1_CTRL__R8_U2H_SETUP_SPEC;
        impl crate::RegisterSpec for EP1_CTRL__R8_U2H_SETUP_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`ep1_ctrl__r8_u2h_setup::R`](R) reader structure
        impl crate::Readable for EP1_CTRL__R8_U2H_SETUP_SPEC {}
        ///`write(|w| ..)` method takes [`ep1_ctrl__r8_u2h_setup::W`](W) writer structure
        impl crate::Writable for EP1_CTRL__R8_U2H_SETUP_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets EP1_CTRL__R8_U2H_SETUP to value 0
        impl crate::Resettable for EP1_CTRL__R8_U2H_SETUP_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///EP2_T_LEN_R8_U2H_EP_PID (rw) register accessor: USB2 endpoint 2 transmittal length;host endpoint and PID
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`ep2_t_len_r8_u2h_ep_pid::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ep2_t_len_r8_u2h_ep_pid::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@ep2_t_len_r8_u2h_ep_pid`]
    ///module
    pub type EP2_T_LEN_R8_U2H_EP_PID =
        crate::Reg<ep2_t_len_r8_u2h_ep_pid::EP2_T_LEN_R8_U2H_EP_PID_SPEC>;
    ///USB2 endpoint 2 transmittal length;host endpoint and PID
    pub mod ep2_t_len_r8_u2h_ep_pid {
        ///Register `EP2_T_LEN_R8_U2H_EP_PID` reader
        pub type R = crate::R<EP2_T_LEN_R8_U2H_EP_PID_SPEC>;
        ///Register `EP2_T_LEN_R8_U2H_EP_PID` writer
        pub type W = crate::W<EP2_T_LEN_R8_U2H_EP_PID_SPEC>;
        ///Field `MASK_UH_ENDP` reader - bit mask of endpoint number for USB host transfer
        pub type MASK_UH_ENDP_R = crate::FieldReader;
        ///Field `MASK_UH_ENDP` writer - bit mask of endpoint number for USB host transfer
        pub type MASK_UH_ENDP_W<'a, REG> = crate::FieldWriter<'a, REG, 4>;
        ///Field `UEP2_T_LEN` reader - endpoint 2 transmittal length;
        pub type UEP2_T_LEN_R = crate::FieldReader;
        ///Field `UEP2_T_LEN` writer - endpoint 2 transmittal length;
        pub type UEP2_T_LEN_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        ///Field `MASK_UH_TOKEN` reader - bit mask of token PID for USB host transfer
        pub type MASK_UH_TOKEN_R = crate::FieldReader;
        ///Field `MASK_UH_TOKEN` writer - bit mask of token PID for USB host transfer
        pub type MASK_UH_TOKEN_W<'a, REG> = crate::FieldWriter<'a, REG, 4>;
        impl R {
            ///Bits 0:3 - bit mask of endpoint number for USB host transfer
            #[inline(always)]
            pub fn mask_uh_endp(&self) -> MASK_UH_ENDP_R {
                MASK_UH_ENDP_R::new(self.bits & 0x0f)
            }
            ///Bits 0:7 - endpoint 2 transmittal length;
            #[inline(always)]
            pub fn uep2_t_len(&self) -> UEP2_T_LEN_R {
                UEP2_T_LEN_R::new(self.bits)
            }
            ///Bits 4:7 - bit mask of token PID for USB host transfer
            #[inline(always)]
            pub fn mask_uh_token(&self) -> MASK_UH_TOKEN_R {
                MASK_UH_TOKEN_R::new((self.bits >> 4) & 0x0f)
            }
        }
        impl W {
            ///Bits 0:3 - bit mask of endpoint number for USB host transfer
            #[inline(always)]
            #[must_use]
            pub fn mask_uh_endp(&mut self) -> MASK_UH_ENDP_W<EP2_T_LEN_R8_U2H_EP_PID_SPEC> {
                MASK_UH_ENDP_W::new(self, 0)
            }
            ///Bits 0:7 - endpoint 2 transmittal length;
            #[inline(always)]
            #[must_use]
            pub fn uep2_t_len(&mut self) -> UEP2_T_LEN_W<EP2_T_LEN_R8_U2H_EP_PID_SPEC> {
                UEP2_T_LEN_W::new(self, 0)
            }
            ///Bits 4:7 - bit mask of token PID for USB host transfer
            #[inline(always)]
            #[must_use]
            pub fn mask_uh_token(&mut self) -> MASK_UH_TOKEN_W<EP2_T_LEN_R8_U2H_EP_PID_SPEC> {
                MASK_UH_TOKEN_W::new(self, 4)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///USB2 endpoint 2 transmittal length;host endpoint and PID
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`ep2_t_len_r8_u2h_ep_pid::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ep2_t_len_r8_u2h_ep_pid::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct EP2_T_LEN_R8_U2H_EP_PID_SPEC;
        impl crate::RegisterSpec for EP2_T_LEN_R8_U2H_EP_PID_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`ep2_t_len_r8_u2h_ep_pid::R`](R) reader structure
        impl crate::Readable for EP2_T_LEN_R8_U2H_EP_PID_SPEC {}
        ///`write(|w| ..)` method takes [`ep2_t_len_r8_u2h_ep_pid::W`](W) writer structure
        impl crate::Writable for EP2_T_LEN_R8_U2H_EP_PID_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets EP2_T_LEN_R8_U2H_EP_PID to value 0
        impl crate::Resettable for EP2_T_LEN_R8_U2H_EP_PID_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///EP2_CTRL_R8_U2H_RX_CTRL (rw) register accessor: USB2 endpoint 2 control;host receiver endpoint control
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`ep2_ctrl_r8_u2h_rx_ctrl::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ep2_ctrl_r8_u2h_rx_ctrl::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@ep2_ctrl_r8_u2h_rx_ctrl`]
    ///module
    pub type EP2_CTRL_R8_U2H_RX_CTRL =
        crate::Reg<ep2_ctrl_r8_u2h_rx_ctrl::EP2_CTRL_R8_U2H_RX_CTRL_SPEC>;
    ///USB2 endpoint 2 control;host receiver endpoint control
    pub mod ep2_ctrl_r8_u2h_rx_ctrl {
        ///Register `EP2_CTRL_R8_U2H_RX_CTRL` reader
        pub type R = crate::R<EP2_CTRL_R8_U2H_RX_CTRL_SPEC>;
        ///Register `EP2_CTRL_R8_U2H_RX_CTRL` writer
        pub type W = crate::W<EP2_CTRL_R8_U2H_RX_CTRL_SPEC>;
        ///Field `MASK_UEP_T_RES` reader - bit mask of handshake response type for USB endpoint X transmittal (IN)
        pub type MASK_UEP_T_RES_R = crate::FieldReader;
        ///Field `MASK_UEP_T_RES` writer - bit mask of handshake response type for USB endpoint X transmittal (IN)
        pub type MASK_UEP_T_RES_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `MASK_UH_R_RES` reader - bit mask of handshake response type for USB endpoint X receiving (OUT)
        pub type MASK_UH_R_RES_R = crate::BitReader;
        ///Field `MASK_UH_R_RES` writer - bit mask of handshake response type for USB endpoint X receiving (OUT)
        pub type MASK_UH_R_RES_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `MASK_UEP_R_RES` reader - bit mask of handshake response type for USB endpoint X receiving (OUT)
        pub type MASK_UEP_R_RES_R = crate::FieldReader;
        ///Field `MASK_UEP_R_RES` writer - bit mask of handshake response type for USB endpoint X receiving (OUT)
        pub type MASK_UEP_R_RES_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `UEP_AUTO_TOG__RB_UH_R_AUTO_TOG` reader - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle;enable automatic toggle after successful transfer completion: 0=manual toggle, 1=automatic toggle
        pub type UEP_AUTO_TOG__RB_UH_R_AUTO_TOG_R = crate::BitReader;
        ///Field `UEP_AUTO_TOG__RB_UH_R_AUTO_TOG` writer - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle;enable automatic toggle after successful transfer completion: 0=manual toggle, 1=automatic toggle
        pub type UEP_AUTO_TOG__RB_UH_R_AUTO_TOG_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UEP_T_TOG` reader - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
        pub type UEP_T_TOG_R = crate::BitReader;
        ///Field `UEP_T_TOG` writer - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
        pub type UEP_T_TOG_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UEP_R_TOG__RB_UH_R_TOG` reader - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1;expected data toggle flag of host receiving (IN): 0=DATA0, 1=DATA1
        pub type UEP_R_TOG__RB_UH_R_TOG_R = crate::BitReader;
        ///Field `UEP_R_TOG__RB_UH_R_TOG` writer - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1;expected data toggle flag of host receiving (IN): 0=DATA0, 1=DATA1
        pub type UEP_R_TOG__RB_UH_R_TOG_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)
            #[inline(always)]
            pub fn mask_uep_t_res(&self) -> MASK_UEP_T_RES_R {
                MASK_UEP_T_RES_R::new(self.bits & 3)
            }
            ///Bit 2 - bit mask of handshake response type for USB endpoint X receiving (OUT)
            #[inline(always)]
            pub fn mask_uh_r_res(&self) -> MASK_UH_R_RES_R {
                MASK_UH_R_RES_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)
            #[inline(always)]
            pub fn mask_uep_r_res(&self) -> MASK_UEP_R_RES_R {
                MASK_UEP_R_RES_R::new((self.bits >> 2) & 3)
            }
            ///Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle;enable automatic toggle after successful transfer completion: 0=manual toggle, 1=automatic toggle
            #[inline(always)]
            pub fn uep_auto_tog__rb_uh_r_auto_tog(&self) -> UEP_AUTO_TOG__RB_UH_R_AUTO_TOG_R {
                UEP_AUTO_TOG__RB_UH_R_AUTO_TOG_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
            #[inline(always)]
            pub fn uep_t_tog(&self) -> UEP_T_TOG_R {
                UEP_T_TOG_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1;expected data toggle flag of host receiving (IN): 0=DATA0, 1=DATA1
            #[inline(always)]
            pub fn uep_r_tog__rb_uh_r_tog(&self) -> UEP_R_TOG__RB_UH_R_TOG_R {
                UEP_R_TOG__RB_UH_R_TOG_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)
            #[inline(always)]
            #[must_use]
            pub fn mask_uep_t_res(&mut self) -> MASK_UEP_T_RES_W<EP2_CTRL_R8_U2H_RX_CTRL_SPEC> {
                MASK_UEP_T_RES_W::new(self, 0)
            }
            ///Bit 2 - bit mask of handshake response type for USB endpoint X receiving (OUT)
            #[inline(always)]
            #[must_use]
            pub fn mask_uh_r_res(&mut self) -> MASK_UH_R_RES_W<EP2_CTRL_R8_U2H_RX_CTRL_SPEC> {
                MASK_UH_R_RES_W::new(self, 2)
            }
            ///Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)
            #[inline(always)]
            #[must_use]
            pub fn mask_uep_r_res(&mut self) -> MASK_UEP_R_RES_W<EP2_CTRL_R8_U2H_RX_CTRL_SPEC> {
                MASK_UEP_R_RES_W::new(self, 2)
            }
            ///Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle;enable automatic toggle after successful transfer completion: 0=manual toggle, 1=automatic toggle
            #[inline(always)]
            #[must_use]
            pub fn uep_auto_tog__rb_uh_r_auto_tog(
                &mut self,
            ) -> UEP_AUTO_TOG__RB_UH_R_AUTO_TOG_W<EP2_CTRL_R8_U2H_RX_CTRL_SPEC> {
                UEP_AUTO_TOG__RB_UH_R_AUTO_TOG_W::new(self, 4)
            }
            ///Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
            #[inline(always)]
            #[must_use]
            pub fn uep_t_tog(&mut self) -> UEP_T_TOG_W<EP2_CTRL_R8_U2H_RX_CTRL_SPEC> {
                UEP_T_TOG_W::new(self, 6)
            }
            ///Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1;expected data toggle flag of host receiving (IN): 0=DATA0, 1=DATA1
            #[inline(always)]
            #[must_use]
            pub fn uep_r_tog__rb_uh_r_tog(
                &mut self,
            ) -> UEP_R_TOG__RB_UH_R_TOG_W<EP2_CTRL_R8_U2H_RX_CTRL_SPEC> {
                UEP_R_TOG__RB_UH_R_TOG_W::new(self, 7)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///USB2 endpoint 2 control;host receiver endpoint control
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`ep2_ctrl_r8_u2h_rx_ctrl::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ep2_ctrl_r8_u2h_rx_ctrl::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct EP2_CTRL_R8_U2H_RX_CTRL_SPEC;
        impl crate::RegisterSpec for EP2_CTRL_R8_U2H_RX_CTRL_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`ep2_ctrl_r8_u2h_rx_ctrl::R`](R) reader structure
        impl crate::Readable for EP2_CTRL_R8_U2H_RX_CTRL_SPEC {}
        ///`write(|w| ..)` method takes [`ep2_ctrl_r8_u2h_rx_ctrl::W`](W) writer structure
        impl crate::Writable for EP2_CTRL_R8_U2H_RX_CTRL_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets EP2_CTRL_R8_U2H_RX_CTRL to value 0
        impl crate::Resettable for EP2_CTRL_R8_U2H_RX_CTRL_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///EP3_T_LEN__R8_U2H_TX_LEN (rw) register accessor: USB2 endpoint 3 transmittal length;host transmittal endpoint transmittal length
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`ep3_t_len__r8_u2h_tx_len::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ep3_t_len__r8_u2h_tx_len::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@ep3_t_len__r8_u2h_tx_len`]
    ///module
    pub type EP3_T_LEN__R8_U2H_TX_LEN =
        crate::Reg<ep3_t_len__r8_u2h_tx_len::EP3_T_LEN__R8_U2H_TX_LEN_SPEC>;
    ///USB2 endpoint 3 transmittal length;host transmittal endpoint transmittal length
    pub mod ep3_t_len__r8_u2h_tx_len {
        ///Register `EP3_T_LEN__R8_U2H_TX_LEN` reader
        pub type R = crate::R<EP3_T_LEN__R8_U2H_TX_LEN_SPEC>;
        ///Register `EP3_T_LEN__R8_U2H_TX_LEN` writer
        pub type W = crate::W<EP3_T_LEN__R8_U2H_TX_LEN_SPEC>;
        ///Field `UEP3_T_LEN__R8_UH_TX_LEN` reader - endpoint 1 transmittal length
        pub type UEP3_T_LEN__R8_UH_TX_LEN_R = crate::FieldReader;
        ///Field `UEP3_T_LEN__R8_UH_TX_LEN` writer - endpoint 1 transmittal length
        pub type UEP3_T_LEN__R8_UH_TX_LEN_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            ///Bits 0:7 - endpoint 1 transmittal length
            #[inline(always)]
            pub fn uep3_t_len__r8_uh_tx_len(&self) -> UEP3_T_LEN__R8_UH_TX_LEN_R {
                UEP3_T_LEN__R8_UH_TX_LEN_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:7 - endpoint 1 transmittal length
            #[inline(always)]
            #[must_use]
            pub fn uep3_t_len__r8_uh_tx_len(
                &mut self,
            ) -> UEP3_T_LEN__R8_UH_TX_LEN_W<EP3_T_LEN__R8_U2H_TX_LEN_SPEC> {
                UEP3_T_LEN__R8_UH_TX_LEN_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///USB2 endpoint 3 transmittal length;host transmittal endpoint transmittal length
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`ep3_t_len__r8_u2h_tx_len::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ep3_t_len__r8_u2h_tx_len::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct EP3_T_LEN__R8_U2H_TX_LEN_SPEC;
        impl crate::RegisterSpec for EP3_T_LEN__R8_U2H_TX_LEN_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`ep3_t_len__r8_u2h_tx_len::R`](R) reader structure
        impl crate::Readable for EP3_T_LEN__R8_U2H_TX_LEN_SPEC {}
        ///`write(|w| ..)` method takes [`ep3_t_len__r8_u2h_tx_len::W`](W) writer structure
        impl crate::Writable for EP3_T_LEN__R8_U2H_TX_LEN_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets EP3_T_LEN__R8_U2H_TX_LEN to value 0
        impl crate::Resettable for EP3_T_LEN__R8_U2H_TX_LEN_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///EP3_CTRL__R8_U2H_TX_CTRL (rw) register accessor: USB2 endpoint 3 control;host transmittal endpoint control
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`ep3_ctrl__r8_u2h_tx_ctrl::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ep3_ctrl__r8_u2h_tx_ctrl::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@ep3_ctrl__r8_u2h_tx_ctrl`]
    ///module
    pub type EP3_CTRL__R8_U2H_TX_CTRL =
        crate::Reg<ep3_ctrl__r8_u2h_tx_ctrl::EP3_CTRL__R8_U2H_TX_CTRL_SPEC>;
    ///USB2 endpoint 3 control;host transmittal endpoint control
    pub mod ep3_ctrl__r8_u2h_tx_ctrl {
        ///Register `EP3_CTRL__R8_U2H_TX_CTRL` reader
        pub type R = crate::R<EP3_CTRL__R8_U2H_TX_CTRL_SPEC>;
        ///Register `EP3_CTRL__R8_U2H_TX_CTRL` writer
        pub type W = crate::W<EP3_CTRL__R8_U2H_TX_CTRL_SPEC>;
        ///Field `UH_T_RES` reader - bit mask of handshake response type for USB endpoint X transmittal (IN)
        pub type UH_T_RES_R = crate::FieldReader;
        ///Field `UH_T_RES` writer - bit mask of handshake response type for USB endpoint X transmittal (IN)
        pub type UH_T_RES_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `MASK_UEP_T_RES` reader - bit mask of handshake response type for USB endpoint X transmittal (IN)
        pub type MASK_UEP_T_RES_R = crate::FieldReader;
        ///Field `MASK_UEP_T_RES` writer - bit mask of handshake response type for USB endpoint X transmittal (IN)
        pub type MASK_UEP_T_RES_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `MASK_UEP_R_RES` reader - bit mask of handshake response type for USB endpoint X receiving (OUT)
        pub type MASK_UEP_R_RES_R = crate::FieldReader;
        ///Field `MASK_UEP_R_RES` writer - bit mask of handshake response type for USB endpoint X receiving (OUT)
        pub type MASK_UEP_R_RES_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `UEP_AUTO_TOG_RB_UH_T_AUTO_TOG` reader - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
        pub type UEP_AUTO_TOG_RB_UH_T_AUTO_TOG_R = crate::BitReader;
        ///Field `UEP_AUTO_TOG_RB_UH_T_AUTO_TOG` writer - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
        pub type UEP_AUTO_TOG_RB_UH_T_AUTO_TOG_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UEP_T_TOG_RB_UH_T_TOG` reader - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
        pub type UEP_T_TOG_RB_UH_T_TOG_R = crate::BitReader;
        ///Field `UEP_T_TOG_RB_UH_T_TOG` writer - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
        pub type UEP_T_TOG_RB_UH_T_TOG_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UEP_R_TOG` reader - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
        pub type UEP_R_TOG_R = crate::BitReader;
        ///Field `UEP_R_TOG` writer - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
        pub type UEP_R_TOG_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)
            #[inline(always)]
            pub fn uh_t_res(&self) -> UH_T_RES_R {
                UH_T_RES_R::new(self.bits & 3)
            }
            ///Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)
            #[inline(always)]
            pub fn mask_uep_t_res(&self) -> MASK_UEP_T_RES_R {
                MASK_UEP_T_RES_R::new(self.bits & 3)
            }
            ///Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)
            #[inline(always)]
            pub fn mask_uep_r_res(&self) -> MASK_UEP_R_RES_R {
                MASK_UEP_R_RES_R::new((self.bits >> 2) & 3)
            }
            ///Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
            #[inline(always)]
            pub fn uep_auto_tog_rb_uh_t_auto_tog(&self) -> UEP_AUTO_TOG_RB_UH_T_AUTO_TOG_R {
                UEP_AUTO_TOG_RB_UH_T_AUTO_TOG_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
            #[inline(always)]
            pub fn uep_t_tog_rb_uh_t_tog(&self) -> UEP_T_TOG_RB_UH_T_TOG_R {
                UEP_T_TOG_RB_UH_T_TOG_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
            #[inline(always)]
            pub fn uep_r_tog(&self) -> UEP_R_TOG_R {
                UEP_R_TOG_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)
            #[inline(always)]
            #[must_use]
            pub fn uh_t_res(&mut self) -> UH_T_RES_W<EP3_CTRL__R8_U2H_TX_CTRL_SPEC> {
                UH_T_RES_W::new(self, 0)
            }
            ///Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)
            #[inline(always)]
            #[must_use]
            pub fn mask_uep_t_res(&mut self) -> MASK_UEP_T_RES_W<EP3_CTRL__R8_U2H_TX_CTRL_SPEC> {
                MASK_UEP_T_RES_W::new(self, 0)
            }
            ///Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)
            #[inline(always)]
            #[must_use]
            pub fn mask_uep_r_res(&mut self) -> MASK_UEP_R_RES_W<EP3_CTRL__R8_U2H_TX_CTRL_SPEC> {
                MASK_UEP_R_RES_W::new(self, 2)
            }
            ///Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
            #[inline(always)]
            #[must_use]
            pub fn uep_auto_tog_rb_uh_t_auto_tog(
                &mut self,
            ) -> UEP_AUTO_TOG_RB_UH_T_AUTO_TOG_W<EP3_CTRL__R8_U2H_TX_CTRL_SPEC> {
                UEP_AUTO_TOG_RB_UH_T_AUTO_TOG_W::new(self, 4)
            }
            ///Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
            #[inline(always)]
            #[must_use]
            pub fn uep_t_tog_rb_uh_t_tog(
                &mut self,
            ) -> UEP_T_TOG_RB_UH_T_TOG_W<EP3_CTRL__R8_U2H_TX_CTRL_SPEC> {
                UEP_T_TOG_RB_UH_T_TOG_W::new(self, 6)
            }
            ///Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
            #[inline(always)]
            #[must_use]
            pub fn uep_r_tog(&mut self) -> UEP_R_TOG_W<EP3_CTRL__R8_U2H_TX_CTRL_SPEC> {
                UEP_R_TOG_W::new(self, 7)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///USB2 endpoint 3 control;host transmittal endpoint control
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`ep3_ctrl__r8_u2h_tx_ctrl::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ep3_ctrl__r8_u2h_tx_ctrl::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct EP3_CTRL__R8_U2H_TX_CTRL_SPEC;
        impl crate::RegisterSpec for EP3_CTRL__R8_U2H_TX_CTRL_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`ep3_ctrl__r8_u2h_tx_ctrl::R`](R) reader structure
        impl crate::Readable for EP3_CTRL__R8_U2H_TX_CTRL_SPEC {}
        ///`write(|w| ..)` method takes [`ep3_ctrl__r8_u2h_tx_ctrl::W`](W) writer structure
        impl crate::Writable for EP3_CTRL__R8_U2H_TX_CTRL_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets EP3_CTRL__R8_U2H_TX_CTRL to value 0
        impl crate::Resettable for EP3_CTRL__R8_U2H_TX_CTRL_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///EP4_T_LEN (rw) register accessor: USB2 endpoint 4 transmittal length
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`ep4_t_len::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ep4_t_len::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@ep4_t_len`]
    ///module
    pub type EP4_T_LEN = crate::Reg<ep4_t_len::EP4_T_LEN_SPEC>;
    ///USB2 endpoint 4 transmittal length
    pub mod ep4_t_len {
        ///Register `EP4_T_LEN` reader
        pub type R = crate::R<EP4_T_LEN_SPEC>;
        ///Register `EP4_T_LEN` writer
        pub type W = crate::W<EP4_T_LEN_SPEC>;
        ///Field `UEP4_T_LEN` reader - endpoint 4 transmittal length
        pub type UEP4_T_LEN_R = crate::FieldReader;
        ///Field `UEP4_T_LEN` writer - endpoint 4 transmittal length
        pub type UEP4_T_LEN_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            ///Bits 0:7 - endpoint 4 transmittal length
            #[inline(always)]
            pub fn uep4_t_len(&self) -> UEP4_T_LEN_R {
                UEP4_T_LEN_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:7 - endpoint 4 transmittal length
            #[inline(always)]
            #[must_use]
            pub fn uep4_t_len(&mut self) -> UEP4_T_LEN_W<EP4_T_LEN_SPEC> {
                UEP4_T_LEN_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///USB2 endpoint 4 transmittal length
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`ep4_t_len::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ep4_t_len::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct EP4_T_LEN_SPEC;
        impl crate::RegisterSpec for EP4_T_LEN_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`ep4_t_len::R`](R) reader structure
        impl crate::Readable for EP4_T_LEN_SPEC {}
        ///`write(|w| ..)` method takes [`ep4_t_len::W`](W) writer structure
        impl crate::Writable for EP4_T_LEN_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets EP4_T_LEN to value 0
        impl crate::Resettable for EP4_T_LEN_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///EP4_CTRL (rw) register accessor: USB2 endpoint 4 control
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`ep4_ctrl::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ep4_ctrl::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@ep4_ctrl`]
    ///module
    pub type EP4_CTRL = crate::Reg<ep4_ctrl::EP4_CTRL_SPEC>;
    ///USB2 endpoint 4 control
    pub mod ep4_ctrl {
        ///Register `EP4_CTRL` reader
        pub type R = crate::R<EP4_CTRL_SPEC>;
        ///Register `EP4_CTRL` writer
        pub type W = crate::W<EP4_CTRL_SPEC>;
        ///Field `MASK_UEP_T_RES` reader - bit mask of handshake response type for USB endpoint X transmittal (IN)
        pub type MASK_UEP_T_RES_R = crate::FieldReader;
        ///Field `MASK_UEP_T_RES` writer - bit mask of handshake response type for USB endpoint X transmittal (IN)
        pub type MASK_UEP_T_RES_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `MASK_UEP_R_RES` reader - bit mask of handshake response type for USB endpoint X receiving (OUT)
        pub type MASK_UEP_R_RES_R = crate::FieldReader;
        ///Field `MASK_UEP_R_RES` writer - bit mask of handshake response type for USB endpoint X receiving (OUT)
        pub type MASK_UEP_R_RES_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `UEP_AUTO_TOG` reader - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
        pub type UEP_AUTO_TOG_R = crate::BitReader;
        ///Field `UEP_AUTO_TOG` writer - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
        pub type UEP_AUTO_TOG_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UEP_T_TOG` reader - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
        pub type UEP_T_TOG_R = crate::BitReader;
        ///Field `UEP_T_TOG` writer - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
        pub type UEP_T_TOG_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UEP_R_TOG` reader - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
        pub type UEP_R_TOG_R = crate::BitReader;
        ///Field `UEP_R_TOG` writer - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
        pub type UEP_R_TOG_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)
            #[inline(always)]
            pub fn mask_uep_t_res(&self) -> MASK_UEP_T_RES_R {
                MASK_UEP_T_RES_R::new(self.bits & 3)
            }
            ///Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)
            #[inline(always)]
            pub fn mask_uep_r_res(&self) -> MASK_UEP_R_RES_R {
                MASK_UEP_R_RES_R::new((self.bits >> 2) & 3)
            }
            ///Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
            #[inline(always)]
            pub fn uep_auto_tog(&self) -> UEP_AUTO_TOG_R {
                UEP_AUTO_TOG_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
            #[inline(always)]
            pub fn uep_t_tog(&self) -> UEP_T_TOG_R {
                UEP_T_TOG_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
            #[inline(always)]
            pub fn uep_r_tog(&self) -> UEP_R_TOG_R {
                UEP_R_TOG_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)
            #[inline(always)]
            #[must_use]
            pub fn mask_uep_t_res(&mut self) -> MASK_UEP_T_RES_W<EP4_CTRL_SPEC> {
                MASK_UEP_T_RES_W::new(self, 0)
            }
            ///Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)
            #[inline(always)]
            #[must_use]
            pub fn mask_uep_r_res(&mut self) -> MASK_UEP_R_RES_W<EP4_CTRL_SPEC> {
                MASK_UEP_R_RES_W::new(self, 2)
            }
            ///Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
            #[inline(always)]
            #[must_use]
            pub fn uep_auto_tog(&mut self) -> UEP_AUTO_TOG_W<EP4_CTRL_SPEC> {
                UEP_AUTO_TOG_W::new(self, 4)
            }
            ///Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
            #[inline(always)]
            #[must_use]
            pub fn uep_t_tog(&mut self) -> UEP_T_TOG_W<EP4_CTRL_SPEC> {
                UEP_T_TOG_W::new(self, 6)
            }
            ///Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
            #[inline(always)]
            #[must_use]
            pub fn uep_r_tog(&mut self) -> UEP_R_TOG_W<EP4_CTRL_SPEC> {
                UEP_R_TOG_W::new(self, 7)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///USB2 endpoint 4 control
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`ep4_ctrl::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ep4_ctrl::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct EP4_CTRL_SPEC;
        impl crate::RegisterSpec for EP4_CTRL_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`ep4_ctrl::R`](R) reader structure
        impl crate::Readable for EP4_CTRL_SPEC {}
        ///`write(|w| ..)` method takes [`ep4_ctrl::W`](W) writer structure
        impl crate::Writable for EP4_CTRL_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets EP4_CTRL to value 0
        impl crate::Resettable for EP4_CTRL_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///EP5_T_LEN (rw) register accessor: USB2 endpoint 5 transmittal length
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`ep5_t_len::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ep5_t_len::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@ep5_t_len`]
    ///module
    pub type EP5_T_LEN = crate::Reg<ep5_t_len::EP5_T_LEN_SPEC>;
    ///USB2 endpoint 5 transmittal length
    pub mod ep5_t_len {
        ///Register `EP5_T_LEN` reader
        pub type R = crate::R<EP5_T_LEN_SPEC>;
        ///Register `EP5_T_LEN` writer
        pub type W = crate::W<EP5_T_LEN_SPEC>;
        ///Field `UEP5_T_LEN` reader - endpoint 5 transmittal length
        pub type UEP5_T_LEN_R = crate::FieldReader;
        ///Field `UEP5_T_LEN` writer - endpoint 5 transmittal length
        pub type UEP5_T_LEN_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            ///Bits 0:7 - endpoint 5 transmittal length
            #[inline(always)]
            pub fn uep5_t_len(&self) -> UEP5_T_LEN_R {
                UEP5_T_LEN_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:7 - endpoint 5 transmittal length
            #[inline(always)]
            #[must_use]
            pub fn uep5_t_len(&mut self) -> UEP5_T_LEN_W<EP5_T_LEN_SPEC> {
                UEP5_T_LEN_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///USB2 endpoint 5 transmittal length
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`ep5_t_len::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ep5_t_len::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct EP5_T_LEN_SPEC;
        impl crate::RegisterSpec for EP5_T_LEN_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`ep5_t_len::R`](R) reader structure
        impl crate::Readable for EP5_T_LEN_SPEC {}
        ///`write(|w| ..)` method takes [`ep5_t_len::W`](W) writer structure
        impl crate::Writable for EP5_T_LEN_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets EP5_T_LEN to value 0
        impl crate::Resettable for EP5_T_LEN_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///EP5_CTRL (rw) register accessor: USB2 endpoint 5 control
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`ep5_ctrl::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ep5_ctrl::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@ep5_ctrl`]
    ///module
    pub type EP5_CTRL = crate::Reg<ep5_ctrl::EP5_CTRL_SPEC>;
    ///USB2 endpoint 5 control
    pub mod ep5_ctrl {
        ///Register `EP5_CTRL` reader
        pub type R = crate::R<EP5_CTRL_SPEC>;
        ///Register `EP5_CTRL` writer
        pub type W = crate::W<EP5_CTRL_SPEC>;
        ///Field `MASK_UEP_T_RES` reader - bit mask of handshake response type for USB endpoint X transmittal (IN)
        pub type MASK_UEP_T_RES_R = crate::FieldReader;
        ///Field `MASK_UEP_T_RES` writer - bit mask of handshake response type for USB endpoint X transmittal (IN)
        pub type MASK_UEP_T_RES_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `MASK_UEP_R_RES` reader - bit mask of handshake response type for USB endpoint X receiving (OUT)
        pub type MASK_UEP_R_RES_R = crate::FieldReader;
        ///Field `MASK_UEP_R_RES` writer - bit mask of handshake response type for USB endpoint X receiving (OUT)
        pub type MASK_UEP_R_RES_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `UEP_AUTO_TOG` reader - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
        pub type UEP_AUTO_TOG_R = crate::BitReader;
        ///Field `UEP_AUTO_TOG` writer - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
        pub type UEP_AUTO_TOG_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UEP_T_TOG` reader - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
        pub type UEP_T_TOG_R = crate::BitReader;
        ///Field `UEP_T_TOG` writer - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
        pub type UEP_T_TOG_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UEP_R_TOG` reader - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
        pub type UEP_R_TOG_R = crate::BitReader;
        ///Field `UEP_R_TOG` writer - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
        pub type UEP_R_TOG_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)
            #[inline(always)]
            pub fn mask_uep_t_res(&self) -> MASK_UEP_T_RES_R {
                MASK_UEP_T_RES_R::new(self.bits & 3)
            }
            ///Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)
            #[inline(always)]
            pub fn mask_uep_r_res(&self) -> MASK_UEP_R_RES_R {
                MASK_UEP_R_RES_R::new((self.bits >> 2) & 3)
            }
            ///Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
            #[inline(always)]
            pub fn uep_auto_tog(&self) -> UEP_AUTO_TOG_R {
                UEP_AUTO_TOG_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
            #[inline(always)]
            pub fn uep_t_tog(&self) -> UEP_T_TOG_R {
                UEP_T_TOG_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
            #[inline(always)]
            pub fn uep_r_tog(&self) -> UEP_R_TOG_R {
                UEP_R_TOG_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)
            #[inline(always)]
            #[must_use]
            pub fn mask_uep_t_res(&mut self) -> MASK_UEP_T_RES_W<EP5_CTRL_SPEC> {
                MASK_UEP_T_RES_W::new(self, 0)
            }
            ///Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)
            #[inline(always)]
            #[must_use]
            pub fn mask_uep_r_res(&mut self) -> MASK_UEP_R_RES_W<EP5_CTRL_SPEC> {
                MASK_UEP_R_RES_W::new(self, 2)
            }
            ///Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
            #[inline(always)]
            #[must_use]
            pub fn uep_auto_tog(&mut self) -> UEP_AUTO_TOG_W<EP5_CTRL_SPEC> {
                UEP_AUTO_TOG_W::new(self, 4)
            }
            ///Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
            #[inline(always)]
            #[must_use]
            pub fn uep_t_tog(&mut self) -> UEP_T_TOG_W<EP5_CTRL_SPEC> {
                UEP_T_TOG_W::new(self, 6)
            }
            ///Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
            #[inline(always)]
            #[must_use]
            pub fn uep_r_tog(&mut self) -> UEP_R_TOG_W<EP5_CTRL_SPEC> {
                UEP_R_TOG_W::new(self, 7)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///USB2 endpoint 5 control
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`ep5_ctrl::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ep5_ctrl::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct EP5_CTRL_SPEC;
        impl crate::RegisterSpec for EP5_CTRL_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`ep5_ctrl::R`](R) reader structure
        impl crate::Readable for EP5_CTRL_SPEC {}
        ///`write(|w| ..)` method takes [`ep5_ctrl::W`](W) writer structure
        impl crate::Writable for EP5_CTRL_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets EP5_CTRL to value 0
        impl crate::Resettable for EP5_CTRL_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///EP6_T_LEN (rw) register accessor: USB2 endpoint 6 transmittal length
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`ep6_t_len::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ep6_t_len::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@ep6_t_len`]
    ///module
    pub type EP6_T_LEN = crate::Reg<ep6_t_len::EP6_T_LEN_SPEC>;
    ///USB2 endpoint 6 transmittal length
    pub mod ep6_t_len {
        ///Register `EP6_T_LEN` reader
        pub type R = crate::R<EP6_T_LEN_SPEC>;
        ///Register `EP6_T_LEN` writer
        pub type W = crate::W<EP6_T_LEN_SPEC>;
        ///Field `UEP6_T_LEN` reader - endpoint 6 transmittal length
        pub type UEP6_T_LEN_R = crate::FieldReader;
        ///Field `UEP6_T_LEN` writer - endpoint 6 transmittal length
        pub type UEP6_T_LEN_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            ///Bits 0:7 - endpoint 6 transmittal length
            #[inline(always)]
            pub fn uep6_t_len(&self) -> UEP6_T_LEN_R {
                UEP6_T_LEN_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:7 - endpoint 6 transmittal length
            #[inline(always)]
            #[must_use]
            pub fn uep6_t_len(&mut self) -> UEP6_T_LEN_W<EP6_T_LEN_SPEC> {
                UEP6_T_LEN_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///USB2 endpoint 6 transmittal length
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`ep6_t_len::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ep6_t_len::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct EP6_T_LEN_SPEC;
        impl crate::RegisterSpec for EP6_T_LEN_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`ep6_t_len::R`](R) reader structure
        impl crate::Readable for EP6_T_LEN_SPEC {}
        ///`write(|w| ..)` method takes [`ep6_t_len::W`](W) writer structure
        impl crate::Writable for EP6_T_LEN_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets EP6_T_LEN to value 0
        impl crate::Resettable for EP6_T_LEN_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///EP6_CTRL (rw) register accessor: USB2 endpoint 6 control
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`ep6_ctrl::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ep6_ctrl::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@ep6_ctrl`]
    ///module
    pub type EP6_CTRL = crate::Reg<ep6_ctrl::EP6_CTRL_SPEC>;
    ///USB2 endpoint 6 control
    pub mod ep6_ctrl {
        ///Register `EP6_CTRL` reader
        pub type R = crate::R<EP6_CTRL_SPEC>;
        ///Register `EP6_CTRL` writer
        pub type W = crate::W<EP6_CTRL_SPEC>;
        ///Field `MASK_UEP_T_RES` reader - bit mask of handshake response type for USB endpoint X transmittal (IN)
        pub type MASK_UEP_T_RES_R = crate::FieldReader;
        ///Field `MASK_UEP_T_RES` writer - bit mask of handshake response type for USB endpoint X transmittal (IN)
        pub type MASK_UEP_T_RES_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `MASK_UEP_R_RES` reader - bit mask of handshake response type for USB endpoint X receiving (OUT)
        pub type MASK_UEP_R_RES_R = crate::FieldReader;
        ///Field `MASK_UEP_R_RES` writer - bit mask of handshake response type for USB endpoint X receiving (OUT)
        pub type MASK_UEP_R_RES_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `UEP_AUTO_TOG` reader - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
        pub type UEP_AUTO_TOG_R = crate::BitReader;
        ///Field `UEP_AUTO_TOG` writer - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
        pub type UEP_AUTO_TOG_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UEP_T_TOG` reader - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
        pub type UEP_T_TOG_R = crate::BitReader;
        ///Field `UEP_T_TOG` writer - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
        pub type UEP_T_TOG_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UEP_R_TOG` reader - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
        pub type UEP_R_TOG_R = crate::BitReader;
        ///Field `UEP_R_TOG` writer - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
        pub type UEP_R_TOG_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)
            #[inline(always)]
            pub fn mask_uep_t_res(&self) -> MASK_UEP_T_RES_R {
                MASK_UEP_T_RES_R::new(self.bits & 3)
            }
            ///Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)
            #[inline(always)]
            pub fn mask_uep_r_res(&self) -> MASK_UEP_R_RES_R {
                MASK_UEP_R_RES_R::new((self.bits >> 2) & 3)
            }
            ///Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
            #[inline(always)]
            pub fn uep_auto_tog(&self) -> UEP_AUTO_TOG_R {
                UEP_AUTO_TOG_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
            #[inline(always)]
            pub fn uep_t_tog(&self) -> UEP_T_TOG_R {
                UEP_T_TOG_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
            #[inline(always)]
            pub fn uep_r_tog(&self) -> UEP_R_TOG_R {
                UEP_R_TOG_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)
            #[inline(always)]
            #[must_use]
            pub fn mask_uep_t_res(&mut self) -> MASK_UEP_T_RES_W<EP6_CTRL_SPEC> {
                MASK_UEP_T_RES_W::new(self, 0)
            }
            ///Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)
            #[inline(always)]
            #[must_use]
            pub fn mask_uep_r_res(&mut self) -> MASK_UEP_R_RES_W<EP6_CTRL_SPEC> {
                MASK_UEP_R_RES_W::new(self, 2)
            }
            ///Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
            #[inline(always)]
            #[must_use]
            pub fn uep_auto_tog(&mut self) -> UEP_AUTO_TOG_W<EP6_CTRL_SPEC> {
                UEP_AUTO_TOG_W::new(self, 4)
            }
            ///Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
            #[inline(always)]
            #[must_use]
            pub fn uep_t_tog(&mut self) -> UEP_T_TOG_W<EP6_CTRL_SPEC> {
                UEP_T_TOG_W::new(self, 6)
            }
            ///Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
            #[inline(always)]
            #[must_use]
            pub fn uep_r_tog(&mut self) -> UEP_R_TOG_W<EP6_CTRL_SPEC> {
                UEP_R_TOG_W::new(self, 7)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///USB2 endpoint 6 control
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`ep6_ctrl::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ep6_ctrl::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct EP6_CTRL_SPEC;
        impl crate::RegisterSpec for EP6_CTRL_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`ep6_ctrl::R`](R) reader structure
        impl crate::Readable for EP6_CTRL_SPEC {}
        ///`write(|w| ..)` method takes [`ep6_ctrl::W`](W) writer structure
        impl crate::Writable for EP6_CTRL_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets EP6_CTRL to value 0
        impl crate::Resettable for EP6_CTRL_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///EP7_T_LEN (rw) register accessor: USB2 endpoint 7 transmittal length
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`ep7_t_len::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ep7_t_len::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@ep7_t_len`]
    ///module
    pub type EP7_T_LEN = crate::Reg<ep7_t_len::EP7_T_LEN_SPEC>;
    ///USB2 endpoint 7 transmittal length
    pub mod ep7_t_len {
        ///Register `EP7_T_LEN` reader
        pub type R = crate::R<EP7_T_LEN_SPEC>;
        ///Register `EP7_T_LEN` writer
        pub type W = crate::W<EP7_T_LEN_SPEC>;
        ///Field `UEP7_T_LEN` reader - endpoint 7 transmittal length
        pub type UEP7_T_LEN_R = crate::FieldReader;
        ///Field `UEP7_T_LEN` writer - endpoint 7 transmittal length
        pub type UEP7_T_LEN_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            ///Bits 0:7 - endpoint 7 transmittal length
            #[inline(always)]
            pub fn uep7_t_len(&self) -> UEP7_T_LEN_R {
                UEP7_T_LEN_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:7 - endpoint 7 transmittal length
            #[inline(always)]
            #[must_use]
            pub fn uep7_t_len(&mut self) -> UEP7_T_LEN_W<EP7_T_LEN_SPEC> {
                UEP7_T_LEN_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///USB2 endpoint 7 transmittal length
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`ep7_t_len::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ep7_t_len::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct EP7_T_LEN_SPEC;
        impl crate::RegisterSpec for EP7_T_LEN_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`ep7_t_len::R`](R) reader structure
        impl crate::Readable for EP7_T_LEN_SPEC {}
        ///`write(|w| ..)` method takes [`ep7_t_len::W`](W) writer structure
        impl crate::Writable for EP7_T_LEN_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets EP7_T_LEN to value 0
        impl crate::Resettable for EP7_T_LEN_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///EP7_CTRL (rw) register accessor: USB2 endpoint 7 control
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`ep7_ctrl::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ep7_ctrl::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@ep7_ctrl`]
    ///module
    pub type EP7_CTRL = crate::Reg<ep7_ctrl::EP7_CTRL_SPEC>;
    ///USB2 endpoint 7 control
    pub mod ep7_ctrl {
        ///Register `EP7_CTRL` reader
        pub type R = crate::R<EP7_CTRL_SPEC>;
        ///Register `EP7_CTRL` writer
        pub type W = crate::W<EP7_CTRL_SPEC>;
        ///Field `MASK_UEP_T_RES` reader - bit mask of handshake response type for USB endpoint X transmittal (IN)
        pub type MASK_UEP_T_RES_R = crate::FieldReader;
        ///Field `MASK_UEP_T_RES` writer - bit mask of handshake response type for USB endpoint X transmittal (IN)
        pub type MASK_UEP_T_RES_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `MASK_UEP_R_RES` reader - bit mask of handshake response type for USB endpoint X receiving (OUT)
        pub type MASK_UEP_R_RES_R = crate::FieldReader;
        ///Field `MASK_UEP_R_RES` writer - bit mask of handshake response type for USB endpoint X receiving (OUT)
        pub type MASK_UEP_R_RES_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `UEP_AUTO_TOG` reader - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
        pub type UEP_AUTO_TOG_R = crate::BitReader;
        ///Field `UEP_AUTO_TOG` writer - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
        pub type UEP_AUTO_TOG_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UEP_T_TOG` reader - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
        pub type UEP_T_TOG_R = crate::BitReader;
        ///Field `UEP_T_TOG` writer - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
        pub type UEP_T_TOG_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UEP_R_TOG` reader - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
        pub type UEP_R_TOG_R = crate::BitReader;
        ///Field `UEP_R_TOG` writer - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
        pub type UEP_R_TOG_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)
            #[inline(always)]
            pub fn mask_uep_t_res(&self) -> MASK_UEP_T_RES_R {
                MASK_UEP_T_RES_R::new(self.bits & 3)
            }
            ///Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)
            #[inline(always)]
            pub fn mask_uep_r_res(&self) -> MASK_UEP_R_RES_R {
                MASK_UEP_R_RES_R::new((self.bits >> 2) & 3)
            }
            ///Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
            #[inline(always)]
            pub fn uep_auto_tog(&self) -> UEP_AUTO_TOG_R {
                UEP_AUTO_TOG_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
            #[inline(always)]
            pub fn uep_t_tog(&self) -> UEP_T_TOG_R {
                UEP_T_TOG_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
            #[inline(always)]
            pub fn uep_r_tog(&self) -> UEP_R_TOG_R {
                UEP_R_TOG_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)
            #[inline(always)]
            #[must_use]
            pub fn mask_uep_t_res(&mut self) -> MASK_UEP_T_RES_W<EP7_CTRL_SPEC> {
                MASK_UEP_T_RES_W::new(self, 0)
            }
            ///Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)
            #[inline(always)]
            #[must_use]
            pub fn mask_uep_r_res(&mut self) -> MASK_UEP_R_RES_W<EP7_CTRL_SPEC> {
                MASK_UEP_R_RES_W::new(self, 2)
            }
            ///Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
            #[inline(always)]
            #[must_use]
            pub fn uep_auto_tog(&mut self) -> UEP_AUTO_TOG_W<EP7_CTRL_SPEC> {
                UEP_AUTO_TOG_W::new(self, 4)
            }
            ///Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
            #[inline(always)]
            #[must_use]
            pub fn uep_t_tog(&mut self) -> UEP_T_TOG_W<EP7_CTRL_SPEC> {
                UEP_T_TOG_W::new(self, 6)
            }
            ///Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
            #[inline(always)]
            #[must_use]
            pub fn uep_r_tog(&mut self) -> UEP_R_TOG_W<EP7_CTRL_SPEC> {
                UEP_R_TOG_W::new(self, 7)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///USB2 endpoint 7 control
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`ep7_ctrl::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ep7_ctrl::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct EP7_CTRL_SPEC;
        impl crate::RegisterSpec for EP7_CTRL_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`ep7_ctrl::R`](R) reader structure
        impl crate::Readable for EP7_CTRL_SPEC {}
        ///`write(|w| ..)` method takes [`ep7_ctrl::W`](W) writer structure
        impl crate::Writable for EP7_CTRL_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets EP7_CTRL to value 0
        impl crate::Resettable for EP7_CTRL_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
}
///Program Fast Interrupt Controller
pub struct PFIC {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for PFIC {}
impl PFIC {
    ///Pointer to the register block
    pub const PTR: *const pfic::RegisterBlock = 0xe000_e000 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const pfic::RegisterBlock {
        Self::PTR
    }
    /// Steal an instance of this peripheral
    ///
    /// # Safety
    ///
    /// Ensure that the new instance of the peripheral cannot be used in a way
    /// that may race with any existing instances, for example by only
    /// accessing read-only or write-only registers, or by consuming the
    /// original peripheral and using critical sections to coordinate
    /// access between multiple new instances.
    ///
    /// Additionally, other software such as HALs may rely on only one
    /// peripheral instance existing to ensure memory safety; ensure
    /// no stolen instances are passed to such software.
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for PFIC {
    type Target = pfic::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for PFIC {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("PFIC").finish()
    }
}
///Program Fast Interrupt Controller
pub mod pfic {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        isr1: ISR1,
        isr2: ISR2,
        _reserved2: [u8; 0x18],
        ipr1: IPR1,
        ipr2: IPR2,
        _reserved4: [u8; 0x18],
        ithresdr: ITHRESDR,
        _reserved5: [u8; 0x04],
        cfgr: CFGR,
        gisr: GISR,
        idcfgr: IDCFGR,
        _reserved8: [u8; 0x0c],
        fiaddrr0: FIADDRR0,
        fiaddrr1: FIADDRR1,
        fiaddrr2: FIADDRR2,
        fiaddrr3: FIADDRR3,
        _reserved12: [u8; 0x90],
        ienr1: IENR1,
        ienr2: IENR2,
        _reserved14: [u8; 0x78],
        irer1: IRER1,
        irer2: IRER2,
        _reserved16: [u8; 0x78],
        ipsr1: IPSR1,
        ipsr2: IPSR2,
        _reserved18: [u8; 0x78],
        iprr1: IPRR1,
        iprr2: IPRR2,
        _reserved20: [u8; 0x78],
        iactr1: IACTR1,
        iactr2: IACTR2,
        _reserved22: [u8; 0xf8],
        iprior0: IPRIOR0,
        _reserved23: [u8; 0x1c],
        iprior1: IPRIOR1,
        _reserved24: [u8; 0x1c],
        iprior2: IPRIOR2,
        _reserved25: [u8; 0x1c],
        iprior3: IPRIOR3,
        _reserved26: [u8; 0x1c],
        iprior4: IPRIOR4,
        _reserved27: [u8; 0x1c],
        iprior5: IPRIOR5,
        _reserved28: [u8; 0x1c],
        iprior6: IPRIOR6,
        _reserved29: [u8; 0x1c],
        iprior7: IPRIOR7,
        _reserved30: [u8; 0x1c],
        iprior8: IPRIOR8,
        _reserved31: [u8; 0x1c],
        iprior9: IPRIOR9,
        _reserved32: [u8; 0x1c],
        iprior10: IPRIOR10,
        _reserved33: [u8; 0x1c],
        iprior11: IPRIOR11,
        _reserved34: [u8; 0x1c],
        iprior12: IPRIOR12,
        _reserved35: [u8; 0x1c],
        iprior13: IPRIOR13,
        _reserved36: [u8; 0x1c],
        iprior14: IPRIOR14,
        _reserved37: [u8; 0x1c],
        iprior15: IPRIOR15,
        _reserved38: [u8; 0x1c],
        iprior16: IPRIOR16,
        _reserved39: [u8; 0x1c],
        iprior17: IPRIOR17,
        _reserved40: [u8; 0x1c],
        iprior18: IPRIOR18,
        _reserved41: [u8; 0x1c],
        iprior19: IPRIOR19,
        _reserved42: [u8; 0x1c],
        iprior20: IPRIOR20,
        _reserved43: [u8; 0x1c],
        iprior21: IPRIOR21,
        _reserved44: [u8; 0x1c],
        iprior22: IPRIOR22,
        _reserved45: [u8; 0x1c],
        iprior23: IPRIOR23,
        _reserved46: [u8; 0x1c],
        iprior24: IPRIOR24,
        _reserved47: [u8; 0x1c],
        iprior25: IPRIOR25,
        _reserved48: [u8; 0x1c],
        iprior26: IPRIOR26,
        _reserved49: [u8; 0x1c],
        iprior27: IPRIOR27,
        _reserved50: [u8; 0x1c],
        iprior28: IPRIOR28,
        _reserved51: [u8; 0x1c],
        iprior29: IPRIOR29,
        _reserved52: [u8; 0x1c],
        iprior30: IPRIOR30,
        _reserved53: [u8; 0x1c],
        iprior31: IPRIOR31,
        _reserved54: [u8; 0x1c],
        iprior32: IPRIOR32,
        _reserved55: [u8; 0x1c],
        iprior33: IPRIOR33,
        _reserved56: [u8; 0x1c],
        iprior34: IPRIOR34,
        _reserved57: [u8; 0x1c],
        iprior35: IPRIOR35,
        _reserved58: [u8; 0x1c],
        iprior36: IPRIOR36,
        _reserved59: [u8; 0x1c],
        iprior37: IPRIOR37,
        _reserved60: [u8; 0x1c],
        iprior38: IPRIOR38,
        _reserved61: [u8; 0x1c],
        iprior39: IPRIOR39,
        _reserved62: [u8; 0x1c],
        iprior40: IPRIOR40,
        _reserved63: [u8; 0x1c],
        iprior41: IPRIOR41,
        _reserved64: [u8; 0x1c],
        iprior42: IPRIOR42,
        _reserved65: [u8; 0x1c],
        iprior43: IPRIOR43,
        _reserved66: [u8; 0x1c],
        iprior44: IPRIOR44,
        _reserved67: [u8; 0x1c],
        iprior45: IPRIOR45,
        _reserved68: [u8; 0x1c],
        iprior46: IPRIOR46,
        _reserved69: [u8; 0x1c],
        iprior47: IPRIOR47,
        _reserved70: [u8; 0x1c],
        iprior48: IPRIOR48,
        _reserved71: [u8; 0x1c],
        iprior49: IPRIOR49,
        _reserved72: [u8; 0x1c],
        iprior50: IPRIOR50,
        _reserved73: [u8; 0x1c],
        iprior51: IPRIOR51,
        _reserved74: [u8; 0x1c],
        iprior52: IPRIOR52,
        _reserved75: [u8; 0x1c],
        iprior53: IPRIOR53,
        _reserved76: [u8; 0x2c],
        iprior54: IPRIOR54,
        _reserved77: [u8; 0x0c],
        iprior55: IPRIOR55,
        _reserved78: [u8; 0x1c],
        iprior56: IPRIOR56,
        _reserved79: [u8; 0x1c],
        iprior57: IPRIOR57,
        _reserved80: [u8; 0x1c],
        iprior58: IPRIOR58,
        _reserved81: [u8; 0x1c],
        iprior59: IPRIOR59,
        _reserved82: [u8; 0x1c],
        iprior60: IPRIOR60,
        _reserved83: [u8; 0x1c],
        iprior61: IPRIOR61,
        _reserved84: [u8; 0x3c],
        iprior62: IPRIOR62,
        _reserved85: [u8; 0x1c],
        iprior63: IPRIOR63,
        _reserved86: [u8; 0x010c],
        sctlr: SCTLR,
    }
    impl RegisterBlock {
        ///0x00 - RO,Interrupt Status Register 1
        #[inline(always)]
        pub const fn isr1(&self) -> &ISR1 {
            &self.isr1
        }
        ///0x04 - RO,Interrupt Status Register 2
        #[inline(always)]
        pub const fn isr2(&self) -> &ISR2 {
            &self.isr2
        }
        ///0x20 - RO,Interrupt Pending Register 1
        #[inline(always)]
        pub const fn ipr1(&self) -> &IPR1 {
            &self.ipr1
        }
        ///0x24 - RO,Interrupt Pending Register 2
        #[inline(always)]
        pub const fn ipr2(&self) -> &IPR2 {
            &self.ipr2
        }
        ///0x40 - RW,Interrupt Priority Register
        #[inline(always)]
        pub const fn ithresdr(&self) -> &ITHRESDR {
            &self.ithresdr
        }
        ///0x48 - Interrupt Config Register
        #[inline(always)]
        pub const fn cfgr(&self) -> &CFGR {
            &self.cfgr
        }
        ///0x4c - Interrupt Global Register
        #[inline(always)]
        pub const fn gisr(&self) -> &GISR {
            &self.gisr
        }
        ///0x50 - RW,Interrupt Fast ID Config Register
        #[inline(always)]
        pub const fn idcfgr(&self) -> &IDCFGR {
            &self.idcfgr
        }
        ///0x60 - Interrupt 0 address Register
        #[inline(always)]
        pub const fn fiaddrr0(&self) -> &FIADDRR0 {
            &self.fiaddrr0
        }
        ///0x64 - Interrupt 1 address Register
        #[inline(always)]
        pub const fn fiaddrr1(&self) -> &FIADDRR1 {
            &self.fiaddrr1
        }
        ///0x68 - Interrupt 2 address Register
        #[inline(always)]
        pub const fn fiaddrr2(&self) -> &FIADDRR2 {
            &self.fiaddrr2
        }
        ///0x6c - Interrupt 3 address Register
        #[inline(always)]
        pub const fn fiaddrr3(&self) -> &FIADDRR3 {
            &self.fiaddrr3
        }
        ///0x100 - Interrupt Setting Register
        #[inline(always)]
        pub const fn ienr1(&self) -> &IENR1 {
            &self.ienr1
        }
        ///0x104 - Interrupt Setting Register
        #[inline(always)]
        pub const fn ienr2(&self) -> &IENR2 {
            &self.ienr2
        }
        ///0x180 - Interrupt Clear Register
        #[inline(always)]
        pub const fn irer1(&self) -> &IRER1 {
            &self.irer1
        }
        ///0x184 - Interrupt Clear Register
        #[inline(always)]
        pub const fn irer2(&self) -> &IRER2 {
            &self.irer2
        }
        ///0x200 - Interrupt Pending Register
        #[inline(always)]
        pub const fn ipsr1(&self) -> &IPSR1 {
            &self.ipsr1
        }
        ///0x204 - Interrupt Pending Register
        #[inline(always)]
        pub const fn ipsr2(&self) -> &IPSR2 {
            &self.ipsr2
        }
        ///0x280 - Interrupt Pending Clear Register
        #[inline(always)]
        pub const fn iprr1(&self) -> &IPRR1 {
            &self.iprr1
        }
        ///0x284 - Interrupt Pending Clear Register
        #[inline(always)]
        pub const fn iprr2(&self) -> &IPRR2 {
            &self.iprr2
        }
        ///0x300 - Interrupt ACTIVE Register
        #[inline(always)]
        pub const fn iactr1(&self) -> &IACTR1 {
            &self.iactr1
        }
        ///0x304 - Interrupt ACTIVE Register
        #[inline(always)]
        pub const fn iactr2(&self) -> &IACTR2 {
            &self.iactr2
        }
        ///0x400 - Interrupt Priority configuration Register 0
        #[inline(always)]
        pub const fn iprior0(&self) -> &IPRIOR0 {
            &self.iprior0
        }
        ///0x420 - Interrupt Priority configuration Register 1
        #[inline(always)]
        pub const fn iprior1(&self) -> &IPRIOR1 {
            &self.iprior1
        }
        ///0x440 - Interrupt Priority configuration Register 2
        #[inline(always)]
        pub const fn iprior2(&self) -> &IPRIOR2 {
            &self.iprior2
        }
        ///0x460 - Interrupt Priority configuration Register 3
        #[inline(always)]
        pub const fn iprior3(&self) -> &IPRIOR3 {
            &self.iprior3
        }
        ///0x480 - Interrupt Priority configuration Register 4
        #[inline(always)]
        pub const fn iprior4(&self) -> &IPRIOR4 {
            &self.iprior4
        }
        ///0x4a0 - Interrupt Priority configuration Register 5
        #[inline(always)]
        pub const fn iprior5(&self) -> &IPRIOR5 {
            &self.iprior5
        }
        ///0x4c0 - Interrupt Priority configuration Register 6
        #[inline(always)]
        pub const fn iprior6(&self) -> &IPRIOR6 {
            &self.iprior6
        }
        ///0x4e0 - Interrupt Priority configuration Register 7
        #[inline(always)]
        pub const fn iprior7(&self) -> &IPRIOR7 {
            &self.iprior7
        }
        ///0x500 - Interrupt Priority configuration Register 8
        #[inline(always)]
        pub const fn iprior8(&self) -> &IPRIOR8 {
            &self.iprior8
        }
        ///0x520 - Interrupt Priority configuration Register 9
        #[inline(always)]
        pub const fn iprior9(&self) -> &IPRIOR9 {
            &self.iprior9
        }
        ///0x540 - Interrupt Priority configuration Register 10
        #[inline(always)]
        pub const fn iprior10(&self) -> &IPRIOR10 {
            &self.iprior10
        }
        ///0x560 - Interrupt Priority configuration Register 11
        #[inline(always)]
        pub const fn iprior11(&self) -> &IPRIOR11 {
            &self.iprior11
        }
        ///0x580 - Interrupt Priority configuration Register 12
        #[inline(always)]
        pub const fn iprior12(&self) -> &IPRIOR12 {
            &self.iprior12
        }
        ///0x5a0 - Interrupt Priority configuration Register 13
        #[inline(always)]
        pub const fn iprior13(&self) -> &IPRIOR13 {
            &self.iprior13
        }
        ///0x5c0 - Interrupt Priority configuration Register 14
        #[inline(always)]
        pub const fn iprior14(&self) -> &IPRIOR14 {
            &self.iprior14
        }
        ///0x5e0 - Interrupt Priority configuration Register 15
        #[inline(always)]
        pub const fn iprior15(&self) -> &IPRIOR15 {
            &self.iprior15
        }
        ///0x600 - Interrupt Priority configuration Register 16
        #[inline(always)]
        pub const fn iprior16(&self) -> &IPRIOR16 {
            &self.iprior16
        }
        ///0x620 - Interrupt Priority configuration Register 17
        #[inline(always)]
        pub const fn iprior17(&self) -> &IPRIOR17 {
            &self.iprior17
        }
        ///0x640 - Interrupt Priority configuration Register 18
        #[inline(always)]
        pub const fn iprior18(&self) -> &IPRIOR18 {
            &self.iprior18
        }
        ///0x660 - Interrupt Priority configuration Register 19
        #[inline(always)]
        pub const fn iprior19(&self) -> &IPRIOR19 {
            &self.iprior19
        }
        ///0x680 - Interrupt Priority configuration Register 20
        #[inline(always)]
        pub const fn iprior20(&self) -> &IPRIOR20 {
            &self.iprior20
        }
        ///0x6a0 - Interrupt Priority configuration Register 21
        #[inline(always)]
        pub const fn iprior21(&self) -> &IPRIOR21 {
            &self.iprior21
        }
        ///0x6c0 - Interrupt Priority configuration Register 22
        #[inline(always)]
        pub const fn iprior22(&self) -> &IPRIOR22 {
            &self.iprior22
        }
        ///0x6e0 - Interrupt Priority configuration Register 23
        #[inline(always)]
        pub const fn iprior23(&self) -> &IPRIOR23 {
            &self.iprior23
        }
        ///0x700 - Interrupt Priority configuration Register 24
        #[inline(always)]
        pub const fn iprior24(&self) -> &IPRIOR24 {
            &self.iprior24
        }
        ///0x720 - Interrupt Priority configuration Register 25
        #[inline(always)]
        pub const fn iprior25(&self) -> &IPRIOR25 {
            &self.iprior25
        }
        ///0x740 - Interrupt Priority configuration Register 26
        #[inline(always)]
        pub const fn iprior26(&self) -> &IPRIOR26 {
            &self.iprior26
        }
        ///0x760 - Interrupt Priority configuration Register 27
        #[inline(always)]
        pub const fn iprior27(&self) -> &IPRIOR27 {
            &self.iprior27
        }
        ///0x780 - Interrupt Priority configuration Register 28
        #[inline(always)]
        pub const fn iprior28(&self) -> &IPRIOR28 {
            &self.iprior28
        }
        ///0x7a0 - Interrupt Priority configuration Register 29
        #[inline(always)]
        pub const fn iprior29(&self) -> &IPRIOR29 {
            &self.iprior29
        }
        ///0x7c0 - Interrupt Priority configuration Register 30
        #[inline(always)]
        pub const fn iprior30(&self) -> &IPRIOR30 {
            &self.iprior30
        }
        ///0x7e0 - Interrupt Priority configuration Register 31
        #[inline(always)]
        pub const fn iprior31(&self) -> &IPRIOR31 {
            &self.iprior31
        }
        ///0x800 - Interrupt Priority configuration Register 32
        #[inline(always)]
        pub const fn iprior32(&self) -> &IPRIOR32 {
            &self.iprior32
        }
        ///0x820 - Interrupt Priority configuration Register 33
        #[inline(always)]
        pub const fn iprior33(&self) -> &IPRIOR33 {
            &self.iprior33
        }
        ///0x840 - Interrupt Priority configuration Register 34
        #[inline(always)]
        pub const fn iprior34(&self) -> &IPRIOR34 {
            &self.iprior34
        }
        ///0x860 - Interrupt Priority configuration Register 35
        #[inline(always)]
        pub const fn iprior35(&self) -> &IPRIOR35 {
            &self.iprior35
        }
        ///0x880 - Interrupt Priority configuration Register 36
        #[inline(always)]
        pub const fn iprior36(&self) -> &IPRIOR36 {
            &self.iprior36
        }
        ///0x8a0 - Interrupt Priority configuration Register 37
        #[inline(always)]
        pub const fn iprior37(&self) -> &IPRIOR37 {
            &self.iprior37
        }
        ///0x8c0 - Interrupt Priority configuration Register 38
        #[inline(always)]
        pub const fn iprior38(&self) -> &IPRIOR38 {
            &self.iprior38
        }
        ///0x8e0 - Interrupt Priority configuration Register 39
        #[inline(always)]
        pub const fn iprior39(&self) -> &IPRIOR39 {
            &self.iprior39
        }
        ///0x900 - Interrupt Priority configuration Register 40
        #[inline(always)]
        pub const fn iprior40(&self) -> &IPRIOR40 {
            &self.iprior40
        }
        ///0x920 - Interrupt Priority configuration Register 41
        #[inline(always)]
        pub const fn iprior41(&self) -> &IPRIOR41 {
            &self.iprior41
        }
        ///0x940 - Interrupt Priority configuration Register 42
        #[inline(always)]
        pub const fn iprior42(&self) -> &IPRIOR42 {
            &self.iprior42
        }
        ///0x960 - Interrupt Priority configuration Register 43
        #[inline(always)]
        pub const fn iprior43(&self) -> &IPRIOR43 {
            &self.iprior43
        }
        ///0x980 - Interrupt Priority configuration Register 44
        #[inline(always)]
        pub const fn iprior44(&self) -> &IPRIOR44 {
            &self.iprior44
        }
        ///0x9a0 - Interrupt Priority configuration Register 45
        #[inline(always)]
        pub const fn iprior45(&self) -> &IPRIOR45 {
            &self.iprior45
        }
        ///0x9c0 - Interrupt Priority configuration Register 46
        #[inline(always)]
        pub const fn iprior46(&self) -> &IPRIOR46 {
            &self.iprior46
        }
        ///0x9e0 - Interrupt Priority configuration Register 47
        #[inline(always)]
        pub const fn iprior47(&self) -> &IPRIOR47 {
            &self.iprior47
        }
        ///0xa00 - Interrupt Priority configuration Register 48
        #[inline(always)]
        pub const fn iprior48(&self) -> &IPRIOR48 {
            &self.iprior48
        }
        ///0xa20 - Interrupt Priority configuration Register 49
        #[inline(always)]
        pub const fn iprior49(&self) -> &IPRIOR49 {
            &self.iprior49
        }
        ///0xa40 - Interrupt Priority configuration Register 50
        #[inline(always)]
        pub const fn iprior50(&self) -> &IPRIOR50 {
            &self.iprior50
        }
        ///0xa60 - Interrupt Priority configuration Register 51
        #[inline(always)]
        pub const fn iprior51(&self) -> &IPRIOR51 {
            &self.iprior51
        }
        ///0xa80 - Interrupt Priority configuration Register 52
        #[inline(always)]
        pub const fn iprior52(&self) -> &IPRIOR52 {
            &self.iprior52
        }
        ///0xaa0 - Interrupt Priority configuration Register 53
        #[inline(always)]
        pub const fn iprior53(&self) -> &IPRIOR53 {
            &self.iprior53
        }
        ///0xad0 - Interrupt Priority configuration Register 54
        #[inline(always)]
        pub const fn iprior54(&self) -> &IPRIOR54 {
            &self.iprior54
        }
        ///0xae0 - Interrupt Priority configuration Register 55
        #[inline(always)]
        pub const fn iprior55(&self) -> &IPRIOR55 {
            &self.iprior55
        }
        ///0xb00 - Interrupt Priority configuration Register 56
        #[inline(always)]
        pub const fn iprior56(&self) -> &IPRIOR56 {
            &self.iprior56
        }
        ///0xb20 - Interrupt Priority configuration Register 57
        #[inline(always)]
        pub const fn iprior57(&self) -> &IPRIOR57 {
            &self.iprior57
        }
        ///0xb40 - Interrupt Priority configuration Register 58
        #[inline(always)]
        pub const fn iprior58(&self) -> &IPRIOR58 {
            &self.iprior58
        }
        ///0xb60 - Interrupt Priority configuration Register 59
        #[inline(always)]
        pub const fn iprior59(&self) -> &IPRIOR59 {
            &self.iprior59
        }
        ///0xb80 - Interrupt Priority configuration Register 60
        #[inline(always)]
        pub const fn iprior60(&self) -> &IPRIOR60 {
            &self.iprior60
        }
        ///0xba0 - Interrupt Priority configuration Register 61
        #[inline(always)]
        pub const fn iprior61(&self) -> &IPRIOR61 {
            &self.iprior61
        }
        ///0xbe0 - Interrupt Priority configuration Register 62
        #[inline(always)]
        pub const fn iprior62(&self) -> &IPRIOR62 {
            &self.iprior62
        }
        ///0xc00 - Interrupt Priority configuration Register 63
        #[inline(always)]
        pub const fn iprior63(&self) -> &IPRIOR63 {
            &self.iprior63
        }
        ///0xd10 - System Control Register
        #[inline(always)]
        pub const fn sctlr(&self) -> &SCTLR {
            &self.sctlr
        }
    }
    ///ISR1 (r) register accessor: RO,Interrupt Status Register 1
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`isr1::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@isr1`]
    ///module
    pub type ISR1 = crate::Reg<isr1::ISR1_SPEC>;
    ///RO,Interrupt Status Register 1
    pub mod isr1 {
        ///Register `ISR1` reader
        pub type R = crate::R<ISR1_SPEC>;
        ///Field `INTENSTA` reader - Interrupt ID Status
        pub type INTENSTA_R = crate::FieldReader<u32>;
        impl R {
            ///Bits 12:31 - Interrupt ID Status
            #[inline(always)]
            pub fn intensta(&self) -> INTENSTA_R {
                INTENSTA_R::new((self.bits >> 12) & 0x000f_ffff)
            }
        }
        ///RO,Interrupt Status Register 1
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`isr1::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct ISR1_SPEC;
        impl crate::RegisterSpec for ISR1_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`isr1::R`](R) reader structure
        impl crate::Readable for ISR1_SPEC {}
        ///`reset()` method sets ISR1 to value 0
        impl crate::Resettable for ISR1_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///ISR2 (r) register accessor: RO,Interrupt Status Register 2
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`isr2::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@isr2`]
    ///module
    pub type ISR2 = crate::Reg<isr2::ISR2_SPEC>;
    ///RO,Interrupt Status Register 2
    pub mod isr2 {
        ///Register `ISR2` reader
        pub type R = crate::R<ISR2_SPEC>;
        ///Field `INTENSTA` reader - Interrupt ID Status
        pub type INTENSTA_R = crate::FieldReader;
        impl R {
            ///Bits 0:3 - Interrupt ID Status
            #[inline(always)]
            pub fn intensta(&self) -> INTENSTA_R {
                INTENSTA_R::new((self.bits & 0x0f) as u8)
            }
        }
        ///RO,Interrupt Status Register 2
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`isr2::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct ISR2_SPEC;
        impl crate::RegisterSpec for ISR2_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`isr2::R`](R) reader structure
        impl crate::Readable for ISR2_SPEC {}
        ///`reset()` method sets ISR2 to value 0
        impl crate::Resettable for ISR2_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPR1 (r) register accessor: RO,Interrupt Pending Register 1
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`ipr1::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@ipr1`]
    ///module
    pub type IPR1 = crate::Reg<ipr1::IPR1_SPEC>;
    ///RO,Interrupt Pending Register 1
    pub mod ipr1 {
        ///Register `IPR1` reader
        pub type R = crate::R<IPR1_SPEC>;
        ///Field `PENDSTA` reader - PENDSTA
        pub type PENDSTA_R = crate::FieldReader<u32>;
        impl R {
            ///Bits 12:31 - PENDSTA
            #[inline(always)]
            pub fn pendsta(&self) -> PENDSTA_R {
                PENDSTA_R::new((self.bits >> 12) & 0x000f_ffff)
            }
        }
        ///RO,Interrupt Pending Register 1
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`ipr1::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPR1_SPEC;
        impl crate::RegisterSpec for IPR1_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`ipr1::R`](R) reader structure
        impl crate::Readable for IPR1_SPEC {}
        ///`reset()` method sets IPR1 to value 0
        impl crate::Resettable for IPR1_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPR2 (r) register accessor: RO,Interrupt Pending Register 2
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`ipr2::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@ipr2`]
    ///module
    pub type IPR2 = crate::Reg<ipr2::IPR2_SPEC>;
    ///RO,Interrupt Pending Register 2
    pub mod ipr2 {
        ///Register `IPR2` reader
        pub type R = crate::R<IPR2_SPEC>;
        ///Field `PENDSTA` reader - PENDSTA
        pub type PENDSTA_R = crate::FieldReader;
        impl R {
            ///Bits 0:3 - PENDSTA
            #[inline(always)]
            pub fn pendsta(&self) -> PENDSTA_R {
                PENDSTA_R::new((self.bits & 0x0f) as u8)
            }
        }
        ///RO,Interrupt Pending Register 2
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`ipr2::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPR2_SPEC;
        impl crate::RegisterSpec for IPR2_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`ipr2::R`](R) reader structure
        impl crate::Readable for IPR2_SPEC {}
        ///`reset()` method sets IPR2 to value 0
        impl crate::Resettable for IPR2_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///ITHRESDR (rw) register accessor: RW,Interrupt Priority Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`ithresdr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ithresdr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@ithresdr`]
    ///module
    pub type ITHRESDR = crate::Reg<ithresdr::ITHRESDR_SPEC>;
    ///RW,Interrupt Priority Register
    pub mod ithresdr {
        ///Register `ITHRESDR` reader
        pub type R = crate::R<ITHRESDR_SPEC>;
        ///Register `ITHRESDR` writer
        pub type W = crate::W<ITHRESDR_SPEC>;
        ///Field `THRESHOLD` reader - RW,THRESHOLD
        pub type THRESHOLD_R = crate::FieldReader;
        ///Field `THRESHOLD` writer - RW,THRESHOLD
        pub type THRESHOLD_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            ///Bits 0:7 - RW,THRESHOLD
            #[inline(always)]
            pub fn threshold(&self) -> THRESHOLD_R {
                THRESHOLD_R::new((self.bits & 0xff) as u8)
            }
        }
        impl W {
            ///Bits 0:7 - RW,THRESHOLD
            #[inline(always)]
            #[must_use]
            pub fn threshold(&mut self) -> THRESHOLD_W<ITHRESDR_SPEC> {
                THRESHOLD_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW,Interrupt Priority Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`ithresdr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ithresdr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct ITHRESDR_SPEC;
        impl crate::RegisterSpec for ITHRESDR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`ithresdr::R`](R) reader structure
        impl crate::Readable for ITHRESDR_SPEC {}
        ///`write(|w| ..)` method takes [`ithresdr::W`](W) writer structure
        impl crate::Writable for ITHRESDR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets ITHRESDR to value 0
        impl crate::Resettable for ITHRESDR_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///CFGR (w) register accessor: Interrupt Config Register
    ///
    ///You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cfgr::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@cfgr`]
    ///module
    pub type CFGR = crate::Reg<cfgr::CFGR_SPEC>;
    ///Interrupt Config Register
    pub mod cfgr {
        ///Register `CFGR` writer
        pub type W = crate::W<CFGR_SPEC>;
        ///Field `RESETSYS` writer - WO,RESETSYS
        pub type RESETSYS_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `KEYCODE` writer - WO,KEYCODE
        pub type KEYCODE_W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl W {
            ///Bit 7 - WO,RESETSYS
            #[inline(always)]
            #[must_use]
            pub fn resetsys(&mut self) -> RESETSYS_W<CFGR_SPEC> {
                RESETSYS_W::new(self, 7)
            }
            ///Bits 16:31 - WO,KEYCODE
            #[inline(always)]
            #[must_use]
            pub fn keycode(&mut self) -> KEYCODE_W<CFGR_SPEC> {
                KEYCODE_W::new(self, 16)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Config Register
        ///
        ///You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cfgr::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct CFGR_SPEC;
        impl crate::RegisterSpec for CFGR_SPEC {
            type Ux = u32;
        }
        ///`write(|w| ..)` method takes [`cfgr::W`](W) writer structure
        impl crate::Writable for CFGR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets CFGR to value 0
        impl crate::Resettable for CFGR_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///GISR (r) register accessor: Interrupt Global Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`gisr::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@gisr`]
    ///module
    pub type GISR = crate::Reg<gisr::GISR_SPEC>;
    ///Interrupt Global Register
    pub mod gisr {
        ///Register `GISR` reader
        pub type R = crate::R<GISR_SPEC>;
        ///Field `NESTSTA` reader - RO,NESTSTA
        pub type NESTSTA_R = crate::FieldReader;
        ///Field `GACTSTA` reader - RO,GACTSTA
        pub type GACTSTA_R = crate::BitReader;
        ///Field `GPENDSTA` reader - RO,GPENDSTA
        pub type GPENDSTA_R = crate::BitReader;
        impl R {
            ///Bits 0:7 - RO,NESTSTA
            #[inline(always)]
            pub fn neststa(&self) -> NESTSTA_R {
                NESTSTA_R::new((self.bits & 0xff) as u8)
            }
            ///Bit 8 - RO,GACTSTA
            #[inline(always)]
            pub fn gactsta(&self) -> GACTSTA_R {
                GACTSTA_R::new(((self.bits >> 8) & 1) != 0)
            }
            ///Bit 9 - RO,GPENDSTA
            #[inline(always)]
            pub fn gpendsta(&self) -> GPENDSTA_R {
                GPENDSTA_R::new(((self.bits >> 9) & 1) != 0)
            }
        }
        ///Interrupt Global Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`gisr::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct GISR_SPEC;
        impl crate::RegisterSpec for GISR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`gisr::R`](R) reader structure
        impl crate::Readable for GISR_SPEC {}
        ///`reset()` method sets GISR to value 0
        impl crate::Resettable for GISR_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IDCFGR (rw) register accessor: RW,Interrupt Fast ID Config Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`idcfgr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`idcfgr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@idcfgr`]
    ///module
    pub type IDCFGR = crate::Reg<idcfgr::IDCFGR_SPEC>;
    ///RW,Interrupt Fast ID Config Register
    pub mod idcfgr {
        ///Register `IDCFGR` reader
        pub type R = crate::R<IDCFGR_SPEC>;
        ///Register `IDCFGR` writer
        pub type W = crate::W<IDCFGR_SPEC>;
        ///Field `FIID0` reader - RW,FIID0
        pub type FIID0_R = crate::FieldReader;
        ///Field `FIID0` writer - RW,FIID0
        pub type FIID0_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        ///Field `FIID1` reader - RW,FIID1
        pub type FIID1_R = crate::FieldReader;
        ///Field `FIID1` writer - RW,FIID1
        pub type FIID1_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        ///Field `FIID2` reader - RW,FIID2
        pub type FIID2_R = crate::FieldReader;
        ///Field `FIID2` writer - RW,FIID2
        pub type FIID2_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        ///Field `FIID3` reader - RW,FIID3
        pub type FIID3_R = crate::FieldReader;
        ///Field `FIID3` writer - RW,FIID3
        pub type FIID3_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            ///Bits 0:7 - RW,FIID0
            #[inline(always)]
            pub fn fiid0(&self) -> FIID0_R {
                FIID0_R::new((self.bits & 0xff) as u8)
            }
            ///Bits 8:15 - RW,FIID1
            #[inline(always)]
            pub fn fiid1(&self) -> FIID1_R {
                FIID1_R::new(((self.bits >> 8) & 0xff) as u8)
            }
            ///Bits 16:23 - RW,FIID2
            #[inline(always)]
            pub fn fiid2(&self) -> FIID2_R {
                FIID2_R::new(((self.bits >> 16) & 0xff) as u8)
            }
            ///Bits 24:31 - RW,FIID3
            #[inline(always)]
            pub fn fiid3(&self) -> FIID3_R {
                FIID3_R::new(((self.bits >> 24) & 0xff) as u8)
            }
        }
        impl W {
            ///Bits 0:7 - RW,FIID0
            #[inline(always)]
            #[must_use]
            pub fn fiid0(&mut self) -> FIID0_W<IDCFGR_SPEC> {
                FIID0_W::new(self, 0)
            }
            ///Bits 8:15 - RW,FIID1
            #[inline(always)]
            #[must_use]
            pub fn fiid1(&mut self) -> FIID1_W<IDCFGR_SPEC> {
                FIID1_W::new(self, 8)
            }
            ///Bits 16:23 - RW,FIID2
            #[inline(always)]
            #[must_use]
            pub fn fiid2(&mut self) -> FIID2_W<IDCFGR_SPEC> {
                FIID2_W::new(self, 16)
            }
            ///Bits 24:31 - RW,FIID3
            #[inline(always)]
            #[must_use]
            pub fn fiid3(&mut self) -> FIID3_W<IDCFGR_SPEC> {
                FIID3_W::new(self, 24)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RW,Interrupt Fast ID Config Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`idcfgr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`idcfgr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IDCFGR_SPEC;
        impl crate::RegisterSpec for IDCFGR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`idcfgr::R`](R) reader structure
        impl crate::Readable for IDCFGR_SPEC {}
        ///`write(|w| ..)` method takes [`idcfgr::W`](W) writer structure
        impl crate::Writable for IDCFGR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IDCFGR to value 0
        impl crate::Resettable for IDCFGR_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///FIADDRR0 (rw) register accessor: Interrupt 0 address Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`fiaddrr0::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`fiaddrr0::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@fiaddrr0`]
    ///module
    pub type FIADDRR0 = crate::Reg<fiaddrr0::FIADDRR0_SPEC>;
    ///Interrupt 0 address Register
    pub mod fiaddrr0 {
        ///Register `FIADDRR0` reader
        pub type R = crate::R<FIADDRR0_SPEC>;
        ///Register `FIADDRR0` writer
        pub type W = crate::W<FIADDRR0_SPEC>;
        ///Field `FI0EN` reader - RW,FI0EN
        pub type FI0EN_R = crate::BitReader;
        ///Field `FI0EN` writer - RW,FI0EN
        pub type FI0EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `ADDR0` reader - RW,ADDR0
        pub type ADDR0_R = crate::FieldReader<u32>;
        ///Field `ADDR0` writer - RW,ADDR0
        pub type ADDR0_W<'a, REG> = crate::FieldWriter<'a, REG, 31, u32>;
        impl R {
            ///Bit 0 - RW,FI0EN
            #[inline(always)]
            pub fn fi0en(&self) -> FI0EN_R {
                FI0EN_R::new((self.bits & 1) != 0)
            }
            ///Bits 1:31 - RW,ADDR0
            #[inline(always)]
            pub fn addr0(&self) -> ADDR0_R {
                ADDR0_R::new((self.bits >> 1) & 0x7fff_ffff)
            }
        }
        impl W {
            ///Bit 0 - RW,FI0EN
            #[inline(always)]
            #[must_use]
            pub fn fi0en(&mut self) -> FI0EN_W<FIADDRR0_SPEC> {
                FI0EN_W::new(self, 0)
            }
            ///Bits 1:31 - RW,ADDR0
            #[inline(always)]
            #[must_use]
            pub fn addr0(&mut self) -> ADDR0_W<FIADDRR0_SPEC> {
                ADDR0_W::new(self, 1)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt 0 address Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`fiaddrr0::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`fiaddrr0::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct FIADDRR0_SPEC;
        impl crate::RegisterSpec for FIADDRR0_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`fiaddrr0::R`](R) reader structure
        impl crate::Readable for FIADDRR0_SPEC {}
        ///`write(|w| ..)` method takes [`fiaddrr0::W`](W) writer structure
        impl crate::Writable for FIADDRR0_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets FIADDRR0 to value 0
        impl crate::Resettable for FIADDRR0_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///FIADDRR1 (rw) register accessor: Interrupt 1 address Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`fiaddrr1::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`fiaddrr1::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@fiaddrr1`]
    ///module
    pub type FIADDRR1 = crate::Reg<fiaddrr1::FIADDRR1_SPEC>;
    ///Interrupt 1 address Register
    pub mod fiaddrr1 {
        ///Register `FIADDRR1` reader
        pub type R = crate::R<FIADDRR1_SPEC>;
        ///Register `FIADDRR1` writer
        pub type W = crate::W<FIADDRR1_SPEC>;
        ///Field `FI1EN` reader - RW,FI1EN
        pub type FI1EN_R = crate::BitReader;
        ///Field `FI1EN` writer - RW,FI1EN
        pub type FI1EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `ADDR1` reader - RW,ADDR1
        pub type ADDR1_R = crate::FieldReader<u32>;
        ///Field `ADDR1` writer - RW,ADDR1
        pub type ADDR1_W<'a, REG> = crate::FieldWriter<'a, REG, 31, u32>;
        impl R {
            ///Bit 0 - RW,FI1EN
            #[inline(always)]
            pub fn fi1en(&self) -> FI1EN_R {
                FI1EN_R::new((self.bits & 1) != 0)
            }
            ///Bits 1:31 - RW,ADDR1
            #[inline(always)]
            pub fn addr1(&self) -> ADDR1_R {
                ADDR1_R::new((self.bits >> 1) & 0x7fff_ffff)
            }
        }
        impl W {
            ///Bit 0 - RW,FI1EN
            #[inline(always)]
            #[must_use]
            pub fn fi1en(&mut self) -> FI1EN_W<FIADDRR1_SPEC> {
                FI1EN_W::new(self, 0)
            }
            ///Bits 1:31 - RW,ADDR1
            #[inline(always)]
            #[must_use]
            pub fn addr1(&mut self) -> ADDR1_W<FIADDRR1_SPEC> {
                ADDR1_W::new(self, 1)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt 1 address Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`fiaddrr1::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`fiaddrr1::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct FIADDRR1_SPEC;
        impl crate::RegisterSpec for FIADDRR1_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`fiaddrr1::R`](R) reader structure
        impl crate::Readable for FIADDRR1_SPEC {}
        ///`write(|w| ..)` method takes [`fiaddrr1::W`](W) writer structure
        impl crate::Writable for FIADDRR1_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets FIADDRR1 to value 0
        impl crate::Resettable for FIADDRR1_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///FIADDRR2 (rw) register accessor: Interrupt 2 address Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`fiaddrr2::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`fiaddrr2::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@fiaddrr2`]
    ///module
    pub type FIADDRR2 = crate::Reg<fiaddrr2::FIADDRR2_SPEC>;
    ///Interrupt 2 address Register
    pub mod fiaddrr2 {
        ///Register `FIADDRR2` reader
        pub type R = crate::R<FIADDRR2_SPEC>;
        ///Register `FIADDRR2` writer
        pub type W = crate::W<FIADDRR2_SPEC>;
        ///Field `FI2EN` reader - RW,FI2EN
        pub type FI2EN_R = crate::BitReader;
        ///Field `FI2EN` writer - RW,FI2EN
        pub type FI2EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `ADDR2` reader - RW,ADDR2
        pub type ADDR2_R = crate::FieldReader<u32>;
        ///Field `ADDR2` writer - RW,ADDR2
        pub type ADDR2_W<'a, REG> = crate::FieldWriter<'a, REG, 31, u32>;
        impl R {
            ///Bit 0 - RW,FI2EN
            #[inline(always)]
            pub fn fi2en(&self) -> FI2EN_R {
                FI2EN_R::new((self.bits & 1) != 0)
            }
            ///Bits 1:31 - RW,ADDR2
            #[inline(always)]
            pub fn addr2(&self) -> ADDR2_R {
                ADDR2_R::new((self.bits >> 1) & 0x7fff_ffff)
            }
        }
        impl W {
            ///Bit 0 - RW,FI2EN
            #[inline(always)]
            #[must_use]
            pub fn fi2en(&mut self) -> FI2EN_W<FIADDRR2_SPEC> {
                FI2EN_W::new(self, 0)
            }
            ///Bits 1:31 - RW,ADDR2
            #[inline(always)]
            #[must_use]
            pub fn addr2(&mut self) -> ADDR2_W<FIADDRR2_SPEC> {
                ADDR2_W::new(self, 1)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt 2 address Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`fiaddrr2::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`fiaddrr2::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct FIADDRR2_SPEC;
        impl crate::RegisterSpec for FIADDRR2_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`fiaddrr2::R`](R) reader structure
        impl crate::Readable for FIADDRR2_SPEC {}
        ///`write(|w| ..)` method takes [`fiaddrr2::W`](W) writer structure
        impl crate::Writable for FIADDRR2_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets FIADDRR2 to value 0
        impl crate::Resettable for FIADDRR2_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///FIADDRR3 (rw) register accessor: Interrupt 3 address Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`fiaddrr3::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`fiaddrr3::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@fiaddrr3`]
    ///module
    pub type FIADDRR3 = crate::Reg<fiaddrr3::FIADDRR3_SPEC>;
    ///Interrupt 3 address Register
    pub mod fiaddrr3 {
        ///Register `FIADDRR3` reader
        pub type R = crate::R<FIADDRR3_SPEC>;
        ///Register `FIADDRR3` writer
        pub type W = crate::W<FIADDRR3_SPEC>;
        ///Field `FI3EN` reader - RW,FI3EN
        pub type FI3EN_R = crate::BitReader;
        ///Field `FI3EN` writer - RW,FI3EN
        pub type FI3EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `ADDR3` reader - RW,ADDR3
        pub type ADDR3_R = crate::FieldReader<u32>;
        ///Field `ADDR3` writer - RW,ADDR3
        pub type ADDR3_W<'a, REG> = crate::FieldWriter<'a, REG, 31, u32>;
        impl R {
            ///Bit 0 - RW,FI3EN
            #[inline(always)]
            pub fn fi3en(&self) -> FI3EN_R {
                FI3EN_R::new((self.bits & 1) != 0)
            }
            ///Bits 1:31 - RW,ADDR3
            #[inline(always)]
            pub fn addr3(&self) -> ADDR3_R {
                ADDR3_R::new((self.bits >> 1) & 0x7fff_ffff)
            }
        }
        impl W {
            ///Bit 0 - RW,FI3EN
            #[inline(always)]
            #[must_use]
            pub fn fi3en(&mut self) -> FI3EN_W<FIADDRR3_SPEC> {
                FI3EN_W::new(self, 0)
            }
            ///Bits 1:31 - RW,ADDR3
            #[inline(always)]
            #[must_use]
            pub fn addr3(&mut self) -> ADDR3_W<FIADDRR3_SPEC> {
                ADDR3_W::new(self, 1)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt 3 address Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`fiaddrr3::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`fiaddrr3::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct FIADDRR3_SPEC;
        impl crate::RegisterSpec for FIADDRR3_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`fiaddrr3::R`](R) reader structure
        impl crate::Readable for FIADDRR3_SPEC {}
        ///`write(|w| ..)` method takes [`fiaddrr3::W`](W) writer structure
        impl crate::Writable for FIADDRR3_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets FIADDRR3 to value 0
        impl crate::Resettable for FIADDRR3_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IENR1 (w) register accessor: Interrupt Setting Register
    ///
    ///You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ienr1::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@ienr1`]
    ///module
    pub type IENR1 = crate::Reg<ienr1::IENR1_SPEC>;
    ///Interrupt Setting Register
    pub mod ienr1 {
        ///Register `IENR1` writer
        pub type W = crate::W<IENR1_SPEC>;
        ///Field `INTEN` writer - RW1,INTEN
        pub type INTEN_W<'a, REG> = crate::FieldWriter<'a, REG, 20, u32>;
        impl W {
            ///Bits 12:31 - RW1,INTEN
            #[inline(always)]
            #[must_use]
            pub fn inten(&mut self) -> INTEN_W<IENR1_SPEC> {
                INTEN_W::new(self, 12)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Setting Register
        ///
        ///You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ienr1::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IENR1_SPEC;
        impl crate::RegisterSpec for IENR1_SPEC {
            type Ux = u32;
        }
        ///`write(|w| ..)` method takes [`ienr1::W`](W) writer structure
        impl crate::Writable for IENR1_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IENR1 to value 0
        impl crate::Resettable for IENR1_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IENR2 (w) register accessor: Interrupt Setting Register
    ///
    ///You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ienr2::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@ienr2`]
    ///module
    pub type IENR2 = crate::Reg<ienr2::IENR2_SPEC>;
    ///Interrupt Setting Register
    pub mod ienr2 {
        ///Register `IENR2` writer
        pub type W = crate::W<IENR2_SPEC>;
        ///Field `INTEN` writer - RW1,INTEN
        pub type INTEN_W<'a, REG> = crate::FieldWriter<'a, REG, 4>;
        impl W {
            ///Bits 0:3 - RW1,INTEN
            #[inline(always)]
            #[must_use]
            pub fn inten(&mut self) -> INTEN_W<IENR2_SPEC> {
                INTEN_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Setting Register
        ///
        ///You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ienr2::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IENR2_SPEC;
        impl crate::RegisterSpec for IENR2_SPEC {
            type Ux = u32;
        }
        ///`write(|w| ..)` method takes [`ienr2::W`](W) writer structure
        impl crate::Writable for IENR2_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IENR2 to value 0
        impl crate::Resettable for IENR2_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IRER1 (w) register accessor: Interrupt Clear Register
    ///
    ///You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`irer1::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@irer1`]
    ///module
    pub type IRER1 = crate::Reg<irer1::IRER1_SPEC>;
    ///Interrupt Clear Register
    pub mod irer1 {
        ///Register `IRER1` writer
        pub type W = crate::W<IRER1_SPEC>;
        ///Field `INTRESET` writer - RW1,INTRESET
        pub type INTRESET_W<'a, REG> = crate::FieldWriter<'a, REG, 20, u32>;
        impl W {
            ///Bits 12:31 - RW1,INTRESET
            #[inline(always)]
            #[must_use]
            pub fn intreset(&mut self) -> INTRESET_W<IRER1_SPEC> {
                INTRESET_W::new(self, 12)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Clear Register
        ///
        ///You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`irer1::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IRER1_SPEC;
        impl crate::RegisterSpec for IRER1_SPEC {
            type Ux = u32;
        }
        ///`write(|w| ..)` method takes [`irer1::W`](W) writer structure
        impl crate::Writable for IRER1_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IRER1 to value 0
        impl crate::Resettable for IRER1_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IRER2 (w) register accessor: Interrupt Clear Register
    ///
    ///You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`irer2::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@irer2`]
    ///module
    pub type IRER2 = crate::Reg<irer2::IRER2_SPEC>;
    ///Interrupt Clear Register
    pub mod irer2 {
        ///Register `IRER2` writer
        pub type W = crate::W<IRER2_SPEC>;
        ///Field `INTRESET` writer - RW1,INTRESET
        pub type INTRESET_W<'a, REG> = crate::FieldWriter<'a, REG, 4>;
        impl W {
            ///Bits 0:3 - RW1,INTRESET
            #[inline(always)]
            #[must_use]
            pub fn intreset(&mut self) -> INTRESET_W<IRER2_SPEC> {
                INTRESET_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Clear Register
        ///
        ///You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`irer2::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IRER2_SPEC;
        impl crate::RegisterSpec for IRER2_SPEC {
            type Ux = u32;
        }
        ///`write(|w| ..)` method takes [`irer2::W`](W) writer structure
        impl crate::Writable for IRER2_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IRER2 to value 0
        impl crate::Resettable for IRER2_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPSR1 (w) register accessor: Interrupt Pending Register
    ///
    ///You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ipsr1::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@ipsr1`]
    ///module
    pub type IPSR1 = crate::Reg<ipsr1::IPSR1_SPEC>;
    ///Interrupt Pending Register
    pub mod ipsr1 {
        ///Register `IPSR1` writer
        pub type W = crate::W<IPSR1_SPEC>;
        ///Field `PENDSET` writer - RW1,PENDSET
        pub type PENDSET_W<'a, REG> = crate::FieldWriter<'a, REG, 20, u32>;
        impl W {
            ///Bits 12:31 - RW1,PENDSET
            #[inline(always)]
            #[must_use]
            pub fn pendset(&mut self) -> PENDSET_W<IPSR1_SPEC> {
                PENDSET_W::new(self, 12)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Pending Register
        ///
        ///You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ipsr1::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPSR1_SPEC;
        impl crate::RegisterSpec for IPSR1_SPEC {
            type Ux = u32;
        }
        ///`write(|w| ..)` method takes [`ipsr1::W`](W) writer structure
        impl crate::Writable for IPSR1_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPSR1 to value 0
        impl crate::Resettable for IPSR1_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPSR2 (w) register accessor: Interrupt Pending Register
    ///
    ///You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ipsr2::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@ipsr2`]
    ///module
    pub type IPSR2 = crate::Reg<ipsr2::IPSR2_SPEC>;
    ///Interrupt Pending Register
    pub mod ipsr2 {
        ///Register `IPSR2` writer
        pub type W = crate::W<IPSR2_SPEC>;
        ///Field `PENDSET` writer - RW1,PENDSET
        pub type PENDSET_W<'a, REG> = crate::FieldWriter<'a, REG, 4>;
        impl W {
            ///Bits 0:3 - RW1,PENDSET
            #[inline(always)]
            #[must_use]
            pub fn pendset(&mut self) -> PENDSET_W<IPSR2_SPEC> {
                PENDSET_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Pending Register
        ///
        ///You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ipsr2::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPSR2_SPEC;
        impl crate::RegisterSpec for IPSR2_SPEC {
            type Ux = u32;
        }
        ///`write(|w| ..)` method takes [`ipsr2::W`](W) writer structure
        impl crate::Writable for IPSR2_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPSR2 to value 0
        impl crate::Resettable for IPSR2_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRR1 (w) register accessor: Interrupt Pending Clear Register
    ///
    ///You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprr1::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprr1`]
    ///module
    pub type IPRR1 = crate::Reg<iprr1::IPRR1_SPEC>;
    ///Interrupt Pending Clear Register
    pub mod iprr1 {
        ///Register `IPRR1` writer
        pub type W = crate::W<IPRR1_SPEC>;
        ///Field `PENDRESET` writer - RW1,PENDRESET
        pub type PENDRESET_W<'a, REG> = crate::FieldWriter<'a, REG, 20, u32>;
        impl W {
            ///Bits 12:31 - RW1,PENDRESET
            #[inline(always)]
            #[must_use]
            pub fn pendreset(&mut self) -> PENDRESET_W<IPRR1_SPEC> {
                PENDRESET_W::new(self, 12)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Pending Clear Register
        ///
        ///You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprr1::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRR1_SPEC;
        impl crate::RegisterSpec for IPRR1_SPEC {
            type Ux = u32;
        }
        ///`write(|w| ..)` method takes [`iprr1::W`](W) writer structure
        impl crate::Writable for IPRR1_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRR1 to value 0
        impl crate::Resettable for IPRR1_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRR2 (w) register accessor: Interrupt Pending Clear Register
    ///
    ///You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprr2::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprr2`]
    ///module
    pub type IPRR2 = crate::Reg<iprr2::IPRR2_SPEC>;
    ///Interrupt Pending Clear Register
    pub mod iprr2 {
        ///Register `IPRR2` writer
        pub type W = crate::W<IPRR2_SPEC>;
        ///Field `PENDRESET` writer - RW1,PENDRESET
        pub type PENDRESET_W<'a, REG> = crate::FieldWriter<'a, REG, 4>;
        impl W {
            ///Bits 0:3 - RW1,PENDRESET
            #[inline(always)]
            #[must_use]
            pub fn pendreset(&mut self) -> PENDRESET_W<IPRR2_SPEC> {
                PENDRESET_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Pending Clear Register
        ///
        ///You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprr2::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRR2_SPEC;
        impl crate::RegisterSpec for IPRR2_SPEC {
            type Ux = u32;
        }
        ///`write(|w| ..)` method takes [`iprr2::W`](W) writer structure
        impl crate::Writable for IPRR2_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRR2 to value 0
        impl crate::Resettable for IPRR2_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IACTR1 (rw) register accessor: Interrupt ACTIVE Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iactr1::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iactr1::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iactr1`]
    ///module
    pub type IACTR1 = crate::Reg<iactr1::IACTR1_SPEC>;
    ///Interrupt ACTIVE Register
    pub mod iactr1 {
        ///Register `IACTR1` reader
        pub type R = crate::R<IACTR1_SPEC>;
        ///Register `IACTR1` writer
        pub type W = crate::W<IACTR1_SPEC>;
        ///Field `IACTS` reader - RW1,IACTS
        pub type IACTS_R = crate::FieldReader<u32>;
        ///Field `IACTS` writer - RW1,IACTS
        pub type IACTS_W<'a, REG> = crate::FieldWriter<'a, REG, 20, u32>;
        impl R {
            ///Bits 12:31 - RW1,IACTS
            #[inline(always)]
            pub fn iacts(&self) -> IACTS_R {
                IACTS_R::new((self.bits >> 12) & 0x000f_ffff)
            }
        }
        impl W {
            ///Bits 12:31 - RW1,IACTS
            #[inline(always)]
            #[must_use]
            pub fn iacts(&mut self) -> IACTS_W<IACTR1_SPEC> {
                IACTS_W::new(self, 12)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt ACTIVE Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iactr1::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iactr1::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IACTR1_SPEC;
        impl crate::RegisterSpec for IACTR1_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iactr1::R`](R) reader structure
        impl crate::Readable for IACTR1_SPEC {}
        ///`write(|w| ..)` method takes [`iactr1::W`](W) writer structure
        impl crate::Writable for IACTR1_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IACTR1 to value 0
        impl crate::Resettable for IACTR1_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IACTR2 (rw) register accessor: Interrupt ACTIVE Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iactr2::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iactr2::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iactr2`]
    ///module
    pub type IACTR2 = crate::Reg<iactr2::IACTR2_SPEC>;
    ///Interrupt ACTIVE Register
    pub mod iactr2 {
        ///Register `IACTR2` reader
        pub type R = crate::R<IACTR2_SPEC>;
        ///Register `IACTR2` writer
        pub type W = crate::W<IACTR2_SPEC>;
        ///Field `IACTS` reader - RW1,IACTS
        pub type IACTS_R = crate::FieldReader;
        ///Field `IACTS` writer - RW1,IACTS
        pub type IACTS_W<'a, REG> = crate::FieldWriter<'a, REG, 4>;
        impl R {
            ///Bits 0:3 - RW1,IACTS
            #[inline(always)]
            pub fn iacts(&self) -> IACTS_R {
                IACTS_R::new((self.bits & 0x0f) as u8)
            }
        }
        impl W {
            ///Bits 0:3 - RW1,IACTS
            #[inline(always)]
            #[must_use]
            pub fn iacts(&mut self) -> IACTS_W<IACTR2_SPEC> {
                IACTS_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt ACTIVE Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iactr2::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iactr2::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IACTR2_SPEC;
        impl crate::RegisterSpec for IACTR2_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iactr2::R`](R) reader structure
        impl crate::Readable for IACTR2_SPEC {}
        ///`write(|w| ..)` method takes [`iactr2::W`](W) writer structure
        impl crate::Writable for IACTR2_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IACTR2 to value 0
        impl crate::Resettable for IACTR2_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR0 (rw) register accessor: Interrupt Priority configuration Register 0
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior0::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior0::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior0`]
    ///module
    pub type IPRIOR0 = crate::Reg<iprior0::IPRIOR0_SPEC>;
    ///Interrupt Priority configuration Register 0
    pub mod iprior0 {
        ///Register `IPRIOR0` reader
        pub type R = crate::R<IPRIOR0_SPEC>;
        ///Register `IPRIOR0` writer
        pub type W = crate::W<IPRIOR0_SPEC>;
        ///Field `IPRIOR0` reader - RW,Interrupt priority for number 0-3
        pub type IPRIOR0_R = crate::FieldReader<u32>;
        ///Field `IPRIOR0` writer - RW,Interrupt priority for number 0-3
        pub type IPRIOR0_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 0-3
            #[inline(always)]
            pub fn iprior0(&self) -> IPRIOR0_R {
                IPRIOR0_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 0-3
            #[inline(always)]
            #[must_use]
            pub fn iprior0(&mut self) -> IPRIOR0_W<IPRIOR0_SPEC> {
                IPRIOR0_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register 0
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior0::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior0::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR0_SPEC;
        impl crate::RegisterSpec for IPRIOR0_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior0::R`](R) reader structure
        impl crate::Readable for IPRIOR0_SPEC {}
        ///`write(|w| ..)` method takes [`iprior0::W`](W) writer structure
        impl crate::Writable for IPRIOR0_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR0 to value 0
        impl crate::Resettable for IPRIOR0_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR1 (rw) register accessor: Interrupt Priority configuration Register 1
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior1::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior1::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior1`]
    ///module
    pub type IPRIOR1 = crate::Reg<iprior1::IPRIOR1_SPEC>;
    ///Interrupt Priority configuration Register 1
    pub mod iprior1 {
        ///Register `IPRIOR1` reader
        pub type R = crate::R<IPRIOR1_SPEC>;
        ///Register `IPRIOR1` writer
        pub type W = crate::W<IPRIOR1_SPEC>;
        ///Field `IPRIOR1` reader - >RW,Interrupt priority for number 4-7
        pub type IPRIOR1_R = crate::FieldReader<u32>;
        ///Field `IPRIOR1` writer - >RW,Interrupt priority for number 4-7
        pub type IPRIOR1_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - >RW,Interrupt priority for number 4-7
            #[inline(always)]
            pub fn iprior1(&self) -> IPRIOR1_R {
                IPRIOR1_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - >RW,Interrupt priority for number 4-7
            #[inline(always)]
            #[must_use]
            pub fn iprior1(&mut self) -> IPRIOR1_W<IPRIOR1_SPEC> {
                IPRIOR1_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register 1
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior1::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior1::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR1_SPEC;
        impl crate::RegisterSpec for IPRIOR1_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior1::R`](R) reader structure
        impl crate::Readable for IPRIOR1_SPEC {}
        ///`write(|w| ..)` method takes [`iprior1::W`](W) writer structure
        impl crate::Writable for IPRIOR1_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR1 to value 0
        impl crate::Resettable for IPRIOR1_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR2 (rw) register accessor: Interrupt Priority configuration Register 2
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior2::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior2::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior2`]
    ///module
    pub type IPRIOR2 = crate::Reg<iprior2::IPRIOR2_SPEC>;
    ///Interrupt Priority configuration Register 2
    pub mod iprior2 {
        ///Register `IPRIOR2` reader
        pub type R = crate::R<IPRIOR2_SPEC>;
        ///Register `IPRIOR2` writer
        pub type W = crate::W<IPRIOR2_SPEC>;
        ///Field `IPRIOR2` reader - >RW,Interrupt priority for number 8-11
        pub type IPRIOR2_R = crate::FieldReader<u32>;
        ///Field `IPRIOR2` writer - >RW,Interrupt priority for number 8-11
        pub type IPRIOR2_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - >RW,Interrupt priority for number 8-11
            #[inline(always)]
            pub fn iprior2(&self) -> IPRIOR2_R {
                IPRIOR2_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - >RW,Interrupt priority for number 8-11
            #[inline(always)]
            #[must_use]
            pub fn iprior2(&mut self) -> IPRIOR2_W<IPRIOR2_SPEC> {
                IPRIOR2_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register 2
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior2::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior2::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR2_SPEC;
        impl crate::RegisterSpec for IPRIOR2_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior2::R`](R) reader structure
        impl crate::Readable for IPRIOR2_SPEC {}
        ///`write(|w| ..)` method takes [`iprior2::W`](W) writer structure
        impl crate::Writable for IPRIOR2_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR2 to value 0
        impl crate::Resettable for IPRIOR2_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR3 (rw) register accessor: Interrupt Priority configuration Register 3
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior3::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior3::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior3`]
    ///module
    pub type IPRIOR3 = crate::Reg<iprior3::IPRIOR3_SPEC>;
    ///Interrupt Priority configuration Register 3
    pub mod iprior3 {
        ///Register `IPRIOR3` reader
        pub type R = crate::R<IPRIOR3_SPEC>;
        ///Register `IPRIOR3` writer
        pub type W = crate::W<IPRIOR3_SPEC>;
        ///Field `IPRIOR3` reader - >RW,Interrupt priority for number 12-15
        pub type IPRIOR3_R = crate::FieldReader<u32>;
        ///Field `IPRIOR3` writer - >RW,Interrupt priority for number 12-15
        pub type IPRIOR3_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - >RW,Interrupt priority for number 12-15
            #[inline(always)]
            pub fn iprior3(&self) -> IPRIOR3_R {
                IPRIOR3_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - >RW,Interrupt priority for number 12-15
            #[inline(always)]
            #[must_use]
            pub fn iprior3(&mut self) -> IPRIOR3_W<IPRIOR3_SPEC> {
                IPRIOR3_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register 3
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior3::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior3::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR3_SPEC;
        impl crate::RegisterSpec for IPRIOR3_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior3::R`](R) reader structure
        impl crate::Readable for IPRIOR3_SPEC {}
        ///`write(|w| ..)` method takes [`iprior3::W`](W) writer structure
        impl crate::Writable for IPRIOR3_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR3 to value 0
        impl crate::Resettable for IPRIOR3_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR4 (rw) register accessor: Interrupt Priority configuration Register 4
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior4::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior4::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior4`]
    ///module
    pub type IPRIOR4 = crate::Reg<iprior4::IPRIOR4_SPEC>;
    ///Interrupt Priority configuration Register 4
    pub mod iprior4 {
        ///Register `IPRIOR4` reader
        pub type R = crate::R<IPRIOR4_SPEC>;
        ///Register `IPRIOR4` writer
        pub type W = crate::W<IPRIOR4_SPEC>;
        ///Field `IPRIOR4` reader - >RW,Interrupt priority for number 16-19
        pub type IPRIOR4_R = crate::FieldReader<u32>;
        ///Field `IPRIOR4` writer - >RW,Interrupt priority for number 16-19
        pub type IPRIOR4_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - >RW,Interrupt priority for number 16-19
            #[inline(always)]
            pub fn iprior4(&self) -> IPRIOR4_R {
                IPRIOR4_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - >RW,Interrupt priority for number 16-19
            #[inline(always)]
            #[must_use]
            pub fn iprior4(&mut self) -> IPRIOR4_W<IPRIOR4_SPEC> {
                IPRIOR4_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register 4
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior4::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior4::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR4_SPEC;
        impl crate::RegisterSpec for IPRIOR4_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior4::R`](R) reader structure
        impl crate::Readable for IPRIOR4_SPEC {}
        ///`write(|w| ..)` method takes [`iprior4::W`](W) writer structure
        impl crate::Writable for IPRIOR4_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR4 to value 0
        impl crate::Resettable for IPRIOR4_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR5 (rw) register accessor: Interrupt Priority configuration Register 5
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior5::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior5::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior5`]
    ///module
    pub type IPRIOR5 = crate::Reg<iprior5::IPRIOR5_SPEC>;
    ///Interrupt Priority configuration Register 5
    pub mod iprior5 {
        ///Register `IPRIOR5` reader
        pub type R = crate::R<IPRIOR5_SPEC>;
        ///Register `IPRIOR5` writer
        pub type W = crate::W<IPRIOR5_SPEC>;
        ///Field `IPRIOR5` reader - >RW,Interrupt priority for number 20-23
        pub type IPRIOR5_R = crate::FieldReader<u32>;
        ///Field `IPRIOR5` writer - >RW,Interrupt priority for number 20-23
        pub type IPRIOR5_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - >RW,Interrupt priority for number 20-23
            #[inline(always)]
            pub fn iprior5(&self) -> IPRIOR5_R {
                IPRIOR5_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - >RW,Interrupt priority for number 20-23
            #[inline(always)]
            #[must_use]
            pub fn iprior5(&mut self) -> IPRIOR5_W<IPRIOR5_SPEC> {
                IPRIOR5_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register 5
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior5::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior5::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR5_SPEC;
        impl crate::RegisterSpec for IPRIOR5_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior5::R`](R) reader structure
        impl crate::Readable for IPRIOR5_SPEC {}
        ///`write(|w| ..)` method takes [`iprior5::W`](W) writer structure
        impl crate::Writable for IPRIOR5_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR5 to value 0
        impl crate::Resettable for IPRIOR5_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR6 (rw) register accessor: Interrupt Priority configuration Register 6
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior6::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior6::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior6`]
    ///module
    pub type IPRIOR6 = crate::Reg<iprior6::IPRIOR6_SPEC>;
    ///Interrupt Priority configuration Register 6
    pub mod iprior6 {
        ///Register `IPRIOR6` reader
        pub type R = crate::R<IPRIOR6_SPEC>;
        ///Register `IPRIOR6` writer
        pub type W = crate::W<IPRIOR6_SPEC>;
        ///Field `IPRIOR6` reader - >RW,Interrupt priority for number 24-27
        pub type IPRIOR6_R = crate::FieldReader<u32>;
        ///Field `IPRIOR6` writer - >RW,Interrupt priority for number 24-27
        pub type IPRIOR6_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - >RW,Interrupt priority for number 24-27
            #[inline(always)]
            pub fn iprior6(&self) -> IPRIOR6_R {
                IPRIOR6_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - >RW,Interrupt priority for number 24-27
            #[inline(always)]
            #[must_use]
            pub fn iprior6(&mut self) -> IPRIOR6_W<IPRIOR6_SPEC> {
                IPRIOR6_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register 6
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior6::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior6::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR6_SPEC;
        impl crate::RegisterSpec for IPRIOR6_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior6::R`](R) reader structure
        impl crate::Readable for IPRIOR6_SPEC {}
        ///`write(|w| ..)` method takes [`iprior6::W`](W) writer structure
        impl crate::Writable for IPRIOR6_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR6 to value 0
        impl crate::Resettable for IPRIOR6_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR7 (rw) register accessor: Interrupt Priority configuration Register 7
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior7::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior7::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior7`]
    ///module
    pub type IPRIOR7 = crate::Reg<iprior7::IPRIOR7_SPEC>;
    ///Interrupt Priority configuration Register 7
    pub mod iprior7 {
        ///Register `IPRIOR7` reader
        pub type R = crate::R<IPRIOR7_SPEC>;
        ///Register `IPRIOR7` writer
        pub type W = crate::W<IPRIOR7_SPEC>;
        ///Field `IPRIOR7` reader - >RW,Interrupt priority for number 28-31
        pub type IPRIOR7_R = crate::FieldReader<u32>;
        ///Field `IPRIOR7` writer - >RW,Interrupt priority for number 28-31
        pub type IPRIOR7_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - >RW,Interrupt priority for number 28-31
            #[inline(always)]
            pub fn iprior7(&self) -> IPRIOR7_R {
                IPRIOR7_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - >RW,Interrupt priority for number 28-31
            #[inline(always)]
            #[must_use]
            pub fn iprior7(&mut self) -> IPRIOR7_W<IPRIOR7_SPEC> {
                IPRIOR7_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register 7
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior7::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior7::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR7_SPEC;
        impl crate::RegisterSpec for IPRIOR7_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior7::R`](R) reader structure
        impl crate::Readable for IPRIOR7_SPEC {}
        ///`write(|w| ..)` method takes [`iprior7::W`](W) writer structure
        impl crate::Writable for IPRIOR7_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR7 to value 0
        impl crate::Resettable for IPRIOR7_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR8 (rw) register accessor: Interrupt Priority configuration Register 8
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior8::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior8::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior8`]
    ///module
    pub type IPRIOR8 = crate::Reg<iprior8::IPRIOR8_SPEC>;
    ///Interrupt Priority configuration Register 8
    pub mod iprior8 {
        ///Register `IPRIOR8` reader
        pub type R = crate::R<IPRIOR8_SPEC>;
        ///Register `IPRIOR8` writer
        pub type W = crate::W<IPRIOR8_SPEC>;
        ///Field `IPRIOR8` reader - >RW,Interrupt priority for number 32-35
        pub type IPRIOR8_R = crate::FieldReader<u32>;
        ///Field `IPRIOR8` writer - >RW,Interrupt priority for number 32-35
        pub type IPRIOR8_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - >RW,Interrupt priority for number 32-35
            #[inline(always)]
            pub fn iprior8(&self) -> IPRIOR8_R {
                IPRIOR8_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - >RW,Interrupt priority for number 32-35
            #[inline(always)]
            #[must_use]
            pub fn iprior8(&mut self) -> IPRIOR8_W<IPRIOR8_SPEC> {
                IPRIOR8_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register 8
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior8::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior8::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR8_SPEC;
        impl crate::RegisterSpec for IPRIOR8_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior8::R`](R) reader structure
        impl crate::Readable for IPRIOR8_SPEC {}
        ///`write(|w| ..)` method takes [`iprior8::W`](W) writer structure
        impl crate::Writable for IPRIOR8_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR8 to value 0
        impl crate::Resettable for IPRIOR8_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR9 (rw) register accessor: Interrupt Priority configuration Register 9
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior9::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior9::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior9`]
    ///module
    pub type IPRIOR9 = crate::Reg<iprior9::IPRIOR9_SPEC>;
    ///Interrupt Priority configuration Register 9
    pub mod iprior9 {
        ///Register `IPRIOR9` reader
        pub type R = crate::R<IPRIOR9_SPEC>;
        ///Register `IPRIOR9` writer
        pub type W = crate::W<IPRIOR9_SPEC>;
        ///Field `IPRIOR9` reader - >RW,Interrupt priority for number 36-39
        pub type IPRIOR9_R = crate::FieldReader<u32>;
        ///Field `IPRIOR9` writer - >RW,Interrupt priority for number 36-39
        pub type IPRIOR9_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - >RW,Interrupt priority for number 36-39
            #[inline(always)]
            pub fn iprior9(&self) -> IPRIOR9_R {
                IPRIOR9_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - >RW,Interrupt priority for number 36-39
            #[inline(always)]
            #[must_use]
            pub fn iprior9(&mut self) -> IPRIOR9_W<IPRIOR9_SPEC> {
                IPRIOR9_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register 9
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior9::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior9::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR9_SPEC;
        impl crate::RegisterSpec for IPRIOR9_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior9::R`](R) reader structure
        impl crate::Readable for IPRIOR9_SPEC {}
        ///`write(|w| ..)` method takes [`iprior9::W`](W) writer structure
        impl crate::Writable for IPRIOR9_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR9 to value 0
        impl crate::Resettable for IPRIOR9_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR10 (rw) register accessor: Interrupt Priority configuration Register 10
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior10::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior10::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior10`]
    ///module
    pub type IPRIOR10 = crate::Reg<iprior10::IPRIOR10_SPEC>;
    ///Interrupt Priority configuration Register 10
    pub mod iprior10 {
        ///Register `IPRIOR10` reader
        pub type R = crate::R<IPRIOR10_SPEC>;
        ///Register `IPRIOR10` writer
        pub type W = crate::W<IPRIOR10_SPEC>;
        ///Field `IPRIOR10` reader - >RW,Interrupt priority for number 40-43
        pub type IPRIOR10_R = crate::FieldReader<u32>;
        ///Field `IPRIOR10` writer - >RW,Interrupt priority for number 40-43
        pub type IPRIOR10_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - >RW,Interrupt priority for number 40-43
            #[inline(always)]
            pub fn iprior10(&self) -> IPRIOR10_R {
                IPRIOR10_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - >RW,Interrupt priority for number 40-43
            #[inline(always)]
            #[must_use]
            pub fn iprior10(&mut self) -> IPRIOR10_W<IPRIOR10_SPEC> {
                IPRIOR10_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register 10
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior10::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior10::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR10_SPEC;
        impl crate::RegisterSpec for IPRIOR10_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior10::R`](R) reader structure
        impl crate::Readable for IPRIOR10_SPEC {}
        ///`write(|w| ..)` method takes [`iprior10::W`](W) writer structure
        impl crate::Writable for IPRIOR10_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR10 to value 0
        impl crate::Resettable for IPRIOR10_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR11 (rw) register accessor: Interrupt Priority configuration Register 11
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior11::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior11::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior11`]
    ///module
    pub type IPRIOR11 = crate::Reg<iprior11::IPRIOR11_SPEC>;
    ///Interrupt Priority configuration Register 11
    pub mod iprior11 {
        ///Register `IPRIOR11` reader
        pub type R = crate::R<IPRIOR11_SPEC>;
        ///Register `IPRIOR11` writer
        pub type W = crate::W<IPRIOR11_SPEC>;
        ///Field `IPRIOR11` reader - RW,Interrupt priority for number 44-47
        pub type IPRIOR11_R = crate::FieldReader<u32>;
        ///Field `IPRIOR11` writer - RW,Interrupt priority for number 44-47
        pub type IPRIOR11_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 44-47
            #[inline(always)]
            pub fn iprior11(&self) -> IPRIOR11_R {
                IPRIOR11_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 44-47
            #[inline(always)]
            #[must_use]
            pub fn iprior11(&mut self) -> IPRIOR11_W<IPRIOR11_SPEC> {
                IPRIOR11_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register 11
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior11::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior11::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR11_SPEC;
        impl crate::RegisterSpec for IPRIOR11_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior11::R`](R) reader structure
        impl crate::Readable for IPRIOR11_SPEC {}
        ///`write(|w| ..)` method takes [`iprior11::W`](W) writer structure
        impl crate::Writable for IPRIOR11_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR11 to value 0
        impl crate::Resettable for IPRIOR11_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR12 (rw) register accessor: Interrupt Priority configuration Register 12
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior12::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior12::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior12`]
    ///module
    pub type IPRIOR12 = crate::Reg<iprior12::IPRIOR12_SPEC>;
    ///Interrupt Priority configuration Register 12
    pub mod iprior12 {
        ///Register `IPRIOR12` reader
        pub type R = crate::R<IPRIOR12_SPEC>;
        ///Register `IPRIOR12` writer
        pub type W = crate::W<IPRIOR12_SPEC>;
        ///Field `IPRIOR12` reader - RW,Interrupt priority for number 48-51
        pub type IPRIOR12_R = crate::FieldReader<u32>;
        ///Field `IPRIOR12` writer - RW,Interrupt priority for number 48-51
        pub type IPRIOR12_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 48-51
            #[inline(always)]
            pub fn iprior12(&self) -> IPRIOR12_R {
                IPRIOR12_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 48-51
            #[inline(always)]
            #[must_use]
            pub fn iprior12(&mut self) -> IPRIOR12_W<IPRIOR12_SPEC> {
                IPRIOR12_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register 12
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior12::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior12::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR12_SPEC;
        impl crate::RegisterSpec for IPRIOR12_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior12::R`](R) reader structure
        impl crate::Readable for IPRIOR12_SPEC {}
        ///`write(|w| ..)` method takes [`iprior12::W`](W) writer structure
        impl crate::Writable for IPRIOR12_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR12 to value 0
        impl crate::Resettable for IPRIOR12_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR13 (rw) register accessor: Interrupt Priority configuration Register 13
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior13::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior13::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior13`]
    ///module
    pub type IPRIOR13 = crate::Reg<iprior13::IPRIOR13_SPEC>;
    ///Interrupt Priority configuration Register 13
    pub mod iprior13 {
        ///Register `IPRIOR13` reader
        pub type R = crate::R<IPRIOR13_SPEC>;
        ///Register `IPRIOR13` writer
        pub type W = crate::W<IPRIOR13_SPEC>;
        ///Field `IPRIOR13` reader - RW,Interrupt priority for number 52-55
        pub type IPRIOR13_R = crate::FieldReader<u32>;
        ///Field `IPRIOR13` writer - RW,Interrupt priority for number 52-55
        pub type IPRIOR13_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 52-55
            #[inline(always)]
            pub fn iprior13(&self) -> IPRIOR13_R {
                IPRIOR13_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 52-55
            #[inline(always)]
            #[must_use]
            pub fn iprior13(&mut self) -> IPRIOR13_W<IPRIOR13_SPEC> {
                IPRIOR13_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register 13
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior13::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior13::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR13_SPEC;
        impl crate::RegisterSpec for IPRIOR13_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior13::R`](R) reader structure
        impl crate::Readable for IPRIOR13_SPEC {}
        ///`write(|w| ..)` method takes [`iprior13::W`](W) writer structure
        impl crate::Writable for IPRIOR13_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR13 to value 0
        impl crate::Resettable for IPRIOR13_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR14 (rw) register accessor: Interrupt Priority configuration Register 14
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior14::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior14::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior14`]
    ///module
    pub type IPRIOR14 = crate::Reg<iprior14::IPRIOR14_SPEC>;
    ///Interrupt Priority configuration Register 14
    pub mod iprior14 {
        ///Register `IPRIOR14` reader
        pub type R = crate::R<IPRIOR14_SPEC>;
        ///Register `IPRIOR14` writer
        pub type W = crate::W<IPRIOR14_SPEC>;
        ///Field `IPRIOR14` reader - RW,Interrupt priority for number 56-59
        pub type IPRIOR14_R = crate::FieldReader<u32>;
        ///Field `IPRIOR14` writer - RW,Interrupt priority for number 56-59
        pub type IPRIOR14_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 56-59
            #[inline(always)]
            pub fn iprior14(&self) -> IPRIOR14_R {
                IPRIOR14_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 56-59
            #[inline(always)]
            #[must_use]
            pub fn iprior14(&mut self) -> IPRIOR14_W<IPRIOR14_SPEC> {
                IPRIOR14_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register 14
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior14::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior14::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR14_SPEC;
        impl crate::RegisterSpec for IPRIOR14_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior14::R`](R) reader structure
        impl crate::Readable for IPRIOR14_SPEC {}
        ///`write(|w| ..)` method takes [`iprior14::W`](W) writer structure
        impl crate::Writable for IPRIOR14_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR14 to value 0
        impl crate::Resettable for IPRIOR14_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR15 (rw) register accessor: Interrupt Priority configuration Register 15
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior15::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior15::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior15`]
    ///module
    pub type IPRIOR15 = crate::Reg<iprior15::IPRIOR15_SPEC>;
    ///Interrupt Priority configuration Register 15
    pub mod iprior15 {
        ///Register `IPRIOR15` reader
        pub type R = crate::R<IPRIOR15_SPEC>;
        ///Register `IPRIOR15` writer
        pub type W = crate::W<IPRIOR15_SPEC>;
        ///Field `IPRIOR15` reader - RW,Interrupt priority for number 60-63
        pub type IPRIOR15_R = crate::FieldReader<u32>;
        ///Field `IPRIOR15` writer - RW,Interrupt priority for number 60-63
        pub type IPRIOR15_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 60-63
            #[inline(always)]
            pub fn iprior15(&self) -> IPRIOR15_R {
                IPRIOR15_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 60-63
            #[inline(always)]
            #[must_use]
            pub fn iprior15(&mut self) -> IPRIOR15_W<IPRIOR15_SPEC> {
                IPRIOR15_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register 15
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior15::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior15::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR15_SPEC;
        impl crate::RegisterSpec for IPRIOR15_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior15::R`](R) reader structure
        impl crate::Readable for IPRIOR15_SPEC {}
        ///`write(|w| ..)` method takes [`iprior15::W`](W) writer structure
        impl crate::Writable for IPRIOR15_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR15 to value 0
        impl crate::Resettable for IPRIOR15_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR16 (rw) register accessor: Interrupt Priority configuration Register 16
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior16::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior16::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior16`]
    ///module
    pub type IPRIOR16 = crate::Reg<iprior16::IPRIOR16_SPEC>;
    ///Interrupt Priority configuration Register 16
    pub mod iprior16 {
        ///Register `IPRIOR16` reader
        pub type R = crate::R<IPRIOR16_SPEC>;
        ///Register `IPRIOR16` writer
        pub type W = crate::W<IPRIOR16_SPEC>;
        ///Field `IPRIOR16` reader - RW,Interrupt priority for number 64-67
        pub type IPRIOR16_R = crate::FieldReader<u32>;
        ///Field `IPRIOR16` writer - RW,Interrupt priority for number 64-67
        pub type IPRIOR16_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 64-67
            #[inline(always)]
            pub fn iprior16(&self) -> IPRIOR16_R {
                IPRIOR16_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 64-67
            #[inline(always)]
            #[must_use]
            pub fn iprior16(&mut self) -> IPRIOR16_W<IPRIOR16_SPEC> {
                IPRIOR16_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register 16
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior16::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior16::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR16_SPEC;
        impl crate::RegisterSpec for IPRIOR16_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior16::R`](R) reader structure
        impl crate::Readable for IPRIOR16_SPEC {}
        ///`write(|w| ..)` method takes [`iprior16::W`](W) writer structure
        impl crate::Writable for IPRIOR16_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR16 to value 0
        impl crate::Resettable for IPRIOR16_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR17 (rw) register accessor: Interrupt Priority configuration Register 17
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior17::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior17::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior17`]
    ///module
    pub type IPRIOR17 = crate::Reg<iprior17::IPRIOR17_SPEC>;
    ///Interrupt Priority configuration Register 17
    pub mod iprior17 {
        ///Register `IPRIOR17` reader
        pub type R = crate::R<IPRIOR17_SPEC>;
        ///Register `IPRIOR17` writer
        pub type W = crate::W<IPRIOR17_SPEC>;
        ///Field `IPRIOR17` reader - RW,Interrupt priority for number 68-71
        pub type IPRIOR17_R = crate::FieldReader<u32>;
        ///Field `IPRIOR17` writer - RW,Interrupt priority for number 68-71
        pub type IPRIOR17_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 68-71
            #[inline(always)]
            pub fn iprior17(&self) -> IPRIOR17_R {
                IPRIOR17_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 68-71
            #[inline(always)]
            #[must_use]
            pub fn iprior17(&mut self) -> IPRIOR17_W<IPRIOR17_SPEC> {
                IPRIOR17_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register 17
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior17::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior17::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR17_SPEC;
        impl crate::RegisterSpec for IPRIOR17_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior17::R`](R) reader structure
        impl crate::Readable for IPRIOR17_SPEC {}
        ///`write(|w| ..)` method takes [`iprior17::W`](W) writer structure
        impl crate::Writable for IPRIOR17_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR17 to value 0
        impl crate::Resettable for IPRIOR17_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR18 (rw) register accessor: Interrupt Priority configuration Register 18
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior18::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior18::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior18`]
    ///module
    pub type IPRIOR18 = crate::Reg<iprior18::IPRIOR18_SPEC>;
    ///Interrupt Priority configuration Register 18
    pub mod iprior18 {
        ///Register `IPRIOR18` reader
        pub type R = crate::R<IPRIOR18_SPEC>;
        ///Register `IPRIOR18` writer
        pub type W = crate::W<IPRIOR18_SPEC>;
        ///Field `IPRIOR18` reader - RW,Interrupt priority for number 72-75
        pub type IPRIOR18_R = crate::FieldReader<u32>;
        ///Field `IPRIOR18` writer - RW,Interrupt priority for number 72-75
        pub type IPRIOR18_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 72-75
            #[inline(always)]
            pub fn iprior18(&self) -> IPRIOR18_R {
                IPRIOR18_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 72-75
            #[inline(always)]
            #[must_use]
            pub fn iprior18(&mut self) -> IPRIOR18_W<IPRIOR18_SPEC> {
                IPRIOR18_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register 18
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior18::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior18::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR18_SPEC;
        impl crate::RegisterSpec for IPRIOR18_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior18::R`](R) reader structure
        impl crate::Readable for IPRIOR18_SPEC {}
        ///`write(|w| ..)` method takes [`iprior18::W`](W) writer structure
        impl crate::Writable for IPRIOR18_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR18 to value 0
        impl crate::Resettable for IPRIOR18_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR19 (rw) register accessor: Interrupt Priority configuration Register 19
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior19::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior19::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior19`]
    ///module
    pub type IPRIOR19 = crate::Reg<iprior19::IPRIOR19_SPEC>;
    ///Interrupt Priority configuration Register 19
    pub mod iprior19 {
        ///Register `IPRIOR19` reader
        pub type R = crate::R<IPRIOR19_SPEC>;
        ///Register `IPRIOR19` writer
        pub type W = crate::W<IPRIOR19_SPEC>;
        ///Field `IPRIOR19` reader - RW,Interrupt priority for number 76-79
        pub type IPRIOR19_R = crate::FieldReader<u32>;
        ///Field `IPRIOR19` writer - RW,Interrupt priority for number 76-79
        pub type IPRIOR19_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 76-79
            #[inline(always)]
            pub fn iprior19(&self) -> IPRIOR19_R {
                IPRIOR19_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 76-79
            #[inline(always)]
            #[must_use]
            pub fn iprior19(&mut self) -> IPRIOR19_W<IPRIOR19_SPEC> {
                IPRIOR19_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register 19
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior19::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior19::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR19_SPEC;
        impl crate::RegisterSpec for IPRIOR19_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior19::R`](R) reader structure
        impl crate::Readable for IPRIOR19_SPEC {}
        ///`write(|w| ..)` method takes [`iprior19::W`](W) writer structure
        impl crate::Writable for IPRIOR19_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR19 to value 0
        impl crate::Resettable for IPRIOR19_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR20 (rw) register accessor: Interrupt Priority configuration Register 20
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior20::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior20::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior20`]
    ///module
    pub type IPRIOR20 = crate::Reg<iprior20::IPRIOR20_SPEC>;
    ///Interrupt Priority configuration Register 20
    pub mod iprior20 {
        ///Register `IPRIOR20` reader
        pub type R = crate::R<IPRIOR20_SPEC>;
        ///Register `IPRIOR20` writer
        pub type W = crate::W<IPRIOR20_SPEC>;
        ///Field `IPRIOR20` reader - RW,RW,Interrupt priority for number 80-83
        pub type IPRIOR20_R = crate::FieldReader<u32>;
        ///Field `IPRIOR20` writer - RW,RW,Interrupt priority for number 80-83
        pub type IPRIOR20_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - RW,RW,Interrupt priority for number 80-83
            #[inline(always)]
            pub fn iprior20(&self) -> IPRIOR20_R {
                IPRIOR20_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,RW,Interrupt priority for number 80-83
            #[inline(always)]
            #[must_use]
            pub fn iprior20(&mut self) -> IPRIOR20_W<IPRIOR20_SPEC> {
                IPRIOR20_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register 20
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior20::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior20::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR20_SPEC;
        impl crate::RegisterSpec for IPRIOR20_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior20::R`](R) reader structure
        impl crate::Readable for IPRIOR20_SPEC {}
        ///`write(|w| ..)` method takes [`iprior20::W`](W) writer structure
        impl crate::Writable for IPRIOR20_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR20 to value 0
        impl crate::Resettable for IPRIOR20_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR21 (rw) register accessor: Interrupt Priority configuration Register 21
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior21::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior21::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior21`]
    ///module
    pub type IPRIOR21 = crate::Reg<iprior21::IPRIOR21_SPEC>;
    ///Interrupt Priority configuration Register 21
    pub mod iprior21 {
        ///Register `IPRIOR21` reader
        pub type R = crate::R<IPRIOR21_SPEC>;
        ///Register `IPRIOR21` writer
        pub type W = crate::W<IPRIOR21_SPEC>;
        ///Field `IPRIOR21` reader - RW,Interrupt priority for number 84-87
        pub type IPRIOR21_R = crate::FieldReader<u32>;
        ///Field `IPRIOR21` writer - RW,Interrupt priority for number 84-87
        pub type IPRIOR21_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 84-87
            #[inline(always)]
            pub fn iprior21(&self) -> IPRIOR21_R {
                IPRIOR21_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 84-87
            #[inline(always)]
            #[must_use]
            pub fn iprior21(&mut self) -> IPRIOR21_W<IPRIOR21_SPEC> {
                IPRIOR21_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register 21
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior21::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior21::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR21_SPEC;
        impl crate::RegisterSpec for IPRIOR21_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior21::R`](R) reader structure
        impl crate::Readable for IPRIOR21_SPEC {}
        ///`write(|w| ..)` method takes [`iprior21::W`](W) writer structure
        impl crate::Writable for IPRIOR21_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR21 to value 0
        impl crate::Resettable for IPRIOR21_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR22 (rw) register accessor: Interrupt Priority configuration Register 22
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior22::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior22::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior22`]
    ///module
    pub type IPRIOR22 = crate::Reg<iprior22::IPRIOR22_SPEC>;
    ///Interrupt Priority configuration Register 22
    pub mod iprior22 {
        ///Register `IPRIOR22` reader
        pub type R = crate::R<IPRIOR22_SPEC>;
        ///Register `IPRIOR22` writer
        pub type W = crate::W<IPRIOR22_SPEC>;
        ///Field `IPRIOR22` reader - RW,Interrupt priority for number 88-91
        pub type IPRIOR22_R = crate::FieldReader<u32>;
        ///Field `IPRIOR22` writer - RW,Interrupt priority for number 88-91
        pub type IPRIOR22_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 88-91
            #[inline(always)]
            pub fn iprior22(&self) -> IPRIOR22_R {
                IPRIOR22_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 88-91
            #[inline(always)]
            #[must_use]
            pub fn iprior22(&mut self) -> IPRIOR22_W<IPRIOR22_SPEC> {
                IPRIOR22_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register 22
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior22::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior22::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR22_SPEC;
        impl crate::RegisterSpec for IPRIOR22_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior22::R`](R) reader structure
        impl crate::Readable for IPRIOR22_SPEC {}
        ///`write(|w| ..)` method takes [`iprior22::W`](W) writer structure
        impl crate::Writable for IPRIOR22_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR22 to value 0
        impl crate::Resettable for IPRIOR22_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR23 (rw) register accessor: Interrupt Priority configuration Register 23
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior23::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior23::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior23`]
    ///module
    pub type IPRIOR23 = crate::Reg<iprior23::IPRIOR23_SPEC>;
    ///Interrupt Priority configuration Register 23
    pub mod iprior23 {
        ///Register `IPRIOR23` reader
        pub type R = crate::R<IPRIOR23_SPEC>;
        ///Register `IPRIOR23` writer
        pub type W = crate::W<IPRIOR23_SPEC>;
        ///Field `IPRIOR23` reader - RW,Interrupt priority for number 92-95
        pub type IPRIOR23_R = crate::FieldReader<u32>;
        ///Field `IPRIOR23` writer - RW,Interrupt priority for number 92-95
        pub type IPRIOR23_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 92-95
            #[inline(always)]
            pub fn iprior23(&self) -> IPRIOR23_R {
                IPRIOR23_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 92-95
            #[inline(always)]
            #[must_use]
            pub fn iprior23(&mut self) -> IPRIOR23_W<IPRIOR23_SPEC> {
                IPRIOR23_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register 23
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior23::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior23::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR23_SPEC;
        impl crate::RegisterSpec for IPRIOR23_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior23::R`](R) reader structure
        impl crate::Readable for IPRIOR23_SPEC {}
        ///`write(|w| ..)` method takes [`iprior23::W`](W) writer structure
        impl crate::Writable for IPRIOR23_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR23 to value 0
        impl crate::Resettable for IPRIOR23_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR24 (rw) register accessor: Interrupt Priority configuration Register 24
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior24::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior24::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior24`]
    ///module
    pub type IPRIOR24 = crate::Reg<iprior24::IPRIOR24_SPEC>;
    ///Interrupt Priority configuration Register 24
    pub mod iprior24 {
        ///Register `IPRIOR24` reader
        pub type R = crate::R<IPRIOR24_SPEC>;
        ///Register `IPRIOR24` writer
        pub type W = crate::W<IPRIOR24_SPEC>;
        ///Field `IPRIOR24` reader - RW,Interrupt priority for number 96-99
        pub type IPRIOR24_R = crate::FieldReader<u32>;
        ///Field `IPRIOR24` writer - RW,Interrupt priority for number 96-99
        pub type IPRIOR24_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 96-99
            #[inline(always)]
            pub fn iprior24(&self) -> IPRIOR24_R {
                IPRIOR24_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 96-99
            #[inline(always)]
            #[must_use]
            pub fn iprior24(&mut self) -> IPRIOR24_W<IPRIOR24_SPEC> {
                IPRIOR24_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register 24
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior24::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior24::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR24_SPEC;
        impl crate::RegisterSpec for IPRIOR24_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior24::R`](R) reader structure
        impl crate::Readable for IPRIOR24_SPEC {}
        ///`write(|w| ..)` method takes [`iprior24::W`](W) writer structure
        impl crate::Writable for IPRIOR24_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR24 to value 0
        impl crate::Resettable for IPRIOR24_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR25 (rw) register accessor: Interrupt Priority configuration Register 25
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior25::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior25::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior25`]
    ///module
    pub type IPRIOR25 = crate::Reg<iprior25::IPRIOR25_SPEC>;
    ///Interrupt Priority configuration Register 25
    pub mod iprior25 {
        ///Register `IPRIOR25` reader
        pub type R = crate::R<IPRIOR25_SPEC>;
        ///Register `IPRIOR25` writer
        pub type W = crate::W<IPRIOR25_SPEC>;
        ///Field `IPRIOR25` reader - RW,Interrupt priority for number 100-103
        pub type IPRIOR25_R = crate::FieldReader<u32>;
        ///Field `IPRIOR25` writer - RW,Interrupt priority for number 100-103
        pub type IPRIOR25_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 100-103
            #[inline(always)]
            pub fn iprior25(&self) -> IPRIOR25_R {
                IPRIOR25_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 100-103
            #[inline(always)]
            #[must_use]
            pub fn iprior25(&mut self) -> IPRIOR25_W<IPRIOR25_SPEC> {
                IPRIOR25_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register 25
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior25::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior25::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR25_SPEC;
        impl crate::RegisterSpec for IPRIOR25_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior25::R`](R) reader structure
        impl crate::Readable for IPRIOR25_SPEC {}
        ///`write(|w| ..)` method takes [`iprior25::W`](W) writer structure
        impl crate::Writable for IPRIOR25_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR25 to value 0
        impl crate::Resettable for IPRIOR25_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR26 (rw) register accessor: Interrupt Priority configuration Register 26
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior26::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior26::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior26`]
    ///module
    pub type IPRIOR26 = crate::Reg<iprior26::IPRIOR26_SPEC>;
    ///Interrupt Priority configuration Register 26
    pub mod iprior26 {
        ///Register `IPRIOR26` reader
        pub type R = crate::R<IPRIOR26_SPEC>;
        ///Register `IPRIOR26` writer
        pub type W = crate::W<IPRIOR26_SPEC>;
        ///Field `IPRIOR26` reader - RW,Interrupt priority for number 104-107
        pub type IPRIOR26_R = crate::FieldReader<u32>;
        ///Field `IPRIOR26` writer - RW,Interrupt priority for number 104-107
        pub type IPRIOR26_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 104-107
            #[inline(always)]
            pub fn iprior26(&self) -> IPRIOR26_R {
                IPRIOR26_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 104-107
            #[inline(always)]
            #[must_use]
            pub fn iprior26(&mut self) -> IPRIOR26_W<IPRIOR26_SPEC> {
                IPRIOR26_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register 26
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior26::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior26::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR26_SPEC;
        impl crate::RegisterSpec for IPRIOR26_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior26::R`](R) reader structure
        impl crate::Readable for IPRIOR26_SPEC {}
        ///`write(|w| ..)` method takes [`iprior26::W`](W) writer structure
        impl crate::Writable for IPRIOR26_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR26 to value 0
        impl crate::Resettable for IPRIOR26_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR27 (rw) register accessor: Interrupt Priority configuration Register 27
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior27::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior27::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior27`]
    ///module
    pub type IPRIOR27 = crate::Reg<iprior27::IPRIOR27_SPEC>;
    ///Interrupt Priority configuration Register 27
    pub mod iprior27 {
        ///Register `IPRIOR27` reader
        pub type R = crate::R<IPRIOR27_SPEC>;
        ///Register `IPRIOR27` writer
        pub type W = crate::W<IPRIOR27_SPEC>;
        ///Field `IPRIOR27` reader - RW,Interrupt priority for number 108-111
        pub type IPRIOR27_R = crate::FieldReader<u32>;
        ///Field `IPRIOR27` writer - RW,Interrupt priority for number 108-111
        pub type IPRIOR27_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 108-111
            #[inline(always)]
            pub fn iprior27(&self) -> IPRIOR27_R {
                IPRIOR27_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 108-111
            #[inline(always)]
            #[must_use]
            pub fn iprior27(&mut self) -> IPRIOR27_W<IPRIOR27_SPEC> {
                IPRIOR27_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register 27
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior27::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior27::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR27_SPEC;
        impl crate::RegisterSpec for IPRIOR27_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior27::R`](R) reader structure
        impl crate::Readable for IPRIOR27_SPEC {}
        ///`write(|w| ..)` method takes [`iprior27::W`](W) writer structure
        impl crate::Writable for IPRIOR27_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR27 to value 0
        impl crate::Resettable for IPRIOR27_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR28 (rw) register accessor: Interrupt Priority configuration Register 28
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior28::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior28::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior28`]
    ///module
    pub type IPRIOR28 = crate::Reg<iprior28::IPRIOR28_SPEC>;
    ///Interrupt Priority configuration Register 28
    pub mod iprior28 {
        ///Register `IPRIOR28` reader
        pub type R = crate::R<IPRIOR28_SPEC>;
        ///Register `IPRIOR28` writer
        pub type W = crate::W<IPRIOR28_SPEC>;
        ///Field `IPRIOR28` reader - RW,Interrupt priority for number 112-115
        pub type IPRIOR28_R = crate::FieldReader<u32>;
        ///Field `IPRIOR28` writer - RW,Interrupt priority for number 112-115
        pub type IPRIOR28_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 112-115
            #[inline(always)]
            pub fn iprior28(&self) -> IPRIOR28_R {
                IPRIOR28_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 112-115
            #[inline(always)]
            #[must_use]
            pub fn iprior28(&mut self) -> IPRIOR28_W<IPRIOR28_SPEC> {
                IPRIOR28_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register 28
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior28::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior28::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR28_SPEC;
        impl crate::RegisterSpec for IPRIOR28_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior28::R`](R) reader structure
        impl crate::Readable for IPRIOR28_SPEC {}
        ///`write(|w| ..)` method takes [`iprior28::W`](W) writer structure
        impl crate::Writable for IPRIOR28_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR28 to value 0
        impl crate::Resettable for IPRIOR28_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR29 (rw) register accessor: Interrupt Priority configuration Register 29
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior29::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior29::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior29`]
    ///module
    pub type IPRIOR29 = crate::Reg<iprior29::IPRIOR29_SPEC>;
    ///Interrupt Priority configuration Register 29
    pub mod iprior29 {
        ///Register `IPRIOR29` reader
        pub type R = crate::R<IPRIOR29_SPEC>;
        ///Register `IPRIOR29` writer
        pub type W = crate::W<IPRIOR29_SPEC>;
        ///Field `IPRIOR29` reader - RW,Interrupt priority for number 116-119
        pub type IPRIOR29_R = crate::FieldReader<u32>;
        ///Field `IPRIOR29` writer - RW,Interrupt priority for number 116-119
        pub type IPRIOR29_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 116-119
            #[inline(always)]
            pub fn iprior29(&self) -> IPRIOR29_R {
                IPRIOR29_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 116-119
            #[inline(always)]
            #[must_use]
            pub fn iprior29(&mut self) -> IPRIOR29_W<IPRIOR29_SPEC> {
                IPRIOR29_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register 29
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior29::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior29::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR29_SPEC;
        impl crate::RegisterSpec for IPRIOR29_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior29::R`](R) reader structure
        impl crate::Readable for IPRIOR29_SPEC {}
        ///`write(|w| ..)` method takes [`iprior29::W`](W) writer structure
        impl crate::Writable for IPRIOR29_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR29 to value 0
        impl crate::Resettable for IPRIOR29_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR30 (rw) register accessor: Interrupt Priority configuration Register 30
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior30::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior30::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior30`]
    ///module
    pub type IPRIOR30 = crate::Reg<iprior30::IPRIOR30_SPEC>;
    ///Interrupt Priority configuration Register 30
    pub mod iprior30 {
        ///Register `IPRIOR30` reader
        pub type R = crate::R<IPRIOR30_SPEC>;
        ///Register `IPRIOR30` writer
        pub type W = crate::W<IPRIOR30_SPEC>;
        ///Field `IPRIOR30` reader - RW,Interrupt priority for number 120-123
        pub type IPRIOR30_R = crate::FieldReader<u32>;
        ///Field `IPRIOR30` writer - RW,Interrupt priority for number 120-123
        pub type IPRIOR30_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 120-123
            #[inline(always)]
            pub fn iprior30(&self) -> IPRIOR30_R {
                IPRIOR30_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 120-123
            #[inline(always)]
            #[must_use]
            pub fn iprior30(&mut self) -> IPRIOR30_W<IPRIOR30_SPEC> {
                IPRIOR30_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register 30
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior30::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior30::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR30_SPEC;
        impl crate::RegisterSpec for IPRIOR30_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior30::R`](R) reader structure
        impl crate::Readable for IPRIOR30_SPEC {}
        ///`write(|w| ..)` method takes [`iprior30::W`](W) writer structure
        impl crate::Writable for IPRIOR30_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR30 to value 0
        impl crate::Resettable for IPRIOR30_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR31 (rw) register accessor: Interrupt Priority configuration Register 31
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior31::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior31::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior31`]
    ///module
    pub type IPRIOR31 = crate::Reg<iprior31::IPRIOR31_SPEC>;
    ///Interrupt Priority configuration Register 31
    pub mod iprior31 {
        ///Register `IPRIOR31` reader
        pub type R = crate::R<IPRIOR31_SPEC>;
        ///Register `IPRIOR31` writer
        pub type W = crate::W<IPRIOR31_SPEC>;
        ///Field `IPRIOR31` reader - RW,Interrupt priority for number 124-127
        pub type IPRIOR31_R = crate::FieldReader<u32>;
        ///Field `IPRIOR31` writer - RW,Interrupt priority for number 124-127
        pub type IPRIOR31_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 124-127
            #[inline(always)]
            pub fn iprior31(&self) -> IPRIOR31_R {
                IPRIOR31_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 124-127
            #[inline(always)]
            #[must_use]
            pub fn iprior31(&mut self) -> IPRIOR31_W<IPRIOR31_SPEC> {
                IPRIOR31_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register 31
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior31::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior31::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR31_SPEC;
        impl crate::RegisterSpec for IPRIOR31_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior31::R`](R) reader structure
        impl crate::Readable for IPRIOR31_SPEC {}
        ///`write(|w| ..)` method takes [`iprior31::W`](W) writer structure
        impl crate::Writable for IPRIOR31_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR31 to value 0
        impl crate::Resettable for IPRIOR31_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR32 (rw) register accessor: Interrupt Priority configuration Register 32
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior32::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior32::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior32`]
    ///module
    pub type IPRIOR32 = crate::Reg<iprior32::IPRIOR32_SPEC>;
    ///Interrupt Priority configuration Register 32
    pub mod iprior32 {
        ///Register `IPRIOR32` reader
        pub type R = crate::R<IPRIOR32_SPEC>;
        ///Register `IPRIOR32` writer
        pub type W = crate::W<IPRIOR32_SPEC>;
        ///Field `IPRIOR32` reader - RW,Interrupt priority for number 128-131
        pub type IPRIOR32_R = crate::FieldReader<u32>;
        ///Field `IPRIOR32` writer - RW,Interrupt priority for number 128-131
        pub type IPRIOR32_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 128-131
            #[inline(always)]
            pub fn iprior32(&self) -> IPRIOR32_R {
                IPRIOR32_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 128-131
            #[inline(always)]
            #[must_use]
            pub fn iprior32(&mut self) -> IPRIOR32_W<IPRIOR32_SPEC> {
                IPRIOR32_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register 32
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior32::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior32::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR32_SPEC;
        impl crate::RegisterSpec for IPRIOR32_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior32::R`](R) reader structure
        impl crate::Readable for IPRIOR32_SPEC {}
        ///`write(|w| ..)` method takes [`iprior32::W`](W) writer structure
        impl crate::Writable for IPRIOR32_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR32 to value 0
        impl crate::Resettable for IPRIOR32_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR33 (rw) register accessor: Interrupt Priority configuration Register 33
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior33::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior33::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior33`]
    ///module
    pub type IPRIOR33 = crate::Reg<iprior33::IPRIOR33_SPEC>;
    ///Interrupt Priority configuration Register 33
    pub mod iprior33 {
        ///Register `IPRIOR33` reader
        pub type R = crate::R<IPRIOR33_SPEC>;
        ///Register `IPRIOR33` writer
        pub type W = crate::W<IPRIOR33_SPEC>;
        ///Field `IPRIOR33` reader - RW,Interrupt priority for number 132-135
        pub type IPRIOR33_R = crate::FieldReader<u32>;
        ///Field `IPRIOR33` writer - RW,Interrupt priority for number 132-135
        pub type IPRIOR33_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 132-135
            #[inline(always)]
            pub fn iprior33(&self) -> IPRIOR33_R {
                IPRIOR33_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 132-135
            #[inline(always)]
            #[must_use]
            pub fn iprior33(&mut self) -> IPRIOR33_W<IPRIOR33_SPEC> {
                IPRIOR33_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register 33
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior33::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior33::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR33_SPEC;
        impl crate::RegisterSpec for IPRIOR33_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior33::R`](R) reader structure
        impl crate::Readable for IPRIOR33_SPEC {}
        ///`write(|w| ..)` method takes [`iprior33::W`](W) writer structure
        impl crate::Writable for IPRIOR33_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR33 to value 0
        impl crate::Resettable for IPRIOR33_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR34 (rw) register accessor: Interrupt Priority configuration Register 34
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior34::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior34::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior34`]
    ///module
    pub type IPRIOR34 = crate::Reg<iprior34::IPRIOR34_SPEC>;
    ///Interrupt Priority configuration Register 34
    pub mod iprior34 {
        ///Register `IPRIOR34` reader
        pub type R = crate::R<IPRIOR34_SPEC>;
        ///Register `IPRIOR34` writer
        pub type W = crate::W<IPRIOR34_SPEC>;
        ///Field `IPRIOR34` reader - RW,Interrupt priority for number 136-139
        pub type IPRIOR34_R = crate::FieldReader<u32>;
        ///Field `IPRIOR34` writer - RW,Interrupt priority for number 136-139
        pub type IPRIOR34_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 136-139
            #[inline(always)]
            pub fn iprior34(&self) -> IPRIOR34_R {
                IPRIOR34_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 136-139
            #[inline(always)]
            #[must_use]
            pub fn iprior34(&mut self) -> IPRIOR34_W<IPRIOR34_SPEC> {
                IPRIOR34_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register 34
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior34::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior34::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR34_SPEC;
        impl crate::RegisterSpec for IPRIOR34_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior34::R`](R) reader structure
        impl crate::Readable for IPRIOR34_SPEC {}
        ///`write(|w| ..)` method takes [`iprior34::W`](W) writer structure
        impl crate::Writable for IPRIOR34_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR34 to value 0
        impl crate::Resettable for IPRIOR34_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR35 (rw) register accessor: Interrupt Priority configuration Register 35
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior35::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior35::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior35`]
    ///module
    pub type IPRIOR35 = crate::Reg<iprior35::IPRIOR35_SPEC>;
    ///Interrupt Priority configuration Register 35
    pub mod iprior35 {
        ///Register `IPRIOR35` reader
        pub type R = crate::R<IPRIOR35_SPEC>;
        ///Register `IPRIOR35` writer
        pub type W = crate::W<IPRIOR35_SPEC>;
        ///Field `IPRIOR35` reader - RW,Interrupt priority for number 140-143
        pub type IPRIOR35_R = crate::FieldReader<u32>;
        ///Field `IPRIOR35` writer - RW,Interrupt priority for number 140-143
        pub type IPRIOR35_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 140-143
            #[inline(always)]
            pub fn iprior35(&self) -> IPRIOR35_R {
                IPRIOR35_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 140-143
            #[inline(always)]
            #[must_use]
            pub fn iprior35(&mut self) -> IPRIOR35_W<IPRIOR35_SPEC> {
                IPRIOR35_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register 35
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior35::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior35::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR35_SPEC;
        impl crate::RegisterSpec for IPRIOR35_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior35::R`](R) reader structure
        impl crate::Readable for IPRIOR35_SPEC {}
        ///`write(|w| ..)` method takes [`iprior35::W`](W) writer structure
        impl crate::Writable for IPRIOR35_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR35 to value 0
        impl crate::Resettable for IPRIOR35_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR36 (rw) register accessor: Interrupt Priority configuration Register 36
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior36::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior36::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior36`]
    ///module
    pub type IPRIOR36 = crate::Reg<iprior36::IPRIOR36_SPEC>;
    ///Interrupt Priority configuration Register 36
    pub mod iprior36 {
        ///Register `IPRIOR36` reader
        pub type R = crate::R<IPRIOR36_SPEC>;
        ///Register `IPRIOR36` writer
        pub type W = crate::W<IPRIOR36_SPEC>;
        ///Field `IPRIOR36` reader - RW,Interrupt priority for number 144-147
        pub type IPRIOR36_R = crate::FieldReader<u32>;
        ///Field `IPRIOR36` writer - RW,Interrupt priority for number 144-147
        pub type IPRIOR36_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 144-147
            #[inline(always)]
            pub fn iprior36(&self) -> IPRIOR36_R {
                IPRIOR36_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 144-147
            #[inline(always)]
            #[must_use]
            pub fn iprior36(&mut self) -> IPRIOR36_W<IPRIOR36_SPEC> {
                IPRIOR36_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register 36
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior36::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior36::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR36_SPEC;
        impl crate::RegisterSpec for IPRIOR36_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior36::R`](R) reader structure
        impl crate::Readable for IPRIOR36_SPEC {}
        ///`write(|w| ..)` method takes [`iprior36::W`](W) writer structure
        impl crate::Writable for IPRIOR36_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR36 to value 0
        impl crate::Resettable for IPRIOR36_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR37 (rw) register accessor: Interrupt Priority configuration Register 37
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior37::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior37::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior37`]
    ///module
    pub type IPRIOR37 = crate::Reg<iprior37::IPRIOR37_SPEC>;
    ///Interrupt Priority configuration Register 37
    pub mod iprior37 {
        ///Register `IPRIOR37` reader
        pub type R = crate::R<IPRIOR37_SPEC>;
        ///Register `IPRIOR37` writer
        pub type W = crate::W<IPRIOR37_SPEC>;
        ///Field `IPRIOR37` reader - RW,Interrupt priority for number 148-151
        pub type IPRIOR37_R = crate::FieldReader<u32>;
        ///Field `IPRIOR37` writer - RW,Interrupt priority for number 148-151
        pub type IPRIOR37_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 148-151
            #[inline(always)]
            pub fn iprior37(&self) -> IPRIOR37_R {
                IPRIOR37_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 148-151
            #[inline(always)]
            #[must_use]
            pub fn iprior37(&mut self) -> IPRIOR37_W<IPRIOR37_SPEC> {
                IPRIOR37_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register 37
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior37::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior37::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR37_SPEC;
        impl crate::RegisterSpec for IPRIOR37_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior37::R`](R) reader structure
        impl crate::Readable for IPRIOR37_SPEC {}
        ///`write(|w| ..)` method takes [`iprior37::W`](W) writer structure
        impl crate::Writable for IPRIOR37_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR37 to value 0
        impl crate::Resettable for IPRIOR37_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR38 (rw) register accessor: Interrupt Priority configuration Register 38
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior38::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior38::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior38`]
    ///module
    pub type IPRIOR38 = crate::Reg<iprior38::IPRIOR38_SPEC>;
    ///Interrupt Priority configuration Register 38
    pub mod iprior38 {
        ///Register `IPRIOR38` reader
        pub type R = crate::R<IPRIOR38_SPEC>;
        ///Register `IPRIOR38` writer
        pub type W = crate::W<IPRIOR38_SPEC>;
        ///Field `IPRIOR38` reader - RW,Interrupt priority for number 152-155
        pub type IPRIOR38_R = crate::FieldReader<u32>;
        ///Field `IPRIOR38` writer - RW,Interrupt priority for number 152-155
        pub type IPRIOR38_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 152-155
            #[inline(always)]
            pub fn iprior38(&self) -> IPRIOR38_R {
                IPRIOR38_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 152-155
            #[inline(always)]
            #[must_use]
            pub fn iprior38(&mut self) -> IPRIOR38_W<IPRIOR38_SPEC> {
                IPRIOR38_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register 38
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior38::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior38::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR38_SPEC;
        impl crate::RegisterSpec for IPRIOR38_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior38::R`](R) reader structure
        impl crate::Readable for IPRIOR38_SPEC {}
        ///`write(|w| ..)` method takes [`iprior38::W`](W) writer structure
        impl crate::Writable for IPRIOR38_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR38 to value 0
        impl crate::Resettable for IPRIOR38_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR39 (rw) register accessor: Interrupt Priority configuration Register 39
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior39::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior39::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior39`]
    ///module
    pub type IPRIOR39 = crate::Reg<iprior39::IPRIOR39_SPEC>;
    ///Interrupt Priority configuration Register 39
    pub mod iprior39 {
        ///Register `IPRIOR39` reader
        pub type R = crate::R<IPRIOR39_SPEC>;
        ///Register `IPRIOR39` writer
        pub type W = crate::W<IPRIOR39_SPEC>;
        ///Field `IPRIOR39` reader - RW,Interrupt priority for number 156-159
        pub type IPRIOR39_R = crate::FieldReader<u32>;
        ///Field `IPRIOR39` writer - RW,Interrupt priority for number 156-159
        pub type IPRIOR39_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 156-159
            #[inline(always)]
            pub fn iprior39(&self) -> IPRIOR39_R {
                IPRIOR39_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 156-159
            #[inline(always)]
            #[must_use]
            pub fn iprior39(&mut self) -> IPRIOR39_W<IPRIOR39_SPEC> {
                IPRIOR39_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register 39
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior39::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior39::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR39_SPEC;
        impl crate::RegisterSpec for IPRIOR39_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior39::R`](R) reader structure
        impl crate::Readable for IPRIOR39_SPEC {}
        ///`write(|w| ..)` method takes [`iprior39::W`](W) writer structure
        impl crate::Writable for IPRIOR39_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR39 to value 0
        impl crate::Resettable for IPRIOR39_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR40 (rw) register accessor: Interrupt Priority configuration Register 40
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior40::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior40::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior40`]
    ///module
    pub type IPRIOR40 = crate::Reg<iprior40::IPRIOR40_SPEC>;
    ///Interrupt Priority configuration Register 40
    pub mod iprior40 {
        ///Register `IPRIOR40` reader
        pub type R = crate::R<IPRIOR40_SPEC>;
        ///Register `IPRIOR40` writer
        pub type W = crate::W<IPRIOR40_SPEC>;
        ///Field `IPRIOR40` reader - RW,Interrupt priority for number 160-163
        pub type IPRIOR40_R = crate::FieldReader<u32>;
        ///Field `IPRIOR40` writer - RW,Interrupt priority for number 160-163
        pub type IPRIOR40_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 160-163
            #[inline(always)]
            pub fn iprior40(&self) -> IPRIOR40_R {
                IPRIOR40_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 160-163
            #[inline(always)]
            #[must_use]
            pub fn iprior40(&mut self) -> IPRIOR40_W<IPRIOR40_SPEC> {
                IPRIOR40_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register 40
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior40::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior40::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR40_SPEC;
        impl crate::RegisterSpec for IPRIOR40_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior40::R`](R) reader structure
        impl crate::Readable for IPRIOR40_SPEC {}
        ///`write(|w| ..)` method takes [`iprior40::W`](W) writer structure
        impl crate::Writable for IPRIOR40_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR40 to value 0
        impl crate::Resettable for IPRIOR40_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR41 (rw) register accessor: Interrupt Priority configuration Register 41
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior41::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior41::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior41`]
    ///module
    pub type IPRIOR41 = crate::Reg<iprior41::IPRIOR41_SPEC>;
    ///Interrupt Priority configuration Register 41
    pub mod iprior41 {
        ///Register `IPRIOR41` reader
        pub type R = crate::R<IPRIOR41_SPEC>;
        ///Register `IPRIOR41` writer
        pub type W = crate::W<IPRIOR41_SPEC>;
        ///Field `IPRIOR41` reader - RW,Interrupt priority for number 164-167
        pub type IPRIOR41_R = crate::FieldReader<u32>;
        ///Field `IPRIOR41` writer - RW,Interrupt priority for number 164-167
        pub type IPRIOR41_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 164-167
            #[inline(always)]
            pub fn iprior41(&self) -> IPRIOR41_R {
                IPRIOR41_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 164-167
            #[inline(always)]
            #[must_use]
            pub fn iprior41(&mut self) -> IPRIOR41_W<IPRIOR41_SPEC> {
                IPRIOR41_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register 41
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior41::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior41::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR41_SPEC;
        impl crate::RegisterSpec for IPRIOR41_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior41::R`](R) reader structure
        impl crate::Readable for IPRIOR41_SPEC {}
        ///`write(|w| ..)` method takes [`iprior41::W`](W) writer structure
        impl crate::Writable for IPRIOR41_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR41 to value 0
        impl crate::Resettable for IPRIOR41_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR42 (rw) register accessor: Interrupt Priority configuration Register 42
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior42::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior42::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior42`]
    ///module
    pub type IPRIOR42 = crate::Reg<iprior42::IPRIOR42_SPEC>;
    ///Interrupt Priority configuration Register 42
    pub mod iprior42 {
        ///Register `IPRIOR42` reader
        pub type R = crate::R<IPRIOR42_SPEC>;
        ///Register `IPRIOR42` writer
        pub type W = crate::W<IPRIOR42_SPEC>;
        ///Field `IPRIOR42` reader - RW,Interrupt priority for number 168-171
        pub type IPRIOR42_R = crate::FieldReader<u32>;
        ///Field `IPRIOR42` writer - RW,Interrupt priority for number 168-171
        pub type IPRIOR42_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 168-171
            #[inline(always)]
            pub fn iprior42(&self) -> IPRIOR42_R {
                IPRIOR42_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 168-171
            #[inline(always)]
            #[must_use]
            pub fn iprior42(&mut self) -> IPRIOR42_W<IPRIOR42_SPEC> {
                IPRIOR42_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register 42
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior42::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior42::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR42_SPEC;
        impl crate::RegisterSpec for IPRIOR42_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior42::R`](R) reader structure
        impl crate::Readable for IPRIOR42_SPEC {}
        ///`write(|w| ..)` method takes [`iprior42::W`](W) writer structure
        impl crate::Writable for IPRIOR42_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR42 to value 0
        impl crate::Resettable for IPRIOR42_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR43 (rw) register accessor: Interrupt Priority configuration Register 43
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior43::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior43::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior43`]
    ///module
    pub type IPRIOR43 = crate::Reg<iprior43::IPRIOR43_SPEC>;
    ///Interrupt Priority configuration Register 43
    pub mod iprior43 {
        ///Register `IPRIOR43` reader
        pub type R = crate::R<IPRIOR43_SPEC>;
        ///Register `IPRIOR43` writer
        pub type W = crate::W<IPRIOR43_SPEC>;
        ///Field `IPRIOR43` reader - RW,Interrupt priority for number 172-175
        pub type IPRIOR43_R = crate::FieldReader<u32>;
        ///Field `IPRIOR43` writer - RW,Interrupt priority for number 172-175
        pub type IPRIOR43_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 172-175
            #[inline(always)]
            pub fn iprior43(&self) -> IPRIOR43_R {
                IPRIOR43_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 172-175
            #[inline(always)]
            #[must_use]
            pub fn iprior43(&mut self) -> IPRIOR43_W<IPRIOR43_SPEC> {
                IPRIOR43_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register 43
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior43::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior43::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR43_SPEC;
        impl crate::RegisterSpec for IPRIOR43_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior43::R`](R) reader structure
        impl crate::Readable for IPRIOR43_SPEC {}
        ///`write(|w| ..)` method takes [`iprior43::W`](W) writer structure
        impl crate::Writable for IPRIOR43_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR43 to value 0
        impl crate::Resettable for IPRIOR43_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR44 (rw) register accessor: Interrupt Priority configuration Register 44
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior44::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior44::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior44`]
    ///module
    pub type IPRIOR44 = crate::Reg<iprior44::IPRIOR44_SPEC>;
    ///Interrupt Priority configuration Register 44
    pub mod iprior44 {
        ///Register `IPRIOR44` reader
        pub type R = crate::R<IPRIOR44_SPEC>;
        ///Register `IPRIOR44` writer
        pub type W = crate::W<IPRIOR44_SPEC>;
        ///Field `IPRIOR44` reader - RW,Interrupt priority for number 176-179
        pub type IPRIOR44_R = crate::FieldReader<u32>;
        ///Field `IPRIOR44` writer - RW,Interrupt priority for number 176-179
        pub type IPRIOR44_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 176-179
            #[inline(always)]
            pub fn iprior44(&self) -> IPRIOR44_R {
                IPRIOR44_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 176-179
            #[inline(always)]
            #[must_use]
            pub fn iprior44(&mut self) -> IPRIOR44_W<IPRIOR44_SPEC> {
                IPRIOR44_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register 44
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior44::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior44::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR44_SPEC;
        impl crate::RegisterSpec for IPRIOR44_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior44::R`](R) reader structure
        impl crate::Readable for IPRIOR44_SPEC {}
        ///`write(|w| ..)` method takes [`iprior44::W`](W) writer structure
        impl crate::Writable for IPRIOR44_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR44 to value 0
        impl crate::Resettable for IPRIOR44_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR45 (rw) register accessor: Interrupt Priority configuration Register 45
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior45::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior45::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior45`]
    ///module
    pub type IPRIOR45 = crate::Reg<iprior45::IPRIOR45_SPEC>;
    ///Interrupt Priority configuration Register 45
    pub mod iprior45 {
        ///Register `IPRIOR45` reader
        pub type R = crate::R<IPRIOR45_SPEC>;
        ///Register `IPRIOR45` writer
        pub type W = crate::W<IPRIOR45_SPEC>;
        ///Field `IPRIOR45` reader - RW,Interrupt priority for number 180-183
        pub type IPRIOR45_R = crate::FieldReader<u32>;
        ///Field `IPRIOR45` writer - RW,Interrupt priority for number 180-183
        pub type IPRIOR45_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 180-183
            #[inline(always)]
            pub fn iprior45(&self) -> IPRIOR45_R {
                IPRIOR45_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 180-183
            #[inline(always)]
            #[must_use]
            pub fn iprior45(&mut self) -> IPRIOR45_W<IPRIOR45_SPEC> {
                IPRIOR45_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register 45
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior45::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior45::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR45_SPEC;
        impl crate::RegisterSpec for IPRIOR45_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior45::R`](R) reader structure
        impl crate::Readable for IPRIOR45_SPEC {}
        ///`write(|w| ..)` method takes [`iprior45::W`](W) writer structure
        impl crate::Writable for IPRIOR45_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR45 to value 0
        impl crate::Resettable for IPRIOR45_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR46 (rw) register accessor: Interrupt Priority configuration Register 46
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior46::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior46::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior46`]
    ///module
    pub type IPRIOR46 = crate::Reg<iprior46::IPRIOR46_SPEC>;
    ///Interrupt Priority configuration Register 46
    pub mod iprior46 {
        ///Register `IPRIOR46` reader
        pub type R = crate::R<IPRIOR46_SPEC>;
        ///Register `IPRIOR46` writer
        pub type W = crate::W<IPRIOR46_SPEC>;
        ///Field `IPRIOR46` reader - RW,Interrupt priority for number 184-187
        pub type IPRIOR46_R = crate::FieldReader<u32>;
        ///Field `IPRIOR46` writer - RW,Interrupt priority for number 184-187
        pub type IPRIOR46_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 184-187
            #[inline(always)]
            pub fn iprior46(&self) -> IPRIOR46_R {
                IPRIOR46_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 184-187
            #[inline(always)]
            #[must_use]
            pub fn iprior46(&mut self) -> IPRIOR46_W<IPRIOR46_SPEC> {
                IPRIOR46_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register 46
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior46::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior46::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR46_SPEC;
        impl crate::RegisterSpec for IPRIOR46_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior46::R`](R) reader structure
        impl crate::Readable for IPRIOR46_SPEC {}
        ///`write(|w| ..)` method takes [`iprior46::W`](W) writer structure
        impl crate::Writable for IPRIOR46_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR46 to value 0
        impl crate::Resettable for IPRIOR46_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR47 (rw) register accessor: Interrupt Priority configuration Register 47
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior47::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior47::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior47`]
    ///module
    pub type IPRIOR47 = crate::Reg<iprior47::IPRIOR47_SPEC>;
    ///Interrupt Priority configuration Register 47
    pub mod iprior47 {
        ///Register `IPRIOR47` reader
        pub type R = crate::R<IPRIOR47_SPEC>;
        ///Register `IPRIOR47` writer
        pub type W = crate::W<IPRIOR47_SPEC>;
        ///Field `IPRIOR47` reader - RW,Interrupt priority for number 188-191
        pub type IPRIOR47_R = crate::FieldReader<u32>;
        ///Field `IPRIOR47` writer - RW,Interrupt priority for number 188-191
        pub type IPRIOR47_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 188-191
            #[inline(always)]
            pub fn iprior47(&self) -> IPRIOR47_R {
                IPRIOR47_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 188-191
            #[inline(always)]
            #[must_use]
            pub fn iprior47(&mut self) -> IPRIOR47_W<IPRIOR47_SPEC> {
                IPRIOR47_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register 47
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior47::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior47::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR47_SPEC;
        impl crate::RegisterSpec for IPRIOR47_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior47::R`](R) reader structure
        impl crate::Readable for IPRIOR47_SPEC {}
        ///`write(|w| ..)` method takes [`iprior47::W`](W) writer structure
        impl crate::Writable for IPRIOR47_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR47 to value 0
        impl crate::Resettable for IPRIOR47_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR48 (rw) register accessor: Interrupt Priority configuration Register 48
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior48::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior48::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior48`]
    ///module
    pub type IPRIOR48 = crate::Reg<iprior48::IPRIOR48_SPEC>;
    ///Interrupt Priority configuration Register 48
    pub mod iprior48 {
        ///Register `IPRIOR48` reader
        pub type R = crate::R<IPRIOR48_SPEC>;
        ///Register `IPRIOR48` writer
        pub type W = crate::W<IPRIOR48_SPEC>;
        ///Field `IPRIOR48` reader - RW,Interrupt priority for number 192-195
        pub type IPRIOR48_R = crate::FieldReader<u32>;
        ///Field `IPRIOR48` writer - RW,Interrupt priority for number 192-195
        pub type IPRIOR48_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 192-195
            #[inline(always)]
            pub fn iprior48(&self) -> IPRIOR48_R {
                IPRIOR48_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 192-195
            #[inline(always)]
            #[must_use]
            pub fn iprior48(&mut self) -> IPRIOR48_W<IPRIOR48_SPEC> {
                IPRIOR48_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register 48
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior48::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior48::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR48_SPEC;
        impl crate::RegisterSpec for IPRIOR48_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior48::R`](R) reader structure
        impl crate::Readable for IPRIOR48_SPEC {}
        ///`write(|w| ..)` method takes [`iprior48::W`](W) writer structure
        impl crate::Writable for IPRIOR48_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR48 to value 0
        impl crate::Resettable for IPRIOR48_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR49 (rw) register accessor: Interrupt Priority configuration Register 49
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior49::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior49::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior49`]
    ///module
    pub type IPRIOR49 = crate::Reg<iprior49::IPRIOR49_SPEC>;
    ///Interrupt Priority configuration Register 49
    pub mod iprior49 {
        ///Register `IPRIOR49` reader
        pub type R = crate::R<IPRIOR49_SPEC>;
        ///Register `IPRIOR49` writer
        pub type W = crate::W<IPRIOR49_SPEC>;
        ///Field `IPRIOR49` reader - RW,Interrupt priority for number 196-199
        pub type IPRIOR49_R = crate::FieldReader<u32>;
        ///Field `IPRIOR49` writer - RW,Interrupt priority for number 196-199
        pub type IPRIOR49_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 196-199
            #[inline(always)]
            pub fn iprior49(&self) -> IPRIOR49_R {
                IPRIOR49_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 196-199
            #[inline(always)]
            #[must_use]
            pub fn iprior49(&mut self) -> IPRIOR49_W<IPRIOR49_SPEC> {
                IPRIOR49_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register 49
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior49::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior49::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR49_SPEC;
        impl crate::RegisterSpec for IPRIOR49_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior49::R`](R) reader structure
        impl crate::Readable for IPRIOR49_SPEC {}
        ///`write(|w| ..)` method takes [`iprior49::W`](W) writer structure
        impl crate::Writable for IPRIOR49_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR49 to value 0
        impl crate::Resettable for IPRIOR49_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR50 (rw) register accessor: Interrupt Priority configuration Register 50
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior50::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior50::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior50`]
    ///module
    pub type IPRIOR50 = crate::Reg<iprior50::IPRIOR50_SPEC>;
    ///Interrupt Priority configuration Register 50
    pub mod iprior50 {
        ///Register `IPRIOR50` reader
        pub type R = crate::R<IPRIOR50_SPEC>;
        ///Register `IPRIOR50` writer
        pub type W = crate::W<IPRIOR50_SPEC>;
        ///Field `IPRIOR50` reader - RW,Interrupt priority for number 200-203
        pub type IPRIOR50_R = crate::FieldReader<u32>;
        ///Field `IPRIOR50` writer - RW,Interrupt priority for number 200-203
        pub type IPRIOR50_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 200-203
            #[inline(always)]
            pub fn iprior50(&self) -> IPRIOR50_R {
                IPRIOR50_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 200-203
            #[inline(always)]
            #[must_use]
            pub fn iprior50(&mut self) -> IPRIOR50_W<IPRIOR50_SPEC> {
                IPRIOR50_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register 50
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior50::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior50::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR50_SPEC;
        impl crate::RegisterSpec for IPRIOR50_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior50::R`](R) reader structure
        impl crate::Readable for IPRIOR50_SPEC {}
        ///`write(|w| ..)` method takes [`iprior50::W`](W) writer structure
        impl crate::Writable for IPRIOR50_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR50 to value 0
        impl crate::Resettable for IPRIOR50_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR51 (rw) register accessor: Interrupt Priority configuration Register 51
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior51::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior51::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior51`]
    ///module
    pub type IPRIOR51 = crate::Reg<iprior51::IPRIOR51_SPEC>;
    ///Interrupt Priority configuration Register 51
    pub mod iprior51 {
        ///Register `IPRIOR51` reader
        pub type R = crate::R<IPRIOR51_SPEC>;
        ///Register `IPRIOR51` writer
        pub type W = crate::W<IPRIOR51_SPEC>;
        ///Field `IPRIOR51` reader - RW,Interrupt priority for number 204-207
        pub type IPRIOR51_R = crate::FieldReader<u32>;
        ///Field `IPRIOR51` writer - RW,Interrupt priority for number 204-207
        pub type IPRIOR51_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 204-207
            #[inline(always)]
            pub fn iprior51(&self) -> IPRIOR51_R {
                IPRIOR51_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 204-207
            #[inline(always)]
            #[must_use]
            pub fn iprior51(&mut self) -> IPRIOR51_W<IPRIOR51_SPEC> {
                IPRIOR51_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register 51
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior51::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior51::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR51_SPEC;
        impl crate::RegisterSpec for IPRIOR51_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior51::R`](R) reader structure
        impl crate::Readable for IPRIOR51_SPEC {}
        ///`write(|w| ..)` method takes [`iprior51::W`](W) writer structure
        impl crate::Writable for IPRIOR51_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR51 to value 0
        impl crate::Resettable for IPRIOR51_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR52 (rw) register accessor: Interrupt Priority configuration Register 52
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior52::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior52::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior52`]
    ///module
    pub type IPRIOR52 = crate::Reg<iprior52::IPRIOR52_SPEC>;
    ///Interrupt Priority configuration Register 52
    pub mod iprior52 {
        ///Register `IPRIOR52` reader
        pub type R = crate::R<IPRIOR52_SPEC>;
        ///Register `IPRIOR52` writer
        pub type W = crate::W<IPRIOR52_SPEC>;
        ///Field `IPRIOR52` reader - RW,Interrupt priority for number 208-211
        pub type IPRIOR52_R = crate::FieldReader<u32>;
        ///Field `IPRIOR52` writer - RW,Interrupt priority for number 208-211
        pub type IPRIOR52_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 208-211
            #[inline(always)]
            pub fn iprior52(&self) -> IPRIOR52_R {
                IPRIOR52_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 208-211
            #[inline(always)]
            #[must_use]
            pub fn iprior52(&mut self) -> IPRIOR52_W<IPRIOR52_SPEC> {
                IPRIOR52_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register 52
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior52::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior52::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR52_SPEC;
        impl crate::RegisterSpec for IPRIOR52_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior52::R`](R) reader structure
        impl crate::Readable for IPRIOR52_SPEC {}
        ///`write(|w| ..)` method takes [`iprior52::W`](W) writer structure
        impl crate::Writable for IPRIOR52_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR52 to value 0
        impl crate::Resettable for IPRIOR52_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR53 (rw) register accessor: Interrupt Priority configuration Register 53
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior53::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior53::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior53`]
    ///module
    pub type IPRIOR53 = crate::Reg<iprior53::IPRIOR53_SPEC>;
    ///Interrupt Priority configuration Register 53
    pub mod iprior53 {
        ///Register `IPRIOR53` reader
        pub type R = crate::R<IPRIOR53_SPEC>;
        ///Register `IPRIOR53` writer
        pub type W = crate::W<IPRIOR53_SPEC>;
        ///Field `IPRIOR53` reader - RW,Interrupt priority for number 212-215
        pub type IPRIOR53_R = crate::FieldReader<u32>;
        ///Field `IPRIOR53` writer - RW,Interrupt priority for number 212-215
        pub type IPRIOR53_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 212-215
            #[inline(always)]
            pub fn iprior53(&self) -> IPRIOR53_R {
                IPRIOR53_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 212-215
            #[inline(always)]
            #[must_use]
            pub fn iprior53(&mut self) -> IPRIOR53_W<IPRIOR53_SPEC> {
                IPRIOR53_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register 53
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior53::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior53::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR53_SPEC;
        impl crate::RegisterSpec for IPRIOR53_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior53::R`](R) reader structure
        impl crate::Readable for IPRIOR53_SPEC {}
        ///`write(|w| ..)` method takes [`iprior53::W`](W) writer structure
        impl crate::Writable for IPRIOR53_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR53 to value 0
        impl crate::Resettable for IPRIOR53_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR54 (rw) register accessor: Interrupt Priority configuration Register 54
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior54::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior54::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior54`]
    ///module
    pub type IPRIOR54 = crate::Reg<iprior54::IPRIOR54_SPEC>;
    ///Interrupt Priority configuration Register 54
    pub mod iprior54 {
        ///Register `IPRIOR54` reader
        pub type R = crate::R<IPRIOR54_SPEC>;
        ///Register `IPRIOR54` writer
        pub type W = crate::W<IPRIOR54_SPEC>;
        ///Field `IPRIOR54` reader - RW,Interrupt priority for number 216-219
        pub type IPRIOR54_R = crate::FieldReader<u32>;
        ///Field `IPRIOR54` writer - RW,Interrupt priority for number 216-219
        pub type IPRIOR54_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 216-219
            #[inline(always)]
            pub fn iprior54(&self) -> IPRIOR54_R {
                IPRIOR54_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 216-219
            #[inline(always)]
            #[must_use]
            pub fn iprior54(&mut self) -> IPRIOR54_W<IPRIOR54_SPEC> {
                IPRIOR54_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register 54
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior54::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior54::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR54_SPEC;
        impl crate::RegisterSpec for IPRIOR54_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior54::R`](R) reader structure
        impl crate::Readable for IPRIOR54_SPEC {}
        ///`write(|w| ..)` method takes [`iprior54::W`](W) writer structure
        impl crate::Writable for IPRIOR54_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR54 to value 0
        impl crate::Resettable for IPRIOR54_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR55 (rw) register accessor: Interrupt Priority configuration Register 55
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior55::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior55::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior55`]
    ///module
    pub type IPRIOR55 = crate::Reg<iprior55::IPRIOR55_SPEC>;
    ///Interrupt Priority configuration Register 55
    pub mod iprior55 {
        ///Register `IPRIOR55` reader
        pub type R = crate::R<IPRIOR55_SPEC>;
        ///Register `IPRIOR55` writer
        pub type W = crate::W<IPRIOR55_SPEC>;
        ///Field `IPRIOR55` reader - RW,Interrupt priority for number 220-223
        pub type IPRIOR55_R = crate::FieldReader<u32>;
        ///Field `IPRIOR55` writer - RW,Interrupt priority for number 220-223
        pub type IPRIOR55_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 220-223
            #[inline(always)]
            pub fn iprior55(&self) -> IPRIOR55_R {
                IPRIOR55_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 220-223
            #[inline(always)]
            #[must_use]
            pub fn iprior55(&mut self) -> IPRIOR55_W<IPRIOR55_SPEC> {
                IPRIOR55_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register 55
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior55::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior55::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR55_SPEC;
        impl crate::RegisterSpec for IPRIOR55_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior55::R`](R) reader structure
        impl crate::Readable for IPRIOR55_SPEC {}
        ///`write(|w| ..)` method takes [`iprior55::W`](W) writer structure
        impl crate::Writable for IPRIOR55_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR55 to value 0
        impl crate::Resettable for IPRIOR55_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR56 (rw) register accessor: Interrupt Priority configuration Register 56
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior56::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior56::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior56`]
    ///module
    pub type IPRIOR56 = crate::Reg<iprior56::IPRIOR56_SPEC>;
    ///Interrupt Priority configuration Register 56
    pub mod iprior56 {
        ///Register `IPRIOR56` reader
        pub type R = crate::R<IPRIOR56_SPEC>;
        ///Register `IPRIOR56` writer
        pub type W = crate::W<IPRIOR56_SPEC>;
        ///Field `IPRIOR56` reader - RW,Interrupt priority for number 224-227
        pub type IPRIOR56_R = crate::FieldReader<u32>;
        ///Field `IPRIOR56` writer - RW,Interrupt priority for number 224-227
        pub type IPRIOR56_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 224-227
            #[inline(always)]
            pub fn iprior56(&self) -> IPRIOR56_R {
                IPRIOR56_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 224-227
            #[inline(always)]
            #[must_use]
            pub fn iprior56(&mut self) -> IPRIOR56_W<IPRIOR56_SPEC> {
                IPRIOR56_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register 56
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior56::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior56::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR56_SPEC;
        impl crate::RegisterSpec for IPRIOR56_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior56::R`](R) reader structure
        impl crate::Readable for IPRIOR56_SPEC {}
        ///`write(|w| ..)` method takes [`iprior56::W`](W) writer structure
        impl crate::Writable for IPRIOR56_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR56 to value 0
        impl crate::Resettable for IPRIOR56_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR57 (rw) register accessor: Interrupt Priority configuration Register 57
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior57::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior57::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior57`]
    ///module
    pub type IPRIOR57 = crate::Reg<iprior57::IPRIOR57_SPEC>;
    ///Interrupt Priority configuration Register 57
    pub mod iprior57 {
        ///Register `IPRIOR57` reader
        pub type R = crate::R<IPRIOR57_SPEC>;
        ///Register `IPRIOR57` writer
        pub type W = crate::W<IPRIOR57_SPEC>;
        ///Field `IPRIOR57` reader - RW,Interrupt priority for number 228-231
        pub type IPRIOR57_R = crate::FieldReader<u32>;
        ///Field `IPRIOR57` writer - RW,Interrupt priority for number 228-231
        pub type IPRIOR57_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 228-231
            #[inline(always)]
            pub fn iprior57(&self) -> IPRIOR57_R {
                IPRIOR57_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 228-231
            #[inline(always)]
            #[must_use]
            pub fn iprior57(&mut self) -> IPRIOR57_W<IPRIOR57_SPEC> {
                IPRIOR57_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register 57
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior57::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior57::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR57_SPEC;
        impl crate::RegisterSpec for IPRIOR57_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior57::R`](R) reader structure
        impl crate::Readable for IPRIOR57_SPEC {}
        ///`write(|w| ..)` method takes [`iprior57::W`](W) writer structure
        impl crate::Writable for IPRIOR57_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR57 to value 0
        impl crate::Resettable for IPRIOR57_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR58 (rw) register accessor: Interrupt Priority configuration Register 58
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior58::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior58::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior58`]
    ///module
    pub type IPRIOR58 = crate::Reg<iprior58::IPRIOR58_SPEC>;
    ///Interrupt Priority configuration Register 58
    pub mod iprior58 {
        ///Register `IPRIOR58` reader
        pub type R = crate::R<IPRIOR58_SPEC>;
        ///Register `IPRIOR58` writer
        pub type W = crate::W<IPRIOR58_SPEC>;
        ///Field `IPRIOR58` reader - RW,Interrupt priority for number 232-235
        pub type IPRIOR58_R = crate::FieldReader<u32>;
        ///Field `IPRIOR58` writer - RW,Interrupt priority for number 232-235
        pub type IPRIOR58_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 232-235
            #[inline(always)]
            pub fn iprior58(&self) -> IPRIOR58_R {
                IPRIOR58_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 232-235
            #[inline(always)]
            #[must_use]
            pub fn iprior58(&mut self) -> IPRIOR58_W<IPRIOR58_SPEC> {
                IPRIOR58_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register 58
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior58::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior58::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR58_SPEC;
        impl crate::RegisterSpec for IPRIOR58_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior58::R`](R) reader structure
        impl crate::Readable for IPRIOR58_SPEC {}
        ///`write(|w| ..)` method takes [`iprior58::W`](W) writer structure
        impl crate::Writable for IPRIOR58_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR58 to value 0
        impl crate::Resettable for IPRIOR58_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR59 (rw) register accessor: Interrupt Priority configuration Register 59
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior59::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior59::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior59`]
    ///module
    pub type IPRIOR59 = crate::Reg<iprior59::IPRIOR59_SPEC>;
    ///Interrupt Priority configuration Register 59
    pub mod iprior59 {
        ///Register `IPRIOR59` reader
        pub type R = crate::R<IPRIOR59_SPEC>;
        ///Register `IPRIOR59` writer
        pub type W = crate::W<IPRIOR59_SPEC>;
        ///Field `IPRIOR59` reader - RW,Interrupt priority for number 236-239
        pub type IPRIOR59_R = crate::FieldReader<u32>;
        ///Field `IPRIOR59` writer - RW,Interrupt priority for number 236-239
        pub type IPRIOR59_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 236-239
            #[inline(always)]
            pub fn iprior59(&self) -> IPRIOR59_R {
                IPRIOR59_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 236-239
            #[inline(always)]
            #[must_use]
            pub fn iprior59(&mut self) -> IPRIOR59_W<IPRIOR59_SPEC> {
                IPRIOR59_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register 59
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior59::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior59::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR59_SPEC;
        impl crate::RegisterSpec for IPRIOR59_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior59::R`](R) reader structure
        impl crate::Readable for IPRIOR59_SPEC {}
        ///`write(|w| ..)` method takes [`iprior59::W`](W) writer structure
        impl crate::Writable for IPRIOR59_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR59 to value 0
        impl crate::Resettable for IPRIOR59_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR60 (rw) register accessor: Interrupt Priority configuration Register 60
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior60::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior60::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior60`]
    ///module
    pub type IPRIOR60 = crate::Reg<iprior60::IPRIOR60_SPEC>;
    ///Interrupt Priority configuration Register 60
    pub mod iprior60 {
        ///Register `IPRIOR60` reader
        pub type R = crate::R<IPRIOR60_SPEC>;
        ///Register `IPRIOR60` writer
        pub type W = crate::W<IPRIOR60_SPEC>;
        ///Field `IPRIOR60` reader - RW,Interrupt priority for number 240-243
        pub type IPRIOR60_R = crate::FieldReader<u32>;
        ///Field `IPRIOR60` writer - RW,Interrupt priority for number 240-243
        pub type IPRIOR60_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 240-243
            #[inline(always)]
            pub fn iprior60(&self) -> IPRIOR60_R {
                IPRIOR60_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 240-243
            #[inline(always)]
            #[must_use]
            pub fn iprior60(&mut self) -> IPRIOR60_W<IPRIOR60_SPEC> {
                IPRIOR60_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register 60
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior60::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior60::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR60_SPEC;
        impl crate::RegisterSpec for IPRIOR60_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior60::R`](R) reader structure
        impl crate::Readable for IPRIOR60_SPEC {}
        ///`write(|w| ..)` method takes [`iprior60::W`](W) writer structure
        impl crate::Writable for IPRIOR60_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR60 to value 0
        impl crate::Resettable for IPRIOR60_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR61 (rw) register accessor: Interrupt Priority configuration Register 61
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior61::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior61::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior61`]
    ///module
    pub type IPRIOR61 = crate::Reg<iprior61::IPRIOR61_SPEC>;
    ///Interrupt Priority configuration Register 61
    pub mod iprior61 {
        ///Register `IPRIOR61` reader
        pub type R = crate::R<IPRIOR61_SPEC>;
        ///Register `IPRIOR61` writer
        pub type W = crate::W<IPRIOR61_SPEC>;
        ///Field `IPRIOR61` reader - RW,Interrupt priority for number 244-247
        pub type IPRIOR61_R = crate::FieldReader<u32>;
        ///Field `IPRIOR61` writer - RW,Interrupt priority for number 244-247
        pub type IPRIOR61_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 244-247
            #[inline(always)]
            pub fn iprior61(&self) -> IPRIOR61_R {
                IPRIOR61_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 244-247
            #[inline(always)]
            #[must_use]
            pub fn iprior61(&mut self) -> IPRIOR61_W<IPRIOR61_SPEC> {
                IPRIOR61_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register 61
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior61::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior61::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR61_SPEC;
        impl crate::RegisterSpec for IPRIOR61_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior61::R`](R) reader structure
        impl crate::Readable for IPRIOR61_SPEC {}
        ///`write(|w| ..)` method takes [`iprior61::W`](W) writer structure
        impl crate::Writable for IPRIOR61_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR61 to value 0
        impl crate::Resettable for IPRIOR61_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR62 (rw) register accessor: Interrupt Priority configuration Register 62
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior62::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior62::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior62`]
    ///module
    pub type IPRIOR62 = crate::Reg<iprior62::IPRIOR62_SPEC>;
    ///Interrupt Priority configuration Register 62
    pub mod iprior62 {
        ///Register `IPRIOR62` reader
        pub type R = crate::R<IPRIOR62_SPEC>;
        ///Register `IPRIOR62` writer
        pub type W = crate::W<IPRIOR62_SPEC>;
        ///Field `IPRIOR62` reader - RW,Interrupt priority for number 248-251
        pub type IPRIOR62_R = crate::FieldReader<u32>;
        ///Field `IPRIOR62` writer - RW,Interrupt priority for number 248-251
        pub type IPRIOR62_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 248-251
            #[inline(always)]
            pub fn iprior62(&self) -> IPRIOR62_R {
                IPRIOR62_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 248-251
            #[inline(always)]
            #[must_use]
            pub fn iprior62(&mut self) -> IPRIOR62_W<IPRIOR62_SPEC> {
                IPRIOR62_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register 62
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior62::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior62::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR62_SPEC;
        impl crate::RegisterSpec for IPRIOR62_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior62::R`](R) reader structure
        impl crate::Readable for IPRIOR62_SPEC {}
        ///`write(|w| ..)` method takes [`iprior62::W`](W) writer structure
        impl crate::Writable for IPRIOR62_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR62 to value 0
        impl crate::Resettable for IPRIOR62_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///IPRIOR63 (rw) register accessor: Interrupt Priority configuration Register 63
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior63::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior63::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@iprior63`]
    ///module
    pub type IPRIOR63 = crate::Reg<iprior63::IPRIOR63_SPEC>;
    ///Interrupt Priority configuration Register 63
    pub mod iprior63 {
        ///Register `IPRIOR63` reader
        pub type R = crate::R<IPRIOR63_SPEC>;
        ///Register `IPRIOR63` writer
        pub type W = crate::W<IPRIOR63_SPEC>;
        ///Field `IPRIOR63` reader - RW,Interrupt priority for number 252-255
        pub type IPRIOR63_R = crate::FieldReader<u32>;
        ///Field `IPRIOR63` writer - RW,Interrupt priority for number 252-255
        pub type IPRIOR63_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 252-255
            #[inline(always)]
            pub fn iprior63(&self) -> IPRIOR63_R {
                IPRIOR63_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 252-255
            #[inline(always)]
            #[must_use]
            pub fn iprior63(&mut self) -> IPRIOR63_W<IPRIOR63_SPEC> {
                IPRIOR63_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///Interrupt Priority configuration Register 63
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`iprior63::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iprior63::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct IPRIOR63_SPEC;
        impl crate::RegisterSpec for IPRIOR63_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`iprior63::R`](R) reader structure
        impl crate::Readable for IPRIOR63_SPEC {}
        ///`write(|w| ..)` method takes [`iprior63::W`](W) writer structure
        impl crate::Writable for IPRIOR63_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets IPRIOR63 to value 0
        impl crate::Resettable for IPRIOR63_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///SCTLR (rw) register accessor: System Control Register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`sctlr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`sctlr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@sctlr`]
    ///module
    pub type SCTLR = crate::Reg<sctlr::SCTLR_SPEC>;
    ///System Control Register
    pub mod sctlr {
        ///Register `SCTLR` reader
        pub type R = crate::R<SCTLR_SPEC>;
        ///Register `SCTLR` writer
        pub type W = crate::W<SCTLR_SPEC>;
        ///Field `SLEEPONEXIT` reader - RW,SLEEPONEXIT
        pub type SLEEPONEXIT_R = crate::BitReader;
        ///Field `SLEEPONEXIT` writer - RW,SLEEPONEXIT
        pub type SLEEPONEXIT_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `SLEEPDEEP` reader - RW,SLEEPDEEP
        pub type SLEEPDEEP_R = crate::BitReader;
        ///Field `SLEEPDEEP` writer - RW,SLEEPDEEP
        pub type SLEEPDEEP_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `WFITOWFE` reader - RW,WFITOWFE
        pub type WFITOWFE_R = crate::BitReader;
        ///Field `WFITOWFE` writer - RW,WFITOWFE
        pub type WFITOWFE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `SEVONPEND` reader - RW,SEVONPEND
        pub type SEVONPEND_R = crate::BitReader;
        ///Field `SEVONPEND` writer - RW,SEVONPEND
        pub type SEVONPEND_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `SETEVENT` reader - WO,SETEVENT
        pub type SETEVENT_R = crate::BitReader;
        ///Field `SETEVENT` writer - WO,SETEVENT
        pub type SETEVENT_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 1 - RW,SLEEPONEXIT
            #[inline(always)]
            pub fn sleeponexit(&self) -> SLEEPONEXIT_R {
                SLEEPONEXIT_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RW,SLEEPDEEP
            #[inline(always)]
            pub fn sleepdeep(&self) -> SLEEPDEEP_R {
                SLEEPDEEP_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RW,WFITOWFE
            #[inline(always)]
            pub fn wfitowfe(&self) -> WFITOWFE_R {
                WFITOWFE_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RW,SEVONPEND
            #[inline(always)]
            pub fn sevonpend(&self) -> SEVONPEND_R {
                SEVONPEND_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - WO,SETEVENT
            #[inline(always)]
            pub fn setevent(&self) -> SETEVENT_R {
                SETEVENT_R::new(((self.bits >> 5) & 1) != 0)
            }
        }
        impl W {
            ///Bit 1 - RW,SLEEPONEXIT
            #[inline(always)]
            #[must_use]
            pub fn sleeponexit(&mut self) -> SLEEPONEXIT_W<SCTLR_SPEC> {
                SLEEPONEXIT_W::new(self, 1)
            }
            ///Bit 2 - RW,SLEEPDEEP
            #[inline(always)]
            #[must_use]
            pub fn sleepdeep(&mut self) -> SLEEPDEEP_W<SCTLR_SPEC> {
                SLEEPDEEP_W::new(self, 2)
            }
            ///Bit 3 - RW,WFITOWFE
            #[inline(always)]
            #[must_use]
            pub fn wfitowfe(&mut self) -> WFITOWFE_W<SCTLR_SPEC> {
                WFITOWFE_W::new(self, 3)
            }
            ///Bit 4 - RW,SEVONPEND
            #[inline(always)]
            #[must_use]
            pub fn sevonpend(&mut self) -> SEVONPEND_W<SCTLR_SPEC> {
                SEVONPEND_W::new(self, 4)
            }
            ///Bit 5 - WO,SETEVENT
            #[inline(always)]
            #[must_use]
            pub fn setevent(&mut self) -> SETEVENT_W<SCTLR_SPEC> {
                SETEVENT_W::new(self, 5)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///System Control Register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`sctlr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`sctlr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct SCTLR_SPEC;
        impl crate::RegisterSpec for SCTLR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`sctlr::R`](R) reader structure
        impl crate::Readable for SCTLR_SPEC {}
        ///`write(|w| ..)` method takes [`sctlr::W`](W) writer structure
        impl crate::Writable for SCTLR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets SCTLR to value 0
        impl crate::Resettable for SCTLR_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
}
///ADC, split from SYS
pub struct ADC {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for ADC {}
impl ADC {
    ///Pointer to the register block
    pub const PTR: *const adc::RegisterBlock = 0x4000_1000 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const adc::RegisterBlock {
        Self::PTR
    }
    /// Steal an instance of this peripheral
    ///
    /// # Safety
    ///
    /// Ensure that the new instance of the peripheral cannot be used in a way
    /// that may race with any existing instances, for example by only
    /// accessing read-only or write-only registers, or by consuming the
    /// original peripheral and using critical sections to coordinate
    /// access between multiple new instances.
    ///
    /// Additionally, other software such as HALs may rely on only one
    /// peripheral instance existing to ensure memory safety; ensure
    /// no stolen instances are passed to such software.
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for ADC {
    type Target = adc::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for ADC {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("ADC").finish()
    }
}
///ADC, split from SYS
pub mod adc {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        _reserved0: [u8; 0x58],
        channel: CHANNEL,
        cfg: CFG,
        convert: CONVERT,
        tem_sensor: TEM_SENSOR,
        data: DATA,
        int_flag: INT_FLAG,
        _reserved6: [u8; 0x02],
        dma_ctrl: DMA_CTRL,
        dma_if: DMA_IF,
        auto_cycle: AUTO_CYCLE,
        dma_now: DMA_NOW,
        _reserved10: [u8; 0x02],
        dma_beg: DMA_BEG,
        _reserved11: [u8; 0x02],
        dma_end: DMA_END,
    }
    impl RegisterBlock {
        ///0x58 - ADC channel select
        #[inline(always)]
        pub const fn channel(&self) -> &CHANNEL {
            &self.channel
        }
        ///0x59 - ADC configuration
        #[inline(always)]
        pub const fn cfg(&self) -> &CFG {
            &self.cfg
        }
        ///0x5a - ADC conversion control
        #[inline(always)]
        pub const fn convert(&self) -> &CONVERT {
            &self.convert
        }
        ///0x5b - ADC temperature sensor
        #[inline(always)]
        pub const fn tem_sensor(&self) -> &TEM_SENSOR {
            &self.tem_sensor
        }
        ///0x5c - ADC conversion data
        #[inline(always)]
        pub const fn data(&self) -> &DATA {
            &self.data
        }
        ///0x5e - ADC interrupt flag
        #[inline(always)]
        pub const fn int_flag(&self) -> &INT_FLAG {
            &self.int_flag
        }
        ///0x61 - ADC DMA control. Renamed from CTRL_DMA
        #[inline(always)]
        pub const fn dma_ctrl(&self) -> &DMA_CTRL {
            &self.dma_ctrl
        }
        ///0x62 - ADC DMA interrupt flag
        #[inline(always)]
        pub const fn dma_if(&self) -> &DMA_IF {
            &self.dma_if
        }
        ///0x63 - ADC auto cycle for contineous conversion
        #[inline(always)]
        pub const fn auto_cycle(&self) -> &AUTO_CYCLE {
            &self.auto_cycle
        }
        ///0x64 - ADC DMA address, current
        #[inline(always)]
        pub const fn dma_now(&self) -> &DMA_NOW {
            &self.dma_now
        }
        ///0x68 - ADC DMA address, begin
        #[inline(always)]
        pub const fn dma_beg(&self) -> &DMA_BEG {
            &self.dma_beg
        }
        ///0x6c - ADC DMA address, end
        #[inline(always)]
        pub const fn dma_end(&self) -> &DMA_END {
            &self.dma_end
        }
    }
    ///CHANNEL (rw) register accessor: ADC channel select
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`channel::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`channel::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@channel`]
    ///module
    pub type CHANNEL = crate::Reg<channel::CHANNEL_SPEC>;
    ///ADC channel select
    pub mod channel {
        ///Register `CHANNEL` reader
        pub type R = crate::R<CHANNEL_SPEC>;
        ///Register `CHANNEL` writer
        pub type W = crate::W<CHANNEL_SPEC>;
        ///Field `CH_IDX` reader - ADC input channel index
        pub type CH_IDX_R = crate::FieldReader;
        ///Field `CH_IDX` writer - ADC input channel index
        pub type CH_IDX_W<'a, REG> = crate::FieldWriter<'a, REG, 4>;
        impl R {
            ///Bits 0:3 - ADC input channel index
            #[inline(always)]
            pub fn ch_idx(&self) -> CH_IDX_R {
                CH_IDX_R::new(self.bits & 0x0f)
            }
        }
        impl W {
            ///Bits 0:3 - ADC input channel index
            #[inline(always)]
            #[must_use]
            pub fn ch_idx(&mut self) -> CH_IDX_W<CHANNEL_SPEC> {
                CH_IDX_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///ADC channel select
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`channel::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`channel::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct CHANNEL_SPEC;
        impl crate::RegisterSpec for CHANNEL_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`channel::R`](R) reader structure
        impl crate::Readable for CHANNEL_SPEC {}
        ///`write(|w| ..)` method takes [`channel::W`](W) writer structure
        impl crate::Writable for CHANNEL_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets CHANNEL to value 0x0f
        impl crate::Resettable for CHANNEL_SPEC {
            const RESET_VALUE: u8 = 0x0f;
        }
    }
    ///CFG (rw) register accessor: ADC configuration
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`cfg::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cfg::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    pub type CFG = crate::Reg<cfg::CFG_SPEC>;
    ///ADC configuration
    pub mod cfg {
        ///Register `CFG` reader
        pub type R = crate::R<CFG_SPEC>;
        ///Register `CFG` writer
        pub type W = crate::W<CFG_SPEC>;
        ///Field `POWER_ON` reader - ADC power on
        pub type POWER_ON_R = crate::BitReader;
        ///Field `POWER_ON` writer - ADC power on
        pub type POWER_ON_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `BUF_EN` reader - ADC input buffer enable
        pub type BUF_EN_R = crate::BitReader;
        ///Field `BUF_EN` writer - ADC input buffer enable
        pub type BUF_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `DIFF_EN` reader - ADC differential input mode, 0=single-end, 1=differnetial
        pub type DIFF_EN_R = crate::BitReader;
        ///Field `DIFF_EN` writer - ADC differential input mode, 0=single-end, 1=differnetial
        pub type DIFF_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `OFS_TEST` reader - enable ADC offset test mode, 0=normal mode, 1=short to test offset
        pub type OFS_TEST_R = crate::BitReader;
        ///Field `OFS_TEST` writer - enable ADC offset test mode, 0=normal mode, 1=short to test offset
        pub type OFS_TEST_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PGA_GAIN` reader - ADC PGA gain, 00=-12dB, 01=-6dB, 10=0dB, 11=6dB
        pub type PGA_GAIN_R = crate::FieldReader;
        ///Field `PGA_GAIN` writer - ADC PGA gain, 00=-12dB, 01=-6dB, 10=0dB, 11=6dB
        pub type PGA_GAIN_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        ///Field `CLK_DIV` reader - ADC clock divider, 00=3.2MHz, 01=2.67MHz, 10=5.33MHz, 11=4MHz
        pub type CLK_DIV_R = crate::FieldReader;
        ///Field `CLK_DIV` writer - ADC clock divider, 00=3.2MHz, 01=2.67MHz, 10=5.33MHz, 11=4MHz
        pub type CLK_DIV_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        impl R {
            ///Bit 0 - ADC power on
            #[inline(always)]
            pub fn power_on(&self) -> POWER_ON_R {
                POWER_ON_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - ADC input buffer enable
            #[inline(always)]
            pub fn buf_en(&self) -> BUF_EN_R {
                BUF_EN_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - ADC differential input mode, 0=single-end, 1=differnetial
            #[inline(always)]
            pub fn diff_en(&self) -> DIFF_EN_R {
                DIFF_EN_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - enable ADC offset test mode, 0=normal mode, 1=short to test offset
            #[inline(always)]
            pub fn ofs_test(&self) -> OFS_TEST_R {
                OFS_TEST_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bits 4:5 - ADC PGA gain, 00=-12dB, 01=-6dB, 10=0dB, 11=6dB
            #[inline(always)]
            pub fn pga_gain(&self) -> PGA_GAIN_R {
                PGA_GAIN_R::new((self.bits >> 4) & 3)
            }
            ///Bits 6:7 - ADC clock divider, 00=3.2MHz, 01=2.67MHz, 10=5.33MHz, 11=4MHz
            #[inline(always)]
            pub fn clk_div(&self) -> CLK_DIV_R {
                CLK_DIV_R::new((self.bits >> 6) & 3)
            }
        }
        impl W {
            ///Bit 0 - ADC power on
            #[inline(always)]
            #[must_use]
            pub fn power_on(&mut self) -> POWER_ON_W<CFG_SPEC> {
                POWER_ON_W::new(self, 0)
            }
            ///Bit 1 - ADC input buffer enable
            #[inline(always)]
            #[must_use]
            pub fn buf_en(&mut self) -> BUF_EN_W<CFG_SPEC> {
                BUF_EN_W::new(self, 1)
            }
            ///Bit 2 - ADC differential input mode, 0=single-end, 1=differnetial
            #[inline(always)]
            #[must_use]
            pub fn diff_en(&mut self) -> DIFF_EN_W<CFG_SPEC> {
                DIFF_EN_W::new(self, 2)
            }
            ///Bit 3 - enable ADC offset test mode, 0=normal mode, 1=short to test offset
            #[inline(always)]
            #[must_use]
            pub fn ofs_test(&mut self) -> OFS_TEST_W<CFG_SPEC> {
                OFS_TEST_W::new(self, 3)
            }
            ///Bits 4:5 - ADC PGA gain, 00=-12dB, 01=-6dB, 10=0dB, 11=6dB
            #[inline(always)]
            #[must_use]
            pub fn pga_gain(&mut self) -> PGA_GAIN_W<CFG_SPEC> {
                PGA_GAIN_W::new(self, 4)
            }
            ///Bits 6:7 - ADC clock divider, 00=3.2MHz, 01=2.67MHz, 10=5.33MHz, 11=4MHz
            #[inline(always)]
            #[must_use]
            pub fn clk_div(&mut self) -> CLK_DIV_W<CFG_SPEC> {
                CLK_DIV_W::new(self, 6)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///ADC configuration
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`cfg::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cfg::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct CFG_SPEC;
        impl crate::RegisterSpec for CFG_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`cfg::R`](R) reader structure
        impl crate::Readable for CFG_SPEC {}
        ///`write(|w| ..)` method takes [`cfg::W`](W) writer structure
        impl crate::Writable for CFG_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets CFG to value 0xa0
        impl crate::Resettable for CFG_SPEC {
            const RESET_VALUE: u8 = 0xa0;
        }
    }
    ///CONVERT (rw) register accessor: ADC conversion control
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`convert::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`convert::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@convert`]
    ///module
    pub type CONVERT = crate::Reg<convert::CONVERT_SPEC>;
    ///ADC conversion control
    pub mod convert {
        ///Register `CONVERT` reader
        pub type R = crate::R<CONVERT_SPEC>;
        ///Register `CONVERT` writer
        pub type W = crate::W<CONVERT_SPEC>;
        ///Field `START` reader - ADC conversion start
        pub type START_R = crate::BitReader;
        ///Field `START` writer - ADC conversion start
        pub type START_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `EOC` reader - ADC conversion end of conversion
        pub type EOC_R = crate::BitReader;
        ///Field `EOC` writer - ADC conversion end of conversion
        pub type EOC_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - ADC conversion start
            #[inline(always)]
            pub fn start(&self) -> START_R {
                START_R::new((self.bits & 1) != 0)
            }
            ///Bit 7 - ADC conversion end of conversion
            #[inline(always)]
            pub fn eoc(&self) -> EOC_R {
                EOC_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - ADC conversion start
            #[inline(always)]
            #[must_use]
            pub fn start(&mut self) -> START_W<CONVERT_SPEC> {
                START_W::new(self, 0)
            }
            ///Bit 7 - ADC conversion end of conversion
            #[inline(always)]
            #[must_use]
            pub fn eoc(&mut self) -> EOC_W<CONVERT_SPEC> {
                EOC_W::new(self, 7)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///ADC conversion control
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`convert::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`convert::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct CONVERT_SPEC;
        impl crate::RegisterSpec for CONVERT_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`convert::R`](R) reader structure
        impl crate::Readable for CONVERT_SPEC {}
        ///`write(|w| ..)` method takes [`convert::W`](W) writer structure
        impl crate::Writable for CONVERT_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets CONVERT to value 0
        impl crate::Resettable for CONVERT_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///TEM_SENSOR (rw) register accessor: ADC temperature sensor
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`tem_sensor::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`tem_sensor::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@tem_sensor`]
    ///module
    pub type TEM_SENSOR = crate::Reg<tem_sensor::TEM_SENSOR_SPEC>;
    ///ADC temperature sensor
    pub mod tem_sensor {
        ///Register `TEM_SENSOR` reader
        pub type R = crate::R<TEM_SENSOR_SPEC>;
        ///Register `TEM_SENSOR` writer
        pub type W = crate::W<TEM_SENSOR_SPEC>;
        ///Field `POWER_ON` reader - ADC temperature sensor enable
        pub type POWER_ON_R = crate::BitReader;
        ///Field `POWER_ON` writer - ADC temperature sensor enable
        pub type POWER_ON_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 7 - ADC temperature sensor enable
            #[inline(always)]
            pub fn power_on(&self) -> POWER_ON_R {
                POWER_ON_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 7 - ADC temperature sensor enable
            #[inline(always)]
            #[must_use]
            pub fn power_on(&mut self) -> POWER_ON_W<TEM_SENSOR_SPEC> {
                POWER_ON_W::new(self, 7)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///ADC temperature sensor
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`tem_sensor::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`tem_sensor::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct TEM_SENSOR_SPEC;
        impl crate::RegisterSpec for TEM_SENSOR_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`tem_sensor::R`](R) reader structure
        impl crate::Readable for TEM_SENSOR_SPEC {}
        ///`write(|w| ..)` method takes [`tem_sensor::W`](W) writer structure
        impl crate::Writable for TEM_SENSOR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets TEM_SENSOR to value 0
        impl crate::Resettable for TEM_SENSOR_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///DATA (r) register accessor: ADC conversion data
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`data::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@data`]
    ///module
    pub type DATA = crate::Reg<data::DATA_SPEC>;
    ///ADC conversion data
    pub mod data {
        ///Register `DATA` reader
        pub type R = crate::R<DATA_SPEC>;
        ///Field `DATA` reader - ADC conversion data, 12 bits
        pub type DATA_R = crate::FieldReader<u16>;
        impl R {
            ///Bits 0:11 - ADC conversion data, 12 bits
            #[inline(always)]
            pub fn data(&self) -> DATA_R {
                DATA_R::new(self.bits & 0x0fff)
            }
        }
        ///ADC conversion data
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`data::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct DATA_SPEC;
        impl crate::RegisterSpec for DATA_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`data::R`](R) reader structure
        impl crate::Readable for DATA_SPEC {}
        ///`reset()` method sets DATA to value 0
        impl crate::Resettable for DATA_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///INT_FLAG (rw) register accessor: ADC interrupt flag
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`int_flag::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`int_flag::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@int_flag`]
    ///module
    pub type INT_FLAG = crate::Reg<int_flag::INT_FLAG_SPEC>;
    ///ADC interrupt flag
    pub mod int_flag {
        ///Register `INT_FLAG` reader
        pub type R = crate::R<INT_FLAG_SPEC>;
        ///Register `INT_FLAG` writer
        pub type W = crate::W<INT_FLAG_SPEC>;
        ///Field `EOC` reader - ADC interrupt flag, end of conversion
        pub type EOC_R = crate::BitReader;
        ///Field `EOC` writer - ADC interrupt flag, end of conversion
        pub type EOC_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 7 - ADC interrupt flag, end of conversion
            #[inline(always)]
            pub fn eoc(&self) -> EOC_R {
                EOC_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 7 - ADC interrupt flag, end of conversion
            #[inline(always)]
            #[must_use]
            pub fn eoc(&mut self) -> EOC_W<INT_FLAG_SPEC> {
                EOC_W::new(self, 7)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///ADC interrupt flag
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`int_flag::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`int_flag::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct INT_FLAG_SPEC;
        impl crate::RegisterSpec for INT_FLAG_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`int_flag::R`](R) reader structure
        impl crate::Readable for INT_FLAG_SPEC {}
        ///`write(|w| ..)` method takes [`int_flag::W`](W) writer structure
        impl crate::Writable for INT_FLAG_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets INT_FLAG to value 0
        impl crate::Resettable for INT_FLAG_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///DMA_CTRL (rw) register accessor: ADC DMA control. Renamed from CTRL_DMA
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`dma_ctrl::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dma_ctrl::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@dma_ctrl`]
    ///module
    pub type DMA_CTRL = crate::Reg<dma_ctrl::DMA_CTRL_SPEC>;
    ///ADC DMA control. Renamed from CTRL_DMA
    pub mod dma_ctrl {
        ///Register `DMA_CTRL` reader
        pub type R = crate::R<DMA_CTRL_SPEC>;
        ///Register `DMA_CTRL` writer
        pub type W = crate::W<DMA_CTRL_SPEC>;
        ///Field `DMA_EN` reader - ADC DMA enable
        pub type DMA_EN_R = crate::BitReader;
        ///Field `DMA_EN` writer - ADC DMA enable
        pub type DMA_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `DMA_LOOP` reader - ADC DMA address loop enable
        pub type DMA_LOOP_R = crate::BitReader;
        ///Field `DMA_LOOP` writer - ADC DMA address loop enable
        pub type DMA_LOOP_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `DMA_END_IE` reader - ADC DMA end interrupt enable, renamed from IE_DMA_END
        pub type DMA_END_IE_R = crate::BitReader;
        ///Field `DMA_END_IE` writer - ADC DMA end interrupt enable, renamed from IE_DMA_END
        pub type DMA_END_IE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `EOC_IE` reader - ADC end of conversion interrupt enable, renamed from IE_EOC
        pub type EOC_IE_R = crate::BitReader;
        ///Field `EOC_IE` writer - ADC end of conversion interrupt enable, renamed from IE_EOC
        pub type EOC_IE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `COUNT_EN` reader - enable contineous conversion
        pub type COUNT_EN_R = crate::BitReader;
        ///Field `COUNT_EN` writer - enable contineous conversion
        pub type COUNT_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `AUTO_EN` reader - enable auto continuing ADC for DMA
        pub type AUTO_EN_R = crate::BitReader;
        ///Field `AUTO_EN` writer - enable auto continuing ADC for DMA
        pub type AUTO_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - ADC DMA enable
            #[inline(always)]
            pub fn dma_en(&self) -> DMA_EN_R {
                DMA_EN_R::new((self.bits & 1) != 0)
            }
            ///Bit 2 - ADC DMA address loop enable
            #[inline(always)]
            pub fn dma_loop(&self) -> DMA_LOOP_R {
                DMA_LOOP_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - ADC DMA end interrupt enable, renamed from IE_DMA_END
            #[inline(always)]
            pub fn dma_end_ie(&self) -> DMA_END_IE_R {
                DMA_END_IE_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - ADC end of conversion interrupt enable, renamed from IE_EOC
            #[inline(always)]
            pub fn eoc_ie(&self) -> EOC_IE_R {
                EOC_IE_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 6 - enable contineous conversion
            #[inline(always)]
            pub fn count_en(&self) -> COUNT_EN_R {
                COUNT_EN_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - enable auto continuing ADC for DMA
            #[inline(always)]
            pub fn auto_en(&self) -> AUTO_EN_R {
                AUTO_EN_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - ADC DMA enable
            #[inline(always)]
            #[must_use]
            pub fn dma_en(&mut self) -> DMA_EN_W<DMA_CTRL_SPEC> {
                DMA_EN_W::new(self, 0)
            }
            ///Bit 2 - ADC DMA address loop enable
            #[inline(always)]
            #[must_use]
            pub fn dma_loop(&mut self) -> DMA_LOOP_W<DMA_CTRL_SPEC> {
                DMA_LOOP_W::new(self, 2)
            }
            ///Bit 3 - ADC DMA end interrupt enable, renamed from IE_DMA_END
            #[inline(always)]
            #[must_use]
            pub fn dma_end_ie(&mut self) -> DMA_END_IE_W<DMA_CTRL_SPEC> {
                DMA_END_IE_W::new(self, 3)
            }
            ///Bit 4 - ADC end of conversion interrupt enable, renamed from IE_EOC
            #[inline(always)]
            #[must_use]
            pub fn eoc_ie(&mut self) -> EOC_IE_W<DMA_CTRL_SPEC> {
                EOC_IE_W::new(self, 4)
            }
            ///Bit 6 - enable contineous conversion
            #[inline(always)]
            #[must_use]
            pub fn count_en(&mut self) -> COUNT_EN_W<DMA_CTRL_SPEC> {
                COUNT_EN_W::new(self, 6)
            }
            ///Bit 7 - enable auto continuing ADC for DMA
            #[inline(always)]
            #[must_use]
            pub fn auto_en(&mut self) -> AUTO_EN_W<DMA_CTRL_SPEC> {
                AUTO_EN_W::new(self, 7)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///ADC DMA control. Renamed from CTRL_DMA
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`dma_ctrl::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dma_ctrl::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct DMA_CTRL_SPEC;
        impl crate::RegisterSpec for DMA_CTRL_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`dma_ctrl::R`](R) reader structure
        impl crate::Readable for DMA_CTRL_SPEC {}
        ///`write(|w| ..)` method takes [`dma_ctrl::W`](W) writer structure
        impl crate::Writable for DMA_CTRL_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets DMA_CTRL to value 0
        impl crate::Resettable for DMA_CTRL_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///DMA_IF (rw) register accessor: ADC DMA interrupt flag
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`dma_if::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dma_if::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@dma_if`]
    ///module
    pub type DMA_IF = crate::Reg<dma_if::DMA_IF_SPEC>;
    ///ADC DMA interrupt flag
    pub mod dma_if {
        ///Register `DMA_IF` reader
        pub type R = crate::R<DMA_IF_SPEC>;
        ///Register `DMA_IF` writer
        pub type W = crate::W<DMA_IF_SPEC>;
        ///Field `DMA_END` reader - ADC DMA end interrupt flag, renamed from IF_DMA_END
        pub type DMA_END_R = crate::BitReader;
        ///Field `DMA_END` writer - ADC DMA end interrupt flag, renamed from IF_DMA_END
        pub type DMA_END_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `EOC` reader - ADC end of conversion interrupt flag, renamed from IF_END_ADC
        pub type EOC_R = crate::BitReader;
        ///Field `EOC` writer - ADC end of conversion interrupt flag, renamed from IF_END_ADC
        pub type EOC_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 3 - ADC DMA end interrupt flag, renamed from IF_DMA_END
            #[inline(always)]
            pub fn dma_end(&self) -> DMA_END_R {
                DMA_END_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - ADC end of conversion interrupt flag, renamed from IF_END_ADC
            #[inline(always)]
            pub fn eoc(&self) -> EOC_R {
                EOC_R::new(((self.bits >> 4) & 1) != 0)
            }
        }
        impl W {
            ///Bit 3 - ADC DMA end interrupt flag, renamed from IF_DMA_END
            #[inline(always)]
            #[must_use]
            pub fn dma_end(&mut self) -> DMA_END_W<DMA_IF_SPEC> {
                DMA_END_W::new(self, 3)
            }
            ///Bit 4 - ADC end of conversion interrupt flag, renamed from IF_END_ADC
            #[inline(always)]
            #[must_use]
            pub fn eoc(&mut self) -> EOC_W<DMA_IF_SPEC> {
                EOC_W::new(self, 4)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///ADC DMA interrupt flag
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`dma_if::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dma_if::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct DMA_IF_SPEC;
        impl crate::RegisterSpec for DMA_IF_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`dma_if::R`](R) reader structure
        impl crate::Readable for DMA_IF_SPEC {}
        ///`write(|w| ..)` method takes [`dma_if::W`](W) writer structure
        impl crate::Writable for DMA_IF_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets DMA_IF to value 0
        impl crate::Resettable for DMA_IF_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///AUTO_CYCLE (rw) register accessor: ADC auto cycle for contineous conversion
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`auto_cycle::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`auto_cycle::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@auto_cycle`]
    ///module
    pub type AUTO_CYCLE = crate::Reg<auto_cycle::AUTO_CYCLE_SPEC>;
    ///ADC auto cycle for contineous conversion
    pub mod auto_cycle {
        ///Register `AUTO_CYCLE` reader
        pub type R = crate::R<AUTO_CYCLE_SPEC>;
        ///Register `AUTO_CYCLE` writer
        pub type W = crate::W<AUTO_CYCLE_SPEC>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<AUTO_CYCLE_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                core::fmt::Debug::fmt(&self.read(), f)
            }
        }
        impl W {
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///ADC auto cycle for contineous conversion
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`auto_cycle::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`auto_cycle::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct AUTO_CYCLE_SPEC;
        impl crate::RegisterSpec for AUTO_CYCLE_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`auto_cycle::R`](R) reader structure
        impl crate::Readable for AUTO_CYCLE_SPEC {}
        ///`write(|w| ..)` method takes [`auto_cycle::W`](W) writer structure
        impl crate::Writable for AUTO_CYCLE_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets AUTO_CYCLE to value 0
        impl crate::Resettable for AUTO_CYCLE_SPEC {
            const RESET_VALUE: u8 = 0;
        }
    }
    ///DMA_NOW (rw) register accessor: ADC DMA address, current
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`dma_now::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dma_now::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@dma_now`]
    ///module
    pub type DMA_NOW = crate::Reg<dma_now::DMA_NOW_SPEC>;
    ///ADC DMA address, current
    pub mod dma_now {
        ///Register `DMA_NOW` reader
        pub type R = crate::R<DMA_NOW_SPEC>;
        ///Register `DMA_NOW` writer
        pub type W = crate::W<DMA_NOW_SPEC>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<DMA_NOW_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                core::fmt::Debug::fmt(&self.read(), f)
            }
        }
        impl W {
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///ADC DMA address, current
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`dma_now::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dma_now::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct DMA_NOW_SPEC;
        impl crate::RegisterSpec for DMA_NOW_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`dma_now::R`](R) reader structure
        impl crate::Readable for DMA_NOW_SPEC {}
        ///`write(|w| ..)` method takes [`dma_now::W`](W) writer structure
        impl crate::Writable for DMA_NOW_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets DMA_NOW to value 0
        impl crate::Resettable for DMA_NOW_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///DMA_BEG (rw) register accessor: ADC DMA address, begin
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`dma_beg::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dma_beg::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@dma_beg`]
    ///module
    pub type DMA_BEG = crate::Reg<dma_beg::DMA_BEG_SPEC>;
    ///ADC DMA address, begin
    pub mod dma_beg {
        ///Register `DMA_BEG` reader
        pub type R = crate::R<DMA_BEG_SPEC>;
        ///Register `DMA_BEG` writer
        pub type W = crate::W<DMA_BEG_SPEC>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<DMA_BEG_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                core::fmt::Debug::fmt(&self.read(), f)
            }
        }
        impl W {
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///ADC DMA address, begin
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`dma_beg::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dma_beg::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct DMA_BEG_SPEC;
        impl crate::RegisterSpec for DMA_BEG_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`dma_beg::R`](R) reader structure
        impl crate::Readable for DMA_BEG_SPEC {}
        ///`write(|w| ..)` method takes [`dma_beg::W`](W) writer structure
        impl crate::Writable for DMA_BEG_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets DMA_BEG to value 0
        impl crate::Resettable for DMA_BEG_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///DMA_END (rw) register accessor: ADC DMA address, end
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`dma_end::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dma_end::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@dma_end`]
    ///module
    pub type DMA_END = crate::Reg<dma_end::DMA_END_SPEC>;
    ///ADC DMA address, end
    pub mod dma_end {
        ///Register `DMA_END` reader
        pub type R = crate::R<DMA_END_SPEC>;
        ///Register `DMA_END` writer
        pub type W = crate::W<DMA_END_SPEC>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<DMA_END_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                core::fmt::Debug::fmt(&self.read(), f)
            }
        }
        impl W {
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///ADC DMA address, end
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`dma_end::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dma_end::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct DMA_END_SPEC;
        impl crate::RegisterSpec for DMA_END_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`dma_end::R`](R) reader structure
        impl crate::Readable for DMA_END_SPEC {}
        ///`write(|w| ..)` method takes [`dma_end::W`](W) writer structure
        impl crate::Writable for DMA_END_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets DMA_END to value 0
        impl crate::Resettable for DMA_END_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
}
///GPIOCTL, split from GPIO
pub struct GPIOCTL {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for GPIOCTL {}
impl GPIOCTL {
    ///Pointer to the register block
    pub const PTR: *const gpioctl::RegisterBlock = 0x4000_1000 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const gpioctl::RegisterBlock {
        Self::PTR
    }
    /// Steal an instance of this peripheral
    ///
    /// # Safety
    ///
    /// Ensure that the new instance of the peripheral cannot be used in a way
    /// that may race with any existing instances, for example by only
    /// accessing read-only or write-only registers, or by consuming the
    /// original peripheral and using critical sections to coordinate
    /// access between multiple new instances.
    ///
    /// Additionally, other software such as HALs may rely on only one
    /// peripheral instance existing to ensure memory safety; ensure
    /// no stolen instances are passed to such software.
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for GPIOCTL {
    type Target = gpioctl::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for GPIOCTL {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GPIOCTL").finish()
    }
}
///GPIOCTL, split from GPIO
pub mod gpioctl {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        _reserved0: [u8; 0x18],
        pin_alternate: PIN_ALTERNATE,
        pin_analog_ie: PIN_ANALOG_IE,
        _reserved2: [u8; 0x74],
        pa_int_en: PA_INT_EN,
        pb_int_en: PB_INT_EN,
        pa_int_mode: PA_INT_MODE,
        pb_int_mode: PB_INT_MODE,
        _reserved6: [u8; 0x04],
        pa_int_if: PA_INT_IF,
        pb_int_if: PB_INT_IF,
    }
    impl RegisterBlock {
        ///0x18 - GPIO pin remap
        #[inline(always)]
        pub const fn pin_alternate(&self) -> &PIN_ALTERNATE {
            &self.pin_alternate
        }
        ///0x1a - GPIO pin analog, 1 disable digitial input. 0 enable digital input
        #[inline(always)]
        pub const fn pin_analog_ie(&self) -> &PIN_ANALOG_IE {
            &self.pin_analog_ie
        }
        ///0x90 - GPIO PA interrupt enable
        #[inline(always)]
        pub const fn pa_int_en(&self) -> &PA_INT_EN {
            &self.pa_int_en
        }
        ///0x92 - GPIO PB interrupt enable, \[9:8\]
        ///might be remapped to \[23:22\]
        #[inline(always)]
        pub const fn pb_int_en(&self) -> &PB_INT_EN {
            &self.pb_int_en
        }
        ///0x94 - GPIO PA interrupt mode
        #[inline(always)]
        pub const fn pa_int_mode(&self) -> &PA_INT_MODE {
            &self.pa_int_mode
        }
        ///0x96 - GPIO PB interrupt mode, \[9:8\]
        ///might be remapped to \[23:22\]
        #[inline(always)]
        pub const fn pb_int_mode(&self) -> &PB_INT_MODE {
            &self.pb_int_mode
        }
        ///0x9c - GPIO PA interrupt flag
        #[inline(always)]
        pub const fn pa_int_if(&self) -> &PA_INT_IF {
            &self.pa_int_if
        }
        ///0x9e - GPIO PB interrupt flag, \[9:8\]
        ///might be remapped to \[23:22\]
        #[inline(always)]
        pub const fn pb_int_if(&self) -> &PB_INT_IF {
            &self.pb_int_if
        }
    }
    ///PIN_ALTERNATE (rw) register accessor: GPIO pin remap
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`pin_alternate::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pin_alternate::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@pin_alternate`]
    ///module
    pub type PIN_ALTERNATE = crate::Reg<pin_alternate::PIN_ALTERNATE_SPEC>;
    ///GPIO pin remap
    pub mod pin_alternate {
        ///Register `PIN_ALTERNATE` reader
        pub type R = crate::R<PIN_ALTERNATE_SPEC>;
        ///Register `PIN_ALTERNATE` writer
        pub type W = crate::W<PIN_ALTERNATE_SPEC>;
        ///Field `TMR0` reader - TMR0 pin remap
        pub type TMR0_R = crate::BitReader;
        ///Field `TMR0` writer - TMR0 pin remap
        pub type TMR0_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TMR1` reader - TMR1 pin remap
        pub type TMR1_R = crate::BitReader;
        ///Field `TMR1` writer - TMR1 pin remap
        pub type TMR1_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TMR2` reader - TMR2 pin remap
        pub type TMR2_R = crate::BitReader;
        ///Field `TMR2` writer - TMR2 pin remap
        pub type TMR2_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TMR3` reader - TMR3 pin remap
        pub type TMR3_R = crate::BitReader;
        ///Field `TMR3` writer - TMR3 pin remap
        pub type TMR3_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UART0` reader - UART0 pin remap
        pub type UART0_R = crate::BitReader;
        ///Field `UART0` writer - UART0 pin remap
        pub type UART0_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UART1` reader - UART1 pin remap
        pub type UART1_R = crate::BitReader;
        ///Field `UART1` writer - UART1 pin remap
        pub type UART1_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UART2` reader - UART2 pin remap
        pub type UART2_R = crate::BitReader;
        ///Field `UART2` writer - UART2 pin remap
        pub type UART2_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UART3` reader - UART3 pin remap
        pub type UART3_R = crate::BitReader;
        ///Field `UART3` writer - UART3 pin remap
        pub type UART3_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `SPI0` reader - SPI0 pin remap
        pub type SPI0_R = crate::BitReader;
        ///Field `SPI0` writer - SPI0 pin remap
        pub type SPI0_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `PWMX` reader - PWMx pin remap
        pub type PWMX_R = crate::BitReader;
        ///Field `PWMX` writer - PWMx pin remap
        pub type PWMX_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `I2C` reader - I2C pin remap
        pub type I2C_R = crate::BitReader;
        ///Field `I2C` writer - I2C pin remap
        pub type I2C_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `MODEM` reader - UART0 MODEM pin remap, DSR/DTR remap from PB\[1\]/PB\[5\]
        ///to PB\[14\]/PB\[15\]
        pub type MODEM_R = crate::BitReader;
        ///Field `MODEM` writer - UART0 MODEM pin remap, DSR/DTR remap from PB\[1\]/PB\[5\]
        ///to PB\[14\]/PB\[15\]
        pub type MODEM_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `INTX` reader - Remap INT from PB\[8\]/PB\[9\]
        ///to PB\[22\]/PB\[23\]
        pub type INTX_R = crate::BitReader;
        ///Field `INTX` writer - Remap INT from PB\[8\]/PB\[9\]
        ///to PB\[22\]/PB\[23\]
        pub type INTX_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `UART0_INV` reader - UART0 RX/TX pin inversion
        pub type UART0_INV_R = crate::BitReader;
        ///Field `UART0_INV` writer - UART0 RX/TX pin inversion
        pub type UART0_INV_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `RF_ANT_SW_EN` reader - RF antenna switch enable
        pub type RF_ANT_SW_EN_R = crate::BitReader;
        ///Field `RF_ANT_SW_EN` writer - RF antenna switch enable
        pub type RF_ANT_SW_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - TMR0 pin remap
            #[inline(always)]
            pub fn tmr0(&self) -> TMR0_R {
                TMR0_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - TMR1 pin remap
            #[inline(always)]
            pub fn tmr1(&self) -> TMR1_R {
                TMR1_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - TMR2 pin remap
            #[inline(always)]
            pub fn tmr2(&self) -> TMR2_R {
                TMR2_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - TMR3 pin remap
            #[inline(always)]
            pub fn tmr3(&self) -> TMR3_R {
                TMR3_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - UART0 pin remap
            #[inline(always)]
            pub fn uart0(&self) -> UART0_R {
                UART0_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - UART1 pin remap
            #[inline(always)]
            pub fn uart1(&self) -> UART1_R {
                UART1_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - UART2 pin remap
            #[inline(always)]
            pub fn uart2(&self) -> UART2_R {
                UART2_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - UART3 pin remap
            #[inline(always)]
            pub fn uart3(&self) -> UART3_R {
                UART3_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bit 8 - SPI0 pin remap
            #[inline(always)]
            pub fn spi0(&self) -> SPI0_R {
                SPI0_R::new(((self.bits >> 8) & 1) != 0)
            }
            ///Bit 10 - PWMx pin remap
            #[inline(always)]
            pub fn pwmx(&self) -> PWMX_R {
                PWMX_R::new(((self.bits >> 10) & 1) != 0)
            }
            ///Bit 11 - I2C pin remap
            #[inline(always)]
            pub fn i2c(&self) -> I2C_R {
                I2C_R::new(((self.bits >> 11) & 1) != 0)
            }
            ///Bit 12 - UART0 MODEM pin remap, DSR/DTR remap from PB\[1\]/PB\[5\]
            ///to PB\[14\]/PB\[15\]
            #[inline(always)]
            pub fn modem(&self) -> MODEM_R {
                MODEM_R::new(((self.bits >> 12) & 1) != 0)
            }
            ///Bit 13 - Remap INT from PB\[8\]/PB\[9\]
            ///to PB\[22\]/PB\[23\]
            #[inline(always)]
            pub fn intx(&self) -> INTX_R {
                INTX_R::new(((self.bits >> 13) & 1) != 0)
            }
            ///Bit 14 - UART0 RX/TX pin inversion
            #[inline(always)]
            pub fn uart0_inv(&self) -> UART0_INV_R {
                UART0_INV_R::new(((self.bits >> 14) & 1) != 0)
            }
            ///Bit 15 - RF antenna switch enable
            #[inline(always)]
            pub fn rf_ant_sw_en(&self) -> RF_ANT_SW_EN_R {
                RF_ANT_SW_EN_R::new(((self.bits >> 15) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - TMR0 pin remap
            #[inline(always)]
            #[must_use]
            pub fn tmr0(&mut self) -> TMR0_W<PIN_ALTERNATE_SPEC> {
                TMR0_W::new(self, 0)
            }
            ///Bit 1 - TMR1 pin remap
            #[inline(always)]
            #[must_use]
            pub fn tmr1(&mut self) -> TMR1_W<PIN_ALTERNATE_SPEC> {
                TMR1_W::new(self, 1)
            }
            ///Bit 2 - TMR2 pin remap
            #[inline(always)]
            #[must_use]
            pub fn tmr2(&mut self) -> TMR2_W<PIN_ALTERNATE_SPEC> {
                TMR2_W::new(self, 2)
            }
            ///Bit 3 - TMR3 pin remap
            #[inline(always)]
            #[must_use]
            pub fn tmr3(&mut self) -> TMR3_W<PIN_ALTERNATE_SPEC> {
                TMR3_W::new(self, 3)
            }
            ///Bit 4 - UART0 pin remap
            #[inline(always)]
            #[must_use]
            pub fn uart0(&mut self) -> UART0_W<PIN_ALTERNATE_SPEC> {
                UART0_W::new(self, 4)
            }
            ///Bit 5 - UART1 pin remap
            #[inline(always)]
            #[must_use]
            pub fn uart1(&mut self) -> UART1_W<PIN_ALTERNATE_SPEC> {
                UART1_W::new(self, 5)
            }
            ///Bit 6 - UART2 pin remap
            #[inline(always)]
            #[must_use]
            pub fn uart2(&mut self) -> UART2_W<PIN_ALTERNATE_SPEC> {
                UART2_W::new(self, 6)
            }
            ///Bit 7 - UART3 pin remap
            #[inline(always)]
            #[must_use]
            pub fn uart3(&mut self) -> UART3_W<PIN_ALTERNATE_SPEC> {
                UART3_W::new(self, 7)
            }
            ///Bit 8 - SPI0 pin remap
            #[inline(always)]
            #[must_use]
            pub fn spi0(&mut self) -> SPI0_W<PIN_ALTERNATE_SPEC> {
                SPI0_W::new(self, 8)
            }
            ///Bit 10 - PWMx pin remap
            #[inline(always)]
            #[must_use]
            pub fn pwmx(&mut self) -> PWMX_W<PIN_ALTERNATE_SPEC> {
                PWMX_W::new(self, 10)
            }
            ///Bit 11 - I2C pin remap
            #[inline(always)]
            #[must_use]
            pub fn i2c(&mut self) -> I2C_W<PIN_ALTERNATE_SPEC> {
                I2C_W::new(self, 11)
            }
            ///Bit 12 - UART0 MODEM pin remap, DSR/DTR remap from PB\[1\]/PB\[5\]
            ///to PB\[14\]/PB\[15\]
            #[inline(always)]
            #[must_use]
            pub fn modem(&mut self) -> MODEM_W<PIN_ALTERNATE_SPEC> {
                MODEM_W::new(self, 12)
            }
            ///Bit 13 - Remap INT from PB\[8\]/PB\[9\]
            ///to PB\[22\]/PB\[23\]
            #[inline(always)]
            #[must_use]
            pub fn intx(&mut self) -> INTX_W<PIN_ALTERNATE_SPEC> {
                INTX_W::new(self, 13)
            }
            ///Bit 14 - UART0 RX/TX pin inversion
            #[inline(always)]
            #[must_use]
            pub fn uart0_inv(&mut self) -> UART0_INV_W<PIN_ALTERNATE_SPEC> {
                UART0_INV_W::new(self, 14)
            }
            ///Bit 15 - RF antenna switch enable
            #[inline(always)]
            #[must_use]
            pub fn rf_ant_sw_en(&mut self) -> RF_ANT_SW_EN_W<PIN_ALTERNATE_SPEC> {
                RF_ANT_SW_EN_W::new(self, 15)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///GPIO pin remap
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`pin_alternate::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pin_alternate::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct PIN_ALTERNATE_SPEC;
        impl crate::RegisterSpec for PIN_ALTERNATE_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`pin_alternate::R`](R) reader structure
        impl crate::Readable for PIN_ALTERNATE_SPEC {}
        ///`write(|w| ..)` method takes [`pin_alternate::W`](W) writer structure
        impl crate::Writable for PIN_ALTERNATE_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets PIN_ALTERNATE to value 0
        impl crate::Resettable for PIN_ALTERNATE_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///PIN_ANALOG_IE (rw) register accessor: GPIO pin analog, 1 disable digitial input. 0 enable digital input
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`pin_analog_ie::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pin_analog_ie::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@pin_analog_ie`]
    ///module
    pub type PIN_ANALOG_IE = crate::Reg<pin_analog_ie::PIN_ANALOG_IE_SPEC>;
    ///GPIO pin analog, 1 disable digitial input. 0 enable digital input
    pub mod pin_analog_ie {
        ///Register `PIN_ANALOG_IE` reader
        pub type R = crate::R<PIN_ANALOG_IE_SPEC>;
        ///Register `PIN_ANALOG_IE` writer
        pub type W = crate::W<PIN_ANALOG_IE_SPEC>;
        ///Field `ADC8_9_IE` reader - ADC8/9 input enable
        pub type ADC8_9_IE_R = crate::BitReader;
        ///Field `ADC8_9_IE` writer - ADC8/9 input enable
        pub type ADC8_9_IE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `ADC6_7_IE` reader - ADC6/7 input enable
        pub type ADC6_7_IE_R = crate::BitReader;
        ///Field `ADC6_7_IE` writer - ADC6/7 input enable
        pub type ADC6_7_IE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `ADC10_IE` reader - ADC10 input enable
        pub type ADC10_IE_R = crate::BitReader;
        ///Field `ADC10_IE` writer - ADC10 input enable
        pub type ADC10_IE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `ADC11_IE` reader - ADC11 input enable
        pub type ADC11_IE_R = crate::BitReader;
        ///Field `ADC11_IE` writer - ADC11 input enable
        pub type ADC11_IE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `USB2_DP_PU` reader - USB2_DP pull-up enable
        pub type USB2_DP_PU_R = crate::BitReader;
        ///Field `USB2_DP_PU` writer - USB2_DP pull-up enable
        pub type USB2_DP_PU_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `USB2_IE` reader - USB2 enable, PB12, PB13
        pub type USB2_IE_R = crate::BitReader;
        ///Field `USB2_IE` writer - USB2 enable, PB12, PB13
        pub type USB2_IE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `USB_DP_PU` reader - USB_DP pull-up enable
        pub type USB_DP_PU_R = crate::BitReader;
        ///Field `USB_DP_PU` writer - USB_DP pull-up enable
        pub type USB_DP_PU_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `USB_IE` reader - USB enable, PB10, PB11
        pub type USB_IE_R = crate::BitReader;
        ///Field `USB_IE` writer - USB enable, PB10, PB11
        pub type USB_IE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `ADC0_IE` reader - ADC0 input enable
        pub type ADC0_IE_R = crate::BitReader;
        ///Field `ADC0_IE` writer - ADC0 input enable
        pub type ADC0_IE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `ADC1_IE` reader - ADC1 input enable
        pub type ADC1_IE_R = crate::BitReader;
        ///Field `ADC1_IE` writer - ADC1 input enable
        pub type ADC1_IE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `ADC12_IE` reader - ADC12 input enable
        pub type ADC12_IE_R = crate::BitReader;
        ///Field `ADC12_IE` writer - ADC12 input enable
        pub type ADC12_IE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `ADC13_IE` reader - ADC13 input enable
        pub type ADC13_IE_R = crate::BitReader;
        ///Field `ADC13_IE` writer - ADC13 input enable
        pub type ADC13_IE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `XT32K_IE` reader - XT32K LSE input enable
        pub type XT32K_IE_R = crate::BitReader;
        ///Field `XT32K_IE` writer - XT32K LSE input enable
        pub type XT32K_IE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `ADC2_3_IE` reader - ADC2/3 input enable
        pub type ADC2_3_IE_R = crate::BitReader;
        ///Field `ADC2_3_IE` writer - ADC2/3 input enable
        pub type ADC2_3_IE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `ADC4_5_IE` reader - ADC4/5 input enable
        pub type ADC4_5_IE_R = crate::BitReader;
        ///Field `ADC4_5_IE` writer - ADC4/5 input enable
        pub type ADC4_5_IE_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - ADC8/9 input enable
            #[inline(always)]
            pub fn adc8_9_ie(&self) -> ADC8_9_IE_R {
                ADC8_9_IE_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - ADC6/7 input enable
            #[inline(always)]
            pub fn adc6_7_ie(&self) -> ADC6_7_IE_R {
                ADC6_7_IE_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - ADC10 input enable
            #[inline(always)]
            pub fn adc10_ie(&self) -> ADC10_IE_R {
                ADC10_IE_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - ADC11 input enable
            #[inline(always)]
            pub fn adc11_ie(&self) -> ADC11_IE_R {
                ADC11_IE_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - USB2_DP pull-up enable
            #[inline(always)]
            pub fn usb2_dp_pu(&self) -> USB2_DP_PU_R {
                USB2_DP_PU_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - USB2 enable, PB12, PB13
            #[inline(always)]
            pub fn usb2_ie(&self) -> USB2_IE_R {
                USB2_IE_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - USB_DP pull-up enable
            #[inline(always)]
            pub fn usb_dp_pu(&self) -> USB_DP_PU_R {
                USB_DP_PU_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - USB enable, PB10, PB11
            #[inline(always)]
            pub fn usb_ie(&self) -> USB_IE_R {
                USB_IE_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bit 9 - ADC0 input enable
            #[inline(always)]
            pub fn adc0_ie(&self) -> ADC0_IE_R {
                ADC0_IE_R::new(((self.bits >> 9) & 1) != 0)
            }
            ///Bit 10 - ADC1 input enable
            #[inline(always)]
            pub fn adc1_ie(&self) -> ADC1_IE_R {
                ADC1_IE_R::new(((self.bits >> 10) & 1) != 0)
            }
            ///Bit 11 - ADC12 input enable
            #[inline(always)]
            pub fn adc12_ie(&self) -> ADC12_IE_R {
                ADC12_IE_R::new(((self.bits >> 11) & 1) != 0)
            }
            ///Bit 12 - ADC13 input enable
            #[inline(always)]
            pub fn adc13_ie(&self) -> ADC13_IE_R {
                ADC13_IE_R::new(((self.bits >> 12) & 1) != 0)
            }
            ///Bit 13 - XT32K LSE input enable
            #[inline(always)]
            pub fn xt32k_ie(&self) -> XT32K_IE_R {
                XT32K_IE_R::new(((self.bits >> 13) & 1) != 0)
            }
            ///Bit 14 - ADC2/3 input enable
            #[inline(always)]
            pub fn adc2_3_ie(&self) -> ADC2_3_IE_R {
                ADC2_3_IE_R::new(((self.bits >> 14) & 1) != 0)
            }
            ///Bit 15 - ADC4/5 input enable
            #[inline(always)]
            pub fn adc4_5_ie(&self) -> ADC4_5_IE_R {
                ADC4_5_IE_R::new(((self.bits >> 15) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - ADC8/9 input enable
            #[inline(always)]
            #[must_use]
            pub fn adc8_9_ie(&mut self) -> ADC8_9_IE_W<PIN_ANALOG_IE_SPEC> {
                ADC8_9_IE_W::new(self, 0)
            }
            ///Bit 1 - ADC6/7 input enable
            #[inline(always)]
            #[must_use]
            pub fn adc6_7_ie(&mut self) -> ADC6_7_IE_W<PIN_ANALOG_IE_SPEC> {
                ADC6_7_IE_W::new(self, 1)
            }
            ///Bit 2 - ADC10 input enable
            #[inline(always)]
            #[must_use]
            pub fn adc10_ie(&mut self) -> ADC10_IE_W<PIN_ANALOG_IE_SPEC> {
                ADC10_IE_W::new(self, 2)
            }
            ///Bit 3 - ADC11 input enable
            #[inline(always)]
            #[must_use]
            pub fn adc11_ie(&mut self) -> ADC11_IE_W<PIN_ANALOG_IE_SPEC> {
                ADC11_IE_W::new(self, 3)
            }
            ///Bit 4 - USB2_DP pull-up enable
            #[inline(always)]
            #[must_use]
            pub fn usb2_dp_pu(&mut self) -> USB2_DP_PU_W<PIN_ANALOG_IE_SPEC> {
                USB2_DP_PU_W::new(self, 4)
            }
            ///Bit 5 - USB2 enable, PB12, PB13
            #[inline(always)]
            #[must_use]
            pub fn usb2_ie(&mut self) -> USB2_IE_W<PIN_ANALOG_IE_SPEC> {
                USB2_IE_W::new(self, 5)
            }
            ///Bit 6 - USB_DP pull-up enable
            #[inline(always)]
            #[must_use]
            pub fn usb_dp_pu(&mut self) -> USB_DP_PU_W<PIN_ANALOG_IE_SPEC> {
                USB_DP_PU_W::new(self, 6)
            }
            ///Bit 7 - USB enable, PB10, PB11
            #[inline(always)]
            #[must_use]
            pub fn usb_ie(&mut self) -> USB_IE_W<PIN_ANALOG_IE_SPEC> {
                USB_IE_W::new(self, 7)
            }
            ///Bit 9 - ADC0 input enable
            #[inline(always)]
            #[must_use]
            pub fn adc0_ie(&mut self) -> ADC0_IE_W<PIN_ANALOG_IE_SPEC> {
                ADC0_IE_W::new(self, 9)
            }
            ///Bit 10 - ADC1 input enable
            #[inline(always)]
            #[must_use]
            pub fn adc1_ie(&mut self) -> ADC1_IE_W<PIN_ANALOG_IE_SPEC> {
                ADC1_IE_W::new(self, 10)
            }
            ///Bit 11 - ADC12 input enable
            #[inline(always)]
            #[must_use]
            pub fn adc12_ie(&mut self) -> ADC12_IE_W<PIN_ANALOG_IE_SPEC> {
                ADC12_IE_W::new(self, 11)
            }
            ///Bit 12 - ADC13 input enable
            #[inline(always)]
            #[must_use]
            pub fn adc13_ie(&mut self) -> ADC13_IE_W<PIN_ANALOG_IE_SPEC> {
                ADC13_IE_W::new(self, 12)
            }
            ///Bit 13 - XT32K LSE input enable
            #[inline(always)]
            #[must_use]
            pub fn xt32k_ie(&mut self) -> XT32K_IE_W<PIN_ANALOG_IE_SPEC> {
                XT32K_IE_W::new(self, 13)
            }
            ///Bit 14 - ADC2/3 input enable
            #[inline(always)]
            #[must_use]
            pub fn adc2_3_ie(&mut self) -> ADC2_3_IE_W<PIN_ANALOG_IE_SPEC> {
                ADC2_3_IE_W::new(self, 14)
            }
            ///Bit 15 - ADC4/5 input enable
            #[inline(always)]
            #[must_use]
            pub fn adc4_5_ie(&mut self) -> ADC4_5_IE_W<PIN_ANALOG_IE_SPEC> {
                ADC4_5_IE_W::new(self, 15)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///GPIO pin analog, 1 disable digitial input. 0 enable digital input
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`pin_analog_ie::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pin_analog_ie::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct PIN_ANALOG_IE_SPEC;
        impl crate::RegisterSpec for PIN_ANALOG_IE_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`pin_analog_ie::R`](R) reader structure
        impl crate::Readable for PIN_ANALOG_IE_SPEC {}
        ///`write(|w| ..)` method takes [`pin_analog_ie::W`](W) writer structure
        impl crate::Writable for PIN_ANALOG_IE_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets PIN_ANALOG_IE to value 0
        impl crate::Resettable for PIN_ANALOG_IE_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///PA_INT_EN (rw) register accessor: GPIO PA interrupt enable
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`pa_int_en::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pa_int_en::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@pa_int_en`]
    ///module
    pub type PA_INT_EN = crate::Reg<pa_int_en::PA_INT_EN_SPEC>;
    ///GPIO PA interrupt enable
    pub mod pa_int_en {
        ///Register `PA_INT_EN` reader
        pub type R = crate::R<PA_INT_EN_SPEC>;
        ///Register `PA_INT_EN` writer
        pub type W = crate::W<PA_INT_EN_SPEC>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<PA_INT_EN_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                core::fmt::Debug::fmt(&self.read(), f)
            }
        }
        impl W {
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///GPIO PA interrupt enable
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`pa_int_en::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pa_int_en::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct PA_INT_EN_SPEC;
        impl crate::RegisterSpec for PA_INT_EN_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`pa_int_en::R`](R) reader structure
        impl crate::Readable for PA_INT_EN_SPEC {}
        ///`write(|w| ..)` method takes [`pa_int_en::W`](W) writer structure
        impl crate::Writable for PA_INT_EN_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets PA_INT_EN to value 0
        impl crate::Resettable for PA_INT_EN_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///PB_INT_EN (rw) register accessor: GPIO PB interrupt enable, \[9:8\]
    ///might be remapped to \[23:22\]
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`pb_int_en::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pb_int_en::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@pb_int_en`]
    ///module
    pub type PB_INT_EN = crate::Reg<pb_int_en::PB_INT_EN_SPEC>;
    ///GPIO PB interrupt enable, \[9:8\]
    ///might be remapped to \[23:22\]
    pub mod pb_int_en {
        ///Register `PB_INT_EN` reader
        pub type R = crate::R<PB_INT_EN_SPEC>;
        ///Register `PB_INT_EN` writer
        pub type W = crate::W<PB_INT_EN_SPEC>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<PB_INT_EN_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                core::fmt::Debug::fmt(&self.read(), f)
            }
        }
        impl W {
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///GPIO PB interrupt enable, \[9:8\]
        ///might be remapped to \[23:22\]
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`pb_int_en::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pb_int_en::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct PB_INT_EN_SPEC;
        impl crate::RegisterSpec for PB_INT_EN_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`pb_int_en::R`](R) reader structure
        impl crate::Readable for PB_INT_EN_SPEC {}
        ///`write(|w| ..)` method takes [`pb_int_en::W`](W) writer structure
        impl crate::Writable for PB_INT_EN_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets PB_INT_EN to value 0
        impl crate::Resettable for PB_INT_EN_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///PA_INT_MODE (rw) register accessor: GPIO PA interrupt mode
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`pa_int_mode::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pa_int_mode::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@pa_int_mode`]
    ///module
    pub type PA_INT_MODE = crate::Reg<pa_int_mode::PA_INT_MODE_SPEC>;
    ///GPIO PA interrupt mode
    pub mod pa_int_mode {
        ///Register `PA_INT_MODE` reader
        pub type R = crate::R<PA_INT_MODE_SPEC>;
        ///Register `PA_INT_MODE` writer
        pub type W = crate::W<PA_INT_MODE_SPEC>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<PA_INT_MODE_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                core::fmt::Debug::fmt(&self.read(), f)
            }
        }
        impl W {
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///GPIO PA interrupt mode
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`pa_int_mode::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pa_int_mode::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct PA_INT_MODE_SPEC;
        impl crate::RegisterSpec for PA_INT_MODE_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`pa_int_mode::R`](R) reader structure
        impl crate::Readable for PA_INT_MODE_SPEC {}
        ///`write(|w| ..)` method takes [`pa_int_mode::W`](W) writer structure
        impl crate::Writable for PA_INT_MODE_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets PA_INT_MODE to value 0
        impl crate::Resettable for PA_INT_MODE_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///PB_INT_MODE (rw) register accessor: GPIO PB interrupt mode, \[9:8\]
    ///might be remapped to \[23:22\]
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`pb_int_mode::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pb_int_mode::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@pb_int_mode`]
    ///module
    pub type PB_INT_MODE = crate::Reg<pb_int_mode::PB_INT_MODE_SPEC>;
    ///GPIO PB interrupt mode, \[9:8\]
    ///might be remapped to \[23:22\]
    pub mod pb_int_mode {
        ///Register `PB_INT_MODE` reader
        pub type R = crate::R<PB_INT_MODE_SPEC>;
        ///Register `PB_INT_MODE` writer
        pub type W = crate::W<PB_INT_MODE_SPEC>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<PB_INT_MODE_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                core::fmt::Debug::fmt(&self.read(), f)
            }
        }
        impl W {
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///GPIO PB interrupt mode, \[9:8\]
        ///might be remapped to \[23:22\]
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`pb_int_mode::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pb_int_mode::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct PB_INT_MODE_SPEC;
        impl crate::RegisterSpec for PB_INT_MODE_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`pb_int_mode::R`](R) reader structure
        impl crate::Readable for PB_INT_MODE_SPEC {}
        ///`write(|w| ..)` method takes [`pb_int_mode::W`](W) writer structure
        impl crate::Writable for PB_INT_MODE_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets PB_INT_MODE to value 0
        impl crate::Resettable for PB_INT_MODE_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///PA_INT_IF (rw) register accessor: GPIO PA interrupt flag
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`pa_int_if::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pa_int_if::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@pa_int_if`]
    ///module
    pub type PA_INT_IF = crate::Reg<pa_int_if::PA_INT_IF_SPEC>;
    ///GPIO PA interrupt flag
    pub mod pa_int_if {
        ///Register `PA_INT_IF` reader
        pub type R = crate::R<PA_INT_IF_SPEC>;
        ///Register `PA_INT_IF` writer
        pub type W = crate::W<PA_INT_IF_SPEC>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<PA_INT_IF_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                core::fmt::Debug::fmt(&self.read(), f)
            }
        }
        impl W {
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///GPIO PA interrupt flag
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`pa_int_if::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pa_int_if::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct PA_INT_IF_SPEC;
        impl crate::RegisterSpec for PA_INT_IF_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`pa_int_if::R`](R) reader structure
        impl crate::Readable for PA_INT_IF_SPEC {}
        ///`write(|w| ..)` method takes [`pa_int_if::W`](W) writer structure
        impl crate::Writable for PA_INT_IF_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets PA_INT_IF to value 0
        impl crate::Resettable for PA_INT_IF_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///PB_INT_IF (rw) register accessor: GPIO PB interrupt flag, \[9:8\]
    ///might be remapped to \[23:22\]
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`pb_int_if::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pb_int_if::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@pb_int_if`]
    ///module
    pub type PB_INT_IF = crate::Reg<pb_int_if::PB_INT_IF_SPEC>;
    ///GPIO PB interrupt flag, \[9:8\]
    ///might be remapped to \[23:22\]
    pub mod pb_int_if {
        ///Register `PB_INT_IF` reader
        pub type R = crate::R<PB_INT_IF_SPEC>;
        ///Register `PB_INT_IF` writer
        pub type W = crate::W<PB_INT_IF_SPEC>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<PB_INT_IF_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                core::fmt::Debug::fmt(&self.read(), f)
            }
        }
        impl W {
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///GPIO PB interrupt flag, \[9:8\]
        ///might be remapped to \[23:22\]
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`pb_int_if::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pb_int_if::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct PB_INT_IF_SPEC;
        impl crate::RegisterSpec for PB_INT_IF_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`pb_int_if::R`](R) reader structure
        impl crate::Readable for PB_INT_IF_SPEC {}
        ///`write(|w| ..)` method takes [`pb_int_if::W`](W) writer structure
        impl crate::Writable for PB_INT_IF_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets PB_INT_IF to value 0
        impl crate::Resettable for PB_INT_IF_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
}
///GPIO, split from SYS
pub struct GPIOA {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for GPIOA {}
impl GPIOA {
    ///Pointer to the register block
    pub const PTR: *const gpioa::RegisterBlock = 0x4000_10a0 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const gpioa::RegisterBlock {
        Self::PTR
    }
    /// Steal an instance of this peripheral
    ///
    /// # Safety
    ///
    /// Ensure that the new instance of the peripheral cannot be used in a way
    /// that may race with any existing instances, for example by only
    /// accessing read-only or write-only registers, or by consuming the
    /// original peripheral and using critical sections to coordinate
    /// access between multiple new instances.
    ///
    /// Additionally, other software such as HALs may rely on only one
    /// peripheral instance existing to ensure memory safety; ensure
    /// no stolen instances are passed to such software.
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for GPIOA {
    type Target = gpioa::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for GPIOA {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GPIOA").finish()
    }
}
///GPIO, split from SYS
pub mod gpioa {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        dir: DIR,
        pin: PIN,
        out: OUT,
        clr: CLR,
        pu: PU,
        pd_drv: PD_DRV,
    }
    impl RegisterBlock {
        ///0x00 - GPIO PA I/O direction
        #[inline(always)]
        pub const fn dir(&self) -> &DIR {
            &self.dir
        }
        ///0x04 - GPIO PA input data
        #[inline(always)]
        pub const fn pin(&self) -> &PIN {
            &self.pin
        }
        ///0x08 - GPIO PA output data
        #[inline(always)]
        pub const fn out(&self) -> &OUT {
            &self.out
        }
        ///0x0c - GPIO PA output clear
        #[inline(always)]
        pub const fn clr(&self) -> &CLR {
            &self.clr
        }
        ///0x10 - GPIO PA pull-up enable
        #[inline(always)]
        pub const fn pu(&self) -> &PU {
            &self.pu
        }
        ///0x14 - GPIO PA pull-down enable or drive strength select
        #[inline(always)]
        pub const fn pd_drv(&self) -> &PD_DRV {
            &self.pd_drv
        }
    }
    ///DIR (rw) register accessor: GPIO PA I/O direction
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`dir::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dir::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@dir`]
    ///module
    pub type DIR = crate::Reg<dir::DIR_SPEC>;
    ///GPIO PA I/O direction
    pub mod dir {
        ///Register `DIR` reader
        pub type R = crate::R<DIR_SPEC>;
        ///Register `DIR` writer
        pub type W = crate::W<DIR_SPEC>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<DIR_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                core::fmt::Debug::fmt(&self.read(), f)
            }
        }
        impl W {
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///GPIO PA I/O direction
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`dir::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dir::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct DIR_SPEC;
        impl crate::RegisterSpec for DIR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`dir::R`](R) reader structure
        impl crate::Readable for DIR_SPEC {}
        ///`write(|w| ..)` method takes [`dir::W`](W) writer structure
        impl crate::Writable for DIR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets DIR to value 0
        impl crate::Resettable for DIR_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///PIN (rw) register accessor: GPIO PA input data
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`pin::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pin::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@pin`]
    ///module
    pub type PIN = crate::Reg<pin::PIN_SPEC>;
    ///GPIO PA input data
    pub mod pin {
        ///Register `PIN` reader
        pub type R = crate::R<PIN_SPEC>;
        ///Register `PIN` writer
        pub type W = crate::W<PIN_SPEC>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<PIN_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                core::fmt::Debug::fmt(&self.read(), f)
            }
        }
        impl W {
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///GPIO PA input data
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`pin::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pin::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct PIN_SPEC;
        impl crate::RegisterSpec for PIN_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`pin::R`](R) reader structure
        impl crate::Readable for PIN_SPEC {}
        ///`write(|w| ..)` method takes [`pin::W`](W) writer structure
        impl crate::Writable for PIN_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets PIN to value 0
        impl crate::Resettable for PIN_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///OUT (rw) register accessor: GPIO PA output data
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`out::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`out::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@out`]
    ///module
    pub type OUT = crate::Reg<out::OUT_SPEC>;
    ///GPIO PA output data
    pub mod out {
        ///Register `OUT` reader
        pub type R = crate::R<OUT_SPEC>;
        ///Register `OUT` writer
        pub type W = crate::W<OUT_SPEC>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<OUT_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                core::fmt::Debug::fmt(&self.read(), f)
            }
        }
        impl W {
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///GPIO PA output data
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`out::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`out::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct OUT_SPEC;
        impl crate::RegisterSpec for OUT_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`out::R`](R) reader structure
        impl crate::Readable for OUT_SPEC {}
        ///`write(|w| ..)` method takes [`out::W`](W) writer structure
        impl crate::Writable for OUT_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets OUT to value 0
        impl crate::Resettable for OUT_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///CLR (rw) register accessor: GPIO PA output clear
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`clr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`clr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@clr`]
    ///module
    pub type CLR = crate::Reg<clr::CLR_SPEC>;
    ///GPIO PA output clear
    pub mod clr {
        ///Register `CLR` reader
        pub type R = crate::R<CLR_SPEC>;
        ///Register `CLR` writer
        pub type W = crate::W<CLR_SPEC>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<CLR_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                core::fmt::Debug::fmt(&self.read(), f)
            }
        }
        impl W {
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///GPIO PA output clear
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`clr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`clr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct CLR_SPEC;
        impl crate::RegisterSpec for CLR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`clr::R`](R) reader structure
        impl crate::Readable for CLR_SPEC {}
        ///`write(|w| ..)` method takes [`clr::W`](W) writer structure
        impl crate::Writable for CLR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets CLR to value 0
        impl crate::Resettable for CLR_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///PU (rw) register accessor: GPIO PA pull-up enable
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`pu::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pu::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@pu`]
    ///module
    pub type PU = crate::Reg<pu::PU_SPEC>;
    ///GPIO PA pull-up enable
    pub mod pu {
        ///Register `PU` reader
        pub type R = crate::R<PU_SPEC>;
        ///Register `PU` writer
        pub type W = crate::W<PU_SPEC>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<PU_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                core::fmt::Debug::fmt(&self.read(), f)
            }
        }
        impl W {
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///GPIO PA pull-up enable
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`pu::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pu::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct PU_SPEC;
        impl crate::RegisterSpec for PU_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`pu::R`](R) reader structure
        impl crate::Readable for PU_SPEC {}
        ///`write(|w| ..)` method takes [`pu::W`](W) writer structure
        impl crate::Writable for PU_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets PU to value 0
        impl crate::Resettable for PU_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///PD_DRV (rw) register accessor: GPIO PA pull-down enable or drive strength select
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`pd_drv::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pd_drv::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@pd_drv`]
    ///module
    pub type PD_DRV = crate::Reg<pd_drv::PD_DRV_SPEC>;
    ///GPIO PA pull-down enable or drive strength select
    pub mod pd_drv {
        ///Register `PD_DRV` reader
        pub type R = crate::R<PD_DRV_SPEC>;
        ///Register `PD_DRV` writer
        pub type W = crate::W<PD_DRV_SPEC>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<PD_DRV_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                core::fmt::Debug::fmt(&self.read(), f)
            }
        }
        impl W {
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///GPIO PA pull-down enable or drive strength select
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`pd_drv::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pd_drv::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct PD_DRV_SPEC;
        impl crate::RegisterSpec for PD_DRV_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`pd_drv::R`](R) reader structure
        impl crate::Readable for PD_DRV_SPEC {}
        ///`write(|w| ..)` method takes [`pd_drv::W`](W) writer structure
        impl crate::Writable for PD_DRV_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets PD_DRV to value 0
        impl crate::Resettable for PD_DRV_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
}
///GPIO, split from SYS
pub struct GPIOB {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for GPIOB {}
impl GPIOB {
    ///Pointer to the register block
    pub const PTR: *const gpioa::RegisterBlock = 0x4000_10c0 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const gpioa::RegisterBlock {
        Self::PTR
    }
    /// Steal an instance of this peripheral
    ///
    /// # Safety
    ///
    /// Ensure that the new instance of the peripheral cannot be used in a way
    /// that may race with any existing instances, for example by only
    /// accessing read-only or write-only registers, or by consuming the
    /// original peripheral and using critical sections to coordinate
    /// access between multiple new instances.
    ///
    /// Additionally, other software such as HALs may rely on only one
    /// peripheral instance existing to ensure memory safety; ensure
    /// no stolen instances are passed to such software.
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for GPIOB {
    type Target = gpioa::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for GPIOB {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GPIOB").finish()
    }
}
///GPIO, split from SYS
pub use self::gpioa as gpiob;
///RTC, split from SYS
pub struct RTC {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for RTC {}
impl RTC {
    ///Pointer to the register block
    pub const PTR: *const rtc::RegisterBlock = 0x4000_1000 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const rtc::RegisterBlock {
        Self::PTR
    }
    /// Steal an instance of this peripheral
    ///
    /// # Safety
    ///
    /// Ensure that the new instance of the peripheral cannot be used in a way
    /// that may race with any existing instances, for example by only
    /// accessing read-only or write-only registers, or by consuming the
    /// original peripheral and using critical sections to coordinate
    /// access between multiple new instances.
    ///
    /// Additionally, other software such as HALs may rely on only one
    /// peripheral instance existing to ensure memory safety; ensure
    /// no stolen instances are passed to such software.
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for RTC {
    type Target = rtc::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for RTC {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("RTC").finish()
    }
}
///RTC, split from SYS
pub mod rtc {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        _reserved0: [u8; 0x30],
        flag_ctrl: FLAG_CTRL,
        mode_ctrl: MODE_CTRL,
        _reserved2: [u8; 0x02],
        trig: TRIG,
        cnt_32k: CNT_32K,
        cnt_2s: CNT_2S,
        cnt_day: CNT_DAY,
    }
    impl RegisterBlock {
        ///0x30 - RTC flag and clear control
        #[inline(always)]
        pub const fn flag_ctrl(&self) -> &FLAG_CTRL {
            &self.flag_ctrl
        }
        ///0x31 - RTC mode control
        #[inline(always)]
        pub const fn mode_ctrl(&self) -> &MODE_CTRL {
            &self.mode_ctrl
        }
        ///0x34 - RTC trigger control
        #[inline(always)]
        pub const fn trig(&self) -> &TRIG {
            &self.trig
        }
        ///0x38 - RTC 32K-based counter
        #[inline(always)]
        pub const fn cnt_32k(&self) -> &CNT_32K {
            &self.cnt_32k
        }
        ///0x3a - RTC 2-second-based counter
        #[inline(always)]
        pub const fn cnt_2s(&self) -> &CNT_2S {
            &self.cnt_2s
        }
        ///0x3c - RTC day-based counter
        #[inline(always)]
        pub const fn cnt_day(&self) -> &CNT_DAY {
            &self.cnt_day
        }
    }
    ///FLAG_CTRL (rw) register accessor: RTC flag and clear control
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`flag_ctrl::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`flag_ctrl::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@flag_ctrl`]
    ///module
    pub type FLAG_CTRL = crate::Reg<flag_ctrl::FLAG_CTRL_SPEC>;
    ///RTC flag and clear control
    pub mod flag_ctrl {
        ///Register `FLAG_CTRL` reader
        pub type R = crate::R<FLAG_CTRL_SPEC>;
        ///Register `FLAG_CTRL` writer
        pub type W = crate::W<FLAG_CTRL_SPEC>;
        ///Field `TMR_CLR` reader - RTC timer flag clear
        pub type TMR_CLR_R = crate::BitReader;
        ///Field `TMR_CLR` writer - RTC timer flag clear
        pub type TMR_CLR_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TRIG_CLR` reader - RTC trigger flag clear
        pub type TRIG_CLR_R = crate::BitReader;
        ///Field `TRIG_CLR` writer - RTC trigger flag clear
        pub type TRIG_CLR_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TMR_FLAG` reader - RTC timer flag
        pub type TMR_FLAG_R = crate::BitReader;
        ///Field `TRIG_FLAG` reader - RTC trigger flag
        pub type TRIG_FLAG_R = crate::BitReader;
        impl R {
            ///Bit 4 - RTC timer flag clear
            #[inline(always)]
            pub fn tmr_clr(&self) -> TMR_CLR_R {
                TMR_CLR_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - RTC trigger flag clear
            #[inline(always)]
            pub fn trig_clr(&self) -> TRIG_CLR_R {
                TRIG_CLR_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - RTC timer flag
            #[inline(always)]
            pub fn tmr_flag(&self) -> TMR_FLAG_R {
                TMR_FLAG_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - RTC trigger flag
            #[inline(always)]
            pub fn trig_flag(&self) -> TRIG_FLAG_R {
                TRIG_FLAG_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 4 - RTC timer flag clear
            #[inline(always)]
            #[must_use]
            pub fn tmr_clr(&mut self) -> TMR_CLR_W<FLAG_CTRL_SPEC> {
                TMR_CLR_W::new(self, 4)
            }
            ///Bit 5 - RTC trigger flag clear
            #[inline(always)]
            #[must_use]
            pub fn trig_clr(&mut self) -> TRIG_CLR_W<FLAG_CTRL_SPEC> {
                TRIG_CLR_W::new(self, 5)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RTC flag and clear control
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`flag_ctrl::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`flag_ctrl::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct FLAG_CTRL_SPEC;
        impl crate::RegisterSpec for FLAG_CTRL_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`flag_ctrl::R`](R) reader structure
        impl crate::Readable for FLAG_CTRL_SPEC {}
        ///`write(|w| ..)` method takes [`flag_ctrl::W`](W) writer structure
        impl crate::Writable for FLAG_CTRL_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets FLAG_CTRL to value 0x30
        impl crate::Resettable for FLAG_CTRL_SPEC {
            const RESET_VALUE: u8 = 0x30;
        }
    }
    ///MODE_CTRL (rw) register accessor: RTC mode control
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`mode_ctrl::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`mode_ctrl::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@mode_ctrl`]
    ///module
    pub type MODE_CTRL = crate::Reg<mode_ctrl::MODE_CTRL_SPEC>;
    ///RTC mode control
    pub mod mode_ctrl {
        ///Register `MODE_CTRL` reader
        pub type R = crate::R<MODE_CTRL_SPEC>;
        ///Register `MODE_CTRL` writer
        pub type W = crate::W<MODE_CTRL_SPEC>;
        ///Field `TMR_MODE` reader - RTC timer mode, 0=0.125S, 111; 16S
        pub type TMR_MODE_R = crate::FieldReader;
        ///Field `TMR_MODE` writer - RTC timer mode, 0=0.125S, 111; 16S
        pub type TMR_MODE_W<'a, REG> = crate::FieldWriter<'a, REG, 3>;
        ///Field `IGNORE_B0` reader - RTC ignore compare bit 0
        pub type IGNORE_B0_R = crate::BitReader;
        ///Field `IGNORE_B0` writer - RTC ignore compare bit 0
        pub type IGNORE_B0_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TMR_EN` reader - RTC timer enable
        pub type TMR_EN_R = crate::BitReader;
        ///Field `TMR_EN` writer - RTC timer enable
        pub type TMR_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `TRIG_EN` reader - RTC trigger enable
        pub type TRIG_EN_R = crate::BitReader;
        ///Field `TRIG_EN` writer - RTC trigger enable
        pub type TRIG_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `LOAD_LO` reader - RTC load TRIG to low word
        pub type LOAD_LO_R = crate::BitReader;
        ///Field `LOAD_LO` writer - RTC load TRIG to low word
        pub type LOAD_LO_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `LOAD_HI` reader - RTC load TRIG to high word
        pub type LOAD_HI_R = crate::BitReader;
        ///Field `LOAD_HI` writer - RTC load TRIG to high word
        pub type LOAD_HI_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bits 0:2 - RTC timer mode, 0=0.125S, 111; 16S
            #[inline(always)]
            pub fn tmr_mode(&self) -> TMR_MODE_R {
                TMR_MODE_R::new(self.bits & 7)
            }
            ///Bit 3 - RTC ignore compare bit 0
            #[inline(always)]
            pub fn ignore_b0(&self) -> IGNORE_B0_R {
                IGNORE_B0_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RTC timer enable
            #[inline(always)]
            pub fn tmr_en(&self) -> TMR_EN_R {
                TMR_EN_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - RTC trigger enable
            #[inline(always)]
            pub fn trig_en(&self) -> TRIG_EN_R {
                TRIG_EN_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - RTC load TRIG to low word
            #[inline(always)]
            pub fn load_lo(&self) -> LOAD_LO_R {
                LOAD_LO_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - RTC load TRIG to high word
            #[inline(always)]
            pub fn load_hi(&self) -> LOAD_HI_R {
                LOAD_HI_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:2 - RTC timer mode, 0=0.125S, 111; 16S
            #[inline(always)]
            #[must_use]
            pub fn tmr_mode(&mut self) -> TMR_MODE_W<MODE_CTRL_SPEC> {
                TMR_MODE_W::new(self, 0)
            }
            ///Bit 3 - RTC ignore compare bit 0
            #[inline(always)]
            #[must_use]
            pub fn ignore_b0(&mut self) -> IGNORE_B0_W<MODE_CTRL_SPEC> {
                IGNORE_B0_W::new(self, 3)
            }
            ///Bit 4 - RTC timer enable
            #[inline(always)]
            #[must_use]
            pub fn tmr_en(&mut self) -> TMR_EN_W<MODE_CTRL_SPEC> {
                TMR_EN_W::new(self, 4)
            }
            ///Bit 5 - RTC trigger enable
            #[inline(always)]
            #[must_use]
            pub fn trig_en(&mut self) -> TRIG_EN_W<MODE_CTRL_SPEC> {
                TRIG_EN_W::new(self, 5)
            }
            ///Bit 6 - RTC load TRIG to low word
            #[inline(always)]
            #[must_use]
            pub fn load_lo(&mut self) -> LOAD_LO_W<MODE_CTRL_SPEC> {
                LOAD_LO_W::new(self, 6)
            }
            ///Bit 7 - RTC load TRIG to high word
            #[inline(always)]
            #[must_use]
            pub fn load_hi(&mut self) -> LOAD_HI_W<MODE_CTRL_SPEC> {
                LOAD_HI_W::new(self, 7)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RTC mode control
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`mode_ctrl::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`mode_ctrl::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct MODE_CTRL_SPEC;
        impl crate::RegisterSpec for MODE_CTRL_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [`mode_ctrl::R`](R) reader structure
        impl crate::Readable for MODE_CTRL_SPEC {}
        ///`write(|w| ..)` method takes [`mode_ctrl::W`](W) writer structure
        impl crate::Writable for MODE_CTRL_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        ///`reset()` method sets MODE_CTRL to value 0x02
        impl crate::Resettable for MODE_CTRL_SPEC {
            const RESET_VALUE: u8 = 0x02;
        }
    }
    ///TRIG (rw) register accessor: RTC trigger control
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`trig::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`trig::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@trig`]
    ///module
    pub type TRIG = crate::Reg<trig::TRIG_SPEC>;
    ///RTC trigger control
    pub mod trig {
        ///Register `TRIG` reader
        pub type R = crate::R<TRIG_SPEC>;
        ///Register `TRIG` writer
        pub type W = crate::W<TRIG_SPEC>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<TRIG_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                core::fmt::Debug::fmt(&self.read(), f)
            }
        }
        impl W {
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RTC trigger control
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`trig::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`trig::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct TRIG_SPEC;
        impl crate::RegisterSpec for TRIG_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`trig::R`](R) reader structure
        impl crate::Readable for TRIG_SPEC {}
        ///`write(|w| ..)` method takes [`trig::W`](W) writer structure
        impl crate::Writable for TRIG_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets TRIG to value 0
        impl crate::Resettable for TRIG_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///CNT_32K (rw) register accessor: RTC 32K-based counter
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`cnt_32k::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cnt_32k::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@cnt_32k`]
    ///module
    pub type CNT_32K = crate::Reg<cnt_32k::CNT_32K_SPEC>;
    ///RTC 32K-based counter
    pub mod cnt_32k {
        ///Register `CNT_32K` reader
        pub type R = crate::R<CNT_32K_SPEC>;
        ///Register `CNT_32K` writer
        pub type W = crate::W<CNT_32K_SPEC>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<CNT_32K_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                core::fmt::Debug::fmt(&self.read(), f)
            }
        }
        impl W {
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RTC 32K-based counter
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`cnt_32k::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cnt_32k::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct CNT_32K_SPEC;
        impl crate::RegisterSpec for CNT_32K_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`cnt_32k::R`](R) reader structure
        impl crate::Readable for CNT_32K_SPEC {}
        ///`write(|w| ..)` method takes [`cnt_32k::W`](W) writer structure
        impl crate::Writable for CNT_32K_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets CNT_32K to value 0
        impl crate::Resettable for CNT_32K_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///CNT_2S (rw) register accessor: RTC 2-second-based counter
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`cnt_2s::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cnt_2s::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@cnt_2s`]
    ///module
    pub type CNT_2S = crate::Reg<cnt_2s::CNT_2S_SPEC>;
    ///RTC 2-second-based counter
    pub mod cnt_2s {
        ///Register `CNT_2S` reader
        pub type R = crate::R<CNT_2S_SPEC>;
        ///Register `CNT_2S` writer
        pub type W = crate::W<CNT_2S_SPEC>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<CNT_2S_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                core::fmt::Debug::fmt(&self.read(), f)
            }
        }
        impl W {
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RTC 2-second-based counter
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`cnt_2s::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cnt_2s::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct CNT_2S_SPEC;
        impl crate::RegisterSpec for CNT_2S_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [`cnt_2s::R`](R) reader structure
        impl crate::Readable for CNT_2S_SPEC {}
        ///`write(|w| ..)` method takes [`cnt_2s::W`](W) writer structure
        impl crate::Writable for CNT_2S_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        ///`reset()` method sets CNT_2S to value 0
        impl crate::Resettable for CNT_2S_SPEC {
            const RESET_VALUE: u16 = 0;
        }
    }
    ///CNT_DAY (rw) register accessor: RTC day-based counter
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`cnt_day::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cnt_day::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@cnt_day`]
    ///module
    pub type CNT_DAY = crate::Reg<cnt_day::CNT_DAY_SPEC>;
    ///RTC day-based counter
    pub mod cnt_day {
        ///Register `CNT_DAY` reader
        pub type R = crate::R<CNT_DAY_SPEC>;
        ///Register `CNT_DAY` writer
        pub type W = crate::W<CNT_DAY_SPEC>;
        ///Field `CNT_DAY` reader - RTC day-based counter
        pub type CNT_DAY_R = crate::FieldReader<u16>;
        ///Field `CNT_DAY` writer - RTC day-based counter
        pub type CNT_DAY_W<'a, REG> = crate::FieldWriter<'a, REG, 14, u16>;
        impl R {
            ///Bits 0:13 - RTC day-based counter
            #[inline(always)]
            pub fn cnt_day(&self) -> CNT_DAY_R {
                CNT_DAY_R::new((self.bits & 0x3fff) as u16)
            }
        }
        impl W {
            ///Bits 0:13 - RTC day-based counter
            #[inline(always)]
            #[must_use]
            pub fn cnt_day(&mut self) -> CNT_DAY_W<CNT_DAY_SPEC> {
                CNT_DAY_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///RTC day-based counter
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`cnt_day::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cnt_day::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct CNT_DAY_SPEC;
        impl crate::RegisterSpec for CNT_DAY_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`cnt_day::R`](R) reader structure
        impl crate::Readable for CNT_DAY_SPEC {}
        ///`write(|w| ..)` method takes [`cnt_day::W`](W) writer structure
        impl crate::Writable for CNT_DAY_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets CNT_DAY to value 0
        impl crate::Resettable for CNT_DAY_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
}
///Systick registers, 64-bit downcounter for QingKeV4
pub struct SYSTICK {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for SYSTICK {}
impl SYSTICK {
    ///Pointer to the register block
    pub const PTR: *const systick::RegisterBlock = 0xe000_f000 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const systick::RegisterBlock {
        Self::PTR
    }
    /// Steal an instance of this peripheral
    ///
    /// # Safety
    ///
    /// Ensure that the new instance of the peripheral cannot be used in a way
    /// that may race with any existing instances, for example by only
    /// accessing read-only or write-only registers, or by consuming the
    /// original peripheral and using critical sections to coordinate
    /// access between multiple new instances.
    ///
    /// Additionally, other software such as HALs may rely on only one
    /// peripheral instance existing to ensure memory safety; ensure
    /// no stolen instances are passed to such software.
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for SYSTICK {
    type Target = systick::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for SYSTICK {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("SYSTICK").finish()
    }
}
///Systick registers, 64-bit downcounter for QingKeV4
pub mod systick {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        ctlr: CTLR,
        sr: SR,
        _reserved_2_cnt: [u8; 0x08],
        _reserved_3_cmp: [u8; 0x08],
    }
    impl RegisterBlock {
        ///0x00 - System count control register
        #[inline(always)]
        pub const fn ctlr(&self) -> &CTLR {
            &self.ctlr
        }
        ///0x04 - System count status register
        #[inline(always)]
        pub const fn sr(&self) -> &SR {
            &self.sr
        }
        ///0x08 - System counter register, lower 32-bit
        #[inline(always)]
        pub const fn cntl(&self) -> &CNTL {
            unsafe { &*(self as *const Self).cast::<u8>().add(8).cast() }
        }
        ///0x08..0x10 - System counter register
        #[inline(always)]
        pub const fn cnt(&self) -> &CNT {
            unsafe { &*(self as *const Self).cast::<u8>().add(8).cast() }
        }
        ///0x10 - System count compare register, lower 32-bit
        #[inline(always)]
        pub const fn cmpl(&self) -> &CMPL {
            unsafe { &*(self as *const Self).cast::<u8>().add(16).cast() }
        }
        ///0x10..0x18 - System count compare register
        #[inline(always)]
        pub const fn cmp(&self) -> &CMP {
            unsafe { &*(self as *const Self).cast::<u8>().add(16).cast() }
        }
    }
    ///CTLR (rw) register accessor: System count control register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`ctlr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ctlr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@ctlr`]
    ///module
    pub type CTLR = crate::Reg<ctlr::CTLR_SPEC>;
    ///System count control register
    pub mod ctlr {
        ///Register `CTLR` reader
        pub type R = crate::R<CTLR_SPEC>;
        ///Register `CTLR` writer
        pub type W = crate::W<CTLR_SPEC>;
        ///Field `STE` reader - Counter enable control bit
        pub type STE_R = crate::BitReader;
        ///Field `STE` writer - Counter enable control bit
        pub type STE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `STIE` reader - Counter interrupt enable control bit
        pub type STIE_R = crate::BitReader;
        ///Field `STIE` writer - Counter interrupt enable control bit
        pub type STIE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `STCLK` reader - Counter system clock sourse selection bit
        pub type STCLK_R = crate::BitReader<STCLK_A>;
        ///Counter system clock sourse selection bit
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum STCLK_A {
            ///0: HCLK/8
            HclkDiv8 = 0,
            ///1: HCLK
            Hclk = 1,
        }
        impl From<STCLK_A> for bool {
            #[inline(always)]
            fn from(variant: STCLK_A) -> Self {
                variant as u8 != 0
            }
        }
        impl STCLK_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub const fn variant(&self) -> STCLK_A {
                match self.bits {
                    false => STCLK_A::HclkDiv8,
                    true => STCLK_A::Hclk,
                }
            }
            ///HCLK/8
            #[inline(always)]
            pub fn is_hclk_div8(&self) -> bool {
                *self == STCLK_A::HclkDiv8
            }
            ///HCLK
            #[inline(always)]
            pub fn is_hclk(&self) -> bool {
                *self == STCLK_A::Hclk
            }
        }
        ///Field `STCLK` writer - Counter system clock sourse selection bit
        pub type STCLK_W<'a, REG> = crate::BitWriter<'a, REG, STCLK_A>;
        impl<'a, REG> STCLK_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            ///HCLK/8
            #[inline(always)]
            pub fn hclk_div8(self) -> &'a mut crate::W<REG> {
                self.variant(STCLK_A::HclkDiv8)
            }
            ///HCLK
            #[inline(always)]
            pub fn hclk(self) -> &'a mut crate::W<REG> {
                self.variant(STCLK_A::Hclk)
            }
        }
        ///Field `STRE` reader - Auto reload count enable bit
        pub type STRE_R = crate::BitReader;
        ///Field `STRE` writer - Auto reload count enable bit
        pub type STRE_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `MODE` reader - Counter mode
        pub type MODE_R = crate::BitReader<MODE_A>;
        ///Counter mode
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum MODE_A {
            ///0: Upcount
            Upcount = 0,
            ///1: Downcount
            Downcount = 1,
        }
        impl From<MODE_A> for bool {
            #[inline(always)]
            fn from(variant: MODE_A) -> Self {
                variant as u8 != 0
            }
        }
        impl MODE_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub const fn variant(&self) -> MODE_A {
                match self.bits {
                    false => MODE_A::Upcount,
                    true => MODE_A::Downcount,
                }
            }
            ///Upcount
            #[inline(always)]
            pub fn is_upcount(&self) -> bool {
                *self == MODE_A::Upcount
            }
            ///Downcount
            #[inline(always)]
            pub fn is_downcount(&self) -> bool {
                *self == MODE_A::Downcount
            }
        }
        ///Field `MODE` writer - Counter mode
        pub type MODE_W<'a, REG> = crate::BitWriter<'a, REG, MODE_A>;
        impl<'a, REG> MODE_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            ///Upcount
            #[inline(always)]
            pub fn upcount(self) -> &'a mut crate::W<REG> {
                self.variant(MODE_A::Upcount)
            }
            ///Downcount
            #[inline(always)]
            pub fn downcount(self) -> &'a mut crate::W<REG> {
                self.variant(MODE_A::Downcount)
            }
        }
        ///Field `INIT` reader - Counter initial value update
        pub type INIT_R = crate::BitReader;
        ///Field `INIT` writer - Counter initial value update
        pub type INIT_W<'a, REG> = crate::BitWriter<'a, REG>;
        ///Field `SWIE` reader - Software interrupt enable
        pub type SWIE_R = crate::BitReader;
        ///Field `SWIE` writer - Software interrupt enable
        pub type SWIE_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - Counter enable control bit
            #[inline(always)]
            pub fn ste(&self) -> STE_R {
                STE_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Counter interrupt enable control bit
            #[inline(always)]
            pub fn stie(&self) -> STIE_R {
                STIE_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - Counter system clock sourse selection bit
            #[inline(always)]
            pub fn stclk(&self) -> STCLK_R {
                STCLK_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - Auto reload count enable bit
            #[inline(always)]
            pub fn stre(&self) -> STRE_R {
                STRE_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - Counter mode
            #[inline(always)]
            pub fn mode(&self) -> MODE_R {
                MODE_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - Counter initial value update
            #[inline(always)]
            pub fn init(&self) -> INIT_R {
                INIT_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 31 - Software interrupt enable
            #[inline(always)]
            pub fn swie(&self) -> SWIE_R {
                SWIE_R::new(((self.bits >> 31) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - Counter enable control bit
            #[inline(always)]
            #[must_use]
            pub fn ste(&mut self) -> STE_W<CTLR_SPEC> {
                STE_W::new(self, 0)
            }
            ///Bit 1 - Counter interrupt enable control bit
            #[inline(always)]
            #[must_use]
            pub fn stie(&mut self) -> STIE_W<CTLR_SPEC> {
                STIE_W::new(self, 1)
            }
            ///Bit 2 - Counter system clock sourse selection bit
            #[inline(always)]
            #[must_use]
            pub fn stclk(&mut self) -> STCLK_W<CTLR_SPEC> {
                STCLK_W::new(self, 2)
            }
            ///Bit 3 - Auto reload count enable bit
            #[inline(always)]
            #[must_use]
            pub fn stre(&mut self) -> STRE_W<CTLR_SPEC> {
                STRE_W::new(self, 3)
            }
            ///Bit 4 - Counter mode
            #[inline(always)]
            #[must_use]
            pub fn mode(&mut self) -> MODE_W<CTLR_SPEC> {
                MODE_W::new(self, 4)
            }
            ///Bit 5 - Counter initial value update
            #[inline(always)]
            #[must_use]
            pub fn init(&mut self) -> INIT_W<CTLR_SPEC> {
                INIT_W::new(self, 5)
            }
            ///Bit 31 - Software interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn swie(&mut self) -> SWIE_W<CTLR_SPEC> {
                SWIE_W::new(self, 31)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///System count control register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`ctlr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ctlr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct CTLR_SPEC;
        impl crate::RegisterSpec for CTLR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`ctlr::R`](R) reader structure
        impl crate::Readable for CTLR_SPEC {}
        ///`write(|w| ..)` method takes [`ctlr::W`](W) writer structure
        impl crate::Writable for CTLR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets CTLR to value 0
        impl crate::Resettable for CTLR_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///SR (rw) register accessor: System count status register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`sr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`sr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@sr`]
    ///module
    pub type SR = crate::Reg<sr::SR_SPEC>;
    ///System count status register
    pub mod sr {
        ///Register `SR` reader
        pub type R = crate::R<SR_SPEC>;
        ///Register `SR` writer
        pub type W = crate::W<SR_SPEC>;
        ///Field `CNTIF` reader - Count value compare flag
        pub type CNTIF_R = crate::BitReader;
        ///Field `CNTIF` writer - Count value compare flag
        pub type CNTIF_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            ///Bit 0 - Count value compare flag
            #[inline(always)]
            pub fn cntif(&self) -> CNTIF_R {
                CNTIF_R::new((self.bits & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - Count value compare flag
            #[inline(always)]
            #[must_use]
            pub fn cntif(&mut self) -> CNTIF_W<SR_SPEC> {
                CNTIF_W::new(self, 0)
            }
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///System count status register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`sr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`sr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct SR_SPEC;
        impl crate::RegisterSpec for SR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`sr::R`](R) reader structure
        impl crate::Readable for SR_SPEC {}
        ///`write(|w| ..)` method takes [`sr::W`](W) writer structure
        impl crate::Writable for SR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets SR to value 0
        impl crate::Resettable for SR_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///CNT (rw) register accessor: System counter register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`cnt::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cnt::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@cnt`]
    ///module
    pub type CNT = crate::Reg<cnt::CNT_SPEC>;
    ///System counter register
    pub mod cnt {
        ///Register `CNT` reader
        pub type R = crate::R<CNT_SPEC>;
        ///Register `CNT` writer
        pub type W = crate::W<CNT_SPEC>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<CNT_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                core::fmt::Debug::fmt(&self.read(), f)
            }
        }
        impl W {
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u64) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///System counter register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`cnt::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cnt::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct CNT_SPEC;
        impl crate::RegisterSpec for CNT_SPEC {
            type Ux = u64;
        }
        ///`read()` method returns [`cnt::R`](R) reader structure
        impl crate::Readable for CNT_SPEC {}
        ///`write(|w| ..)` method takes [`cnt::W`](W) writer structure
        impl crate::Writable for CNT_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u64 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u64 = 0;
        }
        ///`reset()` method sets CNT to value 0
        impl crate::Resettable for CNT_SPEC {
            const RESET_VALUE: u64 = 0;
        }
    }
    ///CNTL (rw) register accessor: System counter register, lower 32-bit
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`cntl::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cntl::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@cntl`]
    ///module
    pub type CNTL = crate::Reg<cntl::CNTL_SPEC>;
    ///System counter register, lower 32-bit
    pub mod cntl {
        ///Register `CNTL` reader
        pub type R = crate::R<CNTL_SPEC>;
        ///Register `CNTL` writer
        pub type W = crate::W<CNTL_SPEC>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<CNTL_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                core::fmt::Debug::fmt(&self.read(), f)
            }
        }
        impl W {
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///System counter register, lower 32-bit
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`cntl::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cntl::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct CNTL_SPEC;
        impl crate::RegisterSpec for CNTL_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`cntl::R`](R) reader structure
        impl crate::Readable for CNTL_SPEC {}
        ///`write(|w| ..)` method takes [`cntl::W`](W) writer structure
        impl crate::Writable for CNTL_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets CNTL to value 0
        impl crate::Resettable for CNTL_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    ///CMP (rw) register accessor: System count compare register
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`cmp::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cmp::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@cmp`]
    ///module
    pub type CMP = crate::Reg<cmp::CMP_SPEC>;
    ///System count compare register
    pub mod cmp {
        ///Register `CMP` reader
        pub type R = crate::R<CMP_SPEC>;
        ///Register `CMP` writer
        pub type W = crate::W<CMP_SPEC>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<CMP_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                core::fmt::Debug::fmt(&self.read(), f)
            }
        }
        impl W {
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u64) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///System count compare register
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`cmp::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cmp::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct CMP_SPEC;
        impl crate::RegisterSpec for CMP_SPEC {
            type Ux = u64;
        }
        ///`read()` method returns [`cmp::R`](R) reader structure
        impl crate::Readable for CMP_SPEC {}
        ///`write(|w| ..)` method takes [`cmp::W`](W) writer structure
        impl crate::Writable for CMP_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u64 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u64 = 0;
        }
        ///`reset()` method sets CMP to value 0
        impl crate::Resettable for CMP_SPEC {
            const RESET_VALUE: u64 = 0;
        }
    }
    ///CMPL (rw) register accessor: System count compare register, lower 32-bit
    ///
    ///You can [`read`](crate::generic::Reg::read) this register and get [`cmpl::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cmpl::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
    ///
    ///For information about available fields see [`mod@cmpl`]
    ///module
    pub type CMPL = crate::Reg<cmpl::CMPL_SPEC>;
    ///System count compare register, lower 32-bit
    pub mod cmpl {
        ///Register `CMPL` reader
        pub type R = crate::R<CMPL_SPEC>;
        ///Register `CMPL` writer
        pub type W = crate::W<CMPL_SPEC>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<CMPL_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                core::fmt::Debug::fmt(&self.read(), f)
            }
        }
        impl W {
            /// Writes raw bits to the register.
            ///
            /// # Safety
            ///
            /// Passing incorrect value can cause undefined behaviour. See reference manual
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        ///System count compare register, lower 32-bit
        ///
        ///You can [`read`](crate::generic::Reg::read) this register and get [`cmpl::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cmpl::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        pub struct CMPL_SPEC;
        impl crate::RegisterSpec for CMPL_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [`cmpl::R`](R) reader structure
        impl crate::Readable for CMPL_SPEC {}
        ///`write(|w| ..)` method takes [`cmpl::W`](W) writer structure
        impl crate::Writable for CMPL_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        ///`reset()` method sets CMPL to value 0
        impl crate::Resettable for CMPL_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
}
#[no_mangle]
static mut DEVICE_PERIPHERALS: bool = false;
/// All the peripherals.
#[allow(non_snake_case)]
pub struct Peripherals {
    ///SYS
    pub SYS: SYS,
    ///TMR0
    pub TMR0: TMR0,
    ///TMR1
    pub TMR1: TMR1,
    ///TMR2
    pub TMR2: TMR2,
    ///TMR3
    pub TMR3: TMR3,
    ///UART0
    pub UART0: UART0,
    ///UART1
    pub UART1: UART1,
    ///UART2
    pub UART2: UART2,
    ///UART3
    pub UART3: UART3,
    ///SPI0
    pub SPI0: SPI0,
    ///SPI1
    pub SPI1: SPI1,
    ///I2C
    pub I2C: I2C,
    ///PWMx
    pub PWMX: PWMX,
    ///USB
    pub USB: USB,
    ///USB2
    pub USB2: USB2,
    ///PFIC
    pub PFIC: PFIC,
    ///ADC
    pub ADC: ADC,
    ///GPIOCTL
    pub GPIOCTL: GPIOCTL,
    ///GPIOA
    pub GPIOA: GPIOA,
    ///GPIOB
    pub GPIOB: GPIOB,
    ///RTC
    pub RTC: RTC,
    ///SYSTICK
    pub SYSTICK: SYSTICK,
}
impl Peripherals {
    /// Returns all the peripherals *once*.
    #[cfg(feature = "critical-section")]
    #[inline]
    pub fn take() -> Option<Self> {
        critical_section::with(|_| {
            if unsafe { DEVICE_PERIPHERALS } {
                return None;
            }
            Some(unsafe { Peripherals::steal() })
        })
    }
    /// Unchecked version of `Peripherals::take`.
    ///
    /// # Safety
    ///
    /// Each of the returned peripherals must be used at most once.
    #[inline]
    pub unsafe fn steal() -> Self {
        DEVICE_PERIPHERALS = true;
        Peripherals {
            SYS: SYS {
                _marker: PhantomData,
            },
            TMR0: TMR0 {
                _marker: PhantomData,
            },
            TMR1: TMR1 {
                _marker: PhantomData,
            },
            TMR2: TMR2 {
                _marker: PhantomData,
            },
            TMR3: TMR3 {
                _marker: PhantomData,
            },
            UART0: UART0 {
                _marker: PhantomData,
            },
            UART1: UART1 {
                _marker: PhantomData,
            },
            UART2: UART2 {
                _marker: PhantomData,
            },
            UART3: UART3 {
                _marker: PhantomData,
            },
            SPI0: SPI0 {
                _marker: PhantomData,
            },
            SPI1: SPI1 {
                _marker: PhantomData,
            },
            I2C: I2C {
                _marker: PhantomData,
            },
            PWMX: PWMX {
                _marker: PhantomData,
            },
            USB: USB {
                _marker: PhantomData,
            },
            USB2: USB2 {
                _marker: PhantomData,
            },
            PFIC: PFIC {
                _marker: PhantomData,
            },
            ADC: ADC {
                _marker: PhantomData,
            },
            GPIOCTL: GPIOCTL {
                _marker: PhantomData,
            },
            GPIOA: GPIOA {
                _marker: PhantomData,
            },
            GPIOB: GPIOB {
                _marker: PhantomData,
            },
            RTC: RTC {
                _marker: PhantomData,
            },
            SYSTICK: SYSTICK {
                _marker: PhantomData,
            },
        }
    }
}
