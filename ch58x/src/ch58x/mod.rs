//!Peripheral access API for CH583SFR microcontrollers (generated using svd2rust v0.27.2 ( ))
//!
//!You can find an overview of the generated API [here].
//!
//!API features to be included in the [next]
//!svd2rust release can be generated by cloning the svd2rust [repository], checking out the above commit, and running `cargo doc --open`.
//!
//![here]: https://docs.rs/svd2rust/0.27.2/svd2rust/#peripheral-api
//![next]: https://github.com/rust-embedded/svd2rust/blob/master/CHANGELOG.md#unreleased
//![repository]: https://github.com/rust-embedded/svd2rust
use core::marker::PhantomData;
use core::ops::Deref;
#[cfg(feature = "rt")]
extern "C" {
    fn TMR0();
    fn GPIO_A();
    fn GPIO_B();
    fn SPI0();
    fn BLEB();
    fn BLEL();
    fn USB();
    fn USB2();
    fn TMR1();
    fn TMR2();
    fn UART0();
    fn UART1();
    fn RTC();
    fn ADC();
    fn I2C();
    fn PWMX();
    fn TMR3();
    fn UART2();
    fn UART3();
    fn WDOG_BAT();
}
#[doc(hidden)]
pub union Vector {
    pub _handler: unsafe extern "C" fn(),
    pub _reserved: usize,
}
#[cfg(feature = "rt")]
#[doc(hidden)]
#[no_mangle]
pub static __EXTERNAL_INTERRUPTS: [Vector; 36] = [
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _handler: TMR0 },
    Vector { _handler: GPIO_A },
    Vector { _handler: GPIO_B },
    Vector { _handler: SPI0 },
    Vector { _handler: BLEB },
    Vector { _handler: BLEL },
    Vector { _handler: USB },
    Vector { _handler: USB2 },
    Vector { _handler: TMR1 },
    Vector { _handler: TMR2 },
    Vector { _handler: UART0 },
    Vector { _handler: UART1 },
    Vector { _handler: RTC },
    Vector { _handler: ADC },
    Vector { _handler: I2C },
    Vector { _handler: PWMX },
    Vector { _handler: TMR3 },
    Vector { _handler: UART2 },
    Vector { _handler: UART3 },
    Vector { _handler: WDOG_BAT },
];
#[doc(hidden)]
pub mod interrupt {
    ///Enumeration of all the interrupts.
    #[derive(Copy, Clone, Debug, PartialEq, Eq)]
    #[repr(u16)]
    pub enum Interrupt {
        ///16 - TMR0_IRQHandler
        TMR0 = 16,
        ///17 - GPIO_IRQHandler
        GPIO_A = 17,
        ///18 - GPIO_IRQHandler
        GPIO_B = 18,
        ///19 - SPI0_IRQHandler
        SPI0 = 19,
        ///20 - BB_IRQHandler
        BLEB = 20,
        ///21 - LLE_IRQHandler
        BLEL = 21,
        ///22 - USB_IRQHandler
        USB = 22,
        ///23 - USB2_IRQHandler
        USB2 = 23,
        ///24 - TMR1_IRQHandler
        TMR1 = 24,
        ///25 - TMR2_IRQHandler
        TMR2 = 25,
        ///26 - UART0_IRQHandler
        UART0 = 26,
        ///27 - UART1_IRQHandler
        UART1 = 27,
        ///28 - RTC_IRQHandler
        RTC = 28,
        ///29 - ADC_IRQHandler
        ADC = 29,
        ///30 - I2C_IRQHandler
        I2C = 30,
        ///31 - PPWMX_SPI1_IRQHandler
        PWMX = 31,
        ///32 - TMR3_IRQHandler
        TMR3 = 32,
        ///33 - UART1_IRQHandler
        UART2 = 33,
        ///34 - UART3_IRQHandler
        UART3 = 34,
        ///35 - WDT_IRQHandler
        WDOG_BAT = 35,
    }
    /// TryFromInterruptError
    #[derive(Debug, Copy, Clone)]
    pub struct TryFromInterruptError(());
    impl Interrupt {
        /// Attempt to convert a given value into an `Interrupt`
        #[inline]
        pub fn try_from(value: u8) -> Result<Self, TryFromInterruptError> {
            match value {
                16 => Ok(Interrupt::TMR0),
                17 => Ok(Interrupt::GPIO_A),
                18 => Ok(Interrupt::GPIO_B),
                19 => Ok(Interrupt::SPI0),
                20 => Ok(Interrupt::BLEB),
                21 => Ok(Interrupt::BLEL),
                22 => Ok(Interrupt::USB),
                23 => Ok(Interrupt::USB2),
                24 => Ok(Interrupt::TMR1),
                25 => Ok(Interrupt::TMR2),
                26 => Ok(Interrupt::UART0),
                27 => Ok(Interrupt::UART1),
                28 => Ok(Interrupt::RTC),
                29 => Ok(Interrupt::ADC),
                30 => Ok(Interrupt::I2C),
                31 => Ok(Interrupt::PWMX),
                32 => Ok(Interrupt::TMR3),
                33 => Ok(Interrupt::UART2),
                34 => Ok(Interrupt::UART3),
                35 => Ok(Interrupt::WDOG_BAT),
                _ => Err(TryFromInterruptError(())),
            }
        }
    }
    #[cfg(feature = "rt")]
    #[macro_export]
    /// Assigns a handler to an interrupt
    ///
    /// This macro takes two arguments: the name of an interrupt and the path to the
    /// function that will be used as the handler of that interrupt. That function
    /// must have signature `fn()`.
    ///
    /// Optionally, a third argument may be used to declare interrupt local data.
    /// The handler will have exclusive access to these *local* variables on each
    /// invocation. If the third argument is used then the signature of the handler
    /// function must be `fn(&mut $NAME::Locals)` where `$NAME` is the first argument
    /// passed to the macro.
    ///
    /// # Example
    ///
    /// ``` ignore
    /// interrupt!(TIM2, periodic);
    ///
    /// fn periodic() {
    ///     print!(".");
    /// }
    ///
    /// interrupt!(TIM3, tick, locals: {
    ///     tick: bool = false;
    /// });
    ///
    /// fn tick(locals: &mut TIM3::Locals) {
    ///     locals.tick = !locals.tick;
    ///
    ///     if locals.tick {
    ///         println!("Tick");
    ///     } else {
    ///         println!("Tock");
    ///     }
    /// }
    /// ```
    macro_rules ! interrupt { ($ NAME : ident , $ path : path , locals : { $ ($ lvar : ident : $ lty : ty = $ lval : expr ;) * }) => { # [allow (non_snake_case)]
mod $ NAME { pub struct Locals { $ (pub $ lvar : $ lty ,) * } } # [allow (non_snake_case)]
# [no_mangle]
pub extern "C" fn $ NAME () { let _ = $ crate :: interrupt :: Interrupt :: $ NAME ; static mut LOCALS : self :: $ NAME :: Locals = self :: $ NAME :: Locals { $ ($ lvar : $ lval ,) * } ; let f : fn (& mut self :: $ NAME :: Locals) = $ path ; f (unsafe { & mut LOCALS }) ; } } ; ($ NAME : ident , $ path : path) => { # [allow (non_snake_case)]
# [no_mangle]
pub extern "C" fn $ NAME () { let _ = $ crate :: interrupt :: Interrupt :: $ NAME ; let f : fn () = $ path ; f () ; } } }
}
pub use self::interrupt::Interrupt;
///System Control Register
pub struct SYS {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for SYS {}
impl SYS {
    ///Pointer to the register block
    pub const PTR: *const sys::RegisterBlock = 0x4000_1000 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const sys::RegisterBlock {
        Self::PTR
    }
}
impl Deref for SYS {
    type Target = sys::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for SYS {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("SYS").finish()
    }
}
///System Control Register
pub mod sys {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        _reserved0: [u8; 0x08],
        ///0x08 - RWA, system clock configuration, SAM
        pub clk_sys_cfg: CLK_SYS_CFG,
        ///0x0a - RWA, high frequency clock module power control, SAM
        pub hfck_pwr_ctrl: HFCK_PWR_CTRL,
        _reserved2: [u8; 0x01],
        ///0x0c - RWA, sleep clock off control byte 0, SAM
        pub slp_clk_off0: SLP_CLK_OFF0,
        ///0x0d - RWA, sleep clock off control byte 1, SAM
        pub slp_clk_off1: SLP_CLK_OFF1,
        ///0x0e - RWA, wake control, SAM
        pub slp_wake_ctrl: SLP_WAKE_CTRL,
        ///0x0f - RWA, peripherals power down control, SAM
        pub slp_power_ctrl: SLP_POWER_CTRL,
        _reserved6: [u8; 0x08],
        ///0x18 - RW, function pin alternate configuration
        pub pin_alternate: PIN_ALTERNATE,
        ///0x1a - RW, analog pin enable and digital input disable
        pub pin_analog_ie: PIN_ANALOG_IE,
        _reserved8: [u8; 0x04],
        ///0x20 - RWA, power plan before sleep instruction, SAM
        pub power_plan: POWER_PLAN,
        ///0x22 - RWA, aux power adjust control, SAM
        pub aux_power_adj: AUX_POWER_ADJ,
        _reserved10: [u8; 0x01],
        ///0x24 - RWA, battery voltage detector control, SAM
        pub bat_det_ctrl: BAT_DET_CTRL,
        ///0x25 - RWA, battery voltage detector configuration, SAM
        pub bat_det_cfg: BAT_DET_CFG,
        ///0x26 - RO, battery status
        pub bat_status: BAT_STATUS,
        _reserved13: [u8; 0x05],
        ///0x2c - RWA, internal 32KHz oscillator tune control, SAM
        pub int32k_tune: INT32K_TUNE,
        ///0x2e - RWA, external 32KHz oscillator tune control, SAM
        pub xt32k_tune: XT32K_TUNE,
        ///0x2f - RWA, 32KHz oscillator configure
        pub ck32k_config: CK32K_CONFIG,
        ///0x30 - RW, RTC flag and clear control
        pub rtc_flag_ctrl: RTC_FLAG_CTRL,
        ///0x31 - RWA, RTC mode control, SAM
        pub rtc_mode_ctrl: RTC_MODE_CTRL,
        _reserved18: [u8; 0x02],
        ///0x34 - RWA, RTC trigger value, SAM
        pub rtc_trig: RTC_TRIG,
        ///0x38 - RO, RTC count based 32KHz
        pub rtc_cnt_32k: RTC_CNT_32K,
        ///0x3a - RO, RTC count based 2 second
        pub rtc_cnt_2s: RTC_CNT_2S,
        ///0x3c - RO, RTC count based one day, only low 14 bit
        pub rtc_cnt_day: RTC_CNT_DAY,
        ///0x40 - WO, safe accessing sign register, must write SAFE_ACCESS_SIG1 then SAFE_ACCESS_SIG2 to enter safe accessing mode
        pub safe_access_sig: SAFE_ACCESS_SIG,
        ///0x41 - RF, chip ID register, always is ID_CH58*
        pub chip_id: CHIP_ID,
        ///0x42 - RF, safe accessing ID register, always 0x0C
        pub safe_access_id: SAFE_ACCESS_ID,
        ///0x43 - RW, watch-dog count, count by clock frequency Fsys/131072
        pub wdog_count: WDOG_COUNT,
        ///0x44 - RWA, reset status, SAM or flash ROM configuration
        pub reset_status__r8_glob_rom_cfg: RESET_STATUS__R8_GLOB_ROM_CFG,
        ///0x45 - RO, global configuration information and status
        pub glob_cfg_info: GLOB_CFG_INFO,
        ///0x46 - RWA, reset and watch-dog control, SAM
        pub rst_wdog_ctrl: RST_WDOG_CTRL,
        ///0x47 - RW, value keeper during global reset
        pub glob_reset_keep: GLOB_RESET_KEEP,
        _reserved30: [u8; 0x03],
        ///0x4b - RWA, PLL configuration control, SAM
        pub pll_config: PLL_CONFIG,
        _reserved31: [u8; 0x02],
        ///0x4e - RWA, external 32MHz oscillator tune control, SAM
        pub xt32m_tune: XT32M_TUNE,
        _reserved32: [u8; 0x01],
        ///0x50 - RO, system clock count value for 32KHz multi-cycles
        pub osc_cal_cnt: OSC_CAL_CNT,
        ///0x52 - RO, oscillator frequency calibration overflow times
        pub osc_cal_ov_cnt: OSC_CAL_OV_CNT,
        ///0x53 - RWA, oscillator frequency calibration control, SAM
        pub osc_cal_ctrl: OSC_CAL_CTRL,
        ///0x54 - RW, Touchkey charge and discharge count
        pub tkey_count: TKEY_COUNT,
        _reserved36: [u8; 0x01],
        ///0x56 - RW, Touchkey convert start control
        pub tkey_convert: TKEY_CONVERT,
        ///0x57 - RW, Touchkey configure
        pub tkey_cfg: TKEY_CFG,
        ///0x58 - RW, ADC input channel selection
        pub adc_channel: ADC_CHANNEL,
        ///0x59 - RW, ADC configure
        pub adc_cfg: ADC_CFG,
        ///0x5a - RW, ADC convert control
        pub adc_convert: ADC_CONVERT,
        ///0x5b - RW, temperature sensor control
        pub tem_sensor: TEM_SENSOR,
        ///0x5c - RO, ADC data
        pub adc_data: ADC_DATA,
        ///0x5e - RO, ADC interrupt flag register
        pub adc_int_flag: ADC_INT_FLAG,
        _reserved44: [u8; 0x01],
        ///0x60 - RO, ADC DMA control and status register
        pub adc_dma_ctrl: ADC_DMA_CTRL,
        ///0x61 - RW, ADC DMA control
        pub adc_ctrl_dma: ADC_CTRL_DMA,
        ///0x62 - RO, ADC interrupt flag
        pub adc_dma_if: ADC_DMA_IF,
        ///0x63 - RO, ADC interrupt flag
        pub adc_auto_cycle: ADC_AUTO_CYCLE,
        ///0x64 - RO, ADC DMA current address
        pub adc_dma_now: ADC_DMA_NOW,
        _reserved49: [u8; 0x02],
        ///0x68 - RW, ADC DMA begin address
        pub adc_dma_beg: ADC_DMA_BEG,
        _reserved50: [u8; 0x02],
        ///0x6c - RW, ADC DMA end address
        pub adc_dma_end: ADC_DMA_END,
        _reserved51: [u8; 0x22],
        ///0x90 - RW, GPIO PA interrupt enable
        pub pa_int_en: PA_INT_EN,
        ///0x92 - RW, GPIO PB interrupt enable
        pub pb_int_en: PB_INT_EN,
        ///0x94 - RW, GPIO PA interrupt mode: 0=level action, 1=edge action
        pub pa_int_mode: PA_INT_MODE,
        ///0x96 - RW, GPIO PB interrupt mode: 0=level action, 1=edge action;RW, status for parallel slave read
        pub pb_int_mode: PB_INT_MODE,
        _reserved55: [u8; 0x04],
        ///0x9c - RW1, GPIO PA interrupt flag
        pub pa_int_if: PA_INT_IF,
        ///0x9e - RW1, GPIO PB interrupt flag
        pub pb_int_if: PB_INT_IF,
        ///0xa0 - RW, GPIO PA I/O direction: 0=in, 1=out
        pub pa_dir: PA_DIR,
        ///0xa4 - RO, GPIO PA input
        pub pa_pin: PA_PIN,
        ///0xa8 - RW, GPIO PA output
        pub pa_out: PA_OUT,
        ///0xac - WZ, GPIO PA clear output: 0=keep, 1=clear
        pub pa_clr: PA_CLR,
        ///0xb0 - RW, GPIO PA pullup resistance enable
        pub pa_pu: PA_PU,
        ///0xb4 - RW, PA pulldown for input or PA driving capability for output
        pub pa_pd_drv: PA_PD_DRV,
        _reserved63: [u8; 0x08],
        ///0xc0 - RW, GPIO PB I/O direction: 0=in, 1=out
        pub pb_dir: PB_DIR,
        ///0xc4 - RO, GPIO PB input
        pub pb_pin: PB_PIN,
        ///0xc8 - RW, GPIO PB output;RW, data for parallel slave read
        pub pb_out__r8_slv_rd_data: PB_OUT__R8_SLV_RD_DATA,
        ///0xcc - WZ, GPIO PB clear output: 0=keep, 1=clear
        pub pb_clr: PB_CLR,
        ///0xd0 - RW, GPIO PB pullup resistance enable
        pub pb_pu: PB_PU,
        ///0xd4 - RW, PB pulldown for input or PB driving capability for output
        pub pb_pd_drv: PB_PD_DRV,
    }
    ///CLK_SYS_CFG (rw) register accessor: an alias for `Reg<CLK_SYS_CFG_SPEC>`
    pub type CLK_SYS_CFG = crate::Reg<clk_sys_cfg::CLK_SYS_CFG_SPEC>;
    ///RWA, system clock configuration, SAM
    pub mod clk_sys_cfg {
        ///Register `CLK_SYS_CFG` reader
        pub struct R(crate::R<CLK_SYS_CFG_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CLK_SYS_CFG_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<CLK_SYS_CFG_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<CLK_SYS_CFG_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CLK_SYS_CFG` writer
        pub struct W(crate::W<CLK_SYS_CFG_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CLK_SYS_CFG_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<CLK_SYS_CFG_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<CLK_SYS_CFG_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `CLK_PLL_DIV` reader - RWA, output clock divider from PLL or CK32M
        pub type CLK_PLL_DIV_R = crate::FieldReader<u8, u8>;
        ///Field `CLK_PLL_DIV` writer - RWA, output clock divider from PLL or CK32M
        pub type CLK_PLL_DIV_W<'a, const O: u8> =
            crate::FieldWriter<'a, u16, CLK_SYS_CFG_SPEC, u8, u8, 5, O>;
        ///Field `CLK_SYS_MOD` reader - RWA, system clock source mode: 00=divided from 32MHz, 01=divided from PLL-480MHz, 10=directly from 32MHz, 11=directly from 32KHz
        pub type CLK_SYS_MOD_R = crate::FieldReader<u8, u8>;
        ///Field `CLK_SYS_MOD` writer - RWA, system clock source mode: 00=divided from 32MHz, 01=divided from PLL-480MHz, 10=directly from 32MHz, 11=directly from 32KHz
        pub type CLK_SYS_MOD_W<'a, const O: u8> =
            crate::FieldWriter<'a, u16, CLK_SYS_CFG_SPEC, u8, u8, 2, O>;
        impl R {
            ///Bits 0:4 - RWA, output clock divider from PLL or CK32M
            #[inline(always)]
            pub fn clk_pll_div(&self) -> CLK_PLL_DIV_R {
                CLK_PLL_DIV_R::new((self.bits & 0x1f) as u8)
            }
            ///Bits 6:7 - RWA, system clock source mode: 00=divided from 32MHz, 01=divided from PLL-480MHz, 10=directly from 32MHz, 11=directly from 32KHz
            #[inline(always)]
            pub fn clk_sys_mod(&self) -> CLK_SYS_MOD_R {
                CLK_SYS_MOD_R::new(((self.bits >> 6) & 3) as u8)
            }
        }
        impl W {
            ///Bits 0:4 - RWA, output clock divider from PLL or CK32M
            #[inline(always)]
            #[must_use]
            pub fn clk_pll_div(&mut self) -> CLK_PLL_DIV_W<0> {
                CLK_PLL_DIV_W::new(self)
            }
            ///Bits 6:7 - RWA, system clock source mode: 00=divided from 32MHz, 01=divided from PLL-480MHz, 10=directly from 32MHz, 11=directly from 32KHz
            #[inline(always)]
            #[must_use]
            pub fn clk_sys_mod(&mut self) -> CLK_SYS_MOD_W<6> {
                CLK_SYS_MOD_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RWA, system clock configuration, SAM
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [clk_sys_cfg](index.html) module
        pub struct CLK_SYS_CFG_SPEC;
        impl crate::RegisterSpec for CLK_SYS_CFG_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [clk_sys_cfg::R](R) reader structure
        impl crate::Readable for CLK_SYS_CFG_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [clk_sys_cfg::W](W) writer structure
        impl crate::Writable for CLK_SYS_CFG_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets CLK_SYS_CFG to value 0x05
        impl crate::Resettable for CLK_SYS_CFG_SPEC {
            const RESET_VALUE: Self::Ux = 0x05;
        }
    }
    ///HFCK_PWR_CTRL (rw) register accessor: an alias for `Reg<HFCK_PWR_CTRL_SPEC>`
    pub type HFCK_PWR_CTRL = crate::Reg<hfck_pwr_ctrl::HFCK_PWR_CTRL_SPEC>;
    ///RWA, high frequency clock module power control, SAM
    pub mod hfck_pwr_ctrl {
        ///Register `HFCK_PWR_CTRL` reader
        pub struct R(crate::R<HFCK_PWR_CTRL_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<HFCK_PWR_CTRL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<HFCK_PWR_CTRL_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<HFCK_PWR_CTRL_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `HFCK_PWR_CTRL` writer
        pub struct W(crate::W<HFCK_PWR_CTRL_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<HFCK_PWR_CTRL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<HFCK_PWR_CTRL_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<HFCK_PWR_CTRL_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `CLK_XT32M_PON` reader - RWA, external 32MHz oscillator power control: 0=power down, 1-power on
        pub type CLK_XT32M_PON_R = crate::BitReader<bool>;
        ///Field `CLK_XT32M_PON` writer - RWA, external 32MHz oscillator power control: 0=power down, 1-power on
        pub type CLK_XT32M_PON_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, HFCK_PWR_CTRL_SPEC, bool, O>;
        ///Field `CLK_XT32M_KEEP` reader - RWA, external 32MHz oscillator power keep under halt mode: 0=auto stop, 1=keep running
        pub type CLK_XT32M_KEEP_R = crate::BitReader<bool>;
        ///Field `CLK_XT32M_KEEP` writer - RWA, external 32MHz oscillator power keep under halt mode: 0=auto stop, 1=keep running
        pub type CLK_XT32M_KEEP_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, HFCK_PWR_CTRL_SPEC, bool, O>;
        ///Field `CLK_PLL_PON` reader - RWA, PLL power control: 0=power down, 1-power on
        pub type CLK_PLL_PON_R = crate::BitReader<bool>;
        ///Field `CLK_PLL_PON` writer - RWA, PLL power control: 0=power down, 1-power on
        pub type CLK_PLL_PON_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, HFCK_PWR_CTRL_SPEC, bool, O>;
        impl R {
            ///Bit 2 - RWA, external 32MHz oscillator power control: 0=power down, 1-power on
            #[inline(always)]
            pub fn clk_xt32m_pon(&self) -> CLK_XT32M_PON_R {
                CLK_XT32M_PON_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RWA, external 32MHz oscillator power keep under halt mode: 0=auto stop, 1=keep running
            #[inline(always)]
            pub fn clk_xt32m_keep(&self) -> CLK_XT32M_KEEP_R {
                CLK_XT32M_KEEP_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RWA, PLL power control: 0=power down, 1-power on
            #[inline(always)]
            pub fn clk_pll_pon(&self) -> CLK_PLL_PON_R {
                CLK_PLL_PON_R::new(((self.bits >> 4) & 1) != 0)
            }
        }
        impl W {
            ///Bit 2 - RWA, external 32MHz oscillator power control: 0=power down, 1-power on
            #[inline(always)]
            #[must_use]
            pub fn clk_xt32m_pon(&mut self) -> CLK_XT32M_PON_W<2> {
                CLK_XT32M_PON_W::new(self)
            }
            ///Bit 3 - RWA, external 32MHz oscillator power keep under halt mode: 0=auto stop, 1=keep running
            #[inline(always)]
            #[must_use]
            pub fn clk_xt32m_keep(&mut self) -> CLK_XT32M_KEEP_W<3> {
                CLK_XT32M_KEEP_W::new(self)
            }
            ///Bit 4 - RWA, PLL power control: 0=power down, 1-power on
            #[inline(always)]
            #[must_use]
            pub fn clk_pll_pon(&mut self) -> CLK_PLL_PON_W<4> {
                CLK_PLL_PON_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RWA, high frequency clock module power control, SAM
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [hfck_pwr_ctrl](index.html) module
        pub struct HFCK_PWR_CTRL_SPEC;
        impl crate::RegisterSpec for HFCK_PWR_CTRL_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [hfck_pwr_ctrl::R](R) reader structure
        impl crate::Readable for HFCK_PWR_CTRL_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [hfck_pwr_ctrl::W](W) writer structure
        impl crate::Writable for HFCK_PWR_CTRL_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets HFCK_PWR_CTRL to value 0x14
        impl crate::Resettable for HFCK_PWR_CTRL_SPEC {
            const RESET_VALUE: Self::Ux = 0x14;
        }
    }
    ///SLP_CLK_OFF0 (rw) register accessor: an alias for `Reg<SLP_CLK_OFF0_SPEC>`
    pub type SLP_CLK_OFF0 = crate::Reg<slp_clk_off0::SLP_CLK_OFF0_SPEC>;
    ///RWA, sleep clock off control byte 0, SAM
    pub mod slp_clk_off0 {
        ///Register `SLP_CLK_OFF0` reader
        pub struct R(crate::R<SLP_CLK_OFF0_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<SLP_CLK_OFF0_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<SLP_CLK_OFF0_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<SLP_CLK_OFF0_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `SLP_CLK_OFF0` writer
        pub struct W(crate::W<SLP_CLK_OFF0_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<SLP_CLK_OFF0_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<SLP_CLK_OFF0_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<SLP_CLK_OFF0_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `SLP_CLK_TMR0` reader - RWA, close TMR0 clock
        pub type SLP_CLK_TMR0_R = crate::BitReader<bool>;
        ///Field `SLP_CLK_TMR0` writer - RWA, close TMR0 clock
        pub type SLP_CLK_TMR0_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, SLP_CLK_OFF0_SPEC, bool, O>;
        ///Field `SLP_CLK_TMR1` reader - RWA, close TMR1 clock
        pub type SLP_CLK_TMR1_R = crate::BitReader<bool>;
        ///Field `SLP_CLK_TMR1` writer - RWA, close TMR1 clock
        pub type SLP_CLK_TMR1_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, SLP_CLK_OFF0_SPEC, bool, O>;
        ///Field `SLP_CLK_TMR2` reader - RWA, close TMR2 clock
        pub type SLP_CLK_TMR2_R = crate::BitReader<bool>;
        ///Field `SLP_CLK_TMR2` writer - RWA, close TMR2 clock
        pub type SLP_CLK_TMR2_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, SLP_CLK_OFF0_SPEC, bool, O>;
        ///Field `SLP_CLK_TMR3` reader - RWA, close TMR3 clock
        pub type SLP_CLK_TMR3_R = crate::BitReader<bool>;
        ///Field `SLP_CLK_TMR3` writer - RWA, close TMR3 clock
        pub type SLP_CLK_TMR3_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, SLP_CLK_OFF0_SPEC, bool, O>;
        ///Field `SLP_CLK_UART0` reader - RWA, close UART0 clock
        pub type SLP_CLK_UART0_R = crate::BitReader<bool>;
        ///Field `SLP_CLK_UART0` writer - RWA, close UART0 clock
        pub type SLP_CLK_UART0_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, SLP_CLK_OFF0_SPEC, bool, O>;
        ///Field `SLP_CLK_UART1` reader - RWA, close UART1 clock
        pub type SLP_CLK_UART1_R = crate::BitReader<bool>;
        ///Field `SLP_CLK_UART1` writer - RWA, close UART1 clock
        pub type SLP_CLK_UART1_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, SLP_CLK_OFF0_SPEC, bool, O>;
        ///Field `SLP_CLK_UART2` reader - RWA, close UART2 clock
        pub type SLP_CLK_UART2_R = crate::BitReader<bool>;
        ///Field `SLP_CLK_UART2` writer - RWA, close UART2 clock
        pub type SLP_CLK_UART2_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, SLP_CLK_OFF0_SPEC, bool, O>;
        ///Field `SLP_CLK_UART3` reader - RWA, close UART3 clock
        pub type SLP_CLK_UART3_R = crate::BitReader<bool>;
        ///Field `SLP_CLK_UART3` writer - RWA, close UART3 clock
        pub type SLP_CLK_UART3_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, SLP_CLK_OFF0_SPEC, bool, O>;
        impl R {
            ///Bit 0 - RWA, close TMR0 clock
            #[inline(always)]
            pub fn slp_clk_tmr0(&self) -> SLP_CLK_TMR0_R {
                SLP_CLK_TMR0_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RWA, close TMR1 clock
            #[inline(always)]
            pub fn slp_clk_tmr1(&self) -> SLP_CLK_TMR1_R {
                SLP_CLK_TMR1_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RWA, close TMR2 clock
            #[inline(always)]
            pub fn slp_clk_tmr2(&self) -> SLP_CLK_TMR2_R {
                SLP_CLK_TMR2_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RWA, close TMR3 clock
            #[inline(always)]
            pub fn slp_clk_tmr3(&self) -> SLP_CLK_TMR3_R {
                SLP_CLK_TMR3_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RWA, close UART0 clock
            #[inline(always)]
            pub fn slp_clk_uart0(&self) -> SLP_CLK_UART0_R {
                SLP_CLK_UART0_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - RWA, close UART1 clock
            #[inline(always)]
            pub fn slp_clk_uart1(&self) -> SLP_CLK_UART1_R {
                SLP_CLK_UART1_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - RWA, close UART2 clock
            #[inline(always)]
            pub fn slp_clk_uart2(&self) -> SLP_CLK_UART2_R {
                SLP_CLK_UART2_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - RWA, close UART3 clock
            #[inline(always)]
            pub fn slp_clk_uart3(&self) -> SLP_CLK_UART3_R {
                SLP_CLK_UART3_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RWA, close TMR0 clock
            #[inline(always)]
            #[must_use]
            pub fn slp_clk_tmr0(&mut self) -> SLP_CLK_TMR0_W<0> {
                SLP_CLK_TMR0_W::new(self)
            }
            ///Bit 1 - RWA, close TMR1 clock
            #[inline(always)]
            #[must_use]
            pub fn slp_clk_tmr1(&mut self) -> SLP_CLK_TMR1_W<1> {
                SLP_CLK_TMR1_W::new(self)
            }
            ///Bit 2 - RWA, close TMR2 clock
            #[inline(always)]
            #[must_use]
            pub fn slp_clk_tmr2(&mut self) -> SLP_CLK_TMR2_W<2> {
                SLP_CLK_TMR2_W::new(self)
            }
            ///Bit 3 - RWA, close TMR3 clock
            #[inline(always)]
            #[must_use]
            pub fn slp_clk_tmr3(&mut self) -> SLP_CLK_TMR3_W<3> {
                SLP_CLK_TMR3_W::new(self)
            }
            ///Bit 4 - RWA, close UART0 clock
            #[inline(always)]
            #[must_use]
            pub fn slp_clk_uart0(&mut self) -> SLP_CLK_UART0_W<4> {
                SLP_CLK_UART0_W::new(self)
            }
            ///Bit 5 - RWA, close UART1 clock
            #[inline(always)]
            #[must_use]
            pub fn slp_clk_uart1(&mut self) -> SLP_CLK_UART1_W<5> {
                SLP_CLK_UART1_W::new(self)
            }
            ///Bit 6 - RWA, close UART2 clock
            #[inline(always)]
            #[must_use]
            pub fn slp_clk_uart2(&mut self) -> SLP_CLK_UART2_W<6> {
                SLP_CLK_UART2_W::new(self)
            }
            ///Bit 7 - RWA, close UART3 clock
            #[inline(always)]
            #[must_use]
            pub fn slp_clk_uart3(&mut self) -> SLP_CLK_UART3_W<7> {
                SLP_CLK_UART3_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RWA, sleep clock off control byte 0, SAM
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [slp_clk_off0](index.html) module
        pub struct SLP_CLK_OFF0_SPEC;
        impl crate::RegisterSpec for SLP_CLK_OFF0_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [slp_clk_off0::R](R) reader structure
        impl crate::Readable for SLP_CLK_OFF0_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [slp_clk_off0::W](W) writer structure
        impl crate::Writable for SLP_CLK_OFF0_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets SLP_CLK_OFF0 to value 0
        impl crate::Resettable for SLP_CLK_OFF0_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///SLP_CLK_OFF1 (rw) register accessor: an alias for `Reg<SLP_CLK_OFF1_SPEC>`
    pub type SLP_CLK_OFF1 = crate::Reg<slp_clk_off1::SLP_CLK_OFF1_SPEC>;
    ///RWA, sleep clock off control byte 1, SAM
    pub mod slp_clk_off1 {
        ///Register `SLP_CLK_OFF1` reader
        pub struct R(crate::R<SLP_CLK_OFF1_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<SLP_CLK_OFF1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<SLP_CLK_OFF1_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<SLP_CLK_OFF1_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `SLP_CLK_OFF1` writer
        pub struct W(crate::W<SLP_CLK_OFF1_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<SLP_CLK_OFF1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<SLP_CLK_OFF1_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<SLP_CLK_OFF1_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `SLP_CLK_SPI0` reader - RWA, close SPI0 clock
        pub type SLP_CLK_SPI0_R = crate::BitReader<bool>;
        ///Field `SLP_CLK_SPI0` writer - RWA, close SPI0 clock
        pub type SLP_CLK_SPI0_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, SLP_CLK_OFF1_SPEC, bool, O>;
        ///Field `SLP_CLK_SPI1` reader - RWA, close SPI1 clock
        pub type SLP_CLK_SPI1_R = crate::BitReader<bool>;
        ///Field `SLP_CLK_SPI1` writer - RWA, close SPI1 clock
        pub type SLP_CLK_SPI1_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, SLP_CLK_OFF1_SPEC, bool, O>;
        ///Field `SLP_CLK_PWMX` reader - RWA, close PWMx clock
        pub type SLP_CLK_PWMX_R = crate::BitReader<bool>;
        ///Field `SLP_CLK_PWMX` writer - RWA, close PWMx clock
        pub type SLP_CLK_PWMX_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, SLP_CLK_OFF1_SPEC, bool, O>;
        ///Field `SLP_CLK_I2C` reader - RWA, close I2C clock
        pub type SLP_CLK_I2C_R = crate::BitReader<bool>;
        ///Field `SLP_CLK_I2C` writer - RWA, close I2C clock
        pub type SLP_CLK_I2C_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, SLP_CLK_OFF1_SPEC, bool, O>;
        ///Field `SLP_CLK_USB` reader - RWA, close USB clock
        pub type SLP_CLK_USB_R = crate::BitReader<bool>;
        ///Field `SLP_CLK_USB` writer - RWA, close USB clock
        pub type SLP_CLK_USB_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, SLP_CLK_OFF1_SPEC, bool, O>;
        ///Field `SLP_CLK_BLE` reader - RWA, close BLE clock
        pub type SLP_CLK_BLE_R = crate::BitReader<bool>;
        ///Field `SLP_CLK_BLE` writer - RWA, close BLE clock
        pub type SLP_CLK_BLE_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, SLP_CLK_OFF1_SPEC, bool, O>;
        impl R {
            ///Bit 0 - RWA, close SPI0 clock
            #[inline(always)]
            pub fn slp_clk_spi0(&self) -> SLP_CLK_SPI0_R {
                SLP_CLK_SPI0_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RWA, close SPI1 clock
            #[inline(always)]
            pub fn slp_clk_spi1(&self) -> SLP_CLK_SPI1_R {
                SLP_CLK_SPI1_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RWA, close PWMx clock
            #[inline(always)]
            pub fn slp_clk_pwmx(&self) -> SLP_CLK_PWMX_R {
                SLP_CLK_PWMX_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RWA, close I2C clock
            #[inline(always)]
            pub fn slp_clk_i2c(&self) -> SLP_CLK_I2C_R {
                SLP_CLK_I2C_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RWA, close USB clock
            #[inline(always)]
            pub fn slp_clk_usb(&self) -> SLP_CLK_USB_R {
                SLP_CLK_USB_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 7 - RWA, close BLE clock
            #[inline(always)]
            pub fn slp_clk_ble(&self) -> SLP_CLK_BLE_R {
                SLP_CLK_BLE_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RWA, close SPI0 clock
            #[inline(always)]
            #[must_use]
            pub fn slp_clk_spi0(&mut self) -> SLP_CLK_SPI0_W<0> {
                SLP_CLK_SPI0_W::new(self)
            }
            ///Bit 1 - RWA, close SPI1 clock
            #[inline(always)]
            #[must_use]
            pub fn slp_clk_spi1(&mut self) -> SLP_CLK_SPI1_W<1> {
                SLP_CLK_SPI1_W::new(self)
            }
            ///Bit 2 - RWA, close PWMx clock
            #[inline(always)]
            #[must_use]
            pub fn slp_clk_pwmx(&mut self) -> SLP_CLK_PWMX_W<2> {
                SLP_CLK_PWMX_W::new(self)
            }
            ///Bit 3 - RWA, close I2C clock
            #[inline(always)]
            #[must_use]
            pub fn slp_clk_i2c(&mut self) -> SLP_CLK_I2C_W<3> {
                SLP_CLK_I2C_W::new(self)
            }
            ///Bit 4 - RWA, close USB clock
            #[inline(always)]
            #[must_use]
            pub fn slp_clk_usb(&mut self) -> SLP_CLK_USB_W<4> {
                SLP_CLK_USB_W::new(self)
            }
            ///Bit 7 - RWA, close BLE clock
            #[inline(always)]
            #[must_use]
            pub fn slp_clk_ble(&mut self) -> SLP_CLK_BLE_W<7> {
                SLP_CLK_BLE_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RWA, sleep clock off control byte 1, SAM
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [slp_clk_off1](index.html) module
        pub struct SLP_CLK_OFF1_SPEC;
        impl crate::RegisterSpec for SLP_CLK_OFF1_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [slp_clk_off1::R](R) reader structure
        impl crate::Readable for SLP_CLK_OFF1_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [slp_clk_off1::W](W) writer structure
        impl crate::Writable for SLP_CLK_OFF1_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets SLP_CLK_OFF1 to value 0
        impl crate::Resettable for SLP_CLK_OFF1_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///SLP_WAKE_CTRL (rw) register accessor: an alias for `Reg<SLP_WAKE_CTRL_SPEC>`
    pub type SLP_WAKE_CTRL = crate::Reg<slp_wake_ctrl::SLP_WAKE_CTRL_SPEC>;
    ///RWA, wake control, SAM
    pub mod slp_wake_ctrl {
        ///Register `SLP_WAKE_CTRL` reader
        pub struct R(crate::R<SLP_WAKE_CTRL_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<SLP_WAKE_CTRL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<SLP_WAKE_CTRL_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<SLP_WAKE_CTRL_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `SLP_WAKE_CTRL` writer
        pub struct W(crate::W<SLP_WAKE_CTRL_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<SLP_WAKE_CTRL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<SLP_WAKE_CTRL_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<SLP_WAKE_CTRL_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `SLP_USB_WAKE` reader - RWA, enable USB waking
        pub type SLP_USB_WAKE_R = crate::BitReader<bool>;
        ///Field `SLP_USB_WAKE` writer - RWA, enable USB waking
        pub type SLP_USB_WAKE_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, SLP_WAKE_CTRL_SPEC, bool, O>;
        ///Field `SLP_USB2_WAKE` reader - RWA, enable USB2 waking
        pub type SLP_USB2_WAKE_R = crate::BitReader<bool>;
        ///Field `SLP_USB2_WAKE` writer - RWA, enable USB2 waking
        pub type SLP_USB2_WAKE_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, SLP_WAKE_CTRL_SPEC, bool, O>;
        ///Field `SLP_RTC_WAKE` reader - RWA, enable RTC waking
        pub type SLP_RTC_WAKE_R = crate::BitReader<bool>;
        ///Field `SLP_RTC_WAKE` writer - RWA, enable RTC waking
        pub type SLP_RTC_WAKE_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, SLP_WAKE_CTRL_SPEC, bool, O>;
        ///Field `SLP_GPIO_WAKE` reader - RWA, enable GPIO waking
        pub type SLP_GPIO_WAKE_R = crate::BitReader<bool>;
        ///Field `SLP_GPIO_WAKE` writer - RWA, enable GPIO waking
        pub type SLP_GPIO_WAKE_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, SLP_WAKE_CTRL_SPEC, bool, O>;
        ///Field `SLP_BAT_WAKE` reader - RWA, enable BAT waking
        pub type SLP_BAT_WAKE_R = crate::BitReader<bool>;
        ///Field `SLP_BAT_WAKE` writer - RWA, enable BAT waking
        pub type SLP_BAT_WAKE_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, SLP_WAKE_CTRL_SPEC, bool, O>;
        ///Field `WAKE_EV_MODE` reader - RWA, event wakeup mode
        pub type WAKE_EV_MODE_R = crate::BitReader<bool>;
        ///Field `WAKE_EV_MODE` writer - RWA, event wakeup mode
        pub type WAKE_EV_MODE_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, SLP_WAKE_CTRL_SPEC, bool, O>;
        impl R {
            ///Bit 0 - RWA, enable USB waking
            #[inline(always)]
            pub fn slp_usb_wake(&self) -> SLP_USB_WAKE_R {
                SLP_USB_WAKE_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RWA, enable USB2 waking
            #[inline(always)]
            pub fn slp_usb2_wake(&self) -> SLP_USB2_WAKE_R {
                SLP_USB2_WAKE_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 3 - RWA, enable RTC waking
            #[inline(always)]
            pub fn slp_rtc_wake(&self) -> SLP_RTC_WAKE_R {
                SLP_RTC_WAKE_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RWA, enable GPIO waking
            #[inline(always)]
            pub fn slp_gpio_wake(&self) -> SLP_GPIO_WAKE_R {
                SLP_GPIO_WAKE_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - RWA, enable BAT waking
            #[inline(always)]
            pub fn slp_bat_wake(&self) -> SLP_BAT_WAKE_R {
                SLP_BAT_WAKE_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - RWA, event wakeup mode
            #[inline(always)]
            pub fn wake_ev_mode(&self) -> WAKE_EV_MODE_R {
                WAKE_EV_MODE_R::new(((self.bits >> 6) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RWA, enable USB waking
            #[inline(always)]
            #[must_use]
            pub fn slp_usb_wake(&mut self) -> SLP_USB_WAKE_W<0> {
                SLP_USB_WAKE_W::new(self)
            }
            ///Bit 1 - RWA, enable USB2 waking
            #[inline(always)]
            #[must_use]
            pub fn slp_usb2_wake(&mut self) -> SLP_USB2_WAKE_W<1> {
                SLP_USB2_WAKE_W::new(self)
            }
            ///Bit 3 - RWA, enable RTC waking
            #[inline(always)]
            #[must_use]
            pub fn slp_rtc_wake(&mut self) -> SLP_RTC_WAKE_W<3> {
                SLP_RTC_WAKE_W::new(self)
            }
            ///Bit 4 - RWA, enable GPIO waking
            #[inline(always)]
            #[must_use]
            pub fn slp_gpio_wake(&mut self) -> SLP_GPIO_WAKE_W<4> {
                SLP_GPIO_WAKE_W::new(self)
            }
            ///Bit 5 - RWA, enable BAT waking
            #[inline(always)]
            #[must_use]
            pub fn slp_bat_wake(&mut self) -> SLP_BAT_WAKE_W<5> {
                SLP_BAT_WAKE_W::new(self)
            }
            ///Bit 6 - RWA, event wakeup mode
            #[inline(always)]
            #[must_use]
            pub fn wake_ev_mode(&mut self) -> WAKE_EV_MODE_W<6> {
                WAKE_EV_MODE_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RWA, wake control, SAM
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [slp_wake_ctrl](index.html) module
        pub struct SLP_WAKE_CTRL_SPEC;
        impl crate::RegisterSpec for SLP_WAKE_CTRL_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [slp_wake_ctrl::R](R) reader structure
        impl crate::Readable for SLP_WAKE_CTRL_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [slp_wake_ctrl::W](W) writer structure
        impl crate::Writable for SLP_WAKE_CTRL_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets SLP_WAKE_CTRL to value 0x20
        impl crate::Resettable for SLP_WAKE_CTRL_SPEC {
            const RESET_VALUE: Self::Ux = 0x20;
        }
    }
    ///SLP_POWER_CTRL (rw) register accessor: an alias for `Reg<SLP_POWER_CTRL_SPEC>`
    pub type SLP_POWER_CTRL = crate::Reg<slp_power_ctrl::SLP_POWER_CTRL_SPEC>;
    ///RWA, peripherals power down control, SAM
    pub mod slp_power_ctrl {
        ///Register `SLP_POWER_CTRL` reader
        pub struct R(crate::R<SLP_POWER_CTRL_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<SLP_POWER_CTRL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<SLP_POWER_CTRL_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<SLP_POWER_CTRL_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `SLP_POWER_CTRL` writer
        pub struct W(crate::W<SLP_POWER_CTRL_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<SLP_POWER_CTRL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<SLP_POWER_CTRL_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<SLP_POWER_CTRL_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `WAKE_DLY_MOD` reader - RWA, wakeup delay time selection
        pub type WAKE_DLY_MOD_R = crate::FieldReader<u8, u8>;
        ///Field `WAKE_DLY_MOD` writer - RWA, wakeup delay time selection
        pub type WAKE_DLY_MOD_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, SLP_POWER_CTRL_SPEC, u8, u8, 2, O>;
        ///Field `SLP_CLK_RAMX` reader - RWA, close main SRAM clock
        pub type SLP_CLK_RAMX_R = crate::BitReader<bool>;
        ///Field `SLP_CLK_RAMX` writer - RWA, close main SRAM clock
        pub type SLP_CLK_RAMX_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, SLP_POWER_CTRL_SPEC, bool, O>;
        ///Field `SLP_CLK_RAM2K` reader - RWA, close retention 2KB SRAM clock
        pub type SLP_CLK_RAM2K_R = crate::BitReader<bool>;
        ///Field `SLP_CLK_RAM2K` writer - RWA, close retention 2KB SRAM clock
        pub type SLP_CLK_RAM2K_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, SLP_POWER_CTRL_SPEC, bool, O>;
        ///Field `RAM_RET_LV` reader - RWA, SRAM retention voltage selection
        pub type RAM_RET_LV_R = crate::BitReader<bool>;
        ///Field `RAM_RET_LV` writer - RWA, SRAM retention voltage selection
        pub type RAM_RET_LV_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, SLP_POWER_CTRL_SPEC, bool, O>;
        impl R {
            ///Bits 0:1 - RWA, wakeup delay time selection
            #[inline(always)]
            pub fn wake_dly_mod(&self) -> WAKE_DLY_MOD_R {
                WAKE_DLY_MOD_R::new(self.bits & 3)
            }
            ///Bit 4 - RWA, close main SRAM clock
            #[inline(always)]
            pub fn slp_clk_ramx(&self) -> SLP_CLK_RAMX_R {
                SLP_CLK_RAMX_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - RWA, close retention 2KB SRAM clock
            #[inline(always)]
            pub fn slp_clk_ram2k(&self) -> SLP_CLK_RAM2K_R {
                SLP_CLK_RAM2K_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - RWA, SRAM retention voltage selection
            #[inline(always)]
            pub fn ram_ret_lv(&self) -> RAM_RET_LV_R {
                RAM_RET_LV_R::new(((self.bits >> 6) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:1 - RWA, wakeup delay time selection
            #[inline(always)]
            #[must_use]
            pub fn wake_dly_mod(&mut self) -> WAKE_DLY_MOD_W<0> {
                WAKE_DLY_MOD_W::new(self)
            }
            ///Bit 4 - RWA, close main SRAM clock
            #[inline(always)]
            #[must_use]
            pub fn slp_clk_ramx(&mut self) -> SLP_CLK_RAMX_W<4> {
                SLP_CLK_RAMX_W::new(self)
            }
            ///Bit 5 - RWA, close retention 2KB SRAM clock
            #[inline(always)]
            #[must_use]
            pub fn slp_clk_ram2k(&mut self) -> SLP_CLK_RAM2K_W<5> {
                SLP_CLK_RAM2K_W::new(self)
            }
            ///Bit 6 - RWA, SRAM retention voltage selection
            #[inline(always)]
            #[must_use]
            pub fn ram_ret_lv(&mut self) -> RAM_RET_LV_W<6> {
                RAM_RET_LV_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RWA, peripherals power down control, SAM
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [slp_power_ctrl](index.html) module
        pub struct SLP_POWER_CTRL_SPEC;
        impl crate::RegisterSpec for SLP_POWER_CTRL_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [slp_power_ctrl::R](R) reader structure
        impl crate::Readable for SLP_POWER_CTRL_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [slp_power_ctrl::W](W) writer structure
        impl crate::Writable for SLP_POWER_CTRL_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets SLP_POWER_CTRL to value 0
        impl crate::Resettable for SLP_POWER_CTRL_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///PIN_ALTERNATE (rw) register accessor: an alias for `Reg<PIN_ALTERNATE_SPEC>`
    pub type PIN_ALTERNATE = crate::Reg<pin_alternate::PIN_ALTERNATE_SPEC>;
    ///RW, function pin alternate configuration
    pub mod pin_alternate {
        ///Register `PIN_ALTERNATE` reader
        pub struct R(crate::R<PIN_ALTERNATE_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PIN_ALTERNATE_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<PIN_ALTERNATE_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<PIN_ALTERNATE_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `PIN_ALTERNATE` writer
        pub struct W(crate::W<PIN_ALTERNATE_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PIN_ALTERNATE_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<PIN_ALTERNATE_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<PIN_ALTERNATE_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `PIN_TMR0` reader - RW, TMR0 alternate pin enable
        pub type PIN_TMR0_R = crate::BitReader<bool>;
        ///Field `PIN_TMR0` writer - RW, TMR0 alternate pin enable
        pub type PIN_TMR0_W<'a, const O: u8> =
            crate::BitWriter<'a, u16, PIN_ALTERNATE_SPEC, bool, O>;
        ///Field `PIN_TMR1` reader - RW, TMR1 alternate pin enable
        pub type PIN_TMR1_R = crate::BitReader<bool>;
        ///Field `PIN_TMR1` writer - RW, TMR1 alternate pin enable
        pub type PIN_TMR1_W<'a, const O: u8> =
            crate::BitWriter<'a, u16, PIN_ALTERNATE_SPEC, bool, O>;
        ///Field `PIN_TMR2` reader - RW, TMR2 alternate pin enable
        pub type PIN_TMR2_R = crate::BitReader<bool>;
        ///Field `PIN_TMR2` writer - RW, TMR2 alternate pin enable
        pub type PIN_TMR2_W<'a, const O: u8> =
            crate::BitWriter<'a, u16, PIN_ALTERNATE_SPEC, bool, O>;
        ///Field `PIN_TMR3` reader - RW, TMR3 alternate pin enable
        pub type PIN_TMR3_R = crate::BitReader<bool>;
        ///Field `PIN_TMR3` writer - RW, TMR3 alternate pin enable
        pub type PIN_TMR3_W<'a, const O: u8> =
            crate::BitWriter<'a, u16, PIN_ALTERNATE_SPEC, bool, O>;
        ///Field `PIN_UART0` reader - RW, RXD0/TXD0 alternate pin enable
        pub type PIN_UART0_R = crate::BitReader<bool>;
        ///Field `PIN_UART0` writer - RW, RXD0/TXD0 alternate pin enable
        pub type PIN_UART0_W<'a, const O: u8> =
            crate::BitWriter<'a, u16, PIN_ALTERNATE_SPEC, bool, O>;
        ///Field `PIN_UART1` reader - RW, RXD1/TXD1 alternate pin enable
        pub type PIN_UART1_R = crate::BitReader<bool>;
        ///Field `PIN_UART1` writer - RW, RXD1/TXD1 alternate pin enable
        pub type PIN_UART1_W<'a, const O: u8> =
            crate::BitWriter<'a, u16, PIN_ALTERNATE_SPEC, bool, O>;
        ///Field `PIN_UART2` reader - RW, RXD2/TXD2 alternate pin enable
        pub type PIN_UART2_R = crate::BitReader<bool>;
        ///Field `PIN_UART2` writer - RW, RXD2/TXD2 alternate pin enable
        pub type PIN_UART2_W<'a, const O: u8> =
            crate::BitWriter<'a, u16, PIN_ALTERNATE_SPEC, bool, O>;
        ///Field `PIN_UART3` reader - RW, RXD3/TXD3 alternate pin enable
        pub type PIN_UART3_R = crate::BitReader<bool>;
        ///Field `PIN_UART3` writer - RW, RXD3/TXD3 alternate pin enable
        pub type PIN_UART3_W<'a, const O: u8> =
            crate::BitWriter<'a, u16, PIN_ALTERNATE_SPEC, bool, O>;
        ///Field `PIN_SPI0` reader - RW, SCS/SCK0/MOSI/MISO alternate pin enable
        pub type PIN_SPI0_R = crate::BitReader<bool>;
        ///Field `PIN_SPI0` writer - RW, SCS/SCK0/MOSI/MISO alternate pin enable
        pub type PIN_SPI0_W<'a, const O: u8> =
            crate::BitWriter<'a, u16, PIN_ALTERNATE_SPEC, bool, O>;
        ///Field `PIN_PWMX` reader - RW, PWM4/PWM5/PWM7/PWM8/PWM9 alternate pin enable
        pub type PIN_PWMX_R = crate::BitReader<bool>;
        ///Field `PIN_PWMX` writer - RW, PWM4/PWM5/PWM7/PWM8/PWM9 alternate pin enable
        pub type PIN_PWMX_W<'a, const O: u8> =
            crate::BitWriter<'a, u16, PIN_ALTERNATE_SPEC, bool, O>;
        ///Field `PIN_I2C` reader - RW, SCL/SDA alternate pin enable
        pub type PIN_I2C_R = crate::BitReader<bool>;
        ///Field `PIN_I2C` writer - RW, SCL/SDA alternate pin enable
        pub type PIN_I2C_W<'a, const O: u8> =
            crate::BitWriter<'a, u16, PIN_ALTERNATE_SPEC, bool, O>;
        ///Field `PIN_MODEM` reader - RW, DSR/DTR alternate pin enable
        pub type PIN_MODEM_R = crate::BitReader<bool>;
        ///Field `PIN_MODEM` writer - RW, DSR/DTR alternate pin enable
        pub type PIN_MODEM_W<'a, const O: u8> =
            crate::BitWriter<'a, u16, PIN_ALTERNATE_SPEC, bool, O>;
        ///Field `PIN_INTX` reader - RW, interrupt INT24/INT25 alternate pin enable
        pub type PIN_INTX_R = crate::BitReader<bool>;
        ///Field `PIN_INTX` writer - RW, interrupt INT24/INT25 alternate pin enable
        pub type PIN_INTX_W<'a, const O: u8> =
            crate::BitWriter<'a, u16, PIN_ALTERNATE_SPEC, bool, O>;
        ///Field `PIN_U0_INV` reader - RW, SCL/SDA alternRW, RXD0/RXD0_/TXD0/TXD0_ invert input/output enableate pin enable
        pub type PIN_U0_INV_R = crate::BitReader<bool>;
        ///Field `PIN_U0_INV` writer - RW, SCL/SDA alternRW, RXD0/RXD0_/TXD0/TXD0_ invert input/output enableate pin enable
        pub type PIN_U0_INV_W<'a, const O: u8> =
            crate::BitWriter<'a, u16, PIN_ALTERNATE_SPEC, bool, O>;
        ///Field `RF_ANT_SW_EN` reader - RW, RF antenna switch control output enable
        pub type RF_ANT_SW_EN_R = crate::BitReader<bool>;
        ///Field `RF_ANT_SW_EN` writer - RW, RF antenna switch control output enable
        pub type RF_ANT_SW_EN_W<'a, const O: u8> =
            crate::BitWriter<'a, u16, PIN_ALTERNATE_SPEC, bool, O>;
        impl R {
            ///Bit 0 - RW, TMR0 alternate pin enable
            #[inline(always)]
            pub fn pin_tmr0(&self) -> PIN_TMR0_R {
                PIN_TMR0_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RW, TMR1 alternate pin enable
            #[inline(always)]
            pub fn pin_tmr1(&self) -> PIN_TMR1_R {
                PIN_TMR1_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RW, TMR2 alternate pin enable
            #[inline(always)]
            pub fn pin_tmr2(&self) -> PIN_TMR2_R {
                PIN_TMR2_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RW, TMR3 alternate pin enable
            #[inline(always)]
            pub fn pin_tmr3(&self) -> PIN_TMR3_R {
                PIN_TMR3_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RW, RXD0/TXD0 alternate pin enable
            #[inline(always)]
            pub fn pin_uart0(&self) -> PIN_UART0_R {
                PIN_UART0_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - RW, RXD1/TXD1 alternate pin enable
            #[inline(always)]
            pub fn pin_uart1(&self) -> PIN_UART1_R {
                PIN_UART1_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - RW, RXD2/TXD2 alternate pin enable
            #[inline(always)]
            pub fn pin_uart2(&self) -> PIN_UART2_R {
                PIN_UART2_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - RW, RXD3/TXD3 alternate pin enable
            #[inline(always)]
            pub fn pin_uart3(&self) -> PIN_UART3_R {
                PIN_UART3_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bit 8 - RW, SCS/SCK0/MOSI/MISO alternate pin enable
            #[inline(always)]
            pub fn pin_spi0(&self) -> PIN_SPI0_R {
                PIN_SPI0_R::new(((self.bits >> 8) & 1) != 0)
            }
            ///Bit 10 - RW, PWM4/PWM5/PWM7/PWM8/PWM9 alternate pin enable
            #[inline(always)]
            pub fn pin_pwmx(&self) -> PIN_PWMX_R {
                PIN_PWMX_R::new(((self.bits >> 10) & 1) != 0)
            }
            ///Bit 11 - RW, SCL/SDA alternate pin enable
            #[inline(always)]
            pub fn pin_i2c(&self) -> PIN_I2C_R {
                PIN_I2C_R::new(((self.bits >> 11) & 1) != 0)
            }
            ///Bit 12 - RW, DSR/DTR alternate pin enable
            #[inline(always)]
            pub fn pin_modem(&self) -> PIN_MODEM_R {
                PIN_MODEM_R::new(((self.bits >> 12) & 1) != 0)
            }
            ///Bit 13 - RW, interrupt INT24/INT25 alternate pin enable
            #[inline(always)]
            pub fn pin_intx(&self) -> PIN_INTX_R {
                PIN_INTX_R::new(((self.bits >> 13) & 1) != 0)
            }
            ///Bit 14 - RW, SCL/SDA alternRW, RXD0/RXD0_/TXD0/TXD0_ invert input/output enableate pin enable
            #[inline(always)]
            pub fn pin_u0_inv(&self) -> PIN_U0_INV_R {
                PIN_U0_INV_R::new(((self.bits >> 14) & 1) != 0)
            }
            ///Bit 15 - RW, RF antenna switch control output enable
            #[inline(always)]
            pub fn rf_ant_sw_en(&self) -> RF_ANT_SW_EN_R {
                RF_ANT_SW_EN_R::new(((self.bits >> 15) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RW, TMR0 alternate pin enable
            #[inline(always)]
            #[must_use]
            pub fn pin_tmr0(&mut self) -> PIN_TMR0_W<0> {
                PIN_TMR0_W::new(self)
            }
            ///Bit 1 - RW, TMR1 alternate pin enable
            #[inline(always)]
            #[must_use]
            pub fn pin_tmr1(&mut self) -> PIN_TMR1_W<1> {
                PIN_TMR1_W::new(self)
            }
            ///Bit 2 - RW, TMR2 alternate pin enable
            #[inline(always)]
            #[must_use]
            pub fn pin_tmr2(&mut self) -> PIN_TMR2_W<2> {
                PIN_TMR2_W::new(self)
            }
            ///Bit 3 - RW, TMR3 alternate pin enable
            #[inline(always)]
            #[must_use]
            pub fn pin_tmr3(&mut self) -> PIN_TMR3_W<3> {
                PIN_TMR3_W::new(self)
            }
            ///Bit 4 - RW, RXD0/TXD0 alternate pin enable
            #[inline(always)]
            #[must_use]
            pub fn pin_uart0(&mut self) -> PIN_UART0_W<4> {
                PIN_UART0_W::new(self)
            }
            ///Bit 5 - RW, RXD1/TXD1 alternate pin enable
            #[inline(always)]
            #[must_use]
            pub fn pin_uart1(&mut self) -> PIN_UART1_W<5> {
                PIN_UART1_W::new(self)
            }
            ///Bit 6 - RW, RXD2/TXD2 alternate pin enable
            #[inline(always)]
            #[must_use]
            pub fn pin_uart2(&mut self) -> PIN_UART2_W<6> {
                PIN_UART2_W::new(self)
            }
            ///Bit 7 - RW, RXD3/TXD3 alternate pin enable
            #[inline(always)]
            #[must_use]
            pub fn pin_uart3(&mut self) -> PIN_UART3_W<7> {
                PIN_UART3_W::new(self)
            }
            ///Bit 8 - RW, SCS/SCK0/MOSI/MISO alternate pin enable
            #[inline(always)]
            #[must_use]
            pub fn pin_spi0(&mut self) -> PIN_SPI0_W<8> {
                PIN_SPI0_W::new(self)
            }
            ///Bit 10 - RW, PWM4/PWM5/PWM7/PWM8/PWM9 alternate pin enable
            #[inline(always)]
            #[must_use]
            pub fn pin_pwmx(&mut self) -> PIN_PWMX_W<10> {
                PIN_PWMX_W::new(self)
            }
            ///Bit 11 - RW, SCL/SDA alternate pin enable
            #[inline(always)]
            #[must_use]
            pub fn pin_i2c(&mut self) -> PIN_I2C_W<11> {
                PIN_I2C_W::new(self)
            }
            ///Bit 12 - RW, DSR/DTR alternate pin enable
            #[inline(always)]
            #[must_use]
            pub fn pin_modem(&mut self) -> PIN_MODEM_W<12> {
                PIN_MODEM_W::new(self)
            }
            ///Bit 13 - RW, interrupt INT24/INT25 alternate pin enable
            #[inline(always)]
            #[must_use]
            pub fn pin_intx(&mut self) -> PIN_INTX_W<13> {
                PIN_INTX_W::new(self)
            }
            ///Bit 14 - RW, SCL/SDA alternRW, RXD0/RXD0_/TXD0/TXD0_ invert input/output enableate pin enable
            #[inline(always)]
            #[must_use]
            pub fn pin_u0_inv(&mut self) -> PIN_U0_INV_W<14> {
                PIN_U0_INV_W::new(self)
            }
            ///Bit 15 - RW, RF antenna switch control output enable
            #[inline(always)]
            #[must_use]
            pub fn rf_ant_sw_en(&mut self) -> RF_ANT_SW_EN_W<15> {
                RF_ANT_SW_EN_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, function pin alternate configuration
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [pin_alternate](index.html) module
        pub struct PIN_ALTERNATE_SPEC;
        impl crate::RegisterSpec for PIN_ALTERNATE_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [pin_alternate::R](R) reader structure
        impl crate::Readable for PIN_ALTERNATE_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [pin_alternate::W](W) writer structure
        impl crate::Writable for PIN_ALTERNATE_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets PIN_ALTERNATE to value 0
        impl crate::Resettable for PIN_ALTERNATE_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///PIN_ANALOG_IE (rw) register accessor: an alias for `Reg<PIN_ANALOG_IE_SPEC>`
    pub type PIN_ANALOG_IE = crate::Reg<pin_analog_ie::PIN_ANALOG_IE_SPEC>;
    ///RW, analog pin enable and digital input disable
    pub mod pin_analog_ie {
        ///Register `PIN_ANALOG_IE` reader
        pub struct R(crate::R<PIN_ANALOG_IE_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PIN_ANALOG_IE_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<PIN_ANALOG_IE_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<PIN_ANALOG_IE_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `PIN_ANALOG_IE` writer
        pub struct W(crate::W<PIN_ANALOG_IE_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PIN_ANALOG_IE_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<PIN_ANALOG_IE_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<PIN_ANALOG_IE_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `PIN_ADC8_9_IE` reader - RW, ADC/TouchKey channel 9/8 digital input disable
        pub type PIN_ADC8_9_IE_R = crate::BitReader<bool>;
        ///Field `PIN_ADC8_9_IE` writer - RW, ADC/TouchKey channel 9/8 digital input disable
        pub type PIN_ADC8_9_IE_W<'a, const O: u8> =
            crate::BitWriter<'a, u16, PIN_ANALOG_IE_SPEC, bool, O>;
        ///Field `PIN_ADC6_7_IE` reader - RW, ADC/TouchKey channel 7/6 digital input disable
        pub type PIN_ADC6_7_IE_R = crate::BitReader<bool>;
        ///Field `PIN_ADC6_7_IE` writer - RW, ADC/TouchKey channel 7/6 digital input disable
        pub type PIN_ADC6_7_IE_W<'a, const O: u8> =
            crate::BitWriter<'a, u16, PIN_ANALOG_IE_SPEC, bool, O>;
        ///Field `PIN_ADC10_IE` reader - RW, ADC/TouchKey channel 10 digital input disable
        pub type PIN_ADC10_IE_R = crate::BitReader<bool>;
        ///Field `PIN_ADC10_IE` writer - RW, ADC/TouchKey channel 10 digital input disable
        pub type PIN_ADC10_IE_W<'a, const O: u8> =
            crate::BitWriter<'a, u16, PIN_ANALOG_IE_SPEC, bool, O>;
        ///Field `PIN_ADC11_IE` reader - RW, ADC/TouchKey channel 11 digital input disable
        pub type PIN_ADC11_IE_R = crate::BitReader<bool>;
        ///Field `PIN_ADC11_IE` writer - RW, ADC/TouchKey channel 11 digital input disable
        pub type PIN_ADC11_IE_W<'a, const O: u8> =
            crate::BitWriter<'a, u16, PIN_ANALOG_IE_SPEC, bool, O>;
        ///Field `PIN_USB2_DP_PU` reader - RW,USB2 UDP internal pullup resistance enable
        pub type PIN_USB2_DP_PU_R = crate::BitReader<bool>;
        ///Field `PIN_USB2_DP_PU` writer - RW,USB2 UDP internal pullup resistance enable
        pub type PIN_USB2_DP_PU_W<'a, const O: u8> =
            crate::BitWriter<'a, u16, PIN_ANALOG_IE_SPEC, bool, O>;
        ///Field `PIN_USB2_IE` reader - RW, USB analog I/O enable: 0=analog I/O disable, 1=analog I/O enable
        pub type PIN_USB2_IE_R = crate::BitReader<bool>;
        ///Field `PIN_USB2_IE` writer - RW, USB analog I/O enable: 0=analog I/O disable, 1=analog I/O enable
        pub type PIN_USB2_IE_W<'a, const O: u8> =
            crate::BitWriter<'a, u16, PIN_ANALOG_IE_SPEC, bool, O>;
        ///Field `PIN_USB_DP_PU` reader - RW,USB UDP internal pullup resistance enable
        pub type PIN_USB_DP_PU_R = crate::BitReader<bool>;
        ///Field `PIN_USB_DP_PU` writer - RW,USB UDP internal pullup resistance enable
        pub type PIN_USB_DP_PU_W<'a, const O: u8> =
            crate::BitWriter<'a, u16, PIN_ANALOG_IE_SPEC, bool, O>;
        ///Field `PIN_USB_IE` reader - RW, USB analog I/O enable: 0=analog I/O disable, 1=analog I/O enable
        pub type PIN_USB_IE_R = crate::BitReader<bool>;
        ///Field `PIN_USB_IE` writer - RW, USB analog I/O enable: 0=analog I/O disable, 1=analog I/O enable
        pub type PIN_USB_IE_W<'a, const O: u8> =
            crate::BitWriter<'a, u16, PIN_ANALOG_IE_SPEC, bool, O>;
        ///Field `PIN_ADC0_IE` reader - RW, ADC/TouchKey channel0 digital input disable: 0=digital input enable, 1=digital input disable
        pub type PIN_ADC0_IE_R = crate::BitReader<bool>;
        ///Field `PIN_ADC0_IE` writer - RW, ADC/TouchKey channel0 digital input disable: 0=digital input enable, 1=digital input disable
        pub type PIN_ADC0_IE_W<'a, const O: u8> =
            crate::BitWriter<'a, u16, PIN_ANALOG_IE_SPEC, bool, O>;
        ///Field `PIN_ADC1_IE` reader - RW, ADC/TouchKey channel1 digital input disable: 0=digital input enable, 1=digital input disable
        pub type PIN_ADC1_IE_R = crate::BitReader<bool>;
        ///Field `PIN_ADC1_IE` writer - RW, ADC/TouchKey channel1 digital input disable: 0=digital input enable, 1=digital input disable
        pub type PIN_ADC1_IE_W<'a, const O: u8> =
            crate::BitWriter<'a, u16, PIN_ANALOG_IE_SPEC, bool, O>;
        ///Field `PIN_ADC12_IE` reader - RW, ADC/TouchKey channel12 digital input disable: 0=digital input enable, 1=digital input disable
        pub type PIN_ADC12_IE_R = crate::BitReader<bool>;
        ///Field `PIN_ADC12_IE` writer - RW, ADC/TouchKey channel12 digital input disable: 0=digital input enable, 1=digital input disable
        pub type PIN_ADC12_IE_W<'a, const O: u8> =
            crate::BitWriter<'a, u16, PIN_ANALOG_IE_SPEC, bool, O>;
        ///Field `PIN_ADC13_IE` reader - RW, ADC/TouchKey channel13 digital input disable: 0=digital input enable, 1=digital input disable
        pub type PIN_ADC13_IE_R = crate::BitReader<bool>;
        ///Field `PIN_ADC13_IE` writer - RW, ADC/TouchKey channel13 digital input disable: 0=digital input enable, 1=digital input disable
        pub type PIN_ADC13_IE_W<'a, const O: u8> =
            crate::BitWriter<'a, u16, PIN_ANALOG_IE_SPEC, bool, O>;
        ///Field `PIN_XT32K_IE` reader - RW, external 32KHz oscillator digital input disable: 0=digital input enable, 1=digital input disable
        pub type PIN_XT32K_IE_R = crate::BitReader<bool>;
        ///Field `PIN_XT32K_IE` writer - RW, external 32KHz oscillator digital input disable: 0=digital input enable, 1=digital input disable
        pub type PIN_XT32K_IE_W<'a, const O: u8> =
            crate::BitWriter<'a, u16, PIN_ANALOG_IE_SPEC, bool, O>;
        ///Field `PIN_ADC2_3_IE` reader - RW, ADC/TouchKey channel 2/3 digital input disable: 0=digital input enable, 1=digital input disable
        pub type PIN_ADC2_3_IE_R = crate::BitReader<bool>;
        ///Field `PIN_ADC2_3_IE` writer - RW, ADC/TouchKey channel 2/3 digital input disable: 0=digital input enable, 1=digital input disable
        pub type PIN_ADC2_3_IE_W<'a, const O: u8> =
            crate::BitWriter<'a, u16, PIN_ANALOG_IE_SPEC, bool, O>;
        ///Field `PIN_ADC4_5_IE` reader - RW, ADC/TouchKey channel 4/5 digital input disable: 0=digital input enable, 1=digital input disable
        pub type PIN_ADC4_5_IE_R = crate::BitReader<bool>;
        ///Field `PIN_ADC4_5_IE` writer - RW, ADC/TouchKey channel 4/5 digital input disable: 0=digital input enable, 1=digital input disable
        pub type PIN_ADC4_5_IE_W<'a, const O: u8> =
            crate::BitWriter<'a, u16, PIN_ANALOG_IE_SPEC, bool, O>;
        impl R {
            ///Bit 0 - RW, ADC/TouchKey channel 9/8 digital input disable
            #[inline(always)]
            pub fn pin_adc8_9_ie(&self) -> PIN_ADC8_9_IE_R {
                PIN_ADC8_9_IE_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RW, ADC/TouchKey channel 7/6 digital input disable
            #[inline(always)]
            pub fn pin_adc6_7_ie(&self) -> PIN_ADC6_7_IE_R {
                PIN_ADC6_7_IE_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RW, ADC/TouchKey channel 10 digital input disable
            #[inline(always)]
            pub fn pin_adc10_ie(&self) -> PIN_ADC10_IE_R {
                PIN_ADC10_IE_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RW, ADC/TouchKey channel 11 digital input disable
            #[inline(always)]
            pub fn pin_adc11_ie(&self) -> PIN_ADC11_IE_R {
                PIN_ADC11_IE_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RW,USB2 UDP internal pullup resistance enable
            #[inline(always)]
            pub fn pin_usb2_dp_pu(&self) -> PIN_USB2_DP_PU_R {
                PIN_USB2_DP_PU_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - RW, USB analog I/O enable: 0=analog I/O disable, 1=analog I/O enable
            #[inline(always)]
            pub fn pin_usb2_ie(&self) -> PIN_USB2_IE_R {
                PIN_USB2_IE_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - RW,USB UDP internal pullup resistance enable
            #[inline(always)]
            pub fn pin_usb_dp_pu(&self) -> PIN_USB_DP_PU_R {
                PIN_USB_DP_PU_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - RW, USB analog I/O enable: 0=analog I/O disable, 1=analog I/O enable
            #[inline(always)]
            pub fn pin_usb_ie(&self) -> PIN_USB_IE_R {
                PIN_USB_IE_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bit 9 - RW, ADC/TouchKey channel0 digital input disable: 0=digital input enable, 1=digital input disable
            #[inline(always)]
            pub fn pin_adc0_ie(&self) -> PIN_ADC0_IE_R {
                PIN_ADC0_IE_R::new(((self.bits >> 9) & 1) != 0)
            }
            ///Bit 10 - RW, ADC/TouchKey channel1 digital input disable: 0=digital input enable, 1=digital input disable
            #[inline(always)]
            pub fn pin_adc1_ie(&self) -> PIN_ADC1_IE_R {
                PIN_ADC1_IE_R::new(((self.bits >> 10) & 1) != 0)
            }
            ///Bit 11 - RW, ADC/TouchKey channel12 digital input disable: 0=digital input enable, 1=digital input disable
            #[inline(always)]
            pub fn pin_adc12_ie(&self) -> PIN_ADC12_IE_R {
                PIN_ADC12_IE_R::new(((self.bits >> 11) & 1) != 0)
            }
            ///Bit 12 - RW, ADC/TouchKey channel13 digital input disable: 0=digital input enable, 1=digital input disable
            #[inline(always)]
            pub fn pin_adc13_ie(&self) -> PIN_ADC13_IE_R {
                PIN_ADC13_IE_R::new(((self.bits >> 12) & 1) != 0)
            }
            ///Bit 13 - RW, external 32KHz oscillator digital input disable: 0=digital input enable, 1=digital input disable
            #[inline(always)]
            pub fn pin_xt32k_ie(&self) -> PIN_XT32K_IE_R {
                PIN_XT32K_IE_R::new(((self.bits >> 13) & 1) != 0)
            }
            ///Bit 14 - RW, ADC/TouchKey channel 2/3 digital input disable: 0=digital input enable, 1=digital input disable
            #[inline(always)]
            pub fn pin_adc2_3_ie(&self) -> PIN_ADC2_3_IE_R {
                PIN_ADC2_3_IE_R::new(((self.bits >> 14) & 1) != 0)
            }
            ///Bit 15 - RW, ADC/TouchKey channel 4/5 digital input disable: 0=digital input enable, 1=digital input disable
            #[inline(always)]
            pub fn pin_adc4_5_ie(&self) -> PIN_ADC4_5_IE_R {
                PIN_ADC4_5_IE_R::new(((self.bits >> 15) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RW, ADC/TouchKey channel 9/8 digital input disable
            #[inline(always)]
            #[must_use]
            pub fn pin_adc8_9_ie(&mut self) -> PIN_ADC8_9_IE_W<0> {
                PIN_ADC8_9_IE_W::new(self)
            }
            ///Bit 1 - RW, ADC/TouchKey channel 7/6 digital input disable
            #[inline(always)]
            #[must_use]
            pub fn pin_adc6_7_ie(&mut self) -> PIN_ADC6_7_IE_W<1> {
                PIN_ADC6_7_IE_W::new(self)
            }
            ///Bit 2 - RW, ADC/TouchKey channel 10 digital input disable
            #[inline(always)]
            #[must_use]
            pub fn pin_adc10_ie(&mut self) -> PIN_ADC10_IE_W<2> {
                PIN_ADC10_IE_W::new(self)
            }
            ///Bit 3 - RW, ADC/TouchKey channel 11 digital input disable
            #[inline(always)]
            #[must_use]
            pub fn pin_adc11_ie(&mut self) -> PIN_ADC11_IE_W<3> {
                PIN_ADC11_IE_W::new(self)
            }
            ///Bit 4 - RW,USB2 UDP internal pullup resistance enable
            #[inline(always)]
            #[must_use]
            pub fn pin_usb2_dp_pu(&mut self) -> PIN_USB2_DP_PU_W<4> {
                PIN_USB2_DP_PU_W::new(self)
            }
            ///Bit 5 - RW, USB analog I/O enable: 0=analog I/O disable, 1=analog I/O enable
            #[inline(always)]
            #[must_use]
            pub fn pin_usb2_ie(&mut self) -> PIN_USB2_IE_W<5> {
                PIN_USB2_IE_W::new(self)
            }
            ///Bit 6 - RW,USB UDP internal pullup resistance enable
            #[inline(always)]
            #[must_use]
            pub fn pin_usb_dp_pu(&mut self) -> PIN_USB_DP_PU_W<6> {
                PIN_USB_DP_PU_W::new(self)
            }
            ///Bit 7 - RW, USB analog I/O enable: 0=analog I/O disable, 1=analog I/O enable
            #[inline(always)]
            #[must_use]
            pub fn pin_usb_ie(&mut self) -> PIN_USB_IE_W<7> {
                PIN_USB_IE_W::new(self)
            }
            ///Bit 9 - RW, ADC/TouchKey channel0 digital input disable: 0=digital input enable, 1=digital input disable
            #[inline(always)]
            #[must_use]
            pub fn pin_adc0_ie(&mut self) -> PIN_ADC0_IE_W<9> {
                PIN_ADC0_IE_W::new(self)
            }
            ///Bit 10 - RW, ADC/TouchKey channel1 digital input disable: 0=digital input enable, 1=digital input disable
            #[inline(always)]
            #[must_use]
            pub fn pin_adc1_ie(&mut self) -> PIN_ADC1_IE_W<10> {
                PIN_ADC1_IE_W::new(self)
            }
            ///Bit 11 - RW, ADC/TouchKey channel12 digital input disable: 0=digital input enable, 1=digital input disable
            #[inline(always)]
            #[must_use]
            pub fn pin_adc12_ie(&mut self) -> PIN_ADC12_IE_W<11> {
                PIN_ADC12_IE_W::new(self)
            }
            ///Bit 12 - RW, ADC/TouchKey channel13 digital input disable: 0=digital input enable, 1=digital input disable
            #[inline(always)]
            #[must_use]
            pub fn pin_adc13_ie(&mut self) -> PIN_ADC13_IE_W<12> {
                PIN_ADC13_IE_W::new(self)
            }
            ///Bit 13 - RW, external 32KHz oscillator digital input disable: 0=digital input enable, 1=digital input disable
            #[inline(always)]
            #[must_use]
            pub fn pin_xt32k_ie(&mut self) -> PIN_XT32K_IE_W<13> {
                PIN_XT32K_IE_W::new(self)
            }
            ///Bit 14 - RW, ADC/TouchKey channel 2/3 digital input disable: 0=digital input enable, 1=digital input disable
            #[inline(always)]
            #[must_use]
            pub fn pin_adc2_3_ie(&mut self) -> PIN_ADC2_3_IE_W<14> {
                PIN_ADC2_3_IE_W::new(self)
            }
            ///Bit 15 - RW, ADC/TouchKey channel 4/5 digital input disable: 0=digital input enable, 1=digital input disable
            #[inline(always)]
            #[must_use]
            pub fn pin_adc4_5_ie(&mut self) -> PIN_ADC4_5_IE_W<15> {
                PIN_ADC4_5_IE_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, analog pin enable and digital input disable
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [pin_analog_ie](index.html) module
        pub struct PIN_ANALOG_IE_SPEC;
        impl crate::RegisterSpec for PIN_ANALOG_IE_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [pin_analog_ie::R](R) reader structure
        impl crate::Readable for PIN_ANALOG_IE_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [pin_analog_ie::W](W) writer structure
        impl crate::Writable for PIN_ANALOG_IE_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets PIN_ANALOG_IE to value 0
        impl crate::Resettable for PIN_ANALOG_IE_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///POWER_PLAN (rw) register accessor: an alias for `Reg<POWER_PLAN_SPEC>`
    pub type POWER_PLAN = crate::Reg<power_plan::POWER_PLAN_SPEC>;
    ///RWA, power plan before sleep instruction, SAM
    pub mod power_plan {
        ///Register `POWER_PLAN` reader
        pub struct R(crate::R<POWER_PLAN_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<POWER_PLAN_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<POWER_PLAN_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<POWER_PLAN_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `POWER_PLAN` writer
        pub struct W(crate::W<POWER_PLAN_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<POWER_PLAN_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<POWER_PLAN_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<POWER_PLAN_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `PWR_XROM` reader - RWA, power for retention 2KB SRAM
        pub type PWR_XROM_R = crate::BitReader<bool>;
        ///Field `PWR_XROM` writer - RWA, power for retention 2KB SRAM
        pub type PWR_XROM_W<'a, const O: u8> = crate::BitWriter<'a, u16, POWER_PLAN_SPEC, bool, O>;
        ///Field `PWR_RAM2K` reader - RWA, power for retention 2KB SRAM
        pub type PWR_RAM2K_R = crate::BitReader<bool>;
        ///Field `PWR_RAM2K` writer - RWA, power for retention 2KB SRAM
        pub type PWR_RAM2K_W<'a, const O: u8> = crate::BitWriter<'a, u16, POWER_PLAN_SPEC, bool, O>;
        ///Field `PWR_CORE` reader - RWA, power retention for core and base peripherals
        pub type PWR_CORE_R = crate::BitReader<bool>;
        ///Field `PWR_CORE` writer - RWA, power retention for core and base peripherals
        pub type PWR_CORE_W<'a, const O: u8> = crate::BitWriter<'a, u16, POWER_PLAN_SPEC, bool, O>;
        ///Field `PWR_EXTEND` reader - RWA, power retention for USB and BLE
        pub type PWR_EXTEND_R = crate::BitReader<bool>;
        ///Field `PWR_EXTEND` writer - RWA, power retention for USB and BLE
        pub type PWR_EXTEND_W<'a, const O: u8> =
            crate::BitWriter<'a, u16, POWER_PLAN_SPEC, bool, O>;
        ///Field `PWR_RAM30K` reader - RWA, power for main SRAM
        pub type PWR_RAM30K_R = crate::BitReader<bool>;
        ///Field `PWR_RAM30K` writer - RWA, power for main SRAM
        pub type PWR_RAM30K_W<'a, const O: u8> =
            crate::BitWriter<'a, u16, POWER_PLAN_SPEC, bool, O>;
        ///Field `PWR_SYS_EN` reader - RWA, power for system
        pub type PWR_SYS_EN_R = crate::BitReader<bool>;
        ///Field `PWR_SYS_EN` writer - RWA, power for system
        pub type PWR_SYS_EN_W<'a, const O: u8> =
            crate::BitWriter<'a, u16, POWER_PLAN_SPEC, bool, O>;
        ///Field `PWR_DCDC_EN` reader - RWA, DC/DC converter enable: 0=DC/DC disable and bypass, 1=DC/DC enable
        pub type PWR_DCDC_EN_R = crate::BitReader<bool>;
        ///Field `PWR_DCDC_EN` writer - RWA, DC/DC converter enable: 0=DC/DC disable and bypass, 1=DC/DC enable
        pub type PWR_DCDC_EN_W<'a, const O: u8> =
            crate::BitWriter<'a, u16, POWER_PLAN_SPEC, bool, O>;
        ///Field `PWR_DCDC_PRE` reader - RWA, DC/DC converter pre-enable
        pub type PWR_DCDC_PRE_R = crate::BitReader<bool>;
        ///Field `PWR_DCDC_PRE` writer - RWA, DC/DC converter pre-enable
        pub type PWR_DCDC_PRE_W<'a, const O: u8> =
            crate::BitWriter<'a, u16, POWER_PLAN_SPEC, bool, O>;
        ///Field `PWR_MUST_0010` reader - RWA, power plan enable, auto clear after sleep executed
        pub type PWR_MUST_0010_R = crate::FieldReader<u8, u8>;
        ///Field `PWR_PLAN_EN` reader - RWA, must write 0010
        pub type PWR_PLAN_EN_R = crate::BitReader<bool>;
        impl R {
            ///Bit 0 - RWA, power for retention 2KB SRAM
            #[inline(always)]
            pub fn pwr_xrom(&self) -> PWR_XROM_R {
                PWR_XROM_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RWA, power for retention 2KB SRAM
            #[inline(always)]
            pub fn pwr_ram2k(&self) -> PWR_RAM2K_R {
                PWR_RAM2K_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RWA, power retention for core and base peripherals
            #[inline(always)]
            pub fn pwr_core(&self) -> PWR_CORE_R {
                PWR_CORE_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RWA, power retention for USB and BLE
            #[inline(always)]
            pub fn pwr_extend(&self) -> PWR_EXTEND_R {
                PWR_EXTEND_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RWA, power for main SRAM
            #[inline(always)]
            pub fn pwr_ram30k(&self) -> PWR_RAM30K_R {
                PWR_RAM30K_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 7 - RWA, power for system
            #[inline(always)]
            pub fn pwr_sys_en(&self) -> PWR_SYS_EN_R {
                PWR_SYS_EN_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bit 9 - RWA, DC/DC converter enable: 0=DC/DC disable and bypass, 1=DC/DC enable
            #[inline(always)]
            pub fn pwr_dcdc_en(&self) -> PWR_DCDC_EN_R {
                PWR_DCDC_EN_R::new(((self.bits >> 9) & 1) != 0)
            }
            ///Bit 10 - RWA, DC/DC converter pre-enable
            #[inline(always)]
            pub fn pwr_dcdc_pre(&self) -> PWR_DCDC_PRE_R {
                PWR_DCDC_PRE_R::new(((self.bits >> 10) & 1) != 0)
            }
            ///Bits 11:14 - RWA, power plan enable, auto clear after sleep executed
            #[inline(always)]
            pub fn pwr_must_0010(&self) -> PWR_MUST_0010_R {
                PWR_MUST_0010_R::new(((self.bits >> 11) & 0x0f) as u8)
            }
            ///Bit 15 - RWA, must write 0010
            #[inline(always)]
            pub fn pwr_plan_en(&self) -> PWR_PLAN_EN_R {
                PWR_PLAN_EN_R::new(((self.bits >> 15) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RWA, power for retention 2KB SRAM
            #[inline(always)]
            #[must_use]
            pub fn pwr_xrom(&mut self) -> PWR_XROM_W<0> {
                PWR_XROM_W::new(self)
            }
            ///Bit 1 - RWA, power for retention 2KB SRAM
            #[inline(always)]
            #[must_use]
            pub fn pwr_ram2k(&mut self) -> PWR_RAM2K_W<1> {
                PWR_RAM2K_W::new(self)
            }
            ///Bit 2 - RWA, power retention for core and base peripherals
            #[inline(always)]
            #[must_use]
            pub fn pwr_core(&mut self) -> PWR_CORE_W<2> {
                PWR_CORE_W::new(self)
            }
            ///Bit 3 - RWA, power retention for USB and BLE
            #[inline(always)]
            #[must_use]
            pub fn pwr_extend(&mut self) -> PWR_EXTEND_W<3> {
                PWR_EXTEND_W::new(self)
            }
            ///Bit 4 - RWA, power for main SRAM
            #[inline(always)]
            #[must_use]
            pub fn pwr_ram30k(&mut self) -> PWR_RAM30K_W<4> {
                PWR_RAM30K_W::new(self)
            }
            ///Bit 7 - RWA, power for system
            #[inline(always)]
            #[must_use]
            pub fn pwr_sys_en(&mut self) -> PWR_SYS_EN_W<7> {
                PWR_SYS_EN_W::new(self)
            }
            ///Bit 9 - RWA, DC/DC converter enable: 0=DC/DC disable and bypass, 1=DC/DC enable
            #[inline(always)]
            #[must_use]
            pub fn pwr_dcdc_en(&mut self) -> PWR_DCDC_EN_W<9> {
                PWR_DCDC_EN_W::new(self)
            }
            ///Bit 10 - RWA, DC/DC converter pre-enable
            #[inline(always)]
            #[must_use]
            pub fn pwr_dcdc_pre(&mut self) -> PWR_DCDC_PRE_W<10> {
                PWR_DCDC_PRE_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RWA, power plan before sleep instruction, SAM
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [power_plan](index.html) module
        pub struct POWER_PLAN_SPEC;
        impl crate::RegisterSpec for POWER_PLAN_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [power_plan::R](R) reader structure
        impl crate::Readable for POWER_PLAN_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [power_plan::W](W) writer structure
        impl crate::Writable for POWER_PLAN_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets POWER_PLAN to value 0x11df
        impl crate::Resettable for POWER_PLAN_SPEC {
            const RESET_VALUE: Self::Ux = 0x11df;
        }
    }
    ///AUX_POWER_ADJ (rw) register accessor: an alias for `Reg<AUX_POWER_ADJ_SPEC>`
    pub type AUX_POWER_ADJ = crate::Reg<aux_power_adj::AUX_POWER_ADJ_SPEC>;
    ///RWA, aux power adjust control, SAM
    pub mod aux_power_adj {
        ///Register `AUX_POWER_ADJ` reader
        pub struct R(crate::R<AUX_POWER_ADJ_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<AUX_POWER_ADJ_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<AUX_POWER_ADJ_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<AUX_POWER_ADJ_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `AUX_POWER_ADJ` writer
        pub struct W(crate::W<AUX_POWER_ADJ_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<AUX_POWER_ADJ_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<AUX_POWER_ADJ_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<AUX_POWER_ADJ_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `ULPLDO_ADJ` reader - RWA, Ultra-Low-Power LDO voltage adjust
        pub type ULPLDO_ADJ_R = crate::FieldReader<u8, u8>;
        ///Field `ULPLDO_ADJ` writer - RWA, Ultra-Low-Power LDO voltage adjust
        pub type ULPLDO_ADJ_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, AUX_POWER_ADJ_SPEC, u8, u8, 3, O>;
        ///Field `DCDC_CHARGE` reader - RWA, Ultra-Low-Power LDO voltage adjust
        pub type DCDC_CHARGE_R = crate::BitReader<bool>;
        ///Field `DCDC_CHARGE` writer - RWA, Ultra-Low-Power LDO voltage adjust
        pub type DCDC_CHARGE_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, AUX_POWER_ADJ_SPEC, bool, O>;
        impl R {
            ///Bits 0:2 - RWA, Ultra-Low-Power LDO voltage adjust
            #[inline(always)]
            pub fn ulpldo_adj(&self) -> ULPLDO_ADJ_R {
                ULPLDO_ADJ_R::new(self.bits & 7)
            }
            ///Bit 7 - RWA, Ultra-Low-Power LDO voltage adjust
            #[inline(always)]
            pub fn dcdc_charge(&self) -> DCDC_CHARGE_R {
                DCDC_CHARGE_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:2 - RWA, Ultra-Low-Power LDO voltage adjust
            #[inline(always)]
            #[must_use]
            pub fn ulpldo_adj(&mut self) -> ULPLDO_ADJ_W<0> {
                ULPLDO_ADJ_W::new(self)
            }
            ///Bit 7 - RWA, Ultra-Low-Power LDO voltage adjust
            #[inline(always)]
            #[must_use]
            pub fn dcdc_charge(&mut self) -> DCDC_CHARGE_W<7> {
                DCDC_CHARGE_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RWA, aux power adjust control, SAM
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [aux_power_adj](index.html) module
        pub struct AUX_POWER_ADJ_SPEC;
        impl crate::RegisterSpec for AUX_POWER_ADJ_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [aux_power_adj::R](R) reader structure
        impl crate::Readable for AUX_POWER_ADJ_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [aux_power_adj::W](W) writer structure
        impl crate::Writable for AUX_POWER_ADJ_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets AUX_POWER_ADJ to value 0
        impl crate::Resettable for AUX_POWER_ADJ_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///BAT_DET_CTRL (rw) register accessor: an alias for `Reg<BAT_DET_CTRL_SPEC>`
    pub type BAT_DET_CTRL = crate::Reg<bat_det_ctrl::BAT_DET_CTRL_SPEC>;
    ///RWA, battery voltage detector control, SAM
    pub mod bat_det_ctrl {
        ///Register `BAT_DET_CTRL` reader
        pub struct R(crate::R<BAT_DET_CTRL_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<BAT_DET_CTRL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<BAT_DET_CTRL_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<BAT_DET_CTRL_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `BAT_DET_CTRL` writer
        pub struct W(crate::W<BAT_DET_CTRL_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<BAT_DET_CTRL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<BAT_DET_CTRL_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<BAT_DET_CTRL_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `BAT_DET_EN__RB_BAT_LOW_VTHX` reader - RWA, battery voltage detector enable/select monitor threshold voltage
        pub type BAT_DET_EN__RB_BAT_LOW_VTHX_R = crate::BitReader<bool>;
        ///Field `BAT_DET_EN__RB_BAT_LOW_VTHX` writer - RWA, battery voltage detector enable/select monitor threshold voltage
        pub type BAT_DET_EN__RB_BAT_LOW_VTHX_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, BAT_DET_CTRL_SPEC, bool, O>;
        ///Field `BAT_MON_EN` reader - RWA, battery voltage monitor enable under sleep mode
        pub type BAT_MON_EN_R = crate::BitReader<bool>;
        ///Field `BAT_MON_EN` writer - RWA, battery voltage monitor enable under sleep mode
        pub type BAT_MON_EN_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, BAT_DET_CTRL_SPEC, bool, O>;
        ///Field `BAT_LOWER_IE` reader - RWA, interrupt enable for battery lower voltage
        pub type BAT_LOWER_IE_R = crate::BitReader<bool>;
        ///Field `BAT_LOWER_IE` writer - RWA, interrupt enable for battery lower voltage
        pub type BAT_LOWER_IE_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, BAT_DET_CTRL_SPEC, bool, O>;
        ///Field `BAT_LOW_IE` reader - RWA, interrupt enable for battery low voltage
        pub type BAT_LOW_IE_R = crate::BitReader<bool>;
        ///Field `BAT_LOW_IE` writer - RWA, interrupt enable for battery low voltage
        pub type BAT_LOW_IE_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, BAT_DET_CTRL_SPEC, bool, O>;
        impl R {
            ///Bit 0 - RWA, battery voltage detector enable/select monitor threshold voltage
            #[inline(always)]
            pub fn bat_det_en__rb_bat_low_vthx(&self) -> BAT_DET_EN__RB_BAT_LOW_VTHX_R {
                BAT_DET_EN__RB_BAT_LOW_VTHX_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RWA, battery voltage monitor enable under sleep mode
            #[inline(always)]
            pub fn bat_mon_en(&self) -> BAT_MON_EN_R {
                BAT_MON_EN_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RWA, interrupt enable for battery lower voltage
            #[inline(always)]
            pub fn bat_lower_ie(&self) -> BAT_LOWER_IE_R {
                BAT_LOWER_IE_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RWA, interrupt enable for battery low voltage
            #[inline(always)]
            pub fn bat_low_ie(&self) -> BAT_LOW_IE_R {
                BAT_LOW_IE_R::new(((self.bits >> 3) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RWA, battery voltage detector enable/select monitor threshold voltage
            #[inline(always)]
            #[must_use]
            pub fn bat_det_en__rb_bat_low_vthx(&mut self) -> BAT_DET_EN__RB_BAT_LOW_VTHX_W<0> {
                BAT_DET_EN__RB_BAT_LOW_VTHX_W::new(self)
            }
            ///Bit 1 - RWA, battery voltage monitor enable under sleep mode
            #[inline(always)]
            #[must_use]
            pub fn bat_mon_en(&mut self) -> BAT_MON_EN_W<1> {
                BAT_MON_EN_W::new(self)
            }
            ///Bit 2 - RWA, interrupt enable for battery lower voltage
            #[inline(always)]
            #[must_use]
            pub fn bat_lower_ie(&mut self) -> BAT_LOWER_IE_W<2> {
                BAT_LOWER_IE_W::new(self)
            }
            ///Bit 3 - RWA, interrupt enable for battery low voltage
            #[inline(always)]
            #[must_use]
            pub fn bat_low_ie(&mut self) -> BAT_LOW_IE_W<3> {
                BAT_LOW_IE_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RWA, battery voltage detector control, SAM
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [bat_det_ctrl](index.html) module
        pub struct BAT_DET_CTRL_SPEC;
        impl crate::RegisterSpec for BAT_DET_CTRL_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [bat_det_ctrl::R](R) reader structure
        impl crate::Readable for BAT_DET_CTRL_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [bat_det_ctrl::W](W) writer structure
        impl crate::Writable for BAT_DET_CTRL_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets BAT_DET_CTRL to value 0
        impl crate::Resettable for BAT_DET_CTRL_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///BAT_DET_CFG (rw) register accessor: an alias for `Reg<BAT_DET_CFG_SPEC>`
    pub type BAT_DET_CFG = crate::Reg<bat_det_cfg::BAT_DET_CFG_SPEC>;
    ///RWA, battery voltage detector configuration, SAM
    pub mod bat_det_cfg {
        ///Register `BAT_DET_CFG` reader
        pub struct R(crate::R<BAT_DET_CFG_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<BAT_DET_CFG_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<BAT_DET_CFG_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<BAT_DET_CFG_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `BAT_DET_CFG` writer
        pub struct W(crate::W<BAT_DET_CFG_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<BAT_DET_CFG_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<BAT_DET_CFG_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<BAT_DET_CFG_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `BAT_LOW_VTH` reader - RWA, select threshold voltage of battery voltage low
        pub type BAT_LOW_VTH_R = crate::FieldReader<u8, u8>;
        ///Field `BAT_LOW_VTH` writer - RWA, select threshold voltage of battery voltage low
        pub type BAT_LOW_VTH_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, BAT_DET_CFG_SPEC, u8, u8, 2, O>;
        impl R {
            ///Bits 0:1 - RWA, select threshold voltage of battery voltage low
            #[inline(always)]
            pub fn bat_low_vth(&self) -> BAT_LOW_VTH_R {
                BAT_LOW_VTH_R::new(self.bits & 3)
            }
        }
        impl W {
            ///Bits 0:1 - RWA, select threshold voltage of battery voltage low
            #[inline(always)]
            #[must_use]
            pub fn bat_low_vth(&mut self) -> BAT_LOW_VTH_W<0> {
                BAT_LOW_VTH_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RWA, battery voltage detector configuration, SAM
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [bat_det_cfg](index.html) module
        pub struct BAT_DET_CFG_SPEC;
        impl crate::RegisterSpec for BAT_DET_CFG_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [bat_det_cfg::R](R) reader structure
        impl crate::Readable for BAT_DET_CFG_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [bat_det_cfg::W](W) writer structure
        impl crate::Writable for BAT_DET_CFG_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets BAT_DET_CFG to value 0x01
        impl crate::Resettable for BAT_DET_CFG_SPEC {
            const RESET_VALUE: Self::Ux = 0x01;
        }
    }
    ///BAT_STATUS (r) register accessor: an alias for `Reg<BAT_STATUS_SPEC>`
    pub type BAT_STATUS = crate::Reg<bat_status::BAT_STATUS_SPEC>;
    ///RO, battery status
    pub mod bat_status {
        ///Register `BAT_STATUS` reader
        pub struct R(crate::R<BAT_STATUS_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<BAT_STATUS_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<BAT_STATUS_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<BAT_STATUS_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `BAT_STAT_LOWER` reader - RO, battery lower voltage status, high action
        pub type BAT_STAT_LOWER_R = crate::BitReader<bool>;
        ///Field `BAT_STAT_LOW` reader - RO, battery low voltage status, high action
        pub type BAT_STAT_LOW_R = crate::BitReader<bool>;
        impl R {
            ///Bit 0 - RO, battery lower voltage status, high action
            #[inline(always)]
            pub fn bat_stat_lower(&self) -> BAT_STAT_LOWER_R {
                BAT_STAT_LOWER_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RO, battery low voltage status, high action
            #[inline(always)]
            pub fn bat_stat_low(&self) -> BAT_STAT_LOW_R {
                BAT_STAT_LOW_R::new(((self.bits >> 1) & 1) != 0)
            }
        }
        ///RO, battery status
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [bat_status](index.html) module
        pub struct BAT_STATUS_SPEC;
        impl crate::RegisterSpec for BAT_STATUS_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [bat_status::R](R) reader structure
        impl crate::Readable for BAT_STATUS_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets BAT_STATUS to value 0
        impl crate::Resettable for BAT_STATUS_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///INT32K_TUNE (rw) register accessor: an alias for `Reg<INT32K_TUNE_SPEC>`
    pub type INT32K_TUNE = crate::Reg<int32k_tune::INT32K_TUNE_SPEC>;
    ///RWA, internal 32KHz oscillator tune control, SAM
    pub mod int32k_tune {
        ///Register `INT32K_TUNE` reader
        pub struct R(crate::R<INT32K_TUNE_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<INT32K_TUNE_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<INT32K_TUNE_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<INT32K_TUNE_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `INT32K_TUNE` writer
        pub struct W(crate::W<INT32K_TUNE_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<INT32K_TUNE_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<INT32K_TUNE_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<INT32K_TUNE_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `INT32K_TUNE` reader - RWA, internal 32KHz oscillator frequency tune
        pub type INT32K_TUNE_R = crate::FieldReader<u16, u16>;
        ///Field `INT32K_TUNE` writer - RWA, internal 32KHz oscillator frequency tune
        pub type INT32K_TUNE_W<'a, const O: u8> =
            crate::FieldWriter<'a, u16, INT32K_TUNE_SPEC, u16, u16, 13, O>;
        impl R {
            ///Bits 0:12 - RWA, internal 32KHz oscillator frequency tune
            #[inline(always)]
            pub fn int32k_tune(&self) -> INT32K_TUNE_R {
                INT32K_TUNE_R::new(self.bits & 0x1fff)
            }
        }
        impl W {
            ///Bits 0:12 - RWA, internal 32KHz oscillator frequency tune
            #[inline(always)]
            #[must_use]
            pub fn int32k_tune(&mut self) -> INT32K_TUNE_W<0> {
                INT32K_TUNE_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RWA, internal 32KHz oscillator tune control, SAM
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [int32k_tune](index.html) module
        pub struct INT32K_TUNE_SPEC;
        impl crate::RegisterSpec for INT32K_TUNE_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [int32k_tune::R](R) reader structure
        impl crate::Readable for INT32K_TUNE_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [int32k_tune::W](W) writer structure
        impl crate::Writable for INT32K_TUNE_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets INT32K_TUNE to value 0x1011
        impl crate::Resettable for INT32K_TUNE_SPEC {
            const RESET_VALUE: Self::Ux = 0x1011;
        }
    }
    ///XT32K_TUNE (rw) register accessor: an alias for `Reg<XT32K_TUNE_SPEC>`
    pub type XT32K_TUNE = crate::Reg<xt32k_tune::XT32K_TUNE_SPEC>;
    ///RWA, external 32KHz oscillator tune control, SAM
    pub mod xt32k_tune {
        ///Register `XT32K_TUNE` reader
        pub struct R(crate::R<XT32K_TUNE_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<XT32K_TUNE_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<XT32K_TUNE_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<XT32K_TUNE_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `XT32K_TUNE` writer
        pub struct W(crate::W<XT32K_TUNE_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<XT32K_TUNE_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<XT32K_TUNE_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<XT32K_TUNE_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `XT32K_I_TUNE` reader - RWA, external 32KHz oscillator current tune: 00=75% current, 01=standard current, 10=150% current, 11=200% current
        pub type XT32K_I_TUNE_R = crate::FieldReader<u8, u8>;
        ///Field `XT32K_I_TUNE` writer - RWA, external 32KHz oscillator current tune: 00=75% current, 01=standard current, 10=150% current, 11=200% current
        pub type XT32K_I_TUNE_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, XT32K_TUNE_SPEC, u8, u8, 2, O>;
        ///Field `XT32K_C_LOAD` reader - RWA, external 32KHz oscillator load capacitor tune: Cap = RB_XT32K_C_LOAD + 12pF
        pub type XT32K_C_LOAD_R = crate::FieldReader<u8, u8>;
        ///Field `XT32K_C_LOAD` writer - RWA, external 32KHz oscillator load capacitor tune: Cap = RB_XT32K_C_LOAD + 12pF
        pub type XT32K_C_LOAD_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, XT32K_TUNE_SPEC, u8, u8, 4, O>;
        impl R {
            ///Bits 0:1 - RWA, external 32KHz oscillator current tune: 00=75% current, 01=standard current, 10=150% current, 11=200% current
            #[inline(always)]
            pub fn xt32k_i_tune(&self) -> XT32K_I_TUNE_R {
                XT32K_I_TUNE_R::new(self.bits & 3)
            }
            ///Bits 4:7 - RWA, external 32KHz oscillator load capacitor tune: Cap = RB_XT32K_C_LOAD + 12pF
            #[inline(always)]
            pub fn xt32k_c_load(&self) -> XT32K_C_LOAD_R {
                XT32K_C_LOAD_R::new((self.bits >> 4) & 0x0f)
            }
        }
        impl W {
            ///Bits 0:1 - RWA, external 32KHz oscillator current tune: 00=75% current, 01=standard current, 10=150% current, 11=200% current
            #[inline(always)]
            #[must_use]
            pub fn xt32k_i_tune(&mut self) -> XT32K_I_TUNE_W<0> {
                XT32K_I_TUNE_W::new(self)
            }
            ///Bits 4:7 - RWA, external 32KHz oscillator load capacitor tune: Cap = RB_XT32K_C_LOAD + 12pF
            #[inline(always)]
            #[must_use]
            pub fn xt32k_c_load(&mut self) -> XT32K_C_LOAD_W<4> {
                XT32K_C_LOAD_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RWA, external 32KHz oscillator tune control, SAM
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [xt32k_tune](index.html) module
        pub struct XT32K_TUNE_SPEC;
        impl crate::RegisterSpec for XT32K_TUNE_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [xt32k_tune::R](R) reader structure
        impl crate::Readable for XT32K_TUNE_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [xt32k_tune::W](W) writer structure
        impl crate::Writable for XT32K_TUNE_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets XT32K_TUNE to value 0xc3
        impl crate::Resettable for XT32K_TUNE_SPEC {
            const RESET_VALUE: Self::Ux = 0xc3;
        }
    }
    ///CK32K_CONFIG (rw) register accessor: an alias for `Reg<CK32K_CONFIG_SPEC>`
    pub type CK32K_CONFIG = crate::Reg<ck32k_config::CK32K_CONFIG_SPEC>;
    ///RWA, 32KHz oscillator configure
    pub mod ck32k_config {
        ///Register `CK32K_CONFIG` reader
        pub struct R(crate::R<CK32K_CONFIG_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CK32K_CONFIG_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<CK32K_CONFIG_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<CK32K_CONFIG_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CK32K_CONFIG` writer
        pub struct W(crate::W<CK32K_CONFIG_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CK32K_CONFIG_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<CK32K_CONFIG_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<CK32K_CONFIG_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `CLK_XT32K_PON` reader - RWA, external 32KHz oscillator power on
        pub type CLK_XT32K_PON_R = crate::BitReader<bool>;
        ///Field `CLK_XT32K_PON` writer - RWA, external 32KHz oscillator power on
        pub type CLK_XT32K_PON_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, CK32K_CONFIG_SPEC, bool, O>;
        ///Field `CLK_INT32K_PON` reader - RWA, internal 32KHz oscillator power on
        pub type CLK_INT32K_PON_R = crate::BitReader<bool>;
        ///Field `CLK_INT32K_PON` writer - RWA, internal 32KHz oscillator power on
        pub type CLK_INT32K_PON_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, CK32K_CONFIG_SPEC, bool, O>;
        ///Field `CLK_OSC32K_XT` reader - RWA, 32KHz oscillator source selection: 0=RC, 1=XT
        pub type CLK_OSC32K_XT_R = crate::BitReader<bool>;
        ///Field `CLK_OSC32K_XT` writer - RWA, 32KHz oscillator source selection: 0=RC, 1=XT
        pub type CLK_OSC32K_XT_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, CK32K_CONFIG_SPEC, bool, O>;
        ///Field `CLK_OSC32K_FILT` reader - RWA, internal 32KHz oscillator low noise mode enable
        pub type CLK_OSC32K_FILT_R = crate::BitReader<bool>;
        ///Field `CLK_OSC32K_FILT` writer - RWA, internal 32KHz oscillator low noise mode enable
        pub type CLK_OSC32K_FILT_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, CK32K_CONFIG_SPEC, bool, O>;
        ///Field `CLK_32K_PIN` reader - RO, 32KHz oscillator clock pin status
        pub type CLK_32K_PIN_R = crate::BitReader<bool>;
        impl R {
            ///Bit 0 - RWA, external 32KHz oscillator power on
            #[inline(always)]
            pub fn clk_xt32k_pon(&self) -> CLK_XT32K_PON_R {
                CLK_XT32K_PON_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RWA, internal 32KHz oscillator power on
            #[inline(always)]
            pub fn clk_int32k_pon(&self) -> CLK_INT32K_PON_R {
                CLK_INT32K_PON_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RWA, 32KHz oscillator source selection: 0=RC, 1=XT
            #[inline(always)]
            pub fn clk_osc32k_xt(&self) -> CLK_OSC32K_XT_R {
                CLK_OSC32K_XT_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RWA, internal 32KHz oscillator low noise mode enable
            #[inline(always)]
            pub fn clk_osc32k_filt(&self) -> CLK_OSC32K_FILT_R {
                CLK_OSC32K_FILT_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 7 - RO, 32KHz oscillator clock pin status
            #[inline(always)]
            pub fn clk_32k_pin(&self) -> CLK_32K_PIN_R {
                CLK_32K_PIN_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RWA, external 32KHz oscillator power on
            #[inline(always)]
            #[must_use]
            pub fn clk_xt32k_pon(&mut self) -> CLK_XT32K_PON_W<0> {
                CLK_XT32K_PON_W::new(self)
            }
            ///Bit 1 - RWA, internal 32KHz oscillator power on
            #[inline(always)]
            #[must_use]
            pub fn clk_int32k_pon(&mut self) -> CLK_INT32K_PON_W<1> {
                CLK_INT32K_PON_W::new(self)
            }
            ///Bit 2 - RWA, 32KHz oscillator source selection: 0=RC, 1=XT
            #[inline(always)]
            #[must_use]
            pub fn clk_osc32k_xt(&mut self) -> CLK_OSC32K_XT_W<2> {
                CLK_OSC32K_XT_W::new(self)
            }
            ///Bit 3 - RWA, internal 32KHz oscillator low noise mode enable
            #[inline(always)]
            #[must_use]
            pub fn clk_osc32k_filt(&mut self) -> CLK_OSC32K_FILT_W<3> {
                CLK_OSC32K_FILT_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RWA, 32KHz oscillator configure
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [ck32k_config](index.html) module
        pub struct CK32K_CONFIG_SPEC;
        impl crate::RegisterSpec for CK32K_CONFIG_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [ck32k_config::R](R) reader structure
        impl crate::Readable for CK32K_CONFIG_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [ck32k_config::W](W) writer structure
        impl crate::Writable for CK32K_CONFIG_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets CK32K_CONFIG to value 0x02
        impl crate::Resettable for CK32K_CONFIG_SPEC {
            const RESET_VALUE: Self::Ux = 0x02;
        }
    }
    ///RTC_FLAG_CTRL (rw) register accessor: an alias for `Reg<RTC_FLAG_CTRL_SPEC>`
    pub type RTC_FLAG_CTRL = crate::Reg<rtc_flag_ctrl::RTC_FLAG_CTRL_SPEC>;
    ///RW, RTC flag and clear control
    pub mod rtc_flag_ctrl {
        ///Register `RTC_FLAG_CTRL` reader
        pub struct R(crate::R<RTC_FLAG_CTRL_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<RTC_FLAG_CTRL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<RTC_FLAG_CTRL_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<RTC_FLAG_CTRL_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `RTC_FLAG_CTRL` writer
        pub struct W(crate::W<RTC_FLAG_CTRL_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<RTC_FLAG_CTRL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<RTC_FLAG_CTRL_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<RTC_FLAG_CTRL_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `RTC_TMR_CLR` reader - RW, set 1 to clear RTC timer action flag, auto clear
        pub type RTC_TMR_CLR_R = crate::BitReader<bool>;
        ///Field `RTC_TMR_CLR` writer - RW, set 1 to clear RTC timer action flag, auto clear
        pub type RTC_TMR_CLR_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, RTC_FLAG_CTRL_SPEC, bool, O>;
        ///Field `RTC_TRIG_CLR` reader - RW, set 1 to clear RTC trigger action flag, auto clear
        pub type RTC_TRIG_CLR_R = crate::BitReader<bool>;
        ///Field `RTC_TRIG_CLR` writer - RW, set 1 to clear RTC trigger action flag, auto clear
        pub type RTC_TRIG_CLR_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, RTC_FLAG_CTRL_SPEC, bool, O>;
        ///Field `RTC_TMR_FLAG` reader - RO, RTC timer action flag
        pub type RTC_TMR_FLAG_R = crate::BitReader<bool>;
        ///Field `RTC_TRIG_FLAG` reader - RO, RTC trigger action flag
        pub type RTC_TRIG_FLAG_R = crate::BitReader<bool>;
        impl R {
            ///Bit 4 - RW, set 1 to clear RTC timer action flag, auto clear
            #[inline(always)]
            pub fn rtc_tmr_clr(&self) -> RTC_TMR_CLR_R {
                RTC_TMR_CLR_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - RW, set 1 to clear RTC trigger action flag, auto clear
            #[inline(always)]
            pub fn rtc_trig_clr(&self) -> RTC_TRIG_CLR_R {
                RTC_TRIG_CLR_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - RO, RTC timer action flag
            #[inline(always)]
            pub fn rtc_tmr_flag(&self) -> RTC_TMR_FLAG_R {
                RTC_TMR_FLAG_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - RO, RTC trigger action flag
            #[inline(always)]
            pub fn rtc_trig_flag(&self) -> RTC_TRIG_FLAG_R {
                RTC_TRIG_FLAG_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 4 - RW, set 1 to clear RTC timer action flag, auto clear
            #[inline(always)]
            #[must_use]
            pub fn rtc_tmr_clr(&mut self) -> RTC_TMR_CLR_W<4> {
                RTC_TMR_CLR_W::new(self)
            }
            ///Bit 5 - RW, set 1 to clear RTC trigger action flag, auto clear
            #[inline(always)]
            #[must_use]
            pub fn rtc_trig_clr(&mut self) -> RTC_TRIG_CLR_W<5> {
                RTC_TRIG_CLR_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, RTC flag and clear control
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [rtc_flag_ctrl](index.html) module
        pub struct RTC_FLAG_CTRL_SPEC;
        impl crate::RegisterSpec for RTC_FLAG_CTRL_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [rtc_flag_ctrl::R](R) reader structure
        impl crate::Readable for RTC_FLAG_CTRL_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [rtc_flag_ctrl::W](W) writer structure
        impl crate::Writable for RTC_FLAG_CTRL_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets RTC_FLAG_CTRL to value 0x30
        impl crate::Resettable for RTC_FLAG_CTRL_SPEC {
            const RESET_VALUE: Self::Ux = 0x30;
        }
    }
    ///RTC_MODE_CTRL (rw) register accessor: an alias for `Reg<RTC_MODE_CTRL_SPEC>`
    pub type RTC_MODE_CTRL = crate::Reg<rtc_mode_ctrl::RTC_MODE_CTRL_SPEC>;
    ///RWA, RTC mode control, SAM
    pub mod rtc_mode_ctrl {
        ///Register `RTC_MODE_CTRL` reader
        pub struct R(crate::R<RTC_MODE_CTRL_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<RTC_MODE_CTRL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<RTC_MODE_CTRL_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<RTC_MODE_CTRL_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `RTC_MODE_CTRL` writer
        pub struct W(crate::W<RTC_MODE_CTRL_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<RTC_MODE_CTRL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<RTC_MODE_CTRL_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<RTC_MODE_CTRL_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `RTC_TMR_MODE` reader - RWA, RTC timer mode: 000=0.125S, 001=0.25S, 010=0.5S, 011=1S, 100=2S, 101=4S, 110=8S, 111=16S
        pub type RTC_TMR_MODE_R = crate::FieldReader<u8, u8>;
        ///Field `RTC_TMR_MODE` writer - RWA, RTC timer mode: 000=0.125S, 001=0.25S, 010=0.5S, 011=1S, 100=2S, 101=4S, 110=8S, 111=16S
        pub type RTC_TMR_MODE_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, RTC_MODE_CTRL_SPEC, u8, u8, 3, O>;
        ///Field `RTC_IGNORE_B0` reader - RWA, force ignore bit0 for trigger mode: 0=compare bit0, 1=ignore bit0
        pub type RTC_IGNORE_B0_R = crate::BitReader<bool>;
        ///Field `RTC_IGNORE_B0` writer - RWA, force ignore bit0 for trigger mode: 0=compare bit0, 1=ignore bit0
        pub type RTC_IGNORE_B0_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, RTC_MODE_CTRL_SPEC, bool, O>;
        ///Field `RTC_TMR_EN` reader - RWA, RTC timer mode enable
        pub type RTC_TMR_EN_R = crate::BitReader<bool>;
        ///Field `RTC_TMR_EN` writer - RWA, RTC timer mode enable
        pub type RTC_TMR_EN_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, RTC_MODE_CTRL_SPEC, bool, O>;
        ///Field `RTC_TRIG_EN` reader - RWA, RTC trigger mode enable
        pub type RTC_TRIG_EN_R = crate::BitReader<bool>;
        ///Field `RTC_TRIG_EN` writer - RWA, RTC trigger mode enable
        pub type RTC_TRIG_EN_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, RTC_MODE_CTRL_SPEC, bool, O>;
        ///Field `RTC_LOAD_LO` reader - RWA, set 1 to load RTC count low word R32_RTC_CNT_32K, auto clear after loaded
        pub type RTC_LOAD_LO_R = crate::BitReader<bool>;
        ///Field `RTC_LOAD_LO` writer - RWA, set 1 to load RTC count low word R32_RTC_CNT_32K, auto clear after loaded
        pub type RTC_LOAD_LO_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, RTC_MODE_CTRL_SPEC, bool, O>;
        ///Field `RTC_LOAD_HI` reader - RWA, set 1 to load RTC count high word R32_RTC_CNT_DAY, auto clear after loaded
        pub type RTC_LOAD_HI_R = crate::BitReader<bool>;
        ///Field `RTC_LOAD_HI` writer - RWA, set 1 to load RTC count high word R32_RTC_CNT_DAY, auto clear after loaded
        pub type RTC_LOAD_HI_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, RTC_MODE_CTRL_SPEC, bool, O>;
        impl R {
            ///Bits 0:2 - RWA, RTC timer mode: 000=0.125S, 001=0.25S, 010=0.5S, 011=1S, 100=2S, 101=4S, 110=8S, 111=16S
            #[inline(always)]
            pub fn rtc_tmr_mode(&self) -> RTC_TMR_MODE_R {
                RTC_TMR_MODE_R::new(self.bits & 7)
            }
            ///Bit 3 - RWA, force ignore bit0 for trigger mode: 0=compare bit0, 1=ignore bit0
            #[inline(always)]
            pub fn rtc_ignore_b0(&self) -> RTC_IGNORE_B0_R {
                RTC_IGNORE_B0_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RWA, RTC timer mode enable
            #[inline(always)]
            pub fn rtc_tmr_en(&self) -> RTC_TMR_EN_R {
                RTC_TMR_EN_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - RWA, RTC trigger mode enable
            #[inline(always)]
            pub fn rtc_trig_en(&self) -> RTC_TRIG_EN_R {
                RTC_TRIG_EN_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - RWA, set 1 to load RTC count low word R32_RTC_CNT_32K, auto clear after loaded
            #[inline(always)]
            pub fn rtc_load_lo(&self) -> RTC_LOAD_LO_R {
                RTC_LOAD_LO_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - RWA, set 1 to load RTC count high word R32_RTC_CNT_DAY, auto clear after loaded
            #[inline(always)]
            pub fn rtc_load_hi(&self) -> RTC_LOAD_HI_R {
                RTC_LOAD_HI_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:2 - RWA, RTC timer mode: 000=0.125S, 001=0.25S, 010=0.5S, 011=1S, 100=2S, 101=4S, 110=8S, 111=16S
            #[inline(always)]
            #[must_use]
            pub fn rtc_tmr_mode(&mut self) -> RTC_TMR_MODE_W<0> {
                RTC_TMR_MODE_W::new(self)
            }
            ///Bit 3 - RWA, force ignore bit0 for trigger mode: 0=compare bit0, 1=ignore bit0
            #[inline(always)]
            #[must_use]
            pub fn rtc_ignore_b0(&mut self) -> RTC_IGNORE_B0_W<3> {
                RTC_IGNORE_B0_W::new(self)
            }
            ///Bit 4 - RWA, RTC timer mode enable
            #[inline(always)]
            #[must_use]
            pub fn rtc_tmr_en(&mut self) -> RTC_TMR_EN_W<4> {
                RTC_TMR_EN_W::new(self)
            }
            ///Bit 5 - RWA, RTC trigger mode enable
            #[inline(always)]
            #[must_use]
            pub fn rtc_trig_en(&mut self) -> RTC_TRIG_EN_W<5> {
                RTC_TRIG_EN_W::new(self)
            }
            ///Bit 6 - RWA, set 1 to load RTC count low word R32_RTC_CNT_32K, auto clear after loaded
            #[inline(always)]
            #[must_use]
            pub fn rtc_load_lo(&mut self) -> RTC_LOAD_LO_W<6> {
                RTC_LOAD_LO_W::new(self)
            }
            ///Bit 7 - RWA, set 1 to load RTC count high word R32_RTC_CNT_DAY, auto clear after loaded
            #[inline(always)]
            #[must_use]
            pub fn rtc_load_hi(&mut self) -> RTC_LOAD_HI_W<7> {
                RTC_LOAD_HI_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RWA, RTC mode control, SAM
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [rtc_mode_ctrl](index.html) module
        pub struct RTC_MODE_CTRL_SPEC;
        impl crate::RegisterSpec for RTC_MODE_CTRL_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [rtc_mode_ctrl::R](R) reader structure
        impl crate::Readable for RTC_MODE_CTRL_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [rtc_mode_ctrl::W](W) writer structure
        impl crate::Writable for RTC_MODE_CTRL_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets RTC_MODE_CTRL to value 0x02
        impl crate::Resettable for RTC_MODE_CTRL_SPEC {
            const RESET_VALUE: Self::Ux = 0x02;
        }
    }
    ///RTC_TRIG (rw) register accessor: an alias for `Reg<RTC_TRIG_SPEC>`
    pub type RTC_TRIG = crate::Reg<rtc_trig::RTC_TRIG_SPEC>;
    ///RWA, RTC trigger value, SAM
    pub mod rtc_trig {
        ///Register `RTC_TRIG` reader
        pub struct R(crate::R<RTC_TRIG_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<RTC_TRIG_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<RTC_TRIG_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<RTC_TRIG_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `RTC_TRIG` writer
        pub struct W(crate::W<RTC_TRIG_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<RTC_TRIG_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<RTC_TRIG_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<RTC_TRIG_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `RTC_TRIG` reader - RWA, RTC trigger value
        pub type RTC_TRIG_R = crate::FieldReader<u32, u32>;
        ///Field `RTC_TRIG` writer - RWA, RTC trigger value
        pub type RTC_TRIG_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, RTC_TRIG_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - RWA, RTC trigger value
            #[inline(always)]
            pub fn rtc_trig(&self) -> RTC_TRIG_R {
                RTC_TRIG_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RWA, RTC trigger value
            #[inline(always)]
            #[must_use]
            pub fn rtc_trig(&mut self) -> RTC_TRIG_W<0> {
                RTC_TRIG_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RWA, RTC trigger value, SAM
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [rtc_trig](index.html) module
        pub struct RTC_TRIG_SPEC;
        impl crate::RegisterSpec for RTC_TRIG_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [rtc_trig::R](R) reader structure
        impl crate::Readable for RTC_TRIG_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [rtc_trig::W](W) writer structure
        impl crate::Writable for RTC_TRIG_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets RTC_TRIG to value 0
        impl crate::Resettable for RTC_TRIG_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///RTC_CNT_32K (r) register accessor: an alias for `Reg<RTC_CNT_32K_SPEC>`
    pub type RTC_CNT_32K = crate::Reg<rtc_cnt_32k::RTC_CNT_32K_SPEC>;
    ///RO, RTC count based 32KHz
    pub mod rtc_cnt_32k {
        ///Register `RTC_CNT_32K` reader
        pub struct R(crate::R<RTC_CNT_32K_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<RTC_CNT_32K_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<RTC_CNT_32K_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<RTC_CNT_32K_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `RTC_CNT_32K` reader - RWA,RTC count based 32KHz
        pub type RTC_CNT_32K_R = crate::FieldReader<u16, u16>;
        impl R {
            ///Bits 0:15 - RWA,RTC count based 32KHz
            #[inline(always)]
            pub fn rtc_cnt_32k(&self) -> RTC_CNT_32K_R {
                RTC_CNT_32K_R::new(self.bits)
            }
        }
        ///RO, RTC count based 32KHz
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [rtc_cnt_32k](index.html) module
        pub struct RTC_CNT_32K_SPEC;
        impl crate::RegisterSpec for RTC_CNT_32K_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [rtc_cnt_32k::R](R) reader structure
        impl crate::Readable for RTC_CNT_32K_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets RTC_CNT_32K to value 0
        impl crate::Resettable for RTC_CNT_32K_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///RTC_CNT_2S (r) register accessor: an alias for `Reg<RTC_CNT_2S_SPEC>`
    pub type RTC_CNT_2S = crate::Reg<rtc_cnt_2s::RTC_CNT_2S_SPEC>;
    ///RO, RTC count based 2 second
    pub mod rtc_cnt_2s {
        ///Register `RTC_CNT_2S` reader
        pub struct R(crate::R<RTC_CNT_2S_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<RTC_CNT_2S_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<RTC_CNT_2S_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<RTC_CNT_2S_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `RTC_CNT_2S` reader - RO, RTC count based 2 second
        pub type RTC_CNT_2S_R = crate::FieldReader<u16, u16>;
        impl R {
            ///Bits 0:15 - RO, RTC count based 2 second
            #[inline(always)]
            pub fn rtc_cnt_2s(&self) -> RTC_CNT_2S_R {
                RTC_CNT_2S_R::new(self.bits)
            }
        }
        ///RO, RTC count based 2 second
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [rtc_cnt_2s](index.html) module
        pub struct RTC_CNT_2S_SPEC;
        impl crate::RegisterSpec for RTC_CNT_2S_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [rtc_cnt_2s::R](R) reader structure
        impl crate::Readable for RTC_CNT_2S_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets RTC_CNT_2S to value 0
        impl crate::Resettable for RTC_CNT_2S_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///RTC_CNT_DAY (r) register accessor: an alias for `Reg<RTC_CNT_DAY_SPEC>`
    pub type RTC_CNT_DAY = crate::Reg<rtc_cnt_day::RTC_CNT_DAY_SPEC>;
    ///RO, RTC count based one day, only low 14 bit
    pub mod rtc_cnt_day {
        ///Register `RTC_CNT_DAY` reader
        pub struct R(crate::R<RTC_CNT_DAY_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<RTC_CNT_DAY_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<RTC_CNT_DAY_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<RTC_CNT_DAY_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `RTC_CNT_DAY` reader - RWA,RTC count based one day
        pub type RTC_CNT_DAY_R = crate::FieldReader<u16, u16>;
        impl R {
            ///Bits 0:13 - RWA,RTC count based one day
            #[inline(always)]
            pub fn rtc_cnt_day(&self) -> RTC_CNT_DAY_R {
                RTC_CNT_DAY_R::new((self.bits & 0x3fff) as u16)
            }
        }
        ///RO, RTC count based one day, only low 14 bit
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [rtc_cnt_day](index.html) module
        pub struct RTC_CNT_DAY_SPEC;
        impl crate::RegisterSpec for RTC_CNT_DAY_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [rtc_cnt_day::R](R) reader structure
        impl crate::Readable for RTC_CNT_DAY_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets RTC_CNT_DAY to value 0
        impl crate::Resettable for RTC_CNT_DAY_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///SAFE_ACCESS_SIG (rw) register accessor: an alias for `Reg<SAFE_ACCESS_SIG_SPEC>`
    pub type SAFE_ACCESS_SIG = crate::Reg<safe_access_sig::SAFE_ACCESS_SIG_SPEC>;
    ///WO, safe accessing sign register, must write SAFE_ACCESS_SIG1 then SAFE_ACCESS_SIG2 to enter safe accessing mode
    pub mod safe_access_sig {
        ///Register `SAFE_ACCESS_SIG` reader
        pub struct R(crate::R<SAFE_ACCESS_SIG_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<SAFE_ACCESS_SIG_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<SAFE_ACCESS_SIG_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<SAFE_ACCESS_SIG_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `SAFE_ACCESS_SIG` writer
        pub struct W(crate::W<SAFE_ACCESS_SIG_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<SAFE_ACCESS_SIG_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<SAFE_ACCESS_SIG_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<SAFE_ACCESS_SIG_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `SAFE_ACC_MODE` reader - RO, current safe accessing mode: 11=safe unlocked (SAM), other=locked (00..01..10..11)
        pub type SAFE_ACC_MODE_R = crate::FieldReader<u8, u8>;
        ///Field `SAFE_ACC_MODE` writer - RO, current safe accessing mode: 11=safe unlocked (SAM), other=locked (00..01..10..11)
        pub type SAFE_ACC_MODE_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, SAFE_ACCESS_SIG_SPEC, u8, u8, 2, O>;
        ///Field `SAFE_ACCESS_SIG` reader - WO, safe accessing sign register, must write 0x57 then 0xA8 to enter safe accessing mode
        pub type SAFE_ACCESS_SIG_R = crate::FieldReader<u8, u8>;
        ///Field `SAFE_ACCESS_SIG` writer - WO, safe accessing sign register, must write 0x57 then 0xA8 to enter safe accessing mode
        pub type SAFE_ACCESS_SIG_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, SAFE_ACCESS_SIG_SPEC, u8, u8, 8, O>;
        ///Field `SAFE_ACC_ACT` reader - RO, indicate safe accessing status now: 0=locked, read-only, 1=safe/unlocked (SAM), write enabled
        pub type SAFE_ACC_ACT_R = crate::BitReader<bool>;
        ///Field `SAFE_ACC_ACT` writer - RO, indicate safe accessing status now: 0=locked, read-only, 1=safe/unlocked (SAM), write enabled
        pub type SAFE_ACC_ACT_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, SAFE_ACCESS_SIG_SPEC, bool, O>;
        ///Field `SAFE_ACC_TIMER` reader - RO, safe accessing timer bit mask (16*clock number)
        pub type SAFE_ACC_TIMER_R = crate::FieldReader<u8, u8>;
        ///Field `SAFE_ACC_TIMER` writer - RO, safe accessing timer bit mask (16*clock number)
        pub type SAFE_ACC_TIMER_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, SAFE_ACCESS_SIG_SPEC, u8, u8, 3, O>;
        impl R {
            ///Bits 0:1 - RO, current safe accessing mode: 11=safe unlocked (SAM), other=locked (00..01..10..11)
            #[inline(always)]
            pub fn safe_acc_mode(&self) -> SAFE_ACC_MODE_R {
                SAFE_ACC_MODE_R::new(self.bits & 3)
            }
            ///Bits 0:7 - WO, safe accessing sign register, must write 0x57 then 0xA8 to enter safe accessing mode
            #[inline(always)]
            pub fn safe_access_sig(&self) -> SAFE_ACCESS_SIG_R {
                SAFE_ACCESS_SIG_R::new(self.bits)
            }
            ///Bit 3 - RO, indicate safe accessing status now: 0=locked, read-only, 1=safe/unlocked (SAM), write enabled
            #[inline(always)]
            pub fn safe_acc_act(&self) -> SAFE_ACC_ACT_R {
                SAFE_ACC_ACT_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bits 4:6 - RO, safe accessing timer bit mask (16*clock number)
            #[inline(always)]
            pub fn safe_acc_timer(&self) -> SAFE_ACC_TIMER_R {
                SAFE_ACC_TIMER_R::new((self.bits >> 4) & 7)
            }
        }
        impl W {
            ///Bits 0:1 - RO, current safe accessing mode: 11=safe unlocked (SAM), other=locked (00..01..10..11)
            #[inline(always)]
            #[must_use]
            pub fn safe_acc_mode(&mut self) -> SAFE_ACC_MODE_W<0> {
                SAFE_ACC_MODE_W::new(self)
            }
            ///Bits 0:7 - WO, safe accessing sign register, must write 0x57 then 0xA8 to enter safe accessing mode
            #[inline(always)]
            #[must_use]
            pub fn safe_access_sig(&mut self) -> SAFE_ACCESS_SIG_W<0> {
                SAFE_ACCESS_SIG_W::new(self)
            }
            ///Bit 3 - RO, indicate safe accessing status now: 0=locked, read-only, 1=safe/unlocked (SAM), write enabled
            #[inline(always)]
            #[must_use]
            pub fn safe_acc_act(&mut self) -> SAFE_ACC_ACT_W<3> {
                SAFE_ACC_ACT_W::new(self)
            }
            ///Bits 4:6 - RO, safe accessing timer bit mask (16*clock number)
            #[inline(always)]
            #[must_use]
            pub fn safe_acc_timer(&mut self) -> SAFE_ACC_TIMER_W<4> {
                SAFE_ACC_TIMER_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///WO, safe accessing sign register, must write SAFE_ACCESS_SIG1 then SAFE_ACCESS_SIG2 to enter safe accessing mode
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [safe_access_sig](index.html) module
        pub struct SAFE_ACCESS_SIG_SPEC;
        impl crate::RegisterSpec for SAFE_ACCESS_SIG_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [safe_access_sig::R](R) reader structure
        impl crate::Readable for SAFE_ACCESS_SIG_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [safe_access_sig::W](W) writer structure
        impl crate::Writable for SAFE_ACCESS_SIG_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets SAFE_ACCESS_SIG to value 0
        impl crate::Resettable for SAFE_ACCESS_SIG_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///CHIP_ID (r) register accessor: an alias for `Reg<CHIP_ID_SPEC>`
    pub type CHIP_ID = crate::Reg<chip_id::CHIP_ID_SPEC>;
    ///RF, chip ID register, always is ID_CH58*
    pub mod chip_id {
        ///Register `CHIP_ID` reader
        pub struct R(crate::R<CHIP_ID_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CHIP_ID_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<CHIP_ID_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<CHIP_ID_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `CHIP_ID` reader - RF,chip ID register
        pub type CHIP_ID_R = crate::FieldReader<u8, u8>;
        impl R {
            ///Bits 0:7 - RF,chip ID register
            #[inline(always)]
            pub fn chip_id(&self) -> CHIP_ID_R {
                CHIP_ID_R::new(self.bits)
            }
        }
        ///RF, chip ID register, always is ID_CH58*
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [chip_id](index.html) module
        pub struct CHIP_ID_SPEC;
        impl crate::RegisterSpec for CHIP_ID_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [chip_id::R](R) reader structure
        impl crate::Readable for CHIP_ID_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets CHIP_ID to value 0x83
        impl crate::Resettable for CHIP_ID_SPEC {
            const RESET_VALUE: Self::Ux = 0x83;
        }
    }
    ///SAFE_ACCESS_ID (r) register accessor: an alias for `Reg<SAFE_ACCESS_ID_SPEC>`
    pub type SAFE_ACCESS_ID = crate::Reg<safe_access_id::SAFE_ACCESS_ID_SPEC>;
    ///RF, safe accessing ID register, always 0x0C
    pub mod safe_access_id {
        ///Register `SAFE_ACCESS_ID` reader
        pub struct R(crate::R<SAFE_ACCESS_ID_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<SAFE_ACCESS_ID_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<SAFE_ACCESS_ID_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<SAFE_ACCESS_ID_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `SAFE_ACCESS_ID` reader - RF,safe accessing ID register
        pub type SAFE_ACCESS_ID_R = crate::FieldReader<u8, u8>;
        impl R {
            ///Bits 0:7 - RF,safe accessing ID register
            #[inline(always)]
            pub fn safe_access_id(&self) -> SAFE_ACCESS_ID_R {
                SAFE_ACCESS_ID_R::new(self.bits)
            }
        }
        ///RF, safe accessing ID register, always 0x0C
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [safe_access_id](index.html) module
        pub struct SAFE_ACCESS_ID_SPEC;
        impl crate::RegisterSpec for SAFE_ACCESS_ID_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [safe_access_id::R](R) reader structure
        impl crate::Readable for SAFE_ACCESS_ID_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets SAFE_ACCESS_ID to value 0x0c
        impl crate::Resettable for SAFE_ACCESS_ID_SPEC {
            const RESET_VALUE: Self::Ux = 0x0c;
        }
    }
    ///WDOG_COUNT (rw) register accessor: an alias for `Reg<WDOG_COUNT_SPEC>`
    pub type WDOG_COUNT = crate::Reg<wdog_count::WDOG_COUNT_SPEC>;
    ///RW, watch-dog count, count by clock frequency Fsys/131072
    pub mod wdog_count {
        ///Register `WDOG_COUNT` reader
        pub struct R(crate::R<WDOG_COUNT_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<WDOG_COUNT_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<WDOG_COUNT_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<WDOG_COUNT_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `WDOG_COUNT` writer
        pub struct W(crate::W<WDOG_COUNT_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<WDOG_COUNT_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<WDOG_COUNT_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<WDOG_COUNT_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `WDOG_COUNT` reader - RF,watch-dog count, count by clock frequency Fsys/131072
        pub type WDOG_COUNT_R = crate::FieldReader<u8, u8>;
        ///Field `WDOG_COUNT` writer - RF,watch-dog count, count by clock frequency Fsys/131072
        pub type WDOG_COUNT_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, WDOG_COUNT_SPEC, u8, u8, 8, O>;
        impl R {
            ///Bits 0:7 - RF,watch-dog count, count by clock frequency Fsys/131072
            #[inline(always)]
            pub fn wdog_count(&self) -> WDOG_COUNT_R {
                WDOG_COUNT_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:7 - RF,watch-dog count, count by clock frequency Fsys/131072
            #[inline(always)]
            #[must_use]
            pub fn wdog_count(&mut self) -> WDOG_COUNT_W<0> {
                WDOG_COUNT_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, watch-dog count, count by clock frequency Fsys/131072
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [wdog_count](index.html) module
        pub struct WDOG_COUNT_SPEC;
        impl crate::RegisterSpec for WDOG_COUNT_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [wdog_count::R](R) reader structure
        impl crate::Readable for WDOG_COUNT_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [wdog_count::W](W) writer structure
        impl crate::Writable for WDOG_COUNT_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets WDOG_COUNT to value 0
        impl crate::Resettable for WDOG_COUNT_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///RESET_STATUS__R8_GLOB_ROM_CFG (r) register accessor: an alias for `Reg<RESET_STATUS__R8_GLOB_ROM_CFG_SPEC>`
    pub type RESET_STATUS__R8_GLOB_ROM_CFG =
        crate::Reg<reset_status__r8_glob_rom_cfg::RESET_STATUS__R8_GLOB_ROM_CFG_SPEC>;
    ///RWA, reset status, SAM or flash ROM configuration
    pub mod reset_status__r8_glob_rom_cfg {
        ///Register `RESET_STATUS__R8_GLOB_ROM_CFG` reader
        pub struct R(crate::R<RESET_STATUS__R8_GLOB_ROM_CFG_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<RESET_STATUS__R8_GLOB_ROM_CFG_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<RESET_STATUS__R8_GLOB_ROM_CFG_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<RESET_STATUS__R8_GLOB_ROM_CFG_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `RESET_FLAG` reader - RO, recent reset flag
        pub type RESET_FLAG_R = crate::FieldReader<u8, u8>;
        ///Field `ROM_CODE_OFS` reader - RWA, code offset address selection in Flash ROM: 0=start address 0x000000, 1=start address 0x008000
        pub type ROM_CODE_OFS_R = crate::BitReader<bool>;
        ///Field `ROM_CTRL_EN` reader - RWA, enable flash ROM control interface enable
        pub type ROM_CTRL_EN_R = crate::BitReader<bool>;
        ///Field `ROM_DATA_WE` reader - RWA,enable flash ROM data and code area being erase/write
        pub type ROM_DATA_WE_R = crate::BitReader<bool>;
        ///Field `ROM_CODE_WE` reader - RWA, enable flash ROM code area being erase or write
        pub type ROM_CODE_WE_R = crate::BitReader<bool>;
        impl R {
            ///Bits 0:2 - RO, recent reset flag
            #[inline(always)]
            pub fn reset_flag(&self) -> RESET_FLAG_R {
                RESET_FLAG_R::new(self.bits & 7)
            }
            ///Bit 4 - RWA, code offset address selection in Flash ROM: 0=start address 0x000000, 1=start address 0x008000
            #[inline(always)]
            pub fn rom_code_ofs(&self) -> ROM_CODE_OFS_R {
                ROM_CODE_OFS_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - RWA, enable flash ROM control interface enable
            #[inline(always)]
            pub fn rom_ctrl_en(&self) -> ROM_CTRL_EN_R {
                ROM_CTRL_EN_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - RWA,enable flash ROM data and code area being erase/write
            #[inline(always)]
            pub fn rom_data_we(&self) -> ROM_DATA_WE_R {
                ROM_DATA_WE_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - RWA, enable flash ROM code area being erase or write
            #[inline(always)]
            pub fn rom_code_we(&self) -> ROM_CODE_WE_R {
                ROM_CODE_WE_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        ///RWA, reset status, SAM or flash ROM configuration
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [reset_status__r8_glob_rom_cfg](index.html) module
        pub struct RESET_STATUS__R8_GLOB_ROM_CFG_SPEC;
        impl crate::RegisterSpec for RESET_STATUS__R8_GLOB_ROM_CFG_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [reset_status__r8_glob_rom_cfg::R](R) reader structure
        impl crate::Readable for RESET_STATUS__R8_GLOB_ROM_CFG_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets RESET_STATUS__R8_GLOB_ROM_CFG to value 0x01
        impl crate::Resettable for RESET_STATUS__R8_GLOB_ROM_CFG_SPEC {
            const RESET_VALUE: Self::Ux = 0x01;
        }
    }
    ///GLOB_CFG_INFO (r) register accessor: an alias for `Reg<GLOB_CFG_INFO_SPEC>`
    pub type GLOB_CFG_INFO = crate::Reg<glob_cfg_info::GLOB_CFG_INFO_SPEC>;
    ///RO, global configuration information and status
    pub mod glob_cfg_info {
        ///Register `GLOB_CFG_INFO` reader
        pub struct R(crate::R<GLOB_CFG_INFO_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<GLOB_CFG_INFO_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<GLOB_CFG_INFO_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<GLOB_CFG_INFO_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `CFG_ROM_READ` reader - RO, indicate protected status of Flash ROM code and data: 0=reading protect, 1=enable read by external programmer
        pub type CFG_ROM_READ_R = crate::BitReader<bool>;
        ///Field `CFG_RESET_EN` reader - RO, manual reset input enable status
        pub type CFG_RESET_EN_R = crate::BitReader<bool>;
        ///Field `CFG_BOOT_EN` reader - RO, boot-loader enable status
        pub type CFG_BOOT_EN_R = crate::BitReader<bool>;
        ///Field `CFG_DEBUG_EN` reader - RO, debug enable status
        pub type CFG_DEBUG_EN_R = crate::BitReader<bool>;
        ///Field `BOOT_LOADER` reader - RO, indicate boot loader status: 0=application status (by software reset), 1=boot loader status
        pub type BOOT_LOADER_R = crate::BitReader<bool>;
        impl R {
            ///Bit 0 - RO, indicate protected status of Flash ROM code and data: 0=reading protect, 1=enable read by external programmer
            #[inline(always)]
            pub fn cfg_rom_read(&self) -> CFG_ROM_READ_R {
                CFG_ROM_READ_R::new((self.bits & 1) != 0)
            }
            ///Bit 2 - RO, manual reset input enable status
            #[inline(always)]
            pub fn cfg_reset_en(&self) -> CFG_RESET_EN_R {
                CFG_RESET_EN_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RO, boot-loader enable status
            #[inline(always)]
            pub fn cfg_boot_en(&self) -> CFG_BOOT_EN_R {
                CFG_BOOT_EN_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RO, debug enable status
            #[inline(always)]
            pub fn cfg_debug_en(&self) -> CFG_DEBUG_EN_R {
                CFG_DEBUG_EN_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - RO, indicate boot loader status: 0=application status (by software reset), 1=boot loader status
            #[inline(always)]
            pub fn boot_loader(&self) -> BOOT_LOADER_R {
                BOOT_LOADER_R::new(((self.bits >> 5) & 1) != 0)
            }
        }
        ///RO, global configuration information and status
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [glob_cfg_info](index.html) module
        pub struct GLOB_CFG_INFO_SPEC;
        impl crate::RegisterSpec for GLOB_CFG_INFO_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [glob_cfg_info::R](R) reader structure
        impl crate::Readable for GLOB_CFG_INFO_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets GLOB_CFG_INFO to value 0x0e
        impl crate::Resettable for GLOB_CFG_INFO_SPEC {
            const RESET_VALUE: Self::Ux = 0x0e;
        }
    }
    ///RST_WDOG_CTRL (rw) register accessor: an alias for `Reg<RST_WDOG_CTRL_SPEC>`
    pub type RST_WDOG_CTRL = crate::Reg<rst_wdog_ctrl::RST_WDOG_CTRL_SPEC>;
    ///RWA, reset and watch-dog control, SAM
    pub mod rst_wdog_ctrl {
        ///Register `RST_WDOG_CTRL` reader
        pub struct R(crate::R<RST_WDOG_CTRL_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<RST_WDOG_CTRL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<RST_WDOG_CTRL_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<RST_WDOG_CTRL_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `RST_WDOG_CTRL` writer
        pub struct W(crate::W<RST_WDOG_CTRL_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<RST_WDOG_CTRL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<RST_WDOG_CTRL_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<RST_WDOG_CTRL_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `SOFTWARE_RESET` reader - WA or WZ, global software reset, high action, auto clear
        pub type SOFTWARE_RESET_R = crate::BitReader<bool>;
        ///Field `SOFTWARE_RESET` writer - WA or WZ, global software reset, high action, auto clear
        pub type SOFTWARE_RESET_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, RST_WDOG_CTRL_SPEC, bool, O>;
        ///Field `WDOG_RST_EN` reader - RWA, enable watch-dog reset if watch-dog timer overflow: 0=as timer only, 1=enable reset if timer overflow
        pub type WDOG_RST_EN_R = crate::BitReader<bool>;
        ///Field `WDOG_RST_EN` writer - RWA, enable watch-dog reset if watch-dog timer overflow: 0=as timer only, 1=enable reset if timer overflow
        pub type WDOG_RST_EN_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, RST_WDOG_CTRL_SPEC, bool, O>;
        ///Field `WDOG_INT_EN` reader - RWA, watch-dog timer overflow interrupt enable: 0=disable, 1=enable
        pub type WDOG_INT_EN_R = crate::BitReader<bool>;
        ///Field `WDOG_INT_EN` writer - RWA, watch-dog timer overflow interrupt enable: 0=disable, 1=enable
        pub type WDOG_INT_EN_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, RST_WDOG_CTRL_SPEC, bool, O>;
        ///Field `WDOG_INT_FLAG` reader - RW1, watch-dog timer overflow interrupt flag, cleared by RW1 or reload watch-dog count or __SEV(Send-Event)
        pub type WDOG_INT_FLAG_R = crate::BitReader<bool>;
        ///Field `WDOG_INT_FLAG` writer - RW1, watch-dog timer overflow interrupt flag, cleared by RW1 or reload watch-dog count or __SEV(Send-Event)
        pub type WDOG_INT_FLAG_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, RST_WDOG_CTRL_SPEC, bool, O>;
        impl R {
            ///Bit 0 - WA or WZ, global software reset, high action, auto clear
            #[inline(always)]
            pub fn software_reset(&self) -> SOFTWARE_RESET_R {
                SOFTWARE_RESET_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RWA, enable watch-dog reset if watch-dog timer overflow: 0=as timer only, 1=enable reset if timer overflow
            #[inline(always)]
            pub fn wdog_rst_en(&self) -> WDOG_RST_EN_R {
                WDOG_RST_EN_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RWA, watch-dog timer overflow interrupt enable: 0=disable, 1=enable
            #[inline(always)]
            pub fn wdog_int_en(&self) -> WDOG_INT_EN_R {
                WDOG_INT_EN_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 4 - RW1, watch-dog timer overflow interrupt flag, cleared by RW1 or reload watch-dog count or __SEV(Send-Event)
            #[inline(always)]
            pub fn wdog_int_flag(&self) -> WDOG_INT_FLAG_R {
                WDOG_INT_FLAG_R::new(((self.bits >> 4) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - WA or WZ, global software reset, high action, auto clear
            #[inline(always)]
            #[must_use]
            pub fn software_reset(&mut self) -> SOFTWARE_RESET_W<0> {
                SOFTWARE_RESET_W::new(self)
            }
            ///Bit 1 - RWA, enable watch-dog reset if watch-dog timer overflow: 0=as timer only, 1=enable reset if timer overflow
            #[inline(always)]
            #[must_use]
            pub fn wdog_rst_en(&mut self) -> WDOG_RST_EN_W<1> {
                WDOG_RST_EN_W::new(self)
            }
            ///Bit 2 - RWA, watch-dog timer overflow interrupt enable: 0=disable, 1=enable
            #[inline(always)]
            #[must_use]
            pub fn wdog_int_en(&mut self) -> WDOG_INT_EN_W<2> {
                WDOG_INT_EN_W::new(self)
            }
            ///Bit 4 - RW1, watch-dog timer overflow interrupt flag, cleared by RW1 or reload watch-dog count or __SEV(Send-Event)
            #[inline(always)]
            #[must_use]
            pub fn wdog_int_flag(&mut self) -> WDOG_INT_FLAG_W<4> {
                WDOG_INT_FLAG_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RWA, reset and watch-dog control, SAM
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [rst_wdog_ctrl](index.html) module
        pub struct RST_WDOG_CTRL_SPEC;
        impl crate::RegisterSpec for RST_WDOG_CTRL_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [rst_wdog_ctrl::R](R) reader structure
        impl crate::Readable for RST_WDOG_CTRL_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [rst_wdog_ctrl::W](W) writer structure
        impl crate::Writable for RST_WDOG_CTRL_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets RST_WDOG_CTRL to value 0
        impl crate::Resettable for RST_WDOG_CTRL_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///GLOB_RESET_KEEP (rw) register accessor: an alias for `Reg<GLOB_RESET_KEEP_SPEC>`
    pub type GLOB_RESET_KEEP = crate::Reg<glob_reset_keep::GLOB_RESET_KEEP_SPEC>;
    ///RW, value keeper during global reset
    pub mod glob_reset_keep {
        ///Register `GLOB_RESET_KEEP` reader
        pub struct R(crate::R<GLOB_RESET_KEEP_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<GLOB_RESET_KEEP_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<GLOB_RESET_KEEP_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<GLOB_RESET_KEEP_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `GLOB_RESET_KEEP` writer
        pub struct W(crate::W<GLOB_RESET_KEEP_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<GLOB_RESET_KEEP_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<GLOB_RESET_KEEP_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<GLOB_RESET_KEEP_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `GLOB_RESET_KEEP` reader - RW, value keeper during global reset
        pub type GLOB_RESET_KEEP_R = crate::FieldReader<u8, u8>;
        ///Field `GLOB_RESET_KEEP` writer - RW, value keeper during global reset
        pub type GLOB_RESET_KEEP_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, GLOB_RESET_KEEP_SPEC, u8, u8, 8, O>;
        impl R {
            ///Bits 0:7 - RW, value keeper during global reset
            #[inline(always)]
            pub fn glob_reset_keep(&self) -> GLOB_RESET_KEEP_R {
                GLOB_RESET_KEEP_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:7 - RW, value keeper during global reset
            #[inline(always)]
            #[must_use]
            pub fn glob_reset_keep(&mut self) -> GLOB_RESET_KEEP_W<0> {
                GLOB_RESET_KEEP_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, value keeper during global reset
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [glob_reset_keep](index.html) module
        pub struct GLOB_RESET_KEEP_SPEC;
        impl crate::RegisterSpec for GLOB_RESET_KEEP_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [glob_reset_keep::R](R) reader structure
        impl crate::Readable for GLOB_RESET_KEEP_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [glob_reset_keep::W](W) writer structure
        impl crate::Writable for GLOB_RESET_KEEP_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets GLOB_RESET_KEEP to value 0
        impl crate::Resettable for GLOB_RESET_KEEP_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///PLL_CONFIG (rw) register accessor: an alias for `Reg<PLL_CONFIG_SPEC>`
    pub type PLL_CONFIG = crate::Reg<pll_config::PLL_CONFIG_SPEC>;
    ///RWA, PLL configuration control, SAM
    pub mod pll_config {
        ///Register `PLL_CONFIG` reader
        pub struct R(crate::R<PLL_CONFIG_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PLL_CONFIG_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<PLL_CONFIG_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<PLL_CONFIG_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `PLL_CONFIG` writer
        pub struct W(crate::W<PLL_CONFIG_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PLL_CONFIG_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<PLL_CONFIG_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<PLL_CONFIG_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `PLL_CFG_DAT` reader - RWA, PLL configure data
        pub type PLL_CFG_DAT_R = crate::FieldReader<u8, u8>;
        ///Field `PLL_CFG_DAT` writer - RWA, PLL configure data
        pub type PLL_CFG_DAT_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, PLL_CONFIG_SPEC, u8, u8, 7, O>;
        ///Field `FLASH_IO_MOD` reader - RWA, flash ROM interface mode
        pub type FLASH_IO_MOD_R = crate::BitReader<bool>;
        ///Field `FLASH_IO_MOD` writer - RWA, flash ROM interface mode
        pub type FLASH_IO_MOD_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, PLL_CONFIG_SPEC, bool, O>;
        impl R {
            ///Bits 0:6 - RWA, PLL configure data
            #[inline(always)]
            pub fn pll_cfg_dat(&self) -> PLL_CFG_DAT_R {
                PLL_CFG_DAT_R::new(self.bits & 0x7f)
            }
            ///Bit 7 - RWA, flash ROM interface mode
            #[inline(always)]
            pub fn flash_io_mod(&self) -> FLASH_IO_MOD_R {
                FLASH_IO_MOD_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:6 - RWA, PLL configure data
            #[inline(always)]
            #[must_use]
            pub fn pll_cfg_dat(&mut self) -> PLL_CFG_DAT_W<0> {
                PLL_CFG_DAT_W::new(self)
            }
            ///Bit 7 - RWA, flash ROM interface mode
            #[inline(always)]
            #[must_use]
            pub fn flash_io_mod(&mut self) -> FLASH_IO_MOD_W<7> {
                FLASH_IO_MOD_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RWA, PLL configuration control, SAM
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [pll_config](index.html) module
        pub struct PLL_CONFIG_SPEC;
        impl crate::RegisterSpec for PLL_CONFIG_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [pll_config::R](R) reader structure
        impl crate::Readable for PLL_CONFIG_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [pll_config::W](W) writer structure
        impl crate::Writable for PLL_CONFIG_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets PLL_CONFIG to value 0x4a
        impl crate::Resettable for PLL_CONFIG_SPEC {
            const RESET_VALUE: Self::Ux = 0x4a;
        }
    }
    ///XT32M_TUNE (rw) register accessor: an alias for `Reg<XT32M_TUNE_SPEC>`
    pub type XT32M_TUNE = crate::Reg<xt32m_tune::XT32M_TUNE_SPEC>;
    ///RWA, external 32MHz oscillator tune control, SAM
    pub mod xt32m_tune {
        ///Register `XT32M_TUNE` reader
        pub struct R(crate::R<XT32M_TUNE_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<XT32M_TUNE_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<XT32M_TUNE_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<XT32M_TUNE_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `XT32M_TUNE` writer
        pub struct W(crate::W<XT32M_TUNE_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<XT32M_TUNE_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<XT32M_TUNE_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<XT32M_TUNE_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `XT32M_I_BIAS` reader - RWA, external 32MHz oscillator bias current tune: 00=75% current, 01=standard current, 10=125% current, 11=150% current
        pub type XT32M_I_BIAS_R = crate::FieldReader<u8, u8>;
        ///Field `XT32M_I_BIAS` writer - RWA, external 32MHz oscillator bias current tune: 00=75% current, 01=standard current, 10=125% current, 11=150% current
        pub type XT32M_I_BIAS_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, XT32M_TUNE_SPEC, u8, u8, 2, O>;
        ///Field `XT32M_C_LOAD` reader - RWA, external 32MHz oscillator load capacitor tune: Cap = RB_XT32M_C_LOAD * 2 + 10pF
        pub type XT32M_C_LOAD_R = crate::FieldReader<u8, u8>;
        ///Field `XT32M_C_LOAD` writer - RWA, external 32MHz oscillator load capacitor tune: Cap = RB_XT32M_C_LOAD * 2 + 10pF
        pub type XT32M_C_LOAD_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, XT32M_TUNE_SPEC, u8, u8, 3, O>;
        impl R {
            ///Bits 0:1 - RWA, external 32MHz oscillator bias current tune: 00=75% current, 01=standard current, 10=125% current, 11=150% current
            #[inline(always)]
            pub fn xt32m_i_bias(&self) -> XT32M_I_BIAS_R {
                XT32M_I_BIAS_R::new(self.bits & 3)
            }
            ///Bits 4:6 - RWA, external 32MHz oscillator load capacitor tune: Cap = RB_XT32M_C_LOAD * 2 + 10pF
            #[inline(always)]
            pub fn xt32m_c_load(&self) -> XT32M_C_LOAD_R {
                XT32M_C_LOAD_R::new((self.bits >> 4) & 7)
            }
        }
        impl W {
            ///Bits 0:1 - RWA, external 32MHz oscillator bias current tune: 00=75% current, 01=standard current, 10=125% current, 11=150% current
            #[inline(always)]
            #[must_use]
            pub fn xt32m_i_bias(&mut self) -> XT32M_I_BIAS_W<0> {
                XT32M_I_BIAS_W::new(self)
            }
            ///Bits 4:6 - RWA, external 32MHz oscillator load capacitor tune: Cap = RB_XT32M_C_LOAD * 2 + 10pF
            #[inline(always)]
            #[must_use]
            pub fn xt32m_c_load(&mut self) -> XT32M_C_LOAD_W<4> {
                XT32M_C_LOAD_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RWA, external 32MHz oscillator tune control, SAM
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [xt32m_tune](index.html) module
        pub struct XT32M_TUNE_SPEC;
        impl crate::RegisterSpec for XT32M_TUNE_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [xt32m_tune::R](R) reader structure
        impl crate::Readable for XT32M_TUNE_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [xt32m_tune::W](W) writer structure
        impl crate::Writable for XT32M_TUNE_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets XT32M_TUNE to value 0x32
        impl crate::Resettable for XT32M_TUNE_SPEC {
            const RESET_VALUE: Self::Ux = 0x32;
        }
    }
    ///OSC_CAL_CNT (r) register accessor: an alias for `Reg<OSC_CAL_CNT_SPEC>`
    pub type OSC_CAL_CNT = crate::Reg<osc_cal_cnt::OSC_CAL_CNT_SPEC>;
    ///RO, system clock count value for 32KHz multi-cycles
    pub mod osc_cal_cnt {
        ///Register `OSC_CAL_CNT` reader
        pub struct R(crate::R<OSC_CAL_CNT_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<OSC_CAL_CNT_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<OSC_CAL_CNT_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<OSC_CAL_CNT_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `OSC_CAL_CNT` reader - RO, system clock count value for 32KHz multi-cycles
        pub type OSC_CAL_CNT_R = crate::FieldReader<u16, u16>;
        ///Field `OSC_CAL_OV_CLR` reader - RW1, indicate R8_OSC_CAL_OV_CNT not zero, set 1 to clear R8_OSC_CAL_OV_CNT
        pub type OSC_CAL_OV_CLR_R = crate::BitReader<bool>;
        ///Field `OSC_CAL_IF` reader - RW1, interrupt flag for oscillator capture end, set 1 to clear
        pub type OSC_CAL_IF_R = crate::BitReader<bool>;
        impl R {
            ///Bits 0:13 - RO, system clock count value for 32KHz multi-cycles
            #[inline(always)]
            pub fn osc_cal_cnt(&self) -> OSC_CAL_CNT_R {
                OSC_CAL_CNT_R::new(self.bits & 0x3fff)
            }
            ///Bit 14 - RW1, indicate R8_OSC_CAL_OV_CNT not zero, set 1 to clear R8_OSC_CAL_OV_CNT
            #[inline(always)]
            pub fn osc_cal_ov_clr(&self) -> OSC_CAL_OV_CLR_R {
                OSC_CAL_OV_CLR_R::new(((self.bits >> 14) & 1) != 0)
            }
            ///Bit 15 - RW1, interrupt flag for oscillator capture end, set 1 to clear
            #[inline(always)]
            pub fn osc_cal_if(&self) -> OSC_CAL_IF_R {
                OSC_CAL_IF_R::new(((self.bits >> 15) & 1) != 0)
            }
        }
        ///RO, system clock count value for 32KHz multi-cycles
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [osc_cal_cnt](index.html) module
        pub struct OSC_CAL_CNT_SPEC;
        impl crate::RegisterSpec for OSC_CAL_CNT_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [osc_cal_cnt::R](R) reader structure
        impl crate::Readable for OSC_CAL_CNT_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets OSC_CAL_CNT to value 0
        impl crate::Resettable for OSC_CAL_CNT_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///OSC_CAL_CTRL (rw) register accessor: an alias for `Reg<OSC_CAL_CTRL_SPEC>`
    pub type OSC_CAL_CTRL = crate::Reg<osc_cal_ctrl::OSC_CAL_CTRL_SPEC>;
    ///RWA, oscillator frequency calibration control, SAM
    pub mod osc_cal_ctrl {
        ///Register `OSC_CAL_CTRL` reader
        pub struct R(crate::R<OSC_CAL_CTRL_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<OSC_CAL_CTRL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<OSC_CAL_CTRL_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<OSC_CAL_CTRL_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `OSC_CAL_CTRL` writer
        pub struct W(crate::W<OSC_CAL_CTRL_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<OSC_CAL_CTRL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<OSC_CAL_CTRL_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<OSC_CAL_CTRL_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `OSC_CNT_TOTAL` reader - RWA, total cycles mode for oscillator capture
        pub type OSC_CNT_TOTAL_R = crate::FieldReader<u8, u8>;
        ///Field `OSC_CNT_TOTAL` writer - RWA, total cycles mode for oscillator capture
        pub type OSC_CNT_TOTAL_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, OSC_CAL_CTRL_SPEC, u8, u8, 3, O>;
        ///Field `OSC_CNT_HALT` reader - RO, calibration counter halt status: 0=counting, 1=halt for reading count value
        pub type OSC_CNT_HALT_R = crate::BitReader<bool>;
        ///Field `OSC_CAL_IE` reader - RWA, interrupt enable for oscillator capture end
        pub type OSC_CAL_IE_R = crate::BitReader<bool>;
        ///Field `OSC_CAL_IE` writer - RWA, interrupt enable for oscillator capture end
        pub type OSC_CAL_IE_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, OSC_CAL_CTRL_SPEC, bool, O>;
        ///Field `OSC_CNT_EN` reader - RWA, calibration counter enable
        pub type OSC_CNT_EN_R = crate::BitReader<bool>;
        ///Field `OSC_CNT_EN` writer - RWA, calibration counter enable
        pub type OSC_CNT_EN_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, OSC_CAL_CTRL_SPEC, bool, O>;
        ///Field `OSC_CNT_END` reader - RWA, select oscillator capture end mode: 0=normal, 1=append 2 cycles
        pub type OSC_CNT_END_R = crate::BitReader<bool>;
        ///Field `OSC_CNT_END` writer - RWA, select oscillator capture end mode: 0=normal, 1=append 2 cycles
        pub type OSC_CNT_END_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, OSC_CAL_CTRL_SPEC, bool, O>;
        impl R {
            ///Bits 0:2 - RWA, total cycles mode for oscillator capture
            #[inline(always)]
            pub fn osc_cnt_total(&self) -> OSC_CNT_TOTAL_R {
                OSC_CNT_TOTAL_R::new(self.bits & 7)
            }
            ///Bit 3 - RO, calibration counter halt status: 0=counting, 1=halt for reading count value
            #[inline(always)]
            pub fn osc_cnt_halt(&self) -> OSC_CNT_HALT_R {
                OSC_CNT_HALT_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RWA, interrupt enable for oscillator capture end
            #[inline(always)]
            pub fn osc_cal_ie(&self) -> OSC_CAL_IE_R {
                OSC_CAL_IE_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - RWA, calibration counter enable
            #[inline(always)]
            pub fn osc_cnt_en(&self) -> OSC_CNT_EN_R {
                OSC_CNT_EN_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - RWA, select oscillator capture end mode: 0=normal, 1=append 2 cycles
            #[inline(always)]
            pub fn osc_cnt_end(&self) -> OSC_CNT_END_R {
                OSC_CNT_END_R::new(((self.bits >> 6) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:2 - RWA, total cycles mode for oscillator capture
            #[inline(always)]
            #[must_use]
            pub fn osc_cnt_total(&mut self) -> OSC_CNT_TOTAL_W<0> {
                OSC_CNT_TOTAL_W::new(self)
            }
            ///Bit 4 - RWA, interrupt enable for oscillator capture end
            #[inline(always)]
            #[must_use]
            pub fn osc_cal_ie(&mut self) -> OSC_CAL_IE_W<4> {
                OSC_CAL_IE_W::new(self)
            }
            ///Bit 5 - RWA, calibration counter enable
            #[inline(always)]
            #[must_use]
            pub fn osc_cnt_en(&mut self) -> OSC_CNT_EN_W<5> {
                OSC_CNT_EN_W::new(self)
            }
            ///Bit 6 - RWA, select oscillator capture end mode: 0=normal, 1=append 2 cycles
            #[inline(always)]
            #[must_use]
            pub fn osc_cnt_end(&mut self) -> OSC_CNT_END_W<6> {
                OSC_CNT_END_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RWA, oscillator frequency calibration control, SAM
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [osc_cal_ctrl](index.html) module
        pub struct OSC_CAL_CTRL_SPEC;
        impl crate::RegisterSpec for OSC_CAL_CTRL_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [osc_cal_ctrl::R](R) reader structure
        impl crate::Readable for OSC_CAL_CTRL_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [osc_cal_ctrl::W](W) writer structure
        impl crate::Writable for OSC_CAL_CTRL_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets OSC_CAL_CTRL to value 0x09
        impl crate::Resettable for OSC_CAL_CTRL_SPEC {
            const RESET_VALUE: Self::Ux = 0x09;
        }
    }
    ///OSC_CAL_OV_CNT (r) register accessor: an alias for `Reg<OSC_CAL_OV_CNT_SPEC>`
    pub type OSC_CAL_OV_CNT = crate::Reg<osc_cal_ov_cnt::OSC_CAL_OV_CNT_SPEC>;
    ///RO, oscillator frequency calibration overflow times
    pub mod osc_cal_ov_cnt {
        ///Register `OSC_CAL_OV_CNT` reader
        pub struct R(crate::R<OSC_CAL_OV_CNT_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<OSC_CAL_OV_CNT_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<OSC_CAL_OV_CNT_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<OSC_CAL_OV_CNT_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `OSC_CAL_OV_CNT` reader - RO, oscillator frequency calibration overflow times
        pub type OSC_CAL_OV_CNT_R = crate::FieldReader<u8, u8>;
        impl R {
            ///Bits 0:7 - RO, oscillator frequency calibration overflow times
            #[inline(always)]
            pub fn osc_cal_ov_cnt(&self) -> OSC_CAL_OV_CNT_R {
                OSC_CAL_OV_CNT_R::new(self.bits)
            }
        }
        ///RO, oscillator frequency calibration overflow times
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [osc_cal_ov_cnt](index.html) module
        pub struct OSC_CAL_OV_CNT_SPEC;
        impl crate::RegisterSpec for OSC_CAL_OV_CNT_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [osc_cal_ov_cnt::R](R) reader structure
        impl crate::Readable for OSC_CAL_OV_CNT_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets OSC_CAL_OV_CNT to value 0
        impl crate::Resettable for OSC_CAL_OV_CNT_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///TKEY_COUNT (rw) register accessor: an alias for `Reg<TKEY_COUNT_SPEC>`
    pub type TKEY_COUNT = crate::Reg<tkey_count::TKEY_COUNT_SPEC>;
    ///RW, Touchkey charge and discharge count
    pub mod tkey_count {
        ///Register `TKEY_COUNT` reader
        pub struct R(crate::R<TKEY_COUNT_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<TKEY_COUNT_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<TKEY_COUNT_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<TKEY_COUNT_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `TKEY_COUNT` writer
        pub struct W(crate::W<TKEY_COUNT_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<TKEY_COUNT_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<TKEY_COUNT_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<TKEY_COUNT_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `TKEY_CHARG_CNT` reader - RW, Touchkey charge count
        pub type TKEY_CHARG_CNT_R = crate::FieldReader<u8, u8>;
        ///Field `TKEY_CHARG_CNT` writer - RW, Touchkey charge count
        pub type TKEY_CHARG_CNT_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, TKEY_COUNT_SPEC, u8, u8, 5, O>;
        ///Field `TKEY_DISCH_CNT` reader - RW, Touchkey discharge count
        pub type TKEY_DISCH_CNT_R = crate::FieldReader<u8, u8>;
        ///Field `TKEY_DISCH_CNT` writer - RW, Touchkey discharge count
        pub type TKEY_DISCH_CNT_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, TKEY_COUNT_SPEC, u8, u8, 3, O>;
        impl R {
            ///Bits 0:4 - RW, Touchkey charge count
            #[inline(always)]
            pub fn tkey_charg_cnt(&self) -> TKEY_CHARG_CNT_R {
                TKEY_CHARG_CNT_R::new(self.bits & 0x1f)
            }
            ///Bits 5:7 - RW, Touchkey discharge count
            #[inline(always)]
            pub fn tkey_disch_cnt(&self) -> TKEY_DISCH_CNT_R {
                TKEY_DISCH_CNT_R::new((self.bits >> 5) & 7)
            }
        }
        impl W {
            ///Bits 0:4 - RW, Touchkey charge count
            #[inline(always)]
            #[must_use]
            pub fn tkey_charg_cnt(&mut self) -> TKEY_CHARG_CNT_W<0> {
                TKEY_CHARG_CNT_W::new(self)
            }
            ///Bits 5:7 - RW, Touchkey discharge count
            #[inline(always)]
            #[must_use]
            pub fn tkey_disch_cnt(&mut self) -> TKEY_DISCH_CNT_W<5> {
                TKEY_DISCH_CNT_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, Touchkey charge and discharge count
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [tkey_count](index.html) module
        pub struct TKEY_COUNT_SPEC;
        impl crate::RegisterSpec for TKEY_COUNT_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [tkey_count::R](R) reader structure
        impl crate::Readable for TKEY_COUNT_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [tkey_count::W](W) writer structure
        impl crate::Writable for TKEY_COUNT_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets TKEY_COUNT to value 0
        impl crate::Resettable for TKEY_COUNT_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///TKEY_CONVERT (rw) register accessor: an alias for `Reg<TKEY_CONVERT_SPEC>`
    pub type TKEY_CONVERT = crate::Reg<tkey_convert::TKEY_CONVERT_SPEC>;
    ///RW, Touchkey convert start control
    pub mod tkey_convert {
        ///Register `TKEY_CONVERT` reader
        pub struct R(crate::R<TKEY_CONVERT_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<TKEY_CONVERT_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<TKEY_CONVERT_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<TKEY_CONVERT_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `TKEY_CONVERT` writer
        pub struct W(crate::W<TKEY_CONVERT_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<TKEY_CONVERT_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<TKEY_CONVERT_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<TKEY_CONVERT_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `TKEY_START` reader - RW, Touchkey convert start control
        pub type TKEY_START_R = crate::BitReader<bool>;
        ///Field `TKEY_START` writer - RW, Touchkey convert start control
        pub type TKEY_START_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, TKEY_CONVERT_SPEC, bool, O>;
        impl R {
            ///Bit 0 - RW, Touchkey convert start control
            #[inline(always)]
            pub fn tkey_start(&self) -> TKEY_START_R {
                TKEY_START_R::new((self.bits & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RW, Touchkey convert start control
            #[inline(always)]
            #[must_use]
            pub fn tkey_start(&mut self) -> TKEY_START_W<0> {
                TKEY_START_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, Touchkey convert start control
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [tkey_convert](index.html) module
        pub struct TKEY_CONVERT_SPEC;
        impl crate::RegisterSpec for TKEY_CONVERT_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [tkey_convert::R](R) reader structure
        impl crate::Readable for TKEY_CONVERT_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [tkey_convert::W](W) writer structure
        impl crate::Writable for TKEY_CONVERT_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets TKEY_CONVERT to value 0
        impl crate::Resettable for TKEY_CONVERT_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///TKEY_CFG (rw) register accessor: an alias for `Reg<TKEY_CFG_SPEC>`
    pub type TKEY_CFG = crate::Reg<tkey_cfg::TKEY_CFG_SPEC>;
    ///RW, Touchkey configure
    pub mod tkey_cfg {
        ///Register `TKEY_CFG` reader
        pub struct R(crate::R<TKEY_CFG_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<TKEY_CFG_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<TKEY_CFG_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<TKEY_CFG_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `TKEY_CFG` writer
        pub struct W(crate::W<TKEY_CFG_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<TKEY_CFG_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<TKEY_CFG_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<TKEY_CFG_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `TKEY_PWR_ON` reader - RW, Touchkey power on
        pub type TKEY_PWR_ON_R = crate::BitReader<bool>;
        ///Field `TKEY_PWR_ON` writer - RW, Touchkey power on
        pub type TKEY_PWR_ON_W<'a, const O: u8> = crate::BitWriter<'a, u8, TKEY_CFG_SPEC, bool, O>;
        ///Field `TKEY_CURRENT` reader - RW, Touchkey charge current selection
        pub type TKEY_CURRENT_R = crate::BitReader<bool>;
        ///Field `TKEY_CURRENT` writer - RW, Touchkey charge current selection
        pub type TKEY_CURRENT_W<'a, const O: u8> = crate::BitWriter<'a, u8, TKEY_CFG_SPEC, bool, O>;
        ///Field `TKEY_DRV_EN` reader - RW, Touchkey drive shield enable
        pub type TKEY_DRV_EN_R = crate::BitReader<bool>;
        ///Field `TKEY_DRV_EN` writer - RW, Touchkey drive shield enable
        pub type TKEY_DRV_EN_W<'a, const O: u8> = crate::BitWriter<'a, u8, TKEY_CFG_SPEC, bool, O>;
        ///Field `TKEY_PGA_ADJ` reader - RW, ADC input PGA speed selection
        pub type TKEY_PGA_ADJ_R = crate::BitReader<bool>;
        ///Field `TKEY_PGA_ADJ` writer - RW, ADC input PGA speed selection
        pub type TKEY_PGA_ADJ_W<'a, const O: u8> = crate::BitWriter<'a, u8, TKEY_CFG_SPEC, bool, O>;
        impl R {
            ///Bit 0 - RW, Touchkey power on
            #[inline(always)]
            pub fn tkey_pwr_on(&self) -> TKEY_PWR_ON_R {
                TKEY_PWR_ON_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RW, Touchkey charge current selection
            #[inline(always)]
            pub fn tkey_current(&self) -> TKEY_CURRENT_R {
                TKEY_CURRENT_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RW, Touchkey drive shield enable
            #[inline(always)]
            pub fn tkey_drv_en(&self) -> TKEY_DRV_EN_R {
                TKEY_DRV_EN_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RW, ADC input PGA speed selection
            #[inline(always)]
            pub fn tkey_pga_adj(&self) -> TKEY_PGA_ADJ_R {
                TKEY_PGA_ADJ_R::new(((self.bits >> 3) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RW, Touchkey power on
            #[inline(always)]
            #[must_use]
            pub fn tkey_pwr_on(&mut self) -> TKEY_PWR_ON_W<0> {
                TKEY_PWR_ON_W::new(self)
            }
            ///Bit 1 - RW, Touchkey charge current selection
            #[inline(always)]
            #[must_use]
            pub fn tkey_current(&mut self) -> TKEY_CURRENT_W<1> {
                TKEY_CURRENT_W::new(self)
            }
            ///Bit 2 - RW, Touchkey drive shield enable
            #[inline(always)]
            #[must_use]
            pub fn tkey_drv_en(&mut self) -> TKEY_DRV_EN_W<2> {
                TKEY_DRV_EN_W::new(self)
            }
            ///Bit 3 - RW, ADC input PGA speed selection
            #[inline(always)]
            #[must_use]
            pub fn tkey_pga_adj(&mut self) -> TKEY_PGA_ADJ_W<3> {
                TKEY_PGA_ADJ_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, Touchkey configure
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [tkey_cfg](index.html) module
        pub struct TKEY_CFG_SPEC;
        impl crate::RegisterSpec for TKEY_CFG_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [tkey_cfg::R](R) reader structure
        impl crate::Readable for TKEY_CFG_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [tkey_cfg::W](W) writer structure
        impl crate::Writable for TKEY_CFG_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets TKEY_CFG to value 0
        impl crate::Resettable for TKEY_CFG_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///ADC_CHANNEL (rw) register accessor: an alias for `Reg<ADC_CHANNEL_SPEC>`
    pub type ADC_CHANNEL = crate::Reg<adc_channel::ADC_CHANNEL_SPEC>;
    ///RW, ADC input channel selection
    pub mod adc_channel {
        ///Register `ADC_CHANNEL` reader
        pub struct R(crate::R<ADC_CHANNEL_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<ADC_CHANNEL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<ADC_CHANNEL_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<ADC_CHANNEL_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `ADC_CHANNEL` writer
        pub struct W(crate::W<ADC_CHANNEL_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<ADC_CHANNEL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<ADC_CHANNEL_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<ADC_CHANNEL_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `ADC_CH_INX` reader - RW, ADC input channel index
        pub type ADC_CH_INX_R = crate::FieldReader<u8, u8>;
        ///Field `ADC_CH_INX` writer - RW, ADC input channel index
        pub type ADC_CH_INX_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, ADC_CHANNEL_SPEC, u8, u8, 4, O>;
        impl R {
            ///Bits 0:3 - RW, ADC input channel index
            #[inline(always)]
            pub fn adc_ch_inx(&self) -> ADC_CH_INX_R {
                ADC_CH_INX_R::new(self.bits & 0x0f)
            }
        }
        impl W {
            ///Bits 0:3 - RW, ADC input channel index
            #[inline(always)]
            #[must_use]
            pub fn adc_ch_inx(&mut self) -> ADC_CH_INX_W<0> {
                ADC_CH_INX_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, ADC input channel selection
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [adc_channel](index.html) module
        pub struct ADC_CHANNEL_SPEC;
        impl crate::RegisterSpec for ADC_CHANNEL_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [adc_channel::R](R) reader structure
        impl crate::Readable for ADC_CHANNEL_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [adc_channel::W](W) writer structure
        impl crate::Writable for ADC_CHANNEL_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets ADC_CHANNEL to value 0x0f
        impl crate::Resettable for ADC_CHANNEL_SPEC {
            const RESET_VALUE: Self::Ux = 0x0f;
        }
    }
    ///ADC_CFG (rw) register accessor: an alias for `Reg<ADC_CFG_SPEC>`
    pub type ADC_CFG = crate::Reg<adc_cfg::ADC_CFG_SPEC>;
    ///RW, ADC configure
    pub mod adc_cfg {
        ///Register `ADC_CFG` reader
        pub struct R(crate::R<ADC_CFG_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<ADC_CFG_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<ADC_CFG_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<ADC_CFG_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `ADC_CFG` writer
        pub struct W(crate::W<ADC_CFG_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<ADC_CFG_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<ADC_CFG_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<ADC_CFG_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `ADC_POWER_ON` reader - RW, ADC power control: 0=power down, 1=power on
        pub type ADC_POWER_ON_R = crate::BitReader<bool>;
        ///Field `ADC_POWER_ON` writer - RW, ADC power control: 0=power down, 1=power on
        pub type ADC_POWER_ON_W<'a, const O: u8> = crate::BitWriter<'a, u8, ADC_CFG_SPEC, bool, O>;
        ///Field `ADC_BUF_EN` reader - RW, ADC input buffer enable
        pub type ADC_BUF_EN_R = crate::BitReader<bool>;
        ///Field `ADC_BUF_EN` writer - RW, ADC input buffer enable
        pub type ADC_BUF_EN_W<'a, const O: u8> = crate::BitWriter<'a, u8, ADC_CFG_SPEC, bool, O>;
        ///Field `ADC_DIFF_EN` reader - RW, ADC input channel mode: 0=single-end, 1=differnetial
        pub type ADC_DIFF_EN_R = crate::BitReader<bool>;
        ///Field `ADC_DIFF_EN` writer - RW, ADC input channel mode: 0=single-end, 1=differnetial
        pub type ADC_DIFF_EN_W<'a, const O: u8> = crate::BitWriter<'a, u8, ADC_CFG_SPEC, bool, O>;
        ///Field `ADC_OFS_TEST` reader - RW, enable ADC offset test mode: 0=normal mode, 1=short to test offset
        pub type ADC_OFS_TEST_R = crate::BitReader<bool>;
        ///Field `ADC_OFS_TEST` writer - RW, enable ADC offset test mode: 0=normal mode, 1=short to test offset
        pub type ADC_OFS_TEST_W<'a, const O: u8> = crate::BitWriter<'a, u8, ADC_CFG_SPEC, bool, O>;
        ///Field `ADC_PGA_GAIN` reader - RW, set ADC input PGA gain: 00=-12dB, 01=-6dB, 10=0dB, 11=6dB
        pub type ADC_PGA_GAIN_R = crate::FieldReader<u8, u8>;
        ///Field `ADC_PGA_GAIN` writer - RW, set ADC input PGA gain: 00=-12dB, 01=-6dB, 10=0dB, 11=6dB
        pub type ADC_PGA_GAIN_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, ADC_CFG_SPEC, u8, u8, 2, O>;
        ///Field `ADC_CLK_DIV` reader - RW, select ADC clock frequency: 00=3.2MHz, 01=2.67MHz, 10=5.33MHz, 11=4MHz
        pub type ADC_CLK_DIV_R = crate::FieldReader<u8, u8>;
        ///Field `ADC_CLK_DIV` writer - RW, select ADC clock frequency: 00=3.2MHz, 01=2.67MHz, 10=5.33MHz, 11=4MHz
        pub type ADC_CLK_DIV_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, ADC_CFG_SPEC, u8, u8, 2, O>;
        impl R {
            ///Bit 0 - RW, ADC power control: 0=power down, 1=power on
            #[inline(always)]
            pub fn adc_power_on(&self) -> ADC_POWER_ON_R {
                ADC_POWER_ON_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RW, ADC input buffer enable
            #[inline(always)]
            pub fn adc_buf_en(&self) -> ADC_BUF_EN_R {
                ADC_BUF_EN_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RW, ADC input channel mode: 0=single-end, 1=differnetial
            #[inline(always)]
            pub fn adc_diff_en(&self) -> ADC_DIFF_EN_R {
                ADC_DIFF_EN_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RW, enable ADC offset test mode: 0=normal mode, 1=short to test offset
            #[inline(always)]
            pub fn adc_ofs_test(&self) -> ADC_OFS_TEST_R {
                ADC_OFS_TEST_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bits 4:5 - RW, set ADC input PGA gain: 00=-12dB, 01=-6dB, 10=0dB, 11=6dB
            #[inline(always)]
            pub fn adc_pga_gain(&self) -> ADC_PGA_GAIN_R {
                ADC_PGA_GAIN_R::new((self.bits >> 4) & 3)
            }
            ///Bits 6:7 - RW, select ADC clock frequency: 00=3.2MHz, 01=2.67MHz, 10=5.33MHz, 11=4MHz
            #[inline(always)]
            pub fn adc_clk_div(&self) -> ADC_CLK_DIV_R {
                ADC_CLK_DIV_R::new((self.bits >> 6) & 3)
            }
        }
        impl W {
            ///Bit 0 - RW, ADC power control: 0=power down, 1=power on
            #[inline(always)]
            #[must_use]
            pub fn adc_power_on(&mut self) -> ADC_POWER_ON_W<0> {
                ADC_POWER_ON_W::new(self)
            }
            ///Bit 1 - RW, ADC input buffer enable
            #[inline(always)]
            #[must_use]
            pub fn adc_buf_en(&mut self) -> ADC_BUF_EN_W<1> {
                ADC_BUF_EN_W::new(self)
            }
            ///Bit 2 - RW, ADC input channel mode: 0=single-end, 1=differnetial
            #[inline(always)]
            #[must_use]
            pub fn adc_diff_en(&mut self) -> ADC_DIFF_EN_W<2> {
                ADC_DIFF_EN_W::new(self)
            }
            ///Bit 3 - RW, enable ADC offset test mode: 0=normal mode, 1=short to test offset
            #[inline(always)]
            #[must_use]
            pub fn adc_ofs_test(&mut self) -> ADC_OFS_TEST_W<3> {
                ADC_OFS_TEST_W::new(self)
            }
            ///Bits 4:5 - RW, set ADC input PGA gain: 00=-12dB, 01=-6dB, 10=0dB, 11=6dB
            #[inline(always)]
            #[must_use]
            pub fn adc_pga_gain(&mut self) -> ADC_PGA_GAIN_W<4> {
                ADC_PGA_GAIN_W::new(self)
            }
            ///Bits 6:7 - RW, select ADC clock frequency: 00=3.2MHz, 01=2.67MHz, 10=5.33MHz, 11=4MHz
            #[inline(always)]
            #[must_use]
            pub fn adc_clk_div(&mut self) -> ADC_CLK_DIV_W<6> {
                ADC_CLK_DIV_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, ADC configure
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [adc_cfg](index.html) module
        pub struct ADC_CFG_SPEC;
        impl crate::RegisterSpec for ADC_CFG_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [adc_cfg::R](R) reader structure
        impl crate::Readable for ADC_CFG_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [adc_cfg::W](W) writer structure
        impl crate::Writable for ADC_CFG_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets ADC_CFG to value 0xa0
        impl crate::Resettable for ADC_CFG_SPEC {
            const RESET_VALUE: Self::Ux = 0xa0;
        }
    }
    ///ADC_CONVERT (rw) register accessor: an alias for `Reg<ADC_CONVERT_SPEC>`
    pub type ADC_CONVERT = crate::Reg<adc_convert::ADC_CONVERT_SPEC>;
    ///RW, ADC convert control
    pub mod adc_convert {
        ///Register `ADC_CONVERT` reader
        pub struct R(crate::R<ADC_CONVERT_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<ADC_CONVERT_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<ADC_CONVERT_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<ADC_CONVERT_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `ADC_CONVERT` writer
        pub struct W(crate::W<ADC_CONVERT_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<ADC_CONVERT_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<ADC_CONVERT_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<ADC_CONVERT_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `ADC_START` reader - RW, ADC convert start control: 0=stop ADC convert, 1=start an ADC convert, auto clear
        pub type ADC_START_R = crate::BitReader<bool>;
        ///Field `ADC_START` writer - RW, ADC convert start control: 0=stop ADC convert, 1=start an ADC convert, auto clear
        pub type ADC_START_W<'a, const O: u8> = crate::BitWriter<'a, u8, ADC_CONVERT_SPEC, bool, O>;
        ///Field `ADC_EOC_X` reader - RO, end of ADC conversion flag
        pub type ADC_EOC_X_R = crate::BitReader<bool>;
        impl R {
            ///Bit 0 - RW, ADC convert start control: 0=stop ADC convert, 1=start an ADC convert, auto clear
            #[inline(always)]
            pub fn adc_start(&self) -> ADC_START_R {
                ADC_START_R::new((self.bits & 1) != 0)
            }
            ///Bit 7 - RO, end of ADC conversion flag
            #[inline(always)]
            pub fn adc_eoc_x(&self) -> ADC_EOC_X_R {
                ADC_EOC_X_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RW, ADC convert start control: 0=stop ADC convert, 1=start an ADC convert, auto clear
            #[inline(always)]
            #[must_use]
            pub fn adc_start(&mut self) -> ADC_START_W<0> {
                ADC_START_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, ADC convert control
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [adc_convert](index.html) module
        pub struct ADC_CONVERT_SPEC;
        impl crate::RegisterSpec for ADC_CONVERT_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [adc_convert::R](R) reader structure
        impl crate::Readable for ADC_CONVERT_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [adc_convert::W](W) writer structure
        impl crate::Writable for ADC_CONVERT_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets ADC_CONVERT to value 0
        impl crate::Resettable for ADC_CONVERT_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///TEM_SENSOR (rw) register accessor: an alias for `Reg<TEM_SENSOR_SPEC>`
    pub type TEM_SENSOR = crate::Reg<tem_sensor::TEM_SENSOR_SPEC>;
    ///RW, temperature sensor control
    pub mod tem_sensor {
        ///Register `TEM_SENSOR` reader
        pub struct R(crate::R<TEM_SENSOR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<TEM_SENSOR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<TEM_SENSOR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<TEM_SENSOR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `TEM_SENSOR` writer
        pub struct W(crate::W<TEM_SENSOR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<TEM_SENSOR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<TEM_SENSOR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<TEM_SENSOR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `TEM_SEN_PWR_ON` reader - RW, temperature sensor power control: 0=power down, 1=power on
        pub type TEM_SEN_PWR_ON_R = crate::BitReader<bool>;
        ///Field `TEM_SEN_PWR_ON` writer - RW, temperature sensor power control: 0=power down, 1=power on
        pub type TEM_SEN_PWR_ON_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, TEM_SENSOR_SPEC, bool, O>;
        impl R {
            ///Bit 7 - RW, temperature sensor power control: 0=power down, 1=power on
            #[inline(always)]
            pub fn tem_sen_pwr_on(&self) -> TEM_SEN_PWR_ON_R {
                TEM_SEN_PWR_ON_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 7 - RW, temperature sensor power control: 0=power down, 1=power on
            #[inline(always)]
            #[must_use]
            pub fn tem_sen_pwr_on(&mut self) -> TEM_SEN_PWR_ON_W<7> {
                TEM_SEN_PWR_ON_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, temperature sensor control
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [tem_sensor](index.html) module
        pub struct TEM_SENSOR_SPEC;
        impl crate::RegisterSpec for TEM_SENSOR_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [tem_sensor::R](R) reader structure
        impl crate::Readable for TEM_SENSOR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [tem_sensor::W](W) writer structure
        impl crate::Writable for TEM_SENSOR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets TEM_SENSOR to value 0
        impl crate::Resettable for TEM_SENSOR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///ADC_DATA (r) register accessor: an alias for `Reg<ADC_DATA_SPEC>`
    pub type ADC_DATA = crate::Reg<adc_data::ADC_DATA_SPEC>;
    ///RO, ADC data
    pub mod adc_data {
        ///Register `ADC_DATA` reader
        pub struct R(crate::R<ADC_DATA_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<ADC_DATA_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<ADC_DATA_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<ADC_DATA_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `ADC_DATA` reader - RO, ADC conversion data
        pub type ADC_DATA_R = crate::FieldReader<u16, u16>;
        impl R {
            ///Bits 0:11 - RO, ADC conversion data
            #[inline(always)]
            pub fn adc_data(&self) -> ADC_DATA_R {
                ADC_DATA_R::new(self.bits & 0x0fff)
            }
        }
        ///RO, ADC data
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [adc_data](index.html) module
        pub struct ADC_DATA_SPEC;
        impl crate::RegisterSpec for ADC_DATA_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [adc_data::R](R) reader structure
        impl crate::Readable for ADC_DATA_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets ADC_DATA to value 0
        impl crate::Resettable for ADC_DATA_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///ADC_INT_FLAG (r) register accessor: an alias for `Reg<ADC_INT_FLAG_SPEC>`
    pub type ADC_INT_FLAG = crate::Reg<adc_int_flag::ADC_INT_FLAG_SPEC>;
    ///RO, ADC interrupt flag register
    pub mod adc_int_flag {
        ///Register `ADC_INT_FLAG` reader
        pub struct R(crate::R<ADC_INT_FLAG_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<ADC_INT_FLAG_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<ADC_INT_FLAG_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<ADC_INT_FLAG_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `ADC_IF_EOC` reader - RO, ADC conversion interrupt flag: 0=free or converting, 1=end of conversion, interrupt action, write R8_ADC_CONVERT to clear flag
        pub type ADC_IF_EOC_R = crate::BitReader<bool>;
        impl R {
            ///Bit 7 - RO, ADC conversion interrupt flag: 0=free or converting, 1=end of conversion, interrupt action, write R8_ADC_CONVERT to clear flag
            #[inline(always)]
            pub fn adc_if_eoc(&self) -> ADC_IF_EOC_R {
                ADC_IF_EOC_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        ///RO, ADC interrupt flag register
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [adc_int_flag](index.html) module
        pub struct ADC_INT_FLAG_SPEC;
        impl crate::RegisterSpec for ADC_INT_FLAG_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [adc_int_flag::R](R) reader structure
        impl crate::Readable for ADC_INT_FLAG_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets ADC_INT_FLAG to value 0
        impl crate::Resettable for ADC_INT_FLAG_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///ADC_DMA_CTRL (rw) register accessor: an alias for `Reg<ADC_DMA_CTRL_SPEC>`
    pub type ADC_DMA_CTRL = crate::Reg<adc_dma_ctrl::ADC_DMA_CTRL_SPEC>;
    ///RO, ADC DMA control and status register
    pub mod adc_dma_ctrl {
        ///Register `ADC_DMA_CTRL` reader
        pub struct R(crate::R<ADC_DMA_CTRL_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<ADC_DMA_CTRL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<ADC_DMA_CTRL_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<ADC_DMA_CTRL_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `ADC_DMA_CTRL` writer
        pub struct W(crate::W<ADC_DMA_CTRL_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<ADC_DMA_CTRL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<ADC_DMA_CTRL_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<ADC_DMA_CTRL_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `ADC_DMA_CTRL` reader - RW, ADC DMA enable
        pub type ADC_DMA_CTRL_R = crate::FieldReader<u8, u8>;
        ///Field `ADC_DMA_CTRL` writer - RW, ADC DMA enable
        pub type ADC_DMA_CTRL_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, ADC_DMA_CTRL_SPEC, u8, u8, 8, O>;
        impl R {
            ///Bits 0:7 - RW, ADC DMA enable
            #[inline(always)]
            pub fn adc_dma_ctrl(&self) -> ADC_DMA_CTRL_R {
                ADC_DMA_CTRL_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:7 - RW, ADC DMA enable
            #[inline(always)]
            #[must_use]
            pub fn adc_dma_ctrl(&mut self) -> ADC_DMA_CTRL_W<0> {
                ADC_DMA_CTRL_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RO, ADC DMA control and status register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [adc_dma_ctrl](index.html) module
        pub struct ADC_DMA_CTRL_SPEC;
        impl crate::RegisterSpec for ADC_DMA_CTRL_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [adc_dma_ctrl::R](R) reader structure
        impl crate::Readable for ADC_DMA_CTRL_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [adc_dma_ctrl::W](W) writer structure
        impl crate::Writable for ADC_DMA_CTRL_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets ADC_DMA_CTRL to value 0
        impl crate::Resettable for ADC_DMA_CTRL_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///ADC_CTRL_DMA (rw) register accessor: an alias for `Reg<ADC_CTRL_DMA_SPEC>`
    pub type ADC_CTRL_DMA = crate::Reg<adc_ctrl_dma::ADC_CTRL_DMA_SPEC>;
    ///RW, ADC DMA control
    pub mod adc_ctrl_dma {
        ///Register `ADC_CTRL_DMA` reader
        pub struct R(crate::R<ADC_CTRL_DMA_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<ADC_CTRL_DMA_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<ADC_CTRL_DMA_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<ADC_CTRL_DMA_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `ADC_CTRL_DMA` writer
        pub struct W(crate::W<ADC_CTRL_DMA_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<ADC_CTRL_DMA_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<ADC_CTRL_DMA_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<ADC_CTRL_DMA_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `ADC_DMA_ENABLE` reader - RW, ADC DMA enable
        pub type ADC_DMA_ENABLE_R = crate::BitReader<bool>;
        ///Field `ADC_DMA_ENABLE` writer - RW, ADC DMA enable
        pub type ADC_DMA_ENABLE_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, ADC_CTRL_DMA_SPEC, bool, O>;
        ///Field `ADC_DMA_LOOP` reader - RW, ADC DMA address loop enable
        pub type ADC_DMA_LOOP_R = crate::BitReader<bool>;
        ///Field `ADC_DMA_LOOP` writer - RW, ADC DMA address loop enable
        pub type ADC_DMA_LOOP_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, ADC_CTRL_DMA_SPEC, bool, O>;
        ///Field `ADC_IE_DMA_END` reader - RW, enable interrupt for ADC DMA completion
        pub type ADC_IE_DMA_END_R = crate::BitReader<bool>;
        ///Field `ADC_IE_DMA_END` writer - RW, enable interrupt for ADC DMA completion
        pub type ADC_IE_DMA_END_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, ADC_CTRL_DMA_SPEC, bool, O>;
        ///Field `ADC_IE_EOC` reader - RW, enable interrupt for end of ADC conversion
        pub type ADC_IE_EOC_R = crate::BitReader<bool>;
        ///Field `ADC_IE_EOC` writer - RW, enable interrupt for end of ADC conversion
        pub type ADC_IE_EOC_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, ADC_CTRL_DMA_SPEC, bool, O>;
        ///Field `ADC_CONT_EN` reader - RW, enable contineous conversion ADC
        pub type ADC_CONT_EN_R = crate::BitReader<bool>;
        ///Field `ADC_CONT_EN` writer - RW, enable contineous conversion ADC
        pub type ADC_CONT_EN_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, ADC_CTRL_DMA_SPEC, bool, O>;
        ///Field `ADC_AUTO_EN` reader - RW, enable auto continuing ADC for DMA
        pub type ADC_AUTO_EN_R = crate::BitReader<bool>;
        ///Field `ADC_AUTO_EN` writer - RW, enable auto continuing ADC for DMA
        pub type ADC_AUTO_EN_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, ADC_CTRL_DMA_SPEC, bool, O>;
        impl R {
            ///Bit 0 - RW, ADC DMA enable
            #[inline(always)]
            pub fn adc_dma_enable(&self) -> ADC_DMA_ENABLE_R {
                ADC_DMA_ENABLE_R::new((self.bits & 1) != 0)
            }
            ///Bit 2 - RW, ADC DMA address loop enable
            #[inline(always)]
            pub fn adc_dma_loop(&self) -> ADC_DMA_LOOP_R {
                ADC_DMA_LOOP_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RW, enable interrupt for ADC DMA completion
            #[inline(always)]
            pub fn adc_ie_dma_end(&self) -> ADC_IE_DMA_END_R {
                ADC_IE_DMA_END_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RW, enable interrupt for end of ADC conversion
            #[inline(always)]
            pub fn adc_ie_eoc(&self) -> ADC_IE_EOC_R {
                ADC_IE_EOC_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 6 - RW, enable contineous conversion ADC
            #[inline(always)]
            pub fn adc_cont_en(&self) -> ADC_CONT_EN_R {
                ADC_CONT_EN_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - RW, enable auto continuing ADC for DMA
            #[inline(always)]
            pub fn adc_auto_en(&self) -> ADC_AUTO_EN_R {
                ADC_AUTO_EN_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RW, ADC DMA enable
            #[inline(always)]
            #[must_use]
            pub fn adc_dma_enable(&mut self) -> ADC_DMA_ENABLE_W<0> {
                ADC_DMA_ENABLE_W::new(self)
            }
            ///Bit 2 - RW, ADC DMA address loop enable
            #[inline(always)]
            #[must_use]
            pub fn adc_dma_loop(&mut self) -> ADC_DMA_LOOP_W<2> {
                ADC_DMA_LOOP_W::new(self)
            }
            ///Bit 3 - RW, enable interrupt for ADC DMA completion
            #[inline(always)]
            #[must_use]
            pub fn adc_ie_dma_end(&mut self) -> ADC_IE_DMA_END_W<3> {
                ADC_IE_DMA_END_W::new(self)
            }
            ///Bit 4 - RW, enable interrupt for end of ADC conversion
            #[inline(always)]
            #[must_use]
            pub fn adc_ie_eoc(&mut self) -> ADC_IE_EOC_W<4> {
                ADC_IE_EOC_W::new(self)
            }
            ///Bit 6 - RW, enable contineous conversion ADC
            #[inline(always)]
            #[must_use]
            pub fn adc_cont_en(&mut self) -> ADC_CONT_EN_W<6> {
                ADC_CONT_EN_W::new(self)
            }
            ///Bit 7 - RW, enable auto continuing ADC for DMA
            #[inline(always)]
            #[must_use]
            pub fn adc_auto_en(&mut self) -> ADC_AUTO_EN_W<7> {
                ADC_AUTO_EN_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, ADC DMA control
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [adc_ctrl_dma](index.html) module
        pub struct ADC_CTRL_DMA_SPEC;
        impl crate::RegisterSpec for ADC_CTRL_DMA_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [adc_ctrl_dma::R](R) reader structure
        impl crate::Readable for ADC_CTRL_DMA_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [adc_ctrl_dma::W](W) writer structure
        impl crate::Writable for ADC_CTRL_DMA_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets ADC_CTRL_DMA to value 0
        impl crate::Resettable for ADC_CTRL_DMA_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///ADC_DMA_IF (rw) register accessor: an alias for `Reg<ADC_DMA_IF_SPEC>`
    pub type ADC_DMA_IF = crate::Reg<adc_dma_if::ADC_DMA_IF_SPEC>;
    ///RO, ADC interrupt flag
    pub mod adc_dma_if {
        ///Register `ADC_DMA_IF` reader
        pub struct R(crate::R<ADC_DMA_IF_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<ADC_DMA_IF_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<ADC_DMA_IF_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<ADC_DMA_IF_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `ADC_DMA_IF` writer
        pub struct W(crate::W<ADC_DMA_IF_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<ADC_DMA_IF_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<ADC_DMA_IF_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<ADC_DMA_IF_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `ADC_IF_DMA_END` reader - interrupt flag for ADC DMA completion
        pub type ADC_IF_DMA_END_R = crate::BitReader<bool>;
        ///Field `ADC_IF_DMA_END` writer - interrupt flag for ADC DMA completion
        pub type ADC_IF_DMA_END_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, ADC_DMA_IF_SPEC, bool, O>;
        ///Field `ADC_IF_END_ADC` reader - interrupt flag for end of ADC conversion
        pub type ADC_IF_END_ADC_R = crate::BitReader<bool>;
        ///Field `ADC_IF_END_ADC` writer - interrupt flag for end of ADC conversion
        pub type ADC_IF_END_ADC_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, ADC_DMA_IF_SPEC, bool, O>;
        impl R {
            ///Bit 3 - interrupt flag for ADC DMA completion
            #[inline(always)]
            pub fn adc_if_dma_end(&self) -> ADC_IF_DMA_END_R {
                ADC_IF_DMA_END_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - interrupt flag for end of ADC conversion
            #[inline(always)]
            pub fn adc_if_end_adc(&self) -> ADC_IF_END_ADC_R {
                ADC_IF_END_ADC_R::new(((self.bits >> 4) & 1) != 0)
            }
        }
        impl W {
            ///Bit 3 - interrupt flag for ADC DMA completion
            #[inline(always)]
            #[must_use]
            pub fn adc_if_dma_end(&mut self) -> ADC_IF_DMA_END_W<3> {
                ADC_IF_DMA_END_W::new(self)
            }
            ///Bit 4 - interrupt flag for end of ADC conversion
            #[inline(always)]
            #[must_use]
            pub fn adc_if_end_adc(&mut self) -> ADC_IF_END_ADC_W<4> {
                ADC_IF_END_ADC_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RO, ADC interrupt flag
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [adc_dma_if](index.html) module
        pub struct ADC_DMA_IF_SPEC;
        impl crate::RegisterSpec for ADC_DMA_IF_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [adc_dma_if::R](R) reader structure
        impl crate::Readable for ADC_DMA_IF_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [adc_dma_if::W](W) writer structure
        impl crate::Writable for ADC_DMA_IF_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets ADC_DMA_IF to value 0
        impl crate::Resettable for ADC_DMA_IF_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///ADC_AUTO_CYCLE (rw) register accessor: an alias for `Reg<ADC_AUTO_CYCLE_SPEC>`
    pub type ADC_AUTO_CYCLE = crate::Reg<adc_auto_cycle::ADC_AUTO_CYCLE_SPEC>;
    ///RO, ADC interrupt flag
    pub mod adc_auto_cycle {
        ///Register `ADC_AUTO_CYCLE` reader
        pub struct R(crate::R<ADC_AUTO_CYCLE_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<ADC_AUTO_CYCLE_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<ADC_AUTO_CYCLE_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<ADC_AUTO_CYCLE_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `ADC_AUTO_CYCLE` writer
        pub struct W(crate::W<ADC_AUTO_CYCLE_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<ADC_AUTO_CYCLE_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<ADC_AUTO_CYCLE_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<ADC_AUTO_CYCLE_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `ADC_AUTO_CYCLE` reader - auto ADC cycle value, unit is 16 Fsys
        pub type ADC_AUTO_CYCLE_R = crate::FieldReader<u8, u8>;
        ///Field `ADC_AUTO_CYCLE` writer - auto ADC cycle value, unit is 16 Fsys
        pub type ADC_AUTO_CYCLE_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, ADC_AUTO_CYCLE_SPEC, u8, u8, 8, O>;
        impl R {
            ///Bits 0:7 - auto ADC cycle value, unit is 16 Fsys
            #[inline(always)]
            pub fn adc_auto_cycle(&self) -> ADC_AUTO_CYCLE_R {
                ADC_AUTO_CYCLE_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:7 - auto ADC cycle value, unit is 16 Fsys
            #[inline(always)]
            #[must_use]
            pub fn adc_auto_cycle(&mut self) -> ADC_AUTO_CYCLE_W<0> {
                ADC_AUTO_CYCLE_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RO, ADC interrupt flag
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [adc_auto_cycle](index.html) module
        pub struct ADC_AUTO_CYCLE_SPEC;
        impl crate::RegisterSpec for ADC_AUTO_CYCLE_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [adc_auto_cycle::R](R) reader structure
        impl crate::Readable for ADC_AUTO_CYCLE_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [adc_auto_cycle::W](W) writer structure
        impl crate::Writable for ADC_AUTO_CYCLE_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets ADC_AUTO_CYCLE to value 0
        impl crate::Resettable for ADC_AUTO_CYCLE_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///ADC_DMA_NOW (r) register accessor: an alias for `Reg<ADC_DMA_NOW_SPEC>`
    pub type ADC_DMA_NOW = crate::Reg<adc_dma_now::ADC_DMA_NOW_SPEC>;
    ///RO, ADC DMA current address
    pub mod adc_dma_now {
        ///Register `ADC_DMA_NOW` reader
        pub struct R(crate::R<ADC_DMA_NOW_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<ADC_DMA_NOW_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<ADC_DMA_NOW_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<ADC_DMA_NOW_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `ADC_DMA_NOW` reader - ADC DMA current address
        pub type ADC_DMA_NOW_R = crate::FieldReader<u16, u16>;
        impl R {
            ///Bits 0:15 - ADC DMA current address
            #[inline(always)]
            pub fn adc_dma_now(&self) -> ADC_DMA_NOW_R {
                ADC_DMA_NOW_R::new(self.bits)
            }
        }
        ///RO, ADC DMA current address
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [adc_dma_now](index.html) module
        pub struct ADC_DMA_NOW_SPEC;
        impl crate::RegisterSpec for ADC_DMA_NOW_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [adc_dma_now::R](R) reader structure
        impl crate::Readable for ADC_DMA_NOW_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets ADC_DMA_NOW to value 0
        impl crate::Resettable for ADC_DMA_NOW_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///ADC_DMA_BEG (rw) register accessor: an alias for `Reg<ADC_DMA_BEG_SPEC>`
    pub type ADC_DMA_BEG = crate::Reg<adc_dma_beg::ADC_DMA_BEG_SPEC>;
    ///RW, ADC DMA begin address
    pub mod adc_dma_beg {
        ///Register `ADC_DMA_BEG` reader
        pub struct R(crate::R<ADC_DMA_BEG_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<ADC_DMA_BEG_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<ADC_DMA_BEG_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<ADC_DMA_BEG_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `ADC_DMA_BEG` writer
        pub struct W(crate::W<ADC_DMA_BEG_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<ADC_DMA_BEG_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<ADC_DMA_BEG_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<ADC_DMA_BEG_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `ADC_DMA_BEG` reader - ADC DMA begin address
        pub type ADC_DMA_BEG_R = crate::FieldReader<u16, u16>;
        ///Field `ADC_DMA_BEG` writer - ADC DMA begin address
        pub type ADC_DMA_BEG_W<'a, const O: u8> =
            crate::FieldWriter<'a, u16, ADC_DMA_BEG_SPEC, u16, u16, 16, O>;
        impl R {
            ///Bits 0:15 - ADC DMA begin address
            #[inline(always)]
            pub fn adc_dma_beg(&self) -> ADC_DMA_BEG_R {
                ADC_DMA_BEG_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - ADC DMA begin address
            #[inline(always)]
            #[must_use]
            pub fn adc_dma_beg(&mut self) -> ADC_DMA_BEG_W<0> {
                ADC_DMA_BEG_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, ADC DMA begin address
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [adc_dma_beg](index.html) module
        pub struct ADC_DMA_BEG_SPEC;
        impl crate::RegisterSpec for ADC_DMA_BEG_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [adc_dma_beg::R](R) reader structure
        impl crate::Readable for ADC_DMA_BEG_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [adc_dma_beg::W](W) writer structure
        impl crate::Writable for ADC_DMA_BEG_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets ADC_DMA_BEG to value 0
        impl crate::Resettable for ADC_DMA_BEG_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///ADC_DMA_END (rw) register accessor: an alias for `Reg<ADC_DMA_END_SPEC>`
    pub type ADC_DMA_END = crate::Reg<adc_dma_end::ADC_DMA_END_SPEC>;
    ///RW, ADC DMA end address
    pub mod adc_dma_end {
        ///Register `ADC_DMA_END` reader
        pub struct R(crate::R<ADC_DMA_END_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<ADC_DMA_END_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<ADC_DMA_END_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<ADC_DMA_END_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `ADC_DMA_END` writer
        pub struct W(crate::W<ADC_DMA_END_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<ADC_DMA_END_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<ADC_DMA_END_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<ADC_DMA_END_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `ADC_DMA_END` reader - ADC DMA end address
        pub type ADC_DMA_END_R = crate::FieldReader<u16, u16>;
        ///Field `ADC_DMA_END` writer - ADC DMA end address
        pub type ADC_DMA_END_W<'a, const O: u8> =
            crate::FieldWriter<'a, u16, ADC_DMA_END_SPEC, u16, u16, 16, O>;
        impl R {
            ///Bits 0:15 - ADC DMA end address
            #[inline(always)]
            pub fn adc_dma_end(&self) -> ADC_DMA_END_R {
                ADC_DMA_END_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - ADC DMA end address
            #[inline(always)]
            #[must_use]
            pub fn adc_dma_end(&mut self) -> ADC_DMA_END_W<0> {
                ADC_DMA_END_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, ADC DMA end address
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [adc_dma_end](index.html) module
        pub struct ADC_DMA_END_SPEC;
        impl crate::RegisterSpec for ADC_DMA_END_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [adc_dma_end::R](R) reader structure
        impl crate::Readable for ADC_DMA_END_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [adc_dma_end::W](W) writer structure
        impl crate::Writable for ADC_DMA_END_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets ADC_DMA_END to value 0
        impl crate::Resettable for ADC_DMA_END_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///PA_INT_EN (rw) register accessor: an alias for `Reg<PA_INT_EN_SPEC>`
    pub type PA_INT_EN = crate::Reg<pa_int_en::PA_INT_EN_SPEC>;
    ///RW, GPIO PA interrupt enable
    pub mod pa_int_en {
        ///Register `PA_INT_EN` reader
        pub struct R(crate::R<PA_INT_EN_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PA_INT_EN_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<PA_INT_EN_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<PA_INT_EN_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `PA_INT_EN` writer
        pub struct W(crate::W<PA_INT_EN_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PA_INT_EN_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<PA_INT_EN_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<PA_INT_EN_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `PA_INT_EN` reader - GPIO PA interrupt enable
        pub type PA_INT_EN_R = crate::FieldReader<u16, u16>;
        ///Field `PA_INT_EN` writer - GPIO PA interrupt enable
        pub type PA_INT_EN_W<'a, const O: u8> =
            crate::FieldWriter<'a, u16, PA_INT_EN_SPEC, u16, u16, 16, O>;
        impl R {
            ///Bits 0:15 - GPIO PA interrupt enable
            #[inline(always)]
            pub fn pa_int_en(&self) -> PA_INT_EN_R {
                PA_INT_EN_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - GPIO PA interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn pa_int_en(&mut self) -> PA_INT_EN_W<0> {
                PA_INT_EN_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, GPIO PA interrupt enable
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [pa_int_en](index.html) module
        pub struct PA_INT_EN_SPEC;
        impl crate::RegisterSpec for PA_INT_EN_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [pa_int_en::R](R) reader structure
        impl crate::Readable for PA_INT_EN_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [pa_int_en::W](W) writer structure
        impl crate::Writable for PA_INT_EN_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets PA_INT_EN to value 0
        impl crate::Resettable for PA_INT_EN_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///PB_INT_EN (rw) register accessor: an alias for `Reg<PB_INT_EN_SPEC>`
    pub type PB_INT_EN = crate::Reg<pb_int_en::PB_INT_EN_SPEC>;
    ///RW, GPIO PB interrupt enable
    pub mod pb_int_en {
        ///Register `PB_INT_EN` reader
        pub struct R(crate::R<PB_INT_EN_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PB_INT_EN_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<PB_INT_EN_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<PB_INT_EN_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `PB_INT_EN` writer
        pub struct W(crate::W<PB_INT_EN_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PB_INT_EN_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<PB_INT_EN_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<PB_INT_EN_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `PB_INT_EN` reader - GPIO PB interrupt enable
        pub type PB_INT_EN_R = crate::FieldReader<u16, u16>;
        ///Field `PB_INT_EN` writer - GPIO PB interrupt enable
        pub type PB_INT_EN_W<'a, const O: u8> =
            crate::FieldWriter<'a, u16, PB_INT_EN_SPEC, u16, u16, 16, O>;
        impl R {
            ///Bits 0:15 - GPIO PB interrupt enable
            #[inline(always)]
            pub fn pb_int_en(&self) -> PB_INT_EN_R {
                PB_INT_EN_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - GPIO PB interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn pb_int_en(&mut self) -> PB_INT_EN_W<0> {
                PB_INT_EN_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, GPIO PB interrupt enable
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [pb_int_en](index.html) module
        pub struct PB_INT_EN_SPEC;
        impl crate::RegisterSpec for PB_INT_EN_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [pb_int_en::R](R) reader structure
        impl crate::Readable for PB_INT_EN_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [pb_int_en::W](W) writer structure
        impl crate::Writable for PB_INT_EN_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets PB_INT_EN to value 0
        impl crate::Resettable for PB_INT_EN_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///PA_INT_MODE (rw) register accessor: an alias for `Reg<PA_INT_MODE_SPEC>`
    pub type PA_INT_MODE = crate::Reg<pa_int_mode::PA_INT_MODE_SPEC>;
    ///RW, GPIO PA interrupt mode: 0=level action, 1=edge action
    pub mod pa_int_mode {
        ///Register `PA_INT_MODE` reader
        pub struct R(crate::R<PA_INT_MODE_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PA_INT_MODE_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<PA_INT_MODE_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<PA_INT_MODE_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `PA_INT_MODE` writer
        pub struct W(crate::W<PA_INT_MODE_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PA_INT_MODE_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<PA_INT_MODE_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<PA_INT_MODE_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `PA_INT_MODE` reader - GPIO PA interrupt mode
        pub type PA_INT_MODE_R = crate::FieldReader<u16, u16>;
        ///Field `PA_INT_MODE` writer - GPIO PA interrupt mode
        pub type PA_INT_MODE_W<'a, const O: u8> =
            crate::FieldWriter<'a, u16, PA_INT_MODE_SPEC, u16, u16, 16, O>;
        impl R {
            ///Bits 0:15 - GPIO PA interrupt mode
            #[inline(always)]
            pub fn pa_int_mode(&self) -> PA_INT_MODE_R {
                PA_INT_MODE_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - GPIO PA interrupt mode
            #[inline(always)]
            #[must_use]
            pub fn pa_int_mode(&mut self) -> PA_INT_MODE_W<0> {
                PA_INT_MODE_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, GPIO PA interrupt mode: 0=level action, 1=edge action
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [pa_int_mode](index.html) module
        pub struct PA_INT_MODE_SPEC;
        impl crate::RegisterSpec for PA_INT_MODE_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [pa_int_mode::R](R) reader structure
        impl crate::Readable for PA_INT_MODE_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [pa_int_mode::W](W) writer structure
        impl crate::Writable for PA_INT_MODE_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets PA_INT_MODE to value 0
        impl crate::Resettable for PA_INT_MODE_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///PB_INT_MODE (rw) register accessor: an alias for `Reg<PB_INT_MODE_SPEC>`
    pub type PB_INT_MODE = crate::Reg<pb_int_mode::PB_INT_MODE_SPEC>;
    ///RW, GPIO PB interrupt mode: 0=level action, 1=edge action;RW, status for parallel slave read
    pub mod pb_int_mode {
        ///Register `PB_INT_MODE` reader
        pub struct R(crate::R<PB_INT_MODE_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PB_INT_MODE_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<PB_INT_MODE_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<PB_INT_MODE_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `PB_INT_MODE` writer
        pub struct W(crate::W<PB_INT_MODE_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PB_INT_MODE_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<PB_INT_MODE_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<PB_INT_MODE_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `PB_INT_MODE` reader - GPIO PB interrupt mode
        pub type PB_INT_MODE_R = crate::FieldReader<u16, u16>;
        ///Field `PB_INT_MODE` writer - GPIO PB interrupt mode
        pub type PB_INT_MODE_W<'a, const O: u8> =
            crate::FieldWriter<'a, u16, PB_INT_MODE_SPEC, u16, u16, 16, O>;
        impl R {
            ///Bits 0:15 - GPIO PB interrupt mode
            #[inline(always)]
            pub fn pb_int_mode(&self) -> PB_INT_MODE_R {
                PB_INT_MODE_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - GPIO PB interrupt mode
            #[inline(always)]
            #[must_use]
            pub fn pb_int_mode(&mut self) -> PB_INT_MODE_W<0> {
                PB_INT_MODE_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, GPIO PB interrupt mode: 0=level action, 1=edge action;RW, status for parallel slave read
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [pb_int_mode](index.html) module
        pub struct PB_INT_MODE_SPEC;
        impl crate::RegisterSpec for PB_INT_MODE_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [pb_int_mode::R](R) reader structure
        impl crate::Readable for PB_INT_MODE_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [pb_int_mode::W](W) writer structure
        impl crate::Writable for PB_INT_MODE_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets PB_INT_MODE to value 0
        impl crate::Resettable for PB_INT_MODE_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///PA_INT_IF (rw) register accessor: an alias for `Reg<PA_INT_IF_SPEC>`
    pub type PA_INT_IF = crate::Reg<pa_int_if::PA_INT_IF_SPEC>;
    ///RW1, GPIO PA interrupt flag
    pub mod pa_int_if {
        ///Register `PA_INT_IF` reader
        pub struct R(crate::R<PA_INT_IF_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PA_INT_IF_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<PA_INT_IF_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<PA_INT_IF_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `PA_INT_IF` writer
        pub struct W(crate::W<PA_INT_IF_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PA_INT_IF_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<PA_INT_IF_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<PA_INT_IF_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `PA_INT_IF` reader - GPIO PA interrupt flag
        pub type PA_INT_IF_R = crate::FieldReader<u16, u16>;
        ///Field `PA_INT_IF` writer - GPIO PA interrupt flag
        pub type PA_INT_IF_W<'a, const O: u8> =
            crate::FieldWriter<'a, u16, PA_INT_IF_SPEC, u16, u16, 16, O>;
        impl R {
            ///Bits 0:15 - GPIO PA interrupt flag
            #[inline(always)]
            pub fn pa_int_if(&self) -> PA_INT_IF_R {
                PA_INT_IF_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - GPIO PA interrupt flag
            #[inline(always)]
            #[must_use]
            pub fn pa_int_if(&mut self) -> PA_INT_IF_W<0> {
                PA_INT_IF_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW1, GPIO PA interrupt flag
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [pa_int_if](index.html) module
        pub struct PA_INT_IF_SPEC;
        impl crate::RegisterSpec for PA_INT_IF_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [pa_int_if::R](R) reader structure
        impl crate::Readable for PA_INT_IF_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [pa_int_if::W](W) writer structure
        impl crate::Writable for PA_INT_IF_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets PA_INT_IF to value 0
        impl crate::Resettable for PA_INT_IF_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///PB_INT_IF (rw) register accessor: an alias for `Reg<PB_INT_IF_SPEC>`
    pub type PB_INT_IF = crate::Reg<pb_int_if::PB_INT_IF_SPEC>;
    ///RW1, GPIO PB interrupt flag
    pub mod pb_int_if {
        ///Register `PB_INT_IF` reader
        pub struct R(crate::R<PB_INT_IF_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PB_INT_IF_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<PB_INT_IF_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<PB_INT_IF_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `PB_INT_IF` writer
        pub struct W(crate::W<PB_INT_IF_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PB_INT_IF_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<PB_INT_IF_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<PB_INT_IF_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `PB_INT_IF` reader - GPIO PB interrupt flag
        pub type PB_INT_IF_R = crate::FieldReader<u16, u16>;
        ///Field `PB_INT_IF` writer - GPIO PB interrupt flag
        pub type PB_INT_IF_W<'a, const O: u8> =
            crate::FieldWriter<'a, u16, PB_INT_IF_SPEC, u16, u16, 16, O>;
        impl R {
            ///Bits 0:15 - GPIO PB interrupt flag
            #[inline(always)]
            pub fn pb_int_if(&self) -> PB_INT_IF_R {
                PB_INT_IF_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - GPIO PB interrupt flag
            #[inline(always)]
            #[must_use]
            pub fn pb_int_if(&mut self) -> PB_INT_IF_W<0> {
                PB_INT_IF_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW1, GPIO PB interrupt flag
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [pb_int_if](index.html) module
        pub struct PB_INT_IF_SPEC;
        impl crate::RegisterSpec for PB_INT_IF_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [pb_int_if::R](R) reader structure
        impl crate::Readable for PB_INT_IF_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [pb_int_if::W](W) writer structure
        impl crate::Writable for PB_INT_IF_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets PB_INT_IF to value 0
        impl crate::Resettable for PB_INT_IF_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///PA_DIR (rw) register accessor: an alias for `Reg<PA_DIR_SPEC>`
    pub type PA_DIR = crate::Reg<pa_dir::PA_DIR_SPEC>;
    ///RW, GPIO PA I/O direction: 0=in, 1=out
    pub mod pa_dir {
        ///Register `PA_DIR` reader
        pub struct R(crate::R<PA_DIR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PA_DIR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<PA_DIR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<PA_DIR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `PA_DIR` writer
        pub struct W(crate::W<PA_DIR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PA_DIR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<PA_DIR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<PA_DIR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `PA_DIR_0` reader - GPIO PA I/O direction byte 0
        pub type PA_DIR_0_R = crate::FieldReader<u8, u8>;
        ///Field `PA_DIR_0` writer - GPIO PA I/O direction byte 0
        pub type PA_DIR_0_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, PA_DIR_SPEC, u8, u8, 8, O>;
        ///Field `PA_DIR_1` reader - GPIO PA I/O direction byte 1
        pub type PA_DIR_1_R = crate::FieldReader<u8, u8>;
        ///Field `PA_DIR_1` writer - GPIO PA I/O direction byte 1
        pub type PA_DIR_1_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, PA_DIR_SPEC, u8, u8, 8, O>;
        impl R {
            ///Bits 0:7 - GPIO PA I/O direction byte 0
            #[inline(always)]
            pub fn pa_dir_0(&self) -> PA_DIR_0_R {
                PA_DIR_0_R::new((self.bits & 0xff) as u8)
            }
            ///Bits 8:15 - GPIO PA I/O direction byte 1
            #[inline(always)]
            pub fn pa_dir_1(&self) -> PA_DIR_1_R {
                PA_DIR_1_R::new(((self.bits >> 8) & 0xff) as u8)
            }
        }
        impl W {
            ///Bits 0:7 - GPIO PA I/O direction byte 0
            #[inline(always)]
            #[must_use]
            pub fn pa_dir_0(&mut self) -> PA_DIR_0_W<0> {
                PA_DIR_0_W::new(self)
            }
            ///Bits 8:15 - GPIO PA I/O direction byte 1
            #[inline(always)]
            #[must_use]
            pub fn pa_dir_1(&mut self) -> PA_DIR_1_W<8> {
                PA_DIR_1_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, GPIO PA I/O direction: 0=in, 1=out
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [pa_dir](index.html) module
        pub struct PA_DIR_SPEC;
        impl crate::RegisterSpec for PA_DIR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [pa_dir::R](R) reader structure
        impl crate::Readable for PA_DIR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [pa_dir::W](W) writer structure
        impl crate::Writable for PA_DIR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets PA_DIR to value 0
        impl crate::Resettable for PA_DIR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///PA_PIN (r) register accessor: an alias for `Reg<PA_PIN_SPEC>`
    pub type PA_PIN = crate::Reg<pa_pin::PA_PIN_SPEC>;
    ///RO, GPIO PA input
    pub mod pa_pin {
        ///Register `PA_PIN` reader
        pub struct R(crate::R<PA_PIN_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PA_PIN_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<PA_PIN_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<PA_PIN_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `PA_PIN_0` reader - GPIO PA input byte 0
        pub type PA_PIN_0_R = crate::FieldReader<u8, u8>;
        ///Field `PA_PIN_1` reader - GPIO PA input byte 1
        pub type PA_PIN_1_R = crate::FieldReader<u8, u8>;
        impl R {
            ///Bits 0:7 - GPIO PA input byte 0
            #[inline(always)]
            pub fn pa_pin_0(&self) -> PA_PIN_0_R {
                PA_PIN_0_R::new((self.bits & 0xff) as u8)
            }
            ///Bits 8:15 - GPIO PA input byte 1
            #[inline(always)]
            pub fn pa_pin_1(&self) -> PA_PIN_1_R {
                PA_PIN_1_R::new(((self.bits >> 8) & 0xff) as u8)
            }
        }
        ///RO, GPIO PA input
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [pa_pin](index.html) module
        pub struct PA_PIN_SPEC;
        impl crate::RegisterSpec for PA_PIN_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [pa_pin::R](R) reader structure
        impl crate::Readable for PA_PIN_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets PA_PIN to value 0
        impl crate::Resettable for PA_PIN_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///PA_OUT (rw) register accessor: an alias for `Reg<PA_OUT_SPEC>`
    pub type PA_OUT = crate::Reg<pa_out::PA_OUT_SPEC>;
    ///RW, GPIO PA output
    pub mod pa_out {
        ///Register `PA_OUT` reader
        pub struct R(crate::R<PA_OUT_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PA_OUT_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<PA_OUT_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<PA_OUT_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `PA_OUT` writer
        pub struct W(crate::W<PA_OUT_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PA_OUT_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<PA_OUT_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<PA_OUT_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `PA_OUT_0` reader - GPIO PA output byte 0
        pub type PA_OUT_0_R = crate::FieldReader<u8, u8>;
        ///Field `PA_OUT_0` writer - GPIO PA output byte 0
        pub type PA_OUT_0_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, PA_OUT_SPEC, u8, u8, 8, O>;
        ///Field `PA_OUT_1` reader - GPIO PA output byte 1
        pub type PA_OUT_1_R = crate::FieldReader<u8, u8>;
        ///Field `PA_OUT_1` writer - GPIO PA output byte 1
        pub type PA_OUT_1_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, PA_OUT_SPEC, u8, u8, 8, O>;
        impl R {
            ///Bits 0:7 - GPIO PA output byte 0
            #[inline(always)]
            pub fn pa_out_0(&self) -> PA_OUT_0_R {
                PA_OUT_0_R::new((self.bits & 0xff) as u8)
            }
            ///Bits 8:15 - GPIO PA output byte 1
            #[inline(always)]
            pub fn pa_out_1(&self) -> PA_OUT_1_R {
                PA_OUT_1_R::new(((self.bits >> 8) & 0xff) as u8)
            }
        }
        impl W {
            ///Bits 0:7 - GPIO PA output byte 0
            #[inline(always)]
            #[must_use]
            pub fn pa_out_0(&mut self) -> PA_OUT_0_W<0> {
                PA_OUT_0_W::new(self)
            }
            ///Bits 8:15 - GPIO PA output byte 1
            #[inline(always)]
            #[must_use]
            pub fn pa_out_1(&mut self) -> PA_OUT_1_W<8> {
                PA_OUT_1_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, GPIO PA output
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [pa_out](index.html) module
        pub struct PA_OUT_SPEC;
        impl crate::RegisterSpec for PA_OUT_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [pa_out::R](R) reader structure
        impl crate::Readable for PA_OUT_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [pa_out::W](W) writer structure
        impl crate::Writable for PA_OUT_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets PA_OUT to value 0
        impl crate::Resettable for PA_OUT_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///PA_CLR (rw) register accessor: an alias for `Reg<PA_CLR_SPEC>`
    pub type PA_CLR = crate::Reg<pa_clr::PA_CLR_SPEC>;
    ///WZ, GPIO PA clear output: 0=keep, 1=clear
    pub mod pa_clr {
        ///Register `PA_CLR` reader
        pub struct R(crate::R<PA_CLR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PA_CLR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<PA_CLR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<PA_CLR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `PA_CLR` writer
        pub struct W(crate::W<PA_CLR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PA_CLR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<PA_CLR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<PA_CLR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `PA_CLR_0` reader - GPIO PA clear output byte 0
        pub type PA_CLR_0_R = crate::FieldReader<u8, u8>;
        ///Field `PA_CLR_0` writer - GPIO PA clear output byte 0
        pub type PA_CLR_0_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, PA_CLR_SPEC, u8, u8, 8, O>;
        ///Field `PA_CLR_1` reader - GPIO PA clear output byte 1
        pub type PA_CLR_1_R = crate::FieldReader<u8, u8>;
        ///Field `PA_CLR_1` writer - GPIO PA clear output byte 1
        pub type PA_CLR_1_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, PA_CLR_SPEC, u8, u8, 8, O>;
        impl R {
            ///Bits 0:7 - GPIO PA clear output byte 0
            #[inline(always)]
            pub fn pa_clr_0(&self) -> PA_CLR_0_R {
                PA_CLR_0_R::new((self.bits & 0xff) as u8)
            }
            ///Bits 8:15 - GPIO PA clear output byte 1
            #[inline(always)]
            pub fn pa_clr_1(&self) -> PA_CLR_1_R {
                PA_CLR_1_R::new(((self.bits >> 8) & 0xff) as u8)
            }
        }
        impl W {
            ///Bits 0:7 - GPIO PA clear output byte 0
            #[inline(always)]
            #[must_use]
            pub fn pa_clr_0(&mut self) -> PA_CLR_0_W<0> {
                PA_CLR_0_W::new(self)
            }
            ///Bits 8:15 - GPIO PA clear output byte 1
            #[inline(always)]
            #[must_use]
            pub fn pa_clr_1(&mut self) -> PA_CLR_1_W<8> {
                PA_CLR_1_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///WZ, GPIO PA clear output: 0=keep, 1=clear
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [pa_clr](index.html) module
        pub struct PA_CLR_SPEC;
        impl crate::RegisterSpec for PA_CLR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [pa_clr::R](R) reader structure
        impl crate::Readable for PA_CLR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [pa_clr::W](W) writer structure
        impl crate::Writable for PA_CLR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets PA_CLR to value 0
        impl crate::Resettable for PA_CLR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///PA_PU (rw) register accessor: an alias for `Reg<PA_PU_SPEC>`
    pub type PA_PU = crate::Reg<pa_pu::PA_PU_SPEC>;
    ///RW, GPIO PA pullup resistance enable
    pub mod pa_pu {
        ///Register `PA_PU` reader
        pub struct R(crate::R<PA_PU_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PA_PU_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<PA_PU_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<PA_PU_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `PA_PU` writer
        pub struct W(crate::W<PA_PU_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PA_PU_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<PA_PU_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<PA_PU_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `PA_PU_0` reader - GPIO PA pullup resistance enable byte 0
        pub type PA_PU_0_R = crate::FieldReader<u8, u8>;
        ///Field `PA_PU_0` writer - GPIO PA pullup resistance enable byte 0
        pub type PA_PU_0_W<'a, const O: u8> = crate::FieldWriter<'a, u32, PA_PU_SPEC, u8, u8, 8, O>;
        ///Field `PA_PU_1` reader - GPIO PA pullup resistance enable byte 0
        pub type PA_PU_1_R = crate::FieldReader<u8, u8>;
        ///Field `PA_PU_1` writer - GPIO PA pullup resistance enable byte 0
        pub type PA_PU_1_W<'a, const O: u8> = crate::FieldWriter<'a, u32, PA_PU_SPEC, u8, u8, 8, O>;
        impl R {
            ///Bits 0:7 - GPIO PA pullup resistance enable byte 0
            #[inline(always)]
            pub fn pa_pu_0(&self) -> PA_PU_0_R {
                PA_PU_0_R::new((self.bits & 0xff) as u8)
            }
            ///Bits 8:15 - GPIO PA pullup resistance enable byte 0
            #[inline(always)]
            pub fn pa_pu_1(&self) -> PA_PU_1_R {
                PA_PU_1_R::new(((self.bits >> 8) & 0xff) as u8)
            }
        }
        impl W {
            ///Bits 0:7 - GPIO PA pullup resistance enable byte 0
            #[inline(always)]
            #[must_use]
            pub fn pa_pu_0(&mut self) -> PA_PU_0_W<0> {
                PA_PU_0_W::new(self)
            }
            ///Bits 8:15 - GPIO PA pullup resistance enable byte 0
            #[inline(always)]
            #[must_use]
            pub fn pa_pu_1(&mut self) -> PA_PU_1_W<8> {
                PA_PU_1_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, GPIO PA pullup resistance enable
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [pa_pu](index.html) module
        pub struct PA_PU_SPEC;
        impl crate::RegisterSpec for PA_PU_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [pa_pu::R](R) reader structure
        impl crate::Readable for PA_PU_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [pa_pu::W](W) writer structure
        impl crate::Writable for PA_PU_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets PA_PU to value 0
        impl crate::Resettable for PA_PU_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///PA_PD_DRV (rw) register accessor: an alias for `Reg<PA_PD_DRV_SPEC>`
    pub type PA_PD_DRV = crate::Reg<pa_pd_drv::PA_PD_DRV_SPEC>;
    ///RW, PA pulldown for input or PA driving capability for output
    pub mod pa_pd_drv {
        ///Register `PA_PD_DRV` reader
        pub struct R(crate::R<PA_PD_DRV_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PA_PD_DRV_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<PA_PD_DRV_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<PA_PD_DRV_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `PA_PD_DRV` writer
        pub struct W(crate::W<PA_PD_DRV_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PA_PD_DRV_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<PA_PD_DRV_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<PA_PD_DRV_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `PA_PD_DRV_0` reader - PA pulldown for input or PA driving capability for output byte 0
        pub type PA_PD_DRV_0_R = crate::FieldReader<u8, u8>;
        ///Field `PA_PD_DRV_0` writer - PA pulldown for input or PA driving capability for output byte 0
        pub type PA_PD_DRV_0_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, PA_PD_DRV_SPEC, u8, u8, 8, O>;
        ///Field `PA_PD_DRV_1` reader - PA pulldown for input or PA driving capability for output byte 1
        pub type PA_PD_DRV_1_R = crate::FieldReader<u8, u8>;
        ///Field `PA_PD_DRV_1` writer - PA pulldown for input or PA driving capability for output byte 1
        pub type PA_PD_DRV_1_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, PA_PD_DRV_SPEC, u8, u8, 8, O>;
        impl R {
            ///Bits 0:7 - PA pulldown for input or PA driving capability for output byte 0
            #[inline(always)]
            pub fn pa_pd_drv_0(&self) -> PA_PD_DRV_0_R {
                PA_PD_DRV_0_R::new((self.bits & 0xff) as u8)
            }
            ///Bits 8:15 - PA pulldown for input or PA driving capability for output byte 1
            #[inline(always)]
            pub fn pa_pd_drv_1(&self) -> PA_PD_DRV_1_R {
                PA_PD_DRV_1_R::new(((self.bits >> 8) & 0xff) as u8)
            }
        }
        impl W {
            ///Bits 0:7 - PA pulldown for input or PA driving capability for output byte 0
            #[inline(always)]
            #[must_use]
            pub fn pa_pd_drv_0(&mut self) -> PA_PD_DRV_0_W<0> {
                PA_PD_DRV_0_W::new(self)
            }
            ///Bits 8:15 - PA pulldown for input or PA driving capability for output byte 1
            #[inline(always)]
            #[must_use]
            pub fn pa_pd_drv_1(&mut self) -> PA_PD_DRV_1_W<8> {
                PA_PD_DRV_1_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, PA pulldown for input or PA driving capability for output
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [pa_pd_drv](index.html) module
        pub struct PA_PD_DRV_SPEC;
        impl crate::RegisterSpec for PA_PD_DRV_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [pa_pd_drv::R](R) reader structure
        impl crate::Readable for PA_PD_DRV_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [pa_pd_drv::W](W) writer structure
        impl crate::Writable for PA_PD_DRV_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets PA_PD_DRV to value 0
        impl crate::Resettable for PA_PD_DRV_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///PB_DIR (rw) register accessor: an alias for `Reg<PB_DIR_SPEC>`
    pub type PB_DIR = crate::Reg<pb_dir::PB_DIR_SPEC>;
    ///RW, GPIO PB I/O direction: 0=in, 1=out
    pub mod pb_dir {
        ///Register `PB_DIR` reader
        pub struct R(crate::R<PB_DIR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PB_DIR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<PB_DIR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<PB_DIR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `PB_DIR` writer
        pub struct W(crate::W<PB_DIR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PB_DIR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<PB_DIR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<PB_DIR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `PB_DIR_0` reader - GPIO PB I/O direction byte 0
        pub type PB_DIR_0_R = crate::FieldReader<u8, u8>;
        ///Field `PB_DIR_0` writer - GPIO PB I/O direction byte 0
        pub type PB_DIR_0_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, PB_DIR_SPEC, u8, u8, 8, O>;
        ///Field `PB_DIR_1` reader - GPIO PB I/O direction byte 1
        pub type PB_DIR_1_R = crate::FieldReader<u8, u8>;
        ///Field `PB_DIR_1` writer - GPIO PB I/O direction byte 1
        pub type PB_DIR_1_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, PB_DIR_SPEC, u8, u8, 8, O>;
        ///Field `PB_DIR_2` reader - GPIO PB I/O direction byte 2
        pub type PB_DIR_2_R = crate::FieldReader<u8, u8>;
        ///Field `PB_DIR_2` writer - GPIO PB I/O direction byte 2
        pub type PB_DIR_2_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, PB_DIR_SPEC, u8, u8, 8, O>;
        impl R {
            ///Bits 0:7 - GPIO PB I/O direction byte 0
            #[inline(always)]
            pub fn pb_dir_0(&self) -> PB_DIR_0_R {
                PB_DIR_0_R::new((self.bits & 0xff) as u8)
            }
            ///Bits 8:15 - GPIO PB I/O direction byte 1
            #[inline(always)]
            pub fn pb_dir_1(&self) -> PB_DIR_1_R {
                PB_DIR_1_R::new(((self.bits >> 8) & 0xff) as u8)
            }
            ///Bits 16:23 - GPIO PB I/O direction byte 2
            #[inline(always)]
            pub fn pb_dir_2(&self) -> PB_DIR_2_R {
                PB_DIR_2_R::new(((self.bits >> 16) & 0xff) as u8)
            }
        }
        impl W {
            ///Bits 0:7 - GPIO PB I/O direction byte 0
            #[inline(always)]
            #[must_use]
            pub fn pb_dir_0(&mut self) -> PB_DIR_0_W<0> {
                PB_DIR_0_W::new(self)
            }
            ///Bits 8:15 - GPIO PB I/O direction byte 1
            #[inline(always)]
            #[must_use]
            pub fn pb_dir_1(&mut self) -> PB_DIR_1_W<8> {
                PB_DIR_1_W::new(self)
            }
            ///Bits 16:23 - GPIO PB I/O direction byte 2
            #[inline(always)]
            #[must_use]
            pub fn pb_dir_2(&mut self) -> PB_DIR_2_W<16> {
                PB_DIR_2_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, GPIO PB I/O direction: 0=in, 1=out
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [pb_dir](index.html) module
        pub struct PB_DIR_SPEC;
        impl crate::RegisterSpec for PB_DIR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [pb_dir::R](R) reader structure
        impl crate::Readable for PB_DIR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [pb_dir::W](W) writer structure
        impl crate::Writable for PB_DIR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets PB_DIR to value 0
        impl crate::Resettable for PB_DIR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///PB_PIN (r) register accessor: an alias for `Reg<PB_PIN_SPEC>`
    pub type PB_PIN = crate::Reg<pb_pin::PB_PIN_SPEC>;
    ///RO, GPIO PB input
    pub mod pb_pin {
        ///Register `PB_PIN` reader
        pub struct R(crate::R<PB_PIN_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PB_PIN_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<PB_PIN_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<PB_PIN_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `PB_PIN_0` reader - GPIO PB input byte 0
        pub type PB_PIN_0_R = crate::FieldReader<u8, u8>;
        ///Field `PB_PIN_1` reader - GPIO PB input byte 1
        pub type PB_PIN_1_R = crate::FieldReader<u8, u8>;
        ///Field `PB_PIN_2` reader - GPIO PB input byte 2
        pub type PB_PIN_2_R = crate::FieldReader<u8, u8>;
        impl R {
            ///Bits 0:7 - GPIO PB input byte 0
            #[inline(always)]
            pub fn pb_pin_0(&self) -> PB_PIN_0_R {
                PB_PIN_0_R::new((self.bits & 0xff) as u8)
            }
            ///Bits 8:15 - GPIO PB input byte 1
            #[inline(always)]
            pub fn pb_pin_1(&self) -> PB_PIN_1_R {
                PB_PIN_1_R::new(((self.bits >> 8) & 0xff) as u8)
            }
            ///Bits 16:23 - GPIO PB input byte 2
            #[inline(always)]
            pub fn pb_pin_2(&self) -> PB_PIN_2_R {
                PB_PIN_2_R::new(((self.bits >> 16) & 0xff) as u8)
            }
        }
        ///RO, GPIO PB input
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [pb_pin](index.html) module
        pub struct PB_PIN_SPEC;
        impl crate::RegisterSpec for PB_PIN_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [pb_pin::R](R) reader structure
        impl crate::Readable for PB_PIN_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets PB_PIN to value 0
        impl crate::Resettable for PB_PIN_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///PB_OUT__R8_SLV_RD_DATA (rw) register accessor: an alias for `Reg<PB_OUT__R8_SLV_RD_DATA_SPEC>`
    pub type PB_OUT__R8_SLV_RD_DATA =
        crate::Reg<pb_out__r8_slv_rd_data::PB_OUT__R8_SLV_RD_DATA_SPEC>;
    ///RW, GPIO PB output;RW, data for parallel slave read
    pub mod pb_out__r8_slv_rd_data {
        ///Register `PB_OUT__R8_SLV_RD_DATA` reader
        pub struct R(crate::R<PB_OUT__R8_SLV_RD_DATA_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PB_OUT__R8_SLV_RD_DATA_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<PB_OUT__R8_SLV_RD_DATA_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<PB_OUT__R8_SLV_RD_DATA_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `PB_OUT__R8_SLV_RD_DATA` writer
        pub struct W(crate::W<PB_OUT__R8_SLV_RD_DATA_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PB_OUT__R8_SLV_RD_DATA_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<PB_OUT__R8_SLV_RD_DATA_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<PB_OUT__R8_SLV_RD_DATA_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `PB_OUT_0` reader - GPIO PB output byte 0
        pub type PB_OUT_0_R = crate::FieldReader<u8, u8>;
        ///Field `PB_OUT_0` writer - GPIO PB output byte 0
        pub type PB_OUT_0_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, PB_OUT__R8_SLV_RD_DATA_SPEC, u8, u8, 8, O>;
        ///Field `PB_OUT_1` reader - GPIO PB output byte 1
        pub type PB_OUT_1_R = crate::FieldReader<u8, u8>;
        ///Field `PB_OUT_1` writer - GPIO PB output byte 1
        pub type PB_OUT_1_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, PB_OUT__R8_SLV_RD_DATA_SPEC, u8, u8, 8, O>;
        ///Field `PB_OUT_2` reader - GPIO PB output byte 2
        pub type PB_OUT_2_R = crate::FieldReader<u8, u8>;
        ///Field `PB_OUT_2` writer - GPIO PB output byte 2
        pub type PB_OUT_2_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, PB_OUT__R8_SLV_RD_DATA_SPEC, u8, u8, 8, O>;
        impl R {
            ///Bits 0:7 - GPIO PB output byte 0
            #[inline(always)]
            pub fn pb_out_0(&self) -> PB_OUT_0_R {
                PB_OUT_0_R::new((self.bits & 0xff) as u8)
            }
            ///Bits 8:15 - GPIO PB output byte 1
            #[inline(always)]
            pub fn pb_out_1(&self) -> PB_OUT_1_R {
                PB_OUT_1_R::new(((self.bits >> 8) & 0xff) as u8)
            }
            ///Bits 16:23 - GPIO PB output byte 2
            #[inline(always)]
            pub fn pb_out_2(&self) -> PB_OUT_2_R {
                PB_OUT_2_R::new(((self.bits >> 16) & 0xff) as u8)
            }
        }
        impl W {
            ///Bits 0:7 - GPIO PB output byte 0
            #[inline(always)]
            #[must_use]
            pub fn pb_out_0(&mut self) -> PB_OUT_0_W<0> {
                PB_OUT_0_W::new(self)
            }
            ///Bits 8:15 - GPIO PB output byte 1
            #[inline(always)]
            #[must_use]
            pub fn pb_out_1(&mut self) -> PB_OUT_1_W<8> {
                PB_OUT_1_W::new(self)
            }
            ///Bits 16:23 - GPIO PB output byte 2
            #[inline(always)]
            #[must_use]
            pub fn pb_out_2(&mut self) -> PB_OUT_2_W<16> {
                PB_OUT_2_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, GPIO PB output;RW, data for parallel slave read
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [pb_out__r8_slv_rd_data](index.html) module
        pub struct PB_OUT__R8_SLV_RD_DATA_SPEC;
        impl crate::RegisterSpec for PB_OUT__R8_SLV_RD_DATA_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [pb_out__r8_slv_rd_data::R](R) reader structure
        impl crate::Readable for PB_OUT__R8_SLV_RD_DATA_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [pb_out__r8_slv_rd_data::W](W) writer structure
        impl crate::Writable for PB_OUT__R8_SLV_RD_DATA_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets PB_OUT__R8_SLV_RD_DATA to value 0
        impl crate::Resettable for PB_OUT__R8_SLV_RD_DATA_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///PB_CLR (rw) register accessor: an alias for `Reg<PB_CLR_SPEC>`
    pub type PB_CLR = crate::Reg<pb_clr::PB_CLR_SPEC>;
    ///WZ, GPIO PB clear output: 0=keep, 1=clear
    pub mod pb_clr {
        ///Register `PB_CLR` reader
        pub struct R(crate::R<PB_CLR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PB_CLR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<PB_CLR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<PB_CLR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `PB_CLR` writer
        pub struct W(crate::W<PB_CLR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PB_CLR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<PB_CLR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<PB_CLR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `PB_CLR_0` reader - GPIO PB clear output byte 0
        pub type PB_CLR_0_R = crate::FieldReader<u8, u8>;
        ///Field `PB_CLR_0` writer - GPIO PB clear output byte 0
        pub type PB_CLR_0_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, PB_CLR_SPEC, u8, u8, 8, O>;
        ///Field `PB_CLR_1` reader - GPIO PB clear output byte 1
        pub type PB_CLR_1_R = crate::FieldReader<u8, u8>;
        ///Field `PB_CLR_1` writer - GPIO PB clear output byte 1
        pub type PB_CLR_1_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, PB_CLR_SPEC, u8, u8, 8, O>;
        ///Field `PB_CLR_2` reader - GPIO PB clear output byte 2
        pub type PB_CLR_2_R = crate::FieldReader<u8, u8>;
        ///Field `PB_CLR_2` writer - GPIO PB clear output byte 2
        pub type PB_CLR_2_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, PB_CLR_SPEC, u8, u8, 8, O>;
        impl R {
            ///Bits 0:7 - GPIO PB clear output byte 0
            #[inline(always)]
            pub fn pb_clr_0(&self) -> PB_CLR_0_R {
                PB_CLR_0_R::new((self.bits & 0xff) as u8)
            }
            ///Bits 8:15 - GPIO PB clear output byte 1
            #[inline(always)]
            pub fn pb_clr_1(&self) -> PB_CLR_1_R {
                PB_CLR_1_R::new(((self.bits >> 8) & 0xff) as u8)
            }
            ///Bits 16:23 - GPIO PB clear output byte 2
            #[inline(always)]
            pub fn pb_clr_2(&self) -> PB_CLR_2_R {
                PB_CLR_2_R::new(((self.bits >> 16) & 0xff) as u8)
            }
        }
        impl W {
            ///Bits 0:7 - GPIO PB clear output byte 0
            #[inline(always)]
            #[must_use]
            pub fn pb_clr_0(&mut self) -> PB_CLR_0_W<0> {
                PB_CLR_0_W::new(self)
            }
            ///Bits 8:15 - GPIO PB clear output byte 1
            #[inline(always)]
            #[must_use]
            pub fn pb_clr_1(&mut self) -> PB_CLR_1_W<8> {
                PB_CLR_1_W::new(self)
            }
            ///Bits 16:23 - GPIO PB clear output byte 2
            #[inline(always)]
            #[must_use]
            pub fn pb_clr_2(&mut self) -> PB_CLR_2_W<16> {
                PB_CLR_2_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///WZ, GPIO PB clear output: 0=keep, 1=clear
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [pb_clr](index.html) module
        pub struct PB_CLR_SPEC;
        impl crate::RegisterSpec for PB_CLR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [pb_clr::R](R) reader structure
        impl crate::Readable for PB_CLR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [pb_clr::W](W) writer structure
        impl crate::Writable for PB_CLR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets PB_CLR to value 0
        impl crate::Resettable for PB_CLR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///PB_PU (rw) register accessor: an alias for `Reg<PB_PU_SPEC>`
    pub type PB_PU = crate::Reg<pb_pu::PB_PU_SPEC>;
    ///RW, GPIO PB pullup resistance enable
    pub mod pb_pu {
        ///Register `PB_PU` reader
        pub struct R(crate::R<PB_PU_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PB_PU_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<PB_PU_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<PB_PU_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `PB_PU` writer
        pub struct W(crate::W<PB_PU_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PB_PU_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<PB_PU_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<PB_PU_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `PB_PU_0` reader - GPIO PB pullup resistance enable byte 0
        pub type PB_PU_0_R = crate::FieldReader<u8, u8>;
        ///Field `PB_PU_0` writer - GPIO PB pullup resistance enable byte 0
        pub type PB_PU_0_W<'a, const O: u8> = crate::FieldWriter<'a, u32, PB_PU_SPEC, u8, u8, 8, O>;
        ///Field `PB_PU_1` reader - GPIO PB pullup resistance enable byte 1
        pub type PB_PU_1_R = crate::FieldReader<u8, u8>;
        ///Field `PB_PU_1` writer - GPIO PB pullup resistance enable byte 1
        pub type PB_PU_1_W<'a, const O: u8> = crate::FieldWriter<'a, u32, PB_PU_SPEC, u8, u8, 8, O>;
        ///Field `PB_PU_2` reader - GPIO PB pullup resistance enable byte 2
        pub type PB_PU_2_R = crate::FieldReader<u8, u8>;
        ///Field `PB_PU_2` writer - GPIO PB pullup resistance enable byte 2
        pub type PB_PU_2_W<'a, const O: u8> = crate::FieldWriter<'a, u32, PB_PU_SPEC, u8, u8, 8, O>;
        impl R {
            ///Bits 0:7 - GPIO PB pullup resistance enable byte 0
            #[inline(always)]
            pub fn pb_pu_0(&self) -> PB_PU_0_R {
                PB_PU_0_R::new((self.bits & 0xff) as u8)
            }
            ///Bits 8:15 - GPIO PB pullup resistance enable byte 1
            #[inline(always)]
            pub fn pb_pu_1(&self) -> PB_PU_1_R {
                PB_PU_1_R::new(((self.bits >> 8) & 0xff) as u8)
            }
            ///Bits 16:23 - GPIO PB pullup resistance enable byte 2
            #[inline(always)]
            pub fn pb_pu_2(&self) -> PB_PU_2_R {
                PB_PU_2_R::new(((self.bits >> 16) & 0xff) as u8)
            }
        }
        impl W {
            ///Bits 0:7 - GPIO PB pullup resistance enable byte 0
            #[inline(always)]
            #[must_use]
            pub fn pb_pu_0(&mut self) -> PB_PU_0_W<0> {
                PB_PU_0_W::new(self)
            }
            ///Bits 8:15 - GPIO PB pullup resistance enable byte 1
            #[inline(always)]
            #[must_use]
            pub fn pb_pu_1(&mut self) -> PB_PU_1_W<8> {
                PB_PU_1_W::new(self)
            }
            ///Bits 16:23 - GPIO PB pullup resistance enable byte 2
            #[inline(always)]
            #[must_use]
            pub fn pb_pu_2(&mut self) -> PB_PU_2_W<16> {
                PB_PU_2_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, GPIO PB pullup resistance enable
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [pb_pu](index.html) module
        pub struct PB_PU_SPEC;
        impl crate::RegisterSpec for PB_PU_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [pb_pu::R](R) reader structure
        impl crate::Readable for PB_PU_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [pb_pu::W](W) writer structure
        impl crate::Writable for PB_PU_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets PB_PU to value 0
        impl crate::Resettable for PB_PU_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///PB_PD_DRV (rw) register accessor: an alias for `Reg<PB_PD_DRV_SPEC>`
    pub type PB_PD_DRV = crate::Reg<pb_pd_drv::PB_PD_DRV_SPEC>;
    ///RW, PB pulldown for input or PB driving capability for output
    pub mod pb_pd_drv {
        ///Register `PB_PD_DRV` reader
        pub struct R(crate::R<PB_PD_DRV_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PB_PD_DRV_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<PB_PD_DRV_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<PB_PD_DRV_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `PB_PD_DRV` writer
        pub struct W(crate::W<PB_PD_DRV_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PB_PD_DRV_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<PB_PD_DRV_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<PB_PD_DRV_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `PB_PD_DRV_0` reader - PB pulldown for input or PB driving capability for output byte 0
        pub type PB_PD_DRV_0_R = crate::FieldReader<u8, u8>;
        ///Field `PB_PD_DRV_0` writer - PB pulldown for input or PB driving capability for output byte 0
        pub type PB_PD_DRV_0_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, PB_PD_DRV_SPEC, u8, u8, 8, O>;
        ///Field `PB_PD_DRV_1` reader - PB pulldown for input or PB driving capability for output byte 0
        pub type PB_PD_DRV_1_R = crate::FieldReader<u8, u8>;
        ///Field `PB_PD_DRV_1` writer - PB pulldown for input or PB driving capability for output byte 0
        pub type PB_PD_DRV_1_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, PB_PD_DRV_SPEC, u8, u8, 8, O>;
        ///Field `PB_PD_DRV_2` reader - PB pulldown for input or PB driving capability for output byte 0
        pub type PB_PD_DRV_2_R = crate::FieldReader<u8, u8>;
        ///Field `PB_PD_DRV_2` writer - PB pulldown for input or PB driving capability for output byte 0
        pub type PB_PD_DRV_2_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, PB_PD_DRV_SPEC, u8, u8, 8, O>;
        impl R {
            ///Bits 0:7 - PB pulldown for input or PB driving capability for output byte 0
            #[inline(always)]
            pub fn pb_pd_drv_0(&self) -> PB_PD_DRV_0_R {
                PB_PD_DRV_0_R::new((self.bits & 0xff) as u8)
            }
            ///Bits 8:15 - PB pulldown for input or PB driving capability for output byte 0
            #[inline(always)]
            pub fn pb_pd_drv_1(&self) -> PB_PD_DRV_1_R {
                PB_PD_DRV_1_R::new(((self.bits >> 8) & 0xff) as u8)
            }
            ///Bits 16:23 - PB pulldown for input or PB driving capability for output byte 0
            #[inline(always)]
            pub fn pb_pd_drv_2(&self) -> PB_PD_DRV_2_R {
                PB_PD_DRV_2_R::new(((self.bits >> 16) & 0xff) as u8)
            }
        }
        impl W {
            ///Bits 0:7 - PB pulldown for input or PB driving capability for output byte 0
            #[inline(always)]
            #[must_use]
            pub fn pb_pd_drv_0(&mut self) -> PB_PD_DRV_0_W<0> {
                PB_PD_DRV_0_W::new(self)
            }
            ///Bits 8:15 - PB pulldown for input or PB driving capability for output byte 0
            #[inline(always)]
            #[must_use]
            pub fn pb_pd_drv_1(&mut self) -> PB_PD_DRV_1_W<8> {
                PB_PD_DRV_1_W::new(self)
            }
            ///Bits 16:23 - PB pulldown for input or PB driving capability for output byte 0
            #[inline(always)]
            #[must_use]
            pub fn pb_pd_drv_2(&mut self) -> PB_PD_DRV_2_W<16> {
                PB_PD_DRV_2_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, PB pulldown for input or PB driving capability for output
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [pb_pd_drv](index.html) module
        pub struct PB_PD_DRV_SPEC;
        impl crate::RegisterSpec for PB_PD_DRV_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [pb_pd_drv::R](R) reader structure
        impl crate::Readable for PB_PD_DRV_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [pb_pd_drv::W](W) writer structure
        impl crate::Writable for PB_PD_DRV_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets PB_PD_DRV to value 0
        impl crate::Resettable for PB_PD_DRV_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
}
///Timer0 register
pub struct TMR0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for TMR0 {}
impl TMR0 {
    ///Pointer to the register block
    pub const PTR: *const tmr0::RegisterBlock = 0x4000_2000 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const tmr0::RegisterBlock {
        Self::PTR
    }
}
impl Deref for TMR0 {
    type Target = tmr0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for TMR0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("TMR0").finish()
    }
}
///Timer0 register
pub mod tmr0 {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        ///0x00 - RW, TMR0 mode control
        pub tmr0_ctrl_mod: TMR0_CTRL_MOD,
        _reserved1: [u8; 0x01],
        ///0x02 - RW, TMR0 interrupt enable
        pub tmr0_inter_en: TMR0_INTER_EN,
        _reserved2: [u8; 0x03],
        ///0x06 - RW1, TMR0 interrupt flag
        pub tmr0_int_flag: TMR0_INT_FLAG,
        ///0x07 - RO, TMR0 FIFO count status
        pub tmr0_fifo_count: TMR0_FIFO_COUNT,
        ///0x08 - RO, TMR0 current count
        pub tmr0_count: TMR0_COUNT,
        ///0x0c - RW, TMR0 end count value, only low 26 bit
        pub tmr0_cnt_end: TMR0_CNT_END,
        ///0x10 - RO/WO, TMR0 FIFO register, only low 26 bit
        pub tmr0_fifo: TMR0_FIFO,
    }
    ///TMR0_CTRL_MOD (rw) register accessor: an alias for `Reg<TMR0_CTRL_MOD_SPEC>`
    pub type TMR0_CTRL_MOD = crate::Reg<tmr0_ctrl_mod::TMR0_CTRL_MOD_SPEC>;
    ///RW, TMR0 mode control
    pub mod tmr0_ctrl_mod {
        ///Register `TMR0_CTRL_MOD` reader
        pub struct R(crate::R<TMR0_CTRL_MOD_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<TMR0_CTRL_MOD_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<TMR0_CTRL_MOD_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<TMR0_CTRL_MOD_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `TMR0_CTRL_MOD` writer
        pub struct W(crate::W<TMR0_CTRL_MOD_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<TMR0_CTRL_MOD_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<TMR0_CTRL_MOD_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<TMR0_CTRL_MOD_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `TMR_MODE_IN` reader - RW, timer in mode: 0=timer/PWM, 1=capture/count
        pub type TMR_MODE_IN_R = crate::BitReader<bool>;
        ///Field `TMR_MODE_IN` writer - RW, timer in mode: 0=timer/PWM, 1=capture/count
        pub type TMR_MODE_IN_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, TMR0_CTRL_MOD_SPEC, bool, O>;
        ///Field `TMR_ALL_CLEAR` reader - RW, force clear timer FIFO and count
        pub type TMR_ALL_CLEAR_R = crate::BitReader<bool>;
        ///Field `TMR_ALL_CLEAR` writer - RW, force clear timer FIFO and count
        pub type TMR_ALL_CLEAR_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, TMR0_CTRL_MOD_SPEC, bool, O>;
        ///Field `TMR_COUNT_EN` reader - RW, timer count enable
        pub type TMR_COUNT_EN_R = crate::BitReader<bool>;
        ///Field `TMR_COUNT_EN` writer - RW, timer count enable
        pub type TMR_COUNT_EN_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, TMR0_CTRL_MOD_SPEC, bool, O>;
        ///Field `TMR_OUT_EN` reader - RW, timer output enable
        pub type TMR_OUT_EN_R = crate::BitReader<bool>;
        ///Field `TMR_OUT_EN` writer - RW, timer output enable
        pub type TMR_OUT_EN_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, TMR0_CTRL_MOD_SPEC, bool, O>;
        ///Field `TMR_OUT_POLAR__RB_TMR_CAP_COUNT` reader - RW, timer PWM output polarity: 0=default low and high action, 1=default high and low action;RW, count sub-mode if RB_TMR_MODE_IN=1: 0=capture, 1=count
        pub type TMR_OUT_POLAR__RB_TMR_CAP_COUNT_R = crate::BitReader<bool>;
        ///Field `TMR_OUT_POLAR__RB_TMR_CAP_COUNT` writer - RW, timer PWM output polarity: 0=default low and high action, 1=default high and low action;RW, count sub-mode if RB_TMR_MODE_IN=1: 0=capture, 1=count
        pub type TMR_OUT_POLAR__RB_TMR_CAP_COUNT_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, TMR0_CTRL_MOD_SPEC, bool, O>;
        ///Field `TMR_PWM_REPEAT__RB_TMR_CAP_EDGE` reader - RW, timer PWM repeat mode: 00=1, 01=4, 10=8, 11-16;RW, timer capture edge mode: 00=disable, 01=edge change, 10=fall to fall, 11-rise to rise
        pub type TMR_PWM_REPEAT__RB_TMR_CAP_EDGE_R = crate::FieldReader<u8, u8>;
        ///Field `TMR_PWM_REPEAT__RB_TMR_CAP_EDGE` writer - RW, timer PWM repeat mode: 00=1, 01=4, 10=8, 11-16;RW, timer capture edge mode: 00=disable, 01=edge change, 10=fall to fall, 11-rise to rise
        pub type TMR_PWM_REPEAT__RB_TMR_CAP_EDGE_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, TMR0_CTRL_MOD_SPEC, u8, u8, 2, O>;
        impl R {
            ///Bit 0 - RW, timer in mode: 0=timer/PWM, 1=capture/count
            #[inline(always)]
            pub fn tmr_mode_in(&self) -> TMR_MODE_IN_R {
                TMR_MODE_IN_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RW, force clear timer FIFO and count
            #[inline(always)]
            pub fn tmr_all_clear(&self) -> TMR_ALL_CLEAR_R {
                TMR_ALL_CLEAR_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RW, timer count enable
            #[inline(always)]
            pub fn tmr_count_en(&self) -> TMR_COUNT_EN_R {
                TMR_COUNT_EN_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RW, timer output enable
            #[inline(always)]
            pub fn tmr_out_en(&self) -> TMR_OUT_EN_R {
                TMR_OUT_EN_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RW, timer PWM output polarity: 0=default low and high action, 1=default high and low action;RW, count sub-mode if RB_TMR_MODE_IN=1: 0=capture, 1=count
            #[inline(always)]
            pub fn tmr_out_polar__rb_tmr_cap_count(&self) -> TMR_OUT_POLAR__RB_TMR_CAP_COUNT_R {
                TMR_OUT_POLAR__RB_TMR_CAP_COUNT_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bits 6:7 - RW, timer PWM repeat mode: 00=1, 01=4, 10=8, 11-16;RW, timer capture edge mode: 00=disable, 01=edge change, 10=fall to fall, 11-rise to rise
            #[inline(always)]
            pub fn tmr_pwm_repeat__rb_tmr_cap_edge(&self) -> TMR_PWM_REPEAT__RB_TMR_CAP_EDGE_R {
                TMR_PWM_REPEAT__RB_TMR_CAP_EDGE_R::new((self.bits >> 6) & 3)
            }
        }
        impl W {
            ///Bit 0 - RW, timer in mode: 0=timer/PWM, 1=capture/count
            #[inline(always)]
            #[must_use]
            pub fn tmr_mode_in(&mut self) -> TMR_MODE_IN_W<0> {
                TMR_MODE_IN_W::new(self)
            }
            ///Bit 1 - RW, force clear timer FIFO and count
            #[inline(always)]
            #[must_use]
            pub fn tmr_all_clear(&mut self) -> TMR_ALL_CLEAR_W<1> {
                TMR_ALL_CLEAR_W::new(self)
            }
            ///Bit 2 - RW, timer count enable
            #[inline(always)]
            #[must_use]
            pub fn tmr_count_en(&mut self) -> TMR_COUNT_EN_W<2> {
                TMR_COUNT_EN_W::new(self)
            }
            ///Bit 3 - RW, timer output enable
            #[inline(always)]
            #[must_use]
            pub fn tmr_out_en(&mut self) -> TMR_OUT_EN_W<3> {
                TMR_OUT_EN_W::new(self)
            }
            ///Bit 4 - RW, timer PWM output polarity: 0=default low and high action, 1=default high and low action;RW, count sub-mode if RB_TMR_MODE_IN=1: 0=capture, 1=count
            #[inline(always)]
            #[must_use]
            pub fn tmr_out_polar__rb_tmr_cap_count(
                &mut self,
            ) -> TMR_OUT_POLAR__RB_TMR_CAP_COUNT_W<4> {
                TMR_OUT_POLAR__RB_TMR_CAP_COUNT_W::new(self)
            }
            ///Bits 6:7 - RW, timer PWM repeat mode: 00=1, 01=4, 10=8, 11-16;RW, timer capture edge mode: 00=disable, 01=edge change, 10=fall to fall, 11-rise to rise
            #[inline(always)]
            #[must_use]
            pub fn tmr_pwm_repeat__rb_tmr_cap_edge(
                &mut self,
            ) -> TMR_PWM_REPEAT__RB_TMR_CAP_EDGE_W<6> {
                TMR_PWM_REPEAT__RB_TMR_CAP_EDGE_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, TMR0 mode control
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [tmr0_ctrl_mod](index.html) module
        pub struct TMR0_CTRL_MOD_SPEC;
        impl crate::RegisterSpec for TMR0_CTRL_MOD_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [tmr0_ctrl_mod::R](R) reader structure
        impl crate::Readable for TMR0_CTRL_MOD_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [tmr0_ctrl_mod::W](W) writer structure
        impl crate::Writable for TMR0_CTRL_MOD_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets TMR0_CTRL_MOD to value 0x02
        impl crate::Resettable for TMR0_CTRL_MOD_SPEC {
            const RESET_VALUE: Self::Ux = 0x02;
        }
    }
    ///TMR0_INTER_EN (rw) register accessor: an alias for `Reg<TMR0_INTER_EN_SPEC>`
    pub type TMR0_INTER_EN = crate::Reg<tmr0_inter_en::TMR0_INTER_EN_SPEC>;
    ///RW, TMR0 interrupt enable
    pub mod tmr0_inter_en {
        ///Register `TMR0_INTER_EN` reader
        pub struct R(crate::R<TMR0_INTER_EN_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<TMR0_INTER_EN_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<TMR0_INTER_EN_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<TMR0_INTER_EN_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `TMR0_INTER_EN` writer
        pub struct W(crate::W<TMR0_INTER_EN_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<TMR0_INTER_EN_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<TMR0_INTER_EN_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<TMR0_INTER_EN_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `TMR_IE_CYC_END` reader - RW, enable interrupt for timer capture count timeout or PWM cycle end
        pub type TMR_IE_CYC_END_R = crate::BitReader<bool>;
        ///Field `TMR_IE_CYC_END` writer - RW, enable interrupt for timer capture count timeout or PWM cycle end
        pub type TMR_IE_CYC_END_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, TMR0_INTER_EN_SPEC, bool, O>;
        ///Field `TMR_IE_DATA_ACT` reader - RW, enable interrupt for timer capture input action or PWM trigger
        pub type TMR_IE_DATA_ACT_R = crate::BitReader<bool>;
        ///Field `TMR_IE_DATA_ACT` writer - RW, enable interrupt for timer capture input action or PWM trigger
        pub type TMR_IE_DATA_ACT_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, TMR0_INTER_EN_SPEC, bool, O>;
        ///Field `TMR_IE_FIFO_HF` reader - RW, enable interrupt for timer FIFO half (capture fifo >=4 or PWM fifo less than 3)
        pub type TMR_IE_FIFO_HF_R = crate::BitReader<bool>;
        ///Field `TMR_IE_FIFO_HF` writer - RW, enable interrupt for timer FIFO half (capture fifo >=4 or PWM fifo less than 3)
        pub type TMR_IE_FIFO_HF_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, TMR0_INTER_EN_SPEC, bool, O>;
        ///Field `TMR_IE_DMA_END` reader - RW, enable interrupt for timer1/2 DMA completion
        pub type TMR_IE_DMA_END_R = crate::BitReader<bool>;
        ///Field `TMR_IE_DMA_END` writer - RW, enable interrupt for timer1/2 DMA completion
        pub type TMR_IE_DMA_END_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, TMR0_INTER_EN_SPEC, bool, O>;
        ///Field `TMR_IE_FIFO_OV` reader - RW, enable interrupt for timer FIFO overflow
        pub type TMR_IE_FIFO_OV_R = crate::BitReader<bool>;
        ///Field `TMR_IE_FIFO_OV` writer - RW, enable interrupt for timer FIFO overflow
        pub type TMR_IE_FIFO_OV_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, TMR0_INTER_EN_SPEC, bool, O>;
        impl R {
            ///Bit 0 - RW, enable interrupt for timer capture count timeout or PWM cycle end
            #[inline(always)]
            pub fn tmr_ie_cyc_end(&self) -> TMR_IE_CYC_END_R {
                TMR_IE_CYC_END_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RW, enable interrupt for timer capture input action or PWM trigger
            #[inline(always)]
            pub fn tmr_ie_data_act(&self) -> TMR_IE_DATA_ACT_R {
                TMR_IE_DATA_ACT_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RW, enable interrupt for timer FIFO half (capture fifo >=4 or PWM fifo less than 3)
            #[inline(always)]
            pub fn tmr_ie_fifo_hf(&self) -> TMR_IE_FIFO_HF_R {
                TMR_IE_FIFO_HF_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RW, enable interrupt for timer1/2 DMA completion
            #[inline(always)]
            pub fn tmr_ie_dma_end(&self) -> TMR_IE_DMA_END_R {
                TMR_IE_DMA_END_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RW, enable interrupt for timer FIFO overflow
            #[inline(always)]
            pub fn tmr_ie_fifo_ov(&self) -> TMR_IE_FIFO_OV_R {
                TMR_IE_FIFO_OV_R::new(((self.bits >> 4) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RW, enable interrupt for timer capture count timeout or PWM cycle end
            #[inline(always)]
            #[must_use]
            pub fn tmr_ie_cyc_end(&mut self) -> TMR_IE_CYC_END_W<0> {
                TMR_IE_CYC_END_W::new(self)
            }
            ///Bit 1 - RW, enable interrupt for timer capture input action or PWM trigger
            #[inline(always)]
            #[must_use]
            pub fn tmr_ie_data_act(&mut self) -> TMR_IE_DATA_ACT_W<1> {
                TMR_IE_DATA_ACT_W::new(self)
            }
            ///Bit 2 - RW, enable interrupt for timer FIFO half (capture fifo >=4 or PWM fifo less than 3)
            #[inline(always)]
            #[must_use]
            pub fn tmr_ie_fifo_hf(&mut self) -> TMR_IE_FIFO_HF_W<2> {
                TMR_IE_FIFO_HF_W::new(self)
            }
            ///Bit 3 - RW, enable interrupt for timer1/2 DMA completion
            #[inline(always)]
            #[must_use]
            pub fn tmr_ie_dma_end(&mut self) -> TMR_IE_DMA_END_W<3> {
                TMR_IE_DMA_END_W::new(self)
            }
            ///Bit 4 - RW, enable interrupt for timer FIFO overflow
            #[inline(always)]
            #[must_use]
            pub fn tmr_ie_fifo_ov(&mut self) -> TMR_IE_FIFO_OV_W<4> {
                TMR_IE_FIFO_OV_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, TMR0 interrupt enable
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [tmr0_inter_en](index.html) module
        pub struct TMR0_INTER_EN_SPEC;
        impl crate::RegisterSpec for TMR0_INTER_EN_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [tmr0_inter_en::R](R) reader structure
        impl crate::Readable for TMR0_INTER_EN_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [tmr0_inter_en::W](W) writer structure
        impl crate::Writable for TMR0_INTER_EN_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets TMR0_INTER_EN to value 0
        impl crate::Resettable for TMR0_INTER_EN_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///TMR0_INT_FLAG (rw) register accessor: an alias for `Reg<TMR0_INT_FLAG_SPEC>`
    pub type TMR0_INT_FLAG = crate::Reg<tmr0_int_flag::TMR0_INT_FLAG_SPEC>;
    ///RW1, TMR0 interrupt flag
    pub mod tmr0_int_flag {
        ///Register `TMR0_INT_FLAG` reader
        pub struct R(crate::R<TMR0_INT_FLAG_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<TMR0_INT_FLAG_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<TMR0_INT_FLAG_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<TMR0_INT_FLAG_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `TMR0_INT_FLAG` writer
        pub struct W(crate::W<TMR0_INT_FLAG_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<TMR0_INT_FLAG_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<TMR0_INT_FLAG_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<TMR0_INT_FLAG_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `TMR_IF_CYC_END` reader - RW1, interrupt flag for timer capture count timeout or PWM cycle end
        pub type TMR_IF_CYC_END_R = crate::BitReader<bool>;
        ///Field `TMR_IF_CYC_END` writer - RW1, interrupt flag for timer capture count timeout or PWM cycle end
        pub type TMR_IF_CYC_END_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, TMR0_INT_FLAG_SPEC, bool, O>;
        ///Field `TMR_IF_DATA_ACT` reader - RW1, interrupt flag for timer capture input action or PWM trigger
        pub type TMR_IF_DATA_ACT_R = crate::BitReader<bool>;
        ///Field `TMR_IF_DATA_ACT` writer - RW1, interrupt flag for timer capture input action or PWM trigger
        pub type TMR_IF_DATA_ACT_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, TMR0_INT_FLAG_SPEC, bool, O>;
        ///Field `TMR_IF_FIFO_HF` reader - RW1, interrupt flag for timer FIFO half (capture fifo >=4 or PWM fifo less than 3
        pub type TMR_IF_FIFO_HF_R = crate::BitReader<bool>;
        ///Field `TMR_IF_FIFO_HF` writer - RW1, interrupt flag for timer FIFO half (capture fifo >=4 or PWM fifo less than 3
        pub type TMR_IF_FIFO_HF_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, TMR0_INT_FLAG_SPEC, bool, O>;
        ///Field `TMR_IF_DMA_END` reader - RW1, interrupt flag for timer1/2 DMA completion
        pub type TMR_IF_DMA_END_R = crate::BitReader<bool>;
        ///Field `TMR_IF_DMA_END` writer - RW1, interrupt flag for timer1/2 DMA completion
        pub type TMR_IF_DMA_END_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, TMR0_INT_FLAG_SPEC, bool, O>;
        ///Field `TMR_IF_FIFO_OV` reader - RW1, interrupt flag for timer FIFO overflow
        pub type TMR_IF_FIFO_OV_R = crate::BitReader<bool>;
        ///Field `TMR_IF_FIFO_OV` writer - RW1, interrupt flag for timer FIFO overflow
        pub type TMR_IF_FIFO_OV_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, TMR0_INT_FLAG_SPEC, bool, O>;
        impl R {
            ///Bit 0 - RW1, interrupt flag for timer capture count timeout or PWM cycle end
            #[inline(always)]
            pub fn tmr_if_cyc_end(&self) -> TMR_IF_CYC_END_R {
                TMR_IF_CYC_END_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RW1, interrupt flag for timer capture input action or PWM trigger
            #[inline(always)]
            pub fn tmr_if_data_act(&self) -> TMR_IF_DATA_ACT_R {
                TMR_IF_DATA_ACT_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RW1, interrupt flag for timer FIFO half (capture fifo >=4 or PWM fifo less than 3
            #[inline(always)]
            pub fn tmr_if_fifo_hf(&self) -> TMR_IF_FIFO_HF_R {
                TMR_IF_FIFO_HF_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RW1, interrupt flag for timer1/2 DMA completion
            #[inline(always)]
            pub fn tmr_if_dma_end(&self) -> TMR_IF_DMA_END_R {
                TMR_IF_DMA_END_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RW1, interrupt flag for timer FIFO overflow
            #[inline(always)]
            pub fn tmr_if_fifo_ov(&self) -> TMR_IF_FIFO_OV_R {
                TMR_IF_FIFO_OV_R::new(((self.bits >> 4) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RW1, interrupt flag for timer capture count timeout or PWM cycle end
            #[inline(always)]
            #[must_use]
            pub fn tmr_if_cyc_end(&mut self) -> TMR_IF_CYC_END_W<0> {
                TMR_IF_CYC_END_W::new(self)
            }
            ///Bit 1 - RW1, interrupt flag for timer capture input action or PWM trigger
            #[inline(always)]
            #[must_use]
            pub fn tmr_if_data_act(&mut self) -> TMR_IF_DATA_ACT_W<1> {
                TMR_IF_DATA_ACT_W::new(self)
            }
            ///Bit 2 - RW1, interrupt flag for timer FIFO half (capture fifo >=4 or PWM fifo less than 3
            #[inline(always)]
            #[must_use]
            pub fn tmr_if_fifo_hf(&mut self) -> TMR_IF_FIFO_HF_W<2> {
                TMR_IF_FIFO_HF_W::new(self)
            }
            ///Bit 3 - RW1, interrupt flag for timer1/2 DMA completion
            #[inline(always)]
            #[must_use]
            pub fn tmr_if_dma_end(&mut self) -> TMR_IF_DMA_END_W<3> {
                TMR_IF_DMA_END_W::new(self)
            }
            ///Bit 4 - RW1, interrupt flag for timer FIFO overflow
            #[inline(always)]
            #[must_use]
            pub fn tmr_if_fifo_ov(&mut self) -> TMR_IF_FIFO_OV_W<4> {
                TMR_IF_FIFO_OV_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW1, TMR0 interrupt flag
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [tmr0_int_flag](index.html) module
        pub struct TMR0_INT_FLAG_SPEC;
        impl crate::RegisterSpec for TMR0_INT_FLAG_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [tmr0_int_flag::R](R) reader structure
        impl crate::Readable for TMR0_INT_FLAG_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [tmr0_int_flag::W](W) writer structure
        impl crate::Writable for TMR0_INT_FLAG_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets TMR0_INT_FLAG to value 0
        impl crate::Resettable for TMR0_INT_FLAG_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///TMR0_FIFO_COUNT (r) register accessor: an alias for `Reg<TMR0_FIFO_COUNT_SPEC>`
    pub type TMR0_FIFO_COUNT = crate::Reg<tmr0_fifo_count::TMR0_FIFO_COUNT_SPEC>;
    ///RO, TMR0 FIFO count status
    pub mod tmr0_fifo_count {
        ///Register `TMR0_FIFO_COUNT` reader
        pub struct R(crate::R<TMR0_FIFO_COUNT_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<TMR0_FIFO_COUNT_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<TMR0_FIFO_COUNT_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<TMR0_FIFO_COUNT_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `TMR0_FIFO_COUNT` reader - RW1,TMR0 FIFO count status
        pub type TMR0_FIFO_COUNT_R = crate::FieldReader<u8, u8>;
        impl R {
            ///Bits 0:7 - RW1,TMR0 FIFO count status
            #[inline(always)]
            pub fn tmr0_fifo_count(&self) -> TMR0_FIFO_COUNT_R {
                TMR0_FIFO_COUNT_R::new(self.bits)
            }
        }
        ///RO, TMR0 FIFO count status
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [tmr0_fifo_count](index.html) module
        pub struct TMR0_FIFO_COUNT_SPEC;
        impl crate::RegisterSpec for TMR0_FIFO_COUNT_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [tmr0_fifo_count::R](R) reader structure
        impl crate::Readable for TMR0_FIFO_COUNT_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets TMR0_FIFO_COUNT to value 0
        impl crate::Resettable for TMR0_FIFO_COUNT_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///TMR0_COUNT (r) register accessor: an alias for `Reg<TMR0_COUNT_SPEC>`
    pub type TMR0_COUNT = crate::Reg<tmr0_count::TMR0_COUNT_SPEC>;
    ///RO, TMR0 current count
    pub mod tmr0_count {
        ///Register `TMR0_COUNT` reader
        pub struct R(crate::R<TMR0_COUNT_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<TMR0_COUNT_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<TMR0_COUNT_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<TMR0_COUNT_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `TMR0_COUNT` reader - RW1,TMR0 current count
        pub type TMR0_COUNT_R = crate::FieldReader<u32, u32>;
        impl R {
            ///Bits 0:31 - RW1,TMR0 current count
            #[inline(always)]
            pub fn tmr0_count(&self) -> TMR0_COUNT_R {
                TMR0_COUNT_R::new(self.bits)
            }
        }
        ///RO, TMR0 current count
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [tmr0_count](index.html) module
        pub struct TMR0_COUNT_SPEC;
        impl crate::RegisterSpec for TMR0_COUNT_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [tmr0_count::R](R) reader structure
        impl crate::Readable for TMR0_COUNT_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets TMR0_COUNT to value 0
        impl crate::Resettable for TMR0_COUNT_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///TMR0_CNT_END (rw) register accessor: an alias for `Reg<TMR0_CNT_END_SPEC>`
    pub type TMR0_CNT_END = crate::Reg<tmr0_cnt_end::TMR0_CNT_END_SPEC>;
    ///RW, TMR0 end count value, only low 26 bit
    pub mod tmr0_cnt_end {
        ///Register `TMR0_CNT_END` reader
        pub struct R(crate::R<TMR0_CNT_END_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<TMR0_CNT_END_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<TMR0_CNT_END_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<TMR0_CNT_END_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `TMR0_CNT_END` writer
        pub struct W(crate::W<TMR0_CNT_END_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<TMR0_CNT_END_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<TMR0_CNT_END_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<TMR0_CNT_END_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `TMR0_CNT_END` reader - RW1,TMR0 end count value
        pub type TMR0_CNT_END_R = crate::FieldReader<u32, u32>;
        ///Field `TMR0_CNT_END` writer - RW1,TMR0 end count value
        pub type TMR0_CNT_END_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, TMR0_CNT_END_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - RW1,TMR0 end count value
            #[inline(always)]
            pub fn tmr0_cnt_end(&self) -> TMR0_CNT_END_R {
                TMR0_CNT_END_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW1,TMR0 end count value
            #[inline(always)]
            #[must_use]
            pub fn tmr0_cnt_end(&mut self) -> TMR0_CNT_END_W<0> {
                TMR0_CNT_END_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, TMR0 end count value, only low 26 bit
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [tmr0_cnt_end](index.html) module
        pub struct TMR0_CNT_END_SPEC;
        impl crate::RegisterSpec for TMR0_CNT_END_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [tmr0_cnt_end::R](R) reader structure
        impl crate::Readable for TMR0_CNT_END_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [tmr0_cnt_end::W](W) writer structure
        impl crate::Writable for TMR0_CNT_END_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets TMR0_CNT_END to value 0
        impl crate::Resettable for TMR0_CNT_END_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///TMR0_FIFO (r) register accessor: an alias for `Reg<TMR0_FIFO_SPEC>`
    pub type TMR0_FIFO = crate::Reg<tmr0_fifo::TMR0_FIFO_SPEC>;
    ///RO/WO, TMR0 FIFO register, only low 26 bit
    pub mod tmr0_fifo {
        ///Register `TMR0_FIFO` reader
        pub struct R(crate::R<TMR0_FIFO_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<TMR0_FIFO_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<TMR0_FIFO_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<TMR0_FIFO_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `TMR0_FIFO` reader - RW1,TMR0 FIFO register
        pub type TMR0_FIFO_R = crate::FieldReader<u32, u32>;
        impl R {
            ///Bits 0:31 - RW1,TMR0 FIFO register
            #[inline(always)]
            pub fn tmr0_fifo(&self) -> TMR0_FIFO_R {
                TMR0_FIFO_R::new(self.bits)
            }
        }
        ///RO/WO, TMR0 FIFO register, only low 26 bit
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [tmr0_fifo](index.html) module
        pub struct TMR0_FIFO_SPEC;
        impl crate::RegisterSpec for TMR0_FIFO_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [tmr0_fifo::R](R) reader structure
        impl crate::Readable for TMR0_FIFO_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets TMR0_FIFO to value 0
        impl crate::Resettable for TMR0_FIFO_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
}
///Timer1 register
pub struct TMR1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for TMR1 {}
impl TMR1 {
    ///Pointer to the register block
    pub const PTR: *const tmr1::RegisterBlock = 0x4000_2400 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const tmr1::RegisterBlock {
        Self::PTR
    }
}
impl Deref for TMR1 {
    type Target = tmr1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for TMR1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("TMR1").finish()
    }
}
///Timer1 register
pub mod tmr1 {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        ///0x00 - RW, TMR1 mode control
        pub tmr1_ctrl_mod: TMR1_CTRL_MOD,
        ///0x01 - RW, TMR1 DMA control
        pub tmr1_ctrl_dma: TMR1_CTRL_DMA,
        ///0x02 - RW, TMR1 interrupt enable
        pub tmr1_inter_en: TMR1_INTER_EN,
        _reserved3: [u8; 0x03],
        ///0x06 - RW1, TMR1 interrupt flag
        pub tmr1_int_flag: TMR1_INT_FLAG,
        ///0x07 - RO, TMR1 FIFO count status
        pub tmr1_fifo_count: TMR1_FIFO_COUNT,
        ///0x08 - RO, TMR1 current count
        pub tmr1_count: TMR1_COUNT,
        ///0x0c - RW, TMR1 end count value, only low 26 bit
        pub tmr1_cnt_end: TMR1_CNT_END,
        ///0x10 - RO, TMR1 FIFO register, only low 26 bit
        pub tmr1_fifo: TMR1_FIFO,
        ///0x14 - RO, TMR1 DMA current address
        pub tmr1_dma_now: TMR1_DMA_NOW,
        _reserved9: [u8; 0x02],
        ///0x18 - RW, TMR1 DMA begin address
        pub tmr1_dma_beg: TMR1_DMA_BEG,
        _reserved10: [u8; 0x02],
        ///0x1c - RW, TMR1 DMA end address
        pub tmr1_dma_end: TMR1_DMA_END,
    }
    ///TMR1_CTRL_MOD (rw) register accessor: an alias for `Reg<TMR1_CTRL_MOD_SPEC>`
    pub type TMR1_CTRL_MOD = crate::Reg<tmr1_ctrl_mod::TMR1_CTRL_MOD_SPEC>;
    ///RW, TMR1 mode control
    pub mod tmr1_ctrl_mod {
        ///Register `TMR1_CTRL_MOD` reader
        pub struct R(crate::R<TMR1_CTRL_MOD_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<TMR1_CTRL_MOD_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<TMR1_CTRL_MOD_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<TMR1_CTRL_MOD_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `TMR1_CTRL_MOD` writer
        pub struct W(crate::W<TMR1_CTRL_MOD_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<TMR1_CTRL_MOD_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<TMR1_CTRL_MOD_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<TMR1_CTRL_MOD_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `TMR_MODE_IN` reader - RW, timer in mode: 0=timer/PWM, 1=capture/count
        pub type TMR_MODE_IN_R = crate::BitReader<bool>;
        ///Field `TMR_MODE_IN` writer - RW, timer in mode: 0=timer/PWM, 1=capture/count
        pub type TMR_MODE_IN_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, TMR1_CTRL_MOD_SPEC, bool, O>;
        ///Field `TMR_ALL_CLEAR` reader - RW, force clear timer FIFO and count
        pub type TMR_ALL_CLEAR_R = crate::BitReader<bool>;
        ///Field `TMR_ALL_CLEAR` writer - RW, force clear timer FIFO and count
        pub type TMR_ALL_CLEAR_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, TMR1_CTRL_MOD_SPEC, bool, O>;
        ///Field `TMR_COUNT_EN` reader - RW, timer count enable
        pub type TMR_COUNT_EN_R = crate::BitReader<bool>;
        ///Field `TMR_COUNT_EN` writer - RW, timer count enable
        pub type TMR_COUNT_EN_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, TMR1_CTRL_MOD_SPEC, bool, O>;
        ///Field `TMR_OUT_EN` reader - RW, timer output enable
        pub type TMR_OUT_EN_R = crate::BitReader<bool>;
        ///Field `TMR_OUT_EN` writer - RW, timer output enable
        pub type TMR_OUT_EN_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, TMR1_CTRL_MOD_SPEC, bool, O>;
        ///Field `TMR_OUT_POLAR__RB_TMR_CAP_COUNT` reader - RW, timer PWM output polarity: 0=default low and high action, 1=default high and low action;RW, count sub-mode if RB_TMR_MODE_IN=1: 0=capture, 1=count
        pub type TMR_OUT_POLAR__RB_TMR_CAP_COUNT_R = crate::BitReader<bool>;
        ///Field `TMR_OUT_POLAR__RB_TMR_CAP_COUNT` writer - RW, timer PWM output polarity: 0=default low and high action, 1=default high and low action;RW, count sub-mode if RB_TMR_MODE_IN=1: 0=capture, 1=count
        pub type TMR_OUT_POLAR__RB_TMR_CAP_COUNT_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, TMR1_CTRL_MOD_SPEC, bool, O>;
        ///Field `TMR_PWM_REPEAT__RB_TMR_CAP_EDGE` reader - RW, timer PWM repeat mode: 00=1, 01=4, 10=8, 11-16;RW, timer capture edge mode: 00=disable, 01=edge change, 10=fall to fall, 11-rise to rise
        pub type TMR_PWM_REPEAT__RB_TMR_CAP_EDGE_R = crate::FieldReader<u8, u8>;
        ///Field `TMR_PWM_REPEAT__RB_TMR_CAP_EDGE` writer - RW, timer PWM repeat mode: 00=1, 01=4, 10=8, 11-16;RW, timer capture edge mode: 00=disable, 01=edge change, 10=fall to fall, 11-rise to rise
        pub type TMR_PWM_REPEAT__RB_TMR_CAP_EDGE_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, TMR1_CTRL_MOD_SPEC, u8, u8, 2, O>;
        impl R {
            ///Bit 0 - RW, timer in mode: 0=timer/PWM, 1=capture/count
            #[inline(always)]
            pub fn tmr_mode_in(&self) -> TMR_MODE_IN_R {
                TMR_MODE_IN_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RW, force clear timer FIFO and count
            #[inline(always)]
            pub fn tmr_all_clear(&self) -> TMR_ALL_CLEAR_R {
                TMR_ALL_CLEAR_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RW, timer count enable
            #[inline(always)]
            pub fn tmr_count_en(&self) -> TMR_COUNT_EN_R {
                TMR_COUNT_EN_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RW, timer output enable
            #[inline(always)]
            pub fn tmr_out_en(&self) -> TMR_OUT_EN_R {
                TMR_OUT_EN_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RW, timer PWM output polarity: 0=default low and high action, 1=default high and low action;RW, count sub-mode if RB_TMR_MODE_IN=1: 0=capture, 1=count
            #[inline(always)]
            pub fn tmr_out_polar__rb_tmr_cap_count(&self) -> TMR_OUT_POLAR__RB_TMR_CAP_COUNT_R {
                TMR_OUT_POLAR__RB_TMR_CAP_COUNT_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bits 6:7 - RW, timer PWM repeat mode: 00=1, 01=4, 10=8, 11-16;RW, timer capture edge mode: 00=disable, 01=edge change, 10=fall to fall, 11-rise to rise
            #[inline(always)]
            pub fn tmr_pwm_repeat__rb_tmr_cap_edge(&self) -> TMR_PWM_REPEAT__RB_TMR_CAP_EDGE_R {
                TMR_PWM_REPEAT__RB_TMR_CAP_EDGE_R::new((self.bits >> 6) & 3)
            }
        }
        impl W {
            ///Bit 0 - RW, timer in mode: 0=timer/PWM, 1=capture/count
            #[inline(always)]
            #[must_use]
            pub fn tmr_mode_in(&mut self) -> TMR_MODE_IN_W<0> {
                TMR_MODE_IN_W::new(self)
            }
            ///Bit 1 - RW, force clear timer FIFO and count
            #[inline(always)]
            #[must_use]
            pub fn tmr_all_clear(&mut self) -> TMR_ALL_CLEAR_W<1> {
                TMR_ALL_CLEAR_W::new(self)
            }
            ///Bit 2 - RW, timer count enable
            #[inline(always)]
            #[must_use]
            pub fn tmr_count_en(&mut self) -> TMR_COUNT_EN_W<2> {
                TMR_COUNT_EN_W::new(self)
            }
            ///Bit 3 - RW, timer output enable
            #[inline(always)]
            #[must_use]
            pub fn tmr_out_en(&mut self) -> TMR_OUT_EN_W<3> {
                TMR_OUT_EN_W::new(self)
            }
            ///Bit 4 - RW, timer PWM output polarity: 0=default low and high action, 1=default high and low action;RW, count sub-mode if RB_TMR_MODE_IN=1: 0=capture, 1=count
            #[inline(always)]
            #[must_use]
            pub fn tmr_out_polar__rb_tmr_cap_count(
                &mut self,
            ) -> TMR_OUT_POLAR__RB_TMR_CAP_COUNT_W<4> {
                TMR_OUT_POLAR__RB_TMR_CAP_COUNT_W::new(self)
            }
            ///Bits 6:7 - RW, timer PWM repeat mode: 00=1, 01=4, 10=8, 11-16;RW, timer capture edge mode: 00=disable, 01=edge change, 10=fall to fall, 11-rise to rise
            #[inline(always)]
            #[must_use]
            pub fn tmr_pwm_repeat__rb_tmr_cap_edge(
                &mut self,
            ) -> TMR_PWM_REPEAT__RB_TMR_CAP_EDGE_W<6> {
                TMR_PWM_REPEAT__RB_TMR_CAP_EDGE_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, TMR1 mode control
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [tmr1_ctrl_mod](index.html) module
        pub struct TMR1_CTRL_MOD_SPEC;
        impl crate::RegisterSpec for TMR1_CTRL_MOD_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [tmr1_ctrl_mod::R](R) reader structure
        impl crate::Readable for TMR1_CTRL_MOD_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [tmr1_ctrl_mod::W](W) writer structure
        impl crate::Writable for TMR1_CTRL_MOD_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets TMR1_CTRL_MOD to value 0x02
        impl crate::Resettable for TMR1_CTRL_MOD_SPEC {
            const RESET_VALUE: Self::Ux = 0x02;
        }
    }
    ///TMR1_CTRL_DMA (rw) register accessor: an alias for `Reg<TMR1_CTRL_DMA_SPEC>`
    pub type TMR1_CTRL_DMA = crate::Reg<tmr1_ctrl_dma::TMR1_CTRL_DMA_SPEC>;
    ///RW, TMR1 DMA control
    pub mod tmr1_ctrl_dma {
        ///Register `TMR1_CTRL_DMA` reader
        pub struct R(crate::R<TMR1_CTRL_DMA_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<TMR1_CTRL_DMA_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<TMR1_CTRL_DMA_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<TMR1_CTRL_DMA_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `TMR1_CTRL_DMA` writer
        pub struct W(crate::W<TMR1_CTRL_DMA_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<TMR1_CTRL_DMA_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<TMR1_CTRL_DMA_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<TMR1_CTRL_DMA_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `TMR_DMA_ENABLE` reader - RW, timer1/2 DMA enable
        pub type TMR_DMA_ENABLE_R = crate::BitReader<bool>;
        ///Field `TMR_DMA_ENABLE` writer - RW, timer1/2 DMA enable
        pub type TMR_DMA_ENABLE_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, TMR1_CTRL_DMA_SPEC, bool, O>;
        ///Field `TMR_DMA_LOOP` reader - RW, timer1/2 DMA address loop enable
        pub type TMR_DMA_LOOP_R = crate::BitReader<bool>;
        ///Field `TMR_DMA_LOOP` writer - RW, timer1/2 DMA address loop enable
        pub type TMR_DMA_LOOP_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, TMR1_CTRL_DMA_SPEC, bool, O>;
        impl R {
            ///Bit 0 - RW, timer1/2 DMA enable
            #[inline(always)]
            pub fn tmr_dma_enable(&self) -> TMR_DMA_ENABLE_R {
                TMR_DMA_ENABLE_R::new((self.bits & 1) != 0)
            }
            ///Bit 2 - RW, timer1/2 DMA address loop enable
            #[inline(always)]
            pub fn tmr_dma_loop(&self) -> TMR_DMA_LOOP_R {
                TMR_DMA_LOOP_R::new(((self.bits >> 2) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RW, timer1/2 DMA enable
            #[inline(always)]
            #[must_use]
            pub fn tmr_dma_enable(&mut self) -> TMR_DMA_ENABLE_W<0> {
                TMR_DMA_ENABLE_W::new(self)
            }
            ///Bit 2 - RW, timer1/2 DMA address loop enable
            #[inline(always)]
            #[must_use]
            pub fn tmr_dma_loop(&mut self) -> TMR_DMA_LOOP_W<2> {
                TMR_DMA_LOOP_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, TMR1 DMA control
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [tmr1_ctrl_dma](index.html) module
        pub struct TMR1_CTRL_DMA_SPEC;
        impl crate::RegisterSpec for TMR1_CTRL_DMA_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [tmr1_ctrl_dma::R](R) reader structure
        impl crate::Readable for TMR1_CTRL_DMA_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [tmr1_ctrl_dma::W](W) writer structure
        impl crate::Writable for TMR1_CTRL_DMA_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets TMR1_CTRL_DMA to value 0
        impl crate::Resettable for TMR1_CTRL_DMA_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///TMR1_INTER_EN (rw) register accessor: an alias for `Reg<TMR1_INTER_EN_SPEC>`
    pub type TMR1_INTER_EN = crate::Reg<tmr1_inter_en::TMR1_INTER_EN_SPEC>;
    ///RW, TMR1 interrupt enable
    pub mod tmr1_inter_en {
        ///Register `TMR1_INTER_EN` reader
        pub struct R(crate::R<TMR1_INTER_EN_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<TMR1_INTER_EN_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<TMR1_INTER_EN_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<TMR1_INTER_EN_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `TMR1_INTER_EN` writer
        pub struct W(crate::W<TMR1_INTER_EN_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<TMR1_INTER_EN_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<TMR1_INTER_EN_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<TMR1_INTER_EN_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `TMR_IE_CYC_END` reader - RW, enable interrupt for timer capture count timeout or PWM cycle end
        pub type TMR_IE_CYC_END_R = crate::BitReader<bool>;
        ///Field `TMR_IE_CYC_END` writer - RW, enable interrupt for timer capture count timeout or PWM cycle end
        pub type TMR_IE_CYC_END_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, TMR1_INTER_EN_SPEC, bool, O>;
        ///Field `TMR_IE_DATA_ACT` reader - RW, enable interrupt for timer capture input action or PWM trigger
        pub type TMR_IE_DATA_ACT_R = crate::BitReader<bool>;
        ///Field `TMR_IE_DATA_ACT` writer - RW, enable interrupt for timer capture input action or PWM trigger
        pub type TMR_IE_DATA_ACT_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, TMR1_INTER_EN_SPEC, bool, O>;
        ///Field `TMR_IE_FIFO_HF` reader - RW, enable interrupt for timer FIFO half (capture fifo >=4 or PWM fifo less than 3)
        pub type TMR_IE_FIFO_HF_R = crate::BitReader<bool>;
        ///Field `TMR_IE_FIFO_HF` writer - RW, enable interrupt for timer FIFO half (capture fifo >=4 or PWM fifo less than 3)
        pub type TMR_IE_FIFO_HF_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, TMR1_INTER_EN_SPEC, bool, O>;
        ///Field `TMR_IE_DMA_END` reader - RW, enable interrupt for timer1/2 DMA completion
        pub type TMR_IE_DMA_END_R = crate::BitReader<bool>;
        ///Field `TMR_IE_DMA_END` writer - RW, enable interrupt for timer1/2 DMA completion
        pub type TMR_IE_DMA_END_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, TMR1_INTER_EN_SPEC, bool, O>;
        ///Field `TMR_IE_FIFO_OV` reader - RW, enable interrupt for timer FIFO overflow
        pub type TMR_IE_FIFO_OV_R = crate::BitReader<bool>;
        ///Field `TMR_IE_FIFO_OV` writer - RW, enable interrupt for timer FIFO overflow
        pub type TMR_IE_FIFO_OV_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, TMR1_INTER_EN_SPEC, bool, O>;
        impl R {
            ///Bit 0 - RW, enable interrupt for timer capture count timeout or PWM cycle end
            #[inline(always)]
            pub fn tmr_ie_cyc_end(&self) -> TMR_IE_CYC_END_R {
                TMR_IE_CYC_END_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RW, enable interrupt for timer capture input action or PWM trigger
            #[inline(always)]
            pub fn tmr_ie_data_act(&self) -> TMR_IE_DATA_ACT_R {
                TMR_IE_DATA_ACT_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RW, enable interrupt for timer FIFO half (capture fifo >=4 or PWM fifo less than 3)
            #[inline(always)]
            pub fn tmr_ie_fifo_hf(&self) -> TMR_IE_FIFO_HF_R {
                TMR_IE_FIFO_HF_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RW, enable interrupt for timer1/2 DMA completion
            #[inline(always)]
            pub fn tmr_ie_dma_end(&self) -> TMR_IE_DMA_END_R {
                TMR_IE_DMA_END_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RW, enable interrupt for timer FIFO overflow
            #[inline(always)]
            pub fn tmr_ie_fifo_ov(&self) -> TMR_IE_FIFO_OV_R {
                TMR_IE_FIFO_OV_R::new(((self.bits >> 4) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RW, enable interrupt for timer capture count timeout or PWM cycle end
            #[inline(always)]
            #[must_use]
            pub fn tmr_ie_cyc_end(&mut self) -> TMR_IE_CYC_END_W<0> {
                TMR_IE_CYC_END_W::new(self)
            }
            ///Bit 1 - RW, enable interrupt for timer capture input action or PWM trigger
            #[inline(always)]
            #[must_use]
            pub fn tmr_ie_data_act(&mut self) -> TMR_IE_DATA_ACT_W<1> {
                TMR_IE_DATA_ACT_W::new(self)
            }
            ///Bit 2 - RW, enable interrupt for timer FIFO half (capture fifo >=4 or PWM fifo less than 3)
            #[inline(always)]
            #[must_use]
            pub fn tmr_ie_fifo_hf(&mut self) -> TMR_IE_FIFO_HF_W<2> {
                TMR_IE_FIFO_HF_W::new(self)
            }
            ///Bit 3 - RW, enable interrupt for timer1/2 DMA completion
            #[inline(always)]
            #[must_use]
            pub fn tmr_ie_dma_end(&mut self) -> TMR_IE_DMA_END_W<3> {
                TMR_IE_DMA_END_W::new(self)
            }
            ///Bit 4 - RW, enable interrupt for timer FIFO overflow
            #[inline(always)]
            #[must_use]
            pub fn tmr_ie_fifo_ov(&mut self) -> TMR_IE_FIFO_OV_W<4> {
                TMR_IE_FIFO_OV_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, TMR1 interrupt enable
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [tmr1_inter_en](index.html) module
        pub struct TMR1_INTER_EN_SPEC;
        impl crate::RegisterSpec for TMR1_INTER_EN_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [tmr1_inter_en::R](R) reader structure
        impl crate::Readable for TMR1_INTER_EN_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [tmr1_inter_en::W](W) writer structure
        impl crate::Writable for TMR1_INTER_EN_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets TMR1_INTER_EN to value 0
        impl crate::Resettable for TMR1_INTER_EN_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///TMR1_INT_FLAG (rw) register accessor: an alias for `Reg<TMR1_INT_FLAG_SPEC>`
    pub type TMR1_INT_FLAG = crate::Reg<tmr1_int_flag::TMR1_INT_FLAG_SPEC>;
    ///RW1, TMR1 interrupt flag
    pub mod tmr1_int_flag {
        ///Register `TMR1_INT_FLAG` reader
        pub struct R(crate::R<TMR1_INT_FLAG_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<TMR1_INT_FLAG_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<TMR1_INT_FLAG_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<TMR1_INT_FLAG_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `TMR1_INT_FLAG` writer
        pub struct W(crate::W<TMR1_INT_FLAG_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<TMR1_INT_FLAG_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<TMR1_INT_FLAG_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<TMR1_INT_FLAG_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `TMR_IF_CYC_END` reader - RW1, interrupt flag for timer capture count timeout or PWM cycle end
        pub type TMR_IF_CYC_END_R = crate::BitReader<bool>;
        ///Field `TMR_IF_CYC_END` writer - RW1, interrupt flag for timer capture count timeout or PWM cycle end
        pub type TMR_IF_CYC_END_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, TMR1_INT_FLAG_SPEC, bool, O>;
        ///Field `TMR_IF_DATA_ACT` reader - RW1, interrupt flag for timer capture input action or PWM trigger
        pub type TMR_IF_DATA_ACT_R = crate::BitReader<bool>;
        ///Field `TMR_IF_DATA_ACT` writer - RW1, interrupt flag for timer capture input action or PWM trigger
        pub type TMR_IF_DATA_ACT_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, TMR1_INT_FLAG_SPEC, bool, O>;
        ///Field `TMR_IF_FIFO_HF` reader - RW1, interrupt flag for timer FIFO half (capture fifo >=4 or PWM fifo less than 3
        pub type TMR_IF_FIFO_HF_R = crate::BitReader<bool>;
        ///Field `TMR_IF_FIFO_HF` writer - RW1, interrupt flag for timer FIFO half (capture fifo >=4 or PWM fifo less than 3
        pub type TMR_IF_FIFO_HF_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, TMR1_INT_FLAG_SPEC, bool, O>;
        ///Field `TMR_IF_DMA_END` reader - RW1, interrupt flag for timer1/2 DMA completion
        pub type TMR_IF_DMA_END_R = crate::BitReader<bool>;
        ///Field `TMR_IF_DMA_END` writer - RW1, interrupt flag for timer1/2 DMA completion
        pub type TMR_IF_DMA_END_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, TMR1_INT_FLAG_SPEC, bool, O>;
        ///Field `TMR_IF_FIFO_OV` reader - RW1, interrupt flag for timer FIFO overflow
        pub type TMR_IF_FIFO_OV_R = crate::BitReader<bool>;
        ///Field `TMR_IF_FIFO_OV` writer - RW1, interrupt flag for timer FIFO overflow
        pub type TMR_IF_FIFO_OV_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, TMR1_INT_FLAG_SPEC, bool, O>;
        impl R {
            ///Bit 0 - RW1, interrupt flag for timer capture count timeout or PWM cycle end
            #[inline(always)]
            pub fn tmr_if_cyc_end(&self) -> TMR_IF_CYC_END_R {
                TMR_IF_CYC_END_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RW1, interrupt flag for timer capture input action or PWM trigger
            #[inline(always)]
            pub fn tmr_if_data_act(&self) -> TMR_IF_DATA_ACT_R {
                TMR_IF_DATA_ACT_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RW1, interrupt flag for timer FIFO half (capture fifo >=4 or PWM fifo less than 3
            #[inline(always)]
            pub fn tmr_if_fifo_hf(&self) -> TMR_IF_FIFO_HF_R {
                TMR_IF_FIFO_HF_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RW1, interrupt flag for timer1/2 DMA completion
            #[inline(always)]
            pub fn tmr_if_dma_end(&self) -> TMR_IF_DMA_END_R {
                TMR_IF_DMA_END_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RW1, interrupt flag for timer FIFO overflow
            #[inline(always)]
            pub fn tmr_if_fifo_ov(&self) -> TMR_IF_FIFO_OV_R {
                TMR_IF_FIFO_OV_R::new(((self.bits >> 4) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RW1, interrupt flag for timer capture count timeout or PWM cycle end
            #[inline(always)]
            #[must_use]
            pub fn tmr_if_cyc_end(&mut self) -> TMR_IF_CYC_END_W<0> {
                TMR_IF_CYC_END_W::new(self)
            }
            ///Bit 1 - RW1, interrupt flag for timer capture input action or PWM trigger
            #[inline(always)]
            #[must_use]
            pub fn tmr_if_data_act(&mut self) -> TMR_IF_DATA_ACT_W<1> {
                TMR_IF_DATA_ACT_W::new(self)
            }
            ///Bit 2 - RW1, interrupt flag for timer FIFO half (capture fifo >=4 or PWM fifo less than 3
            #[inline(always)]
            #[must_use]
            pub fn tmr_if_fifo_hf(&mut self) -> TMR_IF_FIFO_HF_W<2> {
                TMR_IF_FIFO_HF_W::new(self)
            }
            ///Bit 3 - RW1, interrupt flag for timer1/2 DMA completion
            #[inline(always)]
            #[must_use]
            pub fn tmr_if_dma_end(&mut self) -> TMR_IF_DMA_END_W<3> {
                TMR_IF_DMA_END_W::new(self)
            }
            ///Bit 4 - RW1, interrupt flag for timer FIFO overflow
            #[inline(always)]
            #[must_use]
            pub fn tmr_if_fifo_ov(&mut self) -> TMR_IF_FIFO_OV_W<4> {
                TMR_IF_FIFO_OV_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW1, TMR1 interrupt flag
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [tmr1_int_flag](index.html) module
        pub struct TMR1_INT_FLAG_SPEC;
        impl crate::RegisterSpec for TMR1_INT_FLAG_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [tmr1_int_flag::R](R) reader structure
        impl crate::Readable for TMR1_INT_FLAG_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [tmr1_int_flag::W](W) writer structure
        impl crate::Writable for TMR1_INT_FLAG_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets TMR1_INT_FLAG to value 0
        impl crate::Resettable for TMR1_INT_FLAG_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///TMR1_FIFO_COUNT (r) register accessor: an alias for `Reg<TMR1_FIFO_COUNT_SPEC>`
    pub type TMR1_FIFO_COUNT = crate::Reg<tmr1_fifo_count::TMR1_FIFO_COUNT_SPEC>;
    ///RO, TMR1 FIFO count status
    pub mod tmr1_fifo_count {
        ///Register `TMR1_FIFO_COUNT` reader
        pub struct R(crate::R<TMR1_FIFO_COUNT_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<TMR1_FIFO_COUNT_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<TMR1_FIFO_COUNT_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<TMR1_FIFO_COUNT_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `TMR1_FIFO_COUNT` reader - RW1, TMR1 FIFO count status
        pub type TMR1_FIFO_COUNT_R = crate::FieldReader<u8, u8>;
        impl R {
            ///Bits 0:7 - RW1, TMR1 FIFO count status
            #[inline(always)]
            pub fn tmr1_fifo_count(&self) -> TMR1_FIFO_COUNT_R {
                TMR1_FIFO_COUNT_R::new(self.bits)
            }
        }
        ///RO, TMR1 FIFO count status
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [tmr1_fifo_count](index.html) module
        pub struct TMR1_FIFO_COUNT_SPEC;
        impl crate::RegisterSpec for TMR1_FIFO_COUNT_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [tmr1_fifo_count::R](R) reader structure
        impl crate::Readable for TMR1_FIFO_COUNT_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets TMR1_FIFO_COUNT to value 0
        impl crate::Resettable for TMR1_FIFO_COUNT_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///TMR1_COUNT (r) register accessor: an alias for `Reg<TMR1_COUNT_SPEC>`
    pub type TMR1_COUNT = crate::Reg<tmr1_count::TMR1_COUNT_SPEC>;
    ///RO, TMR1 current count
    pub mod tmr1_count {
        ///Register `TMR1_COUNT` reader
        pub struct R(crate::R<TMR1_COUNT_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<TMR1_COUNT_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<TMR1_COUNT_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<TMR1_COUNT_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `TMR1_COUNT` reader - RW1,TMR1 current count
        pub type TMR1_COUNT_R = crate::FieldReader<u32, u32>;
        impl R {
            ///Bits 0:31 - RW1,TMR1 current count
            #[inline(always)]
            pub fn tmr1_count(&self) -> TMR1_COUNT_R {
                TMR1_COUNT_R::new(self.bits)
            }
        }
        ///RO, TMR1 current count
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [tmr1_count](index.html) module
        pub struct TMR1_COUNT_SPEC;
        impl crate::RegisterSpec for TMR1_COUNT_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [tmr1_count::R](R) reader structure
        impl crate::Readable for TMR1_COUNT_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets TMR1_COUNT to value 0
        impl crate::Resettable for TMR1_COUNT_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///TMR1_CNT_END (rw) register accessor: an alias for `Reg<TMR1_CNT_END_SPEC>`
    pub type TMR1_CNT_END = crate::Reg<tmr1_cnt_end::TMR1_CNT_END_SPEC>;
    ///RW, TMR1 end count value, only low 26 bit
    pub mod tmr1_cnt_end {
        ///Register `TMR1_CNT_END` reader
        pub struct R(crate::R<TMR1_CNT_END_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<TMR1_CNT_END_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<TMR1_CNT_END_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<TMR1_CNT_END_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `TMR1_CNT_END` writer
        pub struct W(crate::W<TMR1_CNT_END_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<TMR1_CNT_END_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<TMR1_CNT_END_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<TMR1_CNT_END_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `TMR1_CNT_END` reader - RW1,TMR1 end count value,
        pub type TMR1_CNT_END_R = crate::FieldReader<u32, u32>;
        ///Field `TMR1_CNT_END` writer - RW1,TMR1 end count value,
        pub type TMR1_CNT_END_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, TMR1_CNT_END_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - RW1,TMR1 end count value,
            #[inline(always)]
            pub fn tmr1_cnt_end(&self) -> TMR1_CNT_END_R {
                TMR1_CNT_END_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW1,TMR1 end count value,
            #[inline(always)]
            #[must_use]
            pub fn tmr1_cnt_end(&mut self) -> TMR1_CNT_END_W<0> {
                TMR1_CNT_END_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, TMR1 end count value, only low 26 bit
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [tmr1_cnt_end](index.html) module
        pub struct TMR1_CNT_END_SPEC;
        impl crate::RegisterSpec for TMR1_CNT_END_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [tmr1_cnt_end::R](R) reader structure
        impl crate::Readable for TMR1_CNT_END_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [tmr1_cnt_end::W](W) writer structure
        impl crate::Writable for TMR1_CNT_END_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets TMR1_CNT_END to value 0
        impl crate::Resettable for TMR1_CNT_END_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///TMR1_FIFO (r) register accessor: an alias for `Reg<TMR1_FIFO_SPEC>`
    pub type TMR1_FIFO = crate::Reg<tmr1_fifo::TMR1_FIFO_SPEC>;
    ///RO, TMR1 FIFO register, only low 26 bit
    pub mod tmr1_fifo {
        ///Register `TMR1_FIFO` reader
        pub struct R(crate::R<TMR1_FIFO_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<TMR1_FIFO_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<TMR1_FIFO_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<TMR1_FIFO_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `TMR1_FIFO` reader - RW1,TMR1 FIFO register
        pub type TMR1_FIFO_R = crate::FieldReader<u32, u32>;
        impl R {
            ///Bits 0:31 - RW1,TMR1 FIFO register
            #[inline(always)]
            pub fn tmr1_fifo(&self) -> TMR1_FIFO_R {
                TMR1_FIFO_R::new(self.bits)
            }
        }
        ///RO, TMR1 FIFO register, only low 26 bit
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [tmr1_fifo](index.html) module
        pub struct TMR1_FIFO_SPEC;
        impl crate::RegisterSpec for TMR1_FIFO_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [tmr1_fifo::R](R) reader structure
        impl crate::Readable for TMR1_FIFO_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets TMR1_FIFO to value 0
        impl crate::Resettable for TMR1_FIFO_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///TMR1_DMA_NOW (r) register accessor: an alias for `Reg<TMR1_DMA_NOW_SPEC>`
    pub type TMR1_DMA_NOW = crate::Reg<tmr1_dma_now::TMR1_DMA_NOW_SPEC>;
    ///RO, TMR1 DMA current address
    pub mod tmr1_dma_now {
        ///Register `TMR1_DMA_NOW` reader
        pub struct R(crate::R<TMR1_DMA_NOW_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<TMR1_DMA_NOW_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<TMR1_DMA_NOW_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<TMR1_DMA_NOW_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `TMR1_DMA_NOW` reader - RW1,TMR1 FIFO register
        pub type TMR1_DMA_NOW_R = crate::FieldReader<u16, u16>;
        impl R {
            ///Bits 0:15 - RW1,TMR1 FIFO register
            #[inline(always)]
            pub fn tmr1_dma_now(&self) -> TMR1_DMA_NOW_R {
                TMR1_DMA_NOW_R::new(self.bits)
            }
        }
        ///RO, TMR1 DMA current address
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [tmr1_dma_now](index.html) module
        pub struct TMR1_DMA_NOW_SPEC;
        impl crate::RegisterSpec for TMR1_DMA_NOW_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [tmr1_dma_now::R](R) reader structure
        impl crate::Readable for TMR1_DMA_NOW_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets TMR1_DMA_NOW to value 0
        impl crate::Resettable for TMR1_DMA_NOW_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///TMR1_DMA_BEG (rw) register accessor: an alias for `Reg<TMR1_DMA_BEG_SPEC>`
    pub type TMR1_DMA_BEG = crate::Reg<tmr1_dma_beg::TMR1_DMA_BEG_SPEC>;
    ///RW, TMR1 DMA begin address
    pub mod tmr1_dma_beg {
        ///Register `TMR1_DMA_BEG` reader
        pub struct R(crate::R<TMR1_DMA_BEG_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<TMR1_DMA_BEG_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<TMR1_DMA_BEG_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<TMR1_DMA_BEG_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `TMR1_DMA_BEG` writer
        pub struct W(crate::W<TMR1_DMA_BEG_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<TMR1_DMA_BEG_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<TMR1_DMA_BEG_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<TMR1_DMA_BEG_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `TMR1_DMA_BEG` reader - RW1,TMR1 FIFO register
        pub type TMR1_DMA_BEG_R = crate::FieldReader<u16, u16>;
        ///Field `TMR1_DMA_BEG` writer - RW1,TMR1 FIFO register
        pub type TMR1_DMA_BEG_W<'a, const O: u8> =
            crate::FieldWriter<'a, u16, TMR1_DMA_BEG_SPEC, u16, u16, 16, O>;
        impl R {
            ///Bits 0:15 - RW1,TMR1 FIFO register
            #[inline(always)]
            pub fn tmr1_dma_beg(&self) -> TMR1_DMA_BEG_R {
                TMR1_DMA_BEG_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - RW1,TMR1 FIFO register
            #[inline(always)]
            #[must_use]
            pub fn tmr1_dma_beg(&mut self) -> TMR1_DMA_BEG_W<0> {
                TMR1_DMA_BEG_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, TMR1 DMA begin address
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [tmr1_dma_beg](index.html) module
        pub struct TMR1_DMA_BEG_SPEC;
        impl crate::RegisterSpec for TMR1_DMA_BEG_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [tmr1_dma_beg::R](R) reader structure
        impl crate::Readable for TMR1_DMA_BEG_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [tmr1_dma_beg::W](W) writer structure
        impl crate::Writable for TMR1_DMA_BEG_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets TMR1_DMA_BEG to value 0
        impl crate::Resettable for TMR1_DMA_BEG_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///TMR1_DMA_END (rw) register accessor: an alias for `Reg<TMR1_DMA_END_SPEC>`
    pub type TMR1_DMA_END = crate::Reg<tmr1_dma_end::TMR1_DMA_END_SPEC>;
    ///RW, TMR1 DMA end address
    pub mod tmr1_dma_end {
        ///Register `TMR1_DMA_END` reader
        pub struct R(crate::R<TMR1_DMA_END_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<TMR1_DMA_END_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<TMR1_DMA_END_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<TMR1_DMA_END_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `TMR1_DMA_END` writer
        pub struct W(crate::W<TMR1_DMA_END_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<TMR1_DMA_END_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<TMR1_DMA_END_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<TMR1_DMA_END_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `TMR1_DMA_END` reader - RW1,TMR1 FIFO register
        pub type TMR1_DMA_END_R = crate::FieldReader<u16, u16>;
        ///Field `TMR1_DMA_END` writer - RW1,TMR1 FIFO register
        pub type TMR1_DMA_END_W<'a, const O: u8> =
            crate::FieldWriter<'a, u16, TMR1_DMA_END_SPEC, u16, u16, 16, O>;
        impl R {
            ///Bits 0:15 - RW1,TMR1 FIFO register
            #[inline(always)]
            pub fn tmr1_dma_end(&self) -> TMR1_DMA_END_R {
                TMR1_DMA_END_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - RW1,TMR1 FIFO register
            #[inline(always)]
            #[must_use]
            pub fn tmr1_dma_end(&mut self) -> TMR1_DMA_END_W<0> {
                TMR1_DMA_END_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, TMR1 DMA end address
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [tmr1_dma_end](index.html) module
        pub struct TMR1_DMA_END_SPEC;
        impl crate::RegisterSpec for TMR1_DMA_END_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [tmr1_dma_end::R](R) reader structure
        impl crate::Readable for TMR1_DMA_END_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [tmr1_dma_end::W](W) writer structure
        impl crate::Writable for TMR1_DMA_END_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets TMR1_DMA_END to value 0
        impl crate::Resettable for TMR1_DMA_END_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
}
///Timer2 register
pub struct TMR2 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for TMR2 {}
impl TMR2 {
    ///Pointer to the register block
    pub const PTR: *const tmr2::RegisterBlock = 0x4000_2800 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const tmr2::RegisterBlock {
        Self::PTR
    }
}
impl Deref for TMR2 {
    type Target = tmr2::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for TMR2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("TMR2").finish()
    }
}
///Timer2 register
pub mod tmr2 {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        ///0x00 - RW, TMR2 mode control
        pub ctrl_mod: CTRL_MOD,
        ///0x01 - RW, TMR2 DMA control
        pub ctrl_dma: CTRL_DMA,
        ///0x02 - RW, TMR2 interrupt enable
        pub inter_en: INTER_EN,
        _reserved3: [u8; 0x03],
        ///0x06 - RW1, TMR2 interrupt flag
        pub int_flag: INT_FLAG,
        ///0x07 - RO, TMR2 FIFO count status
        pub fifo_count: FIFO_COUNT,
        ///0x08 - RO, TMR2 current count
        pub count: COUNT,
        ///0x0c - RW, TMR2 end count value, only low 26 bit
        pub cnt_end: CNT_END,
        ///0x10 - RO, TMR2 FIFO register, only low 26 bit
        pub fifo: FIFO,
        ///0x14 - RO, TMR2 DMA current address
        pub dma_now: DMA_NOW,
        _reserved9: [u8; 0x02],
        ///0x18 - RW, TMR2 DMA begin address
        pub dma_beg: DMA_BEG,
        _reserved10: [u8; 0x02],
        ///0x1c - RW, TMR2 DMA end address
        pub dma_end: DMA_END,
    }
    ///CTRL_MOD (rw) register accessor: an alias for `Reg<CTRL_MOD_SPEC>`
    pub type CTRL_MOD = crate::Reg<ctrl_mod::CTRL_MOD_SPEC>;
    ///RW, TMR2 mode control
    pub mod ctrl_mod {
        ///Register `CTRL_MOD` reader
        pub struct R(crate::R<CTRL_MOD_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CTRL_MOD_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<CTRL_MOD_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<CTRL_MOD_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CTRL_MOD` writer
        pub struct W(crate::W<CTRL_MOD_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CTRL_MOD_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<CTRL_MOD_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<CTRL_MOD_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `TMR_MODE_IN` reader - RW, timer in mode: 0=timer_PWM, 1=capture_count
        pub type TMR_MODE_IN_R = crate::BitReader<bool>;
        ///Field `TMR_MODE_IN` writer - RW, timer in mode: 0=timer_PWM, 1=capture_count
        pub type TMR_MODE_IN_W<'a, const O: u8> = crate::BitWriter<'a, u8, CTRL_MOD_SPEC, bool, O>;
        ///Field `TMR_ALL_CLEAR` reader - RW, force clear timer FIFO and count
        pub type TMR_ALL_CLEAR_R = crate::BitReader<bool>;
        ///Field `TMR_ALL_CLEAR` writer - RW, force clear timer FIFO and count
        pub type TMR_ALL_CLEAR_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, CTRL_MOD_SPEC, bool, O>;
        ///Field `TMR_COUNT_EN` reader - RW, timer count enable
        pub type TMR_COUNT_EN_R = crate::BitReader<bool>;
        ///Field `TMR_COUNT_EN` writer - RW, timer count enable
        pub type TMR_COUNT_EN_W<'a, const O: u8> = crate::BitWriter<'a, u8, CTRL_MOD_SPEC, bool, O>;
        ///Field `TMR_OUT_EN` reader - RW, timer output enable
        pub type TMR_OUT_EN_R = crate::BitReader<bool>;
        ///Field `TMR_OUT_EN` writer - RW, timer output enable
        pub type TMR_OUT_EN_W<'a, const O: u8> = crate::BitWriter<'a, u8, CTRL_MOD_SPEC, bool, O>;
        ///Field `TMR_OUT_POLAR__RB_TMR_CAP_COUNT` reader - RW, timer PWM output polarity: 0=default low and high action, 1=default high and low action;RW, count sub-mode if RB_TMR_MODE_IN=1: 0=capture, 1=count
        pub type TMR_OUT_POLAR__RB_TMR_CAP_COUNT_R = crate::BitReader<bool>;
        ///Field `TMR_OUT_POLAR__RB_TMR_CAP_COUNT` writer - RW, timer PWM output polarity: 0=default low and high action, 1=default high and low action;RW, count sub-mode if RB_TMR_MODE_IN=1: 0=capture, 1=count
        pub type TMR_OUT_POLAR__RB_TMR_CAP_COUNT_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, CTRL_MOD_SPEC, bool, O>;
        ///Field `TMR_PWM_REPEAT__RB_TMR_CAP_EDGE` reader - RW, timer PWM repeat mode: 00=1, 01=4, 10=8, 11-16;RW, timer capture edge mode: 00=disable, 01=edge change, 10=fall to fall, 11-rise to rise
        pub type TMR_PWM_REPEAT__RB_TMR_CAP_EDGE_R = crate::FieldReader<u8, u8>;
        ///Field `TMR_PWM_REPEAT__RB_TMR_CAP_EDGE` writer - RW, timer PWM repeat mode: 00=1, 01=4, 10=8, 11-16;RW, timer capture edge mode: 00=disable, 01=edge change, 10=fall to fall, 11-rise to rise
        pub type TMR_PWM_REPEAT__RB_TMR_CAP_EDGE_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, CTRL_MOD_SPEC, u8, u8, 2, O>;
        impl R {
            ///Bit 0 - RW, timer in mode: 0=timer_PWM, 1=capture_count
            #[inline(always)]
            pub fn tmr_mode_in(&self) -> TMR_MODE_IN_R {
                TMR_MODE_IN_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RW, force clear timer FIFO and count
            #[inline(always)]
            pub fn tmr_all_clear(&self) -> TMR_ALL_CLEAR_R {
                TMR_ALL_CLEAR_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RW, timer count enable
            #[inline(always)]
            pub fn tmr_count_en(&self) -> TMR_COUNT_EN_R {
                TMR_COUNT_EN_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RW, timer output enable
            #[inline(always)]
            pub fn tmr_out_en(&self) -> TMR_OUT_EN_R {
                TMR_OUT_EN_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RW, timer PWM output polarity: 0=default low and high action, 1=default high and low action;RW, count sub-mode if RB_TMR_MODE_IN=1: 0=capture, 1=count
            #[inline(always)]
            pub fn tmr_out_polar__rb_tmr_cap_count(&self) -> TMR_OUT_POLAR__RB_TMR_CAP_COUNT_R {
                TMR_OUT_POLAR__RB_TMR_CAP_COUNT_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bits 6:7 - RW, timer PWM repeat mode: 00=1, 01=4, 10=8, 11-16;RW, timer capture edge mode: 00=disable, 01=edge change, 10=fall to fall, 11-rise to rise
            #[inline(always)]
            pub fn tmr_pwm_repeat__rb_tmr_cap_edge(&self) -> TMR_PWM_REPEAT__RB_TMR_CAP_EDGE_R {
                TMR_PWM_REPEAT__RB_TMR_CAP_EDGE_R::new((self.bits >> 6) & 3)
            }
        }
        impl W {
            ///Bit 0 - RW, timer in mode: 0=timer_PWM, 1=capture_count
            #[inline(always)]
            #[must_use]
            pub fn tmr_mode_in(&mut self) -> TMR_MODE_IN_W<0> {
                TMR_MODE_IN_W::new(self)
            }
            ///Bit 1 - RW, force clear timer FIFO and count
            #[inline(always)]
            #[must_use]
            pub fn tmr_all_clear(&mut self) -> TMR_ALL_CLEAR_W<1> {
                TMR_ALL_CLEAR_W::new(self)
            }
            ///Bit 2 - RW, timer count enable
            #[inline(always)]
            #[must_use]
            pub fn tmr_count_en(&mut self) -> TMR_COUNT_EN_W<2> {
                TMR_COUNT_EN_W::new(self)
            }
            ///Bit 3 - RW, timer output enable
            #[inline(always)]
            #[must_use]
            pub fn tmr_out_en(&mut self) -> TMR_OUT_EN_W<3> {
                TMR_OUT_EN_W::new(self)
            }
            ///Bit 4 - RW, timer PWM output polarity: 0=default low and high action, 1=default high and low action;RW, count sub-mode if RB_TMR_MODE_IN=1: 0=capture, 1=count
            #[inline(always)]
            #[must_use]
            pub fn tmr_out_polar__rb_tmr_cap_count(
                &mut self,
            ) -> TMR_OUT_POLAR__RB_TMR_CAP_COUNT_W<4> {
                TMR_OUT_POLAR__RB_TMR_CAP_COUNT_W::new(self)
            }
            ///Bits 6:7 - RW, timer PWM repeat mode: 00=1, 01=4, 10=8, 11-16;RW, timer capture edge mode: 00=disable, 01=edge change, 10=fall to fall, 11-rise to rise
            #[inline(always)]
            #[must_use]
            pub fn tmr_pwm_repeat__rb_tmr_cap_edge(
                &mut self,
            ) -> TMR_PWM_REPEAT__RB_TMR_CAP_EDGE_W<6> {
                TMR_PWM_REPEAT__RB_TMR_CAP_EDGE_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, TMR2 mode control
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [ctrl_mod](index.html) module
        pub struct CTRL_MOD_SPEC;
        impl crate::RegisterSpec for CTRL_MOD_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [ctrl_mod::R](R) reader structure
        impl crate::Readable for CTRL_MOD_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [ctrl_mod::W](W) writer structure
        impl crate::Writable for CTRL_MOD_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets CTRL_MOD to value 0x02
        impl crate::Resettable for CTRL_MOD_SPEC {
            const RESET_VALUE: Self::Ux = 0x02;
        }
    }
    ///CTRL_DMA (rw) register accessor: an alias for `Reg<CTRL_DMA_SPEC>`
    pub type CTRL_DMA = crate::Reg<ctrl_dma::CTRL_DMA_SPEC>;
    ///RW, TMR2 DMA control
    pub mod ctrl_dma {
        ///Register `CTRL_DMA` reader
        pub struct R(crate::R<CTRL_DMA_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CTRL_DMA_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<CTRL_DMA_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<CTRL_DMA_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CTRL_DMA` writer
        pub struct W(crate::W<CTRL_DMA_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CTRL_DMA_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<CTRL_DMA_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<CTRL_DMA_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `TMR_DMA_ENABLE` reader - RW, timer1_2 DMA enable
        pub type TMR_DMA_ENABLE_R = crate::BitReader<bool>;
        ///Field `TMR_DMA_ENABLE` writer - RW, timer1_2 DMA enable
        pub type TMR_DMA_ENABLE_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, CTRL_DMA_SPEC, bool, O>;
        ///Field `TMR_DMA_LOOP` reader - RW, timer1_2 DMA address loop enable
        pub type TMR_DMA_LOOP_R = crate::BitReader<bool>;
        ///Field `TMR_DMA_LOOP` writer - RW, timer1_2 DMA address loop enable
        pub type TMR_DMA_LOOP_W<'a, const O: u8> = crate::BitWriter<'a, u8, CTRL_DMA_SPEC, bool, O>;
        impl R {
            ///Bit 0 - RW, timer1_2 DMA enable
            #[inline(always)]
            pub fn tmr_dma_enable(&self) -> TMR_DMA_ENABLE_R {
                TMR_DMA_ENABLE_R::new((self.bits & 1) != 0)
            }
            ///Bit 2 - RW, timer1_2 DMA address loop enable
            #[inline(always)]
            pub fn tmr_dma_loop(&self) -> TMR_DMA_LOOP_R {
                TMR_DMA_LOOP_R::new(((self.bits >> 2) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RW, timer1_2 DMA enable
            #[inline(always)]
            #[must_use]
            pub fn tmr_dma_enable(&mut self) -> TMR_DMA_ENABLE_W<0> {
                TMR_DMA_ENABLE_W::new(self)
            }
            ///Bit 2 - RW, timer1_2 DMA address loop enable
            #[inline(always)]
            #[must_use]
            pub fn tmr_dma_loop(&mut self) -> TMR_DMA_LOOP_W<2> {
                TMR_DMA_LOOP_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, TMR2 DMA control
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [ctrl_dma](index.html) module
        pub struct CTRL_DMA_SPEC;
        impl crate::RegisterSpec for CTRL_DMA_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [ctrl_dma::R](R) reader structure
        impl crate::Readable for CTRL_DMA_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [ctrl_dma::W](W) writer structure
        impl crate::Writable for CTRL_DMA_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets CTRL_DMA to value 0
        impl crate::Resettable for CTRL_DMA_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///INTER_EN (rw) register accessor: an alias for `Reg<INTER_EN_SPEC>`
    pub type INTER_EN = crate::Reg<inter_en::INTER_EN_SPEC>;
    ///RW, TMR2 interrupt enable
    pub mod inter_en {
        ///Register `INTER_EN` reader
        pub struct R(crate::R<INTER_EN_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<INTER_EN_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<INTER_EN_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<INTER_EN_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `INTER_EN` writer
        pub struct W(crate::W<INTER_EN_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<INTER_EN_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<INTER_EN_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<INTER_EN_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `TMR_IE_CYC_END` reader - RW, enable interrupt for timer capture count timeout or PWM cycle end
        pub type TMR_IE_CYC_END_R = crate::BitReader<bool>;
        ///Field `TMR_IE_CYC_END` writer - RW, enable interrupt for timer capture count timeout or PWM cycle end
        pub type TMR_IE_CYC_END_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, INTER_EN_SPEC, bool, O>;
        ///Field `TMR_IE_DATA_ACT` reader - RW, enable interrupt for timer capture input action or PWM trigger
        pub type TMR_IE_DATA_ACT_R = crate::BitReader<bool>;
        ///Field `TMR_IE_DATA_ACT` writer - RW, enable interrupt for timer capture input action or PWM trigger
        pub type TMR_IE_DATA_ACT_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, INTER_EN_SPEC, bool, O>;
        ///Field `TMR_IE_FIFO_HF` reader - RW, enable interrupt for timer FIFO half (capture fifo >=4 or PWM fifo less than 3)
        pub type TMR_IE_FIFO_HF_R = crate::BitReader<bool>;
        ///Field `TMR_IE_FIFO_HF` writer - RW, enable interrupt for timer FIFO half (capture fifo >=4 or PWM fifo less than 3)
        pub type TMR_IE_FIFO_HF_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, INTER_EN_SPEC, bool, O>;
        ///Field `TMR_IE_DMA_END` reader - RW, enable interrupt for timer1/2 DMA completion
        pub type TMR_IE_DMA_END_R = crate::BitReader<bool>;
        ///Field `TMR_IE_DMA_END` writer - RW, enable interrupt for timer1/2 DMA completion
        pub type TMR_IE_DMA_END_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, INTER_EN_SPEC, bool, O>;
        ///Field `TMR_IE_FIFO_OV` reader - RW, enable interrupt for timer FIFO overflow
        pub type TMR_IE_FIFO_OV_R = crate::BitReader<bool>;
        ///Field `TMR_IE_FIFO_OV` writer - RW, enable interrupt for timer FIFO overflow
        pub type TMR_IE_FIFO_OV_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, INTER_EN_SPEC, bool, O>;
        impl R {
            ///Bit 0 - RW, enable interrupt for timer capture count timeout or PWM cycle end
            #[inline(always)]
            pub fn tmr_ie_cyc_end(&self) -> TMR_IE_CYC_END_R {
                TMR_IE_CYC_END_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RW, enable interrupt for timer capture input action or PWM trigger
            #[inline(always)]
            pub fn tmr_ie_data_act(&self) -> TMR_IE_DATA_ACT_R {
                TMR_IE_DATA_ACT_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RW, enable interrupt for timer FIFO half (capture fifo >=4 or PWM fifo less than 3)
            #[inline(always)]
            pub fn tmr_ie_fifo_hf(&self) -> TMR_IE_FIFO_HF_R {
                TMR_IE_FIFO_HF_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RW, enable interrupt for timer1/2 DMA completion
            #[inline(always)]
            pub fn tmr_ie_dma_end(&self) -> TMR_IE_DMA_END_R {
                TMR_IE_DMA_END_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RW, enable interrupt for timer FIFO overflow
            #[inline(always)]
            pub fn tmr_ie_fifo_ov(&self) -> TMR_IE_FIFO_OV_R {
                TMR_IE_FIFO_OV_R::new(((self.bits >> 4) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RW, enable interrupt for timer capture count timeout or PWM cycle end
            #[inline(always)]
            #[must_use]
            pub fn tmr_ie_cyc_end(&mut self) -> TMR_IE_CYC_END_W<0> {
                TMR_IE_CYC_END_W::new(self)
            }
            ///Bit 1 - RW, enable interrupt for timer capture input action or PWM trigger
            #[inline(always)]
            #[must_use]
            pub fn tmr_ie_data_act(&mut self) -> TMR_IE_DATA_ACT_W<1> {
                TMR_IE_DATA_ACT_W::new(self)
            }
            ///Bit 2 - RW, enable interrupt for timer FIFO half (capture fifo >=4 or PWM fifo less than 3)
            #[inline(always)]
            #[must_use]
            pub fn tmr_ie_fifo_hf(&mut self) -> TMR_IE_FIFO_HF_W<2> {
                TMR_IE_FIFO_HF_W::new(self)
            }
            ///Bit 3 - RW, enable interrupt for timer1/2 DMA completion
            #[inline(always)]
            #[must_use]
            pub fn tmr_ie_dma_end(&mut self) -> TMR_IE_DMA_END_W<3> {
                TMR_IE_DMA_END_W::new(self)
            }
            ///Bit 4 - RW, enable interrupt for timer FIFO overflow
            #[inline(always)]
            #[must_use]
            pub fn tmr_ie_fifo_ov(&mut self) -> TMR_IE_FIFO_OV_W<4> {
                TMR_IE_FIFO_OV_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, TMR2 interrupt enable
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [inter_en](index.html) module
        pub struct INTER_EN_SPEC;
        impl crate::RegisterSpec for INTER_EN_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [inter_en::R](R) reader structure
        impl crate::Readable for INTER_EN_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [inter_en::W](W) writer structure
        impl crate::Writable for INTER_EN_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets INTER_EN to value 0
        impl crate::Resettable for INTER_EN_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///INT_FLAG (rw) register accessor: an alias for `Reg<INT_FLAG_SPEC>`
    pub type INT_FLAG = crate::Reg<int_flag::INT_FLAG_SPEC>;
    ///RW1, TMR2 interrupt flag
    pub mod int_flag {
        ///Register `INT_FLAG` reader
        pub struct R(crate::R<INT_FLAG_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<INT_FLAG_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<INT_FLAG_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<INT_FLAG_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `INT_FLAG` writer
        pub struct W(crate::W<INT_FLAG_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<INT_FLAG_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<INT_FLAG_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<INT_FLAG_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `TMR_IF_CYC_END` reader - RW1, interrupt flag for timer capture count timeout or PWM cycle end
        pub type TMR_IF_CYC_END_R = crate::BitReader<bool>;
        ///Field `TMR_IF_CYC_END` writer - RW1, interrupt flag for timer capture count timeout or PWM cycle end
        pub type TMR_IF_CYC_END_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, INT_FLAG_SPEC, bool, O>;
        ///Field `TMR_IF_DATA_ACT` reader - RW1, interrupt flag for timer capture input action or PWM trigger
        pub type TMR_IF_DATA_ACT_R = crate::BitReader<bool>;
        ///Field `TMR_IF_DATA_ACT` writer - RW1, interrupt flag for timer capture input action or PWM trigger
        pub type TMR_IF_DATA_ACT_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, INT_FLAG_SPEC, bool, O>;
        ///Field `TMR_IF_FIFO_HF` reader - RW1, interrupt flag for timer FIFO half (capture fifo >=4 or PWM fifo less than 3
        pub type TMR_IF_FIFO_HF_R = crate::BitReader<bool>;
        ///Field `TMR_IF_FIFO_HF` writer - RW1, interrupt flag for timer FIFO half (capture fifo >=4 or PWM fifo less than 3
        pub type TMR_IF_FIFO_HF_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, INT_FLAG_SPEC, bool, O>;
        ///Field `TMR_IF_DMA_END` reader - RW1, interrupt flag for timer1/2 DMA completion
        pub type TMR_IF_DMA_END_R = crate::BitReader<bool>;
        ///Field `TMR_IF_DMA_END` writer - RW1, interrupt flag for timer1/2 DMA completion
        pub type TMR_IF_DMA_END_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, INT_FLAG_SPEC, bool, O>;
        ///Field `TMR_IF_FIFO_OV` reader - RW1, interrupt flag for timer FIFO overflow
        pub type TMR_IF_FIFO_OV_R = crate::BitReader<bool>;
        ///Field `TMR_IF_FIFO_OV` writer - RW1, interrupt flag for timer FIFO overflow
        pub type TMR_IF_FIFO_OV_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, INT_FLAG_SPEC, bool, O>;
        impl R {
            ///Bit 0 - RW1, interrupt flag for timer capture count timeout or PWM cycle end
            #[inline(always)]
            pub fn tmr_if_cyc_end(&self) -> TMR_IF_CYC_END_R {
                TMR_IF_CYC_END_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RW1, interrupt flag for timer capture input action or PWM trigger
            #[inline(always)]
            pub fn tmr_if_data_act(&self) -> TMR_IF_DATA_ACT_R {
                TMR_IF_DATA_ACT_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RW1, interrupt flag for timer FIFO half (capture fifo >=4 or PWM fifo less than 3
            #[inline(always)]
            pub fn tmr_if_fifo_hf(&self) -> TMR_IF_FIFO_HF_R {
                TMR_IF_FIFO_HF_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RW1, interrupt flag for timer1/2 DMA completion
            #[inline(always)]
            pub fn tmr_if_dma_end(&self) -> TMR_IF_DMA_END_R {
                TMR_IF_DMA_END_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RW1, interrupt flag for timer FIFO overflow
            #[inline(always)]
            pub fn tmr_if_fifo_ov(&self) -> TMR_IF_FIFO_OV_R {
                TMR_IF_FIFO_OV_R::new(((self.bits >> 4) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RW1, interrupt flag for timer capture count timeout or PWM cycle end
            #[inline(always)]
            #[must_use]
            pub fn tmr_if_cyc_end(&mut self) -> TMR_IF_CYC_END_W<0> {
                TMR_IF_CYC_END_W::new(self)
            }
            ///Bit 1 - RW1, interrupt flag for timer capture input action or PWM trigger
            #[inline(always)]
            #[must_use]
            pub fn tmr_if_data_act(&mut self) -> TMR_IF_DATA_ACT_W<1> {
                TMR_IF_DATA_ACT_W::new(self)
            }
            ///Bit 2 - RW1, interrupt flag for timer FIFO half (capture fifo >=4 or PWM fifo less than 3
            #[inline(always)]
            #[must_use]
            pub fn tmr_if_fifo_hf(&mut self) -> TMR_IF_FIFO_HF_W<2> {
                TMR_IF_FIFO_HF_W::new(self)
            }
            ///Bit 3 - RW1, interrupt flag for timer1/2 DMA completion
            #[inline(always)]
            #[must_use]
            pub fn tmr_if_dma_end(&mut self) -> TMR_IF_DMA_END_W<3> {
                TMR_IF_DMA_END_W::new(self)
            }
            ///Bit 4 - RW1, interrupt flag for timer FIFO overflow
            #[inline(always)]
            #[must_use]
            pub fn tmr_if_fifo_ov(&mut self) -> TMR_IF_FIFO_OV_W<4> {
                TMR_IF_FIFO_OV_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW1, TMR2 interrupt flag
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [int_flag](index.html) module
        pub struct INT_FLAG_SPEC;
        impl crate::RegisterSpec for INT_FLAG_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [int_flag::R](R) reader structure
        impl crate::Readable for INT_FLAG_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [int_flag::W](W) writer structure
        impl crate::Writable for INT_FLAG_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets INT_FLAG to value 0
        impl crate::Resettable for INT_FLAG_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///FIFO_COUNT (r) register accessor: an alias for `Reg<FIFO_COUNT_SPEC>`
    pub type FIFO_COUNT = crate::Reg<fifo_count::FIFO_COUNT_SPEC>;
    ///RO, TMR2 FIFO count status
    pub mod fifo_count {
        ///Register `FIFO_COUNT` reader
        pub struct R(crate::R<FIFO_COUNT_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<FIFO_COUNT_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<FIFO_COUNT_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<FIFO_COUNT_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `TMR2_FIFO_COUNT` reader - RW, TMR2 FIFO count status
        pub type TMR2_FIFO_COUNT_R = crate::FieldReader<u8, u8>;
        impl R {
            ///Bits 0:7 - RW, TMR2 FIFO count status
            #[inline(always)]
            pub fn tmr2_fifo_count(&self) -> TMR2_FIFO_COUNT_R {
                TMR2_FIFO_COUNT_R::new(self.bits)
            }
        }
        ///RO, TMR2 FIFO count status
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [fifo_count](index.html) module
        pub struct FIFO_COUNT_SPEC;
        impl crate::RegisterSpec for FIFO_COUNT_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [fifo_count::R](R) reader structure
        impl crate::Readable for FIFO_COUNT_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets FIFO_COUNT to value 0
        impl crate::Resettable for FIFO_COUNT_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///COUNT (r) register accessor: an alias for `Reg<COUNT_SPEC>`
    pub type COUNT = crate::Reg<count::COUNT_SPEC>;
    ///RO, TMR2 current count
    pub mod count {
        ///Register `COUNT` reader
        pub struct R(crate::R<COUNT_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<COUNT_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<COUNT_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<COUNT_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `TMR2_COUNT` reader - RW, TMR2 current count
        pub type TMR2_COUNT_R = crate::FieldReader<u32, u32>;
        impl R {
            ///Bits 0:31 - RW, TMR2 current count
            #[inline(always)]
            pub fn tmr2_count(&self) -> TMR2_COUNT_R {
                TMR2_COUNT_R::new(self.bits)
            }
        }
        ///RO, TMR2 current count
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [count](index.html) module
        pub struct COUNT_SPEC;
        impl crate::RegisterSpec for COUNT_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [count::R](R) reader structure
        impl crate::Readable for COUNT_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets COUNT to value 0
        impl crate::Resettable for COUNT_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///CNT_END (rw) register accessor: an alias for `Reg<CNT_END_SPEC>`
    pub type CNT_END = crate::Reg<cnt_end::CNT_END_SPEC>;
    ///RW, TMR2 end count value, only low 26 bit
    pub mod cnt_end {
        ///Register `CNT_END` reader
        pub struct R(crate::R<CNT_END_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CNT_END_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<CNT_END_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<CNT_END_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CNT_END` writer
        pub struct W(crate::W<CNT_END_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CNT_END_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<CNT_END_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<CNT_END_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `TMR2_CNT_END` reader - RW, TMR2 current count
        pub type TMR2_CNT_END_R = crate::FieldReader<u32, u32>;
        ///Field `TMR2_CNT_END` writer - RW, TMR2 current count
        pub type TMR2_CNT_END_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, CNT_END_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - RW, TMR2 current count
            #[inline(always)]
            pub fn tmr2_cnt_end(&self) -> TMR2_CNT_END_R {
                TMR2_CNT_END_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW, TMR2 current count
            #[inline(always)]
            #[must_use]
            pub fn tmr2_cnt_end(&mut self) -> TMR2_CNT_END_W<0> {
                TMR2_CNT_END_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, TMR2 end count value, only low 26 bit
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [cnt_end](index.html) module
        pub struct CNT_END_SPEC;
        impl crate::RegisterSpec for CNT_END_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [cnt_end::R](R) reader structure
        impl crate::Readable for CNT_END_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [cnt_end::W](W) writer structure
        impl crate::Writable for CNT_END_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets CNT_END to value 0
        impl crate::Resettable for CNT_END_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///FIFO (rw) register accessor: an alias for `Reg<FIFO_SPEC>`
    pub type FIFO = crate::Reg<fifo::FIFO_SPEC>;
    ///RO, TMR2 FIFO register, only low 26 bit
    pub mod fifo {
        ///Register `FIFO` reader
        pub struct R(crate::R<FIFO_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<FIFO_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<FIFO_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<FIFO_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `FIFO` writer
        pub struct W(crate::W<FIFO_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<FIFO_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<FIFO_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<FIFO_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `TMR2_FIFO` reader - RW, TMR2 current count
        pub type TMR2_FIFO_R = crate::FieldReader<u32, u32>;
        ///Field `TMR2_FIFO` writer - RW, TMR2 current count
        pub type TMR2_FIFO_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, FIFO_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - RW, TMR2 current count
            #[inline(always)]
            pub fn tmr2_fifo(&self) -> TMR2_FIFO_R {
                TMR2_FIFO_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW, TMR2 current count
            #[inline(always)]
            #[must_use]
            pub fn tmr2_fifo(&mut self) -> TMR2_FIFO_W<0> {
                TMR2_FIFO_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RO, TMR2 FIFO register, only low 26 bit
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [fifo](index.html) module
        pub struct FIFO_SPEC;
        impl crate::RegisterSpec for FIFO_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [fifo::R](R) reader structure
        impl crate::Readable for FIFO_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [fifo::W](W) writer structure
        impl crate::Writable for FIFO_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets FIFO to value 0
        impl crate::Resettable for FIFO_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///DMA_NOW (r) register accessor: an alias for `Reg<DMA_NOW_SPEC>`
    pub type DMA_NOW = crate::Reg<dma_now::DMA_NOW_SPEC>;
    ///RO, TMR2 DMA current address
    pub mod dma_now {
        ///Register `DMA_NOW` reader
        pub struct R(crate::R<DMA_NOW_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<DMA_NOW_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<DMA_NOW_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<DMA_NOW_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `TMR2_DMA_NOW` reader - RW, TMR2 current count
        pub type TMR2_DMA_NOW_R = crate::FieldReader<u16, u16>;
        impl R {
            ///Bits 0:15 - RW, TMR2 current count
            #[inline(always)]
            pub fn tmr2_dma_now(&self) -> TMR2_DMA_NOW_R {
                TMR2_DMA_NOW_R::new(self.bits)
            }
        }
        ///RO, TMR2 DMA current address
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [dma_now](index.html) module
        pub struct DMA_NOW_SPEC;
        impl crate::RegisterSpec for DMA_NOW_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [dma_now::R](R) reader structure
        impl crate::Readable for DMA_NOW_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets DMA_NOW to value 0
        impl crate::Resettable for DMA_NOW_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///DMA_BEG (rw) register accessor: an alias for `Reg<DMA_BEG_SPEC>`
    pub type DMA_BEG = crate::Reg<dma_beg::DMA_BEG_SPEC>;
    ///RW, TMR2 DMA begin address
    pub mod dma_beg {
        ///Register `DMA_BEG` reader
        pub struct R(crate::R<DMA_BEG_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<DMA_BEG_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<DMA_BEG_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<DMA_BEG_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `DMA_BEG` writer
        pub struct W(crate::W<DMA_BEG_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<DMA_BEG_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<DMA_BEG_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<DMA_BEG_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `TMR2_DMA_BEG` reader - RW, TMR2 DMA begin address
        pub type TMR2_DMA_BEG_R = crate::FieldReader<u16, u16>;
        ///Field `TMR2_DMA_BEG` writer - RW, TMR2 DMA begin address
        pub type TMR2_DMA_BEG_W<'a, const O: u8> =
            crate::FieldWriter<'a, u16, DMA_BEG_SPEC, u16, u16, 16, O>;
        impl R {
            ///Bits 0:15 - RW, TMR2 DMA begin address
            #[inline(always)]
            pub fn tmr2_dma_beg(&self) -> TMR2_DMA_BEG_R {
                TMR2_DMA_BEG_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - RW, TMR2 DMA begin address
            #[inline(always)]
            #[must_use]
            pub fn tmr2_dma_beg(&mut self) -> TMR2_DMA_BEG_W<0> {
                TMR2_DMA_BEG_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, TMR2 DMA begin address
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [dma_beg](index.html) module
        pub struct DMA_BEG_SPEC;
        impl crate::RegisterSpec for DMA_BEG_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [dma_beg::R](R) reader structure
        impl crate::Readable for DMA_BEG_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [dma_beg::W](W) writer structure
        impl crate::Writable for DMA_BEG_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets DMA_BEG to value 0
        impl crate::Resettable for DMA_BEG_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///DMA_END (rw) register accessor: an alias for `Reg<DMA_END_SPEC>`
    pub type DMA_END = crate::Reg<dma_end::DMA_END_SPEC>;
    ///RW, TMR2 DMA end address
    pub mod dma_end {
        ///Register `DMA_END` reader
        pub struct R(crate::R<DMA_END_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<DMA_END_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<DMA_END_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<DMA_END_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `DMA_END` writer
        pub struct W(crate::W<DMA_END_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<DMA_END_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<DMA_END_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<DMA_END_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `TMR2_DMA_END` reader - RW, TMR2 DMA end address
        pub type TMR2_DMA_END_R = crate::FieldReader<u16, u16>;
        ///Field `TMR2_DMA_END` writer - RW, TMR2 DMA end address
        pub type TMR2_DMA_END_W<'a, const O: u8> =
            crate::FieldWriter<'a, u16, DMA_END_SPEC, u16, u16, 16, O>;
        impl R {
            ///Bits 0:15 - RW, TMR2 DMA end address
            #[inline(always)]
            pub fn tmr2_dma_end(&self) -> TMR2_DMA_END_R {
                TMR2_DMA_END_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - RW, TMR2 DMA end address
            #[inline(always)]
            #[must_use]
            pub fn tmr2_dma_end(&mut self) -> TMR2_DMA_END_W<0> {
                TMR2_DMA_END_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, TMR2 DMA end address
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [dma_end](index.html) module
        pub struct DMA_END_SPEC;
        impl crate::RegisterSpec for DMA_END_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [dma_end::R](R) reader structure
        impl crate::Readable for DMA_END_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [dma_end::W](W) writer structure
        impl crate::Writable for DMA_END_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets DMA_END to value 0
        impl crate::Resettable for DMA_END_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
}
///Timer3 register
pub struct TMR3 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for TMR3 {}
impl TMR3 {
    ///Pointer to the register block
    pub const PTR: *const tmr3::RegisterBlock = 0x4000_2c00 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const tmr3::RegisterBlock {
        Self::PTR
    }
}
impl Deref for TMR3 {
    type Target = tmr3::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for TMR3 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("TMR3").finish()
    }
}
///Timer3 register
pub mod tmr3 {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        ///0x00 - RW, TMR3 mode control
        pub tmr3_ctrl_mod: TMR3_CTRL_MOD,
        _reserved1: [u8; 0x01],
        ///0x02 - RW, TMR3 interrupt enable
        pub tmr3_inter_en: TMR3_INTER_EN,
        _reserved2: [u8; 0x03],
        ///0x06 - RW1, TMR3 interrupt flag
        pub tmr3_int_flag: TMR3_INT_FLAG,
        ///0x07 - RO, TMR3 FIFO count status
        pub tmr3_fifo_count: TMR3_FIFO_COUNT,
        ///0x08 - RO, TMR3 current count
        pub tmr3_count: TMR3_COUNT,
        ///0x0c - RW, TMR3 end count value, only low 26 bit
        pub tmr3_cnt_end: TMR3_CNT_END,
        ///0x10 - RO/WO, TMR3 FIFO register, only low 26 bit
        pub tmr3_fifo: TMR3_FIFO,
    }
    ///TMR3_CTRL_MOD (rw) register accessor: an alias for `Reg<TMR3_CTRL_MOD_SPEC>`
    pub type TMR3_CTRL_MOD = crate::Reg<tmr3_ctrl_mod::TMR3_CTRL_MOD_SPEC>;
    ///RW, TMR3 mode control
    pub mod tmr3_ctrl_mod {
        ///Register `TMR3_CTRL_MOD` reader
        pub struct R(crate::R<TMR3_CTRL_MOD_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<TMR3_CTRL_MOD_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<TMR3_CTRL_MOD_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<TMR3_CTRL_MOD_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `TMR3_CTRL_MOD` writer
        pub struct W(crate::W<TMR3_CTRL_MOD_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<TMR3_CTRL_MOD_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<TMR3_CTRL_MOD_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<TMR3_CTRL_MOD_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `TMR_MODE_IN` reader - RW, timer in mode: 0=timer/PWM, 1=capture/count
        pub type TMR_MODE_IN_R = crate::BitReader<bool>;
        ///Field `TMR_MODE_IN` writer - RW, timer in mode: 0=timer/PWM, 1=capture/count
        pub type TMR_MODE_IN_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, TMR3_CTRL_MOD_SPEC, bool, O>;
        ///Field `TMR_ALL_CLEAR` reader - RW, force clear timer FIFO and count
        pub type TMR_ALL_CLEAR_R = crate::BitReader<bool>;
        ///Field `TMR_ALL_CLEAR` writer - RW, force clear timer FIFO and count
        pub type TMR_ALL_CLEAR_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, TMR3_CTRL_MOD_SPEC, bool, O>;
        ///Field `TMR_COUNT_EN` reader - RW, timer count enable
        pub type TMR_COUNT_EN_R = crate::BitReader<bool>;
        ///Field `TMR_COUNT_EN` writer - RW, timer count enable
        pub type TMR_COUNT_EN_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, TMR3_CTRL_MOD_SPEC, bool, O>;
        ///Field `TMR_OUT_EN` reader - RW, timer output enable
        pub type TMR_OUT_EN_R = crate::BitReader<bool>;
        ///Field `TMR_OUT_EN` writer - RW, timer output enable
        pub type TMR_OUT_EN_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, TMR3_CTRL_MOD_SPEC, bool, O>;
        ///Field `TMR_OUT_POLAR__RB_TMR_CAP_COUNT` reader - RW, timer PWM output polarity: 0=default low and high action, 1=default high and low action;RW, count sub-mode if RB_TMR_MODE_IN=1: 0=capture, 1=count
        pub type TMR_OUT_POLAR__RB_TMR_CAP_COUNT_R = crate::BitReader<bool>;
        ///Field `TMR_OUT_POLAR__RB_TMR_CAP_COUNT` writer - RW, timer PWM output polarity: 0=default low and high action, 1=default high and low action;RW, count sub-mode if RB_TMR_MODE_IN=1: 0=capture, 1=count
        pub type TMR_OUT_POLAR__RB_TMR_CAP_COUNT_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, TMR3_CTRL_MOD_SPEC, bool, O>;
        ///Field `TMR_PWM_REPEAT__RB_TMR_CAP_EDGE` reader - RW, timer PWM repeat mode: 00=1, 01=4, 10=8, 11-16;RW, timer capture edge mode: 00=disable, 01=edge change, 10=fall to fall, 11-rise to rise
        pub type TMR_PWM_REPEAT__RB_TMR_CAP_EDGE_R = crate::FieldReader<u8, u8>;
        ///Field `TMR_PWM_REPEAT__RB_TMR_CAP_EDGE` writer - RW, timer PWM repeat mode: 00=1, 01=4, 10=8, 11-16;RW, timer capture edge mode: 00=disable, 01=edge change, 10=fall to fall, 11-rise to rise
        pub type TMR_PWM_REPEAT__RB_TMR_CAP_EDGE_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, TMR3_CTRL_MOD_SPEC, u8, u8, 2, O>;
        impl R {
            ///Bit 0 - RW, timer in mode: 0=timer/PWM, 1=capture/count
            #[inline(always)]
            pub fn tmr_mode_in(&self) -> TMR_MODE_IN_R {
                TMR_MODE_IN_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RW, force clear timer FIFO and count
            #[inline(always)]
            pub fn tmr_all_clear(&self) -> TMR_ALL_CLEAR_R {
                TMR_ALL_CLEAR_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RW, timer count enable
            #[inline(always)]
            pub fn tmr_count_en(&self) -> TMR_COUNT_EN_R {
                TMR_COUNT_EN_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RW, timer output enable
            #[inline(always)]
            pub fn tmr_out_en(&self) -> TMR_OUT_EN_R {
                TMR_OUT_EN_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RW, timer PWM output polarity: 0=default low and high action, 1=default high and low action;RW, count sub-mode if RB_TMR_MODE_IN=1: 0=capture, 1=count
            #[inline(always)]
            pub fn tmr_out_polar__rb_tmr_cap_count(&self) -> TMR_OUT_POLAR__RB_TMR_CAP_COUNT_R {
                TMR_OUT_POLAR__RB_TMR_CAP_COUNT_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bits 6:7 - RW, timer PWM repeat mode: 00=1, 01=4, 10=8, 11-16;RW, timer capture edge mode: 00=disable, 01=edge change, 10=fall to fall, 11-rise to rise
            #[inline(always)]
            pub fn tmr_pwm_repeat__rb_tmr_cap_edge(&self) -> TMR_PWM_REPEAT__RB_TMR_CAP_EDGE_R {
                TMR_PWM_REPEAT__RB_TMR_CAP_EDGE_R::new((self.bits >> 6) & 3)
            }
        }
        impl W {
            ///Bit 0 - RW, timer in mode: 0=timer/PWM, 1=capture/count
            #[inline(always)]
            #[must_use]
            pub fn tmr_mode_in(&mut self) -> TMR_MODE_IN_W<0> {
                TMR_MODE_IN_W::new(self)
            }
            ///Bit 1 - RW, force clear timer FIFO and count
            #[inline(always)]
            #[must_use]
            pub fn tmr_all_clear(&mut self) -> TMR_ALL_CLEAR_W<1> {
                TMR_ALL_CLEAR_W::new(self)
            }
            ///Bit 2 - RW, timer count enable
            #[inline(always)]
            #[must_use]
            pub fn tmr_count_en(&mut self) -> TMR_COUNT_EN_W<2> {
                TMR_COUNT_EN_W::new(self)
            }
            ///Bit 3 - RW, timer output enable
            #[inline(always)]
            #[must_use]
            pub fn tmr_out_en(&mut self) -> TMR_OUT_EN_W<3> {
                TMR_OUT_EN_W::new(self)
            }
            ///Bit 4 - RW, timer PWM output polarity: 0=default low and high action, 1=default high and low action;RW, count sub-mode if RB_TMR_MODE_IN=1: 0=capture, 1=count
            #[inline(always)]
            #[must_use]
            pub fn tmr_out_polar__rb_tmr_cap_count(
                &mut self,
            ) -> TMR_OUT_POLAR__RB_TMR_CAP_COUNT_W<4> {
                TMR_OUT_POLAR__RB_TMR_CAP_COUNT_W::new(self)
            }
            ///Bits 6:7 - RW, timer PWM repeat mode: 00=1, 01=4, 10=8, 11-16;RW, timer capture edge mode: 00=disable, 01=edge change, 10=fall to fall, 11-rise to rise
            #[inline(always)]
            #[must_use]
            pub fn tmr_pwm_repeat__rb_tmr_cap_edge(
                &mut self,
            ) -> TMR_PWM_REPEAT__RB_TMR_CAP_EDGE_W<6> {
                TMR_PWM_REPEAT__RB_TMR_CAP_EDGE_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, TMR3 mode control
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [tmr3_ctrl_mod](index.html) module
        pub struct TMR3_CTRL_MOD_SPEC;
        impl crate::RegisterSpec for TMR3_CTRL_MOD_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [tmr3_ctrl_mod::R](R) reader structure
        impl crate::Readable for TMR3_CTRL_MOD_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [tmr3_ctrl_mod::W](W) writer structure
        impl crate::Writable for TMR3_CTRL_MOD_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets TMR3_CTRL_MOD to value 0x02
        impl crate::Resettable for TMR3_CTRL_MOD_SPEC {
            const RESET_VALUE: Self::Ux = 0x02;
        }
    }
    ///TMR3_INTER_EN (rw) register accessor: an alias for `Reg<TMR3_INTER_EN_SPEC>`
    pub type TMR3_INTER_EN = crate::Reg<tmr3_inter_en::TMR3_INTER_EN_SPEC>;
    ///RW, TMR3 interrupt enable
    pub mod tmr3_inter_en {
        ///Register `TMR3_INTER_EN` reader
        pub struct R(crate::R<TMR3_INTER_EN_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<TMR3_INTER_EN_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<TMR3_INTER_EN_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<TMR3_INTER_EN_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `TMR3_INTER_EN` writer
        pub struct W(crate::W<TMR3_INTER_EN_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<TMR3_INTER_EN_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<TMR3_INTER_EN_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<TMR3_INTER_EN_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `TMR_IE_CYC_END` reader - RW, enable interrupt for timer capture count timeout or PWM cycle end
        pub type TMR_IE_CYC_END_R = crate::BitReader<bool>;
        ///Field `TMR_IE_CYC_END` writer - RW, enable interrupt for timer capture count timeout or PWM cycle end
        pub type TMR_IE_CYC_END_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, TMR3_INTER_EN_SPEC, bool, O>;
        ///Field `TMR_IE_DATA_ACT` reader - RW, enable interrupt for timer capture input action or PWM trigger
        pub type TMR_IE_DATA_ACT_R = crate::BitReader<bool>;
        ///Field `TMR_IE_DATA_ACT` writer - RW, enable interrupt for timer capture input action or PWM trigger
        pub type TMR_IE_DATA_ACT_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, TMR3_INTER_EN_SPEC, bool, O>;
        ///Field `TMR_IE_FIFO_HF` reader - RW, enable interrupt for timer FIFO half (capture fifo >=4 or PWM fifo less than 3)
        pub type TMR_IE_FIFO_HF_R = crate::BitReader<bool>;
        ///Field `TMR_IE_FIFO_HF` writer - RW, enable interrupt for timer FIFO half (capture fifo >=4 or PWM fifo less than 3)
        pub type TMR_IE_FIFO_HF_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, TMR3_INTER_EN_SPEC, bool, O>;
        ///Field `TMR_IE_DMA_END` reader - RW, enable interrupt for timer1/2 DMA completion
        pub type TMR_IE_DMA_END_R = crate::BitReader<bool>;
        ///Field `TMR_IE_DMA_END` writer - RW, enable interrupt for timer1/2 DMA completion
        pub type TMR_IE_DMA_END_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, TMR3_INTER_EN_SPEC, bool, O>;
        ///Field `TMR_IE_FIFO_OV` reader - RW, enable interrupt for timer FIFO overflow
        pub type TMR_IE_FIFO_OV_R = crate::BitReader<bool>;
        ///Field `TMR_IE_FIFO_OV` writer - RW, enable interrupt for timer FIFO overflow
        pub type TMR_IE_FIFO_OV_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, TMR3_INTER_EN_SPEC, bool, O>;
        impl R {
            ///Bit 0 - RW, enable interrupt for timer capture count timeout or PWM cycle end
            #[inline(always)]
            pub fn tmr_ie_cyc_end(&self) -> TMR_IE_CYC_END_R {
                TMR_IE_CYC_END_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RW, enable interrupt for timer capture input action or PWM trigger
            #[inline(always)]
            pub fn tmr_ie_data_act(&self) -> TMR_IE_DATA_ACT_R {
                TMR_IE_DATA_ACT_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RW, enable interrupt for timer FIFO half (capture fifo >=4 or PWM fifo less than 3)
            #[inline(always)]
            pub fn tmr_ie_fifo_hf(&self) -> TMR_IE_FIFO_HF_R {
                TMR_IE_FIFO_HF_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RW, enable interrupt for timer1/2 DMA completion
            #[inline(always)]
            pub fn tmr_ie_dma_end(&self) -> TMR_IE_DMA_END_R {
                TMR_IE_DMA_END_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RW, enable interrupt for timer FIFO overflow
            #[inline(always)]
            pub fn tmr_ie_fifo_ov(&self) -> TMR_IE_FIFO_OV_R {
                TMR_IE_FIFO_OV_R::new(((self.bits >> 4) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RW, enable interrupt for timer capture count timeout or PWM cycle end
            #[inline(always)]
            #[must_use]
            pub fn tmr_ie_cyc_end(&mut self) -> TMR_IE_CYC_END_W<0> {
                TMR_IE_CYC_END_W::new(self)
            }
            ///Bit 1 - RW, enable interrupt for timer capture input action or PWM trigger
            #[inline(always)]
            #[must_use]
            pub fn tmr_ie_data_act(&mut self) -> TMR_IE_DATA_ACT_W<1> {
                TMR_IE_DATA_ACT_W::new(self)
            }
            ///Bit 2 - RW, enable interrupt for timer FIFO half (capture fifo >=4 or PWM fifo less than 3)
            #[inline(always)]
            #[must_use]
            pub fn tmr_ie_fifo_hf(&mut self) -> TMR_IE_FIFO_HF_W<2> {
                TMR_IE_FIFO_HF_W::new(self)
            }
            ///Bit 3 - RW, enable interrupt for timer1/2 DMA completion
            #[inline(always)]
            #[must_use]
            pub fn tmr_ie_dma_end(&mut self) -> TMR_IE_DMA_END_W<3> {
                TMR_IE_DMA_END_W::new(self)
            }
            ///Bit 4 - RW, enable interrupt for timer FIFO overflow
            #[inline(always)]
            #[must_use]
            pub fn tmr_ie_fifo_ov(&mut self) -> TMR_IE_FIFO_OV_W<4> {
                TMR_IE_FIFO_OV_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, TMR3 interrupt enable
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [tmr3_inter_en](index.html) module
        pub struct TMR3_INTER_EN_SPEC;
        impl crate::RegisterSpec for TMR3_INTER_EN_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [tmr3_inter_en::R](R) reader structure
        impl crate::Readable for TMR3_INTER_EN_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [tmr3_inter_en::W](W) writer structure
        impl crate::Writable for TMR3_INTER_EN_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets TMR3_INTER_EN to value 0
        impl crate::Resettable for TMR3_INTER_EN_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///TMR3_INT_FLAG (rw) register accessor: an alias for `Reg<TMR3_INT_FLAG_SPEC>`
    pub type TMR3_INT_FLAG = crate::Reg<tmr3_int_flag::TMR3_INT_FLAG_SPEC>;
    ///RW1, TMR3 interrupt flag
    pub mod tmr3_int_flag {
        ///Register `TMR3_INT_FLAG` reader
        pub struct R(crate::R<TMR3_INT_FLAG_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<TMR3_INT_FLAG_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<TMR3_INT_FLAG_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<TMR3_INT_FLAG_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `TMR3_INT_FLAG` writer
        pub struct W(crate::W<TMR3_INT_FLAG_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<TMR3_INT_FLAG_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<TMR3_INT_FLAG_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<TMR3_INT_FLAG_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `TMR_IF_CYC_END` reader - RW1, interrupt flag for timer capture count timeout or PWM cycle end
        pub type TMR_IF_CYC_END_R = crate::BitReader<bool>;
        ///Field `TMR_IF_CYC_END` writer - RW1, interrupt flag for timer capture count timeout or PWM cycle end
        pub type TMR_IF_CYC_END_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, TMR3_INT_FLAG_SPEC, bool, O>;
        ///Field `TMR_IF_DATA_ACT` reader - RW1, interrupt flag for timer capture input action or PWM trigger
        pub type TMR_IF_DATA_ACT_R = crate::BitReader<bool>;
        ///Field `TMR_IF_DATA_ACT` writer - RW1, interrupt flag for timer capture input action or PWM trigger
        pub type TMR_IF_DATA_ACT_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, TMR3_INT_FLAG_SPEC, bool, O>;
        ///Field `TMR_IF_FIFO_HF` reader - RW1, interrupt flag for timer FIFO half (capture fifo >=4 or PWM fifo less than 3
        pub type TMR_IF_FIFO_HF_R = crate::BitReader<bool>;
        ///Field `TMR_IF_FIFO_HF` writer - RW1, interrupt flag for timer FIFO half (capture fifo >=4 or PWM fifo less than 3
        pub type TMR_IF_FIFO_HF_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, TMR3_INT_FLAG_SPEC, bool, O>;
        ///Field `TMR_IF_DMA_END` reader - RW1, interrupt flag for timer1/2 DMA completion
        pub type TMR_IF_DMA_END_R = crate::BitReader<bool>;
        ///Field `TMR_IF_DMA_END` writer - RW1, interrupt flag for timer1/2 DMA completion
        pub type TMR_IF_DMA_END_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, TMR3_INT_FLAG_SPEC, bool, O>;
        ///Field `TMR_IF_FIFO_OV` reader - RW1, interrupt flag for timer FIFO overflow
        pub type TMR_IF_FIFO_OV_R = crate::BitReader<bool>;
        ///Field `TMR_IF_FIFO_OV` writer - RW1, interrupt flag for timer FIFO overflow
        pub type TMR_IF_FIFO_OV_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, TMR3_INT_FLAG_SPEC, bool, O>;
        impl R {
            ///Bit 0 - RW1, interrupt flag for timer capture count timeout or PWM cycle end
            #[inline(always)]
            pub fn tmr_if_cyc_end(&self) -> TMR_IF_CYC_END_R {
                TMR_IF_CYC_END_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RW1, interrupt flag for timer capture input action or PWM trigger
            #[inline(always)]
            pub fn tmr_if_data_act(&self) -> TMR_IF_DATA_ACT_R {
                TMR_IF_DATA_ACT_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RW1, interrupt flag for timer FIFO half (capture fifo >=4 or PWM fifo less than 3
            #[inline(always)]
            pub fn tmr_if_fifo_hf(&self) -> TMR_IF_FIFO_HF_R {
                TMR_IF_FIFO_HF_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RW1, interrupt flag for timer1/2 DMA completion
            #[inline(always)]
            pub fn tmr_if_dma_end(&self) -> TMR_IF_DMA_END_R {
                TMR_IF_DMA_END_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RW1, interrupt flag for timer FIFO overflow
            #[inline(always)]
            pub fn tmr_if_fifo_ov(&self) -> TMR_IF_FIFO_OV_R {
                TMR_IF_FIFO_OV_R::new(((self.bits >> 4) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RW1, interrupt flag for timer capture count timeout or PWM cycle end
            #[inline(always)]
            #[must_use]
            pub fn tmr_if_cyc_end(&mut self) -> TMR_IF_CYC_END_W<0> {
                TMR_IF_CYC_END_W::new(self)
            }
            ///Bit 1 - RW1, interrupt flag for timer capture input action or PWM trigger
            #[inline(always)]
            #[must_use]
            pub fn tmr_if_data_act(&mut self) -> TMR_IF_DATA_ACT_W<1> {
                TMR_IF_DATA_ACT_W::new(self)
            }
            ///Bit 2 - RW1, interrupt flag for timer FIFO half (capture fifo >=4 or PWM fifo less than 3
            #[inline(always)]
            #[must_use]
            pub fn tmr_if_fifo_hf(&mut self) -> TMR_IF_FIFO_HF_W<2> {
                TMR_IF_FIFO_HF_W::new(self)
            }
            ///Bit 3 - RW1, interrupt flag for timer1/2 DMA completion
            #[inline(always)]
            #[must_use]
            pub fn tmr_if_dma_end(&mut self) -> TMR_IF_DMA_END_W<3> {
                TMR_IF_DMA_END_W::new(self)
            }
            ///Bit 4 - RW1, interrupt flag for timer FIFO overflow
            #[inline(always)]
            #[must_use]
            pub fn tmr_if_fifo_ov(&mut self) -> TMR_IF_FIFO_OV_W<4> {
                TMR_IF_FIFO_OV_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW1, TMR3 interrupt flag
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [tmr3_int_flag](index.html) module
        pub struct TMR3_INT_FLAG_SPEC;
        impl crate::RegisterSpec for TMR3_INT_FLAG_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [tmr3_int_flag::R](R) reader structure
        impl crate::Readable for TMR3_INT_FLAG_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [tmr3_int_flag::W](W) writer structure
        impl crate::Writable for TMR3_INT_FLAG_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets TMR3_INT_FLAG to value 0
        impl crate::Resettable for TMR3_INT_FLAG_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///TMR3_FIFO_COUNT (r) register accessor: an alias for `Reg<TMR3_FIFO_COUNT_SPEC>`
    pub type TMR3_FIFO_COUNT = crate::Reg<tmr3_fifo_count::TMR3_FIFO_COUNT_SPEC>;
    ///RO, TMR3 FIFO count status
    pub mod tmr3_fifo_count {
        ///Register `TMR3_FIFO_COUNT` reader
        pub struct R(crate::R<TMR3_FIFO_COUNT_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<TMR3_FIFO_COUNT_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<TMR3_FIFO_COUNT_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<TMR3_FIFO_COUNT_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `TMR3_FIFO_COUNT` reader - R0, TMR3 FIFO count status
        pub type TMR3_FIFO_COUNT_R = crate::FieldReader<u8, u8>;
        impl R {
            ///Bits 0:7 - R0, TMR3 FIFO count status
            #[inline(always)]
            pub fn tmr3_fifo_count(&self) -> TMR3_FIFO_COUNT_R {
                TMR3_FIFO_COUNT_R::new(self.bits)
            }
        }
        ///RO, TMR3 FIFO count status
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [tmr3_fifo_count](index.html) module
        pub struct TMR3_FIFO_COUNT_SPEC;
        impl crate::RegisterSpec for TMR3_FIFO_COUNT_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [tmr3_fifo_count::R](R) reader structure
        impl crate::Readable for TMR3_FIFO_COUNT_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets TMR3_FIFO_COUNT to value 0
        impl crate::Resettable for TMR3_FIFO_COUNT_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///TMR3_COUNT (r) register accessor: an alias for `Reg<TMR3_COUNT_SPEC>`
    pub type TMR3_COUNT = crate::Reg<tmr3_count::TMR3_COUNT_SPEC>;
    ///RO, TMR3 current count
    pub mod tmr3_count {
        ///Register `TMR3_COUNT` reader
        pub struct R(crate::R<TMR3_COUNT_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<TMR3_COUNT_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<TMR3_COUNT_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<TMR3_COUNT_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `TMR3_COUNT` reader - R0, TMR3 current count
        pub type TMR3_COUNT_R = crate::FieldReader<u32, u32>;
        impl R {
            ///Bits 0:31 - R0, TMR3 current count
            #[inline(always)]
            pub fn tmr3_count(&self) -> TMR3_COUNT_R {
                TMR3_COUNT_R::new(self.bits)
            }
        }
        ///RO, TMR3 current count
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [tmr3_count](index.html) module
        pub struct TMR3_COUNT_SPEC;
        impl crate::RegisterSpec for TMR3_COUNT_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [tmr3_count::R](R) reader structure
        impl crate::Readable for TMR3_COUNT_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets TMR3_COUNT to value 0
        impl crate::Resettable for TMR3_COUNT_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///TMR3_CNT_END (rw) register accessor: an alias for `Reg<TMR3_CNT_END_SPEC>`
    pub type TMR3_CNT_END = crate::Reg<tmr3_cnt_end::TMR3_CNT_END_SPEC>;
    ///RW, TMR3 end count value, only low 26 bit
    pub mod tmr3_cnt_end {
        ///Register `TMR3_CNT_END` reader
        pub struct R(crate::R<TMR3_CNT_END_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<TMR3_CNT_END_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<TMR3_CNT_END_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<TMR3_CNT_END_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `TMR3_CNT_END` writer
        pub struct W(crate::W<TMR3_CNT_END_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<TMR3_CNT_END_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<TMR3_CNT_END_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<TMR3_CNT_END_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `TMR3_CNT_END` reader - RW, TMR3 end count value, only low 26 bit
        pub type TMR3_CNT_END_R = crate::FieldReader<u32, u32>;
        ///Field `TMR3_CNT_END` writer - RW, TMR3 end count value, only low 26 bit
        pub type TMR3_CNT_END_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, TMR3_CNT_END_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - RW, TMR3 end count value, only low 26 bit
            #[inline(always)]
            pub fn tmr3_cnt_end(&self) -> TMR3_CNT_END_R {
                TMR3_CNT_END_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW, TMR3 end count value, only low 26 bit
            #[inline(always)]
            #[must_use]
            pub fn tmr3_cnt_end(&mut self) -> TMR3_CNT_END_W<0> {
                TMR3_CNT_END_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, TMR3 end count value, only low 26 bit
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [tmr3_cnt_end](index.html) module
        pub struct TMR3_CNT_END_SPEC;
        impl crate::RegisterSpec for TMR3_CNT_END_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [tmr3_cnt_end::R](R) reader structure
        impl crate::Readable for TMR3_CNT_END_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [tmr3_cnt_end::W](W) writer structure
        impl crate::Writable for TMR3_CNT_END_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets TMR3_CNT_END to value 0
        impl crate::Resettable for TMR3_CNT_END_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///TMR3_FIFO (rw) register accessor: an alias for `Reg<TMR3_FIFO_SPEC>`
    pub type TMR3_FIFO = crate::Reg<tmr3_fifo::TMR3_FIFO_SPEC>;
    ///RO/WO, TMR3 FIFO register, only low 26 bit
    pub mod tmr3_fifo {
        ///Register `TMR3_FIFO` reader
        pub struct R(crate::R<TMR3_FIFO_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<TMR3_FIFO_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<TMR3_FIFO_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<TMR3_FIFO_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `TMR3_FIFO` writer
        pub struct W(crate::W<TMR3_FIFO_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<TMR3_FIFO_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<TMR3_FIFO_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<TMR3_FIFO_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `TMR3_FIFO` reader - RO/WO, TMR3 FIFO register, only low 26 bit
        pub type TMR3_FIFO_R = crate::FieldReader<u32, u32>;
        ///Field `TMR3_FIFO` writer - RO/WO, TMR3 FIFO register, only low 26 bit
        pub type TMR3_FIFO_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, TMR3_FIFO_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - RO/WO, TMR3 FIFO register, only low 26 bit
            #[inline(always)]
            pub fn tmr3_fifo(&self) -> TMR3_FIFO_R {
                TMR3_FIFO_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RO/WO, TMR3 FIFO register, only low 26 bit
            #[inline(always)]
            #[must_use]
            pub fn tmr3_fifo(&mut self) -> TMR3_FIFO_W<0> {
                TMR3_FIFO_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RO/WO, TMR3 FIFO register, only low 26 bit
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [tmr3_fifo](index.html) module
        pub struct TMR3_FIFO_SPEC;
        impl crate::RegisterSpec for TMR3_FIFO_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [tmr3_fifo::R](R) reader structure
        impl crate::Readable for TMR3_FIFO_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [tmr3_fifo::W](W) writer structure
        impl crate::Writable for TMR3_FIFO_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets TMR3_FIFO to value 0
        impl crate::Resettable for TMR3_FIFO_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
}
///UART0 register
pub struct UART0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for UART0 {}
impl UART0 {
    ///Pointer to the register block
    pub const PTR: *const uart0::RegisterBlock = 0x4000_3000 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const uart0::RegisterBlock {
        Self::PTR
    }
}
impl Deref for UART0 {
    type Target = uart0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for UART0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("UART0").finish()
    }
}
///UART0 register
pub mod uart0 {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        ///0x00 - RW, UART0 modem control
        pub uart0_mcr: UART0_MCR,
        ///0x01 - RW, UART0 interrupt enable
        pub uart0_ier: UART0_IER,
        ///0x02 - RW, UART0 FIFO control
        pub uart0_fcr: UART0_FCR,
        ///0x03 - RW, UART0 line control
        pub uart0_lcr: UART0_LCR,
        ///0x04 - RO, UART0 interrupt identification
        pub uart0_iir: UART0_IIR,
        ///0x05 - RO, UART0 line status
        pub uart0_lsr: UART0_LSR,
        ///0x06 - RO, UART0 modem status
        pub uart0_msr: UART0_MSR,
        _reserved7: [u8; 0x01],
        _reserved_7_uart0: [u8; 0x01],
        _reserved8: [u8; 0x01],
        ///0x0a - RO, UART0 receiver FIFO count
        pub uart0_rfc: UART0_RFC,
        ///0x0b - RO, UART0 transmitter FIFO count
        pub uart0_tfc: UART0_TFC,
        ///0x0c - RW, UART0 divisor latch
        pub uart0_dl: UART0_DL,
        ///0x0e - RW, UART0 pre-divisor latch byte, only low 7 bit, from 1 to 0/128
        pub uart0_div: UART0_DIV,
        ///0x0f - RW, UART0 slave address: 0xFF=disable, other=enable
        pub uart0_adr: UART0_ADR,
    }
    impl RegisterBlock {
        ///0x08 - WO, UART0 transmitter holding, transmittal byte
        #[inline(always)]
        pub const fn uart0_thr(&self) -> &UART0_THR {
            unsafe { &*(self as *const Self).cast::<u8>().add(8usize).cast() }
        }
        ///0x08 - RO, UART0 receiver buffer, receiving byte
        #[inline(always)]
        pub const fn uart0_rbr(&self) -> &UART0_RBR {
            unsafe { &*(self as *const Self).cast::<u8>().add(8usize).cast() }
        }
    }
    ///UART0_MCR (rw) register accessor: an alias for `Reg<UART0_MCR_SPEC>`
    pub type UART0_MCR = crate::Reg<uart0_mcr::UART0_MCR_SPEC>;
    ///RW, UART0 modem control
    pub mod uart0_mcr {
        ///Register `UART0_MCR` reader
        pub struct R(crate::R<UART0_MCR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<UART0_MCR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<UART0_MCR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<UART0_MCR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `UART0_MCR` writer
        pub struct W(crate::W<UART0_MCR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<UART0_MCR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<UART0_MCR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<UART0_MCR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `MCR_DTR` reader - RW, UART0 control DTR
        pub type MCR_DTR_R = crate::BitReader<bool>;
        ///Field `MCR_DTR` writer - RW, UART0 control DTR
        pub type MCR_DTR_W<'a, const O: u8> = crate::BitWriter<'a, u8, UART0_MCR_SPEC, bool, O>;
        ///Field `MCR_RTS` reader - RW, UART0 control RTS
        pub type MCR_RTS_R = crate::BitReader<bool>;
        ///Field `MCR_RTS` writer - RW, UART0 control RTS
        pub type MCR_RTS_W<'a, const O: u8> = crate::BitWriter<'a, u8, UART0_MCR_SPEC, bool, O>;
        ///Field `MCR_OUT1` reader - RW, UART0 control OUT1
        pub type MCR_OUT1_R = crate::BitReader<bool>;
        ///Field `MCR_OUT1` writer - RW, UART0 control OUT1
        pub type MCR_OUT1_W<'a, const O: u8> = crate::BitWriter<'a, u8, UART0_MCR_SPEC, bool, O>;
        ///Field `MCR_OUT2__RB_MCR_INT_OE` reader - RW, UART control OUT2/ UART interrupt output enable
        pub type MCR_OUT2__RB_MCR_INT_OE_R = crate::BitReader<bool>;
        ///Field `MCR_OUT2__RB_MCR_INT_OE` writer - RW, UART control OUT2/ UART interrupt output enable
        pub type MCR_OUT2__RB_MCR_INT_OE_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, UART0_MCR_SPEC, bool, O>;
        ///Field `MCR_LOOP` reader - RW, UART0 enable local loop back
        pub type MCR_LOOP_R = crate::BitReader<bool>;
        ///Field `MCR_LOOP` writer - RW, UART0 enable local loop back
        pub type MCR_LOOP_W<'a, const O: u8> = crate::BitWriter<'a, u8, UART0_MCR_SPEC, bool, O>;
        ///Field `MCR_AU_FLOW_EN` reader - RW, UART0 enable autoflow control
        pub type MCR_AU_FLOW_EN_R = crate::BitReader<bool>;
        ///Field `MCR_AU_FLOW_EN` writer - RW, UART0 enable autoflow control
        pub type MCR_AU_FLOW_EN_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, UART0_MCR_SPEC, bool, O>;
        ///Field `MCR_TNOW` reader - RW, UART0 enable TNOW output on DTR pin
        pub type MCR_TNOW_R = crate::BitReader<bool>;
        ///Field `MCR_TNOW` writer - RW, UART0 enable TNOW output on DTR pin
        pub type MCR_TNOW_W<'a, const O: u8> = crate::BitWriter<'a, u8, UART0_MCR_SPEC, bool, O>;
        ///Field `MCR_HALF` reader - RW, UART0 enable half-duplex
        pub type MCR_HALF_R = crate::BitReader<bool>;
        ///Field `MCR_HALF` writer - RW, UART0 enable half-duplex
        pub type MCR_HALF_W<'a, const O: u8> = crate::BitWriter<'a, u8, UART0_MCR_SPEC, bool, O>;
        impl R {
            ///Bit 0 - RW, UART0 control DTR
            #[inline(always)]
            pub fn mcr_dtr(&self) -> MCR_DTR_R {
                MCR_DTR_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RW, UART0 control RTS
            #[inline(always)]
            pub fn mcr_rts(&self) -> MCR_RTS_R {
                MCR_RTS_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RW, UART0 control OUT1
            #[inline(always)]
            pub fn mcr_out1(&self) -> MCR_OUT1_R {
                MCR_OUT1_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RW, UART control OUT2/ UART interrupt output enable
            #[inline(always)]
            pub fn mcr_out2__rb_mcr_int_oe(&self) -> MCR_OUT2__RB_MCR_INT_OE_R {
                MCR_OUT2__RB_MCR_INT_OE_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RW, UART0 enable local loop back
            #[inline(always)]
            pub fn mcr_loop(&self) -> MCR_LOOP_R {
                MCR_LOOP_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - RW, UART0 enable autoflow control
            #[inline(always)]
            pub fn mcr_au_flow_en(&self) -> MCR_AU_FLOW_EN_R {
                MCR_AU_FLOW_EN_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - RW, UART0 enable TNOW output on DTR pin
            #[inline(always)]
            pub fn mcr_tnow(&self) -> MCR_TNOW_R {
                MCR_TNOW_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - RW, UART0 enable half-duplex
            #[inline(always)]
            pub fn mcr_half(&self) -> MCR_HALF_R {
                MCR_HALF_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RW, UART0 control DTR
            #[inline(always)]
            #[must_use]
            pub fn mcr_dtr(&mut self) -> MCR_DTR_W<0> {
                MCR_DTR_W::new(self)
            }
            ///Bit 1 - RW, UART0 control RTS
            #[inline(always)]
            #[must_use]
            pub fn mcr_rts(&mut self) -> MCR_RTS_W<1> {
                MCR_RTS_W::new(self)
            }
            ///Bit 2 - RW, UART0 control OUT1
            #[inline(always)]
            #[must_use]
            pub fn mcr_out1(&mut self) -> MCR_OUT1_W<2> {
                MCR_OUT1_W::new(self)
            }
            ///Bit 3 - RW, UART control OUT2/ UART interrupt output enable
            #[inline(always)]
            #[must_use]
            pub fn mcr_out2__rb_mcr_int_oe(&mut self) -> MCR_OUT2__RB_MCR_INT_OE_W<3> {
                MCR_OUT2__RB_MCR_INT_OE_W::new(self)
            }
            ///Bit 4 - RW, UART0 enable local loop back
            #[inline(always)]
            #[must_use]
            pub fn mcr_loop(&mut self) -> MCR_LOOP_W<4> {
                MCR_LOOP_W::new(self)
            }
            ///Bit 5 - RW, UART0 enable autoflow control
            #[inline(always)]
            #[must_use]
            pub fn mcr_au_flow_en(&mut self) -> MCR_AU_FLOW_EN_W<5> {
                MCR_AU_FLOW_EN_W::new(self)
            }
            ///Bit 6 - RW, UART0 enable TNOW output on DTR pin
            #[inline(always)]
            #[must_use]
            pub fn mcr_tnow(&mut self) -> MCR_TNOW_W<6> {
                MCR_TNOW_W::new(self)
            }
            ///Bit 7 - RW, UART0 enable half-duplex
            #[inline(always)]
            #[must_use]
            pub fn mcr_half(&mut self) -> MCR_HALF_W<7> {
                MCR_HALF_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, UART0 modem control
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [uart0_mcr](index.html) module
        pub struct UART0_MCR_SPEC;
        impl crate::RegisterSpec for UART0_MCR_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [uart0_mcr::R](R) reader structure
        impl crate::Readable for UART0_MCR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [uart0_mcr::W](W) writer structure
        impl crate::Writable for UART0_MCR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets UART0_MCR to value 0
        impl crate::Resettable for UART0_MCR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///UART0_IER (rw) register accessor: an alias for `Reg<UART0_IER_SPEC>`
    pub type UART0_IER = crate::Reg<uart0_ier::UART0_IER_SPEC>;
    ///RW, UART0 interrupt enable
    pub mod uart0_ier {
        ///Register `UART0_IER` reader
        pub struct R(crate::R<UART0_IER_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<UART0_IER_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<UART0_IER_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<UART0_IER_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `UART0_IER` writer
        pub struct W(crate::W<UART0_IER_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<UART0_IER_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<UART0_IER_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<UART0_IER_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IER_RECV_RDY` reader - RW, UART interrupt enable for receiver data ready
        pub type IER_RECV_RDY_R = crate::BitReader<bool>;
        ///Field `IER_RECV_RDY` writer - RW, UART interrupt enable for receiver data ready
        pub type IER_RECV_RDY_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, UART0_IER_SPEC, bool, O>;
        ///Field `IER_THR_EMPTY` reader - RW, UART interrupt enable for THR empty
        pub type IER_THR_EMPTY_R = crate::BitReader<bool>;
        ///Field `IER_THR_EMPTY` writer - RW, UART interrupt enable for THR empty
        pub type IER_THR_EMPTY_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, UART0_IER_SPEC, bool, O>;
        ///Field `IER_LINE_STAT` reader - RW, UART interrupt enable for receiver line status
        pub type IER_LINE_STAT_R = crate::BitReader<bool>;
        ///Field `IER_LINE_STAT` writer - RW, UART interrupt enable for receiver line status
        pub type IER_LINE_STAT_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, UART0_IER_SPEC, bool, O>;
        ///Field `IER_MODEM_CHG` reader - RW, UART0 interrupt enable for modem status change
        pub type IER_MODEM_CHG_R = crate::BitReader<bool>;
        ///Field `IER_MODEM_CHG` writer - RW, UART0 interrupt enable for modem status change
        pub type IER_MODEM_CHG_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, UART0_IER_SPEC, bool, O>;
        ///Field `IER_DTR_EN` reader - RW, UART0 DTR/TNOW output pin enable
        pub type IER_DTR_EN_R = crate::BitReader<bool>;
        ///Field `IER_DTR_EN` writer - RW, UART0 DTR/TNOW output pin enable
        pub type IER_DTR_EN_W<'a, const O: u8> = crate::BitWriter<'a, u8, UART0_IER_SPEC, bool, O>;
        ///Field `IER_RTS_EN` reader - RW, UART0 RTS output pin enable
        pub type IER_RTS_EN_R = crate::BitReader<bool>;
        ///Field `IER_RTS_EN` writer - RW, UART0 RTS output pin enable
        pub type IER_RTS_EN_W<'a, const O: u8> = crate::BitWriter<'a, u8, UART0_IER_SPEC, bool, O>;
        ///Field `IER_TXD_EN` reader - RW, UART TXD pin enable
        pub type IER_TXD_EN_R = crate::BitReader<bool>;
        ///Field `IER_TXD_EN` writer - RW, UART TXD pin enable
        pub type IER_TXD_EN_W<'a, const O: u8> = crate::BitWriter<'a, u8, UART0_IER_SPEC, bool, O>;
        ///Field `IER_RESET` reader - WZ, UART software reset control, high action, auto clear
        pub type IER_RESET_R = crate::BitReader<bool>;
        ///Field `IER_RESET` writer - WZ, UART software reset control, high action, auto clear
        pub type IER_RESET_W<'a, const O: u8> = crate::BitWriter<'a, u8, UART0_IER_SPEC, bool, O>;
        impl R {
            ///Bit 0 - RW, UART interrupt enable for receiver data ready
            #[inline(always)]
            pub fn ier_recv_rdy(&self) -> IER_RECV_RDY_R {
                IER_RECV_RDY_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RW, UART interrupt enable for THR empty
            #[inline(always)]
            pub fn ier_thr_empty(&self) -> IER_THR_EMPTY_R {
                IER_THR_EMPTY_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RW, UART interrupt enable for receiver line status
            #[inline(always)]
            pub fn ier_line_stat(&self) -> IER_LINE_STAT_R {
                IER_LINE_STAT_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RW, UART0 interrupt enable for modem status change
            #[inline(always)]
            pub fn ier_modem_chg(&self) -> IER_MODEM_CHG_R {
                IER_MODEM_CHG_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RW, UART0 DTR/TNOW output pin enable
            #[inline(always)]
            pub fn ier_dtr_en(&self) -> IER_DTR_EN_R {
                IER_DTR_EN_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - RW, UART0 RTS output pin enable
            #[inline(always)]
            pub fn ier_rts_en(&self) -> IER_RTS_EN_R {
                IER_RTS_EN_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - RW, UART TXD pin enable
            #[inline(always)]
            pub fn ier_txd_en(&self) -> IER_TXD_EN_R {
                IER_TXD_EN_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - WZ, UART software reset control, high action, auto clear
            #[inline(always)]
            pub fn ier_reset(&self) -> IER_RESET_R {
                IER_RESET_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RW, UART interrupt enable for receiver data ready
            #[inline(always)]
            #[must_use]
            pub fn ier_recv_rdy(&mut self) -> IER_RECV_RDY_W<0> {
                IER_RECV_RDY_W::new(self)
            }
            ///Bit 1 - RW, UART interrupt enable for THR empty
            #[inline(always)]
            #[must_use]
            pub fn ier_thr_empty(&mut self) -> IER_THR_EMPTY_W<1> {
                IER_THR_EMPTY_W::new(self)
            }
            ///Bit 2 - RW, UART interrupt enable for receiver line status
            #[inline(always)]
            #[must_use]
            pub fn ier_line_stat(&mut self) -> IER_LINE_STAT_W<2> {
                IER_LINE_STAT_W::new(self)
            }
            ///Bit 3 - RW, UART0 interrupt enable for modem status change
            #[inline(always)]
            #[must_use]
            pub fn ier_modem_chg(&mut self) -> IER_MODEM_CHG_W<3> {
                IER_MODEM_CHG_W::new(self)
            }
            ///Bit 4 - RW, UART0 DTR/TNOW output pin enable
            #[inline(always)]
            #[must_use]
            pub fn ier_dtr_en(&mut self) -> IER_DTR_EN_W<4> {
                IER_DTR_EN_W::new(self)
            }
            ///Bit 5 - RW, UART0 RTS output pin enable
            #[inline(always)]
            #[must_use]
            pub fn ier_rts_en(&mut self) -> IER_RTS_EN_W<5> {
                IER_RTS_EN_W::new(self)
            }
            ///Bit 6 - RW, UART TXD pin enable
            #[inline(always)]
            #[must_use]
            pub fn ier_txd_en(&mut self) -> IER_TXD_EN_W<6> {
                IER_TXD_EN_W::new(self)
            }
            ///Bit 7 - WZ, UART software reset control, high action, auto clear
            #[inline(always)]
            #[must_use]
            pub fn ier_reset(&mut self) -> IER_RESET_W<7> {
                IER_RESET_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, UART0 interrupt enable
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [uart0_ier](index.html) module
        pub struct UART0_IER_SPEC;
        impl crate::RegisterSpec for UART0_IER_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [uart0_ier::R](R) reader structure
        impl crate::Readable for UART0_IER_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [uart0_ier::W](W) writer structure
        impl crate::Writable for UART0_IER_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets UART0_IER to value 0
        impl crate::Resettable for UART0_IER_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///UART0_FCR (rw) register accessor: an alias for `Reg<UART0_FCR_SPEC>`
    pub type UART0_FCR = crate::Reg<uart0_fcr::UART0_FCR_SPEC>;
    ///RW, UART0 FIFO control
    pub mod uart0_fcr {
        ///Register `UART0_FCR` reader
        pub struct R(crate::R<UART0_FCR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<UART0_FCR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<UART0_FCR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<UART0_FCR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `UART0_FCR` writer
        pub struct W(crate::W<UART0_FCR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<UART0_FCR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<UART0_FCR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<UART0_FCR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `FCR_FIFO_EN` reader - RW, UART FIFO enable
        pub type FCR_FIFO_EN_R = crate::BitReader<bool>;
        ///Field `FCR_FIFO_EN` writer - RW, UART FIFO enable
        pub type FCR_FIFO_EN_W<'a, const O: u8> = crate::BitWriter<'a, u8, UART0_FCR_SPEC, bool, O>;
        ///Field `FCR_RX_FIFO_CLR` reader - WZ, clear UART receiver FIFO, high action, auto clear
        pub type FCR_RX_FIFO_CLR_R = crate::BitReader<bool>;
        ///Field `FCR_RX_FIFO_CLR` writer - WZ, clear UART receiver FIFO, high action, auto clear
        pub type FCR_RX_FIFO_CLR_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, UART0_FCR_SPEC, bool, O>;
        ///Field `FCR_TX_FIFO_CLR` reader - WZ, clear UART transmitter FIFO, high action, auto clear
        pub type FCR_TX_FIFO_CLR_R = crate::BitReader<bool>;
        ///Field `FCR_TX_FIFO_CLR` writer - WZ, clear UART transmitter FIFO, high action, auto clear
        pub type FCR_TX_FIFO_CLR_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, UART0_FCR_SPEC, bool, O>;
        ///Field `FCR_FIFO_TRIG` reader - RW, UART receiver FIFO trigger level: 00-1byte, 01-2bytes, 10-4bytes, 11-7bytes
        pub type FCR_FIFO_TRIG_R = crate::FieldReader<u8, u8>;
        ///Field `FCR_FIFO_TRIG` writer - RW, UART receiver FIFO trigger level: 00-1byte, 01-2bytes, 10-4bytes, 11-7bytes
        pub type FCR_FIFO_TRIG_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, UART0_FCR_SPEC, u8, u8, 2, O>;
        impl R {
            ///Bit 0 - RW, UART FIFO enable
            #[inline(always)]
            pub fn fcr_fifo_en(&self) -> FCR_FIFO_EN_R {
                FCR_FIFO_EN_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - WZ, clear UART receiver FIFO, high action, auto clear
            #[inline(always)]
            pub fn fcr_rx_fifo_clr(&self) -> FCR_RX_FIFO_CLR_R {
                FCR_RX_FIFO_CLR_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - WZ, clear UART transmitter FIFO, high action, auto clear
            #[inline(always)]
            pub fn fcr_tx_fifo_clr(&self) -> FCR_TX_FIFO_CLR_R {
                FCR_TX_FIFO_CLR_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bits 6:7 - RW, UART receiver FIFO trigger level: 00-1byte, 01-2bytes, 10-4bytes, 11-7bytes
            #[inline(always)]
            pub fn fcr_fifo_trig(&self) -> FCR_FIFO_TRIG_R {
                FCR_FIFO_TRIG_R::new((self.bits >> 6) & 3)
            }
        }
        impl W {
            ///Bit 0 - RW, UART FIFO enable
            #[inline(always)]
            #[must_use]
            pub fn fcr_fifo_en(&mut self) -> FCR_FIFO_EN_W<0> {
                FCR_FIFO_EN_W::new(self)
            }
            ///Bit 1 - WZ, clear UART receiver FIFO, high action, auto clear
            #[inline(always)]
            #[must_use]
            pub fn fcr_rx_fifo_clr(&mut self) -> FCR_RX_FIFO_CLR_W<1> {
                FCR_RX_FIFO_CLR_W::new(self)
            }
            ///Bit 2 - WZ, clear UART transmitter FIFO, high action, auto clear
            #[inline(always)]
            #[must_use]
            pub fn fcr_tx_fifo_clr(&mut self) -> FCR_TX_FIFO_CLR_W<2> {
                FCR_TX_FIFO_CLR_W::new(self)
            }
            ///Bits 6:7 - RW, UART receiver FIFO trigger level: 00-1byte, 01-2bytes, 10-4bytes, 11-7bytes
            #[inline(always)]
            #[must_use]
            pub fn fcr_fifo_trig(&mut self) -> FCR_FIFO_TRIG_W<6> {
                FCR_FIFO_TRIG_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, UART0 FIFO control
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [uart0_fcr](index.html) module
        pub struct UART0_FCR_SPEC;
        impl crate::RegisterSpec for UART0_FCR_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [uart0_fcr::R](R) reader structure
        impl crate::Readable for UART0_FCR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [uart0_fcr::W](W) writer structure
        impl crate::Writable for UART0_FCR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets UART0_FCR to value 0
        impl crate::Resettable for UART0_FCR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///UART0_LCR (rw) register accessor: an alias for `Reg<UART0_LCR_SPEC>`
    pub type UART0_LCR = crate::Reg<uart0_lcr::UART0_LCR_SPEC>;
    ///RW, UART0 line control
    pub mod uart0_lcr {
        ///Register `UART0_LCR` reader
        pub struct R(crate::R<UART0_LCR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<UART0_LCR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<UART0_LCR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<UART0_LCR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `UART0_LCR` writer
        pub struct W(crate::W<UART0_LCR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<UART0_LCR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<UART0_LCR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<UART0_LCR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `LCR_WORD_SZ` reader - RW, UART word bit length: 00-5bit, 01-6bit, 10-7bit, 11-8bit
        pub type LCR_WORD_SZ_R = crate::FieldReader<u8, u8>;
        ///Field `LCR_WORD_SZ` writer - RW, UART word bit length: 00-5bit, 01-6bit, 10-7bit, 11-8bit
        pub type LCR_WORD_SZ_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, UART0_LCR_SPEC, u8, u8, 2, O>;
        ///Field `LCR_STOP_BIT` reader - RW, UART stop bit length: 0-1bit, 1-2bit
        pub type LCR_STOP_BIT_R = crate::BitReader<bool>;
        ///Field `LCR_STOP_BIT` writer - RW, UART stop bit length: 0-1bit, 1-2bit
        pub type LCR_STOP_BIT_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, UART0_LCR_SPEC, bool, O>;
        ///Field `LCR_PAR_EN` reader - RW, UART parity enable
        pub type LCR_PAR_EN_R = crate::BitReader<bool>;
        ///Field `LCR_PAR_EN` writer - RW, UART parity enable
        pub type LCR_PAR_EN_W<'a, const O: u8> = crate::BitWriter<'a, u8, UART0_LCR_SPEC, bool, O>;
        ///Field `LCR_PAR_MOD` reader - RW, UART parity mode: 00-odd, 01-even, 10-mark, 11-space
        pub type LCR_PAR_MOD_R = crate::FieldReader<u8, u8>;
        ///Field `LCR_PAR_MOD` writer - RW, UART parity mode: 00-odd, 01-even, 10-mark, 11-space
        pub type LCR_PAR_MOD_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, UART0_LCR_SPEC, u8, u8, 2, O>;
        ///Field `LCR_BREAK_EN` reader - RW, UART break control enable
        pub type LCR_BREAK_EN_R = crate::BitReader<bool>;
        ///Field `LCR_BREAK_EN` writer - RW, UART break control enable
        pub type LCR_BREAK_EN_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, UART0_LCR_SPEC, bool, O>;
        ///Field `LCR_GP_BIT__RB_LCR_DLAB` reader - RW, UART general purpose bit;RW, UART reserved bit
        pub type LCR_GP_BIT__RB_LCR_DLAB_R = crate::BitReader<bool>;
        ///Field `LCR_GP_BIT__RB_LCR_DLAB` writer - RW, UART general purpose bit;RW, UART reserved bit
        pub type LCR_GP_BIT__RB_LCR_DLAB_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, UART0_LCR_SPEC, bool, O>;
        impl R {
            ///Bits 0:1 - RW, UART word bit length: 00-5bit, 01-6bit, 10-7bit, 11-8bit
            #[inline(always)]
            pub fn lcr_word_sz(&self) -> LCR_WORD_SZ_R {
                LCR_WORD_SZ_R::new(self.bits & 3)
            }
            ///Bit 2 - RW, UART stop bit length: 0-1bit, 1-2bit
            #[inline(always)]
            pub fn lcr_stop_bit(&self) -> LCR_STOP_BIT_R {
                LCR_STOP_BIT_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RW, UART parity enable
            #[inline(always)]
            pub fn lcr_par_en(&self) -> LCR_PAR_EN_R {
                LCR_PAR_EN_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bits 4:5 - RW, UART parity mode: 00-odd, 01-even, 10-mark, 11-space
            #[inline(always)]
            pub fn lcr_par_mod(&self) -> LCR_PAR_MOD_R {
                LCR_PAR_MOD_R::new((self.bits >> 4) & 3)
            }
            ///Bit 6 - RW, UART break control enable
            #[inline(always)]
            pub fn lcr_break_en(&self) -> LCR_BREAK_EN_R {
                LCR_BREAK_EN_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - RW, UART general purpose bit;RW, UART reserved bit
            #[inline(always)]
            pub fn lcr_gp_bit__rb_lcr_dlab(&self) -> LCR_GP_BIT__RB_LCR_DLAB_R {
                LCR_GP_BIT__RB_LCR_DLAB_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:1 - RW, UART word bit length: 00-5bit, 01-6bit, 10-7bit, 11-8bit
            #[inline(always)]
            #[must_use]
            pub fn lcr_word_sz(&mut self) -> LCR_WORD_SZ_W<0> {
                LCR_WORD_SZ_W::new(self)
            }
            ///Bit 2 - RW, UART stop bit length: 0-1bit, 1-2bit
            #[inline(always)]
            #[must_use]
            pub fn lcr_stop_bit(&mut self) -> LCR_STOP_BIT_W<2> {
                LCR_STOP_BIT_W::new(self)
            }
            ///Bit 3 - RW, UART parity enable
            #[inline(always)]
            #[must_use]
            pub fn lcr_par_en(&mut self) -> LCR_PAR_EN_W<3> {
                LCR_PAR_EN_W::new(self)
            }
            ///Bits 4:5 - RW, UART parity mode: 00-odd, 01-even, 10-mark, 11-space
            #[inline(always)]
            #[must_use]
            pub fn lcr_par_mod(&mut self) -> LCR_PAR_MOD_W<4> {
                LCR_PAR_MOD_W::new(self)
            }
            ///Bit 6 - RW, UART break control enable
            #[inline(always)]
            #[must_use]
            pub fn lcr_break_en(&mut self) -> LCR_BREAK_EN_W<6> {
                LCR_BREAK_EN_W::new(self)
            }
            ///Bit 7 - RW, UART general purpose bit;RW, UART reserved bit
            #[inline(always)]
            #[must_use]
            pub fn lcr_gp_bit__rb_lcr_dlab(&mut self) -> LCR_GP_BIT__RB_LCR_DLAB_W<7> {
                LCR_GP_BIT__RB_LCR_DLAB_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, UART0 line control
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [uart0_lcr](index.html) module
        pub struct UART0_LCR_SPEC;
        impl crate::RegisterSpec for UART0_LCR_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [uart0_lcr::R](R) reader structure
        impl crate::Readable for UART0_LCR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [uart0_lcr::W](W) writer structure
        impl crate::Writable for UART0_LCR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets UART0_LCR to value 0
        impl crate::Resettable for UART0_LCR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///UART0_IIR (r) register accessor: an alias for `Reg<UART0_IIR_SPEC>`
    pub type UART0_IIR = crate::Reg<uart0_iir::UART0_IIR_SPEC>;
    ///RO, UART0 interrupt identification
    pub mod uart0_iir {
        ///Register `UART0_IIR` reader
        pub struct R(crate::R<UART0_IIR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<UART0_IIR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<UART0_IIR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<UART0_IIR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `IIR_NO_INT` reader - RO, UART no interrupt flag: 0=interrupt action, 1=no interrupt
        pub type IIR_NO_INT_R = crate::BitReader<bool>;
        ///Field `IIR_INT_MASK` reader - RO, UART interrupt flag bit mask
        pub type IIR_INT_MASK_R = crate::FieldReader<u8, u8>;
        ///Field `IIR_FIFO_ID` reader - RO, UART FIFO enabled flag
        pub type IIR_FIFO_ID_R = crate::FieldReader<u8, u8>;
        impl R {
            ///Bit 0 - RO, UART no interrupt flag: 0=interrupt action, 1=no interrupt
            #[inline(always)]
            pub fn iir_no_int(&self) -> IIR_NO_INT_R {
                IIR_NO_INT_R::new((self.bits & 1) != 0)
            }
            ///Bits 0:3 - RO, UART interrupt flag bit mask
            #[inline(always)]
            pub fn iir_int_mask(&self) -> IIR_INT_MASK_R {
                IIR_INT_MASK_R::new(self.bits & 0x0f)
            }
            ///Bits 6:7 - RO, UART FIFO enabled flag
            #[inline(always)]
            pub fn iir_fifo_id(&self) -> IIR_FIFO_ID_R {
                IIR_FIFO_ID_R::new((self.bits >> 6) & 3)
            }
        }
        ///RO, UART0 interrupt identification
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [uart0_iir](index.html) module
        pub struct UART0_IIR_SPEC;
        impl crate::RegisterSpec for UART0_IIR_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [uart0_iir::R](R) reader structure
        impl crate::Readable for UART0_IIR_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets UART0_IIR to value 0x01
        impl crate::Resettable for UART0_IIR_SPEC {
            const RESET_VALUE: Self::Ux = 0x01;
        }
    }
    ///UART0_LSR (r) register accessor: an alias for `Reg<UART0_LSR_SPEC>`
    pub type UART0_LSR = crate::Reg<uart0_lsr::UART0_LSR_SPEC>;
    ///RO, UART0 line status
    pub mod uart0_lsr {
        ///Register `UART0_LSR` reader
        pub struct R(crate::R<UART0_LSR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<UART0_LSR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<UART0_LSR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<UART0_LSR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `LSR_DATA_RDY` reader - RO, UART receiver fifo data ready status
        pub type LSR_DATA_RDY_R = crate::BitReader<bool>;
        ///Field `LSR_OVER_ERR` reader - RZ, UART receiver overrun error
        pub type LSR_OVER_ERR_R = crate::BitReader<bool>;
        ///Field `LSR_PAR_ERR` reader - RZ, UART receiver parity error
        pub type LSR_PAR_ERR_R = crate::BitReader<bool>;
        ///Field `LSR_FRAME_ERR` reader - RZ, UART receiver frame error
        pub type LSR_FRAME_ERR_R = crate::BitReader<bool>;
        ///Field `LSR_BREAK_ERR` reader - RZ, UART receiver break error
        pub type LSR_BREAK_ERR_R = crate::BitReader<bool>;
        ///Field `LSR_TX_FIFO_EMP` reader - RO, UART transmitter fifo empty status
        pub type LSR_TX_FIFO_EMP_R = crate::BitReader<bool>;
        ///Field `LSR_TX_ALL_EMP` reader - RO, UART transmitter all empty status
        pub type LSR_TX_ALL_EMP_R = crate::BitReader<bool>;
        ///Field `LSR_ERR_RX_FIFO` reader - RO, indicate error in UART receiver fifo
        pub type LSR_ERR_RX_FIFO_R = crate::BitReader<bool>;
        impl R {
            ///Bit 0 - RO, UART receiver fifo data ready status
            #[inline(always)]
            pub fn lsr_data_rdy(&self) -> LSR_DATA_RDY_R {
                LSR_DATA_RDY_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RZ, UART receiver overrun error
            #[inline(always)]
            pub fn lsr_over_err(&self) -> LSR_OVER_ERR_R {
                LSR_OVER_ERR_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RZ, UART receiver parity error
            #[inline(always)]
            pub fn lsr_par_err(&self) -> LSR_PAR_ERR_R {
                LSR_PAR_ERR_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RZ, UART receiver frame error
            #[inline(always)]
            pub fn lsr_frame_err(&self) -> LSR_FRAME_ERR_R {
                LSR_FRAME_ERR_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RZ, UART receiver break error
            #[inline(always)]
            pub fn lsr_break_err(&self) -> LSR_BREAK_ERR_R {
                LSR_BREAK_ERR_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - RO, UART transmitter fifo empty status
            #[inline(always)]
            pub fn lsr_tx_fifo_emp(&self) -> LSR_TX_FIFO_EMP_R {
                LSR_TX_FIFO_EMP_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - RO, UART transmitter all empty status
            #[inline(always)]
            pub fn lsr_tx_all_emp(&self) -> LSR_TX_ALL_EMP_R {
                LSR_TX_ALL_EMP_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - RO, indicate error in UART receiver fifo
            #[inline(always)]
            pub fn lsr_err_rx_fifo(&self) -> LSR_ERR_RX_FIFO_R {
                LSR_ERR_RX_FIFO_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        ///RO, UART0 line status
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [uart0_lsr](index.html) module
        pub struct UART0_LSR_SPEC;
        impl crate::RegisterSpec for UART0_LSR_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [uart0_lsr::R](R) reader structure
        impl crate::Readable for UART0_LSR_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets UART0_LSR to value 0x60
        impl crate::Resettable for UART0_LSR_SPEC {
            const RESET_VALUE: Self::Ux = 0x60;
        }
    }
    ///UART0_MSR (r) register accessor: an alias for `Reg<UART0_MSR_SPEC>`
    pub type UART0_MSR = crate::Reg<uart0_msr::UART0_MSR_SPEC>;
    ///RO, UART0 modem status
    pub mod uart0_msr {
        ///Register `UART0_MSR` reader
        pub struct R(crate::R<UART0_MSR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<UART0_MSR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<UART0_MSR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<UART0_MSR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `MSR_CTS_CHG` reader - RZ, UART0 CTS changed status, high action
        pub type MSR_CTS_CHG_R = crate::BitReader<bool>;
        ///Field `MSR_DSR_CHG` reader - RZ, UART0 DSR changed status, high action
        pub type MSR_DSR_CHG_R = crate::BitReader<bool>;
        ///Field `MSR_RI_CHG` reader - RZ, UART0 RI changed status, high action
        pub type MSR_RI_CHG_R = crate::BitReader<bool>;
        ///Field `MSR_DCD_CHG` reader - RZ, UART0 DCD changed status, high action
        pub type MSR_DCD_CHG_R = crate::BitReader<bool>;
        ///Field `MSR_CTS` reader - RO, UART0 CTS action status
        pub type MSR_CTS_R = crate::BitReader<bool>;
        ///Field `MSR_DSR` reader - RO, UART0 DSR action statusv
        pub type MSR_DSR_R = crate::BitReader<bool>;
        ///Field `MSR_RI` reader - RO, UART0 RI action status
        pub type MSR_RI_R = crate::BitReader<bool>;
        ///Field `MSR_DCD` reader - RO, UART0 DCD action status
        pub type MSR_DCD_R = crate::BitReader<bool>;
        impl R {
            ///Bit 0 - RZ, UART0 CTS changed status, high action
            #[inline(always)]
            pub fn msr_cts_chg(&self) -> MSR_CTS_CHG_R {
                MSR_CTS_CHG_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RZ, UART0 DSR changed status, high action
            #[inline(always)]
            pub fn msr_dsr_chg(&self) -> MSR_DSR_CHG_R {
                MSR_DSR_CHG_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RZ, UART0 RI changed status, high action
            #[inline(always)]
            pub fn msr_ri_chg(&self) -> MSR_RI_CHG_R {
                MSR_RI_CHG_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RZ, UART0 DCD changed status, high action
            #[inline(always)]
            pub fn msr_dcd_chg(&self) -> MSR_DCD_CHG_R {
                MSR_DCD_CHG_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RO, UART0 CTS action status
            #[inline(always)]
            pub fn msr_cts(&self) -> MSR_CTS_R {
                MSR_CTS_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - RO, UART0 DSR action statusv
            #[inline(always)]
            pub fn msr_dsr(&self) -> MSR_DSR_R {
                MSR_DSR_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - RO, UART0 RI action status
            #[inline(always)]
            pub fn msr_ri(&self) -> MSR_RI_R {
                MSR_RI_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - RO, UART0 DCD action status
            #[inline(always)]
            pub fn msr_dcd(&self) -> MSR_DCD_R {
                MSR_DCD_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        ///RO, UART0 modem status
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [uart0_msr](index.html) module
        pub struct UART0_MSR_SPEC;
        impl crate::RegisterSpec for UART0_MSR_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [uart0_msr::R](R) reader structure
        impl crate::Readable for UART0_MSR_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets UART0_MSR to value 0
        impl crate::Resettable for UART0_MSR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///UART0_RBR (r) register accessor: an alias for `Reg<UART0_RBR_SPEC>`
    pub type UART0_RBR = crate::Reg<uart0_rbr::UART0_RBR_SPEC>;
    ///RO, UART0 receiver buffer, receiving byte
    pub mod uart0_rbr {
        ///Register `UART0_RBR` reader
        pub struct R(crate::R<UART0_RBR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<UART0_RBR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<UART0_RBR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<UART0_RBR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `UART0_RBR` reader - RO, UART0 receiver buffer, receiving byte
        pub type UART0_RBR_R = crate::FieldReader<u8, u8>;
        impl R {
            ///Bits 0:7 - RO, UART0 receiver buffer, receiving byte
            #[inline(always)]
            pub fn uart0_rbr(&self) -> UART0_RBR_R {
                UART0_RBR_R::new(self.bits)
            }
        }
        ///RO, UART0 receiver buffer, receiving byte
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [uart0_rbr](index.html) module
        pub struct UART0_RBR_SPEC;
        impl crate::RegisterSpec for UART0_RBR_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [uart0_rbr::R](R) reader structure
        impl crate::Readable for UART0_RBR_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets UART0_RBR to value 0
        impl crate::Resettable for UART0_RBR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///UART0_THR (w) register accessor: an alias for `Reg<UART0_THR_SPEC>`
    pub type UART0_THR = crate::Reg<uart0_thr::UART0_THR_SPEC>;
    ///WO, UART0 transmitter holding, transmittal byte
    pub mod uart0_thr {
        ///Register `UART0_THR` writer
        pub struct W(crate::W<UART0_THR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<UART0_THR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<UART0_THR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<UART0_THR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `UART0_THR` writer - RO, UART0 transmitter holding, transmittal byte
        pub type UART0_THR_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, UART0_THR_SPEC, u8, u8, 8, O>;
        impl W {
            ///Bits 0:7 - RO, UART0 transmitter holding, transmittal byte
            #[inline(always)]
            #[must_use]
            pub fn uart0_thr(&mut self) -> UART0_THR_W<0> {
                UART0_THR_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///WO, UART0 transmitter holding, transmittal byte
        ///
        ///This register you can [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [uart0_thr](index.html) module
        pub struct UART0_THR_SPEC;
        impl crate::RegisterSpec for UART0_THR_SPEC {
            type Ux = u8;
        }
        ///`write(|w| ..)` method takes [uart0_thr::W](W) writer structure
        impl crate::Writable for UART0_THR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets UART0_THR to value 0
        impl crate::Resettable for UART0_THR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///UART0_RFC (r) register accessor: an alias for `Reg<UART0_RFC_SPEC>`
    pub type UART0_RFC = crate::Reg<uart0_rfc::UART0_RFC_SPEC>;
    ///RO, UART0 receiver FIFO count
    pub mod uart0_rfc {
        ///Register `UART0_RFC` reader
        pub struct R(crate::R<UART0_RFC_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<UART0_RFC_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<UART0_RFC_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<UART0_RFC_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `UART0_RFC` reader - RO, UART0 receiver FIFO count
        pub type UART0_RFC_R = crate::FieldReader<u8, u8>;
        impl R {
            ///Bits 0:7 - RO, UART0 receiver FIFO count
            #[inline(always)]
            pub fn uart0_rfc(&self) -> UART0_RFC_R {
                UART0_RFC_R::new(self.bits)
            }
        }
        ///RO, UART0 receiver FIFO count
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [uart0_rfc](index.html) module
        pub struct UART0_RFC_SPEC;
        impl crate::RegisterSpec for UART0_RFC_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [uart0_rfc::R](R) reader structure
        impl crate::Readable for UART0_RFC_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets UART0_RFC to value 0
        impl crate::Resettable for UART0_RFC_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///UART0_TFC (r) register accessor: an alias for `Reg<UART0_TFC_SPEC>`
    pub type UART0_TFC = crate::Reg<uart0_tfc::UART0_TFC_SPEC>;
    ///RO, UART0 transmitter FIFO count
    pub mod uart0_tfc {
        ///Register `UART0_TFC` reader
        pub struct R(crate::R<UART0_TFC_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<UART0_TFC_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<UART0_TFC_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<UART0_TFC_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `UART0_TFC` reader - RO, UART0 transmitter FIFO count
        pub type UART0_TFC_R = crate::FieldReader<u8, u8>;
        impl R {
            ///Bits 0:7 - RO, UART0 transmitter FIFO count
            #[inline(always)]
            pub fn uart0_tfc(&self) -> UART0_TFC_R {
                UART0_TFC_R::new(self.bits)
            }
        }
        ///RO, UART0 transmitter FIFO count
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [uart0_tfc](index.html) module
        pub struct UART0_TFC_SPEC;
        impl crate::RegisterSpec for UART0_TFC_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [uart0_tfc::R](R) reader structure
        impl crate::Readable for UART0_TFC_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets UART0_TFC to value 0
        impl crate::Resettable for UART0_TFC_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///UART0_DL (rw) register accessor: an alias for `Reg<UART0_DL_SPEC>`
    pub type UART0_DL = crate::Reg<uart0_dl::UART0_DL_SPEC>;
    ///RW, UART0 divisor latch
    pub mod uart0_dl {
        ///Register `UART0_DL` reader
        pub struct R(crate::R<UART0_DL_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<UART0_DL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<UART0_DL_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<UART0_DL_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `UART0_DL` writer
        pub struct W(crate::W<UART0_DL_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<UART0_DL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<UART0_DL_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<UART0_DL_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `UART0_DL` reader - RW, UART0 divisor latch
        pub type UART0_DL_R = crate::FieldReader<u16, u16>;
        ///Field `UART0_DL` writer - RW, UART0 divisor latch
        pub type UART0_DL_W<'a, const O: u8> =
            crate::FieldWriter<'a, u16, UART0_DL_SPEC, u16, u16, 16, O>;
        impl R {
            ///Bits 0:15 - RW, UART0 divisor latch
            #[inline(always)]
            pub fn uart0_dl(&self) -> UART0_DL_R {
                UART0_DL_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - RW, UART0 divisor latch
            #[inline(always)]
            #[must_use]
            pub fn uart0_dl(&mut self) -> UART0_DL_W<0> {
                UART0_DL_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, UART0 divisor latch
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [uart0_dl](index.html) module
        pub struct UART0_DL_SPEC;
        impl crate::RegisterSpec for UART0_DL_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [uart0_dl::R](R) reader structure
        impl crate::Readable for UART0_DL_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [uart0_dl::W](W) writer structure
        impl crate::Writable for UART0_DL_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets UART0_DL to value 0
        impl crate::Resettable for UART0_DL_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///UART0_DIV (rw) register accessor: an alias for `Reg<UART0_DIV_SPEC>`
    pub type UART0_DIV = crate::Reg<uart0_div::UART0_DIV_SPEC>;
    ///RW, UART0 pre-divisor latch byte, only low 7 bit, from 1 to 0/128
    pub mod uart0_div {
        ///Register `UART0_DIV` reader
        pub struct R(crate::R<UART0_DIV_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<UART0_DIV_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<UART0_DIV_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<UART0_DIV_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `UART0_DIV` writer
        pub struct W(crate::W<UART0_DIV_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<UART0_DIV_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<UART0_DIV_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<UART0_DIV_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `UART0_DIV` reader - RW,UART0 pre-divisor latch byte, only low 7 bit, from 1 to 0/128
        pub type UART0_DIV_R = crate::FieldReader<u8, u8>;
        ///Field `UART0_DIV` writer - RW,UART0 pre-divisor latch byte, only low 7 bit, from 1 to 0/128
        pub type UART0_DIV_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, UART0_DIV_SPEC, u8, u8, 8, O>;
        impl R {
            ///Bits 0:7 - RW,UART0 pre-divisor latch byte, only low 7 bit, from 1 to 0/128
            #[inline(always)]
            pub fn uart0_div(&self) -> UART0_DIV_R {
                UART0_DIV_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:7 - RW,UART0 pre-divisor latch byte, only low 7 bit, from 1 to 0/128
            #[inline(always)]
            #[must_use]
            pub fn uart0_div(&mut self) -> UART0_DIV_W<0> {
                UART0_DIV_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, UART0 pre-divisor latch byte, only low 7 bit, from 1 to 0/128
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [uart0_div](index.html) module
        pub struct UART0_DIV_SPEC;
        impl crate::RegisterSpec for UART0_DIV_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [uart0_div::R](R) reader structure
        impl crate::Readable for UART0_DIV_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [uart0_div::W](W) writer structure
        impl crate::Writable for UART0_DIV_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets UART0_DIV to value 0
        impl crate::Resettable for UART0_DIV_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///UART0_ADR (rw) register accessor: an alias for `Reg<UART0_ADR_SPEC>`
    pub type UART0_ADR = crate::Reg<uart0_adr::UART0_ADR_SPEC>;
    ///RW, UART0 slave address: 0xFF=disable, other=enable
    pub mod uart0_adr {
        ///Register `UART0_ADR` reader
        pub struct R(crate::R<UART0_ADR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<UART0_ADR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<UART0_ADR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<UART0_ADR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `UART0_ADR` writer
        pub struct W(crate::W<UART0_ADR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<UART0_ADR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<UART0_ADR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<UART0_ADR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `UART0_ADR` reader - RW,UART0 slave address: 0xFF=disable, other=enable
        pub type UART0_ADR_R = crate::FieldReader<u8, u8>;
        ///Field `UART0_ADR` writer - RW,UART0 slave address: 0xFF=disable, other=enable
        pub type UART0_ADR_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, UART0_ADR_SPEC, u8, u8, 8, O>;
        impl R {
            ///Bits 0:7 - RW,UART0 slave address: 0xFF=disable, other=enable
            #[inline(always)]
            pub fn uart0_adr(&self) -> UART0_ADR_R {
                UART0_ADR_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:7 - RW,UART0 slave address: 0xFF=disable, other=enable
            #[inline(always)]
            #[must_use]
            pub fn uart0_adr(&mut self) -> UART0_ADR_W<0> {
                UART0_ADR_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, UART0 slave address: 0xFF=disable, other=enable
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [uart0_adr](index.html) module
        pub struct UART0_ADR_SPEC;
        impl crate::RegisterSpec for UART0_ADR_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [uart0_adr::R](R) reader structure
        impl crate::Readable for UART0_ADR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [uart0_adr::W](W) writer structure
        impl crate::Writable for UART0_ADR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets UART0_ADR to value 0xff
        impl crate::Resettable for UART0_ADR_SPEC {
            const RESET_VALUE: Self::Ux = 0xff;
        }
    }
}
///UART1 register
pub struct UART1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for UART1 {}
impl UART1 {
    ///Pointer to the register block
    pub const PTR: *const uart1::RegisterBlock = 0x4000_3400 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const uart1::RegisterBlock {
        Self::PTR
    }
}
impl Deref for UART1 {
    type Target = uart1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for UART1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("UART1").finish()
    }
}
///UART1 register
pub mod uart1 {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        ///0x00 - RW, UART1 modem control
        pub uart1_mcr: UART1_MCR,
        ///0x01 - RW, UART1 interrupt enable
        pub uart1_ier: UART1_IER,
        ///0x02 - RW, UART1 FIFO control
        pub uart1_fcr: UART1_FCR,
        ///0x03 - RW, UART1 line control
        pub uart1_lcr: UART1_LCR,
        ///0x04 - RO, UART1 interrupt identification
        pub uart1_iir: UART1_IIR,
        ///0x05 - RO, UART1 line status
        pub uart1_lsr: UART1_LSR,
        _reserved6: [u8; 0x02],
        _reserved_6_uart1: [u8; 0x01],
        _reserved7: [u8; 0x01],
        ///0x0a - RO, UART1 receiver FIFO count
        pub uart1_rfc: UART1_RFC,
        ///0x0b - RO, UART1 transmitter FIFO count
        pub uart1_tfc: UART1_TFC,
        ///0x0c - RW, UART1 divisor latch
        pub uart1_dl: UART1_DL,
        ///0x0e - RW, UART1 pre-divisor latch byte, only low 7 bit, from 1 to 128
        pub uart1_div: UART1_DIV,
    }
    impl RegisterBlock {
        ///0x08 - WO, UART1 transmitter holding, transmittal byte
        #[inline(always)]
        pub const fn uart1_thr(&self) -> &UART1_THR {
            unsafe { &*(self as *const Self).cast::<u8>().add(8usize).cast() }
        }
        ///0x08 - RO, UART1 receiver buffer, receiving byte
        #[inline(always)]
        pub const fn uart1_rbr(&self) -> &UART1_RBR {
            unsafe { &*(self as *const Self).cast::<u8>().add(8usize).cast() }
        }
    }
    ///UART1_MCR (rw) register accessor: an alias for `Reg<UART1_MCR_SPEC>`
    pub type UART1_MCR = crate::Reg<uart1_mcr::UART1_MCR_SPEC>;
    ///RW, UART1 modem control
    pub mod uart1_mcr {
        ///Register `UART1_MCR` reader
        pub struct R(crate::R<UART1_MCR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<UART1_MCR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<UART1_MCR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<UART1_MCR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `UART1_MCR` writer
        pub struct W(crate::W<UART1_MCR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<UART1_MCR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<UART1_MCR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<UART1_MCR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `MCR_OUT2__RB_MCR_INT_OE` reader - RW, UART control OUT2/UART interrupt output enable
        pub type MCR_OUT2__RB_MCR_INT_OE_R = crate::BitReader<bool>;
        ///Field `MCR_OUT2__RB_MCR_INT_OE` writer - RW, UART control OUT2/UART interrupt output enable
        pub type MCR_OUT2__RB_MCR_INT_OE_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, UART1_MCR_SPEC, bool, O>;
        impl R {
            ///Bit 3 - RW, UART control OUT2/UART interrupt output enable
            #[inline(always)]
            pub fn mcr_out2__rb_mcr_int_oe(&self) -> MCR_OUT2__RB_MCR_INT_OE_R {
                MCR_OUT2__RB_MCR_INT_OE_R::new(((self.bits >> 3) & 1) != 0)
            }
        }
        impl W {
            ///Bit 3 - RW, UART control OUT2/UART interrupt output enable
            #[inline(always)]
            #[must_use]
            pub fn mcr_out2__rb_mcr_int_oe(&mut self) -> MCR_OUT2__RB_MCR_INT_OE_W<3> {
                MCR_OUT2__RB_MCR_INT_OE_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, UART1 modem control
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [uart1_mcr](index.html) module
        pub struct UART1_MCR_SPEC;
        impl crate::RegisterSpec for UART1_MCR_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [uart1_mcr::R](R) reader structure
        impl crate::Readable for UART1_MCR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [uart1_mcr::W](W) writer structure
        impl crate::Writable for UART1_MCR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets UART1_MCR to value 0
        impl crate::Resettable for UART1_MCR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///UART1_IER (rw) register accessor: an alias for `Reg<UART1_IER_SPEC>`
    pub type UART1_IER = crate::Reg<uart1_ier::UART1_IER_SPEC>;
    ///RW, UART1 interrupt enable
    pub mod uart1_ier {
        ///Register `UART1_IER` reader
        pub struct R(crate::R<UART1_IER_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<UART1_IER_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<UART1_IER_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<UART1_IER_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `UART1_IER` writer
        pub struct W(crate::W<UART1_IER_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<UART1_IER_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<UART1_IER_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<UART1_IER_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IER_RECV_RDY` reader - RW, UART interrupt enable for receiver data ready
        pub type IER_RECV_RDY_R = crate::BitReader<bool>;
        ///Field `IER_RECV_RDY` writer - RW, UART interrupt enable for receiver data ready
        pub type IER_RECV_RDY_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, UART1_IER_SPEC, bool, O>;
        ///Field `IER_THR_EMPTY` reader - RW, UART interrupt enable for THR empty
        pub type IER_THR_EMPTY_R = crate::BitReader<bool>;
        ///Field `IER_THR_EMPTY` writer - RW, UART interrupt enable for THR empty
        pub type IER_THR_EMPTY_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, UART1_IER_SPEC, bool, O>;
        ///Field `IER_LINE_STAT` reader - RW, UART interrupt enable for receiver line status
        pub type IER_LINE_STAT_R = crate::BitReader<bool>;
        ///Field `IER_LINE_STAT` writer - RW, UART interrupt enable for receiver line status
        pub type IER_LINE_STAT_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, UART1_IER_SPEC, bool, O>;
        ///Field `IER_TXD_EN` reader - RW, UART TXD pin enable
        pub type IER_TXD_EN_R = crate::BitReader<bool>;
        ///Field `IER_TXD_EN` writer - RW, UART TXD pin enable
        pub type IER_TXD_EN_W<'a, const O: u8> = crate::BitWriter<'a, u8, UART1_IER_SPEC, bool, O>;
        ///Field `IER_RESET` reader - WZ, UART software reset control, high action, auto clear
        pub type IER_RESET_R = crate::BitReader<bool>;
        ///Field `IER_RESET` writer - WZ, UART software reset control, high action, auto clear
        pub type IER_RESET_W<'a, const O: u8> = crate::BitWriter<'a, u8, UART1_IER_SPEC, bool, O>;
        impl R {
            ///Bit 0 - RW, UART interrupt enable for receiver data ready
            #[inline(always)]
            pub fn ier_recv_rdy(&self) -> IER_RECV_RDY_R {
                IER_RECV_RDY_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RW, UART interrupt enable for THR empty
            #[inline(always)]
            pub fn ier_thr_empty(&self) -> IER_THR_EMPTY_R {
                IER_THR_EMPTY_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RW, UART interrupt enable for receiver line status
            #[inline(always)]
            pub fn ier_line_stat(&self) -> IER_LINE_STAT_R {
                IER_LINE_STAT_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 6 - RW, UART TXD pin enable
            #[inline(always)]
            pub fn ier_txd_en(&self) -> IER_TXD_EN_R {
                IER_TXD_EN_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - WZ, UART software reset control, high action, auto clear
            #[inline(always)]
            pub fn ier_reset(&self) -> IER_RESET_R {
                IER_RESET_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RW, UART interrupt enable for receiver data ready
            #[inline(always)]
            #[must_use]
            pub fn ier_recv_rdy(&mut self) -> IER_RECV_RDY_W<0> {
                IER_RECV_RDY_W::new(self)
            }
            ///Bit 1 - RW, UART interrupt enable for THR empty
            #[inline(always)]
            #[must_use]
            pub fn ier_thr_empty(&mut self) -> IER_THR_EMPTY_W<1> {
                IER_THR_EMPTY_W::new(self)
            }
            ///Bit 2 - RW, UART interrupt enable for receiver line status
            #[inline(always)]
            #[must_use]
            pub fn ier_line_stat(&mut self) -> IER_LINE_STAT_W<2> {
                IER_LINE_STAT_W::new(self)
            }
            ///Bit 6 - RW, UART TXD pin enable
            #[inline(always)]
            #[must_use]
            pub fn ier_txd_en(&mut self) -> IER_TXD_EN_W<6> {
                IER_TXD_EN_W::new(self)
            }
            ///Bit 7 - WZ, UART software reset control, high action, auto clear
            #[inline(always)]
            #[must_use]
            pub fn ier_reset(&mut self) -> IER_RESET_W<7> {
                IER_RESET_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, UART1 interrupt enable
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [uart1_ier](index.html) module
        pub struct UART1_IER_SPEC;
        impl crate::RegisterSpec for UART1_IER_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [uart1_ier::R](R) reader structure
        impl crate::Readable for UART1_IER_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [uart1_ier::W](W) writer structure
        impl crate::Writable for UART1_IER_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets UART1_IER to value 0
        impl crate::Resettable for UART1_IER_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///UART1_FCR (rw) register accessor: an alias for `Reg<UART1_FCR_SPEC>`
    pub type UART1_FCR = crate::Reg<uart1_fcr::UART1_FCR_SPEC>;
    ///RW, UART1 FIFO control
    pub mod uart1_fcr {
        ///Register `UART1_FCR` reader
        pub struct R(crate::R<UART1_FCR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<UART1_FCR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<UART1_FCR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<UART1_FCR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `UART1_FCR` writer
        pub struct W(crate::W<UART1_FCR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<UART1_FCR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<UART1_FCR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<UART1_FCR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `FCR_FIFO_EN` reader - RW, UART FIFO enable
        pub type FCR_FIFO_EN_R = crate::BitReader<bool>;
        ///Field `FCR_FIFO_EN` writer - RW, UART FIFO enable
        pub type FCR_FIFO_EN_W<'a, const O: u8> = crate::BitWriter<'a, u8, UART1_FCR_SPEC, bool, O>;
        ///Field `FCR_RX_FIFO_CLR` reader - WZ, clear UART receiver FIFO, high action, auto clear
        pub type FCR_RX_FIFO_CLR_R = crate::BitReader<bool>;
        ///Field `FCR_RX_FIFO_CLR` writer - WZ, clear UART receiver FIFO, high action, auto clear
        pub type FCR_RX_FIFO_CLR_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, UART1_FCR_SPEC, bool, O>;
        ///Field `FCR_TX_FIFO_CLR` reader - WZ, clear UART transmitter FIFO, high action, auto clear
        pub type FCR_TX_FIFO_CLR_R = crate::BitReader<bool>;
        ///Field `FCR_TX_FIFO_CLR` writer - WZ, clear UART transmitter FIFO, high action, auto clear
        pub type FCR_TX_FIFO_CLR_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, UART1_FCR_SPEC, bool, O>;
        ///Field `FCR_FIFO_TRIG` reader - RW, UART receiver FIFO trigger level: 00-1byte, 01-2bytes, 10-4bytes, 11-7bytes
        pub type FCR_FIFO_TRIG_R = crate::FieldReader<u8, u8>;
        ///Field `FCR_FIFO_TRIG` writer - RW, UART receiver FIFO trigger level: 00-1byte, 01-2bytes, 10-4bytes, 11-7bytes
        pub type FCR_FIFO_TRIG_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, UART1_FCR_SPEC, u8, u8, 2, O>;
        impl R {
            ///Bit 0 - RW, UART FIFO enable
            #[inline(always)]
            pub fn fcr_fifo_en(&self) -> FCR_FIFO_EN_R {
                FCR_FIFO_EN_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - WZ, clear UART receiver FIFO, high action, auto clear
            #[inline(always)]
            pub fn fcr_rx_fifo_clr(&self) -> FCR_RX_FIFO_CLR_R {
                FCR_RX_FIFO_CLR_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - WZ, clear UART transmitter FIFO, high action, auto clear
            #[inline(always)]
            pub fn fcr_tx_fifo_clr(&self) -> FCR_TX_FIFO_CLR_R {
                FCR_TX_FIFO_CLR_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bits 6:7 - RW, UART receiver FIFO trigger level: 00-1byte, 01-2bytes, 10-4bytes, 11-7bytes
            #[inline(always)]
            pub fn fcr_fifo_trig(&self) -> FCR_FIFO_TRIG_R {
                FCR_FIFO_TRIG_R::new((self.bits >> 6) & 3)
            }
        }
        impl W {
            ///Bit 0 - RW, UART FIFO enable
            #[inline(always)]
            #[must_use]
            pub fn fcr_fifo_en(&mut self) -> FCR_FIFO_EN_W<0> {
                FCR_FIFO_EN_W::new(self)
            }
            ///Bit 1 - WZ, clear UART receiver FIFO, high action, auto clear
            #[inline(always)]
            #[must_use]
            pub fn fcr_rx_fifo_clr(&mut self) -> FCR_RX_FIFO_CLR_W<1> {
                FCR_RX_FIFO_CLR_W::new(self)
            }
            ///Bit 2 - WZ, clear UART transmitter FIFO, high action, auto clear
            #[inline(always)]
            #[must_use]
            pub fn fcr_tx_fifo_clr(&mut self) -> FCR_TX_FIFO_CLR_W<2> {
                FCR_TX_FIFO_CLR_W::new(self)
            }
            ///Bits 6:7 - RW, UART receiver FIFO trigger level: 00-1byte, 01-2bytes, 10-4bytes, 11-7bytes
            #[inline(always)]
            #[must_use]
            pub fn fcr_fifo_trig(&mut self) -> FCR_FIFO_TRIG_W<6> {
                FCR_FIFO_TRIG_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, UART1 FIFO control
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [uart1_fcr](index.html) module
        pub struct UART1_FCR_SPEC;
        impl crate::RegisterSpec for UART1_FCR_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [uart1_fcr::R](R) reader structure
        impl crate::Readable for UART1_FCR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [uart1_fcr::W](W) writer structure
        impl crate::Writable for UART1_FCR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets UART1_FCR to value 0
        impl crate::Resettable for UART1_FCR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///UART1_LCR (rw) register accessor: an alias for `Reg<UART1_LCR_SPEC>`
    pub type UART1_LCR = crate::Reg<uart1_lcr::UART1_LCR_SPEC>;
    ///RW, UART1 line control
    pub mod uart1_lcr {
        ///Register `UART1_LCR` reader
        pub struct R(crate::R<UART1_LCR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<UART1_LCR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<UART1_LCR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<UART1_LCR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `UART1_LCR` writer
        pub struct W(crate::W<UART1_LCR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<UART1_LCR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<UART1_LCR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<UART1_LCR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `LCR_WORD_SZ` reader - RW, UART word bit length: 00-5bit, 01-6bit, 10-7bit, 11-8bit
        pub type LCR_WORD_SZ_R = crate::FieldReader<u8, u8>;
        ///Field `LCR_WORD_SZ` writer - RW, UART word bit length: 00-5bit, 01-6bit, 10-7bit, 11-8bit
        pub type LCR_WORD_SZ_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, UART1_LCR_SPEC, u8, u8, 2, O>;
        ///Field `LCR_STOP_BIT` reader - RW, UART stop bit length: 0-1bit, 1-2bit
        pub type LCR_STOP_BIT_R = crate::BitReader<bool>;
        ///Field `LCR_STOP_BIT` writer - RW, UART stop bit length: 0-1bit, 1-2bit
        pub type LCR_STOP_BIT_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, UART1_LCR_SPEC, bool, O>;
        ///Field `LCR_PAR_EN` reader - RW, UART parity enable
        pub type LCR_PAR_EN_R = crate::BitReader<bool>;
        ///Field `LCR_PAR_EN` writer - RW, UART parity enable
        pub type LCR_PAR_EN_W<'a, const O: u8> = crate::BitWriter<'a, u8, UART1_LCR_SPEC, bool, O>;
        ///Field `LCR_PAR_MOD` reader - RW, UART parity mode: 00-odd, 01-even, 10-mark, 11-space
        pub type LCR_PAR_MOD_R = crate::FieldReader<u8, u8>;
        ///Field `LCR_PAR_MOD` writer - RW, UART parity mode: 00-odd, 01-even, 10-mark, 11-space
        pub type LCR_PAR_MOD_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, UART1_LCR_SPEC, u8, u8, 2, O>;
        ///Field `LCR_BREAK_EN` reader - RW, UART break control enable
        pub type LCR_BREAK_EN_R = crate::BitReader<bool>;
        ///Field `LCR_BREAK_EN` writer - RW, UART break control enable
        pub type LCR_BREAK_EN_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, UART1_LCR_SPEC, bool, O>;
        ///Field `LCR_GP_BIT__RB_LCR_DLAB` reader - RW, UART general purpose bit;RW, UART reserved bit
        pub type LCR_GP_BIT__RB_LCR_DLAB_R = crate::BitReader<bool>;
        ///Field `LCR_GP_BIT__RB_LCR_DLAB` writer - RW, UART general purpose bit;RW, UART reserved bit
        pub type LCR_GP_BIT__RB_LCR_DLAB_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, UART1_LCR_SPEC, bool, O>;
        impl R {
            ///Bits 0:1 - RW, UART word bit length: 00-5bit, 01-6bit, 10-7bit, 11-8bit
            #[inline(always)]
            pub fn lcr_word_sz(&self) -> LCR_WORD_SZ_R {
                LCR_WORD_SZ_R::new(self.bits & 3)
            }
            ///Bit 2 - RW, UART stop bit length: 0-1bit, 1-2bit
            #[inline(always)]
            pub fn lcr_stop_bit(&self) -> LCR_STOP_BIT_R {
                LCR_STOP_BIT_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RW, UART parity enable
            #[inline(always)]
            pub fn lcr_par_en(&self) -> LCR_PAR_EN_R {
                LCR_PAR_EN_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bits 4:5 - RW, UART parity mode: 00-odd, 01-even, 10-mark, 11-space
            #[inline(always)]
            pub fn lcr_par_mod(&self) -> LCR_PAR_MOD_R {
                LCR_PAR_MOD_R::new((self.bits >> 4) & 3)
            }
            ///Bit 6 - RW, UART break control enable
            #[inline(always)]
            pub fn lcr_break_en(&self) -> LCR_BREAK_EN_R {
                LCR_BREAK_EN_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - RW, UART general purpose bit;RW, UART reserved bit
            #[inline(always)]
            pub fn lcr_gp_bit__rb_lcr_dlab(&self) -> LCR_GP_BIT__RB_LCR_DLAB_R {
                LCR_GP_BIT__RB_LCR_DLAB_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:1 - RW, UART word bit length: 00-5bit, 01-6bit, 10-7bit, 11-8bit
            #[inline(always)]
            #[must_use]
            pub fn lcr_word_sz(&mut self) -> LCR_WORD_SZ_W<0> {
                LCR_WORD_SZ_W::new(self)
            }
            ///Bit 2 - RW, UART stop bit length: 0-1bit, 1-2bit
            #[inline(always)]
            #[must_use]
            pub fn lcr_stop_bit(&mut self) -> LCR_STOP_BIT_W<2> {
                LCR_STOP_BIT_W::new(self)
            }
            ///Bit 3 - RW, UART parity enable
            #[inline(always)]
            #[must_use]
            pub fn lcr_par_en(&mut self) -> LCR_PAR_EN_W<3> {
                LCR_PAR_EN_W::new(self)
            }
            ///Bits 4:5 - RW, UART parity mode: 00-odd, 01-even, 10-mark, 11-space
            #[inline(always)]
            #[must_use]
            pub fn lcr_par_mod(&mut self) -> LCR_PAR_MOD_W<4> {
                LCR_PAR_MOD_W::new(self)
            }
            ///Bit 6 - RW, UART break control enable
            #[inline(always)]
            #[must_use]
            pub fn lcr_break_en(&mut self) -> LCR_BREAK_EN_W<6> {
                LCR_BREAK_EN_W::new(self)
            }
            ///Bit 7 - RW, UART general purpose bit;RW, UART reserved bit
            #[inline(always)]
            #[must_use]
            pub fn lcr_gp_bit__rb_lcr_dlab(&mut self) -> LCR_GP_BIT__RB_LCR_DLAB_W<7> {
                LCR_GP_BIT__RB_LCR_DLAB_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, UART1 line control
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [uart1_lcr](index.html) module
        pub struct UART1_LCR_SPEC;
        impl crate::RegisterSpec for UART1_LCR_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [uart1_lcr::R](R) reader structure
        impl crate::Readable for UART1_LCR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [uart1_lcr::W](W) writer structure
        impl crate::Writable for UART1_LCR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets UART1_LCR to value 0
        impl crate::Resettable for UART1_LCR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///UART1_IIR (r) register accessor: an alias for `Reg<UART1_IIR_SPEC>`
    pub type UART1_IIR = crate::Reg<uart1_iir::UART1_IIR_SPEC>;
    ///RO, UART1 interrupt identification
    pub mod uart1_iir {
        ///Register `UART1_IIR` reader
        pub struct R(crate::R<UART1_IIR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<UART1_IIR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<UART1_IIR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<UART1_IIR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `IIR_NO_INT` reader - RO, UART no interrupt flag: 0=interrupt action, 1=no interrupt
        pub type IIR_NO_INT_R = crate::BitReader<bool>;
        ///Field `IIR_INT_MASK` reader - RO, UART interrupt flag bit mask
        pub type IIR_INT_MASK_R = crate::FieldReader<u8, u8>;
        ///Field `IIR_FIFO_ID` reader - RO, UART FIFO enabled flag
        pub type IIR_FIFO_ID_R = crate::BitReader<bool>;
        impl R {
            ///Bit 0 - RO, UART no interrupt flag: 0=interrupt action, 1=no interrupt
            #[inline(always)]
            pub fn iir_no_int(&self) -> IIR_NO_INT_R {
                IIR_NO_INT_R::new((self.bits & 1) != 0)
            }
            ///Bits 0:3 - RO, UART interrupt flag bit mask
            #[inline(always)]
            pub fn iir_int_mask(&self) -> IIR_INT_MASK_R {
                IIR_INT_MASK_R::new(self.bits & 0x0f)
            }
            ///Bit 7 - RO, UART FIFO enabled flag
            #[inline(always)]
            pub fn iir_fifo_id(&self) -> IIR_FIFO_ID_R {
                IIR_FIFO_ID_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        ///RO, UART1 interrupt identification
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [uart1_iir](index.html) module
        pub struct UART1_IIR_SPEC;
        impl crate::RegisterSpec for UART1_IIR_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [uart1_iir::R](R) reader structure
        impl crate::Readable for UART1_IIR_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets UART1_IIR to value 0x01
        impl crate::Resettable for UART1_IIR_SPEC {
            const RESET_VALUE: Self::Ux = 0x01;
        }
    }
    ///UART1_LSR (r) register accessor: an alias for `Reg<UART1_LSR_SPEC>`
    pub type UART1_LSR = crate::Reg<uart1_lsr::UART1_LSR_SPEC>;
    ///RO, UART1 line status
    pub mod uart1_lsr {
        ///Register `UART1_LSR` reader
        pub struct R(crate::R<UART1_LSR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<UART1_LSR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<UART1_LSR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<UART1_LSR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `LSR_DATA_RDY` reader - RO, UART receiver fifo data ready status
        pub type LSR_DATA_RDY_R = crate::BitReader<bool>;
        ///Field `LSR_OVER_ERR` reader - RZ, UART receiver overrun error
        pub type LSR_OVER_ERR_R = crate::BitReader<bool>;
        ///Field `LSR_PAR_ERR` reader - RZ, UART receiver parity error
        pub type LSR_PAR_ERR_R = crate::BitReader<bool>;
        ///Field `LSR_FRAME_ERR` reader - RZ, UART receiver frame error
        pub type LSR_FRAME_ERR_R = crate::BitReader<bool>;
        ///Field `LSR_BREAK_ERR` reader - RZ, UART receiver break error
        pub type LSR_BREAK_ERR_R = crate::BitReader<bool>;
        ///Field `LSR_TX_FIFO_EMP` reader - RO, UART transmitter fifo empty status
        pub type LSR_TX_FIFO_EMP_R = crate::BitReader<bool>;
        ///Field `LSR_TX_ALL_EMP` reader - RO, UART transmitter all empty status
        pub type LSR_TX_ALL_EMP_R = crate::BitReader<bool>;
        ///Field `LSR_ERR_RX_FIFO` reader - RO, indicate error in UART receiver fifo
        pub type LSR_ERR_RX_FIFO_R = crate::BitReader<bool>;
        impl R {
            ///Bit 0 - RO, UART receiver fifo data ready status
            #[inline(always)]
            pub fn lsr_data_rdy(&self) -> LSR_DATA_RDY_R {
                LSR_DATA_RDY_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RZ, UART receiver overrun error
            #[inline(always)]
            pub fn lsr_over_err(&self) -> LSR_OVER_ERR_R {
                LSR_OVER_ERR_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RZ, UART receiver parity error
            #[inline(always)]
            pub fn lsr_par_err(&self) -> LSR_PAR_ERR_R {
                LSR_PAR_ERR_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RZ, UART receiver frame error
            #[inline(always)]
            pub fn lsr_frame_err(&self) -> LSR_FRAME_ERR_R {
                LSR_FRAME_ERR_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RZ, UART receiver break error
            #[inline(always)]
            pub fn lsr_break_err(&self) -> LSR_BREAK_ERR_R {
                LSR_BREAK_ERR_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - RO, UART transmitter fifo empty status
            #[inline(always)]
            pub fn lsr_tx_fifo_emp(&self) -> LSR_TX_FIFO_EMP_R {
                LSR_TX_FIFO_EMP_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - RO, UART transmitter all empty status
            #[inline(always)]
            pub fn lsr_tx_all_emp(&self) -> LSR_TX_ALL_EMP_R {
                LSR_TX_ALL_EMP_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - RO, indicate error in UART receiver fifo
            #[inline(always)]
            pub fn lsr_err_rx_fifo(&self) -> LSR_ERR_RX_FIFO_R {
                LSR_ERR_RX_FIFO_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        ///RO, UART1 line status
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [uart1_lsr](index.html) module
        pub struct UART1_LSR_SPEC;
        impl crate::RegisterSpec for UART1_LSR_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [uart1_lsr::R](R) reader structure
        impl crate::Readable for UART1_LSR_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets UART1_LSR to value 0x60
        impl crate::Resettable for UART1_LSR_SPEC {
            const RESET_VALUE: Self::Ux = 0x60;
        }
    }
    ///UART1_RBR (r) register accessor: an alias for `Reg<UART1_RBR_SPEC>`
    pub type UART1_RBR = crate::Reg<uart1_rbr::UART1_RBR_SPEC>;
    ///RO, UART1 receiver buffer, receiving byte
    pub mod uart1_rbr {
        ///Register `UART1_RBR` reader
        pub struct R(crate::R<UART1_RBR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<UART1_RBR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<UART1_RBR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<UART1_RBR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `UART1_RBR` reader - RO, UART1 receiver buffer, receiving byte
        pub type UART1_RBR_R = crate::FieldReader<u8, u8>;
        impl R {
            ///Bits 0:7 - RO, UART1 receiver buffer, receiving byte
            #[inline(always)]
            pub fn uart1_rbr(&self) -> UART1_RBR_R {
                UART1_RBR_R::new(self.bits)
            }
        }
        ///RO, UART1 receiver buffer, receiving byte
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [uart1_rbr](index.html) module
        pub struct UART1_RBR_SPEC;
        impl crate::RegisterSpec for UART1_RBR_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [uart1_rbr::R](R) reader structure
        impl crate::Readable for UART1_RBR_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets UART1_RBR to value 0
        impl crate::Resettable for UART1_RBR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///UART1_THR (w) register accessor: an alias for `Reg<UART1_THR_SPEC>`
    pub type UART1_THR = crate::Reg<uart1_thr::UART1_THR_SPEC>;
    ///WO, UART1 transmitter holding, transmittal byte
    pub mod uart1_thr {
        ///Register `UART1_THR` writer
        pub struct W(crate::W<UART1_THR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<UART1_THR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<UART1_THR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<UART1_THR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `UART1_RBR` writer - WO, UART1 transmitter holding, transmittal byte
        pub type UART1_RBR_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, UART1_THR_SPEC, u8, u8, 8, O>;
        impl W {
            ///Bits 0:7 - WO, UART1 transmitter holding, transmittal byte
            #[inline(always)]
            #[must_use]
            pub fn uart1_rbr(&mut self) -> UART1_RBR_W<0> {
                UART1_RBR_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///WO, UART1 transmitter holding, transmittal byte
        ///
        ///This register you can [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [uart1_thr](index.html) module
        pub struct UART1_THR_SPEC;
        impl crate::RegisterSpec for UART1_THR_SPEC {
            type Ux = u8;
        }
        ///`write(|w| ..)` method takes [uart1_thr::W](W) writer structure
        impl crate::Writable for UART1_THR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets UART1_THR to value 0
        impl crate::Resettable for UART1_THR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///UART1_RFC (r) register accessor: an alias for `Reg<UART1_RFC_SPEC>`
    pub type UART1_RFC = crate::Reg<uart1_rfc::UART1_RFC_SPEC>;
    ///RO, UART1 receiver FIFO count
    pub mod uart1_rfc {
        ///Register `UART1_RFC` reader
        pub struct R(crate::R<UART1_RFC_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<UART1_RFC_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<UART1_RFC_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<UART1_RFC_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `UART1_RFC` reader - RO, UART1 receiver FIFO count
        pub type UART1_RFC_R = crate::FieldReader<u8, u8>;
        impl R {
            ///Bits 0:7 - RO, UART1 receiver FIFO count
            #[inline(always)]
            pub fn uart1_rfc(&self) -> UART1_RFC_R {
                UART1_RFC_R::new(self.bits)
            }
        }
        ///RO, UART1 receiver FIFO count
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [uart1_rfc](index.html) module
        pub struct UART1_RFC_SPEC;
        impl crate::RegisterSpec for UART1_RFC_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [uart1_rfc::R](R) reader structure
        impl crate::Readable for UART1_RFC_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets UART1_RFC to value 0
        impl crate::Resettable for UART1_RFC_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///UART1_TFC (r) register accessor: an alias for `Reg<UART1_TFC_SPEC>`
    pub type UART1_TFC = crate::Reg<uart1_tfc::UART1_TFC_SPEC>;
    ///RO, UART1 transmitter FIFO count
    pub mod uart1_tfc {
        ///Register `UART1_TFC` reader
        pub struct R(crate::R<UART1_TFC_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<UART1_TFC_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<UART1_TFC_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<UART1_TFC_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `UART1_TFC` reader - RO, UART1 receiver FIFO count
        pub type UART1_TFC_R = crate::FieldReader<u8, u8>;
        impl R {
            ///Bits 0:7 - RO, UART1 receiver FIFO count
            #[inline(always)]
            pub fn uart1_tfc(&self) -> UART1_TFC_R {
                UART1_TFC_R::new(self.bits)
            }
        }
        ///RO, UART1 transmitter FIFO count
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [uart1_tfc](index.html) module
        pub struct UART1_TFC_SPEC;
        impl crate::RegisterSpec for UART1_TFC_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [uart1_tfc::R](R) reader structure
        impl crate::Readable for UART1_TFC_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets UART1_TFC to value 0
        impl crate::Resettable for UART1_TFC_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///UART1_DL (rw) register accessor: an alias for `Reg<UART1_DL_SPEC>`
    pub type UART1_DL = crate::Reg<uart1_dl::UART1_DL_SPEC>;
    ///RW, UART1 divisor latch
    pub mod uart1_dl {
        ///Register `UART1_DL` reader
        pub struct R(crate::R<UART1_DL_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<UART1_DL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<UART1_DL_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<UART1_DL_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `UART1_DL` writer
        pub struct W(crate::W<UART1_DL_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<UART1_DL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<UART1_DL_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<UART1_DL_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `UART1_DL` reader - RW, UART1 divisor latch
        pub type UART1_DL_R = crate::FieldReader<u16, u16>;
        ///Field `UART1_DL` writer - RW, UART1 divisor latch
        pub type UART1_DL_W<'a, const O: u8> =
            crate::FieldWriter<'a, u16, UART1_DL_SPEC, u16, u16, 16, O>;
        impl R {
            ///Bits 0:15 - RW, UART1 divisor latch
            #[inline(always)]
            pub fn uart1_dl(&self) -> UART1_DL_R {
                UART1_DL_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - RW, UART1 divisor latch
            #[inline(always)]
            #[must_use]
            pub fn uart1_dl(&mut self) -> UART1_DL_W<0> {
                UART1_DL_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, UART1 divisor latch
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [uart1_dl](index.html) module
        pub struct UART1_DL_SPEC;
        impl crate::RegisterSpec for UART1_DL_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [uart1_dl::R](R) reader structure
        impl crate::Readable for UART1_DL_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [uart1_dl::W](W) writer structure
        impl crate::Writable for UART1_DL_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets UART1_DL to value 0
        impl crate::Resettable for UART1_DL_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///UART1_DIV (rw) register accessor: an alias for `Reg<UART1_DIV_SPEC>`
    pub type UART1_DIV = crate::Reg<uart1_div::UART1_DIV_SPEC>;
    ///RW, UART1 pre-divisor latch byte, only low 7 bit, from 1 to 128
    pub mod uart1_div {
        ///Register `UART1_DIV` reader
        pub struct R(crate::R<UART1_DIV_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<UART1_DIV_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<UART1_DIV_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<UART1_DIV_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `UART1_DIV` writer
        pub struct W(crate::W<UART1_DIV_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<UART1_DIV_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<UART1_DIV_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<UART1_DIV_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `UART1_DIV` reader - RW, UART1 pre-divisor latch byte, only low 7 bit, from 1 to 128
        pub type UART1_DIV_R = crate::FieldReader<u8, u8>;
        ///Field `UART1_DIV` writer - RW, UART1 pre-divisor latch byte, only low 7 bit, from 1 to 128
        pub type UART1_DIV_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, UART1_DIV_SPEC, u8, u8, 8, O>;
        impl R {
            ///Bits 0:7 - RW, UART1 pre-divisor latch byte, only low 7 bit, from 1 to 128
            #[inline(always)]
            pub fn uart1_div(&self) -> UART1_DIV_R {
                UART1_DIV_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:7 - RW, UART1 pre-divisor latch byte, only low 7 bit, from 1 to 128
            #[inline(always)]
            #[must_use]
            pub fn uart1_div(&mut self) -> UART1_DIV_W<0> {
                UART1_DIV_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, UART1 pre-divisor latch byte, only low 7 bit, from 1 to 128
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [uart1_div](index.html) module
        pub struct UART1_DIV_SPEC;
        impl crate::RegisterSpec for UART1_DIV_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [uart1_div::R](R) reader structure
        impl crate::Readable for UART1_DIV_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [uart1_div::W](W) writer structure
        impl crate::Writable for UART1_DIV_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets UART1_DIV to value 0
        impl crate::Resettable for UART1_DIV_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
}
///UART2 register
pub struct UART2 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for UART2 {}
impl UART2 {
    ///Pointer to the register block
    pub const PTR: *const uart2::RegisterBlock = 0x4000_3800 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const uart2::RegisterBlock {
        Self::PTR
    }
}
impl Deref for UART2 {
    type Target = uart2::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for UART2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("UART2").finish()
    }
}
///UART2 register
pub mod uart2 {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        ///0x00 - RW, UART2 modem control
        pub uart2_mcr: UART2_MCR,
        ///0x01 - RW, UART2 interrupt enable
        pub uart2_ier: UART2_IER,
        ///0x02 - RW, UART2 FIFO control
        pub uart2_fcr: UART2_FCR,
        ///0x03 - RW, UART2 line control
        pub uart2_lcr: UART2_LCR,
        ///0x04 - RO, UART2 interrupt identification
        pub uart2_iir: UART2_IIR,
        ///0x05 - RO, UART2 line status
        pub uart2_lsr: UART2_LSR,
        _reserved6: [u8; 0x02],
        _reserved_6_uart2: [u8; 0x01],
        _reserved7: [u8; 0x01],
        ///0x0a - RO, UART2 receiver FIFO count
        pub uart2_rfc: UART2_RFC,
        ///0x0b - RO, UART2 transmitter FIFO count
        pub uart2_tfc: UART2_TFC,
        ///0x0c - RW, UART2 divisor latch
        pub uart2_dl: UART2_DL,
        ///0x0e - RW, UART2 pre-divisor latch byte, only low 7 bit, from 1 to 128
        pub uart2_div: UART2_DIV,
    }
    impl RegisterBlock {
        ///0x08 - WO, UART2 transmitter holding, transmittal byte
        #[inline(always)]
        pub const fn uart2_thr(&self) -> &UART2_THR {
            unsafe { &*(self as *const Self).cast::<u8>().add(8usize).cast() }
        }
        ///0x08 - RO, UART2 receiver buffer, receiving byte
        #[inline(always)]
        pub const fn uart2_rbr(&self) -> &UART2_RBR {
            unsafe { &*(self as *const Self).cast::<u8>().add(8usize).cast() }
        }
    }
    ///UART2_MCR (rw) register accessor: an alias for `Reg<UART2_MCR_SPEC>`
    pub type UART2_MCR = crate::Reg<uart2_mcr::UART2_MCR_SPEC>;
    ///RW, UART2 modem control
    pub mod uart2_mcr {
        ///Register `UART2_MCR` reader
        pub struct R(crate::R<UART2_MCR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<UART2_MCR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<UART2_MCR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<UART2_MCR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `UART2_MCR` writer
        pub struct W(crate::W<UART2_MCR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<UART2_MCR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<UART2_MCR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<UART2_MCR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `MCR_OUT2__RB_MCR_INT_OE` reader - RW, UART control OUT2;UART interrupt output enable
        pub type MCR_OUT2__RB_MCR_INT_OE_R = crate::BitReader<bool>;
        ///Field `MCR_OUT2__RB_MCR_INT_OE` writer - RW, UART control OUT2;UART interrupt output enable
        pub type MCR_OUT2__RB_MCR_INT_OE_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, UART2_MCR_SPEC, bool, O>;
        impl R {
            ///Bit 3 - RW, UART control OUT2;UART interrupt output enable
            #[inline(always)]
            pub fn mcr_out2__rb_mcr_int_oe(&self) -> MCR_OUT2__RB_MCR_INT_OE_R {
                MCR_OUT2__RB_MCR_INT_OE_R::new(((self.bits >> 3) & 1) != 0)
            }
        }
        impl W {
            ///Bit 3 - RW, UART control OUT2;UART interrupt output enable
            #[inline(always)]
            #[must_use]
            pub fn mcr_out2__rb_mcr_int_oe(&mut self) -> MCR_OUT2__RB_MCR_INT_OE_W<3> {
                MCR_OUT2__RB_MCR_INT_OE_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, UART2 modem control
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [uart2_mcr](index.html) module
        pub struct UART2_MCR_SPEC;
        impl crate::RegisterSpec for UART2_MCR_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [uart2_mcr::R](R) reader structure
        impl crate::Readable for UART2_MCR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [uart2_mcr::W](W) writer structure
        impl crate::Writable for UART2_MCR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets UART2_MCR to value 0
        impl crate::Resettable for UART2_MCR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///UART2_IER (rw) register accessor: an alias for `Reg<UART2_IER_SPEC>`
    pub type UART2_IER = crate::Reg<uart2_ier::UART2_IER_SPEC>;
    ///RW, UART2 interrupt enable
    pub mod uart2_ier {
        ///Register `UART2_IER` reader
        pub struct R(crate::R<UART2_IER_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<UART2_IER_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<UART2_IER_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<UART2_IER_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `UART2_IER` writer
        pub struct W(crate::W<UART2_IER_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<UART2_IER_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<UART2_IER_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<UART2_IER_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IER_RECV_RDY` reader - RW, UART interrupt enable for receiver data ready
        pub type IER_RECV_RDY_R = crate::BitReader<bool>;
        ///Field `IER_RECV_RDY` writer - RW, UART interrupt enable for receiver data ready
        pub type IER_RECV_RDY_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, UART2_IER_SPEC, bool, O>;
        ///Field `IER_THR_EMPTY` reader - RW, UART interrupt enable for THR empty
        pub type IER_THR_EMPTY_R = crate::BitReader<bool>;
        ///Field `IER_THR_EMPTY` writer - RW, UART interrupt enable for THR empty
        pub type IER_THR_EMPTY_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, UART2_IER_SPEC, bool, O>;
        ///Field `IER_LINE_STAT` reader - RW, UART interrupt enable for receiver line status
        pub type IER_LINE_STAT_R = crate::BitReader<bool>;
        ///Field `IER_LINE_STAT` writer - RW, UART interrupt enable for receiver line status
        pub type IER_LINE_STAT_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, UART2_IER_SPEC, bool, O>;
        ///Field `IER_TXD_EN` reader - RW, UART TXD pin enable
        pub type IER_TXD_EN_R = crate::BitReader<bool>;
        ///Field `IER_TXD_EN` writer - RW, UART TXD pin enable
        pub type IER_TXD_EN_W<'a, const O: u8> = crate::BitWriter<'a, u8, UART2_IER_SPEC, bool, O>;
        ///Field `IER_RESET` reader - WZ, UART software reset control, high action, auto clear
        pub type IER_RESET_R = crate::BitReader<bool>;
        ///Field `IER_RESET` writer - WZ, UART software reset control, high action, auto clear
        pub type IER_RESET_W<'a, const O: u8> = crate::BitWriter<'a, u8, UART2_IER_SPEC, bool, O>;
        impl R {
            ///Bit 0 - RW, UART interrupt enable for receiver data ready
            #[inline(always)]
            pub fn ier_recv_rdy(&self) -> IER_RECV_RDY_R {
                IER_RECV_RDY_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RW, UART interrupt enable for THR empty
            #[inline(always)]
            pub fn ier_thr_empty(&self) -> IER_THR_EMPTY_R {
                IER_THR_EMPTY_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RW, UART interrupt enable for receiver line status
            #[inline(always)]
            pub fn ier_line_stat(&self) -> IER_LINE_STAT_R {
                IER_LINE_STAT_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 6 - RW, UART TXD pin enable
            #[inline(always)]
            pub fn ier_txd_en(&self) -> IER_TXD_EN_R {
                IER_TXD_EN_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - WZ, UART software reset control, high action, auto clear
            #[inline(always)]
            pub fn ier_reset(&self) -> IER_RESET_R {
                IER_RESET_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RW, UART interrupt enable for receiver data ready
            #[inline(always)]
            #[must_use]
            pub fn ier_recv_rdy(&mut self) -> IER_RECV_RDY_W<0> {
                IER_RECV_RDY_W::new(self)
            }
            ///Bit 1 - RW, UART interrupt enable for THR empty
            #[inline(always)]
            #[must_use]
            pub fn ier_thr_empty(&mut self) -> IER_THR_EMPTY_W<1> {
                IER_THR_EMPTY_W::new(self)
            }
            ///Bit 2 - RW, UART interrupt enable for receiver line status
            #[inline(always)]
            #[must_use]
            pub fn ier_line_stat(&mut self) -> IER_LINE_STAT_W<2> {
                IER_LINE_STAT_W::new(self)
            }
            ///Bit 6 - RW, UART TXD pin enable
            #[inline(always)]
            #[must_use]
            pub fn ier_txd_en(&mut self) -> IER_TXD_EN_W<6> {
                IER_TXD_EN_W::new(self)
            }
            ///Bit 7 - WZ, UART software reset control, high action, auto clear
            #[inline(always)]
            #[must_use]
            pub fn ier_reset(&mut self) -> IER_RESET_W<7> {
                IER_RESET_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, UART2 interrupt enable
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [uart2_ier](index.html) module
        pub struct UART2_IER_SPEC;
        impl crate::RegisterSpec for UART2_IER_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [uart2_ier::R](R) reader structure
        impl crate::Readable for UART2_IER_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [uart2_ier::W](W) writer structure
        impl crate::Writable for UART2_IER_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets UART2_IER to value 0
        impl crate::Resettable for UART2_IER_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///UART2_FCR (rw) register accessor: an alias for `Reg<UART2_FCR_SPEC>`
    pub type UART2_FCR = crate::Reg<uart2_fcr::UART2_FCR_SPEC>;
    ///RW, UART2 FIFO control
    pub mod uart2_fcr {
        ///Register `UART2_FCR` reader
        pub struct R(crate::R<UART2_FCR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<UART2_FCR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<UART2_FCR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<UART2_FCR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `UART2_FCR` writer
        pub struct W(crate::W<UART2_FCR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<UART2_FCR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<UART2_FCR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<UART2_FCR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `FCR_FIFO_EN` reader - RW, UART FIFO enable
        pub type FCR_FIFO_EN_R = crate::BitReader<bool>;
        ///Field `FCR_FIFO_EN` writer - RW, UART FIFO enable
        pub type FCR_FIFO_EN_W<'a, const O: u8> = crate::BitWriter<'a, u8, UART2_FCR_SPEC, bool, O>;
        ///Field `FCR_RX_FIFO_CLR` reader - WZ, clear UART receiver FIFO, high action, auto clear
        pub type FCR_RX_FIFO_CLR_R = crate::BitReader<bool>;
        ///Field `FCR_RX_FIFO_CLR` writer - WZ, clear UART receiver FIFO, high action, auto clear
        pub type FCR_RX_FIFO_CLR_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, UART2_FCR_SPEC, bool, O>;
        ///Field `FCR_TX_FIFO_CLR` reader - WZ, clear UART transmitter FIFO, high action, auto clear
        pub type FCR_TX_FIFO_CLR_R = crate::BitReader<bool>;
        ///Field `FCR_TX_FIFO_CLR` writer - WZ, clear UART transmitter FIFO, high action, auto clear
        pub type FCR_TX_FIFO_CLR_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, UART2_FCR_SPEC, bool, O>;
        ///Field `FCR_FIFO_TRIG` reader - RW, UART receiver FIFO trigger level: 00-1byte, 01-2bytes, 10-4bytes, 11-7bytes
        pub type FCR_FIFO_TRIG_R = crate::FieldReader<u8, u8>;
        ///Field `FCR_FIFO_TRIG` writer - RW, UART receiver FIFO trigger level: 00-1byte, 01-2bytes, 10-4bytes, 11-7bytes
        pub type FCR_FIFO_TRIG_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, UART2_FCR_SPEC, u8, u8, 2, O>;
        impl R {
            ///Bit 0 - RW, UART FIFO enable
            #[inline(always)]
            pub fn fcr_fifo_en(&self) -> FCR_FIFO_EN_R {
                FCR_FIFO_EN_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - WZ, clear UART receiver FIFO, high action, auto clear
            #[inline(always)]
            pub fn fcr_rx_fifo_clr(&self) -> FCR_RX_FIFO_CLR_R {
                FCR_RX_FIFO_CLR_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - WZ, clear UART transmitter FIFO, high action, auto clear
            #[inline(always)]
            pub fn fcr_tx_fifo_clr(&self) -> FCR_TX_FIFO_CLR_R {
                FCR_TX_FIFO_CLR_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bits 6:7 - RW, UART receiver FIFO trigger level: 00-1byte, 01-2bytes, 10-4bytes, 11-7bytes
            #[inline(always)]
            pub fn fcr_fifo_trig(&self) -> FCR_FIFO_TRIG_R {
                FCR_FIFO_TRIG_R::new((self.bits >> 6) & 3)
            }
        }
        impl W {
            ///Bit 0 - RW, UART FIFO enable
            #[inline(always)]
            #[must_use]
            pub fn fcr_fifo_en(&mut self) -> FCR_FIFO_EN_W<0> {
                FCR_FIFO_EN_W::new(self)
            }
            ///Bit 1 - WZ, clear UART receiver FIFO, high action, auto clear
            #[inline(always)]
            #[must_use]
            pub fn fcr_rx_fifo_clr(&mut self) -> FCR_RX_FIFO_CLR_W<1> {
                FCR_RX_FIFO_CLR_W::new(self)
            }
            ///Bit 2 - WZ, clear UART transmitter FIFO, high action, auto clear
            #[inline(always)]
            #[must_use]
            pub fn fcr_tx_fifo_clr(&mut self) -> FCR_TX_FIFO_CLR_W<2> {
                FCR_TX_FIFO_CLR_W::new(self)
            }
            ///Bits 6:7 - RW, UART receiver FIFO trigger level: 00-1byte, 01-2bytes, 10-4bytes, 11-7bytes
            #[inline(always)]
            #[must_use]
            pub fn fcr_fifo_trig(&mut self) -> FCR_FIFO_TRIG_W<6> {
                FCR_FIFO_TRIG_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, UART2 FIFO control
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [uart2_fcr](index.html) module
        pub struct UART2_FCR_SPEC;
        impl crate::RegisterSpec for UART2_FCR_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [uart2_fcr::R](R) reader structure
        impl crate::Readable for UART2_FCR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [uart2_fcr::W](W) writer structure
        impl crate::Writable for UART2_FCR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets UART2_FCR to value 0
        impl crate::Resettable for UART2_FCR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///UART2_LCR (rw) register accessor: an alias for `Reg<UART2_LCR_SPEC>`
    pub type UART2_LCR = crate::Reg<uart2_lcr::UART2_LCR_SPEC>;
    ///RW, UART2 line control
    pub mod uart2_lcr {
        ///Register `UART2_LCR` reader
        pub struct R(crate::R<UART2_LCR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<UART2_LCR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<UART2_LCR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<UART2_LCR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `UART2_LCR` writer
        pub struct W(crate::W<UART2_LCR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<UART2_LCR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<UART2_LCR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<UART2_LCR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `LCR_WORD_SZ` reader - RW, UART word bit length: 00-5bit, 01-6bit, 10-7bit, 11-8bit
        pub type LCR_WORD_SZ_R = crate::FieldReader<u8, u8>;
        ///Field `LCR_WORD_SZ` writer - RW, UART word bit length: 00-5bit, 01-6bit, 10-7bit, 11-8bit
        pub type LCR_WORD_SZ_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, UART2_LCR_SPEC, u8, u8, 2, O>;
        ///Field `LCR_STOP_BIT` reader - RW, UART stop bit length: 0-1bit, 1-2bit
        pub type LCR_STOP_BIT_R = crate::BitReader<bool>;
        ///Field `LCR_STOP_BIT` writer - RW, UART stop bit length: 0-1bit, 1-2bit
        pub type LCR_STOP_BIT_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, UART2_LCR_SPEC, bool, O>;
        ///Field `LCR_PAR_EN` reader - RW, UART parity enable
        pub type LCR_PAR_EN_R = crate::BitReader<bool>;
        ///Field `LCR_PAR_EN` writer - RW, UART parity enable
        pub type LCR_PAR_EN_W<'a, const O: u8> = crate::BitWriter<'a, u8, UART2_LCR_SPEC, bool, O>;
        ///Field `LCR_PAR_MOD` reader - RW, UART parity mode: 00-odd, 01-even, 10-mark, 11-space
        pub type LCR_PAR_MOD_R = crate::FieldReader<u8, u8>;
        ///Field `LCR_PAR_MOD` writer - RW, UART parity mode: 00-odd, 01-even, 10-mark, 11-space
        pub type LCR_PAR_MOD_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, UART2_LCR_SPEC, u8, u8, 2, O>;
        ///Field `LCR_BREAK_EN` reader - RW, UART break control enable
        pub type LCR_BREAK_EN_R = crate::BitReader<bool>;
        ///Field `LCR_BREAK_EN` writer - RW, UART break control enable
        pub type LCR_BREAK_EN_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, UART2_LCR_SPEC, bool, O>;
        ///Field `LCR_GP_BIT__RB_LCR_DLAB` reader - RW, UART general purpose bit;RW, UART reserved bit
        pub type LCR_GP_BIT__RB_LCR_DLAB_R = crate::BitReader<bool>;
        ///Field `LCR_GP_BIT__RB_LCR_DLAB` writer - RW, UART general purpose bit;RW, UART reserved bit
        pub type LCR_GP_BIT__RB_LCR_DLAB_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, UART2_LCR_SPEC, bool, O>;
        impl R {
            ///Bits 0:1 - RW, UART word bit length: 00-5bit, 01-6bit, 10-7bit, 11-8bit
            #[inline(always)]
            pub fn lcr_word_sz(&self) -> LCR_WORD_SZ_R {
                LCR_WORD_SZ_R::new(self.bits & 3)
            }
            ///Bit 2 - RW, UART stop bit length: 0-1bit, 1-2bit
            #[inline(always)]
            pub fn lcr_stop_bit(&self) -> LCR_STOP_BIT_R {
                LCR_STOP_BIT_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RW, UART parity enable
            #[inline(always)]
            pub fn lcr_par_en(&self) -> LCR_PAR_EN_R {
                LCR_PAR_EN_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bits 4:5 - RW, UART parity mode: 00-odd, 01-even, 10-mark, 11-space
            #[inline(always)]
            pub fn lcr_par_mod(&self) -> LCR_PAR_MOD_R {
                LCR_PAR_MOD_R::new((self.bits >> 4) & 3)
            }
            ///Bit 6 - RW, UART break control enable
            #[inline(always)]
            pub fn lcr_break_en(&self) -> LCR_BREAK_EN_R {
                LCR_BREAK_EN_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - RW, UART general purpose bit;RW, UART reserved bit
            #[inline(always)]
            pub fn lcr_gp_bit__rb_lcr_dlab(&self) -> LCR_GP_BIT__RB_LCR_DLAB_R {
                LCR_GP_BIT__RB_LCR_DLAB_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:1 - RW, UART word bit length: 00-5bit, 01-6bit, 10-7bit, 11-8bit
            #[inline(always)]
            #[must_use]
            pub fn lcr_word_sz(&mut self) -> LCR_WORD_SZ_W<0> {
                LCR_WORD_SZ_W::new(self)
            }
            ///Bit 2 - RW, UART stop bit length: 0-1bit, 1-2bit
            #[inline(always)]
            #[must_use]
            pub fn lcr_stop_bit(&mut self) -> LCR_STOP_BIT_W<2> {
                LCR_STOP_BIT_W::new(self)
            }
            ///Bit 3 - RW, UART parity enable
            #[inline(always)]
            #[must_use]
            pub fn lcr_par_en(&mut self) -> LCR_PAR_EN_W<3> {
                LCR_PAR_EN_W::new(self)
            }
            ///Bits 4:5 - RW, UART parity mode: 00-odd, 01-even, 10-mark, 11-space
            #[inline(always)]
            #[must_use]
            pub fn lcr_par_mod(&mut self) -> LCR_PAR_MOD_W<4> {
                LCR_PAR_MOD_W::new(self)
            }
            ///Bit 6 - RW, UART break control enable
            #[inline(always)]
            #[must_use]
            pub fn lcr_break_en(&mut self) -> LCR_BREAK_EN_W<6> {
                LCR_BREAK_EN_W::new(self)
            }
            ///Bit 7 - RW, UART general purpose bit;RW, UART reserved bit
            #[inline(always)]
            #[must_use]
            pub fn lcr_gp_bit__rb_lcr_dlab(&mut self) -> LCR_GP_BIT__RB_LCR_DLAB_W<7> {
                LCR_GP_BIT__RB_LCR_DLAB_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, UART2 line control
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [uart2_lcr](index.html) module
        pub struct UART2_LCR_SPEC;
        impl crate::RegisterSpec for UART2_LCR_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [uart2_lcr::R](R) reader structure
        impl crate::Readable for UART2_LCR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [uart2_lcr::W](W) writer structure
        impl crate::Writable for UART2_LCR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets UART2_LCR to value 0
        impl crate::Resettable for UART2_LCR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///UART2_IIR (r) register accessor: an alias for `Reg<UART2_IIR_SPEC>`
    pub type UART2_IIR = crate::Reg<uart2_iir::UART2_IIR_SPEC>;
    ///RO, UART2 interrupt identification
    pub mod uart2_iir {
        ///Register `UART2_IIR` reader
        pub struct R(crate::R<UART2_IIR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<UART2_IIR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<UART2_IIR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<UART2_IIR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `IIR_NO_INT` reader - RO, UART no interrupt flag: 0=interrupt action, 1=no interrupt
        pub type IIR_NO_INT_R = crate::BitReader<bool>;
        ///Field `IIR_INT_MASK` reader - RO, UART interrupt flag bit mask
        pub type IIR_INT_MASK_R = crate::FieldReader<u8, u8>;
        ///Field `IIR_FIFO_ID` reader - RO, UART FIFO enabled flag
        pub type IIR_FIFO_ID_R = crate::BitReader<bool>;
        impl R {
            ///Bit 0 - RO, UART no interrupt flag: 0=interrupt action, 1=no interrupt
            #[inline(always)]
            pub fn iir_no_int(&self) -> IIR_NO_INT_R {
                IIR_NO_INT_R::new((self.bits & 1) != 0)
            }
            ///Bits 0:3 - RO, UART interrupt flag bit mask
            #[inline(always)]
            pub fn iir_int_mask(&self) -> IIR_INT_MASK_R {
                IIR_INT_MASK_R::new(self.bits & 0x0f)
            }
            ///Bit 7 - RO, UART FIFO enabled flag
            #[inline(always)]
            pub fn iir_fifo_id(&self) -> IIR_FIFO_ID_R {
                IIR_FIFO_ID_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        ///RO, UART2 interrupt identification
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [uart2_iir](index.html) module
        pub struct UART2_IIR_SPEC;
        impl crate::RegisterSpec for UART2_IIR_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [uart2_iir::R](R) reader structure
        impl crate::Readable for UART2_IIR_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets UART2_IIR to value 0x01
        impl crate::Resettable for UART2_IIR_SPEC {
            const RESET_VALUE: Self::Ux = 0x01;
        }
    }
    ///UART2_LSR (r) register accessor: an alias for `Reg<UART2_LSR_SPEC>`
    pub type UART2_LSR = crate::Reg<uart2_lsr::UART2_LSR_SPEC>;
    ///RO, UART2 line status
    pub mod uart2_lsr {
        ///Register `UART2_LSR` reader
        pub struct R(crate::R<UART2_LSR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<UART2_LSR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<UART2_LSR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<UART2_LSR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `LSR_DATA_RDY` reader - RO, UART receiver fifo data ready status
        pub type LSR_DATA_RDY_R = crate::BitReader<bool>;
        ///Field `LSR_OVER_ERR` reader - RZ, UART receiver overrun error
        pub type LSR_OVER_ERR_R = crate::BitReader<bool>;
        ///Field `LSR_PAR_ERR` reader - RZ, UART receiver parity error
        pub type LSR_PAR_ERR_R = crate::BitReader<bool>;
        ///Field `LSR_FRAME_ERR` reader - RZ, UART receiver frame error
        pub type LSR_FRAME_ERR_R = crate::BitReader<bool>;
        ///Field `LSR_BREAK_ERR` reader - RZ, UART receiver break error
        pub type LSR_BREAK_ERR_R = crate::BitReader<bool>;
        ///Field `LSR_TX_FIFO_EMP` reader - RO, UART transmitter fifo empty status
        pub type LSR_TX_FIFO_EMP_R = crate::BitReader<bool>;
        ///Field `LSR_TX_ALL_EMP` reader - RO, UART transmitter all empty status
        pub type LSR_TX_ALL_EMP_R = crate::BitReader<bool>;
        ///Field `LSR_ERR_RX_FIFO` reader - RO, indicate error in UART receiver fifo
        pub type LSR_ERR_RX_FIFO_R = crate::BitReader<bool>;
        impl R {
            ///Bit 0 - RO, UART receiver fifo data ready status
            #[inline(always)]
            pub fn lsr_data_rdy(&self) -> LSR_DATA_RDY_R {
                LSR_DATA_RDY_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RZ, UART receiver overrun error
            #[inline(always)]
            pub fn lsr_over_err(&self) -> LSR_OVER_ERR_R {
                LSR_OVER_ERR_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RZ, UART receiver parity error
            #[inline(always)]
            pub fn lsr_par_err(&self) -> LSR_PAR_ERR_R {
                LSR_PAR_ERR_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RZ, UART receiver frame error
            #[inline(always)]
            pub fn lsr_frame_err(&self) -> LSR_FRAME_ERR_R {
                LSR_FRAME_ERR_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RZ, UART receiver break error
            #[inline(always)]
            pub fn lsr_break_err(&self) -> LSR_BREAK_ERR_R {
                LSR_BREAK_ERR_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - RO, UART transmitter fifo empty status
            #[inline(always)]
            pub fn lsr_tx_fifo_emp(&self) -> LSR_TX_FIFO_EMP_R {
                LSR_TX_FIFO_EMP_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - RO, UART transmitter all empty status
            #[inline(always)]
            pub fn lsr_tx_all_emp(&self) -> LSR_TX_ALL_EMP_R {
                LSR_TX_ALL_EMP_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - RO, indicate error in UART receiver fifo
            #[inline(always)]
            pub fn lsr_err_rx_fifo(&self) -> LSR_ERR_RX_FIFO_R {
                LSR_ERR_RX_FIFO_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        ///RO, UART2 line status
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [uart2_lsr](index.html) module
        pub struct UART2_LSR_SPEC;
        impl crate::RegisterSpec for UART2_LSR_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [uart2_lsr::R](R) reader structure
        impl crate::Readable for UART2_LSR_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets UART2_LSR to value 0x60
        impl crate::Resettable for UART2_LSR_SPEC {
            const RESET_VALUE: Self::Ux = 0x60;
        }
    }
    ///UART2_RBR (r) register accessor: an alias for `Reg<UART2_RBR_SPEC>`
    pub type UART2_RBR = crate::Reg<uart2_rbr::UART2_RBR_SPEC>;
    ///RO, UART2 receiver buffer, receiving byte
    pub mod uart2_rbr {
        ///Register `UART2_RBR` reader
        pub struct R(crate::R<UART2_RBR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<UART2_RBR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<UART2_RBR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<UART2_RBR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `UART2_RBR` reader - RO, UART2 receiver buffer, receiving byte
        pub type UART2_RBR_R = crate::FieldReader<u8, u8>;
        impl R {
            ///Bits 0:7 - RO, UART2 receiver buffer, receiving byte
            #[inline(always)]
            pub fn uart2_rbr(&self) -> UART2_RBR_R {
                UART2_RBR_R::new(self.bits)
            }
        }
        ///RO, UART2 receiver buffer, receiving byte
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [uart2_rbr](index.html) module
        pub struct UART2_RBR_SPEC;
        impl crate::RegisterSpec for UART2_RBR_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [uart2_rbr::R](R) reader structure
        impl crate::Readable for UART2_RBR_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets UART2_RBR to value 0
        impl crate::Resettable for UART2_RBR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///UART2_THR (w) register accessor: an alias for `Reg<UART2_THR_SPEC>`
    pub type UART2_THR = crate::Reg<uart2_thr::UART2_THR_SPEC>;
    ///WO, UART2 transmitter holding, transmittal byte
    pub mod uart2_thr {
        ///Register `UART2_THR` writer
        pub struct W(crate::W<UART2_THR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<UART2_THR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<UART2_THR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<UART2_THR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `UART2_THR` writer - WO, UART2 transmitter holding, transmittal byte
        pub type UART2_THR_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, UART2_THR_SPEC, u8, u8, 8, O>;
        impl W {
            ///Bits 0:7 - WO, UART2 transmitter holding, transmittal byte
            #[inline(always)]
            #[must_use]
            pub fn uart2_thr(&mut self) -> UART2_THR_W<0> {
                UART2_THR_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///WO, UART2 transmitter holding, transmittal byte
        ///
        ///This register you can [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [uart2_thr](index.html) module
        pub struct UART2_THR_SPEC;
        impl crate::RegisterSpec for UART2_THR_SPEC {
            type Ux = u8;
        }
        ///`write(|w| ..)` method takes [uart2_thr::W](W) writer structure
        impl crate::Writable for UART2_THR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets UART2_THR to value 0
        impl crate::Resettable for UART2_THR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///UART2_RFC (r) register accessor: an alias for `Reg<UART2_RFC_SPEC>`
    pub type UART2_RFC = crate::Reg<uart2_rfc::UART2_RFC_SPEC>;
    ///RO, UART2 receiver FIFO count
    pub mod uart2_rfc {
        ///Register `UART2_RFC` reader
        pub struct R(crate::R<UART2_RFC_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<UART2_RFC_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<UART2_RFC_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<UART2_RFC_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `UART2_RFC` reader - RO, UART2 receiver FIFO count
        pub type UART2_RFC_R = crate::FieldReader<u8, u8>;
        impl R {
            ///Bits 0:7 - RO, UART2 receiver FIFO count
            #[inline(always)]
            pub fn uart2_rfc(&self) -> UART2_RFC_R {
                UART2_RFC_R::new(self.bits)
            }
        }
        ///RO, UART2 receiver FIFO count
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [uart2_rfc](index.html) module
        pub struct UART2_RFC_SPEC;
        impl crate::RegisterSpec for UART2_RFC_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [uart2_rfc::R](R) reader structure
        impl crate::Readable for UART2_RFC_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets UART2_RFC to value 0
        impl crate::Resettable for UART2_RFC_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///UART2_TFC (r) register accessor: an alias for `Reg<UART2_TFC_SPEC>`
    pub type UART2_TFC = crate::Reg<uart2_tfc::UART2_TFC_SPEC>;
    ///RO, UART2 transmitter FIFO count
    pub mod uart2_tfc {
        ///Register `UART2_TFC` reader
        pub struct R(crate::R<UART2_TFC_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<UART2_TFC_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<UART2_TFC_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<UART2_TFC_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `UART2_TFC` reader - RO, UART2 transmitter FIFO count
        pub type UART2_TFC_R = crate::FieldReader<u8, u8>;
        impl R {
            ///Bits 0:7 - RO, UART2 transmitter FIFO count
            #[inline(always)]
            pub fn uart2_tfc(&self) -> UART2_TFC_R {
                UART2_TFC_R::new(self.bits)
            }
        }
        ///RO, UART2 transmitter FIFO count
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [uart2_tfc](index.html) module
        pub struct UART2_TFC_SPEC;
        impl crate::RegisterSpec for UART2_TFC_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [uart2_tfc::R](R) reader structure
        impl crate::Readable for UART2_TFC_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets UART2_TFC to value 0
        impl crate::Resettable for UART2_TFC_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///UART2_DL (rw) register accessor: an alias for `Reg<UART2_DL_SPEC>`
    pub type UART2_DL = crate::Reg<uart2_dl::UART2_DL_SPEC>;
    ///RW, UART2 divisor latch
    pub mod uart2_dl {
        ///Register `UART2_DL` reader
        pub struct R(crate::R<UART2_DL_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<UART2_DL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<UART2_DL_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<UART2_DL_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `UART2_DL` writer
        pub struct W(crate::W<UART2_DL_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<UART2_DL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<UART2_DL_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<UART2_DL_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `UART2_DL` reader - RW, UART2 divisor latch
        pub type UART2_DL_R = crate::FieldReader<u16, u16>;
        ///Field `UART2_DL` writer - RW, UART2 divisor latch
        pub type UART2_DL_W<'a, const O: u8> =
            crate::FieldWriter<'a, u16, UART2_DL_SPEC, u16, u16, 16, O>;
        impl R {
            ///Bits 0:15 - RW, UART2 divisor latch
            #[inline(always)]
            pub fn uart2_dl(&self) -> UART2_DL_R {
                UART2_DL_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - RW, UART2 divisor latch
            #[inline(always)]
            #[must_use]
            pub fn uart2_dl(&mut self) -> UART2_DL_W<0> {
                UART2_DL_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, UART2 divisor latch
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [uart2_dl](index.html) module
        pub struct UART2_DL_SPEC;
        impl crate::RegisterSpec for UART2_DL_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [uart2_dl::R](R) reader structure
        impl crate::Readable for UART2_DL_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [uart2_dl::W](W) writer structure
        impl crate::Writable for UART2_DL_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets UART2_DL to value 0
        impl crate::Resettable for UART2_DL_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///UART2_DIV (rw) register accessor: an alias for `Reg<UART2_DIV_SPEC>`
    pub type UART2_DIV = crate::Reg<uart2_div::UART2_DIV_SPEC>;
    ///RW, UART2 pre-divisor latch byte, only low 7 bit, from 1 to 128
    pub mod uart2_div {
        ///Register `UART2_DIV` reader
        pub struct R(crate::R<UART2_DIV_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<UART2_DIV_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<UART2_DIV_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<UART2_DIV_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `UART2_DIV` writer
        pub struct W(crate::W<UART2_DIV_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<UART2_DIV_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<UART2_DIV_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<UART2_DIV_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `UART2_DIV` reader - RW, UART2 pre-divisor latch byte, only low 7 bit, from 1 to 128
        pub type UART2_DIV_R = crate::FieldReader<u8, u8>;
        ///Field `UART2_DIV` writer - RW, UART2 pre-divisor latch byte, only low 7 bit, from 1 to 128
        pub type UART2_DIV_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, UART2_DIV_SPEC, u8, u8, 8, O>;
        impl R {
            ///Bits 0:7 - RW, UART2 pre-divisor latch byte, only low 7 bit, from 1 to 128
            #[inline(always)]
            pub fn uart2_div(&self) -> UART2_DIV_R {
                UART2_DIV_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:7 - RW, UART2 pre-divisor latch byte, only low 7 bit, from 1 to 128
            #[inline(always)]
            #[must_use]
            pub fn uart2_div(&mut self) -> UART2_DIV_W<0> {
                UART2_DIV_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, UART2 pre-divisor latch byte, only low 7 bit, from 1 to 128
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [uart2_div](index.html) module
        pub struct UART2_DIV_SPEC;
        impl crate::RegisterSpec for UART2_DIV_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [uart2_div::R](R) reader structure
        impl crate::Readable for UART2_DIV_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [uart2_div::W](W) writer structure
        impl crate::Writable for UART2_DIV_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets UART2_DIV to value 0
        impl crate::Resettable for UART2_DIV_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
}
///UART3 register
pub struct UART3 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for UART3 {}
impl UART3 {
    ///Pointer to the register block
    pub const PTR: *const uart3::RegisterBlock = 0x4000_3c00 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const uart3::RegisterBlock {
        Self::PTR
    }
}
impl Deref for UART3 {
    type Target = uart3::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for UART3 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("UART3").finish()
    }
}
///UART3 register
pub mod uart3 {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        ///0x00 - RW, UART3 modem control
        pub uart3_mcr: UART3_MCR,
        ///0x01 - RW, UART3 interrupt enable
        pub uart3_ier: UART3_IER,
        ///0x02 - RW, UART3 FIFO control
        pub uart3_fcr: UART3_FCR,
        ///0x03 - RW, UART3 line control
        pub uart3_lcr: UART3_LCR,
        ///0x04 - RO, UART3 interrupt identification
        pub uart3_iir: UART3_IIR,
        ///0x05 - RO, UART3 line status
        pub uart3_lsr: UART3_LSR,
        _reserved6: [u8; 0x02],
        _reserved_6_uart3: [u8; 0x01],
        _reserved7: [u8; 0x01],
        ///0x0a - RO, UART3 receiver FIFO count
        pub uart3_rfc: UART3_RFC,
        ///0x0b - RO, UART3 transmitter FIFO count
        pub uart3_tfc: UART3_TFC,
        ///0x0c - RW, UART3 divisor latch
        pub uart3_dl: UART3_DL,
        ///0x0e - RW, UART3 pre-divisor latch byte, only low 7 bit, from 1 to 128
        pub uart3_div: UART3_DIV,
    }
    impl RegisterBlock {
        ///0x08 - WO, UART3 transmitter holding, transmittal byte
        #[inline(always)]
        pub const fn uart3_thr(&self) -> &UART3_THR {
            unsafe { &*(self as *const Self).cast::<u8>().add(8usize).cast() }
        }
        ///0x08 - RO, UART3 receiver buffer, receiving byte
        #[inline(always)]
        pub const fn uart3_rbr(&self) -> &UART3_RBR {
            unsafe { &*(self as *const Self).cast::<u8>().add(8usize).cast() }
        }
    }
    ///UART3_MCR (rw) register accessor: an alias for `Reg<UART3_MCR_SPEC>`
    pub type UART3_MCR = crate::Reg<uart3_mcr::UART3_MCR_SPEC>;
    ///RW, UART3 modem control
    pub mod uart3_mcr {
        ///Register `UART3_MCR` reader
        pub struct R(crate::R<UART3_MCR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<UART3_MCR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<UART3_MCR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<UART3_MCR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `UART3_MCR` writer
        pub struct W(crate::W<UART3_MCR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<UART3_MCR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<UART3_MCR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<UART3_MCR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `MCR_OUT2__RB_MCR_INT_OE` reader - RW, UART control OUT2;UART interrupt output enable
        pub type MCR_OUT2__RB_MCR_INT_OE_R = crate::BitReader<bool>;
        ///Field `MCR_OUT2__RB_MCR_INT_OE` writer - RW, UART control OUT2;UART interrupt output enable
        pub type MCR_OUT2__RB_MCR_INT_OE_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, UART3_MCR_SPEC, bool, O>;
        impl R {
            ///Bit 3 - RW, UART control OUT2;UART interrupt output enable
            #[inline(always)]
            pub fn mcr_out2__rb_mcr_int_oe(&self) -> MCR_OUT2__RB_MCR_INT_OE_R {
                MCR_OUT2__RB_MCR_INT_OE_R::new(((self.bits >> 3) & 1) != 0)
            }
        }
        impl W {
            ///Bit 3 - RW, UART control OUT2;UART interrupt output enable
            #[inline(always)]
            #[must_use]
            pub fn mcr_out2__rb_mcr_int_oe(&mut self) -> MCR_OUT2__RB_MCR_INT_OE_W<3> {
                MCR_OUT2__RB_MCR_INT_OE_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, UART3 modem control
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [uart3_mcr](index.html) module
        pub struct UART3_MCR_SPEC;
        impl crate::RegisterSpec for UART3_MCR_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [uart3_mcr::R](R) reader structure
        impl crate::Readable for UART3_MCR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [uart3_mcr::W](W) writer structure
        impl crate::Writable for UART3_MCR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets UART3_MCR to value 0
        impl crate::Resettable for UART3_MCR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///UART3_IER (rw) register accessor: an alias for `Reg<UART3_IER_SPEC>`
    pub type UART3_IER = crate::Reg<uart3_ier::UART3_IER_SPEC>;
    ///RW, UART3 interrupt enable
    pub mod uart3_ier {
        ///Register `UART3_IER` reader
        pub struct R(crate::R<UART3_IER_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<UART3_IER_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<UART3_IER_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<UART3_IER_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `UART3_IER` writer
        pub struct W(crate::W<UART3_IER_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<UART3_IER_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<UART3_IER_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<UART3_IER_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IER_RECV_RDY` reader - RW, UART interrupt enable for receiver data ready
        pub type IER_RECV_RDY_R = crate::BitReader<bool>;
        ///Field `IER_RECV_RDY` writer - RW, UART interrupt enable for receiver data ready
        pub type IER_RECV_RDY_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, UART3_IER_SPEC, bool, O>;
        ///Field `IER_THR_EMPTY` reader - RW, UART interrupt enable for THR empty
        pub type IER_THR_EMPTY_R = crate::BitReader<bool>;
        ///Field `IER_THR_EMPTY` writer - RW, UART interrupt enable for THR empty
        pub type IER_THR_EMPTY_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, UART3_IER_SPEC, bool, O>;
        ///Field `IER_LINE_STAT` reader - RW, UART interrupt enable for receiver line status
        pub type IER_LINE_STAT_R = crate::BitReader<bool>;
        ///Field `IER_LINE_STAT` writer - RW, UART interrupt enable for receiver line status
        pub type IER_LINE_STAT_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, UART3_IER_SPEC, bool, O>;
        ///Field `IER_TXD_EN` reader - RW, UART TXD pin enable
        pub type IER_TXD_EN_R = crate::BitReader<bool>;
        ///Field `IER_TXD_EN` writer - RW, UART TXD pin enable
        pub type IER_TXD_EN_W<'a, const O: u8> = crate::BitWriter<'a, u8, UART3_IER_SPEC, bool, O>;
        ///Field `IER_RESET` reader - WZ, UART software reset control, high action, auto clear
        pub type IER_RESET_R = crate::BitReader<bool>;
        ///Field `IER_RESET` writer - WZ, UART software reset control, high action, auto clear
        pub type IER_RESET_W<'a, const O: u8> = crate::BitWriter<'a, u8, UART3_IER_SPEC, bool, O>;
        impl R {
            ///Bit 0 - RW, UART interrupt enable for receiver data ready
            #[inline(always)]
            pub fn ier_recv_rdy(&self) -> IER_RECV_RDY_R {
                IER_RECV_RDY_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RW, UART interrupt enable for THR empty
            #[inline(always)]
            pub fn ier_thr_empty(&self) -> IER_THR_EMPTY_R {
                IER_THR_EMPTY_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RW, UART interrupt enable for receiver line status
            #[inline(always)]
            pub fn ier_line_stat(&self) -> IER_LINE_STAT_R {
                IER_LINE_STAT_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 6 - RW, UART TXD pin enable
            #[inline(always)]
            pub fn ier_txd_en(&self) -> IER_TXD_EN_R {
                IER_TXD_EN_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - WZ, UART software reset control, high action, auto clear
            #[inline(always)]
            pub fn ier_reset(&self) -> IER_RESET_R {
                IER_RESET_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RW, UART interrupt enable for receiver data ready
            #[inline(always)]
            #[must_use]
            pub fn ier_recv_rdy(&mut self) -> IER_RECV_RDY_W<0> {
                IER_RECV_RDY_W::new(self)
            }
            ///Bit 1 - RW, UART interrupt enable for THR empty
            #[inline(always)]
            #[must_use]
            pub fn ier_thr_empty(&mut self) -> IER_THR_EMPTY_W<1> {
                IER_THR_EMPTY_W::new(self)
            }
            ///Bit 2 - RW, UART interrupt enable for receiver line status
            #[inline(always)]
            #[must_use]
            pub fn ier_line_stat(&mut self) -> IER_LINE_STAT_W<2> {
                IER_LINE_STAT_W::new(self)
            }
            ///Bit 6 - RW, UART TXD pin enable
            #[inline(always)]
            #[must_use]
            pub fn ier_txd_en(&mut self) -> IER_TXD_EN_W<6> {
                IER_TXD_EN_W::new(self)
            }
            ///Bit 7 - WZ, UART software reset control, high action, auto clear
            #[inline(always)]
            #[must_use]
            pub fn ier_reset(&mut self) -> IER_RESET_W<7> {
                IER_RESET_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, UART3 interrupt enable
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [uart3_ier](index.html) module
        pub struct UART3_IER_SPEC;
        impl crate::RegisterSpec for UART3_IER_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [uart3_ier::R](R) reader structure
        impl crate::Readable for UART3_IER_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [uart3_ier::W](W) writer structure
        impl crate::Writable for UART3_IER_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets UART3_IER to value 0
        impl crate::Resettable for UART3_IER_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///UART3_FCR (rw) register accessor: an alias for `Reg<UART3_FCR_SPEC>`
    pub type UART3_FCR = crate::Reg<uart3_fcr::UART3_FCR_SPEC>;
    ///RW, UART3 FIFO control
    pub mod uart3_fcr {
        ///Register `UART3_FCR` reader
        pub struct R(crate::R<UART3_FCR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<UART3_FCR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<UART3_FCR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<UART3_FCR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `UART3_FCR` writer
        pub struct W(crate::W<UART3_FCR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<UART3_FCR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<UART3_FCR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<UART3_FCR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `FCR_FIFO_EN` reader - RW, UART FIFO enable
        pub type FCR_FIFO_EN_R = crate::BitReader<bool>;
        ///Field `FCR_FIFO_EN` writer - RW, UART FIFO enable
        pub type FCR_FIFO_EN_W<'a, const O: u8> = crate::BitWriter<'a, u8, UART3_FCR_SPEC, bool, O>;
        ///Field `FCR_RX_FIFO_CLR` reader - WZ, clear UART receiver FIFO, high action, auto clear
        pub type FCR_RX_FIFO_CLR_R = crate::BitReader<bool>;
        ///Field `FCR_RX_FIFO_CLR` writer - WZ, clear UART receiver FIFO, high action, auto clear
        pub type FCR_RX_FIFO_CLR_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, UART3_FCR_SPEC, bool, O>;
        ///Field `FCR_TX_FIFO_CLR` reader - WZ, clear UART transmitter FIFO, high action, auto clear
        pub type FCR_TX_FIFO_CLR_R = crate::BitReader<bool>;
        ///Field `FCR_TX_FIFO_CLR` writer - WZ, clear UART transmitter FIFO, high action, auto clear
        pub type FCR_TX_FIFO_CLR_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, UART3_FCR_SPEC, bool, O>;
        ///Field `FCR_FIFO_TRIG` reader - RW, UART receiver FIFO trigger level: 00-1byte, 01-2bytes, 10-4bytes, 11-7bytes
        pub type FCR_FIFO_TRIG_R = crate::FieldReader<u8, u8>;
        ///Field `FCR_FIFO_TRIG` writer - RW, UART receiver FIFO trigger level: 00-1byte, 01-2bytes, 10-4bytes, 11-7bytes
        pub type FCR_FIFO_TRIG_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, UART3_FCR_SPEC, u8, u8, 2, O>;
        impl R {
            ///Bit 0 - RW, UART FIFO enable
            #[inline(always)]
            pub fn fcr_fifo_en(&self) -> FCR_FIFO_EN_R {
                FCR_FIFO_EN_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - WZ, clear UART receiver FIFO, high action, auto clear
            #[inline(always)]
            pub fn fcr_rx_fifo_clr(&self) -> FCR_RX_FIFO_CLR_R {
                FCR_RX_FIFO_CLR_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - WZ, clear UART transmitter FIFO, high action, auto clear
            #[inline(always)]
            pub fn fcr_tx_fifo_clr(&self) -> FCR_TX_FIFO_CLR_R {
                FCR_TX_FIFO_CLR_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bits 6:7 - RW, UART receiver FIFO trigger level: 00-1byte, 01-2bytes, 10-4bytes, 11-7bytes
            #[inline(always)]
            pub fn fcr_fifo_trig(&self) -> FCR_FIFO_TRIG_R {
                FCR_FIFO_TRIG_R::new((self.bits >> 6) & 3)
            }
        }
        impl W {
            ///Bit 0 - RW, UART FIFO enable
            #[inline(always)]
            #[must_use]
            pub fn fcr_fifo_en(&mut self) -> FCR_FIFO_EN_W<0> {
                FCR_FIFO_EN_W::new(self)
            }
            ///Bit 1 - WZ, clear UART receiver FIFO, high action, auto clear
            #[inline(always)]
            #[must_use]
            pub fn fcr_rx_fifo_clr(&mut self) -> FCR_RX_FIFO_CLR_W<1> {
                FCR_RX_FIFO_CLR_W::new(self)
            }
            ///Bit 2 - WZ, clear UART transmitter FIFO, high action, auto clear
            #[inline(always)]
            #[must_use]
            pub fn fcr_tx_fifo_clr(&mut self) -> FCR_TX_FIFO_CLR_W<2> {
                FCR_TX_FIFO_CLR_W::new(self)
            }
            ///Bits 6:7 - RW, UART receiver FIFO trigger level: 00-1byte, 01-2bytes, 10-4bytes, 11-7bytes
            #[inline(always)]
            #[must_use]
            pub fn fcr_fifo_trig(&mut self) -> FCR_FIFO_TRIG_W<6> {
                FCR_FIFO_TRIG_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, UART3 FIFO control
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [uart3_fcr](index.html) module
        pub struct UART3_FCR_SPEC;
        impl crate::RegisterSpec for UART3_FCR_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [uart3_fcr::R](R) reader structure
        impl crate::Readable for UART3_FCR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [uart3_fcr::W](W) writer structure
        impl crate::Writable for UART3_FCR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets UART3_FCR to value 0
        impl crate::Resettable for UART3_FCR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///UART3_LCR (rw) register accessor: an alias for `Reg<UART3_LCR_SPEC>`
    pub type UART3_LCR = crate::Reg<uart3_lcr::UART3_LCR_SPEC>;
    ///RW, UART3 line control
    pub mod uart3_lcr {
        ///Register `UART3_LCR` reader
        pub struct R(crate::R<UART3_LCR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<UART3_LCR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<UART3_LCR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<UART3_LCR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `UART3_LCR` writer
        pub struct W(crate::W<UART3_LCR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<UART3_LCR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<UART3_LCR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<UART3_LCR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `LCR_WORD_SZ` reader - RW, UART word bit length: 00-5bit, 01-6bit, 10-7bit, 11-8bit
        pub type LCR_WORD_SZ_R = crate::FieldReader<u8, u8>;
        ///Field `LCR_WORD_SZ` writer - RW, UART word bit length: 00-5bit, 01-6bit, 10-7bit, 11-8bit
        pub type LCR_WORD_SZ_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, UART3_LCR_SPEC, u8, u8, 2, O>;
        ///Field `LCR_STOP_BIT` reader - RW, UART stop bit length: 0-1bit, 1-2bit
        pub type LCR_STOP_BIT_R = crate::BitReader<bool>;
        ///Field `LCR_STOP_BIT` writer - RW, UART stop bit length: 0-1bit, 1-2bit
        pub type LCR_STOP_BIT_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, UART3_LCR_SPEC, bool, O>;
        ///Field `LCR_PAR_EN` reader - RW, UART parity enable
        pub type LCR_PAR_EN_R = crate::BitReader<bool>;
        ///Field `LCR_PAR_EN` writer - RW, UART parity enable
        pub type LCR_PAR_EN_W<'a, const O: u8> = crate::BitWriter<'a, u8, UART3_LCR_SPEC, bool, O>;
        ///Field `LCR_PAR_MOD` reader - RW, UART parity mode: 00-odd, 01-even, 10-mark, 11-space
        pub type LCR_PAR_MOD_R = crate::FieldReader<u8, u8>;
        ///Field `LCR_PAR_MOD` writer - RW, UART parity mode: 00-odd, 01-even, 10-mark, 11-space
        pub type LCR_PAR_MOD_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, UART3_LCR_SPEC, u8, u8, 2, O>;
        ///Field `LCR_BREAK_EN` reader - RW, UART break control enable
        pub type LCR_BREAK_EN_R = crate::BitReader<bool>;
        ///Field `LCR_BREAK_EN` writer - RW, UART break control enable
        pub type LCR_BREAK_EN_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, UART3_LCR_SPEC, bool, O>;
        ///Field `LCR_GP_BIT__RB_LCR_DLAB` reader - RW, UART general purpose bit;RW, UART reserved bit
        pub type LCR_GP_BIT__RB_LCR_DLAB_R = crate::BitReader<bool>;
        ///Field `LCR_GP_BIT__RB_LCR_DLAB` writer - RW, UART general purpose bit;RW, UART reserved bit
        pub type LCR_GP_BIT__RB_LCR_DLAB_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, UART3_LCR_SPEC, bool, O>;
        impl R {
            ///Bits 0:1 - RW, UART word bit length: 00-5bit, 01-6bit, 10-7bit, 11-8bit
            #[inline(always)]
            pub fn lcr_word_sz(&self) -> LCR_WORD_SZ_R {
                LCR_WORD_SZ_R::new(self.bits & 3)
            }
            ///Bit 2 - RW, UART stop bit length: 0-1bit, 1-2bit
            #[inline(always)]
            pub fn lcr_stop_bit(&self) -> LCR_STOP_BIT_R {
                LCR_STOP_BIT_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RW, UART parity enable
            #[inline(always)]
            pub fn lcr_par_en(&self) -> LCR_PAR_EN_R {
                LCR_PAR_EN_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bits 4:5 - RW, UART parity mode: 00-odd, 01-even, 10-mark, 11-space
            #[inline(always)]
            pub fn lcr_par_mod(&self) -> LCR_PAR_MOD_R {
                LCR_PAR_MOD_R::new((self.bits >> 4) & 3)
            }
            ///Bit 6 - RW, UART break control enable
            #[inline(always)]
            pub fn lcr_break_en(&self) -> LCR_BREAK_EN_R {
                LCR_BREAK_EN_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - RW, UART general purpose bit;RW, UART reserved bit
            #[inline(always)]
            pub fn lcr_gp_bit__rb_lcr_dlab(&self) -> LCR_GP_BIT__RB_LCR_DLAB_R {
                LCR_GP_BIT__RB_LCR_DLAB_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:1 - RW, UART word bit length: 00-5bit, 01-6bit, 10-7bit, 11-8bit
            #[inline(always)]
            #[must_use]
            pub fn lcr_word_sz(&mut self) -> LCR_WORD_SZ_W<0> {
                LCR_WORD_SZ_W::new(self)
            }
            ///Bit 2 - RW, UART stop bit length: 0-1bit, 1-2bit
            #[inline(always)]
            #[must_use]
            pub fn lcr_stop_bit(&mut self) -> LCR_STOP_BIT_W<2> {
                LCR_STOP_BIT_W::new(self)
            }
            ///Bit 3 - RW, UART parity enable
            #[inline(always)]
            #[must_use]
            pub fn lcr_par_en(&mut self) -> LCR_PAR_EN_W<3> {
                LCR_PAR_EN_W::new(self)
            }
            ///Bits 4:5 - RW, UART parity mode: 00-odd, 01-even, 10-mark, 11-space
            #[inline(always)]
            #[must_use]
            pub fn lcr_par_mod(&mut self) -> LCR_PAR_MOD_W<4> {
                LCR_PAR_MOD_W::new(self)
            }
            ///Bit 6 - RW, UART break control enable
            #[inline(always)]
            #[must_use]
            pub fn lcr_break_en(&mut self) -> LCR_BREAK_EN_W<6> {
                LCR_BREAK_EN_W::new(self)
            }
            ///Bit 7 - RW, UART general purpose bit;RW, UART reserved bit
            #[inline(always)]
            #[must_use]
            pub fn lcr_gp_bit__rb_lcr_dlab(&mut self) -> LCR_GP_BIT__RB_LCR_DLAB_W<7> {
                LCR_GP_BIT__RB_LCR_DLAB_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, UART3 line control
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [uart3_lcr](index.html) module
        pub struct UART3_LCR_SPEC;
        impl crate::RegisterSpec for UART3_LCR_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [uart3_lcr::R](R) reader structure
        impl crate::Readable for UART3_LCR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [uart3_lcr::W](W) writer structure
        impl crate::Writable for UART3_LCR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets UART3_LCR to value 0
        impl crate::Resettable for UART3_LCR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///UART3_IIR (r) register accessor: an alias for `Reg<UART3_IIR_SPEC>`
    pub type UART3_IIR = crate::Reg<uart3_iir::UART3_IIR_SPEC>;
    ///RO, UART3 interrupt identification
    pub mod uart3_iir {
        ///Register `UART3_IIR` reader
        pub struct R(crate::R<UART3_IIR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<UART3_IIR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<UART3_IIR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<UART3_IIR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `IIR_NO_INT` reader - RO, UART no interrupt flag: 0=interrupt action, 1=no interrupt
        pub type IIR_NO_INT_R = crate::BitReader<bool>;
        ///Field `IIR_INT_MASK` reader - RO, UART interrupt flag bit mask
        pub type IIR_INT_MASK_R = crate::FieldReader<u8, u8>;
        ///Field `IIR_FIFO_ID` reader - RO, UART FIFO enabled flag
        pub type IIR_FIFO_ID_R = crate::BitReader<bool>;
        impl R {
            ///Bit 0 - RO, UART no interrupt flag: 0=interrupt action, 1=no interrupt
            #[inline(always)]
            pub fn iir_no_int(&self) -> IIR_NO_INT_R {
                IIR_NO_INT_R::new((self.bits & 1) != 0)
            }
            ///Bits 1:3 - RO, UART interrupt flag bit mask
            #[inline(always)]
            pub fn iir_int_mask(&self) -> IIR_INT_MASK_R {
                IIR_INT_MASK_R::new((self.bits >> 1) & 7)
            }
            ///Bit 7 - RO, UART FIFO enabled flag
            #[inline(always)]
            pub fn iir_fifo_id(&self) -> IIR_FIFO_ID_R {
                IIR_FIFO_ID_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        ///RO, UART3 interrupt identification
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [uart3_iir](index.html) module
        pub struct UART3_IIR_SPEC;
        impl crate::RegisterSpec for UART3_IIR_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [uart3_iir::R](R) reader structure
        impl crate::Readable for UART3_IIR_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets UART3_IIR to value 0x01
        impl crate::Resettable for UART3_IIR_SPEC {
            const RESET_VALUE: Self::Ux = 0x01;
        }
    }
    ///UART3_LSR (r) register accessor: an alias for `Reg<UART3_LSR_SPEC>`
    pub type UART3_LSR = crate::Reg<uart3_lsr::UART3_LSR_SPEC>;
    ///RO, UART3 line status
    pub mod uart3_lsr {
        ///Register `UART3_LSR` reader
        pub struct R(crate::R<UART3_LSR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<UART3_LSR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<UART3_LSR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<UART3_LSR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `LSR_DATA_RDY` reader - RO, UART receiver fifo data ready status
        pub type LSR_DATA_RDY_R = crate::BitReader<bool>;
        ///Field `LSR_OVER_ERR` reader - RZ, UART receiver overrun error
        pub type LSR_OVER_ERR_R = crate::BitReader<bool>;
        ///Field `LSR_PAR_ERR` reader - RZ, UART receiver parity error
        pub type LSR_PAR_ERR_R = crate::BitReader<bool>;
        ///Field `LSR_FRAME_ERR` reader - RZ, UART receiver frame error
        pub type LSR_FRAME_ERR_R = crate::BitReader<bool>;
        ///Field `LSR_BREAK_ERR` reader - RZ, UART receiver break error
        pub type LSR_BREAK_ERR_R = crate::BitReader<bool>;
        ///Field `LSR_TX_FIFO_EMP` reader - RO, UART transmitter fifo empty status
        pub type LSR_TX_FIFO_EMP_R = crate::BitReader<bool>;
        ///Field `LSR_TX_ALL_EMP` reader - RO, UART transmitter all empty status
        pub type LSR_TX_ALL_EMP_R = crate::BitReader<bool>;
        ///Field `LSR_ERR_RX_FIFO` reader - RO, indicate error in UART receiver fifo
        pub type LSR_ERR_RX_FIFO_R = crate::BitReader<bool>;
        impl R {
            ///Bit 0 - RO, UART receiver fifo data ready status
            #[inline(always)]
            pub fn lsr_data_rdy(&self) -> LSR_DATA_RDY_R {
                LSR_DATA_RDY_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RZ, UART receiver overrun error
            #[inline(always)]
            pub fn lsr_over_err(&self) -> LSR_OVER_ERR_R {
                LSR_OVER_ERR_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RZ, UART receiver parity error
            #[inline(always)]
            pub fn lsr_par_err(&self) -> LSR_PAR_ERR_R {
                LSR_PAR_ERR_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RZ, UART receiver frame error
            #[inline(always)]
            pub fn lsr_frame_err(&self) -> LSR_FRAME_ERR_R {
                LSR_FRAME_ERR_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RZ, UART receiver break error
            #[inline(always)]
            pub fn lsr_break_err(&self) -> LSR_BREAK_ERR_R {
                LSR_BREAK_ERR_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - RO, UART transmitter fifo empty status
            #[inline(always)]
            pub fn lsr_tx_fifo_emp(&self) -> LSR_TX_FIFO_EMP_R {
                LSR_TX_FIFO_EMP_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - RO, UART transmitter all empty status
            #[inline(always)]
            pub fn lsr_tx_all_emp(&self) -> LSR_TX_ALL_EMP_R {
                LSR_TX_ALL_EMP_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - RO, indicate error in UART receiver fifo
            #[inline(always)]
            pub fn lsr_err_rx_fifo(&self) -> LSR_ERR_RX_FIFO_R {
                LSR_ERR_RX_FIFO_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        ///RO, UART3 line status
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [uart3_lsr](index.html) module
        pub struct UART3_LSR_SPEC;
        impl crate::RegisterSpec for UART3_LSR_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [uart3_lsr::R](R) reader structure
        impl crate::Readable for UART3_LSR_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets UART3_LSR to value 0x60
        impl crate::Resettable for UART3_LSR_SPEC {
            const RESET_VALUE: Self::Ux = 0x60;
        }
    }
    ///UART3_RBR (r) register accessor: an alias for `Reg<UART3_RBR_SPEC>`
    pub type UART3_RBR = crate::Reg<uart3_rbr::UART3_RBR_SPEC>;
    ///RO, UART3 receiver buffer, receiving byte
    pub mod uart3_rbr {
        ///Register `UART3_RBR` reader
        pub struct R(crate::R<UART3_RBR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<UART3_RBR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<UART3_RBR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<UART3_RBR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `UART3_RBR` reader - RO, UART3 receiver buffer, receiving byte
        pub type UART3_RBR_R = crate::FieldReader<u8, u8>;
        impl R {
            ///Bits 0:7 - RO, UART3 receiver buffer, receiving byte
            #[inline(always)]
            pub fn uart3_rbr(&self) -> UART3_RBR_R {
                UART3_RBR_R::new(self.bits)
            }
        }
        ///RO, UART3 receiver buffer, receiving byte
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [uart3_rbr](index.html) module
        pub struct UART3_RBR_SPEC;
        impl crate::RegisterSpec for UART3_RBR_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [uart3_rbr::R](R) reader structure
        impl crate::Readable for UART3_RBR_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets UART3_RBR to value 0
        impl crate::Resettable for UART3_RBR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///UART3_THR (w) register accessor: an alias for `Reg<UART3_THR_SPEC>`
    pub type UART3_THR = crate::Reg<uart3_thr::UART3_THR_SPEC>;
    ///WO, UART3 transmitter holding, transmittal byte
    pub mod uart3_thr {
        ///Register `UART3_THR` writer
        pub struct W(crate::W<UART3_THR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<UART3_THR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<UART3_THR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<UART3_THR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `UART3_THR` writer - WO, UART3 transmitter holding, transmittal byte
        pub type UART3_THR_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, UART3_THR_SPEC, u8, u8, 8, O>;
        impl W {
            ///Bits 0:7 - WO, UART3 transmitter holding, transmittal byte
            #[inline(always)]
            #[must_use]
            pub fn uart3_thr(&mut self) -> UART3_THR_W<0> {
                UART3_THR_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///WO, UART3 transmitter holding, transmittal byte
        ///
        ///This register you can [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [uart3_thr](index.html) module
        pub struct UART3_THR_SPEC;
        impl crate::RegisterSpec for UART3_THR_SPEC {
            type Ux = u8;
        }
        ///`write(|w| ..)` method takes [uart3_thr::W](W) writer structure
        impl crate::Writable for UART3_THR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets UART3_THR to value 0
        impl crate::Resettable for UART3_THR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///UART3_RFC (r) register accessor: an alias for `Reg<UART3_RFC_SPEC>`
    pub type UART3_RFC = crate::Reg<uart3_rfc::UART3_RFC_SPEC>;
    ///RO, UART3 receiver FIFO count
    pub mod uart3_rfc {
        ///Register `UART3_RFC` reader
        pub struct R(crate::R<UART3_RFC_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<UART3_RFC_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<UART3_RFC_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<UART3_RFC_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `UART3_RFC` reader - RO, UART3 receiver FIFO count
        pub type UART3_RFC_R = crate::FieldReader<u8, u8>;
        impl R {
            ///Bits 0:7 - RO, UART3 receiver FIFO count
            #[inline(always)]
            pub fn uart3_rfc(&self) -> UART3_RFC_R {
                UART3_RFC_R::new(self.bits)
            }
        }
        ///RO, UART3 receiver FIFO count
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [uart3_rfc](index.html) module
        pub struct UART3_RFC_SPEC;
        impl crate::RegisterSpec for UART3_RFC_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [uart3_rfc::R](R) reader structure
        impl crate::Readable for UART3_RFC_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets UART3_RFC to value 0
        impl crate::Resettable for UART3_RFC_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///UART3_TFC (r) register accessor: an alias for `Reg<UART3_TFC_SPEC>`
    pub type UART3_TFC = crate::Reg<uart3_tfc::UART3_TFC_SPEC>;
    ///RO, UART3 transmitter FIFO count
    pub mod uart3_tfc {
        ///Register `UART3_TFC` reader
        pub struct R(crate::R<UART3_TFC_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<UART3_TFC_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<UART3_TFC_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<UART3_TFC_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `UART3_TFC` reader - RO, UART3 transmitter FIFO count
        pub type UART3_TFC_R = crate::FieldReader<u8, u8>;
        impl R {
            ///Bits 0:7 - RO, UART3 transmitter FIFO count
            #[inline(always)]
            pub fn uart3_tfc(&self) -> UART3_TFC_R {
                UART3_TFC_R::new(self.bits)
            }
        }
        ///RO, UART3 transmitter FIFO count
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [uart3_tfc](index.html) module
        pub struct UART3_TFC_SPEC;
        impl crate::RegisterSpec for UART3_TFC_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [uart3_tfc::R](R) reader structure
        impl crate::Readable for UART3_TFC_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets UART3_TFC to value 0
        impl crate::Resettable for UART3_TFC_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///UART3_DL (rw) register accessor: an alias for `Reg<UART3_DL_SPEC>`
    pub type UART3_DL = crate::Reg<uart3_dl::UART3_DL_SPEC>;
    ///RW, UART3 divisor latch
    pub mod uart3_dl {
        ///Register `UART3_DL` reader
        pub struct R(crate::R<UART3_DL_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<UART3_DL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<UART3_DL_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<UART3_DL_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `UART3_DL` writer
        pub struct W(crate::W<UART3_DL_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<UART3_DL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<UART3_DL_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<UART3_DL_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `UART3_DL` reader - RW, UART3 divisor latch
        pub type UART3_DL_R = crate::FieldReader<u16, u16>;
        ///Field `UART3_DL` writer - RW, UART3 divisor latch
        pub type UART3_DL_W<'a, const O: u8> =
            crate::FieldWriter<'a, u16, UART3_DL_SPEC, u16, u16, 16, O>;
        impl R {
            ///Bits 0:15 - RW, UART3 divisor latch
            #[inline(always)]
            pub fn uart3_dl(&self) -> UART3_DL_R {
                UART3_DL_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - RW, UART3 divisor latch
            #[inline(always)]
            #[must_use]
            pub fn uart3_dl(&mut self) -> UART3_DL_W<0> {
                UART3_DL_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, UART3 divisor latch
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [uart3_dl](index.html) module
        pub struct UART3_DL_SPEC;
        impl crate::RegisterSpec for UART3_DL_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [uart3_dl::R](R) reader structure
        impl crate::Readable for UART3_DL_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [uart3_dl::W](W) writer structure
        impl crate::Writable for UART3_DL_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets UART3_DL to value 0
        impl crate::Resettable for UART3_DL_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///UART3_DIV (rw) register accessor: an alias for `Reg<UART3_DIV_SPEC>`
    pub type UART3_DIV = crate::Reg<uart3_div::UART3_DIV_SPEC>;
    ///RW, UART3 pre-divisor latch byte, only low 7 bit, from 1 to 128
    pub mod uart3_div {
        ///Register `UART3_DIV` reader
        pub struct R(crate::R<UART3_DIV_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<UART3_DIV_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<UART3_DIV_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<UART3_DIV_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `UART3_DIV` writer
        pub struct W(crate::W<UART3_DIV_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<UART3_DIV_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<UART3_DIV_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<UART3_DIV_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `UART3_DIV` reader - RW, UART3 pre-divisor latch byte, only low 7 bit, from 1 to 128
        pub type UART3_DIV_R = crate::FieldReader<u8, u8>;
        ///Field `UART3_DIV` writer - RW, UART3 pre-divisor latch byte, only low 7 bit, from 1 to 128
        pub type UART3_DIV_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, UART3_DIV_SPEC, u8, u8, 8, O>;
        impl R {
            ///Bits 0:7 - RW, UART3 pre-divisor latch byte, only low 7 bit, from 1 to 128
            #[inline(always)]
            pub fn uart3_div(&self) -> UART3_DIV_R {
                UART3_DIV_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:7 - RW, UART3 pre-divisor latch byte, only low 7 bit, from 1 to 128
            #[inline(always)]
            #[must_use]
            pub fn uart3_div(&mut self) -> UART3_DIV_W<0> {
                UART3_DIV_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, UART3 pre-divisor latch byte, only low 7 bit, from 1 to 128
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [uart3_div](index.html) module
        pub struct UART3_DIV_SPEC;
        impl crate::RegisterSpec for UART3_DIV_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [uart3_div::R](R) reader structure
        impl crate::Readable for UART3_DIV_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [uart3_div::W](W) writer structure
        impl crate::Writable for UART3_DIV_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets UART3_DIV to value 0
        impl crate::Resettable for UART3_DIV_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
}
///SPI0 register
pub struct SPI0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for SPI0 {}
impl SPI0 {
    ///Pointer to the register block
    pub const PTR: *const spi0::RegisterBlock = 0x4000_4000 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const spi0::RegisterBlock {
        Self::PTR
    }
}
impl Deref for SPI0 {
    type Target = spi0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for SPI0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("SPI0").finish()
    }
}
///SPI0 register
pub mod spi0 {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        ///0x00 - RW, SPI0 mode control
        pub spi0_ctrl_mod: SPI0_CTRL_MOD,
        ///0x01 - RW, SPI0 configuration control
        pub spi0_ctrl_cfg: SPI0_CTRL_CFG,
        ///0x02 - RW, SPI0 interrupt enable
        pub spi0_inter_en: SPI0_INTER_EN,
        ///0x03 - RW, SPI0 master clock divisor;RW, SPI0 slave preset value
        pub spi0_clock_div__r8_spi0_slave_pre: SPI0_CLOCK_DIV__R8_SPI0_SLAVE_PRE,
        ///0x04 - RW, SPI0 data buffer
        pub spi0_buffer: SPI0_BUFFER,
        ///0x05 - RO, SPI0 work flag
        pub spi0_run_flag: SPI0_RUN_FLAG,
        ///0x06 - RW1, SPI0 interrupt flag
        pub spi0_int_flag: SPI0_INT_FLAG,
        ///0x07 - RO, SPI0 FIFO count status
        pub spi0_fifo_count: SPI0_FIFO_COUNT,
        _reserved8: [u8; 0x04],
        ///0x0c - RW, SPI0 total byte count, only low 12 bit
        pub spi0_total_cnt: SPI0_TOTAL_CNT,
        _reserved9: [u8; 0x02],
        ///0x10 - RO/WO, SPI0 FIFO register
        pub spi0_fifo: SPI0_FIFO,
        _reserved10: [u8; 0x02],
        ///0x13 - RO, SPI0 FIFO count status
        pub spi0_fifo_count1: SPI0_FIFO_COUNT1,
        ///0x14 - RW, SPI0 DMA current address
        pub spi0_dma_now: SPI0_DMA_NOW,
        _reserved12: [u8; 0x02],
        ///0x18 - RW, SPI0 DMA begin address
        pub spi0_dma_beg: SPI0_DMA_BEG,
        _reserved13: [u8; 0x02],
        ///0x1c - RW, SPI0 DMA end address
        pub spi0_dma_end: SPI0_DMA_END,
    }
    ///SPI0_CTRL_MOD (rw) register accessor: an alias for `Reg<SPI0_CTRL_MOD_SPEC>`
    pub type SPI0_CTRL_MOD = crate::Reg<spi0_ctrl_mod::SPI0_CTRL_MOD_SPEC>;
    ///RW, SPI0 mode control
    pub mod spi0_ctrl_mod {
        ///Register `SPI0_CTRL_MOD` reader
        pub struct R(crate::R<SPI0_CTRL_MOD_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<SPI0_CTRL_MOD_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<SPI0_CTRL_MOD_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<SPI0_CTRL_MOD_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `SPI0_CTRL_MOD` writer
        pub struct W(crate::W<SPI0_CTRL_MOD_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<SPI0_CTRL_MOD_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<SPI0_CTRL_MOD_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<SPI0_CTRL_MOD_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `SPI_MODE_SLAVE` reader - RW, SPI0 slave mode: 0=master or host, 1=slave or device
        pub type SPI_MODE_SLAVE_R = crate::BitReader<bool>;
        ///Field `SPI_MODE_SLAVE` writer - RW, SPI0 slave mode: 0=master or host, 1=slave or device
        pub type SPI_MODE_SLAVE_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, SPI0_CTRL_MOD_SPEC, bool, O>;
        ///Field `SPI_ALL_CLEAR` reader - RW, force clear SPI FIFO and count
        pub type SPI_ALL_CLEAR_R = crate::BitReader<bool>;
        ///Field `SPI_ALL_CLEAR` writer - RW, force clear SPI FIFO and count
        pub type SPI_ALL_CLEAR_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, SPI0_CTRL_MOD_SPEC, bool, O>;
        ///Field `SPI_2WIRE_MOD` reader - RW, SPI0 enable 2 wire mode for slave: 0=3wire(SCK0,MOSI,MISO), 1=2wire(SCK0,MISO=MXSX)
        pub type SPI_2WIRE_MOD_R = crate::BitReader<bool>;
        ///Field `SPI_2WIRE_MOD` writer - RW, SPI0 enable 2 wire mode for slave: 0=3wire(SCK0,MOSI,MISO), 1=2wire(SCK0,MISO=MXSX)
        pub type SPI_2WIRE_MOD_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, SPI0_CTRL_MOD_SPEC, bool, O>;
        ///Field `SPI_MST_SCK_MOD__RB_SPI_SLV_CMD_MOD` reader - RW, SPI master clock mode: 0=mode 0, 1=mode 3;RW, SPI0 slave command mode: 0=byte stream, 1=first byte command
        pub type SPI_MST_SCK_MOD__RB_SPI_SLV_CMD_MOD_R = crate::BitReader<bool>;
        ///Field `SPI_MST_SCK_MOD__RB_SPI_SLV_CMD_MOD` writer - RW, SPI master clock mode: 0=mode 0, 1=mode 3;RW, SPI0 slave command mode: 0=byte stream, 1=first byte command
        pub type SPI_MST_SCK_MOD__RB_SPI_SLV_CMD_MOD_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, SPI0_CTRL_MOD_SPEC, bool, O>;
        ///Field `SPI_FIFO_DIR` reader - RW, SPI FIFO direction: 0=out(write @master mode), 1=in(read @master mode)
        pub type SPI_FIFO_DIR_R = crate::BitReader<bool>;
        ///Field `SPI_FIFO_DIR` writer - RW, SPI FIFO direction: 0=out(write @master mode), 1=in(read @master mode)
        pub type SPI_FIFO_DIR_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, SPI0_CTRL_MOD_SPEC, bool, O>;
        ///Field `SPI_SCK_OE` reader - RW, SPI SCK output enable
        pub type SPI_SCK_OE_R = crate::BitReader<bool>;
        ///Field `SPI_SCK_OE` writer - RW, SPI SCK output enable
        pub type SPI_SCK_OE_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, SPI0_CTRL_MOD_SPEC, bool, O>;
        ///Field `SPI_MOSI_OE` reader - RW, SPI MOSI output enable
        pub type SPI_MOSI_OE_R = crate::BitReader<bool>;
        ///Field `SPI_MOSI_OE` writer - RW, SPI MOSI output enable
        pub type SPI_MOSI_OE_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, SPI0_CTRL_MOD_SPEC, bool, O>;
        ///Field `SPI_MISO_OE` reader - RW, SPI MISO output enable
        pub type SPI_MISO_OE_R = crate::BitReader<bool>;
        ///Field `SPI_MISO_OE` writer - RW, SPI MISO output enable
        pub type SPI_MISO_OE_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, SPI0_CTRL_MOD_SPEC, bool, O>;
        impl R {
            ///Bit 0 - RW, SPI0 slave mode: 0=master or host, 1=slave or device
            #[inline(always)]
            pub fn spi_mode_slave(&self) -> SPI_MODE_SLAVE_R {
                SPI_MODE_SLAVE_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RW, force clear SPI FIFO and count
            #[inline(always)]
            pub fn spi_all_clear(&self) -> SPI_ALL_CLEAR_R {
                SPI_ALL_CLEAR_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RW, SPI0 enable 2 wire mode for slave: 0=3wire(SCK0,MOSI,MISO), 1=2wire(SCK0,MISO=MXSX)
            #[inline(always)]
            pub fn spi_2wire_mod(&self) -> SPI_2WIRE_MOD_R {
                SPI_2WIRE_MOD_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RW, SPI master clock mode: 0=mode 0, 1=mode 3;RW, SPI0 slave command mode: 0=byte stream, 1=first byte command
            #[inline(always)]
            pub fn spi_mst_sck_mod__rb_spi_slv_cmd_mod(
                &self,
            ) -> SPI_MST_SCK_MOD__RB_SPI_SLV_CMD_MOD_R {
                SPI_MST_SCK_MOD__RB_SPI_SLV_CMD_MOD_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RW, SPI FIFO direction: 0=out(write @master mode), 1=in(read @master mode)
            #[inline(always)]
            pub fn spi_fifo_dir(&self) -> SPI_FIFO_DIR_R {
                SPI_FIFO_DIR_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - RW, SPI SCK output enable
            #[inline(always)]
            pub fn spi_sck_oe(&self) -> SPI_SCK_OE_R {
                SPI_SCK_OE_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - RW, SPI MOSI output enable
            #[inline(always)]
            pub fn spi_mosi_oe(&self) -> SPI_MOSI_OE_R {
                SPI_MOSI_OE_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - RW, SPI MISO output enable
            #[inline(always)]
            pub fn spi_miso_oe(&self) -> SPI_MISO_OE_R {
                SPI_MISO_OE_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RW, SPI0 slave mode: 0=master or host, 1=slave or device
            #[inline(always)]
            #[must_use]
            pub fn spi_mode_slave(&mut self) -> SPI_MODE_SLAVE_W<0> {
                SPI_MODE_SLAVE_W::new(self)
            }
            ///Bit 1 - RW, force clear SPI FIFO and count
            #[inline(always)]
            #[must_use]
            pub fn spi_all_clear(&mut self) -> SPI_ALL_CLEAR_W<1> {
                SPI_ALL_CLEAR_W::new(self)
            }
            ///Bit 2 - RW, SPI0 enable 2 wire mode for slave: 0=3wire(SCK0,MOSI,MISO), 1=2wire(SCK0,MISO=MXSX)
            #[inline(always)]
            #[must_use]
            pub fn spi_2wire_mod(&mut self) -> SPI_2WIRE_MOD_W<2> {
                SPI_2WIRE_MOD_W::new(self)
            }
            ///Bit 3 - RW, SPI master clock mode: 0=mode 0, 1=mode 3;RW, SPI0 slave command mode: 0=byte stream, 1=first byte command
            #[inline(always)]
            #[must_use]
            pub fn spi_mst_sck_mod__rb_spi_slv_cmd_mod(
                &mut self,
            ) -> SPI_MST_SCK_MOD__RB_SPI_SLV_CMD_MOD_W<3> {
                SPI_MST_SCK_MOD__RB_SPI_SLV_CMD_MOD_W::new(self)
            }
            ///Bit 4 - RW, SPI FIFO direction: 0=out(write @master mode), 1=in(read @master mode)
            #[inline(always)]
            #[must_use]
            pub fn spi_fifo_dir(&mut self) -> SPI_FIFO_DIR_W<4> {
                SPI_FIFO_DIR_W::new(self)
            }
            ///Bit 5 - RW, SPI SCK output enable
            #[inline(always)]
            #[must_use]
            pub fn spi_sck_oe(&mut self) -> SPI_SCK_OE_W<5> {
                SPI_SCK_OE_W::new(self)
            }
            ///Bit 6 - RW, SPI MOSI output enable
            #[inline(always)]
            #[must_use]
            pub fn spi_mosi_oe(&mut self) -> SPI_MOSI_OE_W<6> {
                SPI_MOSI_OE_W::new(self)
            }
            ///Bit 7 - RW, SPI MISO output enable
            #[inline(always)]
            #[must_use]
            pub fn spi_miso_oe(&mut self) -> SPI_MISO_OE_W<7> {
                SPI_MISO_OE_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, SPI0 mode control
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [spi0_ctrl_mod](index.html) module
        pub struct SPI0_CTRL_MOD_SPEC;
        impl crate::RegisterSpec for SPI0_CTRL_MOD_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [spi0_ctrl_mod::R](R) reader structure
        impl crate::Readable for SPI0_CTRL_MOD_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [spi0_ctrl_mod::W](W) writer structure
        impl crate::Writable for SPI0_CTRL_MOD_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets SPI0_CTRL_MOD to value 0x02
        impl crate::Resettable for SPI0_CTRL_MOD_SPEC {
            const RESET_VALUE: Self::Ux = 0x02;
        }
    }
    ///SPI0_CTRL_CFG (rw) register accessor: an alias for `Reg<SPI0_CTRL_CFG_SPEC>`
    pub type SPI0_CTRL_CFG = crate::Reg<spi0_ctrl_cfg::SPI0_CTRL_CFG_SPEC>;
    ///RW, SPI0 configuration control
    pub mod spi0_ctrl_cfg {
        ///Register `SPI0_CTRL_CFG` reader
        pub struct R(crate::R<SPI0_CTRL_CFG_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<SPI0_CTRL_CFG_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<SPI0_CTRL_CFG_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<SPI0_CTRL_CFG_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `SPI0_CTRL_CFG` writer
        pub struct W(crate::W<SPI0_CTRL_CFG_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<SPI0_CTRL_CFG_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<SPI0_CTRL_CFG_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<SPI0_CTRL_CFG_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `SPI_DMA_ENABLE` reader - RW, SPI0 DMA enable
        pub type SPI_DMA_ENABLE_R = crate::BitReader<bool>;
        ///Field `SPI_DMA_ENABLE` writer - RW, SPI0 DMA enable
        pub type SPI_DMA_ENABLE_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, SPI0_CTRL_CFG_SPEC, bool, O>;
        ///Field `SPI_DMA_LOOP` reader - RW, SPI0 DMA address loop enable
        pub type SPI_DMA_LOOP_R = crate::BitReader<bool>;
        ///Field `SPI_DMA_LOOP` writer - RW, SPI0 DMA address loop enable
        pub type SPI_DMA_LOOP_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, SPI0_CTRL_CFG_SPEC, bool, O>;
        ///Field `SPI_AUTO_IF` reader - RW, enable buffer/FIFO accessing to auto clear RB_SPI_IF_BYTE_END interrupt flag
        pub type SPI_AUTO_IF_R = crate::BitReader<bool>;
        ///Field `SPI_AUTO_IF` writer - RW, enable buffer/FIFO accessing to auto clear RB_SPI_IF_BYTE_END interrupt flag
        pub type SPI_AUTO_IF_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, SPI0_CTRL_CFG_SPEC, bool, O>;
        ///Field `SPI_BIT_ORDER` reader - RW, SPI bit data order: 0=MSB first, 1=LSB first
        pub type SPI_BIT_ORDER_R = crate::BitReader<bool>;
        ///Field `SPI_BIT_ORDER` writer - RW, SPI bit data order: 0=MSB first, 1=LSB first
        pub type SPI_BIT_ORDER_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, SPI0_CTRL_CFG_SPEC, bool, O>;
        ///Field `SPI_MST_DLY_EN` reader - RW, SPI master input delay enable
        pub type SPI_MST_DLY_EN_R = crate::BitReader<bool>;
        ///Field `SPI_MST_DLY_EN` writer - RW, SPI master input delay enable
        pub type SPI_MST_DLY_EN_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, SPI0_CTRL_CFG_SPEC, bool, O>;
        impl R {
            ///Bit 0 - RW, SPI0 DMA enable
            #[inline(always)]
            pub fn spi_dma_enable(&self) -> SPI_DMA_ENABLE_R {
                SPI_DMA_ENABLE_R::new((self.bits & 1) != 0)
            }
            ///Bit 2 - RW, SPI0 DMA address loop enable
            #[inline(always)]
            pub fn spi_dma_loop(&self) -> SPI_DMA_LOOP_R {
                SPI_DMA_LOOP_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 4 - RW, enable buffer/FIFO accessing to auto clear RB_SPI_IF_BYTE_END interrupt flag
            #[inline(always)]
            pub fn spi_auto_if(&self) -> SPI_AUTO_IF_R {
                SPI_AUTO_IF_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - RW, SPI bit data order: 0=MSB first, 1=LSB first
            #[inline(always)]
            pub fn spi_bit_order(&self) -> SPI_BIT_ORDER_R {
                SPI_BIT_ORDER_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - RW, SPI master input delay enable
            #[inline(always)]
            pub fn spi_mst_dly_en(&self) -> SPI_MST_DLY_EN_R {
                SPI_MST_DLY_EN_R::new(((self.bits >> 6) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RW, SPI0 DMA enable
            #[inline(always)]
            #[must_use]
            pub fn spi_dma_enable(&mut self) -> SPI_DMA_ENABLE_W<0> {
                SPI_DMA_ENABLE_W::new(self)
            }
            ///Bit 2 - RW, SPI0 DMA address loop enable
            #[inline(always)]
            #[must_use]
            pub fn spi_dma_loop(&mut self) -> SPI_DMA_LOOP_W<2> {
                SPI_DMA_LOOP_W::new(self)
            }
            ///Bit 4 - RW, enable buffer/FIFO accessing to auto clear RB_SPI_IF_BYTE_END interrupt flag
            #[inline(always)]
            #[must_use]
            pub fn spi_auto_if(&mut self) -> SPI_AUTO_IF_W<4> {
                SPI_AUTO_IF_W::new(self)
            }
            ///Bit 5 - RW, SPI bit data order: 0=MSB first, 1=LSB first
            #[inline(always)]
            #[must_use]
            pub fn spi_bit_order(&mut self) -> SPI_BIT_ORDER_W<5> {
                SPI_BIT_ORDER_W::new(self)
            }
            ///Bit 6 - RW, SPI master input delay enable
            #[inline(always)]
            #[must_use]
            pub fn spi_mst_dly_en(&mut self) -> SPI_MST_DLY_EN_W<6> {
                SPI_MST_DLY_EN_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, SPI0 configuration control
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [spi0_ctrl_cfg](index.html) module
        pub struct SPI0_CTRL_CFG_SPEC;
        impl crate::RegisterSpec for SPI0_CTRL_CFG_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [spi0_ctrl_cfg::R](R) reader structure
        impl crate::Readable for SPI0_CTRL_CFG_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [spi0_ctrl_cfg::W](W) writer structure
        impl crate::Writable for SPI0_CTRL_CFG_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets SPI0_CTRL_CFG to value 0
        impl crate::Resettable for SPI0_CTRL_CFG_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///SPI0_INTER_EN (rw) register accessor: an alias for `Reg<SPI0_INTER_EN_SPEC>`
    pub type SPI0_INTER_EN = crate::Reg<spi0_inter_en::SPI0_INTER_EN_SPEC>;
    ///RW, SPI0 interrupt enable
    pub mod spi0_inter_en {
        ///Register `SPI0_INTER_EN` reader
        pub struct R(crate::R<SPI0_INTER_EN_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<SPI0_INTER_EN_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<SPI0_INTER_EN_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<SPI0_INTER_EN_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `SPI0_INTER_EN` writer
        pub struct W(crate::W<SPI0_INTER_EN_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<SPI0_INTER_EN_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<SPI0_INTER_EN_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<SPI0_INTER_EN_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `SPI_IE_CNT_END` reader - RW, enable interrupt for SPI total byte count end
        pub type SPI_IE_CNT_END_R = crate::BitReader<bool>;
        ///Field `SPI_IE_CNT_END` writer - RW, enable interrupt for SPI total byte count end
        pub type SPI_IE_CNT_END_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, SPI0_INTER_EN_SPEC, bool, O>;
        ///Field `SPI_IE_BYTE_END` reader - RW, enable interrupt for SPI byte exchanged
        pub type SPI_IE_BYTE_END_R = crate::BitReader<bool>;
        ///Field `SPI_IE_BYTE_END` writer - RW, enable interrupt for SPI byte exchanged
        pub type SPI_IE_BYTE_END_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, SPI0_INTER_EN_SPEC, bool, O>;
        ///Field `SPI_IE_FIFO_HF` reader - RW, enable interrupt for SPI FIFO half
        pub type SPI_IE_FIFO_HF_R = crate::BitReader<bool>;
        ///Field `SPI_IE_FIFO_HF` writer - RW, enable interrupt for SPI FIFO half
        pub type SPI_IE_FIFO_HF_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, SPI0_INTER_EN_SPEC, bool, O>;
        ///Field `SPI_IE_DMA_END` reader - RW, enable interrupt for SPI0 DMA completion
        pub type SPI_IE_DMA_END_R = crate::BitReader<bool>;
        ///Field `SPI_IE_DMA_END` writer - RW, enable interrupt for SPI0 DMA completion
        pub type SPI_IE_DMA_END_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, SPI0_INTER_EN_SPEC, bool, O>;
        ///Field `SPI_IE_FIFO_OV` reader - RW, enable interrupt for SPI0 FIFO overflow
        pub type SPI_IE_FIFO_OV_R = crate::BitReader<bool>;
        ///Field `SPI_IE_FIFO_OV` writer - RW, enable interrupt for SPI0 FIFO overflow
        pub type SPI_IE_FIFO_OV_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, SPI0_INTER_EN_SPEC, bool, O>;
        ///Field `SPI_IE_FST_BYTE` reader - RW, enable interrupt for SPI0 slave mode first byte received
        pub type SPI_IE_FST_BYTE_R = crate::BitReader<bool>;
        ///Field `SPI_IE_FST_BYTE` writer - RW, enable interrupt for SPI0 slave mode first byte received
        pub type SPI_IE_FST_BYTE_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, SPI0_INTER_EN_SPEC, bool, O>;
        impl R {
            ///Bit 0 - RW, enable interrupt for SPI total byte count end
            #[inline(always)]
            pub fn spi_ie_cnt_end(&self) -> SPI_IE_CNT_END_R {
                SPI_IE_CNT_END_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RW, enable interrupt for SPI byte exchanged
            #[inline(always)]
            pub fn spi_ie_byte_end(&self) -> SPI_IE_BYTE_END_R {
                SPI_IE_BYTE_END_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RW, enable interrupt for SPI FIFO half
            #[inline(always)]
            pub fn spi_ie_fifo_hf(&self) -> SPI_IE_FIFO_HF_R {
                SPI_IE_FIFO_HF_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RW, enable interrupt for SPI0 DMA completion
            #[inline(always)]
            pub fn spi_ie_dma_end(&self) -> SPI_IE_DMA_END_R {
                SPI_IE_DMA_END_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RW, enable interrupt for SPI0 FIFO overflow
            #[inline(always)]
            pub fn spi_ie_fifo_ov(&self) -> SPI_IE_FIFO_OV_R {
                SPI_IE_FIFO_OV_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 7 - RW, enable interrupt for SPI0 slave mode first byte received
            #[inline(always)]
            pub fn spi_ie_fst_byte(&self) -> SPI_IE_FST_BYTE_R {
                SPI_IE_FST_BYTE_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RW, enable interrupt for SPI total byte count end
            #[inline(always)]
            #[must_use]
            pub fn spi_ie_cnt_end(&mut self) -> SPI_IE_CNT_END_W<0> {
                SPI_IE_CNT_END_W::new(self)
            }
            ///Bit 1 - RW, enable interrupt for SPI byte exchanged
            #[inline(always)]
            #[must_use]
            pub fn spi_ie_byte_end(&mut self) -> SPI_IE_BYTE_END_W<1> {
                SPI_IE_BYTE_END_W::new(self)
            }
            ///Bit 2 - RW, enable interrupt for SPI FIFO half
            #[inline(always)]
            #[must_use]
            pub fn spi_ie_fifo_hf(&mut self) -> SPI_IE_FIFO_HF_W<2> {
                SPI_IE_FIFO_HF_W::new(self)
            }
            ///Bit 3 - RW, enable interrupt for SPI0 DMA completion
            #[inline(always)]
            #[must_use]
            pub fn spi_ie_dma_end(&mut self) -> SPI_IE_DMA_END_W<3> {
                SPI_IE_DMA_END_W::new(self)
            }
            ///Bit 4 - RW, enable interrupt for SPI0 FIFO overflow
            #[inline(always)]
            #[must_use]
            pub fn spi_ie_fifo_ov(&mut self) -> SPI_IE_FIFO_OV_W<4> {
                SPI_IE_FIFO_OV_W::new(self)
            }
            ///Bit 7 - RW, enable interrupt for SPI0 slave mode first byte received
            #[inline(always)]
            #[must_use]
            pub fn spi_ie_fst_byte(&mut self) -> SPI_IE_FST_BYTE_W<7> {
                SPI_IE_FST_BYTE_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, SPI0 interrupt enable
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [spi0_inter_en](index.html) module
        pub struct SPI0_INTER_EN_SPEC;
        impl crate::RegisterSpec for SPI0_INTER_EN_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [spi0_inter_en::R](R) reader structure
        impl crate::Readable for SPI0_INTER_EN_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [spi0_inter_en::W](W) writer structure
        impl crate::Writable for SPI0_INTER_EN_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets SPI0_INTER_EN to value 0
        impl crate::Resettable for SPI0_INTER_EN_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///SPI0_CLOCK_DIV__R8_SPI0_SLAVE_PRE (rw) register accessor: an alias for `Reg<SPI0_CLOCK_DIV__R8_SPI0_SLAVE_PRE_SPEC>`
    pub type SPI0_CLOCK_DIV__R8_SPI0_SLAVE_PRE =
        crate::Reg<spi0_clock_div__r8_spi0_slave_pre::SPI0_CLOCK_DIV__R8_SPI0_SLAVE_PRE_SPEC>;
    ///RW, SPI0 master clock divisor;RW, SPI0 slave preset value
    pub mod spi0_clock_div__r8_spi0_slave_pre {
        ///Register `SPI0_CLOCK_DIV__R8_SPI0_SLAVE_PRE` reader
        pub struct R(crate::R<SPI0_CLOCK_DIV__R8_SPI0_SLAVE_PRE_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<SPI0_CLOCK_DIV__R8_SPI0_SLAVE_PRE_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<SPI0_CLOCK_DIV__R8_SPI0_SLAVE_PRE_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<SPI0_CLOCK_DIV__R8_SPI0_SLAVE_PRE_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `SPI0_CLOCK_DIV__R8_SPI0_SLAVE_PRE` writer
        pub struct W(crate::W<SPI0_CLOCK_DIV__R8_SPI0_SLAVE_PRE_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<SPI0_CLOCK_DIV__R8_SPI0_SLAVE_PRE_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<SPI0_CLOCK_DIV__R8_SPI0_SLAVE_PRE_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<SPI0_CLOCK_DIV__R8_SPI0_SLAVE_PRE_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `SPI0_CLOCK_DIV__R8_SPI0_SLAVE_PRE` reader - RW, SPI0 master clock divisor;RW, SPI0 slave preset value
        pub type SPI0_CLOCK_DIV__R8_SPI0_SLAVE_PRE_R = crate::FieldReader<u8, u8>;
        ///Field `SPI0_CLOCK_DIV__R8_SPI0_SLAVE_PRE` writer - RW, SPI0 master clock divisor;RW, SPI0 slave preset value
        pub type SPI0_CLOCK_DIV__R8_SPI0_SLAVE_PRE_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, SPI0_CLOCK_DIV__R8_SPI0_SLAVE_PRE_SPEC, u8, u8, 8, O>;
        impl R {
            ///Bits 0:7 - RW, SPI0 master clock divisor;RW, SPI0 slave preset value
            #[inline(always)]
            pub fn spi0_clock_div__r8_spi0_slave_pre(&self) -> SPI0_CLOCK_DIV__R8_SPI0_SLAVE_PRE_R {
                SPI0_CLOCK_DIV__R8_SPI0_SLAVE_PRE_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:7 - RW, SPI0 master clock divisor;RW, SPI0 slave preset value
            #[inline(always)]
            #[must_use]
            pub fn spi0_clock_div__r8_spi0_slave_pre(
                &mut self,
            ) -> SPI0_CLOCK_DIV__R8_SPI0_SLAVE_PRE_W<0> {
                SPI0_CLOCK_DIV__R8_SPI0_SLAVE_PRE_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, SPI0 master clock divisor;RW, SPI0 slave preset value
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [spi0_clock_div__r8_spi0_slave_pre](index.html) module
        pub struct SPI0_CLOCK_DIV__R8_SPI0_SLAVE_PRE_SPEC;
        impl crate::RegisterSpec for SPI0_CLOCK_DIV__R8_SPI0_SLAVE_PRE_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [spi0_clock_div__r8_spi0_slave_pre::R](R) reader structure
        impl crate::Readable for SPI0_CLOCK_DIV__R8_SPI0_SLAVE_PRE_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [spi0_clock_div__r8_spi0_slave_pre::W](W) writer structure
        impl crate::Writable for SPI0_CLOCK_DIV__R8_SPI0_SLAVE_PRE_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets SPI0_CLOCK_DIV__R8_SPI0_SLAVE_PRE to value 0x10
        impl crate::Resettable for SPI0_CLOCK_DIV__R8_SPI0_SLAVE_PRE_SPEC {
            const RESET_VALUE: Self::Ux = 0x10;
        }
    }
    ///SPI0_BUFFER (rw) register accessor: an alias for `Reg<SPI0_BUFFER_SPEC>`
    pub type SPI0_BUFFER = crate::Reg<spi0_buffer::SPI0_BUFFER_SPEC>;
    ///RW, SPI0 data buffer
    pub mod spi0_buffer {
        ///Register `SPI0_BUFFER` reader
        pub struct R(crate::R<SPI0_BUFFER_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<SPI0_BUFFER_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<SPI0_BUFFER_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<SPI0_BUFFER_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `SPI0_BUFFER` writer
        pub struct W(crate::W<SPI0_BUFFER_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<SPI0_BUFFER_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<SPI0_BUFFER_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<SPI0_BUFFER_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `SPI0_BUFFER` reader - RW, SPI0 data buffer
        pub type SPI0_BUFFER_R = crate::FieldReader<u8, u8>;
        ///Field `SPI0_BUFFER` writer - RW, SPI0 data buffer
        pub type SPI0_BUFFER_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, SPI0_BUFFER_SPEC, u8, u8, 8, O>;
        impl R {
            ///Bits 0:7 - RW, SPI0 data buffer
            #[inline(always)]
            pub fn spi0_buffer(&self) -> SPI0_BUFFER_R {
                SPI0_BUFFER_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:7 - RW, SPI0 data buffer
            #[inline(always)]
            #[must_use]
            pub fn spi0_buffer(&mut self) -> SPI0_BUFFER_W<0> {
                SPI0_BUFFER_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, SPI0 data buffer
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [spi0_buffer](index.html) module
        pub struct SPI0_BUFFER_SPEC;
        impl crate::RegisterSpec for SPI0_BUFFER_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [spi0_buffer::R](R) reader structure
        impl crate::Readable for SPI0_BUFFER_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [spi0_buffer::W](W) writer structure
        impl crate::Writable for SPI0_BUFFER_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets SPI0_BUFFER to value 0
        impl crate::Resettable for SPI0_BUFFER_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///SPI0_RUN_FLAG (r) register accessor: an alias for `Reg<SPI0_RUN_FLAG_SPEC>`
    pub type SPI0_RUN_FLAG = crate::Reg<spi0_run_flag::SPI0_RUN_FLAG_SPEC>;
    ///RO, SPI0 work flag
    pub mod spi0_run_flag {
        ///Register `SPI0_RUN_FLAG` reader
        pub struct R(crate::R<SPI0_RUN_FLAG_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<SPI0_RUN_FLAG_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<SPI0_RUN_FLAG_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<SPI0_RUN_FLAG_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `SPI_SLV_CMD_ACT` reader - RO, SPI0 slave first byte or command flag
        pub type SPI_SLV_CMD_ACT_R = crate::BitReader<bool>;
        ///Field `SPI_FIFO_READY` reader - RO, SPI FIFO ready status
        pub type SPI_FIFO_READY_R = crate::BitReader<bool>;
        ///Field `SPI_SLV_CS_LOAD` reader - RO, SPI0 slave chip-select loading status
        pub type SPI_SLV_CS_LOAD_R = crate::BitReader<bool>;
        ///Field `SPI_SLV_SELECT` reader - RO, SPI0 slave selection status
        pub type SPI_SLV_SELECT_R = crate::BitReader<bool>;
        impl R {
            ///Bit 4 - RO, SPI0 slave first byte or command flag
            #[inline(always)]
            pub fn spi_slv_cmd_act(&self) -> SPI_SLV_CMD_ACT_R {
                SPI_SLV_CMD_ACT_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - RO, SPI FIFO ready status
            #[inline(always)]
            pub fn spi_fifo_ready(&self) -> SPI_FIFO_READY_R {
                SPI_FIFO_READY_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - RO, SPI0 slave chip-select loading status
            #[inline(always)]
            pub fn spi_slv_cs_load(&self) -> SPI_SLV_CS_LOAD_R {
                SPI_SLV_CS_LOAD_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - RO, SPI0 slave selection status
            #[inline(always)]
            pub fn spi_slv_select(&self) -> SPI_SLV_SELECT_R {
                SPI_SLV_SELECT_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        ///RO, SPI0 work flag
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [spi0_run_flag](index.html) module
        pub struct SPI0_RUN_FLAG_SPEC;
        impl crate::RegisterSpec for SPI0_RUN_FLAG_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [spi0_run_flag::R](R) reader structure
        impl crate::Readable for SPI0_RUN_FLAG_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets SPI0_RUN_FLAG to value 0
        impl crate::Resettable for SPI0_RUN_FLAG_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///SPI0_INT_FLAG (rw) register accessor: an alias for `Reg<SPI0_INT_FLAG_SPEC>`
    pub type SPI0_INT_FLAG = crate::Reg<spi0_int_flag::SPI0_INT_FLAG_SPEC>;
    ///RW1, SPI0 interrupt flag
    pub mod spi0_int_flag {
        ///Register `SPI0_INT_FLAG` reader
        pub struct R(crate::R<SPI0_INT_FLAG_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<SPI0_INT_FLAG_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<SPI0_INT_FLAG_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<SPI0_INT_FLAG_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `SPI0_INT_FLAG` writer
        pub struct W(crate::W<SPI0_INT_FLAG_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<SPI0_INT_FLAG_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<SPI0_INT_FLAG_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<SPI0_INT_FLAG_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `SPI_IF_CNT_END` reader - RW1, interrupt flag for SPI total byte count end
        pub type SPI_IF_CNT_END_R = crate::BitReader<bool>;
        ///Field `SPI_IF_CNT_END` writer - RW1, interrupt flag for SPI total byte count end
        pub type SPI_IF_CNT_END_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, SPI0_INT_FLAG_SPEC, bool, O>;
        ///Field `SPI_IF_BYTE_END` reader - RW1, interrupt flag for SPI byte exchanged
        pub type SPI_IF_BYTE_END_R = crate::BitReader<bool>;
        ///Field `SPI_IF_BYTE_END` writer - RW1, interrupt flag for SPI byte exchanged
        pub type SPI_IF_BYTE_END_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, SPI0_INT_FLAG_SPEC, bool, O>;
        ///Field `SPI_IF_FIFO_HF` reader - RW1, interrupt flag for SPI FIFO half
        pub type SPI_IF_FIFO_HF_R = crate::BitReader<bool>;
        ///Field `SPI_IF_FIFO_HF` writer - RW1, interrupt flag for SPI FIFO half
        pub type SPI_IF_FIFO_HF_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, SPI0_INT_FLAG_SPEC, bool, O>;
        ///Field `SPI_IF_DMA_END` reader - RW1, interrupt flag for SPI0 DMA completion
        pub type SPI_IF_DMA_END_R = crate::BitReader<bool>;
        ///Field `SPI_IF_DMA_END` writer - RW1, interrupt flag for SPI0 DMA completion
        pub type SPI_IF_DMA_END_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, SPI0_INT_FLAG_SPEC, bool, O>;
        ///Field `SPI_IF_FIFO_OV` reader - RW1, interrupt flag for SPI0 FIFO overflow
        pub type SPI_IF_FIFO_OV_R = crate::BitReader<bool>;
        ///Field `SPI_IF_FIFO_OV` writer - RW1, interrupt flag for SPI0 FIFO overflow
        pub type SPI_IF_FIFO_OV_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, SPI0_INT_FLAG_SPEC, bool, O>;
        ///Field `SPI_FREE` reader - RO, current SPI free status
        pub type SPI_FREE_R = crate::BitReader<bool>;
        ///Field `SPI_FREE` writer - RO, current SPI free status
        pub type SPI_FREE_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, SPI0_INT_FLAG_SPEC, bool, O>;
        ///Field `SPI_IF_FST_BYTE` reader - RW1, interrupt flag for SPI0 slave mode first byte received
        pub type SPI_IF_FST_BYTE_R = crate::BitReader<bool>;
        ///Field `SPI_IF_FST_BYTE` writer - RW1, interrupt flag for SPI0 slave mode first byte received
        pub type SPI_IF_FST_BYTE_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, SPI0_INT_FLAG_SPEC, bool, O>;
        impl R {
            ///Bit 0 - RW1, interrupt flag for SPI total byte count end
            #[inline(always)]
            pub fn spi_if_cnt_end(&self) -> SPI_IF_CNT_END_R {
                SPI_IF_CNT_END_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RW1, interrupt flag for SPI byte exchanged
            #[inline(always)]
            pub fn spi_if_byte_end(&self) -> SPI_IF_BYTE_END_R {
                SPI_IF_BYTE_END_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RW1, interrupt flag for SPI FIFO half
            #[inline(always)]
            pub fn spi_if_fifo_hf(&self) -> SPI_IF_FIFO_HF_R {
                SPI_IF_FIFO_HF_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RW1, interrupt flag for SPI0 DMA completion
            #[inline(always)]
            pub fn spi_if_dma_end(&self) -> SPI_IF_DMA_END_R {
                SPI_IF_DMA_END_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RW1, interrupt flag for SPI0 FIFO overflow
            #[inline(always)]
            pub fn spi_if_fifo_ov(&self) -> SPI_IF_FIFO_OV_R {
                SPI_IF_FIFO_OV_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 6 - RO, current SPI free status
            #[inline(always)]
            pub fn spi_free(&self) -> SPI_FREE_R {
                SPI_FREE_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - RW1, interrupt flag for SPI0 slave mode first byte received
            #[inline(always)]
            pub fn spi_if_fst_byte(&self) -> SPI_IF_FST_BYTE_R {
                SPI_IF_FST_BYTE_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RW1, interrupt flag for SPI total byte count end
            #[inline(always)]
            #[must_use]
            pub fn spi_if_cnt_end(&mut self) -> SPI_IF_CNT_END_W<0> {
                SPI_IF_CNT_END_W::new(self)
            }
            ///Bit 1 - RW1, interrupt flag for SPI byte exchanged
            #[inline(always)]
            #[must_use]
            pub fn spi_if_byte_end(&mut self) -> SPI_IF_BYTE_END_W<1> {
                SPI_IF_BYTE_END_W::new(self)
            }
            ///Bit 2 - RW1, interrupt flag for SPI FIFO half
            #[inline(always)]
            #[must_use]
            pub fn spi_if_fifo_hf(&mut self) -> SPI_IF_FIFO_HF_W<2> {
                SPI_IF_FIFO_HF_W::new(self)
            }
            ///Bit 3 - RW1, interrupt flag for SPI0 DMA completion
            #[inline(always)]
            #[must_use]
            pub fn spi_if_dma_end(&mut self) -> SPI_IF_DMA_END_W<3> {
                SPI_IF_DMA_END_W::new(self)
            }
            ///Bit 4 - RW1, interrupt flag for SPI0 FIFO overflow
            #[inline(always)]
            #[must_use]
            pub fn spi_if_fifo_ov(&mut self) -> SPI_IF_FIFO_OV_W<4> {
                SPI_IF_FIFO_OV_W::new(self)
            }
            ///Bit 6 - RO, current SPI free status
            #[inline(always)]
            #[must_use]
            pub fn spi_free(&mut self) -> SPI_FREE_W<6> {
                SPI_FREE_W::new(self)
            }
            ///Bit 7 - RW1, interrupt flag for SPI0 slave mode first byte received
            #[inline(always)]
            #[must_use]
            pub fn spi_if_fst_byte(&mut self) -> SPI_IF_FST_BYTE_W<7> {
                SPI_IF_FST_BYTE_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW1, SPI0 interrupt flag
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [spi0_int_flag](index.html) module
        pub struct SPI0_INT_FLAG_SPEC;
        impl crate::RegisterSpec for SPI0_INT_FLAG_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [spi0_int_flag::R](R) reader structure
        impl crate::Readable for SPI0_INT_FLAG_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [spi0_int_flag::W](W) writer structure
        impl crate::Writable for SPI0_INT_FLAG_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets SPI0_INT_FLAG to value 0x40
        impl crate::Resettable for SPI0_INT_FLAG_SPEC {
            const RESET_VALUE: Self::Ux = 0x40;
        }
    }
    ///SPI0_FIFO_COUNT (r) register accessor: an alias for `Reg<SPI0_FIFO_COUNT_SPEC>`
    pub type SPI0_FIFO_COUNT = crate::Reg<spi0_fifo_count::SPI0_FIFO_COUNT_SPEC>;
    ///RO, SPI0 FIFO count status
    pub mod spi0_fifo_count {
        ///Register `SPI0_FIFO_COUNT` reader
        pub struct R(crate::R<SPI0_FIFO_COUNT_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<SPI0_FIFO_COUNT_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<SPI0_FIFO_COUNT_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<SPI0_FIFO_COUNT_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `SPI0_FIFO_COUNT` reader - RO, SPI0 FIFO count status
        pub type SPI0_FIFO_COUNT_R = crate::FieldReader<u8, u8>;
        impl R {
            ///Bits 0:7 - RO, SPI0 FIFO count status
            #[inline(always)]
            pub fn spi0_fifo_count(&self) -> SPI0_FIFO_COUNT_R {
                SPI0_FIFO_COUNT_R::new(self.bits)
            }
        }
        ///RO, SPI0 FIFO count status
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [spi0_fifo_count](index.html) module
        pub struct SPI0_FIFO_COUNT_SPEC;
        impl crate::RegisterSpec for SPI0_FIFO_COUNT_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [spi0_fifo_count::R](R) reader structure
        impl crate::Readable for SPI0_FIFO_COUNT_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets SPI0_FIFO_COUNT to value 0
        impl crate::Resettable for SPI0_FIFO_COUNT_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///SPI0_TOTAL_CNT (rw) register accessor: an alias for `Reg<SPI0_TOTAL_CNT_SPEC>`
    pub type SPI0_TOTAL_CNT = crate::Reg<spi0_total_cnt::SPI0_TOTAL_CNT_SPEC>;
    ///RW, SPI0 total byte count, only low 12 bit
    pub mod spi0_total_cnt {
        ///Register `SPI0_TOTAL_CNT` reader
        pub struct R(crate::R<SPI0_TOTAL_CNT_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<SPI0_TOTAL_CNT_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<SPI0_TOTAL_CNT_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<SPI0_TOTAL_CNT_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `SPI0_TOTAL_CNT` writer
        pub struct W(crate::W<SPI0_TOTAL_CNT_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<SPI0_TOTAL_CNT_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<SPI0_TOTAL_CNT_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<SPI0_TOTAL_CNT_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `SPI0_TOTAL_CNT` reader - RW, SPI0 total byte count, only low 12 bit
        pub type SPI0_TOTAL_CNT_R = crate::FieldReader<u16, u16>;
        ///Field `SPI0_TOTAL_CNT` writer - RW, SPI0 total byte count, only low 12 bit
        pub type SPI0_TOTAL_CNT_W<'a, const O: u8> =
            crate::FieldWriter<'a, u16, SPI0_TOTAL_CNT_SPEC, u16, u16, 16, O>;
        impl R {
            ///Bits 0:15 - RW, SPI0 total byte count, only low 12 bit
            #[inline(always)]
            pub fn spi0_total_cnt(&self) -> SPI0_TOTAL_CNT_R {
                SPI0_TOTAL_CNT_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - RW, SPI0 total byte count, only low 12 bit
            #[inline(always)]
            #[must_use]
            pub fn spi0_total_cnt(&mut self) -> SPI0_TOTAL_CNT_W<0> {
                SPI0_TOTAL_CNT_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, SPI0 total byte count, only low 12 bit
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [spi0_total_cnt](index.html) module
        pub struct SPI0_TOTAL_CNT_SPEC;
        impl crate::RegisterSpec for SPI0_TOTAL_CNT_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [spi0_total_cnt::R](R) reader structure
        impl crate::Readable for SPI0_TOTAL_CNT_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [spi0_total_cnt::W](W) writer structure
        impl crate::Writable for SPI0_TOTAL_CNT_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets SPI0_TOTAL_CNT to value 0
        impl crate::Resettable for SPI0_TOTAL_CNT_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///SPI0_FIFO (rw) register accessor: an alias for `Reg<SPI0_FIFO_SPEC>`
    pub type SPI0_FIFO = crate::Reg<spi0_fifo::SPI0_FIFO_SPEC>;
    ///RO/WO, SPI0 FIFO register
    pub mod spi0_fifo {
        ///Register `SPI0_FIFO` reader
        pub struct R(crate::R<SPI0_FIFO_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<SPI0_FIFO_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<SPI0_FIFO_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<SPI0_FIFO_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `SPI0_FIFO` writer
        pub struct W(crate::W<SPI0_FIFO_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<SPI0_FIFO_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<SPI0_FIFO_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<SPI0_FIFO_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `SPI0_FIFO` reader - RO/WO, SPI0 FIFO register
        pub type SPI0_FIFO_R = crate::FieldReader<u8, u8>;
        ///Field `SPI0_FIFO` writer - RO/WO, SPI0 FIFO register
        pub type SPI0_FIFO_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, SPI0_FIFO_SPEC, u8, u8, 8, O>;
        impl R {
            ///Bits 0:7 - RO/WO, SPI0 FIFO register
            #[inline(always)]
            pub fn spi0_fifo(&self) -> SPI0_FIFO_R {
                SPI0_FIFO_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:7 - RO/WO, SPI0 FIFO register
            #[inline(always)]
            #[must_use]
            pub fn spi0_fifo(&mut self) -> SPI0_FIFO_W<0> {
                SPI0_FIFO_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RO/WO, SPI0 FIFO register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [spi0_fifo](index.html) module
        pub struct SPI0_FIFO_SPEC;
        impl crate::RegisterSpec for SPI0_FIFO_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [spi0_fifo::R](R) reader structure
        impl crate::Readable for SPI0_FIFO_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [spi0_fifo::W](W) writer structure
        impl crate::Writable for SPI0_FIFO_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets SPI0_FIFO to value 0
        impl crate::Resettable for SPI0_FIFO_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///SPI0_FIFO_COUNT1 (r) register accessor: an alias for `Reg<SPI0_FIFO_COUNT1_SPEC>`
    pub type SPI0_FIFO_COUNT1 = crate::Reg<spi0_fifo_count1::SPI0_FIFO_COUNT1_SPEC>;
    ///RO, SPI0 FIFO count status
    pub mod spi0_fifo_count1 {
        ///Register `SPI0_FIFO_COUNT1` reader
        pub struct R(crate::R<SPI0_FIFO_COUNT1_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<SPI0_FIFO_COUNT1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<SPI0_FIFO_COUNT1_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<SPI0_FIFO_COUNT1_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `SPI0_FIFO_COUNT1` reader - RO, SPI0 FIFO count status
        pub type SPI0_FIFO_COUNT1_R = crate::FieldReader<u8, u8>;
        impl R {
            ///Bits 0:7 - RO, SPI0 FIFO count status
            #[inline(always)]
            pub fn spi0_fifo_count1(&self) -> SPI0_FIFO_COUNT1_R {
                SPI0_FIFO_COUNT1_R::new(self.bits)
            }
        }
        ///RO, SPI0 FIFO count status
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [spi0_fifo_count1](index.html) module
        pub struct SPI0_FIFO_COUNT1_SPEC;
        impl crate::RegisterSpec for SPI0_FIFO_COUNT1_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [spi0_fifo_count1::R](R) reader structure
        impl crate::Readable for SPI0_FIFO_COUNT1_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets SPI0_FIFO_COUNT1 to value 0
        impl crate::Resettable for SPI0_FIFO_COUNT1_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///SPI0_DMA_NOW (rw) register accessor: an alias for `Reg<SPI0_DMA_NOW_SPEC>`
    pub type SPI0_DMA_NOW = crate::Reg<spi0_dma_now::SPI0_DMA_NOW_SPEC>;
    ///RW, SPI0 DMA current address
    pub mod spi0_dma_now {
        ///Register `SPI0_DMA_NOW` reader
        pub struct R(crate::R<SPI0_DMA_NOW_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<SPI0_DMA_NOW_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<SPI0_DMA_NOW_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<SPI0_DMA_NOW_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `SPI0_DMA_NOW` writer
        pub struct W(crate::W<SPI0_DMA_NOW_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<SPI0_DMA_NOW_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<SPI0_DMA_NOW_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<SPI0_DMA_NOW_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `SPI0_DMA_NOW` reader - RW, SPI0 DMA current address
        pub type SPI0_DMA_NOW_R = crate::FieldReader<u16, u16>;
        ///Field `SPI0_DMA_NOW` writer - RW, SPI0 DMA current address
        pub type SPI0_DMA_NOW_W<'a, const O: u8> =
            crate::FieldWriter<'a, u16, SPI0_DMA_NOW_SPEC, u16, u16, 16, O>;
        impl R {
            ///Bits 0:15 - RW, SPI0 DMA current address
            #[inline(always)]
            pub fn spi0_dma_now(&self) -> SPI0_DMA_NOW_R {
                SPI0_DMA_NOW_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - RW, SPI0 DMA current address
            #[inline(always)]
            #[must_use]
            pub fn spi0_dma_now(&mut self) -> SPI0_DMA_NOW_W<0> {
                SPI0_DMA_NOW_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, SPI0 DMA current address
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [spi0_dma_now](index.html) module
        pub struct SPI0_DMA_NOW_SPEC;
        impl crate::RegisterSpec for SPI0_DMA_NOW_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [spi0_dma_now::R](R) reader structure
        impl crate::Readable for SPI0_DMA_NOW_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [spi0_dma_now::W](W) writer structure
        impl crate::Writable for SPI0_DMA_NOW_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets SPI0_DMA_NOW to value 0
        impl crate::Resettable for SPI0_DMA_NOW_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///SPI0_DMA_BEG (rw) register accessor: an alias for `Reg<SPI0_DMA_BEG_SPEC>`
    pub type SPI0_DMA_BEG = crate::Reg<spi0_dma_beg::SPI0_DMA_BEG_SPEC>;
    ///RW, SPI0 DMA begin address
    pub mod spi0_dma_beg {
        ///Register `SPI0_DMA_BEG` reader
        pub struct R(crate::R<SPI0_DMA_BEG_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<SPI0_DMA_BEG_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<SPI0_DMA_BEG_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<SPI0_DMA_BEG_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `SPI0_DMA_BEG` writer
        pub struct W(crate::W<SPI0_DMA_BEG_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<SPI0_DMA_BEG_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<SPI0_DMA_BEG_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<SPI0_DMA_BEG_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `SPI0_DMA_BEG` reader - RW, SPI0 DMA begin address
        pub type SPI0_DMA_BEG_R = crate::FieldReader<u16, u16>;
        ///Field `SPI0_DMA_BEG` writer - RW, SPI0 DMA begin address
        pub type SPI0_DMA_BEG_W<'a, const O: u8> =
            crate::FieldWriter<'a, u16, SPI0_DMA_BEG_SPEC, u16, u16, 16, O>;
        impl R {
            ///Bits 0:15 - RW, SPI0 DMA begin address
            #[inline(always)]
            pub fn spi0_dma_beg(&self) -> SPI0_DMA_BEG_R {
                SPI0_DMA_BEG_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - RW, SPI0 DMA begin address
            #[inline(always)]
            #[must_use]
            pub fn spi0_dma_beg(&mut self) -> SPI0_DMA_BEG_W<0> {
                SPI0_DMA_BEG_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, SPI0 DMA begin address
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [spi0_dma_beg](index.html) module
        pub struct SPI0_DMA_BEG_SPEC;
        impl crate::RegisterSpec for SPI0_DMA_BEG_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [spi0_dma_beg::R](R) reader structure
        impl crate::Readable for SPI0_DMA_BEG_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [spi0_dma_beg::W](W) writer structure
        impl crate::Writable for SPI0_DMA_BEG_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets SPI0_DMA_BEG to value 0
        impl crate::Resettable for SPI0_DMA_BEG_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///SPI0_DMA_END (rw) register accessor: an alias for `Reg<SPI0_DMA_END_SPEC>`
    pub type SPI0_DMA_END = crate::Reg<spi0_dma_end::SPI0_DMA_END_SPEC>;
    ///RW, SPI0 DMA end address
    pub mod spi0_dma_end {
        ///Register `SPI0_DMA_END` reader
        pub struct R(crate::R<SPI0_DMA_END_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<SPI0_DMA_END_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<SPI0_DMA_END_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<SPI0_DMA_END_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `SPI0_DMA_END` writer
        pub struct W(crate::W<SPI0_DMA_END_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<SPI0_DMA_END_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<SPI0_DMA_END_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<SPI0_DMA_END_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `SPI0_DMA_END` reader - RW, SPI0 DMA end address
        pub type SPI0_DMA_END_R = crate::FieldReader<u16, u16>;
        ///Field `SPI0_DMA_END` writer - RW, SPI0 DMA end address
        pub type SPI0_DMA_END_W<'a, const O: u8> =
            crate::FieldWriter<'a, u16, SPI0_DMA_END_SPEC, u16, u16, 16, O>;
        impl R {
            ///Bits 0:15 - RW, SPI0 DMA end address
            #[inline(always)]
            pub fn spi0_dma_end(&self) -> SPI0_DMA_END_R {
                SPI0_DMA_END_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - RW, SPI0 DMA end address
            #[inline(always)]
            #[must_use]
            pub fn spi0_dma_end(&mut self) -> SPI0_DMA_END_W<0> {
                SPI0_DMA_END_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, SPI0 DMA end address
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [spi0_dma_end](index.html) module
        pub struct SPI0_DMA_END_SPEC;
        impl crate::RegisterSpec for SPI0_DMA_END_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [spi0_dma_end::R](R) reader structure
        impl crate::Readable for SPI0_DMA_END_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [spi0_dma_end::W](W) writer structure
        impl crate::Writable for SPI0_DMA_END_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets SPI0_DMA_END to value 0
        impl crate::Resettable for SPI0_DMA_END_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
}
///SPI1 register
pub struct SPI1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for SPI1 {}
impl SPI1 {
    ///Pointer to the register block
    pub const PTR: *const spi1::RegisterBlock = 0x4000_4400 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const spi1::RegisterBlock {
        Self::PTR
    }
}
impl Deref for SPI1 {
    type Target = spi1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for SPI1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("SPI1").finish()
    }
}
///SPI1 register
pub mod spi1 {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        ///0x00 - RW, SPI1 mode control
        pub spi1_ctrl_mod: SPI1_CTRL_MOD,
        ///0x01 - RW, SPI1 configuration control
        pub spi1_ctrl_cfg: SPI1_CTRL_CFG,
        ///0x02 - RW, SPI1 interrupt enable
        pub spi1_inter_en: SPI1_INTER_EN,
        ///0x03 - RW, SPI1 master clock divisor;
        pub spi1_clock_div: SPI1_CLOCK_DIV,
        ///0x04 - RW, SPI1 data buffer
        pub spi1_buffer: SPI1_BUFFER,
        ///0x05 - RO, SPI1 work flag
        pub spi1_run_flag: SPI1_RUN_FLAG,
        ///0x06 - RW1, SPI1 interrupt flag
        pub spi1_int_flag: SPI1_INT_FLAG,
        ///0x07 - RO, SPI1 FIFO count status
        pub spi1_fifo_count: SPI1_FIFO_COUNT,
        _reserved8: [u8; 0x04],
        ///0x0c - RW, SPI1 total byte count, only low 12 bit
        pub spi1_total_cnt: SPI1_TOTAL_CNT,
        _reserved9: [u8; 0x02],
        ///0x10 - RO/WO, SPI1 FIFO register
        pub spi1_fifo: SPI1_FIFO,
        _reserved10: [u8; 0x02],
        ///0x13 - RO, SPI1 FIFO count status
        pub spi1_fifo_count1: SPI1_FIFO_COUNT1,
    }
    ///SPI1_CTRL_MOD (rw) register accessor: an alias for `Reg<SPI1_CTRL_MOD_SPEC>`
    pub type SPI1_CTRL_MOD = crate::Reg<spi1_ctrl_mod::SPI1_CTRL_MOD_SPEC>;
    ///RW, SPI1 mode control
    pub mod spi1_ctrl_mod {
        ///Register `SPI1_CTRL_MOD` reader
        pub struct R(crate::R<SPI1_CTRL_MOD_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<SPI1_CTRL_MOD_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<SPI1_CTRL_MOD_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<SPI1_CTRL_MOD_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `SPI1_CTRL_MOD` writer
        pub struct W(crate::W<SPI1_CTRL_MOD_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<SPI1_CTRL_MOD_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<SPI1_CTRL_MOD_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<SPI1_CTRL_MOD_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `SPI_MODE_SLAVE` reader - RW, SPI0 slave mode: 0=master or host, 1=slave or device
        pub type SPI_MODE_SLAVE_R = crate::BitReader<bool>;
        ///Field `SPI_MODE_SLAVE` writer - RW, SPI0 slave mode: 0=master or host, 1=slave or device
        pub type SPI_MODE_SLAVE_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, SPI1_CTRL_MOD_SPEC, bool, O>;
        ///Field `SPI_ALL_CLEAR` reader - RW, force clear SPI FIFO and count
        pub type SPI_ALL_CLEAR_R = crate::BitReader<bool>;
        ///Field `SPI_ALL_CLEAR` writer - RW, force clear SPI FIFO and count
        pub type SPI_ALL_CLEAR_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, SPI1_CTRL_MOD_SPEC, bool, O>;
        ///Field `SPI_2WIRE_MOD` reader - RW, SPI0 enable 2 wire mode for slave: 0=3wire(SCK0,MOSI,MISO), 1=2wire(SCK0,MISO=MXSX)
        pub type SPI_2WIRE_MOD_R = crate::BitReader<bool>;
        ///Field `SPI_2WIRE_MOD` writer - RW, SPI0 enable 2 wire mode for slave: 0=3wire(SCK0,MOSI,MISO), 1=2wire(SCK0,MISO=MXSX)
        pub type SPI_2WIRE_MOD_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, SPI1_CTRL_MOD_SPEC, bool, O>;
        ///Field `SPI_MST_SCK_MOD__RB_SPI_SLV_CMD_MOD` reader - RW, SPI master clock mode: 0=mode 0, 1=mode 3;RW, SPI0 slave command mode: 0=byte stream, 1=first byte command
        pub type SPI_MST_SCK_MOD__RB_SPI_SLV_CMD_MOD_R = crate::BitReader<bool>;
        ///Field `SPI_MST_SCK_MOD__RB_SPI_SLV_CMD_MOD` writer - RW, SPI master clock mode: 0=mode 0, 1=mode 3;RW, SPI0 slave command mode: 0=byte stream, 1=first byte command
        pub type SPI_MST_SCK_MOD__RB_SPI_SLV_CMD_MOD_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, SPI1_CTRL_MOD_SPEC, bool, O>;
        ///Field `SPI_FIFO_DIR` reader - RW, SPI FIFO direction: 0=out(write @master mode), 1=in(read @master mode)
        pub type SPI_FIFO_DIR_R = crate::BitReader<bool>;
        ///Field `SPI_FIFO_DIR` writer - RW, SPI FIFO direction: 0=out(write @master mode), 1=in(read @master mode)
        pub type SPI_FIFO_DIR_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, SPI1_CTRL_MOD_SPEC, bool, O>;
        ///Field `SPI_SCK_OE` reader - RW, SPI SCK output enable
        pub type SPI_SCK_OE_R = crate::BitReader<bool>;
        ///Field `SPI_SCK_OE` writer - RW, SPI SCK output enable
        pub type SPI_SCK_OE_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, SPI1_CTRL_MOD_SPEC, bool, O>;
        ///Field `SPI_MOSI_OE` reader - RW, SPI MOSI output enable
        pub type SPI_MOSI_OE_R = crate::BitReader<bool>;
        ///Field `SPI_MOSI_OE` writer - RW, SPI MOSI output enable
        pub type SPI_MOSI_OE_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, SPI1_CTRL_MOD_SPEC, bool, O>;
        ///Field `SPI_MISO_OE` reader - RW, SPI MISO output enable
        pub type SPI_MISO_OE_R = crate::BitReader<bool>;
        ///Field `SPI_MISO_OE` writer - RW, SPI MISO output enable
        pub type SPI_MISO_OE_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, SPI1_CTRL_MOD_SPEC, bool, O>;
        impl R {
            ///Bit 0 - RW, SPI0 slave mode: 0=master or host, 1=slave or device
            #[inline(always)]
            pub fn spi_mode_slave(&self) -> SPI_MODE_SLAVE_R {
                SPI_MODE_SLAVE_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RW, force clear SPI FIFO and count
            #[inline(always)]
            pub fn spi_all_clear(&self) -> SPI_ALL_CLEAR_R {
                SPI_ALL_CLEAR_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RW, SPI0 enable 2 wire mode for slave: 0=3wire(SCK0,MOSI,MISO), 1=2wire(SCK0,MISO=MXSX)
            #[inline(always)]
            pub fn spi_2wire_mod(&self) -> SPI_2WIRE_MOD_R {
                SPI_2WIRE_MOD_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RW, SPI master clock mode: 0=mode 0, 1=mode 3;RW, SPI0 slave command mode: 0=byte stream, 1=first byte command
            #[inline(always)]
            pub fn spi_mst_sck_mod__rb_spi_slv_cmd_mod(
                &self,
            ) -> SPI_MST_SCK_MOD__RB_SPI_SLV_CMD_MOD_R {
                SPI_MST_SCK_MOD__RB_SPI_SLV_CMD_MOD_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RW, SPI FIFO direction: 0=out(write @master mode), 1=in(read @master mode)
            #[inline(always)]
            pub fn spi_fifo_dir(&self) -> SPI_FIFO_DIR_R {
                SPI_FIFO_DIR_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - RW, SPI SCK output enable
            #[inline(always)]
            pub fn spi_sck_oe(&self) -> SPI_SCK_OE_R {
                SPI_SCK_OE_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - RW, SPI MOSI output enable
            #[inline(always)]
            pub fn spi_mosi_oe(&self) -> SPI_MOSI_OE_R {
                SPI_MOSI_OE_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - RW, SPI MISO output enable
            #[inline(always)]
            pub fn spi_miso_oe(&self) -> SPI_MISO_OE_R {
                SPI_MISO_OE_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RW, SPI0 slave mode: 0=master or host, 1=slave or device
            #[inline(always)]
            #[must_use]
            pub fn spi_mode_slave(&mut self) -> SPI_MODE_SLAVE_W<0> {
                SPI_MODE_SLAVE_W::new(self)
            }
            ///Bit 1 - RW, force clear SPI FIFO and count
            #[inline(always)]
            #[must_use]
            pub fn spi_all_clear(&mut self) -> SPI_ALL_CLEAR_W<1> {
                SPI_ALL_CLEAR_W::new(self)
            }
            ///Bit 2 - RW, SPI0 enable 2 wire mode for slave: 0=3wire(SCK0,MOSI,MISO), 1=2wire(SCK0,MISO=MXSX)
            #[inline(always)]
            #[must_use]
            pub fn spi_2wire_mod(&mut self) -> SPI_2WIRE_MOD_W<2> {
                SPI_2WIRE_MOD_W::new(self)
            }
            ///Bit 3 - RW, SPI master clock mode: 0=mode 0, 1=mode 3;RW, SPI0 slave command mode: 0=byte stream, 1=first byte command
            #[inline(always)]
            #[must_use]
            pub fn spi_mst_sck_mod__rb_spi_slv_cmd_mod(
                &mut self,
            ) -> SPI_MST_SCK_MOD__RB_SPI_SLV_CMD_MOD_W<3> {
                SPI_MST_SCK_MOD__RB_SPI_SLV_CMD_MOD_W::new(self)
            }
            ///Bit 4 - RW, SPI FIFO direction: 0=out(write @master mode), 1=in(read @master mode)
            #[inline(always)]
            #[must_use]
            pub fn spi_fifo_dir(&mut self) -> SPI_FIFO_DIR_W<4> {
                SPI_FIFO_DIR_W::new(self)
            }
            ///Bit 5 - RW, SPI SCK output enable
            #[inline(always)]
            #[must_use]
            pub fn spi_sck_oe(&mut self) -> SPI_SCK_OE_W<5> {
                SPI_SCK_OE_W::new(self)
            }
            ///Bit 6 - RW, SPI MOSI output enable
            #[inline(always)]
            #[must_use]
            pub fn spi_mosi_oe(&mut self) -> SPI_MOSI_OE_W<6> {
                SPI_MOSI_OE_W::new(self)
            }
            ///Bit 7 - RW, SPI MISO output enable
            #[inline(always)]
            #[must_use]
            pub fn spi_miso_oe(&mut self) -> SPI_MISO_OE_W<7> {
                SPI_MISO_OE_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, SPI1 mode control
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [spi1_ctrl_mod](index.html) module
        pub struct SPI1_CTRL_MOD_SPEC;
        impl crate::RegisterSpec for SPI1_CTRL_MOD_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [spi1_ctrl_mod::R](R) reader structure
        impl crate::Readable for SPI1_CTRL_MOD_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [spi1_ctrl_mod::W](W) writer structure
        impl crate::Writable for SPI1_CTRL_MOD_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets SPI1_CTRL_MOD to value 0x02
        impl crate::Resettable for SPI1_CTRL_MOD_SPEC {
            const RESET_VALUE: Self::Ux = 0x02;
        }
    }
    ///SPI1_CTRL_CFG (rw) register accessor: an alias for `Reg<SPI1_CTRL_CFG_SPEC>`
    pub type SPI1_CTRL_CFG = crate::Reg<spi1_ctrl_cfg::SPI1_CTRL_CFG_SPEC>;
    ///RW, SPI1 configuration control
    pub mod spi1_ctrl_cfg {
        ///Register `SPI1_CTRL_CFG` reader
        pub struct R(crate::R<SPI1_CTRL_CFG_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<SPI1_CTRL_CFG_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<SPI1_CTRL_CFG_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<SPI1_CTRL_CFG_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `SPI1_CTRL_CFG` writer
        pub struct W(crate::W<SPI1_CTRL_CFG_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<SPI1_CTRL_CFG_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<SPI1_CTRL_CFG_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<SPI1_CTRL_CFG_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `SPI_DMA_ENABLE` reader - RW, SPI0 DMA enable
        pub type SPI_DMA_ENABLE_R = crate::BitReader<bool>;
        ///Field `SPI_DMA_ENABLE` writer - RW, SPI0 DMA enable
        pub type SPI_DMA_ENABLE_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, SPI1_CTRL_CFG_SPEC, bool, O>;
        ///Field `SPI_DMA_LOOP` reader - RW, SPI0 DMA address loop enable
        pub type SPI_DMA_LOOP_R = crate::BitReader<bool>;
        ///Field `SPI_DMA_LOOP` writer - RW, SPI0 DMA address loop enable
        pub type SPI_DMA_LOOP_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, SPI1_CTRL_CFG_SPEC, bool, O>;
        ///Field `SPI_AUTO_IF` reader - RW, enable buffer/FIFO accessing to auto clear RB_SPI_IF_BYTE_END interrupt flag
        pub type SPI_AUTO_IF_R = crate::BitReader<bool>;
        ///Field `SPI_AUTO_IF` writer - RW, enable buffer/FIFO accessing to auto clear RB_SPI_IF_BYTE_END interrupt flag
        pub type SPI_AUTO_IF_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, SPI1_CTRL_CFG_SPEC, bool, O>;
        ///Field `SPI_BIT_ORDER` reader - RW, SPI bit data order: 0=MSB first, 1=LSB first
        pub type SPI_BIT_ORDER_R = crate::BitReader<bool>;
        ///Field `SPI_BIT_ORDER` writer - RW, SPI bit data order: 0=MSB first, 1=LSB first
        pub type SPI_BIT_ORDER_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, SPI1_CTRL_CFG_SPEC, bool, O>;
        ///Field `SPI_MST_DLY_EN` reader - RW, SPI master input delay enable
        pub type SPI_MST_DLY_EN_R = crate::BitReader<bool>;
        ///Field `SPI_MST_DLY_EN` writer - RW, SPI master input delay enable
        pub type SPI_MST_DLY_EN_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, SPI1_CTRL_CFG_SPEC, bool, O>;
        impl R {
            ///Bit 0 - RW, SPI0 DMA enable
            #[inline(always)]
            pub fn spi_dma_enable(&self) -> SPI_DMA_ENABLE_R {
                SPI_DMA_ENABLE_R::new((self.bits & 1) != 0)
            }
            ///Bit 2 - RW, SPI0 DMA address loop enable
            #[inline(always)]
            pub fn spi_dma_loop(&self) -> SPI_DMA_LOOP_R {
                SPI_DMA_LOOP_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 4 - RW, enable buffer/FIFO accessing to auto clear RB_SPI_IF_BYTE_END interrupt flag
            #[inline(always)]
            pub fn spi_auto_if(&self) -> SPI_AUTO_IF_R {
                SPI_AUTO_IF_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - RW, SPI bit data order: 0=MSB first, 1=LSB first
            #[inline(always)]
            pub fn spi_bit_order(&self) -> SPI_BIT_ORDER_R {
                SPI_BIT_ORDER_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - RW, SPI master input delay enable
            #[inline(always)]
            pub fn spi_mst_dly_en(&self) -> SPI_MST_DLY_EN_R {
                SPI_MST_DLY_EN_R::new(((self.bits >> 6) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RW, SPI0 DMA enable
            #[inline(always)]
            #[must_use]
            pub fn spi_dma_enable(&mut self) -> SPI_DMA_ENABLE_W<0> {
                SPI_DMA_ENABLE_W::new(self)
            }
            ///Bit 2 - RW, SPI0 DMA address loop enable
            #[inline(always)]
            #[must_use]
            pub fn spi_dma_loop(&mut self) -> SPI_DMA_LOOP_W<2> {
                SPI_DMA_LOOP_W::new(self)
            }
            ///Bit 4 - RW, enable buffer/FIFO accessing to auto clear RB_SPI_IF_BYTE_END interrupt flag
            #[inline(always)]
            #[must_use]
            pub fn spi_auto_if(&mut self) -> SPI_AUTO_IF_W<4> {
                SPI_AUTO_IF_W::new(self)
            }
            ///Bit 5 - RW, SPI bit data order: 0=MSB first, 1=LSB first
            #[inline(always)]
            #[must_use]
            pub fn spi_bit_order(&mut self) -> SPI_BIT_ORDER_W<5> {
                SPI_BIT_ORDER_W::new(self)
            }
            ///Bit 6 - RW, SPI master input delay enable
            #[inline(always)]
            #[must_use]
            pub fn spi_mst_dly_en(&mut self) -> SPI_MST_DLY_EN_W<6> {
                SPI_MST_DLY_EN_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, SPI1 configuration control
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [spi1_ctrl_cfg](index.html) module
        pub struct SPI1_CTRL_CFG_SPEC;
        impl crate::RegisterSpec for SPI1_CTRL_CFG_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [spi1_ctrl_cfg::R](R) reader structure
        impl crate::Readable for SPI1_CTRL_CFG_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [spi1_ctrl_cfg::W](W) writer structure
        impl crate::Writable for SPI1_CTRL_CFG_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets SPI1_CTRL_CFG to value 0
        impl crate::Resettable for SPI1_CTRL_CFG_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///SPI1_INTER_EN (rw) register accessor: an alias for `Reg<SPI1_INTER_EN_SPEC>`
    pub type SPI1_INTER_EN = crate::Reg<spi1_inter_en::SPI1_INTER_EN_SPEC>;
    ///RW, SPI1 interrupt enable
    pub mod spi1_inter_en {
        ///Register `SPI1_INTER_EN` reader
        pub struct R(crate::R<SPI1_INTER_EN_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<SPI1_INTER_EN_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<SPI1_INTER_EN_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<SPI1_INTER_EN_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `SPI1_INTER_EN` writer
        pub struct W(crate::W<SPI1_INTER_EN_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<SPI1_INTER_EN_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<SPI1_INTER_EN_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<SPI1_INTER_EN_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `SPI_IE_CNT_END` reader - RW, enable interrupt for SPI total byte count end
        pub type SPI_IE_CNT_END_R = crate::BitReader<bool>;
        ///Field `SPI_IE_CNT_END` writer - RW, enable interrupt for SPI total byte count end
        pub type SPI_IE_CNT_END_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, SPI1_INTER_EN_SPEC, bool, O>;
        ///Field `SPI_IE_BYTE_END` reader - RW, enable interrupt for SPI byte exchanged
        pub type SPI_IE_BYTE_END_R = crate::BitReader<bool>;
        ///Field `SPI_IE_BYTE_END` writer - RW, enable interrupt for SPI byte exchanged
        pub type SPI_IE_BYTE_END_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, SPI1_INTER_EN_SPEC, bool, O>;
        ///Field `SPI_IE_FIFO_HF` reader - RW, enable interrupt for SPI FIFO half
        pub type SPI_IE_FIFO_HF_R = crate::BitReader<bool>;
        ///Field `SPI_IE_FIFO_HF` writer - RW, enable interrupt for SPI FIFO half
        pub type SPI_IE_FIFO_HF_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, SPI1_INTER_EN_SPEC, bool, O>;
        ///Field `SPI_IE_DMA_END` reader - RW, enable interrupt for SPI0 DMA completion
        pub type SPI_IE_DMA_END_R = crate::BitReader<bool>;
        ///Field `SPI_IE_DMA_END` writer - RW, enable interrupt for SPI0 DMA completion
        pub type SPI_IE_DMA_END_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, SPI1_INTER_EN_SPEC, bool, O>;
        ///Field `SPI_IE_FIFO_OV` reader - RW, enable interrupt for SPI0 FIFO overflow
        pub type SPI_IE_FIFO_OV_R = crate::BitReader<bool>;
        ///Field `SPI_IE_FIFO_OV` writer - RW, enable interrupt for SPI0 FIFO overflow
        pub type SPI_IE_FIFO_OV_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, SPI1_INTER_EN_SPEC, bool, O>;
        ///Field `SPI_IE_FST_BYTE` reader - RW, enable interrupt for SPI0 slave mode first byte received
        pub type SPI_IE_FST_BYTE_R = crate::BitReader<bool>;
        ///Field `SPI_IE_FST_BYTE` writer - RW, enable interrupt for SPI0 slave mode first byte received
        pub type SPI_IE_FST_BYTE_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, SPI1_INTER_EN_SPEC, bool, O>;
        impl R {
            ///Bit 0 - RW, enable interrupt for SPI total byte count end
            #[inline(always)]
            pub fn spi_ie_cnt_end(&self) -> SPI_IE_CNT_END_R {
                SPI_IE_CNT_END_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RW, enable interrupt for SPI byte exchanged
            #[inline(always)]
            pub fn spi_ie_byte_end(&self) -> SPI_IE_BYTE_END_R {
                SPI_IE_BYTE_END_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RW, enable interrupt for SPI FIFO half
            #[inline(always)]
            pub fn spi_ie_fifo_hf(&self) -> SPI_IE_FIFO_HF_R {
                SPI_IE_FIFO_HF_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RW, enable interrupt for SPI0 DMA completion
            #[inline(always)]
            pub fn spi_ie_dma_end(&self) -> SPI_IE_DMA_END_R {
                SPI_IE_DMA_END_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RW, enable interrupt for SPI0 FIFO overflow
            #[inline(always)]
            pub fn spi_ie_fifo_ov(&self) -> SPI_IE_FIFO_OV_R {
                SPI_IE_FIFO_OV_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 7 - RW, enable interrupt for SPI0 slave mode first byte received
            #[inline(always)]
            pub fn spi_ie_fst_byte(&self) -> SPI_IE_FST_BYTE_R {
                SPI_IE_FST_BYTE_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RW, enable interrupt for SPI total byte count end
            #[inline(always)]
            #[must_use]
            pub fn spi_ie_cnt_end(&mut self) -> SPI_IE_CNT_END_W<0> {
                SPI_IE_CNT_END_W::new(self)
            }
            ///Bit 1 - RW, enable interrupt for SPI byte exchanged
            #[inline(always)]
            #[must_use]
            pub fn spi_ie_byte_end(&mut self) -> SPI_IE_BYTE_END_W<1> {
                SPI_IE_BYTE_END_W::new(self)
            }
            ///Bit 2 - RW, enable interrupt for SPI FIFO half
            #[inline(always)]
            #[must_use]
            pub fn spi_ie_fifo_hf(&mut self) -> SPI_IE_FIFO_HF_W<2> {
                SPI_IE_FIFO_HF_W::new(self)
            }
            ///Bit 3 - RW, enable interrupt for SPI0 DMA completion
            #[inline(always)]
            #[must_use]
            pub fn spi_ie_dma_end(&mut self) -> SPI_IE_DMA_END_W<3> {
                SPI_IE_DMA_END_W::new(self)
            }
            ///Bit 4 - RW, enable interrupt for SPI0 FIFO overflow
            #[inline(always)]
            #[must_use]
            pub fn spi_ie_fifo_ov(&mut self) -> SPI_IE_FIFO_OV_W<4> {
                SPI_IE_FIFO_OV_W::new(self)
            }
            ///Bit 7 - RW, enable interrupt for SPI0 slave mode first byte received
            #[inline(always)]
            #[must_use]
            pub fn spi_ie_fst_byte(&mut self) -> SPI_IE_FST_BYTE_W<7> {
                SPI_IE_FST_BYTE_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, SPI1 interrupt enable
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [spi1_inter_en](index.html) module
        pub struct SPI1_INTER_EN_SPEC;
        impl crate::RegisterSpec for SPI1_INTER_EN_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [spi1_inter_en::R](R) reader structure
        impl crate::Readable for SPI1_INTER_EN_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [spi1_inter_en::W](W) writer structure
        impl crate::Writable for SPI1_INTER_EN_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets SPI1_INTER_EN to value 0
        impl crate::Resettable for SPI1_INTER_EN_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///SPI1_CLOCK_DIV (rw) register accessor: an alias for `Reg<SPI1_CLOCK_DIV_SPEC>`
    pub type SPI1_CLOCK_DIV = crate::Reg<spi1_clock_div::SPI1_CLOCK_DIV_SPEC>;
    ///RW, SPI1 master clock divisor;
    pub mod spi1_clock_div {
        ///Register `SPI1_CLOCK_DIV` reader
        pub struct R(crate::R<SPI1_CLOCK_DIV_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<SPI1_CLOCK_DIV_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<SPI1_CLOCK_DIV_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<SPI1_CLOCK_DIV_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `SPI1_CLOCK_DIV` writer
        pub struct W(crate::W<SPI1_CLOCK_DIV_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<SPI1_CLOCK_DIV_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<SPI1_CLOCK_DIV_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<SPI1_CLOCK_DIV_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `SPI0_CLOCK_DIV__R8_SPI0_SLAVE_PRE` reader - RW, SPI0 master clock divisor;RW, SPI0 slave preset value
        pub type SPI0_CLOCK_DIV__R8_SPI0_SLAVE_PRE_R = crate::FieldReader<u8, u8>;
        ///Field `SPI0_CLOCK_DIV__R8_SPI0_SLAVE_PRE` writer - RW, SPI0 master clock divisor;RW, SPI0 slave preset value
        pub type SPI0_CLOCK_DIV__R8_SPI0_SLAVE_PRE_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, SPI1_CLOCK_DIV_SPEC, u8, u8, 8, O>;
        impl R {
            ///Bits 0:7 - RW, SPI0 master clock divisor;RW, SPI0 slave preset value
            #[inline(always)]
            pub fn spi0_clock_div__r8_spi0_slave_pre(&self) -> SPI0_CLOCK_DIV__R8_SPI0_SLAVE_PRE_R {
                SPI0_CLOCK_DIV__R8_SPI0_SLAVE_PRE_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:7 - RW, SPI0 master clock divisor;RW, SPI0 slave preset value
            #[inline(always)]
            #[must_use]
            pub fn spi0_clock_div__r8_spi0_slave_pre(
                &mut self,
            ) -> SPI0_CLOCK_DIV__R8_SPI0_SLAVE_PRE_W<0> {
                SPI0_CLOCK_DIV__R8_SPI0_SLAVE_PRE_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, SPI1 master clock divisor;
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [spi1_clock_div](index.html) module
        pub struct SPI1_CLOCK_DIV_SPEC;
        impl crate::RegisterSpec for SPI1_CLOCK_DIV_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [spi1_clock_div::R](R) reader structure
        impl crate::Readable for SPI1_CLOCK_DIV_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [spi1_clock_div::W](W) writer structure
        impl crate::Writable for SPI1_CLOCK_DIV_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets SPI1_CLOCK_DIV to value 0x10
        impl crate::Resettable for SPI1_CLOCK_DIV_SPEC {
            const RESET_VALUE: Self::Ux = 0x10;
        }
    }
    ///SPI1_BUFFER (rw) register accessor: an alias for `Reg<SPI1_BUFFER_SPEC>`
    pub type SPI1_BUFFER = crate::Reg<spi1_buffer::SPI1_BUFFER_SPEC>;
    ///RW, SPI1 data buffer
    pub mod spi1_buffer {
        ///Register `SPI1_BUFFER` reader
        pub struct R(crate::R<SPI1_BUFFER_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<SPI1_BUFFER_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<SPI1_BUFFER_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<SPI1_BUFFER_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `SPI1_BUFFER` writer
        pub struct W(crate::W<SPI1_BUFFER_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<SPI1_BUFFER_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<SPI1_BUFFER_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<SPI1_BUFFER_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `SPI1_BUFFER` reader - RW, SPI1 data buffer
        pub type SPI1_BUFFER_R = crate::FieldReader<u8, u8>;
        ///Field `SPI1_BUFFER` writer - RW, SPI1 data buffer
        pub type SPI1_BUFFER_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, SPI1_BUFFER_SPEC, u8, u8, 8, O>;
        impl R {
            ///Bits 0:7 - RW, SPI1 data buffer
            #[inline(always)]
            pub fn spi1_buffer(&self) -> SPI1_BUFFER_R {
                SPI1_BUFFER_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:7 - RW, SPI1 data buffer
            #[inline(always)]
            #[must_use]
            pub fn spi1_buffer(&mut self) -> SPI1_BUFFER_W<0> {
                SPI1_BUFFER_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, SPI1 data buffer
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [spi1_buffer](index.html) module
        pub struct SPI1_BUFFER_SPEC;
        impl crate::RegisterSpec for SPI1_BUFFER_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [spi1_buffer::R](R) reader structure
        impl crate::Readable for SPI1_BUFFER_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [spi1_buffer::W](W) writer structure
        impl crate::Writable for SPI1_BUFFER_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets SPI1_BUFFER to value 0
        impl crate::Resettable for SPI1_BUFFER_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///SPI1_RUN_FLAG (r) register accessor: an alias for `Reg<SPI1_RUN_FLAG_SPEC>`
    pub type SPI1_RUN_FLAG = crate::Reg<spi1_run_flag::SPI1_RUN_FLAG_SPEC>;
    ///RO, SPI1 work flag
    pub mod spi1_run_flag {
        ///Register `SPI1_RUN_FLAG` reader
        pub struct R(crate::R<SPI1_RUN_FLAG_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<SPI1_RUN_FLAG_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<SPI1_RUN_FLAG_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<SPI1_RUN_FLAG_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `SPI_SLV_CMD_ACT` reader - RO, SPI0 slave first byte or command flag
        pub type SPI_SLV_CMD_ACT_R = crate::BitReader<bool>;
        ///Field `SPI_FIFO_READY` reader - RO, SPI FIFO ready status
        pub type SPI_FIFO_READY_R = crate::BitReader<bool>;
        ///Field `SPI_SLV_CS_LOAD` reader - RO, SPI0 slave chip-select loading status
        pub type SPI_SLV_CS_LOAD_R = crate::BitReader<bool>;
        ///Field `SPI_SLV_SELECT` reader - RO, SPI0 slave selection status
        pub type SPI_SLV_SELECT_R = crate::BitReader<bool>;
        impl R {
            ///Bit 4 - RO, SPI0 slave first byte or command flag
            #[inline(always)]
            pub fn spi_slv_cmd_act(&self) -> SPI_SLV_CMD_ACT_R {
                SPI_SLV_CMD_ACT_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - RO, SPI FIFO ready status
            #[inline(always)]
            pub fn spi_fifo_ready(&self) -> SPI_FIFO_READY_R {
                SPI_FIFO_READY_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - RO, SPI0 slave chip-select loading status
            #[inline(always)]
            pub fn spi_slv_cs_load(&self) -> SPI_SLV_CS_LOAD_R {
                SPI_SLV_CS_LOAD_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - RO, SPI0 slave selection status
            #[inline(always)]
            pub fn spi_slv_select(&self) -> SPI_SLV_SELECT_R {
                SPI_SLV_SELECT_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        ///RO, SPI1 work flag
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [spi1_run_flag](index.html) module
        pub struct SPI1_RUN_FLAG_SPEC;
        impl crate::RegisterSpec for SPI1_RUN_FLAG_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [spi1_run_flag::R](R) reader structure
        impl crate::Readable for SPI1_RUN_FLAG_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets SPI1_RUN_FLAG to value 0
        impl crate::Resettable for SPI1_RUN_FLAG_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///SPI1_INT_FLAG (rw) register accessor: an alias for `Reg<SPI1_INT_FLAG_SPEC>`
    pub type SPI1_INT_FLAG = crate::Reg<spi1_int_flag::SPI1_INT_FLAG_SPEC>;
    ///RW1, SPI1 interrupt flag
    pub mod spi1_int_flag {
        ///Register `SPI1_INT_FLAG` reader
        pub struct R(crate::R<SPI1_INT_FLAG_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<SPI1_INT_FLAG_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<SPI1_INT_FLAG_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<SPI1_INT_FLAG_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `SPI1_INT_FLAG` writer
        pub struct W(crate::W<SPI1_INT_FLAG_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<SPI1_INT_FLAG_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<SPI1_INT_FLAG_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<SPI1_INT_FLAG_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `SPI_IF_CNT_END` reader - RW1, interrupt flag for SPI total byte count end
        pub type SPI_IF_CNT_END_R = crate::BitReader<bool>;
        ///Field `SPI_IF_CNT_END` writer - RW1, interrupt flag for SPI total byte count end
        pub type SPI_IF_CNT_END_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, SPI1_INT_FLAG_SPEC, bool, O>;
        ///Field `SPI_IF_BYTE_END` reader - RW1, interrupt flag for SPI byte exchanged
        pub type SPI_IF_BYTE_END_R = crate::BitReader<bool>;
        ///Field `SPI_IF_BYTE_END` writer - RW1, interrupt flag for SPI byte exchanged
        pub type SPI_IF_BYTE_END_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, SPI1_INT_FLAG_SPEC, bool, O>;
        ///Field `SPI_IF_FIFO_HF` reader - RW1, interrupt flag for SPI FIFO half
        pub type SPI_IF_FIFO_HF_R = crate::BitReader<bool>;
        ///Field `SPI_IF_FIFO_HF` writer - RW1, interrupt flag for SPI FIFO half
        pub type SPI_IF_FIFO_HF_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, SPI1_INT_FLAG_SPEC, bool, O>;
        ///Field `SPI_IF_DMA_END` reader - RW1, interrupt flag for SPI0 DMA completion
        pub type SPI_IF_DMA_END_R = crate::BitReader<bool>;
        ///Field `SPI_IF_DMA_END` writer - RW1, interrupt flag for SPI0 DMA completion
        pub type SPI_IF_DMA_END_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, SPI1_INT_FLAG_SPEC, bool, O>;
        ///Field `SPI_IF_FIFO_OV` reader - RW1, interrupt flag for SPI0 FIFO overflow
        pub type SPI_IF_FIFO_OV_R = crate::BitReader<bool>;
        ///Field `SPI_IF_FIFO_OV` writer - RW1, interrupt flag for SPI0 FIFO overflow
        pub type SPI_IF_FIFO_OV_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, SPI1_INT_FLAG_SPEC, bool, O>;
        ///Field `SPI_FREE` reader - RO, current SPI free status
        pub type SPI_FREE_R = crate::BitReader<bool>;
        ///Field `SPI_FREE` writer - RO, current SPI free status
        pub type SPI_FREE_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, SPI1_INT_FLAG_SPEC, bool, O>;
        ///Field `SPI_IF_FST_BYTE` reader - RW1, interrupt flag for SPI0 slave mode first byte received
        pub type SPI_IF_FST_BYTE_R = crate::BitReader<bool>;
        ///Field `SPI_IF_FST_BYTE` writer - RW1, interrupt flag for SPI0 slave mode first byte received
        pub type SPI_IF_FST_BYTE_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, SPI1_INT_FLAG_SPEC, bool, O>;
        impl R {
            ///Bit 0 - RW1, interrupt flag for SPI total byte count end
            #[inline(always)]
            pub fn spi_if_cnt_end(&self) -> SPI_IF_CNT_END_R {
                SPI_IF_CNT_END_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RW1, interrupt flag for SPI byte exchanged
            #[inline(always)]
            pub fn spi_if_byte_end(&self) -> SPI_IF_BYTE_END_R {
                SPI_IF_BYTE_END_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RW1, interrupt flag for SPI FIFO half
            #[inline(always)]
            pub fn spi_if_fifo_hf(&self) -> SPI_IF_FIFO_HF_R {
                SPI_IF_FIFO_HF_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RW1, interrupt flag for SPI0 DMA completion
            #[inline(always)]
            pub fn spi_if_dma_end(&self) -> SPI_IF_DMA_END_R {
                SPI_IF_DMA_END_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RW1, interrupt flag for SPI0 FIFO overflow
            #[inline(always)]
            pub fn spi_if_fifo_ov(&self) -> SPI_IF_FIFO_OV_R {
                SPI_IF_FIFO_OV_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 6 - RO, current SPI free status
            #[inline(always)]
            pub fn spi_free(&self) -> SPI_FREE_R {
                SPI_FREE_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - RW1, interrupt flag for SPI0 slave mode first byte received
            #[inline(always)]
            pub fn spi_if_fst_byte(&self) -> SPI_IF_FST_BYTE_R {
                SPI_IF_FST_BYTE_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RW1, interrupt flag for SPI total byte count end
            #[inline(always)]
            #[must_use]
            pub fn spi_if_cnt_end(&mut self) -> SPI_IF_CNT_END_W<0> {
                SPI_IF_CNT_END_W::new(self)
            }
            ///Bit 1 - RW1, interrupt flag for SPI byte exchanged
            #[inline(always)]
            #[must_use]
            pub fn spi_if_byte_end(&mut self) -> SPI_IF_BYTE_END_W<1> {
                SPI_IF_BYTE_END_W::new(self)
            }
            ///Bit 2 - RW1, interrupt flag for SPI FIFO half
            #[inline(always)]
            #[must_use]
            pub fn spi_if_fifo_hf(&mut self) -> SPI_IF_FIFO_HF_W<2> {
                SPI_IF_FIFO_HF_W::new(self)
            }
            ///Bit 3 - RW1, interrupt flag for SPI0 DMA completion
            #[inline(always)]
            #[must_use]
            pub fn spi_if_dma_end(&mut self) -> SPI_IF_DMA_END_W<3> {
                SPI_IF_DMA_END_W::new(self)
            }
            ///Bit 4 - RW1, interrupt flag for SPI0 FIFO overflow
            #[inline(always)]
            #[must_use]
            pub fn spi_if_fifo_ov(&mut self) -> SPI_IF_FIFO_OV_W<4> {
                SPI_IF_FIFO_OV_W::new(self)
            }
            ///Bit 6 - RO, current SPI free status
            #[inline(always)]
            #[must_use]
            pub fn spi_free(&mut self) -> SPI_FREE_W<6> {
                SPI_FREE_W::new(self)
            }
            ///Bit 7 - RW1, interrupt flag for SPI0 slave mode first byte received
            #[inline(always)]
            #[must_use]
            pub fn spi_if_fst_byte(&mut self) -> SPI_IF_FST_BYTE_W<7> {
                SPI_IF_FST_BYTE_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW1, SPI1 interrupt flag
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [spi1_int_flag](index.html) module
        pub struct SPI1_INT_FLAG_SPEC;
        impl crate::RegisterSpec for SPI1_INT_FLAG_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [spi1_int_flag::R](R) reader structure
        impl crate::Readable for SPI1_INT_FLAG_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [spi1_int_flag::W](W) writer structure
        impl crate::Writable for SPI1_INT_FLAG_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets SPI1_INT_FLAG to value 0x40
        impl crate::Resettable for SPI1_INT_FLAG_SPEC {
            const RESET_VALUE: Self::Ux = 0x40;
        }
    }
    ///SPI1_FIFO_COUNT (r) register accessor: an alias for `Reg<SPI1_FIFO_COUNT_SPEC>`
    pub type SPI1_FIFO_COUNT = crate::Reg<spi1_fifo_count::SPI1_FIFO_COUNT_SPEC>;
    ///RO, SPI1 FIFO count status
    pub mod spi1_fifo_count {
        ///Register `SPI1_FIFO_COUNT` reader
        pub struct R(crate::R<SPI1_FIFO_COUNT_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<SPI1_FIFO_COUNT_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<SPI1_FIFO_COUNT_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<SPI1_FIFO_COUNT_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `SPI1_FIFO_COUNT` reader - RO, SPI0 FIFO count status
        pub type SPI1_FIFO_COUNT_R = crate::FieldReader<u8, u8>;
        impl R {
            ///Bits 0:7 - RO, SPI0 FIFO count status
            #[inline(always)]
            pub fn spi1_fifo_count(&self) -> SPI1_FIFO_COUNT_R {
                SPI1_FIFO_COUNT_R::new(self.bits)
            }
        }
        ///RO, SPI1 FIFO count status
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [spi1_fifo_count](index.html) module
        pub struct SPI1_FIFO_COUNT_SPEC;
        impl crate::RegisterSpec for SPI1_FIFO_COUNT_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [spi1_fifo_count::R](R) reader structure
        impl crate::Readable for SPI1_FIFO_COUNT_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets SPI1_FIFO_COUNT to value 0
        impl crate::Resettable for SPI1_FIFO_COUNT_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///SPI1_TOTAL_CNT (rw) register accessor: an alias for `Reg<SPI1_TOTAL_CNT_SPEC>`
    pub type SPI1_TOTAL_CNT = crate::Reg<spi1_total_cnt::SPI1_TOTAL_CNT_SPEC>;
    ///RW, SPI1 total byte count, only low 12 bit
    pub mod spi1_total_cnt {
        ///Register `SPI1_TOTAL_CNT` reader
        pub struct R(crate::R<SPI1_TOTAL_CNT_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<SPI1_TOTAL_CNT_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<SPI1_TOTAL_CNT_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<SPI1_TOTAL_CNT_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `SPI1_TOTAL_CNT` writer
        pub struct W(crate::W<SPI1_TOTAL_CNT_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<SPI1_TOTAL_CNT_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<SPI1_TOTAL_CNT_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<SPI1_TOTAL_CNT_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `SPI1_TOTAL_CNT` reader - RW, SPI1 total byte count, only low 12 bit
        pub type SPI1_TOTAL_CNT_R = crate::FieldReader<u16, u16>;
        ///Field `SPI1_TOTAL_CNT` writer - RW, SPI1 total byte count, only low 12 bit
        pub type SPI1_TOTAL_CNT_W<'a, const O: u8> =
            crate::FieldWriter<'a, u16, SPI1_TOTAL_CNT_SPEC, u16, u16, 16, O>;
        impl R {
            ///Bits 0:15 - RW, SPI1 total byte count, only low 12 bit
            #[inline(always)]
            pub fn spi1_total_cnt(&self) -> SPI1_TOTAL_CNT_R {
                SPI1_TOTAL_CNT_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - RW, SPI1 total byte count, only low 12 bit
            #[inline(always)]
            #[must_use]
            pub fn spi1_total_cnt(&mut self) -> SPI1_TOTAL_CNT_W<0> {
                SPI1_TOTAL_CNT_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, SPI1 total byte count, only low 12 bit
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [spi1_total_cnt](index.html) module
        pub struct SPI1_TOTAL_CNT_SPEC;
        impl crate::RegisterSpec for SPI1_TOTAL_CNT_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [spi1_total_cnt::R](R) reader structure
        impl crate::Readable for SPI1_TOTAL_CNT_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [spi1_total_cnt::W](W) writer structure
        impl crate::Writable for SPI1_TOTAL_CNT_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets SPI1_TOTAL_CNT to value 0
        impl crate::Resettable for SPI1_TOTAL_CNT_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///SPI1_FIFO (rw) register accessor: an alias for `Reg<SPI1_FIFO_SPEC>`
    pub type SPI1_FIFO = crate::Reg<spi1_fifo::SPI1_FIFO_SPEC>;
    ///RO/WO, SPI1 FIFO register
    pub mod spi1_fifo {
        ///Register `SPI1_FIFO` reader
        pub struct R(crate::R<SPI1_FIFO_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<SPI1_FIFO_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<SPI1_FIFO_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<SPI1_FIFO_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `SPI1_FIFO` writer
        pub struct W(crate::W<SPI1_FIFO_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<SPI1_FIFO_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<SPI1_FIFO_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<SPI1_FIFO_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `SPI1_FIFO` reader - RO/WO, SPI1 FIFO register
        pub type SPI1_FIFO_R = crate::FieldReader<u8, u8>;
        ///Field `SPI1_FIFO` writer - RO/WO, SPI1 FIFO register
        pub type SPI1_FIFO_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, SPI1_FIFO_SPEC, u8, u8, 8, O>;
        impl R {
            ///Bits 0:7 - RO/WO, SPI1 FIFO register
            #[inline(always)]
            pub fn spi1_fifo(&self) -> SPI1_FIFO_R {
                SPI1_FIFO_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:7 - RO/WO, SPI1 FIFO register
            #[inline(always)]
            #[must_use]
            pub fn spi1_fifo(&mut self) -> SPI1_FIFO_W<0> {
                SPI1_FIFO_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RO/WO, SPI1 FIFO register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [spi1_fifo](index.html) module
        pub struct SPI1_FIFO_SPEC;
        impl crate::RegisterSpec for SPI1_FIFO_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [spi1_fifo::R](R) reader structure
        impl crate::Readable for SPI1_FIFO_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [spi1_fifo::W](W) writer structure
        impl crate::Writable for SPI1_FIFO_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets SPI1_FIFO to value 0
        impl crate::Resettable for SPI1_FIFO_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///SPI1_FIFO_COUNT1 (r) register accessor: an alias for `Reg<SPI1_FIFO_COUNT1_SPEC>`
    pub type SPI1_FIFO_COUNT1 = crate::Reg<spi1_fifo_count1::SPI1_FIFO_COUNT1_SPEC>;
    ///RO, SPI1 FIFO count status
    pub mod spi1_fifo_count1 {
        ///Register `SPI1_FIFO_COUNT1` reader
        pub struct R(crate::R<SPI1_FIFO_COUNT1_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<SPI1_FIFO_COUNT1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<SPI1_FIFO_COUNT1_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<SPI1_FIFO_COUNT1_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `SPI1_FIFO_COUNT1` reader - RO, SPI1 FIFO count status
        pub type SPI1_FIFO_COUNT1_R = crate::FieldReader<u8, u8>;
        impl R {
            ///Bits 0:7 - RO, SPI1 FIFO count status
            #[inline(always)]
            pub fn spi1_fifo_count1(&self) -> SPI1_FIFO_COUNT1_R {
                SPI1_FIFO_COUNT1_R::new(self.bits)
            }
        }
        ///RO, SPI1 FIFO count status
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [spi1_fifo_count1](index.html) module
        pub struct SPI1_FIFO_COUNT1_SPEC;
        impl crate::RegisterSpec for SPI1_FIFO_COUNT1_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [spi1_fifo_count1::R](R) reader structure
        impl crate::Readable for SPI1_FIFO_COUNT1_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets SPI1_FIFO_COUNT1 to value 0
        impl crate::Resettable for SPI1_FIFO_COUNT1_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
}
///I2C register
pub struct I2C {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for I2C {}
impl I2C {
    ///Pointer to the register block
    pub const PTR: *const i2c::RegisterBlock = 0x4000_4800 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const i2c::RegisterBlock {
        Self::PTR
    }
}
impl Deref for I2C {
    type Target = i2c::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for I2C {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("I2C").finish()
    }
}
///I2C register
pub mod i2c {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        ///0x00 - RW, I2C control 1
        pub i2c_ctrl1: I2C_CTRL1,
        _reserved1: [u8; 0x02],
        ///0x04 - RW, I2C control 2
        pub i2c_ctrl2: I2C_CTRL2,
        _reserved2: [u8; 0x02],
        ///0x08 - RW, I2C own address register 1
        pub i2c_oaddr1: I2C_OADDR1,
        _reserved3: [u8; 0x02],
        ///0x0c - RW, I2C own address register 2
        pub i2c_oaddr2: I2C_OADDR2,
        _reserved4: [u8; 0x02],
        ///0x10 - RW, I2C data register
        pub i2c_datar: I2C_DATAR,
        _reserved5: [u8; 0x02],
        ///0x14 - R0, I2C stauts register 1
        pub i2c_star1: I2C_STAR1,
        _reserved6: [u8; 0x02],
        _reserved_6_i2c: [u8; 0x02],
        _reserved7: [u8; 0x02],
        ///0x1c - RW, I2C clock control register
        pub i2c_ckcfgr: I2C_CKCFGR,
        _reserved8: [u8; 0x02],
        ///0x20 - RW, I2C trise register
        pub i2c_rtr: I2C_RTR,
    }
    impl RegisterBlock {
        ///0x18 - R0, I2C status register 2
        #[inline(always)]
        pub const fn i2c_star2(&self) -> &I2C_STAR2 {
            unsafe { &*(self as *const Self).cast::<u8>().add(24usize).cast() }
        }
        ///0x19 - R0, I2C Packet error checking register
        #[inline(always)]
        pub const fn i2c_pec(&self) -> &I2C_PEC {
            unsafe { &*(self as *const Self).cast::<u8>().add(25usize).cast() }
        }
    }
    ///I2C_CTRL1 (rw) register accessor: an alias for `Reg<I2C_CTRL1_SPEC>`
    pub type I2C_CTRL1 = crate::Reg<i2c_ctrl1::I2C_CTRL1_SPEC>;
    ///RW, I2C control 1
    pub mod i2c_ctrl1 {
        ///Register `I2C_CTRL1` reader
        pub struct R(crate::R<I2C_CTRL1_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<I2C_CTRL1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<I2C_CTRL1_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<I2C_CTRL1_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `I2C_CTRL1` writer
        pub struct W(crate::W<I2C_CTRL1_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<I2C_CTRL1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<I2C_CTRL1_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<I2C_CTRL1_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `I2C_PE` reader - RW, Peripheral enable
        pub type I2C_PE_R = crate::BitReader<bool>;
        ///Field `I2C_PE` writer - RW, Peripheral enable
        pub type I2C_PE_W<'a, const O: u8> = crate::BitWriter<'a, u16, I2C_CTRL1_SPEC, bool, O>;
        ///Field `I2C_SMBUS` reader - RW, SMBUS mode: 0=I2C mode, 1=SMBUS mode
        pub type I2C_SMBUS_R = crate::BitReader<bool>;
        ///Field `I2C_SMBUS` writer - RW, SMBUS mode: 0=I2C mode, 1=SMBUS mode
        pub type I2C_SMBUS_W<'a, const O: u8> = crate::BitWriter<'a, u16, I2C_CTRL1_SPEC, bool, O>;
        ///Field `I2C_SMBTYPE` reader - RW, SMBus type: 0=Device, 1=Host
        pub type I2C_SMBTYPE_R = crate::BitReader<bool>;
        ///Field `I2C_SMBTYPE` writer - RW, SMBus type: 0=Device, 1=Host
        pub type I2C_SMBTYPE_W<'a, const O: u8> =
            crate::BitWriter<'a, u16, I2C_CTRL1_SPEC, bool, O>;
        ///Field `I2C_EBARP` reader - RW, ARP enable
        pub type I2C_EBARP_R = crate::BitReader<bool>;
        ///Field `I2C_EBARP` writer - RW, ARP enable
        pub type I2C_EBARP_W<'a, const O: u8> = crate::BitWriter<'a, u16, I2C_CTRL1_SPEC, bool, O>;
        ///Field `I2C_ENPEC` reader - RW, PEC ebable
        pub type I2C_ENPEC_R = crate::BitReader<bool>;
        ///Field `I2C_ENPEC` writer - RW, PEC ebable
        pub type I2C_ENPEC_W<'a, const O: u8> = crate::BitWriter<'a, u16, I2C_CTRL1_SPEC, bool, O>;
        ///Field `I2C_ENGC` reader - RW, General call enable
        pub type I2C_ENGC_R = crate::BitReader<bool>;
        ///Field `I2C_ENGC` writer - RW, General call enable
        pub type I2C_ENGC_W<'a, const O: u8> = crate::BitWriter<'a, u16, I2C_CTRL1_SPEC, bool, O>;
        ///Field `I2C_NOSTRETCH` reader - RW, Clock stretching disable (Slave mode)
        pub type I2C_NOSTRETCH_R = crate::BitReader<bool>;
        ///Field `I2C_NOSTRETCH` writer - RW, Clock stretching disable (Slave mode)
        pub type I2C_NOSTRETCH_W<'a, const O: u8> =
            crate::BitWriter<'a, u16, I2C_CTRL1_SPEC, bool, O>;
        ///Field `I2C_START` reader - RW, Start generation: master mode: 0=no start, 1=repeated start; slave mode: 0=no start, 1=start at bus free
        pub type I2C_START_R = crate::BitReader<bool>;
        ///Field `I2C_START` writer - RW, Start generation: master mode: 0=no start, 1=repeated start; slave mode: 0=no start, 1=start at bus free
        pub type I2C_START_W<'a, const O: u8> = crate::BitWriter<'a, u16, I2C_CTRL1_SPEC, bool, O>;
        ///Field `I2C_STOP` reader - RW, Stop generation: master mode: 0=no stop, 1=stop after the current byte transfer or after the current Start condition is sent; slave mode: 0=no stop, 1=Release the SCL and SDA lines after the current byte transfer
        pub type I2C_STOP_R = crate::BitReader<bool>;
        ///Field `I2C_STOP` writer - RW, Stop generation: master mode: 0=no stop, 1=stop after the current byte transfer or after the current Start condition is sent; slave mode: 0=no stop, 1=Release the SCL and SDA lines after the current byte transfer
        pub type I2C_STOP_W<'a, const O: u8> = crate::BitWriter<'a, u16, I2C_CTRL1_SPEC, bool, O>;
        ///Field `I2C_ACK` reader - RW, Acknowledge enable
        pub type I2C_ACK_R = crate::BitReader<bool>;
        ///Field `I2C_ACK` writer - RW, Acknowledge enable
        pub type I2C_ACK_W<'a, const O: u8> = crate::BitWriter<'a, u16, I2C_CTRL1_SPEC, bool, O>;
        ///Field `I2C_POS` reader - RW, Acknowledge/PEC Position (for data reception)
        pub type I2C_POS_R = crate::BitReader<bool>;
        ///Field `I2C_POS` writer - RW, Acknowledge/PEC Position (for data reception)
        pub type I2C_POS_W<'a, const O: u8> = crate::BitWriter<'a, u16, I2C_CTRL1_SPEC, bool, O>;
        ///Field `I2C_PEC` reader - RW, Packet error checking: 0=No PEC transfer, 1=PEC transfer (in Tx or Rx mode)
        pub type I2C_PEC_R = crate::BitReader<bool>;
        ///Field `I2C_PEC` writer - RW, Packet error checking: 0=No PEC transfer, 1=PEC transfer (in Tx or Rx mode)
        pub type I2C_PEC_W<'a, const O: u8> = crate::BitWriter<'a, u16, I2C_CTRL1_SPEC, bool, O>;
        ///Field `I2C_ALERT` reader - RW, SMBus alert: 0=Releases SMBA pin high, 1=Drives SMBA pin low.
        pub type I2C_ALERT_R = crate::BitReader<bool>;
        ///Field `I2C_ALERT` writer - RW, SMBus alert: 0=Releases SMBA pin high, 1=Drives SMBA pin low.
        pub type I2C_ALERT_W<'a, const O: u8> = crate::BitWriter<'a, u16, I2C_CTRL1_SPEC, bool, O>;
        ///Field `I2C_SWRST` reader - RW, Software reset
        pub type I2C_SWRST_R = crate::BitReader<bool>;
        ///Field `I2C_SWRST` writer - RW, Software reset
        pub type I2C_SWRST_W<'a, const O: u8> = crate::BitWriter<'a, u16, I2C_CTRL1_SPEC, bool, O>;
        impl R {
            ///Bit 0 - RW, Peripheral enable
            #[inline(always)]
            pub fn i2c_pe(&self) -> I2C_PE_R {
                I2C_PE_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RW, SMBUS mode: 0=I2C mode, 1=SMBUS mode
            #[inline(always)]
            pub fn i2c_smbus(&self) -> I2C_SMBUS_R {
                I2C_SMBUS_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 3 - RW, SMBus type: 0=Device, 1=Host
            #[inline(always)]
            pub fn i2c_smbtype(&self) -> I2C_SMBTYPE_R {
                I2C_SMBTYPE_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RW, ARP enable
            #[inline(always)]
            pub fn i2c_ebarp(&self) -> I2C_EBARP_R {
                I2C_EBARP_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - RW, PEC ebable
            #[inline(always)]
            pub fn i2c_enpec(&self) -> I2C_ENPEC_R {
                I2C_ENPEC_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - RW, General call enable
            #[inline(always)]
            pub fn i2c_engc(&self) -> I2C_ENGC_R {
                I2C_ENGC_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - RW, Clock stretching disable (Slave mode)
            #[inline(always)]
            pub fn i2c_nostretch(&self) -> I2C_NOSTRETCH_R {
                I2C_NOSTRETCH_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bit 8 - RW, Start generation: master mode: 0=no start, 1=repeated start; slave mode: 0=no start, 1=start at bus free
            #[inline(always)]
            pub fn i2c_start(&self) -> I2C_START_R {
                I2C_START_R::new(((self.bits >> 8) & 1) != 0)
            }
            ///Bit 9 - RW, Stop generation: master mode: 0=no stop, 1=stop after the current byte transfer or after the current Start condition is sent; slave mode: 0=no stop, 1=Release the SCL and SDA lines after the current byte transfer
            #[inline(always)]
            pub fn i2c_stop(&self) -> I2C_STOP_R {
                I2C_STOP_R::new(((self.bits >> 9) & 1) != 0)
            }
            ///Bit 10 - RW, Acknowledge enable
            #[inline(always)]
            pub fn i2c_ack(&self) -> I2C_ACK_R {
                I2C_ACK_R::new(((self.bits >> 10) & 1) != 0)
            }
            ///Bit 11 - RW, Acknowledge/PEC Position (for data reception)
            #[inline(always)]
            pub fn i2c_pos(&self) -> I2C_POS_R {
                I2C_POS_R::new(((self.bits >> 11) & 1) != 0)
            }
            ///Bit 12 - RW, Packet error checking: 0=No PEC transfer, 1=PEC transfer (in Tx or Rx mode)
            #[inline(always)]
            pub fn i2c_pec(&self) -> I2C_PEC_R {
                I2C_PEC_R::new(((self.bits >> 12) & 1) != 0)
            }
            ///Bit 13 - RW, SMBus alert: 0=Releases SMBA pin high, 1=Drives SMBA pin low.
            #[inline(always)]
            pub fn i2c_alert(&self) -> I2C_ALERT_R {
                I2C_ALERT_R::new(((self.bits >> 13) & 1) != 0)
            }
            ///Bit 15 - RW, Software reset
            #[inline(always)]
            pub fn i2c_swrst(&self) -> I2C_SWRST_R {
                I2C_SWRST_R::new(((self.bits >> 15) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RW, Peripheral enable
            #[inline(always)]
            #[must_use]
            pub fn i2c_pe(&mut self) -> I2C_PE_W<0> {
                I2C_PE_W::new(self)
            }
            ///Bit 1 - RW, SMBUS mode: 0=I2C mode, 1=SMBUS mode
            #[inline(always)]
            #[must_use]
            pub fn i2c_smbus(&mut self) -> I2C_SMBUS_W<1> {
                I2C_SMBUS_W::new(self)
            }
            ///Bit 3 - RW, SMBus type: 0=Device, 1=Host
            #[inline(always)]
            #[must_use]
            pub fn i2c_smbtype(&mut self) -> I2C_SMBTYPE_W<3> {
                I2C_SMBTYPE_W::new(self)
            }
            ///Bit 4 - RW, ARP enable
            #[inline(always)]
            #[must_use]
            pub fn i2c_ebarp(&mut self) -> I2C_EBARP_W<4> {
                I2C_EBARP_W::new(self)
            }
            ///Bit 5 - RW, PEC ebable
            #[inline(always)]
            #[must_use]
            pub fn i2c_enpec(&mut self) -> I2C_ENPEC_W<5> {
                I2C_ENPEC_W::new(self)
            }
            ///Bit 6 - RW, General call enable
            #[inline(always)]
            #[must_use]
            pub fn i2c_engc(&mut self) -> I2C_ENGC_W<6> {
                I2C_ENGC_W::new(self)
            }
            ///Bit 7 - RW, Clock stretching disable (Slave mode)
            #[inline(always)]
            #[must_use]
            pub fn i2c_nostretch(&mut self) -> I2C_NOSTRETCH_W<7> {
                I2C_NOSTRETCH_W::new(self)
            }
            ///Bit 8 - RW, Start generation: master mode: 0=no start, 1=repeated start; slave mode: 0=no start, 1=start at bus free
            #[inline(always)]
            #[must_use]
            pub fn i2c_start(&mut self) -> I2C_START_W<8> {
                I2C_START_W::new(self)
            }
            ///Bit 9 - RW, Stop generation: master mode: 0=no stop, 1=stop after the current byte transfer or after the current Start condition is sent; slave mode: 0=no stop, 1=Release the SCL and SDA lines after the current byte transfer
            #[inline(always)]
            #[must_use]
            pub fn i2c_stop(&mut self) -> I2C_STOP_W<9> {
                I2C_STOP_W::new(self)
            }
            ///Bit 10 - RW, Acknowledge enable
            #[inline(always)]
            #[must_use]
            pub fn i2c_ack(&mut self) -> I2C_ACK_W<10> {
                I2C_ACK_W::new(self)
            }
            ///Bit 11 - RW, Acknowledge/PEC Position (for data reception)
            #[inline(always)]
            #[must_use]
            pub fn i2c_pos(&mut self) -> I2C_POS_W<11> {
                I2C_POS_W::new(self)
            }
            ///Bit 12 - RW, Packet error checking: 0=No PEC transfer, 1=PEC transfer (in Tx or Rx mode)
            #[inline(always)]
            #[must_use]
            pub fn i2c_pec(&mut self) -> I2C_PEC_W<12> {
                I2C_PEC_W::new(self)
            }
            ///Bit 13 - RW, SMBus alert: 0=Releases SMBA pin high, 1=Drives SMBA pin low.
            #[inline(always)]
            #[must_use]
            pub fn i2c_alert(&mut self) -> I2C_ALERT_W<13> {
                I2C_ALERT_W::new(self)
            }
            ///Bit 15 - RW, Software reset
            #[inline(always)]
            #[must_use]
            pub fn i2c_swrst(&mut self) -> I2C_SWRST_W<15> {
                I2C_SWRST_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, I2C control 1
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [i2c_ctrl1](index.html) module
        pub struct I2C_CTRL1_SPEC;
        impl crate::RegisterSpec for I2C_CTRL1_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [i2c_ctrl1::R](R) reader structure
        impl crate::Readable for I2C_CTRL1_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [i2c_ctrl1::W](W) writer structure
        impl crate::Writable for I2C_CTRL1_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets I2C_CTRL1 to value 0
        impl crate::Resettable for I2C_CTRL1_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///I2C_CTRL2 (rw) register accessor: an alias for `Reg<I2C_CTRL2_SPEC>`
    pub type I2C_CTRL2 = crate::Reg<i2c_ctrl2::I2C_CTRL2_SPEC>;
    ///RW, I2C control 2
    pub mod i2c_ctrl2 {
        ///Register `I2C_CTRL2` reader
        pub struct R(crate::R<I2C_CTRL2_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<I2C_CTRL2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<I2C_CTRL2_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<I2C_CTRL2_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `I2C_CTRL2` writer
        pub struct W(crate::W<I2C_CTRL2_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<I2C_CTRL2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<I2C_CTRL2_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<I2C_CTRL2_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `I2C_FREQ` reader - RW, Peripheral clock frequency, The minimum allowed frequency is 2 MHz,the maximum frequency is 36 MHz
        pub type I2C_FREQ_R = crate::FieldReader<u8, u8>;
        ///Field `I2C_FREQ` writer - RW, Peripheral clock frequency, The minimum allowed frequency is 2 MHz,the maximum frequency is 36 MHz
        pub type I2C_FREQ_W<'a, const O: u8> =
            crate::FieldWriter<'a, u16, I2C_CTRL2_SPEC, u8, u8, 6, O>;
        ///Field `I2C_ITERREN` reader - RW, Error interrupt enable
        pub type I2C_ITERREN_R = crate::BitReader<bool>;
        ///Field `I2C_ITERREN` writer - RW, Error interrupt enable
        pub type I2C_ITERREN_W<'a, const O: u8> =
            crate::BitWriter<'a, u16, I2C_CTRL2_SPEC, bool, O>;
        ///Field `I2C_ITEVTEN` reader - RW, Event interrupt enable
        pub type I2C_ITEVTEN_R = crate::BitReader<bool>;
        ///Field `I2C_ITEVTEN` writer - RW, Event interrupt enable
        pub type I2C_ITEVTEN_W<'a, const O: u8> =
            crate::BitWriter<'a, u16, I2C_CTRL2_SPEC, bool, O>;
        ///Field `I2C_ITBUFEN` reader - RW, Buffer interrupt enable
        pub type I2C_ITBUFEN_R = crate::BitReader<bool>;
        ///Field `I2C_ITBUFEN` writer - RW, Buffer interrupt enable
        pub type I2C_ITBUFEN_W<'a, const O: u8> =
            crate::BitWriter<'a, u16, I2C_CTRL2_SPEC, bool, O>;
        impl R {
            ///Bits 0:5 - RW, Peripheral clock frequency, The minimum allowed frequency is 2 MHz,the maximum frequency is 36 MHz
            #[inline(always)]
            pub fn i2c_freq(&self) -> I2C_FREQ_R {
                I2C_FREQ_R::new((self.bits & 0x3f) as u8)
            }
            ///Bit 8 - RW, Error interrupt enable
            #[inline(always)]
            pub fn i2c_iterren(&self) -> I2C_ITERREN_R {
                I2C_ITERREN_R::new(((self.bits >> 8) & 1) != 0)
            }
            ///Bit 9 - RW, Event interrupt enable
            #[inline(always)]
            pub fn i2c_itevten(&self) -> I2C_ITEVTEN_R {
                I2C_ITEVTEN_R::new(((self.bits >> 9) & 1) != 0)
            }
            ///Bit 10 - RW, Buffer interrupt enable
            #[inline(always)]
            pub fn i2c_itbufen(&self) -> I2C_ITBUFEN_R {
                I2C_ITBUFEN_R::new(((self.bits >> 10) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:5 - RW, Peripheral clock frequency, The minimum allowed frequency is 2 MHz,the maximum frequency is 36 MHz
            #[inline(always)]
            #[must_use]
            pub fn i2c_freq(&mut self) -> I2C_FREQ_W<0> {
                I2C_FREQ_W::new(self)
            }
            ///Bit 8 - RW, Error interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn i2c_iterren(&mut self) -> I2C_ITERREN_W<8> {
                I2C_ITERREN_W::new(self)
            }
            ///Bit 9 - RW, Event interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn i2c_itevten(&mut self) -> I2C_ITEVTEN_W<9> {
                I2C_ITEVTEN_W::new(self)
            }
            ///Bit 10 - RW, Buffer interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn i2c_itbufen(&mut self) -> I2C_ITBUFEN_W<10> {
                I2C_ITBUFEN_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, I2C control 2
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [i2c_ctrl2](index.html) module
        pub struct I2C_CTRL2_SPEC;
        impl crate::RegisterSpec for I2C_CTRL2_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [i2c_ctrl2::R](R) reader structure
        impl crate::Readable for I2C_CTRL2_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [i2c_ctrl2::W](W) writer structure
        impl crate::Writable for I2C_CTRL2_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets I2C_CTRL2 to value 0
        impl crate::Resettable for I2C_CTRL2_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///I2C_OADDR1 (rw) register accessor: an alias for `Reg<I2C_OADDR1_SPEC>`
    pub type I2C_OADDR1 = crate::Reg<i2c_oaddr1::I2C_OADDR1_SPEC>;
    ///RW, I2C own address register 1
    pub mod i2c_oaddr1 {
        ///Register `I2C_OADDR1` reader
        pub struct R(crate::R<I2C_OADDR1_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<I2C_OADDR1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<I2C_OADDR1_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<I2C_OADDR1_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `I2C_OADDR1` writer
        pub struct W(crate::W<I2C_OADDR1_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<I2C_OADDR1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<I2C_OADDR1_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<I2C_OADDR1_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `I2C_ADD0` reader - RW, bit0 of address in 10-bit addressing mode
        pub type I2C_ADD0_R = crate::BitReader<bool>;
        ///Field `I2C_ADD0` writer - RW, bit0 of address in 10-bit addressing mode
        pub type I2C_ADD0_W<'a, const O: u8> = crate::BitWriter<'a, u16, I2C_OADDR1_SPEC, bool, O>;
        ///Field `I2C_ADD7_1` reader - RW, bit\[7:1\]
        ///of address
        pub type I2C_ADD7_1_R = crate::FieldReader<u8, u8>;
        ///Field `I2C_ADD7_1` writer - RW, bit\[7:1\]
        ///of address
        pub type I2C_ADD7_1_W<'a, const O: u8> =
            crate::FieldWriter<'a, u16, I2C_OADDR1_SPEC, u8, u8, 7, O>;
        ///Field `I2C_ADD9_8` reader - RW, bit\[9:8\]
        ///of address in 10-bit addressing mode
        pub type I2C_ADD9_8_R = crate::FieldReader<u8, u8>;
        ///Field `I2C_ADD9_8` writer - RW, bit\[9:8\]
        ///of address in 10-bit addressing mode
        pub type I2C_ADD9_8_W<'a, const O: u8> =
            crate::FieldWriter<'a, u16, I2C_OADDR1_SPEC, u8, u8, 2, O>;
        ///Field `I2C_MUST1` reader - RW, Should always be kept at 1
        pub type I2C_MUST1_R = crate::BitReader<bool>;
        ///Field `I2C_MUST1` writer - RW, Should always be kept at 1
        pub type I2C_MUST1_W<'a, const O: u8> = crate::BitWriter<'a, u16, I2C_OADDR1_SPEC, bool, O>;
        ///Field `I2C_ADDMODE` reader - RW, Addressing mode (slave mode): 0=7-bit slave address, 1=10-bit slave address
        pub type I2C_ADDMODE_R = crate::BitReader<bool>;
        ///Field `I2C_ADDMODE` writer - RW, Addressing mode (slave mode): 0=7-bit slave address, 1=10-bit slave address
        pub type I2C_ADDMODE_W<'a, const O: u8> =
            crate::BitWriter<'a, u16, I2C_OADDR1_SPEC, bool, O>;
        impl R {
            ///Bit 0 - RW, bit0 of address in 10-bit addressing mode
            #[inline(always)]
            pub fn i2c_add0(&self) -> I2C_ADD0_R {
                I2C_ADD0_R::new((self.bits & 1) != 0)
            }
            ///Bits 1:7 - RW, bit\[7:1\]
            ///of address
            #[inline(always)]
            pub fn i2c_add7_1(&self) -> I2C_ADD7_1_R {
                I2C_ADD7_1_R::new(((self.bits >> 1) & 0x7f) as u8)
            }
            ///Bits 8:9 - RW, bit\[9:8\]
            ///of address in 10-bit addressing mode
            #[inline(always)]
            pub fn i2c_add9_8(&self) -> I2C_ADD9_8_R {
                I2C_ADD9_8_R::new(((self.bits >> 8) & 3) as u8)
            }
            ///Bit 14 - RW, Should always be kept at 1
            #[inline(always)]
            pub fn i2c_must1(&self) -> I2C_MUST1_R {
                I2C_MUST1_R::new(((self.bits >> 14) & 1) != 0)
            }
            ///Bit 15 - RW, Addressing mode (slave mode): 0=7-bit slave address, 1=10-bit slave address
            #[inline(always)]
            pub fn i2c_addmode(&self) -> I2C_ADDMODE_R {
                I2C_ADDMODE_R::new(((self.bits >> 15) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RW, bit0 of address in 10-bit addressing mode
            #[inline(always)]
            #[must_use]
            pub fn i2c_add0(&mut self) -> I2C_ADD0_W<0> {
                I2C_ADD0_W::new(self)
            }
            ///Bits 1:7 - RW, bit\[7:1\]
            ///of address
            #[inline(always)]
            #[must_use]
            pub fn i2c_add7_1(&mut self) -> I2C_ADD7_1_W<1> {
                I2C_ADD7_1_W::new(self)
            }
            ///Bits 8:9 - RW, bit\[9:8\]
            ///of address in 10-bit addressing mode
            #[inline(always)]
            #[must_use]
            pub fn i2c_add9_8(&mut self) -> I2C_ADD9_8_W<8> {
                I2C_ADD9_8_W::new(self)
            }
            ///Bit 14 - RW, Should always be kept at 1
            #[inline(always)]
            #[must_use]
            pub fn i2c_must1(&mut self) -> I2C_MUST1_W<14> {
                I2C_MUST1_W::new(self)
            }
            ///Bit 15 - RW, Addressing mode (slave mode): 0=7-bit slave address, 1=10-bit slave address
            #[inline(always)]
            #[must_use]
            pub fn i2c_addmode(&mut self) -> I2C_ADDMODE_W<15> {
                I2C_ADDMODE_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, I2C own address register 1
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [i2c_oaddr1](index.html) module
        pub struct I2C_OADDR1_SPEC;
        impl crate::RegisterSpec for I2C_OADDR1_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [i2c_oaddr1::R](R) reader structure
        impl crate::Readable for I2C_OADDR1_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [i2c_oaddr1::W](W) writer structure
        impl crate::Writable for I2C_OADDR1_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets I2C_OADDR1 to value 0
        impl crate::Resettable for I2C_OADDR1_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///I2C_OADDR2 (rw) register accessor: an alias for `Reg<I2C_OADDR2_SPEC>`
    pub type I2C_OADDR2 = crate::Reg<i2c_oaddr2::I2C_OADDR2_SPEC>;
    ///RW, I2C own address register 2
    pub mod i2c_oaddr2 {
        ///Register `I2C_OADDR2` reader
        pub struct R(crate::R<I2C_OADDR2_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<I2C_OADDR2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<I2C_OADDR2_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<I2C_OADDR2_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `I2C_OADDR2` writer
        pub struct W(crate::W<I2C_OADDR2_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<I2C_OADDR2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<I2C_OADDR2_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<I2C_OADDR2_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `I2C_ENDUAL` reader - RW, Dual addressing mode enable
        pub type I2C_ENDUAL_R = crate::BitReader<bool>;
        ///Field `I2C_ENDUAL` writer - RW, Dual addressing mode enable
        pub type I2C_ENDUAL_W<'a, const O: u8> =
            crate::BitWriter<'a, u16, I2C_OADDR2_SPEC, bool, O>;
        ///Field `I2C_ADD2` reader - RW, bit\[7:1\]
        ///of address2
        pub type I2C_ADD2_R = crate::FieldReader<u8, u8>;
        ///Field `I2C_ADD2` writer - RW, bit\[7:1\]
        ///of address2
        pub type I2C_ADD2_W<'a, const O: u8> =
            crate::FieldWriter<'a, u16, I2C_OADDR2_SPEC, u8, u8, 7, O>;
        impl R {
            ///Bit 0 - RW, Dual addressing mode enable
            #[inline(always)]
            pub fn i2c_endual(&self) -> I2C_ENDUAL_R {
                I2C_ENDUAL_R::new((self.bits & 1) != 0)
            }
            ///Bits 1:7 - RW, bit\[7:1\]
            ///of address2
            #[inline(always)]
            pub fn i2c_add2(&self) -> I2C_ADD2_R {
                I2C_ADD2_R::new(((self.bits >> 1) & 0x7f) as u8)
            }
        }
        impl W {
            ///Bit 0 - RW, Dual addressing mode enable
            #[inline(always)]
            #[must_use]
            pub fn i2c_endual(&mut self) -> I2C_ENDUAL_W<0> {
                I2C_ENDUAL_W::new(self)
            }
            ///Bits 1:7 - RW, bit\[7:1\]
            ///of address2
            #[inline(always)]
            #[must_use]
            pub fn i2c_add2(&mut self) -> I2C_ADD2_W<1> {
                I2C_ADD2_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, I2C own address register 2
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [i2c_oaddr2](index.html) module
        pub struct I2C_OADDR2_SPEC;
        impl crate::RegisterSpec for I2C_OADDR2_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [i2c_oaddr2::R](R) reader structure
        impl crate::Readable for I2C_OADDR2_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [i2c_oaddr2::W](W) writer structure
        impl crate::Writable for I2C_OADDR2_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets I2C_OADDR2 to value 0
        impl crate::Resettable for I2C_OADDR2_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///I2C_DATAR (rw) register accessor: an alias for `Reg<I2C_DATAR_SPEC>`
    pub type I2C_DATAR = crate::Reg<i2c_datar::I2C_DATAR_SPEC>;
    ///RW, I2C data register
    pub mod i2c_datar {
        ///Register `I2C_DATAR` reader
        pub struct R(crate::R<I2C_DATAR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<I2C_DATAR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<I2C_DATAR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<I2C_DATAR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `I2C_DATAR` writer
        pub struct W(crate::W<I2C_DATAR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<I2C_DATAR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<I2C_DATAR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<I2C_DATAR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `I2C_DATAR` reader - RW, I2C data register
        pub type I2C_DATAR_R = crate::FieldReader<u8, u8>;
        ///Field `I2C_DATAR` writer - RW, I2C data register
        pub type I2C_DATAR_W<'a, const O: u8> =
            crate::FieldWriter<'a, u16, I2C_DATAR_SPEC, u8, u8, 8, O>;
        impl R {
            ///Bits 0:7 - RW, I2C data register
            #[inline(always)]
            pub fn i2c_datar(&self) -> I2C_DATAR_R {
                I2C_DATAR_R::new((self.bits & 0xff) as u8)
            }
        }
        impl W {
            ///Bits 0:7 - RW, I2C data register
            #[inline(always)]
            #[must_use]
            pub fn i2c_datar(&mut self) -> I2C_DATAR_W<0> {
                I2C_DATAR_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, I2C data register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [i2c_datar](index.html) module
        pub struct I2C_DATAR_SPEC;
        impl crate::RegisterSpec for I2C_DATAR_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [i2c_datar::R](R) reader structure
        impl crate::Readable for I2C_DATAR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [i2c_datar::W](W) writer structure
        impl crate::Writable for I2C_DATAR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets I2C_DATAR to value 0
        impl crate::Resettable for I2C_DATAR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///I2C_STAR1 (r) register accessor: an alias for `Reg<I2C_STAR1_SPEC>`
    pub type I2C_STAR1 = crate::Reg<i2c_star1::I2C_STAR1_SPEC>;
    ///R0, I2C stauts register 1
    pub mod i2c_star1 {
        ///Register `I2C_STAR1` reader
        pub struct R(crate::R<I2C_STAR1_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<I2C_STAR1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<I2C_STAR1_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<I2C_STAR1_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `I2C_SB` reader - RW0, Start bit flag (Master mode)
        pub type I2C_SB_R = crate::BitReader<bool>;
        ///Field `I2C_ADDR` reader - RW0, Address sent (master mode)/matched (slave mode) flag
        pub type I2C_ADDR_R = crate::BitReader<bool>;
        ///Field `I2C_BTF` reader - RO, Byte transfer finished flag
        pub type I2C_BTF_R = crate::BitReader<bool>;
        ///Field `I2C_ADD10` reader - RO, 10-bit header sent flag (Master mode)
        pub type I2C_ADD10_R = crate::BitReader<bool>;
        ///Field `I2C_STOPF` reader - RO, Stop detection flag (slave mode)
        pub type I2C_STOPF_R = crate::BitReader<bool>;
        ///Field `I2C_RxNE` reader - RO, Data register not empty flag (receivers)
        pub type I2C_RX_NE_R = crate::BitReader<bool>;
        ///Field `I2C_TxE` reader - RO, Data register empty flag (transmitters)
        pub type I2C_TX_E_R = crate::BitReader<bool>;
        ///Field `I2C_BERR` reader - RW0, Bus error flag
        pub type I2C_BERR_R = crate::BitReader<bool>;
        ///Field `I2C_ARLO` reader - RW0, Arbitration lost flag (master mode)
        pub type I2C_ARLO_R = crate::BitReader<bool>;
        ///Field `I2C_AF` reader - RW0, Acknowledge failure flag
        pub type I2C_AF_R = crate::BitReader<bool>;
        ///Field `I2C_OVR` reader - RW0, Overrun/Underrun flag
        pub type I2C_OVR_R = crate::BitReader<bool>;
        ///Field `I2C_PECERR` reader - RW0, PEC Error flag in reception
        pub type I2C_PECERR_R = crate::BitReader<bool>;
        ///Field `I2C_TIMEOUT` reader - RW0, Timeout or Tlow error flag
        pub type I2C_TIMEOUT_R = crate::BitReader<bool>;
        ///Field `I2C_SMBALERT` reader - RW0, SMBus alert flag
        pub type I2C_SMBALERT_R = crate::BitReader<bool>;
        impl R {
            ///Bit 0 - RW0, Start bit flag (Master mode)
            #[inline(always)]
            pub fn i2c_sb(&self) -> I2C_SB_R {
                I2C_SB_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RW0, Address sent (master mode)/matched (slave mode) flag
            #[inline(always)]
            pub fn i2c_addr(&self) -> I2C_ADDR_R {
                I2C_ADDR_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RO, Byte transfer finished flag
            #[inline(always)]
            pub fn i2c_btf(&self) -> I2C_BTF_R {
                I2C_BTF_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RO, 10-bit header sent flag (Master mode)
            #[inline(always)]
            pub fn i2c_add10(&self) -> I2C_ADD10_R {
                I2C_ADD10_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RO, Stop detection flag (slave mode)
            #[inline(always)]
            pub fn i2c_stopf(&self) -> I2C_STOPF_R {
                I2C_STOPF_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 6 - RO, Data register not empty flag (receivers)
            #[inline(always)]
            pub fn i2c_rx_ne(&self) -> I2C_RX_NE_R {
                I2C_RX_NE_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - RO, Data register empty flag (transmitters)
            #[inline(always)]
            pub fn i2c_tx_e(&self) -> I2C_TX_E_R {
                I2C_TX_E_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bit 8 - RW0, Bus error flag
            #[inline(always)]
            pub fn i2c_berr(&self) -> I2C_BERR_R {
                I2C_BERR_R::new(((self.bits >> 8) & 1) != 0)
            }
            ///Bit 9 - RW0, Arbitration lost flag (master mode)
            #[inline(always)]
            pub fn i2c_arlo(&self) -> I2C_ARLO_R {
                I2C_ARLO_R::new(((self.bits >> 9) & 1) != 0)
            }
            ///Bit 10 - RW0, Acknowledge failure flag
            #[inline(always)]
            pub fn i2c_af(&self) -> I2C_AF_R {
                I2C_AF_R::new(((self.bits >> 10) & 1) != 0)
            }
            ///Bit 11 - RW0, Overrun/Underrun flag
            #[inline(always)]
            pub fn i2c_ovr(&self) -> I2C_OVR_R {
                I2C_OVR_R::new(((self.bits >> 11) & 1) != 0)
            }
            ///Bit 12 - RW0, PEC Error flag in reception
            #[inline(always)]
            pub fn i2c_pecerr(&self) -> I2C_PECERR_R {
                I2C_PECERR_R::new(((self.bits >> 12) & 1) != 0)
            }
            ///Bit 13 - RW0, Timeout or Tlow error flag
            #[inline(always)]
            pub fn i2c_timeout(&self) -> I2C_TIMEOUT_R {
                I2C_TIMEOUT_R::new(((self.bits >> 13) & 1) != 0)
            }
            ///Bit 15 - RW0, SMBus alert flag
            #[inline(always)]
            pub fn i2c_smbalert(&self) -> I2C_SMBALERT_R {
                I2C_SMBALERT_R::new(((self.bits >> 15) & 1) != 0)
            }
        }
        ///R0, I2C stauts register 1
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [i2c_star1](index.html) module
        pub struct I2C_STAR1_SPEC;
        impl crate::RegisterSpec for I2C_STAR1_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [i2c_star1::R](R) reader structure
        impl crate::Readable for I2C_STAR1_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets I2C_STAR1 to value 0
        impl crate::Resettable for I2C_STAR1_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///I2C_STAR2 (r) register accessor: an alias for `Reg<I2C_STAR2_SPEC>`
    pub type I2C_STAR2 = crate::Reg<i2c_star2::I2C_STAR2_SPEC>;
    ///R0, I2C status register 2
    pub mod i2c_star2 {
        ///Register `I2C_STAR2` reader
        pub struct R(crate::R<I2C_STAR2_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<I2C_STAR2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<I2C_STAR2_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<I2C_STAR2_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `I2C_MSL` reader - RO, Mode statu: 0=Slave mode, 1=Master mode
        pub type I2C_MSL_R = crate::BitReader<bool>;
        ///Field `I2C_BUSY` reader - RO, Bus busy flag
        pub type I2C_BUSY_R = crate::BitReader<bool>;
        ///Field `I2C_TRA` reader - RO, Trans flag: 0=data bytes received, 1=data bytes transmitted
        pub type I2C_TRA_R = crate::BitReader<bool>;
        ///Field `I2C_GENCALL` reader - RO, General call address (Slave mode) received flag
        pub type I2C_GENCALL_R = crate::BitReader<bool>;
        ///Field `I2C_SMBDEFAULT` reader - RO, SMBus device default address (Slave mode) received flag
        pub type I2C_SMBDEFAULT_R = crate::BitReader<bool>;
        ///Field `I2C_SMBHOST` reader - RO, SMBus host header (Slave mode) received flag
        pub type I2C_SMBHOST_R = crate::BitReader<bool>;
        ///Field `I2C_DUALF` reader - RO, Dual flag (Slave mode): 0=Received address matched with OAR1, 1=Received address matched with OAR2
        pub type I2C_DUALF_R = crate::BitReader<bool>;
        ///Field `I2C_PECX` reader - RO, Packet error checking register
        pub type I2C_PECX_R = crate::FieldReader<u8, u8>;
        impl R {
            ///Bit 0 - RO, Mode statu: 0=Slave mode, 1=Master mode
            #[inline(always)]
            pub fn i2c_msl(&self) -> I2C_MSL_R {
                I2C_MSL_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RO, Bus busy flag
            #[inline(always)]
            pub fn i2c_busy(&self) -> I2C_BUSY_R {
                I2C_BUSY_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RO, Trans flag: 0=data bytes received, 1=data bytes transmitted
            #[inline(always)]
            pub fn i2c_tra(&self) -> I2C_TRA_R {
                I2C_TRA_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 4 - RO, General call address (Slave mode) received flag
            #[inline(always)]
            pub fn i2c_gencall(&self) -> I2C_GENCALL_R {
                I2C_GENCALL_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - RO, SMBus device default address (Slave mode) received flag
            #[inline(always)]
            pub fn i2c_smbdefault(&self) -> I2C_SMBDEFAULT_R {
                I2C_SMBDEFAULT_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - RO, SMBus host header (Slave mode) received flag
            #[inline(always)]
            pub fn i2c_smbhost(&self) -> I2C_SMBHOST_R {
                I2C_SMBHOST_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - RO, Dual flag (Slave mode): 0=Received address matched with OAR1, 1=Received address matched with OAR2
            #[inline(always)]
            pub fn i2c_dualf(&self) -> I2C_DUALF_R {
                I2C_DUALF_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bits 8:15 - RO, Packet error checking register
            #[inline(always)]
            pub fn i2c_pecx(&self) -> I2C_PECX_R {
                I2C_PECX_R::new(((self.bits >> 8) & 0xff) as u8)
            }
        }
        ///R0, I2C status register 2
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [i2c_star2](index.html) module
        pub struct I2C_STAR2_SPEC;
        impl crate::RegisterSpec for I2C_STAR2_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [i2c_star2::R](R) reader structure
        impl crate::Readable for I2C_STAR2_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets I2C_STAR2 to value 0
        impl crate::Resettable for I2C_STAR2_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///I2C_PEC (r) register accessor: an alias for `Reg<I2C_PEC_SPEC>`
    pub type I2C_PEC = crate::Reg<i2c_pec::I2C_PEC_SPEC>;
    ///R0, I2C Packet error checking register
    pub mod i2c_pec {
        ///Register `I2C_PEC` reader
        pub struct R(crate::R<I2C_PEC_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<I2C_PEC_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<I2C_PEC_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<I2C_PEC_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `SPI0_FIFO_COUNT` reader - RO, SPI0 FIFO count status
        pub type SPI0_FIFO_COUNT_R = crate::FieldReader<u8, u8>;
        impl R {
            ///Bits 0:7 - RO, SPI0 FIFO count status
            #[inline(always)]
            pub fn spi0_fifo_count(&self) -> SPI0_FIFO_COUNT_R {
                SPI0_FIFO_COUNT_R::new(self.bits)
            }
        }
        ///R0, I2C Packet error checking register
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [i2c_pec](index.html) module
        pub struct I2C_PEC_SPEC;
        impl crate::RegisterSpec for I2C_PEC_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [i2c_pec::R](R) reader structure
        impl crate::Readable for I2C_PEC_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets I2C_PEC to value 0
        impl crate::Resettable for I2C_PEC_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///I2C_CKCFGR (rw) register accessor: an alias for `Reg<I2C_CKCFGR_SPEC>`
    pub type I2C_CKCFGR = crate::Reg<i2c_ckcfgr::I2C_CKCFGR_SPEC>;
    ///RW, I2C clock control register
    pub mod i2c_ckcfgr {
        ///Register `I2C_CKCFGR` reader
        pub struct R(crate::R<I2C_CKCFGR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<I2C_CKCFGR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<I2C_CKCFGR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<I2C_CKCFGR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `I2C_CKCFGR` writer
        pub struct W(crate::W<I2C_CKCFGR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<I2C_CKCFGR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<I2C_CKCFGR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<I2C_CKCFGR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `I2C_CCR` reader - RW, Controls the SCL clock in Fm/Sm mode (Master mode)
        pub type I2C_CCR_R = crate::FieldReader<u16, u16>;
        ///Field `I2C_CCR` writer - RW, Controls the SCL clock in Fm/Sm mode (Master mode)
        pub type I2C_CCR_W<'a, const O: u8> =
            crate::FieldWriter<'a, u16, I2C_CKCFGR_SPEC, u16, u16, 12, O>;
        ///Field `I2C_DUTY` reader - RW, Fm mode duty cycle: 0=L/H=2, 1=L/H=16/9
        pub type I2C_DUTY_R = crate::BitReader<bool>;
        ///Field `I2C_DUTY` writer - RW, Fm mode duty cycle: 0=L/H=2, 1=L/H=16/9
        pub type I2C_DUTY_W<'a, const O: u8> = crate::BitWriter<'a, u16, I2C_CKCFGR_SPEC, bool, O>;
        ///Field `I2C_F_S` reader - RW, I2C master mode selection: 0=standard mode, 1=fast mode
        pub type I2C_F_S_R = crate::BitReader<bool>;
        ///Field `I2C_F_S` writer - RW, I2C master mode selection: 0=standard mode, 1=fast mode
        pub type I2C_F_S_W<'a, const O: u8> = crate::BitWriter<'a, u16, I2C_CKCFGR_SPEC, bool, O>;
        impl R {
            ///Bits 0:11 - RW, Controls the SCL clock in Fm/Sm mode (Master mode)
            #[inline(always)]
            pub fn i2c_ccr(&self) -> I2C_CCR_R {
                I2C_CCR_R::new(self.bits & 0x0fff)
            }
            ///Bit 14 - RW, Fm mode duty cycle: 0=L/H=2, 1=L/H=16/9
            #[inline(always)]
            pub fn i2c_duty(&self) -> I2C_DUTY_R {
                I2C_DUTY_R::new(((self.bits >> 14) & 1) != 0)
            }
            ///Bit 15 - RW, I2C master mode selection: 0=standard mode, 1=fast mode
            #[inline(always)]
            pub fn i2c_f_s(&self) -> I2C_F_S_R {
                I2C_F_S_R::new(((self.bits >> 15) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:11 - RW, Controls the SCL clock in Fm/Sm mode (Master mode)
            #[inline(always)]
            #[must_use]
            pub fn i2c_ccr(&mut self) -> I2C_CCR_W<0> {
                I2C_CCR_W::new(self)
            }
            ///Bit 14 - RW, Fm mode duty cycle: 0=L/H=2, 1=L/H=16/9
            #[inline(always)]
            #[must_use]
            pub fn i2c_duty(&mut self) -> I2C_DUTY_W<14> {
                I2C_DUTY_W::new(self)
            }
            ///Bit 15 - RW, I2C master mode selection: 0=standard mode, 1=fast mode
            #[inline(always)]
            #[must_use]
            pub fn i2c_f_s(&mut self) -> I2C_F_S_W<15> {
                I2C_F_S_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, I2C clock control register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [i2c_ckcfgr](index.html) module
        pub struct I2C_CKCFGR_SPEC;
        impl crate::RegisterSpec for I2C_CKCFGR_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [i2c_ckcfgr::R](R) reader structure
        impl crate::Readable for I2C_CKCFGR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [i2c_ckcfgr::W](W) writer structure
        impl crate::Writable for I2C_CKCFGR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets I2C_CKCFGR to value 0
        impl crate::Resettable for I2C_CKCFGR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///I2C_RTR (rw) register accessor: an alias for `Reg<I2C_RTR_SPEC>`
    pub type I2C_RTR = crate::Reg<i2c_rtr::I2C_RTR_SPEC>;
    ///RW, I2C trise register
    pub mod i2c_rtr {
        ///Register `I2C_RTR` reader
        pub struct R(crate::R<I2C_RTR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<I2C_RTR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<I2C_RTR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<I2C_RTR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `I2C_RTR` writer
        pub struct W(crate::W<I2C_RTR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<I2C_RTR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<I2C_RTR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<I2C_RTR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `I2C_TRISE` reader - RW, Maximum rise time in Fm/Sm mode (Master mode)
        pub type I2C_TRISE_R = crate::FieldReader<u8, u8>;
        ///Field `I2C_TRISE` writer - RW, Maximum rise time in Fm/Sm mode (Master mode)
        pub type I2C_TRISE_W<'a, const O: u8> =
            crate::FieldWriter<'a, u16, I2C_RTR_SPEC, u8, u8, 6, O>;
        impl R {
            ///Bits 0:5 - RW, Maximum rise time in Fm/Sm mode (Master mode)
            #[inline(always)]
            pub fn i2c_trise(&self) -> I2C_TRISE_R {
                I2C_TRISE_R::new((self.bits & 0x3f) as u8)
            }
        }
        impl W {
            ///Bits 0:5 - RW, Maximum rise time in Fm/Sm mode (Master mode)
            #[inline(always)]
            #[must_use]
            pub fn i2c_trise(&mut self) -> I2C_TRISE_W<0> {
                I2C_TRISE_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, I2C trise register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [i2c_rtr](index.html) module
        pub struct I2C_RTR_SPEC;
        impl crate::RegisterSpec for I2C_RTR_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [i2c_rtr::R](R) reader structure
        impl crate::Readable for I2C_RTR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [i2c_rtr::W](W) writer structure
        impl crate::Writable for I2C_RTR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets I2C_RTR to value 0x02
        impl crate::Resettable for I2C_RTR_SPEC {
            const RESET_VALUE: Self::Ux = 0x02;
        }
    }
}
///PWMx register
pub struct PWMX {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for PWMX {}
impl PWMX {
    ///Pointer to the register block
    pub const PTR: *const pwmx::RegisterBlock = 0x4000_5000 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const pwmx::RegisterBlock {
        Self::PTR
    }
}
impl Deref for PWMX {
    type Target = pwmx::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for PWMX {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("PWMX").finish()
    }
}
///PWMx register
pub mod pwmx {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        ///0x00 - RW, PWM output enable control
        pub pwm_out_en: PWM_OUT_EN,
        ///0x01 - RW, PWM output polarity control
        pub pwm_polar: PWM_POLAR,
        ///0x02 - RW, PWM configuration
        pub pwm_config: PWM_CONFIG,
        ///0x03 - RW, PWM clock divisor
        pub pwm_clock_div: PWM_CLOCK_DIV,
        ///0x04 - RW, PWM4 data holding
        pub pwm4_data: PWM4_DATA,
        ///0x05 - RW, PWM5 data holding
        pub pwm5_data: PWM5_DATA,
        ///0x06 - RW, PWM6 data holding
        pub pwm6_data: PWM6_DATA,
        ///0x07 - RW, PWM7 data holding
        pub pwm7_data: PWM7_DATA,
        ///0x08 - RW, PWM8 data holding
        pub pwm8_data: PWM8_DATA,
        ///0x09 - RW, PWM9 data holding
        pub pwm9_data: PWM9_DATA,
        ///0x0a - RW, PWM10 data holding
        pub pwm10_data: PWM10_DATA,
        ///0x0b - RW, PWM11 data holding
        pub pwm11_data: PWM11_DATA,
        ///0x0c - RW, PWM interrupt control
        pub pwm_int_ctrl: PWM_INT_CTRL,
    }
    ///PWM_OUT_EN (rw) register accessor: an alias for `Reg<PWM_OUT_EN_SPEC>`
    pub type PWM_OUT_EN = crate::Reg<pwm_out_en::PWM_OUT_EN_SPEC>;
    ///RW, PWM output enable control
    pub mod pwm_out_en {
        ///Register `PWM_OUT_EN` reader
        pub struct R(crate::R<PWM_OUT_EN_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PWM_OUT_EN_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<PWM_OUT_EN_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<PWM_OUT_EN_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `PWM_OUT_EN` writer
        pub struct W(crate::W<PWM_OUT_EN_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PWM_OUT_EN_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<PWM_OUT_EN_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<PWM_OUT_EN_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `PWM4_OUT_EN` reader - RW, PWM4 output enable
        pub type PWM4_OUT_EN_R = crate::BitReader<bool>;
        ///Field `PWM4_OUT_EN` writer - RW, PWM4 output enable
        pub type PWM4_OUT_EN_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, PWM_OUT_EN_SPEC, bool, O>;
        ///Field `PWM5_OUT_EN` reader - RW, PWM5 output enable
        pub type PWM5_OUT_EN_R = crate::BitReader<bool>;
        ///Field `PWM5_OUT_EN` writer - RW, PWM5 output enable
        pub type PWM5_OUT_EN_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, PWM_OUT_EN_SPEC, bool, O>;
        ///Field `PWM6_OUT_EN` reader - RW, PWM6 output enable
        pub type PWM6_OUT_EN_R = crate::BitReader<bool>;
        ///Field `PWM6_OUT_EN` writer - RW, PWM6 output enable
        pub type PWM6_OUT_EN_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, PWM_OUT_EN_SPEC, bool, O>;
        ///Field `PWM7_OUT_EN` reader - RW, PWM7 output enable
        pub type PWM7_OUT_EN_R = crate::BitReader<bool>;
        ///Field `PWM7_OUT_EN` writer - RW, PWM7 output enable
        pub type PWM7_OUT_EN_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, PWM_OUT_EN_SPEC, bool, O>;
        ///Field `PWM8_OUT_EN` reader - RW, PWM8 output enable
        pub type PWM8_OUT_EN_R = crate::BitReader<bool>;
        ///Field `PWM8_OUT_EN` writer - RW, PWM8 output enable
        pub type PWM8_OUT_EN_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, PWM_OUT_EN_SPEC, bool, O>;
        ///Field `PWM9_OUT_EN` reader - RW, PWM9 output enable
        pub type PWM9_OUT_EN_R = crate::BitReader<bool>;
        ///Field `PWM9_OUT_EN` writer - RW, PWM9 output enable
        pub type PWM9_OUT_EN_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, PWM_OUT_EN_SPEC, bool, O>;
        ///Field `PWM10_OUT_EN` reader - RW, PWM10 output enable
        pub type PWM10_OUT_EN_R = crate::BitReader<bool>;
        ///Field `PWM10_OUT_EN` writer - RW, PWM10 output enable
        pub type PWM10_OUT_EN_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, PWM_OUT_EN_SPEC, bool, O>;
        ///Field `PWM11_OUT_EN` reader - RW, PWM11 output enable
        pub type PWM11_OUT_EN_R = crate::BitReader<bool>;
        ///Field `PWM11_OUT_EN` writer - RW, PWM11 output enable
        pub type PWM11_OUT_EN_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, PWM_OUT_EN_SPEC, bool, O>;
        impl R {
            ///Bit 0 - RW, PWM4 output enable
            #[inline(always)]
            pub fn pwm4_out_en(&self) -> PWM4_OUT_EN_R {
                PWM4_OUT_EN_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RW, PWM5 output enable
            #[inline(always)]
            pub fn pwm5_out_en(&self) -> PWM5_OUT_EN_R {
                PWM5_OUT_EN_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RW, PWM6 output enable
            #[inline(always)]
            pub fn pwm6_out_en(&self) -> PWM6_OUT_EN_R {
                PWM6_OUT_EN_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RW, PWM7 output enable
            #[inline(always)]
            pub fn pwm7_out_en(&self) -> PWM7_OUT_EN_R {
                PWM7_OUT_EN_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RW, PWM8 output enable
            #[inline(always)]
            pub fn pwm8_out_en(&self) -> PWM8_OUT_EN_R {
                PWM8_OUT_EN_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - RW, PWM9 output enable
            #[inline(always)]
            pub fn pwm9_out_en(&self) -> PWM9_OUT_EN_R {
                PWM9_OUT_EN_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - RW, PWM10 output enable
            #[inline(always)]
            pub fn pwm10_out_en(&self) -> PWM10_OUT_EN_R {
                PWM10_OUT_EN_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - RW, PWM11 output enable
            #[inline(always)]
            pub fn pwm11_out_en(&self) -> PWM11_OUT_EN_R {
                PWM11_OUT_EN_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RW, PWM4 output enable
            #[inline(always)]
            #[must_use]
            pub fn pwm4_out_en(&mut self) -> PWM4_OUT_EN_W<0> {
                PWM4_OUT_EN_W::new(self)
            }
            ///Bit 1 - RW, PWM5 output enable
            #[inline(always)]
            #[must_use]
            pub fn pwm5_out_en(&mut self) -> PWM5_OUT_EN_W<1> {
                PWM5_OUT_EN_W::new(self)
            }
            ///Bit 2 - RW, PWM6 output enable
            #[inline(always)]
            #[must_use]
            pub fn pwm6_out_en(&mut self) -> PWM6_OUT_EN_W<2> {
                PWM6_OUT_EN_W::new(self)
            }
            ///Bit 3 - RW, PWM7 output enable
            #[inline(always)]
            #[must_use]
            pub fn pwm7_out_en(&mut self) -> PWM7_OUT_EN_W<3> {
                PWM7_OUT_EN_W::new(self)
            }
            ///Bit 4 - RW, PWM8 output enable
            #[inline(always)]
            #[must_use]
            pub fn pwm8_out_en(&mut self) -> PWM8_OUT_EN_W<4> {
                PWM8_OUT_EN_W::new(self)
            }
            ///Bit 5 - RW, PWM9 output enable
            #[inline(always)]
            #[must_use]
            pub fn pwm9_out_en(&mut self) -> PWM9_OUT_EN_W<5> {
                PWM9_OUT_EN_W::new(self)
            }
            ///Bit 6 - RW, PWM10 output enable
            #[inline(always)]
            #[must_use]
            pub fn pwm10_out_en(&mut self) -> PWM10_OUT_EN_W<6> {
                PWM10_OUT_EN_W::new(self)
            }
            ///Bit 7 - RW, PWM11 output enable
            #[inline(always)]
            #[must_use]
            pub fn pwm11_out_en(&mut self) -> PWM11_OUT_EN_W<7> {
                PWM11_OUT_EN_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, PWM output enable control
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [pwm_out_en](index.html) module
        pub struct PWM_OUT_EN_SPEC;
        impl crate::RegisterSpec for PWM_OUT_EN_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [pwm_out_en::R](R) reader structure
        impl crate::Readable for PWM_OUT_EN_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [pwm_out_en::W](W) writer structure
        impl crate::Writable for PWM_OUT_EN_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets PWM_OUT_EN to value 0
        impl crate::Resettable for PWM_OUT_EN_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///PWM_POLAR (rw) register accessor: an alias for `Reg<PWM_POLAR_SPEC>`
    pub type PWM_POLAR = crate::Reg<pwm_polar::PWM_POLAR_SPEC>;
    ///RW, PWM output polarity control
    pub mod pwm_polar {
        ///Register `PWM_POLAR` reader
        pub struct R(crate::R<PWM_POLAR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PWM_POLAR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<PWM_POLAR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<PWM_POLAR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `PWM_POLAR` writer
        pub struct W(crate::W<PWM_POLAR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PWM_POLAR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<PWM_POLAR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<PWM_POLAR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `PWM4_POLAR` reader - RW, PWM4 output polarity: 0=default low and high action, 1=default high and low action
        pub type PWM4_POLAR_R = crate::BitReader<bool>;
        ///Field `PWM4_POLAR` writer - RW, PWM4 output polarity: 0=default low and high action, 1=default high and low action
        pub type PWM4_POLAR_W<'a, const O: u8> = crate::BitWriter<'a, u8, PWM_POLAR_SPEC, bool, O>;
        ///Field `PWM5_POLAR` reader - RW, PWM5 output polarity: 0=default low and high action, 1=default high and low action
        pub type PWM5_POLAR_R = crate::BitReader<bool>;
        ///Field `PWM5_POLAR` writer - RW, PWM5 output polarity: 0=default low and high action, 1=default high and low action
        pub type PWM5_POLAR_W<'a, const O: u8> = crate::BitWriter<'a, u8, PWM_POLAR_SPEC, bool, O>;
        ///Field `PWM6_POLAR` reader - RW, PWM6 output polarity: 0=default low and high action, 1=default high and low action
        pub type PWM6_POLAR_R = crate::BitReader<bool>;
        ///Field `PWM6_POLAR` writer - RW, PWM6 output polarity: 0=default low and high action, 1=default high and low action
        pub type PWM6_POLAR_W<'a, const O: u8> = crate::BitWriter<'a, u8, PWM_POLAR_SPEC, bool, O>;
        ///Field `PWM7_POLAR` reader - RW, PWM7 output polarity: 0=default low and high action, 1=default high and low action
        pub type PWM7_POLAR_R = crate::BitReader<bool>;
        ///Field `PWM7_POLAR` writer - RW, PWM7 output polarity: 0=default low and high action, 1=default high and low action
        pub type PWM7_POLAR_W<'a, const O: u8> = crate::BitWriter<'a, u8, PWM_POLAR_SPEC, bool, O>;
        ///Field `PWM8_POLAR` reader - RW, PWM8 output polarity: 0=default low and high action, 1=default high and low action
        pub type PWM8_POLAR_R = crate::BitReader<bool>;
        ///Field `PWM8_POLAR` writer - RW, PWM8 output polarity: 0=default low and high action, 1=default high and low action
        pub type PWM8_POLAR_W<'a, const O: u8> = crate::BitWriter<'a, u8, PWM_POLAR_SPEC, bool, O>;
        ///Field `PWM9_POLAR` reader - RW, PWM9 output polarity: 0=default low and high action, 1=default high and low action
        pub type PWM9_POLAR_R = crate::BitReader<bool>;
        ///Field `PWM9_POLAR` writer - RW, PWM9 output polarity: 0=default low and high action, 1=default high and low action
        pub type PWM9_POLAR_W<'a, const O: u8> = crate::BitWriter<'a, u8, PWM_POLAR_SPEC, bool, O>;
        ///Field `PWM10_POLAR` reader - RW, PWM10 output polarity: 0=default low and high action, 1=default high and low action
        pub type PWM10_POLAR_R = crate::BitReader<bool>;
        ///Field `PWM10_POLAR` writer - RW, PWM10 output polarity: 0=default low and high action, 1=default high and low action
        pub type PWM10_POLAR_W<'a, const O: u8> = crate::BitWriter<'a, u8, PWM_POLAR_SPEC, bool, O>;
        ///Field `PWM11_POLAR` reader - RW, PWM11 output polarity: 0=default low and high action, 1=default high and low action
        pub type PWM11_POLAR_R = crate::BitReader<bool>;
        ///Field `PWM11_POLAR` writer - RW, PWM11 output polarity: 0=default low and high action, 1=default high and low action
        pub type PWM11_POLAR_W<'a, const O: u8> = crate::BitWriter<'a, u8, PWM_POLAR_SPEC, bool, O>;
        impl R {
            ///Bit 0 - RW, PWM4 output polarity: 0=default low and high action, 1=default high and low action
            #[inline(always)]
            pub fn pwm4_polar(&self) -> PWM4_POLAR_R {
                PWM4_POLAR_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RW, PWM5 output polarity: 0=default low and high action, 1=default high and low action
            #[inline(always)]
            pub fn pwm5_polar(&self) -> PWM5_POLAR_R {
                PWM5_POLAR_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RW, PWM6 output polarity: 0=default low and high action, 1=default high and low action
            #[inline(always)]
            pub fn pwm6_polar(&self) -> PWM6_POLAR_R {
                PWM6_POLAR_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RW, PWM7 output polarity: 0=default low and high action, 1=default high and low action
            #[inline(always)]
            pub fn pwm7_polar(&self) -> PWM7_POLAR_R {
                PWM7_POLAR_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RW, PWM8 output polarity: 0=default low and high action, 1=default high and low action
            #[inline(always)]
            pub fn pwm8_polar(&self) -> PWM8_POLAR_R {
                PWM8_POLAR_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - RW, PWM9 output polarity: 0=default low and high action, 1=default high and low action
            #[inline(always)]
            pub fn pwm9_polar(&self) -> PWM9_POLAR_R {
                PWM9_POLAR_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - RW, PWM10 output polarity: 0=default low and high action, 1=default high and low action
            #[inline(always)]
            pub fn pwm10_polar(&self) -> PWM10_POLAR_R {
                PWM10_POLAR_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - RW, PWM11 output polarity: 0=default low and high action, 1=default high and low action
            #[inline(always)]
            pub fn pwm11_polar(&self) -> PWM11_POLAR_R {
                PWM11_POLAR_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RW, PWM4 output polarity: 0=default low and high action, 1=default high and low action
            #[inline(always)]
            #[must_use]
            pub fn pwm4_polar(&mut self) -> PWM4_POLAR_W<0> {
                PWM4_POLAR_W::new(self)
            }
            ///Bit 1 - RW, PWM5 output polarity: 0=default low and high action, 1=default high and low action
            #[inline(always)]
            #[must_use]
            pub fn pwm5_polar(&mut self) -> PWM5_POLAR_W<1> {
                PWM5_POLAR_W::new(self)
            }
            ///Bit 2 - RW, PWM6 output polarity: 0=default low and high action, 1=default high and low action
            #[inline(always)]
            #[must_use]
            pub fn pwm6_polar(&mut self) -> PWM6_POLAR_W<2> {
                PWM6_POLAR_W::new(self)
            }
            ///Bit 3 - RW, PWM7 output polarity: 0=default low and high action, 1=default high and low action
            #[inline(always)]
            #[must_use]
            pub fn pwm7_polar(&mut self) -> PWM7_POLAR_W<3> {
                PWM7_POLAR_W::new(self)
            }
            ///Bit 4 - RW, PWM8 output polarity: 0=default low and high action, 1=default high and low action
            #[inline(always)]
            #[must_use]
            pub fn pwm8_polar(&mut self) -> PWM8_POLAR_W<4> {
                PWM8_POLAR_W::new(self)
            }
            ///Bit 5 - RW, PWM9 output polarity: 0=default low and high action, 1=default high and low action
            #[inline(always)]
            #[must_use]
            pub fn pwm9_polar(&mut self) -> PWM9_POLAR_W<5> {
                PWM9_POLAR_W::new(self)
            }
            ///Bit 6 - RW, PWM10 output polarity: 0=default low and high action, 1=default high and low action
            #[inline(always)]
            #[must_use]
            pub fn pwm10_polar(&mut self) -> PWM10_POLAR_W<6> {
                PWM10_POLAR_W::new(self)
            }
            ///Bit 7 - RW, PWM11 output polarity: 0=default low and high action, 1=default high and low action
            #[inline(always)]
            #[must_use]
            pub fn pwm11_polar(&mut self) -> PWM11_POLAR_W<7> {
                PWM11_POLAR_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, PWM output polarity control
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [pwm_polar](index.html) module
        pub struct PWM_POLAR_SPEC;
        impl crate::RegisterSpec for PWM_POLAR_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [pwm_polar::R](R) reader structure
        impl crate::Readable for PWM_POLAR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [pwm_polar::W](W) writer structure
        impl crate::Writable for PWM_POLAR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets PWM_POLAR to value 0
        impl crate::Resettable for PWM_POLAR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///PWM_CONFIG (rw) register accessor: an alias for `Reg<PWM_CONFIG_SPEC>`
    pub type PWM_CONFIG = crate::Reg<pwm_config::PWM_CONFIG_SPEC>;
    ///RW, PWM configuration
    pub mod pwm_config {
        ///Register `PWM_CONFIG` reader
        pub struct R(crate::R<PWM_CONFIG_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PWM_CONFIG_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<PWM_CONFIG_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<PWM_CONFIG_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `PWM_CONFIG` writer
        pub struct W(crate::W<PWM_CONFIG_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PWM_CONFIG_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<PWM_CONFIG_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<PWM_CONFIG_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `PWM_CYCLE_SEL` reader - RW, PWM cycle selection: 0=256;128;64;32 clocks, 1=255;127;63;31 clocks
        pub type PWM_CYCLE_SEL_R = crate::BitReader<bool>;
        ///Field `PWM_CYCLE_SEL` writer - RW, PWM cycle selection: 0=256;128;64;32 clocks, 1=255;127;63;31 clocks
        pub type PWM_CYCLE_SEL_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, PWM_CONFIG_SPEC, bool, O>;
        ///Field `PWM_STAG_ST` reader - RO, PWM stagger cycle status
        pub type PWM_STAG_ST_R = crate::BitReader<bool>;
        ///Field `PWM_CYC_MOD` reader - RW, PWM data width mode: 00=8 bits data, 01=7 bits data, 10=6 bits data, 11=5 bits data
        pub type PWM_CYC_MOD_R = crate::FieldReader<u8, u8>;
        ///Field `PWM_CYC_MOD` writer - RW, PWM data width mode: 00=8 bits data, 01=7 bits data, 10=6 bits data, 11=5 bits data
        pub type PWM_CYC_MOD_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, PWM_CONFIG_SPEC, u8, u8, 2, O>;
        ///Field `PWM4_5_STAG_EN` reader - RW, PWM4/5 stagger output enable: 0=independent output, 1=stagger output
        pub type PWM4_5_STAG_EN_R = crate::BitReader<bool>;
        ///Field `PWM4_5_STAG_EN` writer - RW, PWM4/5 stagger output enable: 0=independent output, 1=stagger output
        pub type PWM4_5_STAG_EN_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, PWM_CONFIG_SPEC, bool, O>;
        ///Field `PWM6_7_STAG_EN` reader - RW, PWM6/7 stagger output enable: 0=independent output, 1=stagger output
        pub type PWM6_7_STAG_EN_R = crate::BitReader<bool>;
        ///Field `PWM6_7_STAG_EN` writer - RW, PWM6/7 stagger output enable: 0=independent output, 1=stagger output
        pub type PWM6_7_STAG_EN_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, PWM_CONFIG_SPEC, bool, O>;
        ///Field `PWM8_9_STAG_EN` reader - RW, PWM8/9 stagger output enable: 0=independent output, 1=stagger output
        pub type PWM8_9_STAG_EN_R = crate::BitReader<bool>;
        ///Field `PWM8_9_STAG_EN` writer - RW, PWM8/9 stagger output enable: 0=independent output, 1=stagger output
        pub type PWM8_9_STAG_EN_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, PWM_CONFIG_SPEC, bool, O>;
        ///Field `PWM10_11_STAG_EN` reader - RW, PWM10/11 stagger output enable: 0=independent output, 1=stagger output
        pub type PWM10_11_STAG_EN_R = crate::BitReader<bool>;
        ///Field `PWM10_11_STAG_EN` writer - RW, PWM10/11 stagger output enable: 0=independent output, 1=stagger output
        pub type PWM10_11_STAG_EN_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, PWM_CONFIG_SPEC, bool, O>;
        impl R {
            ///Bit 0 - RW, PWM cycle selection: 0=256;128;64;32 clocks, 1=255;127;63;31 clocks
            #[inline(always)]
            pub fn pwm_cycle_sel(&self) -> PWM_CYCLE_SEL_R {
                PWM_CYCLE_SEL_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RO, PWM stagger cycle status
            #[inline(always)]
            pub fn pwm_stag_st(&self) -> PWM_STAG_ST_R {
                PWM_STAG_ST_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bits 2:3 - RW, PWM data width mode: 00=8 bits data, 01=7 bits data, 10=6 bits data, 11=5 bits data
            #[inline(always)]
            pub fn pwm_cyc_mod(&self) -> PWM_CYC_MOD_R {
                PWM_CYC_MOD_R::new((self.bits >> 2) & 3)
            }
            ///Bit 4 - RW, PWM4/5 stagger output enable: 0=independent output, 1=stagger output
            #[inline(always)]
            pub fn pwm4_5_stag_en(&self) -> PWM4_5_STAG_EN_R {
                PWM4_5_STAG_EN_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - RW, PWM6/7 stagger output enable: 0=independent output, 1=stagger output
            #[inline(always)]
            pub fn pwm6_7_stag_en(&self) -> PWM6_7_STAG_EN_R {
                PWM6_7_STAG_EN_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - RW, PWM8/9 stagger output enable: 0=independent output, 1=stagger output
            #[inline(always)]
            pub fn pwm8_9_stag_en(&self) -> PWM8_9_STAG_EN_R {
                PWM8_9_STAG_EN_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - RW, PWM10/11 stagger output enable: 0=independent output, 1=stagger output
            #[inline(always)]
            pub fn pwm10_11_stag_en(&self) -> PWM10_11_STAG_EN_R {
                PWM10_11_STAG_EN_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RW, PWM cycle selection: 0=256;128;64;32 clocks, 1=255;127;63;31 clocks
            #[inline(always)]
            #[must_use]
            pub fn pwm_cycle_sel(&mut self) -> PWM_CYCLE_SEL_W<0> {
                PWM_CYCLE_SEL_W::new(self)
            }
            ///Bits 2:3 - RW, PWM data width mode: 00=8 bits data, 01=7 bits data, 10=6 bits data, 11=5 bits data
            #[inline(always)]
            #[must_use]
            pub fn pwm_cyc_mod(&mut self) -> PWM_CYC_MOD_W<2> {
                PWM_CYC_MOD_W::new(self)
            }
            ///Bit 4 - RW, PWM4/5 stagger output enable: 0=independent output, 1=stagger output
            #[inline(always)]
            #[must_use]
            pub fn pwm4_5_stag_en(&mut self) -> PWM4_5_STAG_EN_W<4> {
                PWM4_5_STAG_EN_W::new(self)
            }
            ///Bit 5 - RW, PWM6/7 stagger output enable: 0=independent output, 1=stagger output
            #[inline(always)]
            #[must_use]
            pub fn pwm6_7_stag_en(&mut self) -> PWM6_7_STAG_EN_W<5> {
                PWM6_7_STAG_EN_W::new(self)
            }
            ///Bit 6 - RW, PWM8/9 stagger output enable: 0=independent output, 1=stagger output
            #[inline(always)]
            #[must_use]
            pub fn pwm8_9_stag_en(&mut self) -> PWM8_9_STAG_EN_W<6> {
                PWM8_9_STAG_EN_W::new(self)
            }
            ///Bit 7 - RW, PWM10/11 stagger output enable: 0=independent output, 1=stagger output
            #[inline(always)]
            #[must_use]
            pub fn pwm10_11_stag_en(&mut self) -> PWM10_11_STAG_EN_W<7> {
                PWM10_11_STAG_EN_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, PWM configuration
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [pwm_config](index.html) module
        pub struct PWM_CONFIG_SPEC;
        impl crate::RegisterSpec for PWM_CONFIG_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [pwm_config::R](R) reader structure
        impl crate::Readable for PWM_CONFIG_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [pwm_config::W](W) writer structure
        impl crate::Writable for PWM_CONFIG_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets PWM_CONFIG to value 0
        impl crate::Resettable for PWM_CONFIG_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///PWM_CLOCK_DIV (rw) register accessor: an alias for `Reg<PWM_CLOCK_DIV_SPEC>`
    pub type PWM_CLOCK_DIV = crate::Reg<pwm_clock_div::PWM_CLOCK_DIV_SPEC>;
    ///RW, PWM clock divisor
    pub mod pwm_clock_div {
        ///Register `PWM_CLOCK_DIV` reader
        pub struct R(crate::R<PWM_CLOCK_DIV_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PWM_CLOCK_DIV_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<PWM_CLOCK_DIV_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<PWM_CLOCK_DIV_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `PWM_CLOCK_DIV` writer
        pub struct W(crate::W<PWM_CLOCK_DIV_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PWM_CLOCK_DIV_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<PWM_CLOCK_DIV_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<PWM_CLOCK_DIV_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `PWM_CLOCK_DIV` reader - RW, PWM clock divisor
        pub type PWM_CLOCK_DIV_R = crate::FieldReader<u8, u8>;
        ///Field `PWM_CLOCK_DIV` writer - RW, PWM clock divisor
        pub type PWM_CLOCK_DIV_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, PWM_CLOCK_DIV_SPEC, u8, u8, 8, O>;
        impl R {
            ///Bits 0:7 - RW, PWM clock divisor
            #[inline(always)]
            pub fn pwm_clock_div(&self) -> PWM_CLOCK_DIV_R {
                PWM_CLOCK_DIV_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:7 - RW, PWM clock divisor
            #[inline(always)]
            #[must_use]
            pub fn pwm_clock_div(&mut self) -> PWM_CLOCK_DIV_W<0> {
                PWM_CLOCK_DIV_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, PWM clock divisor
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [pwm_clock_div](index.html) module
        pub struct PWM_CLOCK_DIV_SPEC;
        impl crate::RegisterSpec for PWM_CLOCK_DIV_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [pwm_clock_div::R](R) reader structure
        impl crate::Readable for PWM_CLOCK_DIV_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [pwm_clock_div::W](W) writer structure
        impl crate::Writable for PWM_CLOCK_DIV_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets PWM_CLOCK_DIV to value 0
        impl crate::Resettable for PWM_CLOCK_DIV_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///PWM4_DATA (rw) register accessor: an alias for `Reg<PWM4_DATA_SPEC>`
    pub type PWM4_DATA = crate::Reg<pwm4_data::PWM4_DATA_SPEC>;
    ///RW, PWM4 data holding
    pub mod pwm4_data {
        ///Register `PWM4_DATA` reader
        pub struct R(crate::R<PWM4_DATA_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PWM4_DATA_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<PWM4_DATA_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<PWM4_DATA_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `PWM4_DATA` writer
        pub struct W(crate::W<PWM4_DATA_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PWM4_DATA_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<PWM4_DATA_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<PWM4_DATA_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `PWM4_DATA` reader - RW, PWM4 data holding
        pub type PWM4_DATA_R = crate::FieldReader<u8, u8>;
        ///Field `PWM4_DATA` writer - RW, PWM4 data holding
        pub type PWM4_DATA_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, PWM4_DATA_SPEC, u8, u8, 8, O>;
        impl R {
            ///Bits 0:7 - RW, PWM4 data holding
            #[inline(always)]
            pub fn pwm4_data(&self) -> PWM4_DATA_R {
                PWM4_DATA_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:7 - RW, PWM4 data holding
            #[inline(always)]
            #[must_use]
            pub fn pwm4_data(&mut self) -> PWM4_DATA_W<0> {
                PWM4_DATA_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, PWM4 data holding
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [pwm4_data](index.html) module
        pub struct PWM4_DATA_SPEC;
        impl crate::RegisterSpec for PWM4_DATA_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [pwm4_data::R](R) reader structure
        impl crate::Readable for PWM4_DATA_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [pwm4_data::W](W) writer structure
        impl crate::Writable for PWM4_DATA_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets PWM4_DATA to value 0
        impl crate::Resettable for PWM4_DATA_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///PWM5_DATA (rw) register accessor: an alias for `Reg<PWM5_DATA_SPEC>`
    pub type PWM5_DATA = crate::Reg<pwm5_data::PWM5_DATA_SPEC>;
    ///RW, PWM5 data holding
    pub mod pwm5_data {
        ///Register `PWM5_DATA` reader
        pub struct R(crate::R<PWM5_DATA_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PWM5_DATA_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<PWM5_DATA_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<PWM5_DATA_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `PWM5_DATA` writer
        pub struct W(crate::W<PWM5_DATA_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PWM5_DATA_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<PWM5_DATA_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<PWM5_DATA_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `PWM5_DATA` reader - RW, PWM5 data holding
        pub type PWM5_DATA_R = crate::FieldReader<u8, u8>;
        ///Field `PWM5_DATA` writer - RW, PWM5 data holding
        pub type PWM5_DATA_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, PWM5_DATA_SPEC, u8, u8, 8, O>;
        impl R {
            ///Bits 0:7 - RW, PWM5 data holding
            #[inline(always)]
            pub fn pwm5_data(&self) -> PWM5_DATA_R {
                PWM5_DATA_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:7 - RW, PWM5 data holding
            #[inline(always)]
            #[must_use]
            pub fn pwm5_data(&mut self) -> PWM5_DATA_W<0> {
                PWM5_DATA_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, PWM5 data holding
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [pwm5_data](index.html) module
        pub struct PWM5_DATA_SPEC;
        impl crate::RegisterSpec for PWM5_DATA_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [pwm5_data::R](R) reader structure
        impl crate::Readable for PWM5_DATA_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [pwm5_data::W](W) writer structure
        impl crate::Writable for PWM5_DATA_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets PWM5_DATA to value 0
        impl crate::Resettable for PWM5_DATA_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///PWM6_DATA (rw) register accessor: an alias for `Reg<PWM6_DATA_SPEC>`
    pub type PWM6_DATA = crate::Reg<pwm6_data::PWM6_DATA_SPEC>;
    ///RW, PWM6 data holding
    pub mod pwm6_data {
        ///Register `PWM6_DATA` reader
        pub struct R(crate::R<PWM6_DATA_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PWM6_DATA_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<PWM6_DATA_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<PWM6_DATA_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `PWM6_DATA` writer
        pub struct W(crate::W<PWM6_DATA_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PWM6_DATA_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<PWM6_DATA_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<PWM6_DATA_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `PWM6_DATA` reader - RW, PWM6 data holding
        pub type PWM6_DATA_R = crate::FieldReader<u8, u8>;
        ///Field `PWM6_DATA` writer - RW, PWM6 data holding
        pub type PWM6_DATA_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, PWM6_DATA_SPEC, u8, u8, 8, O>;
        impl R {
            ///Bits 0:7 - RW, PWM6 data holding
            #[inline(always)]
            pub fn pwm6_data(&self) -> PWM6_DATA_R {
                PWM6_DATA_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:7 - RW, PWM6 data holding
            #[inline(always)]
            #[must_use]
            pub fn pwm6_data(&mut self) -> PWM6_DATA_W<0> {
                PWM6_DATA_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, PWM6 data holding
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [pwm6_data](index.html) module
        pub struct PWM6_DATA_SPEC;
        impl crate::RegisterSpec for PWM6_DATA_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [pwm6_data::R](R) reader structure
        impl crate::Readable for PWM6_DATA_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [pwm6_data::W](W) writer structure
        impl crate::Writable for PWM6_DATA_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets PWM6_DATA to value 0
        impl crate::Resettable for PWM6_DATA_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///PWM7_DATA (rw) register accessor: an alias for `Reg<PWM7_DATA_SPEC>`
    pub type PWM7_DATA = crate::Reg<pwm7_data::PWM7_DATA_SPEC>;
    ///RW, PWM7 data holding
    pub mod pwm7_data {
        ///Register `PWM7_DATA` reader
        pub struct R(crate::R<PWM7_DATA_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PWM7_DATA_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<PWM7_DATA_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<PWM7_DATA_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `PWM7_DATA` writer
        pub struct W(crate::W<PWM7_DATA_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PWM7_DATA_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<PWM7_DATA_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<PWM7_DATA_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `PWM7_DATA` reader - RW, PWM7 data holding
        pub type PWM7_DATA_R = crate::FieldReader<u8, u8>;
        ///Field `PWM7_DATA` writer - RW, PWM7 data holding
        pub type PWM7_DATA_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, PWM7_DATA_SPEC, u8, u8, 8, O>;
        impl R {
            ///Bits 0:7 - RW, PWM7 data holding
            #[inline(always)]
            pub fn pwm7_data(&self) -> PWM7_DATA_R {
                PWM7_DATA_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:7 - RW, PWM7 data holding
            #[inline(always)]
            #[must_use]
            pub fn pwm7_data(&mut self) -> PWM7_DATA_W<0> {
                PWM7_DATA_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, PWM7 data holding
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [pwm7_data](index.html) module
        pub struct PWM7_DATA_SPEC;
        impl crate::RegisterSpec for PWM7_DATA_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [pwm7_data::R](R) reader structure
        impl crate::Readable for PWM7_DATA_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [pwm7_data::W](W) writer structure
        impl crate::Writable for PWM7_DATA_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets PWM7_DATA to value 0
        impl crate::Resettable for PWM7_DATA_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///PWM8_DATA (rw) register accessor: an alias for `Reg<PWM8_DATA_SPEC>`
    pub type PWM8_DATA = crate::Reg<pwm8_data::PWM8_DATA_SPEC>;
    ///RW, PWM8 data holding
    pub mod pwm8_data {
        ///Register `PWM8_DATA` reader
        pub struct R(crate::R<PWM8_DATA_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PWM8_DATA_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<PWM8_DATA_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<PWM8_DATA_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `PWM8_DATA` writer
        pub struct W(crate::W<PWM8_DATA_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PWM8_DATA_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<PWM8_DATA_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<PWM8_DATA_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `PWM8_DATA` reader - RW, PWM8 data holding
        pub type PWM8_DATA_R = crate::FieldReader<u8, u8>;
        ///Field `PWM8_DATA` writer - RW, PWM8 data holding
        pub type PWM8_DATA_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, PWM8_DATA_SPEC, u8, u8, 8, O>;
        impl R {
            ///Bits 0:7 - RW, PWM8 data holding
            #[inline(always)]
            pub fn pwm8_data(&self) -> PWM8_DATA_R {
                PWM8_DATA_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:7 - RW, PWM8 data holding
            #[inline(always)]
            #[must_use]
            pub fn pwm8_data(&mut self) -> PWM8_DATA_W<0> {
                PWM8_DATA_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, PWM8 data holding
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [pwm8_data](index.html) module
        pub struct PWM8_DATA_SPEC;
        impl crate::RegisterSpec for PWM8_DATA_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [pwm8_data::R](R) reader structure
        impl crate::Readable for PWM8_DATA_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [pwm8_data::W](W) writer structure
        impl crate::Writable for PWM8_DATA_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets PWM8_DATA to value 0
        impl crate::Resettable for PWM8_DATA_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///PWM9_DATA (rw) register accessor: an alias for `Reg<PWM9_DATA_SPEC>`
    pub type PWM9_DATA = crate::Reg<pwm9_data::PWM9_DATA_SPEC>;
    ///RW, PWM9 data holding
    pub mod pwm9_data {
        ///Register `PWM9_DATA` reader
        pub struct R(crate::R<PWM9_DATA_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PWM9_DATA_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<PWM9_DATA_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<PWM9_DATA_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `PWM9_DATA` writer
        pub struct W(crate::W<PWM9_DATA_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PWM9_DATA_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<PWM9_DATA_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<PWM9_DATA_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `PWM9_DATA` reader - RW, PWM9 data holding
        pub type PWM9_DATA_R = crate::FieldReader<u8, u8>;
        ///Field `PWM9_DATA` writer - RW, PWM9 data holding
        pub type PWM9_DATA_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, PWM9_DATA_SPEC, u8, u8, 8, O>;
        impl R {
            ///Bits 0:7 - RW, PWM9 data holding
            #[inline(always)]
            pub fn pwm9_data(&self) -> PWM9_DATA_R {
                PWM9_DATA_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:7 - RW, PWM9 data holding
            #[inline(always)]
            #[must_use]
            pub fn pwm9_data(&mut self) -> PWM9_DATA_W<0> {
                PWM9_DATA_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, PWM9 data holding
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [pwm9_data](index.html) module
        pub struct PWM9_DATA_SPEC;
        impl crate::RegisterSpec for PWM9_DATA_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [pwm9_data::R](R) reader structure
        impl crate::Readable for PWM9_DATA_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [pwm9_data::W](W) writer structure
        impl crate::Writable for PWM9_DATA_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets PWM9_DATA to value 0
        impl crate::Resettable for PWM9_DATA_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///PWM10_DATA (rw) register accessor: an alias for `Reg<PWM10_DATA_SPEC>`
    pub type PWM10_DATA = crate::Reg<pwm10_data::PWM10_DATA_SPEC>;
    ///RW, PWM10 data holding
    pub mod pwm10_data {
        ///Register `PWM10_DATA` reader
        pub struct R(crate::R<PWM10_DATA_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PWM10_DATA_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<PWM10_DATA_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<PWM10_DATA_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `PWM10_DATA` writer
        pub struct W(crate::W<PWM10_DATA_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PWM10_DATA_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<PWM10_DATA_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<PWM10_DATA_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `PWM10_DATA` reader - RW, PWM10 data holding
        pub type PWM10_DATA_R = crate::FieldReader<u8, u8>;
        ///Field `PWM10_DATA` writer - RW, PWM10 data holding
        pub type PWM10_DATA_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, PWM10_DATA_SPEC, u8, u8, 8, O>;
        impl R {
            ///Bits 0:7 - RW, PWM10 data holding
            #[inline(always)]
            pub fn pwm10_data(&self) -> PWM10_DATA_R {
                PWM10_DATA_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:7 - RW, PWM10 data holding
            #[inline(always)]
            #[must_use]
            pub fn pwm10_data(&mut self) -> PWM10_DATA_W<0> {
                PWM10_DATA_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, PWM10 data holding
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [pwm10_data](index.html) module
        pub struct PWM10_DATA_SPEC;
        impl crate::RegisterSpec for PWM10_DATA_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [pwm10_data::R](R) reader structure
        impl crate::Readable for PWM10_DATA_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [pwm10_data::W](W) writer structure
        impl crate::Writable for PWM10_DATA_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets PWM10_DATA to value 0
        impl crate::Resettable for PWM10_DATA_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///PWM11_DATA (rw) register accessor: an alias for `Reg<PWM11_DATA_SPEC>`
    pub type PWM11_DATA = crate::Reg<pwm11_data::PWM11_DATA_SPEC>;
    ///RW, PWM11 data holding
    pub mod pwm11_data {
        ///Register `PWM11_DATA` reader
        pub struct R(crate::R<PWM11_DATA_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PWM11_DATA_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<PWM11_DATA_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<PWM11_DATA_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `PWM11_DATA` writer
        pub struct W(crate::W<PWM11_DATA_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PWM11_DATA_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<PWM11_DATA_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<PWM11_DATA_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `PWM11_DATA` reader - RW, PWM11 data holding
        pub type PWM11_DATA_R = crate::FieldReader<u8, u8>;
        ///Field `PWM11_DATA` writer - RW, PWM11 data holding
        pub type PWM11_DATA_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, PWM11_DATA_SPEC, u8, u8, 8, O>;
        impl R {
            ///Bits 0:7 - RW, PWM11 data holding
            #[inline(always)]
            pub fn pwm11_data(&self) -> PWM11_DATA_R {
                PWM11_DATA_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:7 - RW, PWM11 data holding
            #[inline(always)]
            #[must_use]
            pub fn pwm11_data(&mut self) -> PWM11_DATA_W<0> {
                PWM11_DATA_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, PWM11 data holding
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [pwm11_data](index.html) module
        pub struct PWM11_DATA_SPEC;
        impl crate::RegisterSpec for PWM11_DATA_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [pwm11_data::R](R) reader structure
        impl crate::Readable for PWM11_DATA_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [pwm11_data::W](W) writer structure
        impl crate::Writable for PWM11_DATA_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets PWM11_DATA to value 0
        impl crate::Resettable for PWM11_DATA_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///PWM_INT_CTRL (rw) register accessor: an alias for `Reg<PWM_INT_CTRL_SPEC>`
    pub type PWM_INT_CTRL = crate::Reg<pwm_int_ctrl::PWM_INT_CTRL_SPEC>;
    ///RW, PWM interrupt control
    pub mod pwm_int_ctrl {
        ///Register `PWM_INT_CTRL` reader
        pub struct R(crate::R<PWM_INT_CTRL_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PWM_INT_CTRL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<PWM_INT_CTRL_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<PWM_INT_CTRL_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `PWM_INT_CTRL` writer
        pub struct W(crate::W<PWM_INT_CTRL_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PWM_INT_CTRL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<PWM_INT_CTRL_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<PWM_INT_CTRL_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `PWM_IE_CYC` reader - RW, enable interrupt for PWM cycle end
        pub type PWM_IE_CYC_R = crate::BitReader<bool>;
        ///Field `PWM_IE_CYC` writer - RW, enable interrupt for PWM cycle end
        pub type PWM_IE_CYC_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, PWM_INT_CTRL_SPEC, bool, O>;
        ///Field `PWM_CYC_PRE` reader - RW, select PWM cycle interrupt point
        pub type PWM_CYC_PRE_R = crate::BitReader<bool>;
        ///Field `PWM_CYC_PRE` writer - RW, select PWM cycle interrupt point
        pub type PWM_CYC_PRE_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, PWM_INT_CTRL_SPEC, bool, O>;
        ///Field `PWM_IF_CYC` reader - RW1, interrupt flag for PWM cycle end
        pub type PWM_IF_CYC_R = crate::BitReader<bool>;
        ///Field `PWM_IF_CYC` writer - RW1, interrupt flag for PWM cycle end
        pub type PWM_IF_CYC_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, PWM_INT_CTRL_SPEC, bool, O>;
        impl R {
            ///Bit 0 - RW, enable interrupt for PWM cycle end
            #[inline(always)]
            pub fn pwm_ie_cyc(&self) -> PWM_IE_CYC_R {
                PWM_IE_CYC_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RW, select PWM cycle interrupt point
            #[inline(always)]
            pub fn pwm_cyc_pre(&self) -> PWM_CYC_PRE_R {
                PWM_CYC_PRE_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 7 - RW1, interrupt flag for PWM cycle end
            #[inline(always)]
            pub fn pwm_if_cyc(&self) -> PWM_IF_CYC_R {
                PWM_IF_CYC_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RW, enable interrupt for PWM cycle end
            #[inline(always)]
            #[must_use]
            pub fn pwm_ie_cyc(&mut self) -> PWM_IE_CYC_W<0> {
                PWM_IE_CYC_W::new(self)
            }
            ///Bit 1 - RW, select PWM cycle interrupt point
            #[inline(always)]
            #[must_use]
            pub fn pwm_cyc_pre(&mut self) -> PWM_CYC_PRE_W<1> {
                PWM_CYC_PRE_W::new(self)
            }
            ///Bit 7 - RW1, interrupt flag for PWM cycle end
            #[inline(always)]
            #[must_use]
            pub fn pwm_if_cyc(&mut self) -> PWM_IF_CYC_W<7> {
                PWM_IF_CYC_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW, PWM interrupt control
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [pwm_int_ctrl](index.html) module
        pub struct PWM_INT_CTRL_SPEC;
        impl crate::RegisterSpec for PWM_INT_CTRL_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [pwm_int_ctrl::R](R) reader structure
        impl crate::Readable for PWM_INT_CTRL_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [pwm_int_ctrl::W](W) writer structure
        impl crate::Writable for PWM_INT_CTRL_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets PWM_INT_CTRL to value 0
        impl crate::Resettable for PWM_INT_CTRL_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
}
///USB register
pub struct USB {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for USB {}
impl USB {
    ///Pointer to the register block
    pub const PTR: *const usb::RegisterBlock = 0x4000_8000 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const usb::RegisterBlock {
        Self::PTR
    }
}
impl Deref for USB {
    type Target = usb::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for USB {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("USB").finish()
    }
}
///USB register
pub mod usb {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        ///0x00 - USB base control
        pub usb_ctrl: USB_CTRL,
        ///0x01 - USB device physical prot control
        pub udev_ctrl__r8_uhost_ctrl: UDEV_CTRL__R8_UHOST_CTRL,
        ///0x02 - USB interrupt enable
        pub usb_int_en: USB_INT_EN,
        ///0x03 - USB device address
        pub usb_dev_ad: USB_DEV_AD,
        _reserved4: [u8; 0x01],
        ///0x05 - USB miscellaneous status
        pub usb_mis_st: USB_MIS_ST,
        ///0x06 - USB interrupt flag
        pub usb_int_fg: USB_INT_FG,
        ///0x07 - USB interrupt status
        pub usb_int_st: USB_INT_ST,
        ///0x08 - USB receiving length
        pub usb_rx_len: USB_RX_LEN,
        _reserved8: [u8; 0x03],
        ///0x0c - endpoint 4/1 mode
        pub uep4_1_mod: UEP4_1_MOD,
        ///0x0d - endpoint 2_3 mode;host endpoint mode
        pub uep2_3_mod__r8_uh_ep_mod: UEP2_3_MOD__R8_UH_EP_MOD,
        ///0x0e - endpoint 5/6/7 mode
        pub uep567_mod: UEP567_MOD,
        _reserved11: [u8; 0x01],
        ///0x10 - endpoint 0 DMA buffer address
        pub uep0_dma: UEP0_DMA,
        _reserved12: [u8; 0x02],
        ///0x14 - endpoint 1 DMA buffer address
        pub uep1_dma: UEP1_DMA,
        _reserved13: [u8; 0x02],
        ///0x18 - endpoint 2 DMA buffer address;host rx endpoint buffer high address
        pub uep2_dma__r16_uh_rx_dma: UEP2_DMA__R16_UH_RX_DMA,
        _reserved14: [u8; 0x02],
        ///0x1c - endpoint 3 DMA buffer address;host tx endpoint buffer high address
        pub uep3_dma__r16_uh_tx_dma: UEP3_DMA__R16_UH_TX_DMA,
        _reserved15: [u8; 0x02],
        ///0x20 - endpoint 0 transmittal length
        pub uep0_t_len: UEP0_T_LEN,
        _reserved16: [u8; 0x01],
        ///0x22 - endpoint 0 control
        pub uep0_ctrl: UEP0_CTRL,
        _reserved17: [u8; 0x01],
        ///0x24 - endpoint 1 transmittal length
        pub uep1_t_len: UEP1_T_LEN,
        _reserved18: [u8; 0x01],
        ///0x26 - endpoint 1 control;host aux setup
        pub uep1_ctrl__r8_uh_setup: UEP1_CTRL__R8_UH_SETUP,
        _reserved19: [u8; 0x01],
        ///0x28 - endpoint 2 transmittal length;host endpoint and PID
        pub uep2_t_len_r8_uh_ep_pid: UEP2_T_LEN_R8_UH_EP_PID,
        _reserved20: [u8; 0x01],
        ///0x2a - endpoint 2 control;host receiver endpoint control
        pub uep2_ctrl_r8_uh_rx_ctrl: UEP2_CTRL_R8_UH_RX_CTRL,
        _reserved21: [u8; 0x01],
        ///0x2c - endpoint 3 transmittal length;host transmittal endpoint transmittal length
        pub uep3_t_len__r8_uh_tx_len: UEP3_T_LEN__R8_UH_TX_LEN,
        _reserved22: [u8; 0x01],
        ///0x2e - endpoint 3 control;host transmittal endpoint control
        pub uep3_ctrl__r8_uh_tx_ctrl: UEP3_CTRL__R8_UH_TX_CTRL,
        _reserved23: [u8; 0x01],
        ///0x30 - endpoint 4 transmittal length
        pub uep4_t_len: UEP4_T_LEN,
        _reserved24: [u8; 0x01],
        ///0x32 - endpoint 4 control
        pub uep4_ctrl: UEP4_CTRL,
        _reserved25: [u8; 0x21],
        ///0x54 - endpoint 5 DMA buffer address
        pub uep5_dma: UEP5_DMA,
        _reserved26: [u8; 0x02],
        ///0x58 - endpoint 6 DMA buffer address
        pub uep6_dma: UEP6_DMA,
        _reserved27: [u8; 0x02],
        ///0x5c - endpoint 7 DMA buffer address
        pub uep7_dma: UEP7_DMA,
        _reserved28: [u8; 0x06],
        ///0x64 - endpoint 5 transmittal length
        pub uep5_t_len: UEP5_T_LEN,
        _reserved29: [u8; 0x01],
        ///0x66 - endpoint 5 control
        pub uep5_ctrl: UEP5_CTRL,
        _reserved30: [u8; 0x01],
        ///0x68 - endpoint 6 transmittal length
        pub uep6_t_len: UEP6_T_LEN,
        _reserved31: [u8; 0x01],
        ///0x6a - endpoint 6 control
        pub uep6_ctrl: UEP6_CTRL,
        _reserved32: [u8; 0x01],
        ///0x6c - endpoint 7 transmittal length
        pub uep7_t_len: UEP7_T_LEN,
        _reserved33: [u8; 0x01],
        ///0x6e - endpoint 7 control
        pub uep7_ctrl: UEP7_CTRL,
    }
    ///USB_CTRL (rw) register accessor: an alias for `Reg<USB_CTRL_SPEC>`
    pub type USB_CTRL = crate::Reg<usb_ctrl::USB_CTRL_SPEC>;
    ///USB base control
    pub mod usb_ctrl {
        ///Register `USB_CTRL` reader
        pub struct R(crate::R<USB_CTRL_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<USB_CTRL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<USB_CTRL_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<USB_CTRL_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `USB_CTRL` writer
        pub struct W(crate::W<USB_CTRL_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<USB_CTRL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<USB_CTRL_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<USB_CTRL_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `UC_DMA_EN` reader - DMA enable and DMA interrupt enable for USB
        pub type UC_DMA_EN_R = crate::BitReader<bool>;
        ///Field `UC_DMA_EN` writer - DMA enable and DMA interrupt enable for USB
        pub type UC_DMA_EN_W<'a, const O: u8> = crate::BitWriter<'a, u8, USB_CTRL_SPEC, bool, O>;
        ///Field `UC_CLR_ALL` reader - force clear FIFO and count of USB
        pub type UC_CLR_ALL_R = crate::BitReader<bool>;
        ///Field `UC_CLR_ALL` writer - force clear FIFO and count of USB
        pub type UC_CLR_ALL_W<'a, const O: u8> = crate::BitWriter<'a, u8, USB_CTRL_SPEC, bool, O>;
        ///Field `UC_RESET_SIE` reader - force reset USB SIE, need software clear
        pub type UC_RESET_SIE_R = crate::BitReader<bool>;
        ///Field `UC_RESET_SIE` writer - force reset USB SIE, need software clear
        pub type UC_RESET_SIE_W<'a, const O: u8> = crate::BitWriter<'a, u8, USB_CTRL_SPEC, bool, O>;
        ///Field `UC_INT_BUSY` reader - enable automatic responding busy for device mode or automatic pause for host mode during interrupt flag UIF_TRANSFER valid
        pub type UC_INT_BUSY_R = crate::BitReader<bool>;
        ///Field `UC_INT_BUSY` writer - enable automatic responding busy for device mode or automatic pause for host mode during interrupt flag UIF_TRANSFER valid
        pub type UC_INT_BUSY_W<'a, const O: u8> = crate::BitWriter<'a, u8, USB_CTRL_SPEC, bool, O>;
        ///Field `MASK_UC_SYS_CTRL` reader - bit mask of USB system control
        pub type MASK_UC_SYS_CTRL_R = crate::FieldReader<u8, u8>;
        ///Field `MASK_UC_SYS_CTRL` writer - bit mask of USB system control
        pub type MASK_UC_SYS_CTRL_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, USB_CTRL_SPEC, u8, u8, 2, O>;
        ///Field `UC_DEV_PU_EN` reader - USB device enable and internal pullup resistance enable
        pub type UC_DEV_PU_EN_R = crate::BitReader<bool>;
        ///Field `UC_DEV_PU_EN` writer - USB device enable and internal pullup resistance enable
        pub type UC_DEV_PU_EN_W<'a, const O: u8> = crate::BitWriter<'a, u8, USB_CTRL_SPEC, bool, O>;
        ///Field `UC_LOW_SPEED` reader - enable USB low speed: 0=12Mbps, 1=1.5Mbps
        pub type UC_LOW_SPEED_R = crate::BitReader<bool>;
        ///Field `UC_LOW_SPEED` writer - enable USB low speed: 0=12Mbps, 1=1.5Mbps
        pub type UC_LOW_SPEED_W<'a, const O: u8> = crate::BitWriter<'a, u8, USB_CTRL_SPEC, bool, O>;
        ///Field `UC_HOST_MODE` reader - enable USB host mode: 0=device mode, 1=host mode
        pub type UC_HOST_MODE_R = crate::BitReader<bool>;
        ///Field `UC_HOST_MODE` writer - enable USB host mode: 0=device mode, 1=host mode
        pub type UC_HOST_MODE_W<'a, const O: u8> = crate::BitWriter<'a, u8, USB_CTRL_SPEC, bool, O>;
        impl R {
            ///Bit 0 - DMA enable and DMA interrupt enable for USB
            #[inline(always)]
            pub fn uc_dma_en(&self) -> UC_DMA_EN_R {
                UC_DMA_EN_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - force clear FIFO and count of USB
            #[inline(always)]
            pub fn uc_clr_all(&self) -> UC_CLR_ALL_R {
                UC_CLR_ALL_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - force reset USB SIE, need software clear
            #[inline(always)]
            pub fn uc_reset_sie(&self) -> UC_RESET_SIE_R {
                UC_RESET_SIE_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - enable automatic responding busy for device mode or automatic pause for host mode during interrupt flag UIF_TRANSFER valid
            #[inline(always)]
            pub fn uc_int_busy(&self) -> UC_INT_BUSY_R {
                UC_INT_BUSY_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bits 4:5 - bit mask of USB system control
            #[inline(always)]
            pub fn mask_uc_sys_ctrl(&self) -> MASK_UC_SYS_CTRL_R {
                MASK_UC_SYS_CTRL_R::new((self.bits >> 4) & 3)
            }
            ///Bit 5 - USB device enable and internal pullup resistance enable
            #[inline(always)]
            pub fn uc_dev_pu_en(&self) -> UC_DEV_PU_EN_R {
                UC_DEV_PU_EN_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - enable USB low speed: 0=12Mbps, 1=1.5Mbps
            #[inline(always)]
            pub fn uc_low_speed(&self) -> UC_LOW_SPEED_R {
                UC_LOW_SPEED_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - enable USB host mode: 0=device mode, 1=host mode
            #[inline(always)]
            pub fn uc_host_mode(&self) -> UC_HOST_MODE_R {
                UC_HOST_MODE_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - DMA enable and DMA interrupt enable for USB
            #[inline(always)]
            #[must_use]
            pub fn uc_dma_en(&mut self) -> UC_DMA_EN_W<0> {
                UC_DMA_EN_W::new(self)
            }
            ///Bit 1 - force clear FIFO and count of USB
            #[inline(always)]
            #[must_use]
            pub fn uc_clr_all(&mut self) -> UC_CLR_ALL_W<1> {
                UC_CLR_ALL_W::new(self)
            }
            ///Bit 2 - force reset USB SIE, need software clear
            #[inline(always)]
            #[must_use]
            pub fn uc_reset_sie(&mut self) -> UC_RESET_SIE_W<2> {
                UC_RESET_SIE_W::new(self)
            }
            ///Bit 3 - enable automatic responding busy for device mode or automatic pause for host mode during interrupt flag UIF_TRANSFER valid
            #[inline(always)]
            #[must_use]
            pub fn uc_int_busy(&mut self) -> UC_INT_BUSY_W<3> {
                UC_INT_BUSY_W::new(self)
            }
            ///Bits 4:5 - bit mask of USB system control
            #[inline(always)]
            #[must_use]
            pub fn mask_uc_sys_ctrl(&mut self) -> MASK_UC_SYS_CTRL_W<4> {
                MASK_UC_SYS_CTRL_W::new(self)
            }
            ///Bit 5 - USB device enable and internal pullup resistance enable
            #[inline(always)]
            #[must_use]
            pub fn uc_dev_pu_en(&mut self) -> UC_DEV_PU_EN_W<5> {
                UC_DEV_PU_EN_W::new(self)
            }
            ///Bit 6 - enable USB low speed: 0=12Mbps, 1=1.5Mbps
            #[inline(always)]
            #[must_use]
            pub fn uc_low_speed(&mut self) -> UC_LOW_SPEED_W<6> {
                UC_LOW_SPEED_W::new(self)
            }
            ///Bit 7 - enable USB host mode: 0=device mode, 1=host mode
            #[inline(always)]
            #[must_use]
            pub fn uc_host_mode(&mut self) -> UC_HOST_MODE_W<7> {
                UC_HOST_MODE_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///USB base control
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [usb_ctrl](index.html) module
        pub struct USB_CTRL_SPEC;
        impl crate::RegisterSpec for USB_CTRL_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [usb_ctrl::R](R) reader structure
        impl crate::Readable for USB_CTRL_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [usb_ctrl::W](W) writer structure
        impl crate::Writable for USB_CTRL_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets USB_CTRL to value 0x06
        impl crate::Resettable for USB_CTRL_SPEC {
            const RESET_VALUE: Self::Ux = 0x06;
        }
    }
    ///UDEV_CTRL__R8_UHOST_CTRL (rw) register accessor: an alias for `Reg<UDEV_CTRL__R8_UHOST_CTRL_SPEC>`
    pub type UDEV_CTRL__R8_UHOST_CTRL =
        crate::Reg<udev_ctrl__r8_uhost_ctrl::UDEV_CTRL__R8_UHOST_CTRL_SPEC>;
    ///USB device physical prot control
    pub mod udev_ctrl__r8_uhost_ctrl {
        ///Register `UDEV_CTRL__R8_UHOST_CTRL` reader
        pub struct R(crate::R<UDEV_CTRL__R8_UHOST_CTRL_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<UDEV_CTRL__R8_UHOST_CTRL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<UDEV_CTRL__R8_UHOST_CTRL_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<UDEV_CTRL__R8_UHOST_CTRL_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `UDEV_CTRL__R8_UHOST_CTRL` writer
        pub struct W(crate::W<UDEV_CTRL__R8_UHOST_CTRL_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<UDEV_CTRL__R8_UHOST_CTRL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<UDEV_CTRL__R8_UHOST_CTRL_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<UDEV_CTRL__R8_UHOST_CTRL_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `UD_PORT_EN__RB_UH_PORT_EN` reader - enable USB physical port I-O: 0=disable, 1=enable;enable USB port: 0=disable, 1=enable port, automatic disabled if USB device detached
        pub type UD_PORT_EN__RB_UH_PORT_EN_R = crate::BitReader<bool>;
        ///Field `UD_PORT_EN__RB_UH_PORT_EN` writer - enable USB physical port I-O: 0=disable, 1=enable;enable USB port: 0=disable, 1=enable port, automatic disabled if USB device detached
        pub type UD_PORT_EN__RB_UH_PORT_EN_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, UDEV_CTRL__R8_UHOST_CTRL_SPEC, bool, O>;
        ///Field `UD_GP_BIT__RB_UH_BUS_RESET` reader - general purpose bit;control USB bus reset: 0=normal, 1=force bus reset
        pub type UD_GP_BIT__RB_UH_BUS_RESET_R = crate::BitReader<bool>;
        ///Field `UD_GP_BIT__RB_UH_BUS_RESET` writer - general purpose bit;control USB bus reset: 0=normal, 1=force bus reset
        pub type UD_GP_BIT__RB_UH_BUS_RESET_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, UDEV_CTRL__R8_UHOST_CTRL_SPEC, bool, O>;
        ///Field `UD_LOW_SPEED__RB_UH_LOW_SPEED` reader - enable USB physical port low speed: 0=full speed, 1=low speed;enable USB port low speed: 0=full speed, 1=low speed
        pub type UD_LOW_SPEED__RB_UH_LOW_SPEED_R = crate::BitReader<bool>;
        ///Field `UD_LOW_SPEED__RB_UH_LOW_SPEED` writer - enable USB physical port low speed: 0=full speed, 1=low speed;enable USB port low speed: 0=full speed, 1=low speed
        pub type UD_LOW_SPEED__RB_UH_LOW_SPEED_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, UDEV_CTRL__R8_UHOST_CTRL_SPEC, bool, O>;
        ///Field `UD_DM_PIN__RB_UH_DM_PIN` reader - ReadOnly: indicate current UDM pin level
        pub type UD_DM_PIN__RB_UH_DM_PIN_R = crate::BitReader<bool>;
        ///Field `UD_DP_PIN__RB_UH_DP_PIN` reader - ReadOnly: indicate current UDP pin level
        pub type UD_DP_PIN__RB_UH_DP_PIN_R = crate::BitReader<bool>;
        ///Field `UD_PD_DIS__RB_UH_PD_DIS` reader - disable USB UDP-UDM pulldown resistance: 0=enable pulldown, 1=disable
        pub type UD_PD_DIS__RB_UH_PD_DIS_R = crate::BitReader<bool>;
        impl R {
            ///Bit 0 - enable USB physical port I-O: 0=disable, 1=enable;enable USB port: 0=disable, 1=enable port, automatic disabled if USB device detached
            #[inline(always)]
            pub fn ud_port_en__rb_uh_port_en(&self) -> UD_PORT_EN__RB_UH_PORT_EN_R {
                UD_PORT_EN__RB_UH_PORT_EN_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - general purpose bit;control USB bus reset: 0=normal, 1=force bus reset
            #[inline(always)]
            pub fn ud_gp_bit__rb_uh_bus_reset(&self) -> UD_GP_BIT__RB_UH_BUS_RESET_R {
                UD_GP_BIT__RB_UH_BUS_RESET_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - enable USB physical port low speed: 0=full speed, 1=low speed;enable USB port low speed: 0=full speed, 1=low speed
            #[inline(always)]
            pub fn ud_low_speed__rb_uh_low_speed(&self) -> UD_LOW_SPEED__RB_UH_LOW_SPEED_R {
                UD_LOW_SPEED__RB_UH_LOW_SPEED_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 4 - ReadOnly: indicate current UDM pin level
            #[inline(always)]
            pub fn ud_dm_pin__rb_uh_dm_pin(&self) -> UD_DM_PIN__RB_UH_DM_PIN_R {
                UD_DM_PIN__RB_UH_DM_PIN_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - ReadOnly: indicate current UDP pin level
            #[inline(always)]
            pub fn ud_dp_pin__rb_uh_dp_pin(&self) -> UD_DP_PIN__RB_UH_DP_PIN_R {
                UD_DP_PIN__RB_UH_DP_PIN_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 7 - disable USB UDP-UDM pulldown resistance: 0=enable pulldown, 1=disable
            #[inline(always)]
            pub fn ud_pd_dis__rb_uh_pd_dis(&self) -> UD_PD_DIS__RB_UH_PD_DIS_R {
                UD_PD_DIS__RB_UH_PD_DIS_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - enable USB physical port I-O: 0=disable, 1=enable;enable USB port: 0=disable, 1=enable port, automatic disabled if USB device detached
            #[inline(always)]
            #[must_use]
            pub fn ud_port_en__rb_uh_port_en(&mut self) -> UD_PORT_EN__RB_UH_PORT_EN_W<0> {
                UD_PORT_EN__RB_UH_PORT_EN_W::new(self)
            }
            ///Bit 1 - general purpose bit;control USB bus reset: 0=normal, 1=force bus reset
            #[inline(always)]
            #[must_use]
            pub fn ud_gp_bit__rb_uh_bus_reset(&mut self) -> UD_GP_BIT__RB_UH_BUS_RESET_W<1> {
                UD_GP_BIT__RB_UH_BUS_RESET_W::new(self)
            }
            ///Bit 2 - enable USB physical port low speed: 0=full speed, 1=low speed;enable USB port low speed: 0=full speed, 1=low speed
            #[inline(always)]
            #[must_use]
            pub fn ud_low_speed__rb_uh_low_speed(&mut self) -> UD_LOW_SPEED__RB_UH_LOW_SPEED_W<2> {
                UD_LOW_SPEED__RB_UH_LOW_SPEED_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///USB device physical prot control
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [udev_ctrl__r8_uhost_ctrl](index.html) module
        pub struct UDEV_CTRL__R8_UHOST_CTRL_SPEC;
        impl crate::RegisterSpec for UDEV_CTRL__R8_UHOST_CTRL_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [udev_ctrl__r8_uhost_ctrl::R](R) reader structure
        impl crate::Readable for UDEV_CTRL__R8_UHOST_CTRL_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [udev_ctrl__r8_uhost_ctrl::W](W) writer structure
        impl crate::Writable for UDEV_CTRL__R8_UHOST_CTRL_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets UDEV_CTRL__R8_UHOST_CTRL to value 0
        impl crate::Resettable for UDEV_CTRL__R8_UHOST_CTRL_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///USB_INT_EN (rw) register accessor: an alias for `Reg<USB_INT_EN_SPEC>`
    pub type USB_INT_EN = crate::Reg<usb_int_en::USB_INT_EN_SPEC>;
    ///USB interrupt enable
    pub mod usb_int_en {
        ///Register `USB_INT_EN` reader
        pub struct R(crate::R<USB_INT_EN_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<USB_INT_EN_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<USB_INT_EN_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<USB_INT_EN_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `USB_INT_EN` writer
        pub struct W(crate::W<USB_INT_EN_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<USB_INT_EN_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<USB_INT_EN_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<USB_INT_EN_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `UIE_BUS_RST__RB_UIE_DETECT` reader - enable interrupt for USB bus reset event for USB device mode;enable interrupt for USB device detected event for USB host mode
        pub type UIE_BUS_RST__RB_UIE_DETECT_R = crate::BitReader<bool>;
        ///Field `UIE_BUS_RST__RB_UIE_DETECT` writer - enable interrupt for USB bus reset event for USB device mode;enable interrupt for USB device detected event for USB host mode
        pub type UIE_BUS_RST__RB_UIE_DETECT_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, USB_INT_EN_SPEC, bool, O>;
        ///Field `UIE_TRANSFER` reader - enable interrupt for USB transfer completion
        pub type UIE_TRANSFER_R = crate::BitReader<bool>;
        ///Field `UIE_TRANSFER` writer - enable interrupt for USB transfer completion
        pub type UIE_TRANSFER_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, USB_INT_EN_SPEC, bool, O>;
        ///Field `UIE_SUSPEND` reader - enable interrupt for USB suspend or resume event
        pub type UIE_SUSPEND_R = crate::BitReader<bool>;
        ///Field `UIE_SUSPEND` writer - enable interrupt for USB suspend or resume event
        pub type UIE_SUSPEND_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, USB_INT_EN_SPEC, bool, O>;
        ///Field `UIE_HST_SOF` reader - enable interrupt for host SOF timer action for USB host mode
        pub type UIE_HST_SOF_R = crate::BitReader<bool>;
        ///Field `UIE_HST_SOF` writer - enable interrupt for host SOF timer action for USB host mode
        pub type UIE_HST_SOF_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, USB_INT_EN_SPEC, bool, O>;
        ///Field `UIE_FIFO_OV` reader - enable interrupt for FIFO overflow
        pub type UIE_FIFO_OV_R = crate::BitReader<bool>;
        ///Field `UIE_FIFO_OV` writer - enable interrupt for FIFO overflow
        pub type UIE_FIFO_OV_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, USB_INT_EN_SPEC, bool, O>;
        ///Field `UIE_DEV_NAK` reader - enable interrupt for NAK responded for USB device mode
        pub type UIE_DEV_NAK_R = crate::BitReader<bool>;
        ///Field `UIE_DEV_NAK` writer - enable interrupt for NAK responded for USB device mode
        pub type UIE_DEV_NAK_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, USB_INT_EN_SPEC, bool, O>;
        ///Field `UIE_DEV_SOF` reader - enable interrupt for SOF received for USB device mode
        pub type UIE_DEV_SOF_R = crate::BitReader<bool>;
        ///Field `UIE_DEV_SOF` writer - enable interrupt for SOF received for USB device mode
        pub type UIE_DEV_SOF_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, USB_INT_EN_SPEC, bool, O>;
        impl R {
            ///Bit 0 - enable interrupt for USB bus reset event for USB device mode;enable interrupt for USB device detected event for USB host mode
            #[inline(always)]
            pub fn uie_bus_rst__rb_uie_detect(&self) -> UIE_BUS_RST__RB_UIE_DETECT_R {
                UIE_BUS_RST__RB_UIE_DETECT_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - enable interrupt for USB transfer completion
            #[inline(always)]
            pub fn uie_transfer(&self) -> UIE_TRANSFER_R {
                UIE_TRANSFER_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - enable interrupt for USB suspend or resume event
            #[inline(always)]
            pub fn uie_suspend(&self) -> UIE_SUSPEND_R {
                UIE_SUSPEND_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - enable interrupt for host SOF timer action for USB host mode
            #[inline(always)]
            pub fn uie_hst_sof(&self) -> UIE_HST_SOF_R {
                UIE_HST_SOF_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - enable interrupt for FIFO overflow
            #[inline(always)]
            pub fn uie_fifo_ov(&self) -> UIE_FIFO_OV_R {
                UIE_FIFO_OV_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 6 - enable interrupt for NAK responded for USB device mode
            #[inline(always)]
            pub fn uie_dev_nak(&self) -> UIE_DEV_NAK_R {
                UIE_DEV_NAK_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - enable interrupt for SOF received for USB device mode
            #[inline(always)]
            pub fn uie_dev_sof(&self) -> UIE_DEV_SOF_R {
                UIE_DEV_SOF_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - enable interrupt for USB bus reset event for USB device mode;enable interrupt for USB device detected event for USB host mode
            #[inline(always)]
            #[must_use]
            pub fn uie_bus_rst__rb_uie_detect(&mut self) -> UIE_BUS_RST__RB_UIE_DETECT_W<0> {
                UIE_BUS_RST__RB_UIE_DETECT_W::new(self)
            }
            ///Bit 1 - enable interrupt for USB transfer completion
            #[inline(always)]
            #[must_use]
            pub fn uie_transfer(&mut self) -> UIE_TRANSFER_W<1> {
                UIE_TRANSFER_W::new(self)
            }
            ///Bit 2 - enable interrupt for USB suspend or resume event
            #[inline(always)]
            #[must_use]
            pub fn uie_suspend(&mut self) -> UIE_SUSPEND_W<2> {
                UIE_SUSPEND_W::new(self)
            }
            ///Bit 3 - enable interrupt for host SOF timer action for USB host mode
            #[inline(always)]
            #[must_use]
            pub fn uie_hst_sof(&mut self) -> UIE_HST_SOF_W<3> {
                UIE_HST_SOF_W::new(self)
            }
            ///Bit 4 - enable interrupt for FIFO overflow
            #[inline(always)]
            #[must_use]
            pub fn uie_fifo_ov(&mut self) -> UIE_FIFO_OV_W<4> {
                UIE_FIFO_OV_W::new(self)
            }
            ///Bit 6 - enable interrupt for NAK responded for USB device mode
            #[inline(always)]
            #[must_use]
            pub fn uie_dev_nak(&mut self) -> UIE_DEV_NAK_W<6> {
                UIE_DEV_NAK_W::new(self)
            }
            ///Bit 7 - enable interrupt for SOF received for USB device mode
            #[inline(always)]
            #[must_use]
            pub fn uie_dev_sof(&mut self) -> UIE_DEV_SOF_W<7> {
                UIE_DEV_SOF_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///USB interrupt enable
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [usb_int_en](index.html) module
        pub struct USB_INT_EN_SPEC;
        impl crate::RegisterSpec for USB_INT_EN_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [usb_int_en::R](R) reader structure
        impl crate::Readable for USB_INT_EN_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [usb_int_en::W](W) writer structure
        impl crate::Writable for USB_INT_EN_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets USB_INT_EN to value 0
        impl crate::Resettable for USB_INT_EN_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///USB_DEV_AD (rw) register accessor: an alias for `Reg<USB_DEV_AD_SPEC>`
    pub type USB_DEV_AD = crate::Reg<usb_dev_ad::USB_DEV_AD_SPEC>;
    ///USB device address
    pub mod usb_dev_ad {
        ///Register `USB_DEV_AD` reader
        pub struct R(crate::R<USB_DEV_AD_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<USB_DEV_AD_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<USB_DEV_AD_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<USB_DEV_AD_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `USB_DEV_AD` writer
        pub struct W(crate::W<USB_DEV_AD_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<USB_DEV_AD_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<USB_DEV_AD_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<USB_DEV_AD_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `MASK_USB_ADDR` reader - bit mask for USB device address
        pub type MASK_USB_ADDR_R = crate::FieldReader<u8, u8>;
        ///Field `MASK_USB_ADDR` writer - bit mask for USB device address
        pub type MASK_USB_ADDR_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, USB_DEV_AD_SPEC, u8, u8, 7, O>;
        ///Field `UDA_GP_BIT` reader - general purpose bit
        pub type UDA_GP_BIT_R = crate::BitReader<bool>;
        ///Field `UDA_GP_BIT` writer - general purpose bit
        pub type UDA_GP_BIT_W<'a, const O: u8> = crate::BitWriter<'a, u8, USB_DEV_AD_SPEC, bool, O>;
        impl R {
            ///Bits 0:6 - bit mask for USB device address
            #[inline(always)]
            pub fn mask_usb_addr(&self) -> MASK_USB_ADDR_R {
                MASK_USB_ADDR_R::new(self.bits & 0x7f)
            }
            ///Bit 7 - general purpose bit
            #[inline(always)]
            pub fn uda_gp_bit(&self) -> UDA_GP_BIT_R {
                UDA_GP_BIT_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:6 - bit mask for USB device address
            #[inline(always)]
            #[must_use]
            pub fn mask_usb_addr(&mut self) -> MASK_USB_ADDR_W<0> {
                MASK_USB_ADDR_W::new(self)
            }
            ///Bit 7 - general purpose bit
            #[inline(always)]
            #[must_use]
            pub fn uda_gp_bit(&mut self) -> UDA_GP_BIT_W<7> {
                UDA_GP_BIT_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///USB device address
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [usb_dev_ad](index.html) module
        pub struct USB_DEV_AD_SPEC;
        impl crate::RegisterSpec for USB_DEV_AD_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [usb_dev_ad::R](R) reader structure
        impl crate::Readable for USB_DEV_AD_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [usb_dev_ad::W](W) writer structure
        impl crate::Writable for USB_DEV_AD_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets USB_DEV_AD to value 0
        impl crate::Resettable for USB_DEV_AD_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///USB_MIS_ST (r) register accessor: an alias for `Reg<USB_MIS_ST_SPEC>`
    pub type USB_MIS_ST = crate::Reg<usb_mis_st::USB_MIS_ST_SPEC>;
    ///USB miscellaneous status
    pub mod usb_mis_st {
        ///Register `USB_MIS_ST` reader
        pub struct R(crate::R<USB_MIS_ST_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<USB_MIS_ST_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<USB_MIS_ST_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<USB_MIS_ST_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `UMS_DEV_ATTACH` reader - RO, indicate device attached status on USB host
        pub type UMS_DEV_ATTACH_R = crate::BitReader<bool>;
        ///Field `UMS_DM_LEVEL` reader - RO, indicate UDM level saved at device attached to USB host
        pub type UMS_DM_LEVEL_R = crate::BitReader<bool>;
        ///Field `UMS_SUSPEND` reader - RO, indicate USB suspend status
        pub type UMS_SUSPEND_R = crate::BitReader<bool>;
        ///Field `UMS_BUS_RESET` reader - RO, indicate USB bus reset status
        pub type UMS_BUS_RESET_R = crate::BitReader<bool>;
        ///Field `UMS_R_FIFO_RDY` reader - RO, indicate USB receiving FIFO ready status (not empty)
        pub type UMS_R_FIFO_RDY_R = crate::BitReader<bool>;
        ///Field `UMS_SIE_FREE` reader - RO, indicate USB SIE free status
        pub type UMS_SIE_FREE_R = crate::BitReader<bool>;
        ///Field `UMS_SOF_ACT` reader - RO, indicate host SOF timer action status for USB host
        pub type UMS_SOF_ACT_R = crate::BitReader<bool>;
        ///Field `UMS_SOF_PRES` reader - RO, indicate host SOF timer presage status
        pub type UMS_SOF_PRES_R = crate::BitReader<bool>;
        impl R {
            ///Bit 0 - RO, indicate device attached status on USB host
            #[inline(always)]
            pub fn ums_dev_attach(&self) -> UMS_DEV_ATTACH_R {
                UMS_DEV_ATTACH_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RO, indicate UDM level saved at device attached to USB host
            #[inline(always)]
            pub fn ums_dm_level(&self) -> UMS_DM_LEVEL_R {
                UMS_DM_LEVEL_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RO, indicate USB suspend status
            #[inline(always)]
            pub fn ums_suspend(&self) -> UMS_SUSPEND_R {
                UMS_SUSPEND_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RO, indicate USB bus reset status
            #[inline(always)]
            pub fn ums_bus_reset(&self) -> UMS_BUS_RESET_R {
                UMS_BUS_RESET_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RO, indicate USB receiving FIFO ready status (not empty)
            #[inline(always)]
            pub fn ums_r_fifo_rdy(&self) -> UMS_R_FIFO_RDY_R {
                UMS_R_FIFO_RDY_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - RO, indicate USB SIE free status
            #[inline(always)]
            pub fn ums_sie_free(&self) -> UMS_SIE_FREE_R {
                UMS_SIE_FREE_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - RO, indicate host SOF timer action status for USB host
            #[inline(always)]
            pub fn ums_sof_act(&self) -> UMS_SOF_ACT_R {
                UMS_SOF_ACT_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - RO, indicate host SOF timer presage status
            #[inline(always)]
            pub fn ums_sof_pres(&self) -> UMS_SOF_PRES_R {
                UMS_SOF_PRES_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        ///USB miscellaneous status
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [usb_mis_st](index.html) module
        pub struct USB_MIS_ST_SPEC;
        impl crate::RegisterSpec for USB_MIS_ST_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [usb_mis_st::R](R) reader structure
        impl crate::Readable for USB_MIS_ST_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets USB_MIS_ST to value 0
        impl crate::Resettable for USB_MIS_ST_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///USB_INT_FG (rw) register accessor: an alias for `Reg<USB_INT_FG_SPEC>`
    pub type USB_INT_FG = crate::Reg<usb_int_fg::USB_INT_FG_SPEC>;
    ///USB interrupt flag
    pub mod usb_int_fg {
        ///Register `USB_INT_FG` reader
        pub struct R(crate::R<USB_INT_FG_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<USB_INT_FG_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<USB_INT_FG_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<USB_INT_FG_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `USB_INT_FG` writer
        pub struct W(crate::W<USB_INT_FG_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<USB_INT_FG_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<USB_INT_FG_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<USB_INT_FG_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `UIF_BUS_RST__RB_UIF_DETECT` reader - RW,bus reset event interrupt flag for USB device mode, direct bit address clear or write 1 to clear;device detected event interrupt flag for USB host mode, direct bit address clear or write 1 to clear
        pub type UIF_BUS_RST__RB_UIF_DETECT_R = crate::BitReader<bool>;
        ///Field `UIF_BUS_RST__RB_UIF_DETECT` writer - RW,bus reset event interrupt flag for USB device mode, direct bit address clear or write 1 to clear;device detected event interrupt flag for USB host mode, direct bit address clear or write 1 to clear
        pub type UIF_BUS_RST__RB_UIF_DETECT_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, USB_INT_FG_SPEC, bool, O>;
        ///Field `UIF_TRANSFER` reader - RW,USB transfer completion interrupt flag, direct bit address clear or write 1 to clear
        pub type UIF_TRANSFER_R = crate::BitReader<bool>;
        ///Field `UIF_TRANSFER` writer - RW,USB transfer completion interrupt flag, direct bit address clear or write 1 to clear
        pub type UIF_TRANSFER_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, USB_INT_FG_SPEC, bool, O>;
        ///Field `UIF_SUSPEND` reader - RW,USB suspend or resume event interrupt flag, direct bit address clear or write 1 to clear
        pub type UIF_SUSPEND_R = crate::BitReader<bool>;
        ///Field `UIF_SUSPEND` writer - RW,USB suspend or resume event interrupt flag, direct bit address clear or write 1 to clear
        pub type UIF_SUSPEND_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, USB_INT_FG_SPEC, bool, O>;
        ///Field `UIF_HST_SOF` reader - RW,host SOF timer interrupt flag for USB host, direct bit address clear or write 1 to clear
        pub type UIF_HST_SOF_R = crate::BitReader<bool>;
        ///Field `UIF_HST_SOF` writer - RW,host SOF timer interrupt flag for USB host, direct bit address clear or write 1 to clear
        pub type UIF_HST_SOF_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, USB_INT_FG_SPEC, bool, O>;
        ///Field `UIF_FIFO_OV` reader - RW,FIFO overflow interrupt flag for USB, direct bit address clear or write 1 to clear
        pub type UIF_FIFO_OV_R = crate::BitReader<bool>;
        ///Field `UIF_FIFO_OV` writer - RW,FIFO overflow interrupt flag for USB, direct bit address clear or write 1 to clear
        pub type UIF_FIFO_OV_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, USB_INT_FG_SPEC, bool, O>;
        ///Field `U_SIE_FREE` reader - RO, indicate USB SIE free status
        pub type U_SIE_FREE_R = crate::BitReader<bool>;
        ///Field `U_TOG_OK` reader - RO, indicate current USB transfer toggle is OK
        pub type U_TOG_OK_R = crate::BitReader<bool>;
        ///Field `U_IS_NAK` reader - RO, indicate current USB transfer is NAK received
        pub type U_IS_NAK_R = crate::BitReader<bool>;
        impl R {
            ///Bit 0 - RW,bus reset event interrupt flag for USB device mode, direct bit address clear or write 1 to clear;device detected event interrupt flag for USB host mode, direct bit address clear or write 1 to clear
            #[inline(always)]
            pub fn uif_bus_rst__rb_uif_detect(&self) -> UIF_BUS_RST__RB_UIF_DETECT_R {
                UIF_BUS_RST__RB_UIF_DETECT_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RW,USB transfer completion interrupt flag, direct bit address clear or write 1 to clear
            #[inline(always)]
            pub fn uif_transfer(&self) -> UIF_TRANSFER_R {
                UIF_TRANSFER_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RW,USB suspend or resume event interrupt flag, direct bit address clear or write 1 to clear
            #[inline(always)]
            pub fn uif_suspend(&self) -> UIF_SUSPEND_R {
                UIF_SUSPEND_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RW,host SOF timer interrupt flag for USB host, direct bit address clear or write 1 to clear
            #[inline(always)]
            pub fn uif_hst_sof(&self) -> UIF_HST_SOF_R {
                UIF_HST_SOF_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RW,FIFO overflow interrupt flag for USB, direct bit address clear or write 1 to clear
            #[inline(always)]
            pub fn uif_fifo_ov(&self) -> UIF_FIFO_OV_R {
                UIF_FIFO_OV_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - RO, indicate USB SIE free status
            #[inline(always)]
            pub fn u_sie_free(&self) -> U_SIE_FREE_R {
                U_SIE_FREE_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - RO, indicate current USB transfer toggle is OK
            #[inline(always)]
            pub fn u_tog_ok(&self) -> U_TOG_OK_R {
                U_TOG_OK_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - RO, indicate current USB transfer is NAK received
            #[inline(always)]
            pub fn u_is_nak(&self) -> U_IS_NAK_R {
                U_IS_NAK_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RW,bus reset event interrupt flag for USB device mode, direct bit address clear or write 1 to clear;device detected event interrupt flag for USB host mode, direct bit address clear or write 1 to clear
            #[inline(always)]
            #[must_use]
            pub fn uif_bus_rst__rb_uif_detect(&mut self) -> UIF_BUS_RST__RB_UIF_DETECT_W<0> {
                UIF_BUS_RST__RB_UIF_DETECT_W::new(self)
            }
            ///Bit 1 - RW,USB transfer completion interrupt flag, direct bit address clear or write 1 to clear
            #[inline(always)]
            #[must_use]
            pub fn uif_transfer(&mut self) -> UIF_TRANSFER_W<1> {
                UIF_TRANSFER_W::new(self)
            }
            ///Bit 2 - RW,USB suspend or resume event interrupt flag, direct bit address clear or write 1 to clear
            #[inline(always)]
            #[must_use]
            pub fn uif_suspend(&mut self) -> UIF_SUSPEND_W<2> {
                UIF_SUSPEND_W::new(self)
            }
            ///Bit 3 - RW,host SOF timer interrupt flag for USB host, direct bit address clear or write 1 to clear
            #[inline(always)]
            #[must_use]
            pub fn uif_hst_sof(&mut self) -> UIF_HST_SOF_W<3> {
                UIF_HST_SOF_W::new(self)
            }
            ///Bit 4 - RW,FIFO overflow interrupt flag for USB, direct bit address clear or write 1 to clear
            #[inline(always)]
            #[must_use]
            pub fn uif_fifo_ov(&mut self) -> UIF_FIFO_OV_W<4> {
                UIF_FIFO_OV_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///USB interrupt flag
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [usb_int_fg](index.html) module
        pub struct USB_INT_FG_SPEC;
        impl crate::RegisterSpec for USB_INT_FG_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [usb_int_fg::R](R) reader structure
        impl crate::Readable for USB_INT_FG_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [usb_int_fg::W](W) writer structure
        impl crate::Writable for USB_INT_FG_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets USB_INT_FG to value 0x20
        impl crate::Resettable for USB_INT_FG_SPEC {
            const RESET_VALUE: Self::Ux = 0x20;
        }
    }
    ///USB_INT_ST (r) register accessor: an alias for `Reg<USB_INT_ST_SPEC>`
    pub type USB_INT_ST = crate::Reg<usb_int_st::USB_INT_ST_SPEC>;
    ///USB interrupt status
    pub mod usb_int_st {
        ///Register `USB_INT_ST` reader
        pub struct R(crate::R<USB_INT_ST_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<USB_INT_ST_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<USB_INT_ST_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<USB_INT_ST_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `MASK_UIS_H_RES__MASK_UIS_ENDP` reader - RO, bit mask of current transfer handshake response for USB host mode: 0000=no response, time out from device, others=handshake response PID received;RO, bit mask of current transfer endpoint number for USB device mode
        pub type MASK_UIS_H_RES__MASK_UIS_ENDP_R = crate::FieldReader<u8, u8>;
        ///Field `MASK_UIS_TOKEN` reader - RO, bit mask of current token PID code received for USB device mode
        pub type MASK_UIS_TOKEN_R = crate::FieldReader<u8, u8>;
        ///Field `UIS_TOG_OK` reader - RO, indicate current USB transfer toggle is OK
        pub type UIS_TOG_OK_R = crate::BitReader<bool>;
        ///Field `UIS_SETUP_ACT` reader - RO, indicate current USB transfer is NAK received for USB device mode
        pub type UIS_SETUP_ACT_R = crate::BitReader<bool>;
        impl R {
            ///Bits 0:3 - RO, bit mask of current transfer handshake response for USB host mode: 0000=no response, time out from device, others=handshake response PID received;RO, bit mask of current transfer endpoint number for USB device mode
            #[inline(always)]
            pub fn mask_uis_h_res__mask_uis_endp(&self) -> MASK_UIS_H_RES__MASK_UIS_ENDP_R {
                MASK_UIS_H_RES__MASK_UIS_ENDP_R::new(self.bits & 0x0f)
            }
            ///Bits 4:5 - RO, bit mask of current token PID code received for USB device mode
            #[inline(always)]
            pub fn mask_uis_token(&self) -> MASK_UIS_TOKEN_R {
                MASK_UIS_TOKEN_R::new((self.bits >> 4) & 3)
            }
            ///Bit 6 - RO, indicate current USB transfer toggle is OK
            #[inline(always)]
            pub fn uis_tog_ok(&self) -> UIS_TOG_OK_R {
                UIS_TOG_OK_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - RO, indicate current USB transfer is NAK received for USB device mode
            #[inline(always)]
            pub fn uis_setup_act(&self) -> UIS_SETUP_ACT_R {
                UIS_SETUP_ACT_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        ///USB interrupt status
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [usb_int_st](index.html) module
        pub struct USB_INT_ST_SPEC;
        impl crate::RegisterSpec for USB_INT_ST_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [usb_int_st::R](R) reader structure
        impl crate::Readable for USB_INT_ST_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets USB_INT_ST to value 0
        impl crate::Resettable for USB_INT_ST_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///USB_RX_LEN (r) register accessor: an alias for `Reg<USB_RX_LEN_SPEC>`
    pub type USB_RX_LEN = crate::Reg<usb_rx_len::USB_RX_LEN_SPEC>;
    ///USB receiving length
    pub mod usb_rx_len {
        ///Register `USB_RX_LEN` reader
        pub struct R(crate::R<USB_RX_LEN_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<USB_RX_LEN_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<USB_RX_LEN_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<USB_RX_LEN_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `USB_RX_LEN` reader - RO,USB receiving length
        pub type USB_RX_LEN_R = crate::FieldReader<u8, u8>;
        impl R {
            ///Bits 0:7 - RO,USB receiving length
            #[inline(always)]
            pub fn usb_rx_len(&self) -> USB_RX_LEN_R {
                USB_RX_LEN_R::new(self.bits)
            }
        }
        ///USB receiving length
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [usb_rx_len](index.html) module
        pub struct USB_RX_LEN_SPEC;
        impl crate::RegisterSpec for USB_RX_LEN_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [usb_rx_len::R](R) reader structure
        impl crate::Readable for USB_RX_LEN_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets USB_RX_LEN to value 0
        impl crate::Resettable for USB_RX_LEN_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///UEP4_1_MOD (rw) register accessor: an alias for `Reg<UEP4_1_MOD_SPEC>`
    pub type UEP4_1_MOD = crate::Reg<uep4_1_mod::UEP4_1_MOD_SPEC>;
    ///endpoint 4/1 mode
    pub mod uep4_1_mod {
        ///Register `UEP4_1_MOD` reader
        pub struct R(crate::R<UEP4_1_MOD_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<UEP4_1_MOD_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<UEP4_1_MOD_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<UEP4_1_MOD_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `UEP4_1_MOD` writer
        pub struct W(crate::W<UEP4_1_MOD_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<UEP4_1_MOD_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<UEP4_1_MOD_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<UEP4_1_MOD_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `UEP4_TX_EN` reader - enable USB endpoint 4 transmittal (IN)
        pub type UEP4_TX_EN_R = crate::BitReader<bool>;
        ///Field `UEP4_TX_EN` writer - enable USB endpoint 4 transmittal (IN)
        pub type UEP4_TX_EN_W<'a, const O: u8> = crate::BitWriter<'a, u8, UEP4_1_MOD_SPEC, bool, O>;
        ///Field `UEP4_RX_EN` reader - enable USB endpoint 4 receiving (OUT)
        pub type UEP4_RX_EN_R = crate::BitReader<bool>;
        ///Field `UEP4_RX_EN` writer - enable USB endpoint 4 receiving (OUT)
        pub type UEP4_RX_EN_W<'a, const O: u8> = crate::BitWriter<'a, u8, UEP4_1_MOD_SPEC, bool, O>;
        ///Field `UEP1_BUF_MOD` reader - buffer mode of USB endpoint 1
        pub type UEP1_BUF_MOD_R = crate::BitReader<bool>;
        ///Field `UEP1_BUF_MOD` writer - buffer mode of USB endpoint 1
        pub type UEP1_BUF_MOD_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, UEP4_1_MOD_SPEC, bool, O>;
        ///Field `UEP1_TX_EN` reader - enable USB endpoint 1 transmittal (IN)
        pub type UEP1_TX_EN_R = crate::BitReader<bool>;
        ///Field `UEP1_TX_EN` writer - enable USB endpoint 1 transmittal (IN)
        pub type UEP1_TX_EN_W<'a, const O: u8> = crate::BitWriter<'a, u8, UEP4_1_MOD_SPEC, bool, O>;
        ///Field `UEP1_RX_EN` reader - enable USB endpoint 1 receiving (OUT)
        pub type UEP1_RX_EN_R = crate::BitReader<bool>;
        ///Field `UEP1_RX_EN` writer - enable USB endpoint 1 receiving (OUT)
        pub type UEP1_RX_EN_W<'a, const O: u8> = crate::BitWriter<'a, u8, UEP4_1_MOD_SPEC, bool, O>;
        impl R {
            ///Bit 2 - enable USB endpoint 4 transmittal (IN)
            #[inline(always)]
            pub fn uep4_tx_en(&self) -> UEP4_TX_EN_R {
                UEP4_TX_EN_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - enable USB endpoint 4 receiving (OUT)
            #[inline(always)]
            pub fn uep4_rx_en(&self) -> UEP4_RX_EN_R {
                UEP4_RX_EN_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - buffer mode of USB endpoint 1
            #[inline(always)]
            pub fn uep1_buf_mod(&self) -> UEP1_BUF_MOD_R {
                UEP1_BUF_MOD_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 6 - enable USB endpoint 1 transmittal (IN)
            #[inline(always)]
            pub fn uep1_tx_en(&self) -> UEP1_TX_EN_R {
                UEP1_TX_EN_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - enable USB endpoint 1 receiving (OUT)
            #[inline(always)]
            pub fn uep1_rx_en(&self) -> UEP1_RX_EN_R {
                UEP1_RX_EN_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 2 - enable USB endpoint 4 transmittal (IN)
            #[inline(always)]
            #[must_use]
            pub fn uep4_tx_en(&mut self) -> UEP4_TX_EN_W<2> {
                UEP4_TX_EN_W::new(self)
            }
            ///Bit 3 - enable USB endpoint 4 receiving (OUT)
            #[inline(always)]
            #[must_use]
            pub fn uep4_rx_en(&mut self) -> UEP4_RX_EN_W<3> {
                UEP4_RX_EN_W::new(self)
            }
            ///Bit 4 - buffer mode of USB endpoint 1
            #[inline(always)]
            #[must_use]
            pub fn uep1_buf_mod(&mut self) -> UEP1_BUF_MOD_W<4> {
                UEP1_BUF_MOD_W::new(self)
            }
            ///Bit 6 - enable USB endpoint 1 transmittal (IN)
            #[inline(always)]
            #[must_use]
            pub fn uep1_tx_en(&mut self) -> UEP1_TX_EN_W<6> {
                UEP1_TX_EN_W::new(self)
            }
            ///Bit 7 - enable USB endpoint 1 receiving (OUT)
            #[inline(always)]
            #[must_use]
            pub fn uep1_rx_en(&mut self) -> UEP1_RX_EN_W<7> {
                UEP1_RX_EN_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///endpoint 4/1 mode
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [uep4_1_mod](index.html) module
        pub struct UEP4_1_MOD_SPEC;
        impl crate::RegisterSpec for UEP4_1_MOD_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [uep4_1_mod::R](R) reader structure
        impl crate::Readable for UEP4_1_MOD_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [uep4_1_mod::W](W) writer structure
        impl crate::Writable for UEP4_1_MOD_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets UEP4_1_MOD to value 0
        impl crate::Resettable for UEP4_1_MOD_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///UEP2_3_MOD__R8_UH_EP_MOD (rw) register accessor: an alias for `Reg<UEP2_3_MOD__R8_UH_EP_MOD_SPEC>`
    pub type UEP2_3_MOD__R8_UH_EP_MOD =
        crate::Reg<uep2_3_mod__r8_uh_ep_mod::UEP2_3_MOD__R8_UH_EP_MOD_SPEC>;
    ///endpoint 2_3 mode;host endpoint mode
    pub mod uep2_3_mod__r8_uh_ep_mod {
        ///Register `UEP2_3_MOD__R8_UH_EP_MOD` reader
        pub struct R(crate::R<UEP2_3_MOD__R8_UH_EP_MOD_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<UEP2_3_MOD__R8_UH_EP_MOD_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<UEP2_3_MOD__R8_UH_EP_MOD_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<UEP2_3_MOD__R8_UH_EP_MOD_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `UEP2_3_MOD__R8_UH_EP_MOD` writer
        pub struct W(crate::W<UEP2_3_MOD__R8_UH_EP_MOD_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<UEP2_3_MOD__R8_UH_EP_MOD_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<UEP2_3_MOD__R8_UH_EP_MOD_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<UEP2_3_MOD__R8_UH_EP_MOD_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `UEP2_BUF_MOD__RB_UH_EP_RBUF_MOD` reader - buffer mode of USB endpoint 2;buffer mode of USB host IN endpoint
        pub type UEP2_BUF_MOD__RB_UH_EP_RBUF_MOD_R = crate::BitReader<bool>;
        ///Field `UEP2_BUF_MOD__RB_UH_EP_RBUF_MOD` writer - buffer mode of USB endpoint 2;buffer mode of USB host IN endpoint
        pub type UEP2_BUF_MOD__RB_UH_EP_RBUF_MOD_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, UEP2_3_MOD__R8_UH_EP_MOD_SPEC, bool, O>;
        ///Field `UEP2_TX_EN` reader - enable USB endpoint 2 transmittal (IN)
        pub type UEP2_TX_EN_R = crate::BitReader<bool>;
        ///Field `UEP2_TX_EN` writer - enable USB endpoint 2 transmittal (IN)
        pub type UEP2_TX_EN_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, UEP2_3_MOD__R8_UH_EP_MOD_SPEC, bool, O>;
        ///Field `UEP2_RX_EN__RB_UH_EP_RX_EN` reader - enable USB endpoint 2 receiving (OUT);enable USB host IN endpoint receiving
        pub type UEP2_RX_EN__RB_UH_EP_RX_EN_R = crate::BitReader<bool>;
        ///Field `UEP2_RX_EN__RB_UH_EP_RX_EN` writer - enable USB endpoint 2 receiving (OUT);enable USB host IN endpoint receiving
        pub type UEP2_RX_EN__RB_UH_EP_RX_EN_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, UEP2_3_MOD__R8_UH_EP_MOD_SPEC, bool, O>;
        ///Field `UEP3_BUF_MOD__RB_UH_EP_TBUF_MOD` reader - buffer mode of USB endpoint 3;buffer mode of USB host OUT endpoint
        pub type UEP3_BUF_MOD__RB_UH_EP_TBUF_MOD_R = crate::BitReader<bool>;
        ///Field `UEP3_BUF_MOD__RB_UH_EP_TBUF_MOD` writer - buffer mode of USB endpoint 3;buffer mode of USB host OUT endpoint
        pub type UEP3_BUF_MOD__RB_UH_EP_TBUF_MOD_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, UEP2_3_MOD__R8_UH_EP_MOD_SPEC, bool, O>;
        ///Field `UEP3_TX_EN__RB_UH_EP_TX_EN` reader - enable USB endpoint 3 transmittal (IN);enable USB host OUT endpoint transmittal
        pub type UEP3_TX_EN__RB_UH_EP_TX_EN_R = crate::BitReader<bool>;
        ///Field `UEP3_TX_EN__RB_UH_EP_TX_EN` writer - enable USB endpoint 3 transmittal (IN);enable USB host OUT endpoint transmittal
        pub type UEP3_TX_EN__RB_UH_EP_TX_EN_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, UEP2_3_MOD__R8_UH_EP_MOD_SPEC, bool, O>;
        ///Field `UEP3_RX_EN` reader - enable USB endpoint 3 receiving (OUT)
        pub type UEP3_RX_EN_R = crate::BitReader<bool>;
        ///Field `UEP3_RX_EN` writer - enable USB endpoint 3 receiving (OUT)
        pub type UEP3_RX_EN_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, UEP2_3_MOD__R8_UH_EP_MOD_SPEC, bool, O>;
        impl R {
            ///Bit 0 - buffer mode of USB endpoint 2;buffer mode of USB host IN endpoint
            #[inline(always)]
            pub fn uep2_buf_mod__rb_uh_ep_rbuf_mod(&self) -> UEP2_BUF_MOD__RB_UH_EP_RBUF_MOD_R {
                UEP2_BUF_MOD__RB_UH_EP_RBUF_MOD_R::new((self.bits & 1) != 0)
            }
            ///Bit 2 - enable USB endpoint 2 transmittal (IN)
            #[inline(always)]
            pub fn uep2_tx_en(&self) -> UEP2_TX_EN_R {
                UEP2_TX_EN_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - enable USB endpoint 2 receiving (OUT);enable USB host IN endpoint receiving
            #[inline(always)]
            pub fn uep2_rx_en__rb_uh_ep_rx_en(&self) -> UEP2_RX_EN__RB_UH_EP_RX_EN_R {
                UEP2_RX_EN__RB_UH_EP_RX_EN_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - buffer mode of USB endpoint 3;buffer mode of USB host OUT endpoint
            #[inline(always)]
            pub fn uep3_buf_mod__rb_uh_ep_tbuf_mod(&self) -> UEP3_BUF_MOD__RB_UH_EP_TBUF_MOD_R {
                UEP3_BUF_MOD__RB_UH_EP_TBUF_MOD_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 6 - enable USB endpoint 3 transmittal (IN);enable USB host OUT endpoint transmittal
            #[inline(always)]
            pub fn uep3_tx_en__rb_uh_ep_tx_en(&self) -> UEP3_TX_EN__RB_UH_EP_TX_EN_R {
                UEP3_TX_EN__RB_UH_EP_TX_EN_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - enable USB endpoint 3 receiving (OUT)
            #[inline(always)]
            pub fn uep3_rx_en(&self) -> UEP3_RX_EN_R {
                UEP3_RX_EN_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - buffer mode of USB endpoint 2;buffer mode of USB host IN endpoint
            #[inline(always)]
            #[must_use]
            pub fn uep2_buf_mod__rb_uh_ep_rbuf_mod(
                &mut self,
            ) -> UEP2_BUF_MOD__RB_UH_EP_RBUF_MOD_W<0> {
                UEP2_BUF_MOD__RB_UH_EP_RBUF_MOD_W::new(self)
            }
            ///Bit 2 - enable USB endpoint 2 transmittal (IN)
            #[inline(always)]
            #[must_use]
            pub fn uep2_tx_en(&mut self) -> UEP2_TX_EN_W<2> {
                UEP2_TX_EN_W::new(self)
            }
            ///Bit 3 - enable USB endpoint 2 receiving (OUT);enable USB host IN endpoint receiving
            #[inline(always)]
            #[must_use]
            pub fn uep2_rx_en__rb_uh_ep_rx_en(&mut self) -> UEP2_RX_EN__RB_UH_EP_RX_EN_W<3> {
                UEP2_RX_EN__RB_UH_EP_RX_EN_W::new(self)
            }
            ///Bit 4 - buffer mode of USB endpoint 3;buffer mode of USB host OUT endpoint
            #[inline(always)]
            #[must_use]
            pub fn uep3_buf_mod__rb_uh_ep_tbuf_mod(
                &mut self,
            ) -> UEP3_BUF_MOD__RB_UH_EP_TBUF_MOD_W<4> {
                UEP3_BUF_MOD__RB_UH_EP_TBUF_MOD_W::new(self)
            }
            ///Bit 6 - enable USB endpoint 3 transmittal (IN);enable USB host OUT endpoint transmittal
            #[inline(always)]
            #[must_use]
            pub fn uep3_tx_en__rb_uh_ep_tx_en(&mut self) -> UEP3_TX_EN__RB_UH_EP_TX_EN_W<6> {
                UEP3_TX_EN__RB_UH_EP_TX_EN_W::new(self)
            }
            ///Bit 7 - enable USB endpoint 3 receiving (OUT)
            #[inline(always)]
            #[must_use]
            pub fn uep3_rx_en(&mut self) -> UEP3_RX_EN_W<7> {
                UEP3_RX_EN_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///endpoint 2_3 mode;host endpoint mode
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [uep2_3_mod__r8_uh_ep_mod](index.html) module
        pub struct UEP2_3_MOD__R8_UH_EP_MOD_SPEC;
        impl crate::RegisterSpec for UEP2_3_MOD__R8_UH_EP_MOD_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [uep2_3_mod__r8_uh_ep_mod::R](R) reader structure
        impl crate::Readable for UEP2_3_MOD__R8_UH_EP_MOD_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [uep2_3_mod__r8_uh_ep_mod::W](W) writer structure
        impl crate::Writable for UEP2_3_MOD__R8_UH_EP_MOD_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets UEP2_3_MOD__R8_UH_EP_MOD to value 0
        impl crate::Resettable for UEP2_3_MOD__R8_UH_EP_MOD_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///UEP567_MOD (rw) register accessor: an alias for `Reg<UEP567_MOD_SPEC>`
    pub type UEP567_MOD = crate::Reg<uep567_mod::UEP567_MOD_SPEC>;
    ///endpoint 5/6/7 mode
    pub mod uep567_mod {
        ///Register `UEP567_MOD` reader
        pub struct R(crate::R<UEP567_MOD_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<UEP567_MOD_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<UEP567_MOD_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<UEP567_MOD_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `UEP567_MOD` writer
        pub struct W(crate::W<UEP567_MOD_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<UEP567_MOD_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<UEP567_MOD_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<UEP567_MOD_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `UEP5_TX_EN` reader - enable USB endpoint 5 transmittal (IN)
        pub type UEP5_TX_EN_R = crate::BitReader<bool>;
        ///Field `UEP5_TX_EN` writer - enable USB endpoint 5 transmittal (IN)
        pub type UEP5_TX_EN_W<'a, const O: u8> = crate::BitWriter<'a, u8, UEP567_MOD_SPEC, bool, O>;
        ///Field `UEP5_RX_EN` reader - enable USB endpoint 5 receiving (OUT)
        pub type UEP5_RX_EN_R = crate::BitReader<bool>;
        ///Field `UEP5_RX_EN` writer - enable USB endpoint 5 receiving (OUT)
        pub type UEP5_RX_EN_W<'a, const O: u8> = crate::BitWriter<'a, u8, UEP567_MOD_SPEC, bool, O>;
        ///Field `UEP6_TX_EN` reader - enable USB endpoint 6 transmittal (IN)
        pub type UEP6_TX_EN_R = crate::BitReader<bool>;
        ///Field `UEP6_TX_EN` writer - enable USB endpoint 6 transmittal (IN)
        pub type UEP6_TX_EN_W<'a, const O: u8> = crate::BitWriter<'a, u8, UEP567_MOD_SPEC, bool, O>;
        ///Field `UEP6_RX_EN` reader - enable USB endpoint 6 receiving (OUT)
        pub type UEP6_RX_EN_R = crate::BitReader<bool>;
        ///Field `UEP6_RX_EN` writer - enable USB endpoint 6 receiving (OUT)
        pub type UEP6_RX_EN_W<'a, const O: u8> = crate::BitWriter<'a, u8, UEP567_MOD_SPEC, bool, O>;
        ///Field `UEP7_TX_EN` reader - enable USB endpoint 7 transmittal (IN)
        pub type UEP7_TX_EN_R = crate::BitReader<bool>;
        ///Field `UEP7_TX_EN` writer - enable USB endpoint 7 transmittal (IN)
        pub type UEP7_TX_EN_W<'a, const O: u8> = crate::BitWriter<'a, u8, UEP567_MOD_SPEC, bool, O>;
        ///Field `UEP7_RX_EN` reader - enable USB endpoint 7 receiving (OUT)
        pub type UEP7_RX_EN_R = crate::BitReader<bool>;
        ///Field `UEP7_RX_EN` writer - enable USB endpoint 7 receiving (OUT)
        pub type UEP7_RX_EN_W<'a, const O: u8> = crate::BitWriter<'a, u8, UEP567_MOD_SPEC, bool, O>;
        impl R {
            ///Bit 0 - enable USB endpoint 5 transmittal (IN)
            #[inline(always)]
            pub fn uep5_tx_en(&self) -> UEP5_TX_EN_R {
                UEP5_TX_EN_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - enable USB endpoint 5 receiving (OUT)
            #[inline(always)]
            pub fn uep5_rx_en(&self) -> UEP5_RX_EN_R {
                UEP5_RX_EN_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - enable USB endpoint 6 transmittal (IN)
            #[inline(always)]
            pub fn uep6_tx_en(&self) -> UEP6_TX_EN_R {
                UEP6_TX_EN_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - enable USB endpoint 6 receiving (OUT)
            #[inline(always)]
            pub fn uep6_rx_en(&self) -> UEP6_RX_EN_R {
                UEP6_RX_EN_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - enable USB endpoint 7 transmittal (IN)
            #[inline(always)]
            pub fn uep7_tx_en(&self) -> UEP7_TX_EN_R {
                UEP7_TX_EN_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - enable USB endpoint 7 receiving (OUT)
            #[inline(always)]
            pub fn uep7_rx_en(&self) -> UEP7_RX_EN_R {
                UEP7_RX_EN_R::new(((self.bits >> 5) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - enable USB endpoint 5 transmittal (IN)
            #[inline(always)]
            #[must_use]
            pub fn uep5_tx_en(&mut self) -> UEP5_TX_EN_W<0> {
                UEP5_TX_EN_W::new(self)
            }
            ///Bit 1 - enable USB endpoint 5 receiving (OUT)
            #[inline(always)]
            #[must_use]
            pub fn uep5_rx_en(&mut self) -> UEP5_RX_EN_W<1> {
                UEP5_RX_EN_W::new(self)
            }
            ///Bit 2 - enable USB endpoint 6 transmittal (IN)
            #[inline(always)]
            #[must_use]
            pub fn uep6_tx_en(&mut self) -> UEP6_TX_EN_W<2> {
                UEP6_TX_EN_W::new(self)
            }
            ///Bit 3 - enable USB endpoint 6 receiving (OUT)
            #[inline(always)]
            #[must_use]
            pub fn uep6_rx_en(&mut self) -> UEP6_RX_EN_W<3> {
                UEP6_RX_EN_W::new(self)
            }
            ///Bit 4 - enable USB endpoint 7 transmittal (IN)
            #[inline(always)]
            #[must_use]
            pub fn uep7_tx_en(&mut self) -> UEP7_TX_EN_W<4> {
                UEP7_TX_EN_W::new(self)
            }
            ///Bit 5 - enable USB endpoint 7 receiving (OUT)
            #[inline(always)]
            #[must_use]
            pub fn uep7_rx_en(&mut self) -> UEP7_RX_EN_W<5> {
                UEP7_RX_EN_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///endpoint 5/6/7 mode
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [uep567_mod](index.html) module
        pub struct UEP567_MOD_SPEC;
        impl crate::RegisterSpec for UEP567_MOD_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [uep567_mod::R](R) reader structure
        impl crate::Readable for UEP567_MOD_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [uep567_mod::W](W) writer structure
        impl crate::Writable for UEP567_MOD_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets UEP567_MOD to value 0
        impl crate::Resettable for UEP567_MOD_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///UEP0_DMA (rw) register accessor: an alias for `Reg<UEP0_DMA_SPEC>`
    pub type UEP0_DMA = crate::Reg<uep0_dma::UEP0_DMA_SPEC>;
    ///endpoint 0 DMA buffer address
    pub mod uep0_dma {
        ///Register `UEP0_DMA` reader
        pub struct R(crate::R<UEP0_DMA_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<UEP0_DMA_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<UEP0_DMA_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<UEP0_DMA_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `UEP0_DMA` writer
        pub struct W(crate::W<UEP0_DMA_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<UEP0_DMA_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<UEP0_DMA_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<UEP0_DMA_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `UEP0_DMA` reader - RW,endpoint 0 DMA buffer address
        pub type UEP0_DMA_R = crate::FieldReader<u16, u16>;
        ///Field `UEP0_DMA` writer - RW,endpoint 0 DMA buffer address
        pub type UEP0_DMA_W<'a, const O: u8> =
            crate::FieldWriter<'a, u16, UEP0_DMA_SPEC, u16, u16, 16, O>;
        impl R {
            ///Bits 0:15 - RW,endpoint 0 DMA buffer address
            #[inline(always)]
            pub fn uep0_dma(&self) -> UEP0_DMA_R {
                UEP0_DMA_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - RW,endpoint 0 DMA buffer address
            #[inline(always)]
            #[must_use]
            pub fn uep0_dma(&mut self) -> UEP0_DMA_W<0> {
                UEP0_DMA_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///endpoint 0 DMA buffer address
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [uep0_dma](index.html) module
        pub struct UEP0_DMA_SPEC;
        impl crate::RegisterSpec for UEP0_DMA_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [uep0_dma::R](R) reader structure
        impl crate::Readable for UEP0_DMA_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [uep0_dma::W](W) writer structure
        impl crate::Writable for UEP0_DMA_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets UEP0_DMA to value 0
        impl crate::Resettable for UEP0_DMA_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///UEP1_DMA (rw) register accessor: an alias for `Reg<UEP1_DMA_SPEC>`
    pub type UEP1_DMA = crate::Reg<uep1_dma::UEP1_DMA_SPEC>;
    ///endpoint 1 DMA buffer address
    pub mod uep1_dma {
        ///Register `UEP1_DMA` reader
        pub struct R(crate::R<UEP1_DMA_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<UEP1_DMA_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<UEP1_DMA_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<UEP1_DMA_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `UEP1_DMA` writer
        pub struct W(crate::W<UEP1_DMA_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<UEP1_DMA_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<UEP1_DMA_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<UEP1_DMA_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `UEP1_DMA` reader - RW,endpoint 1 DMA buffer address
        pub type UEP1_DMA_R = crate::FieldReader<u16, u16>;
        ///Field `UEP1_DMA` writer - RW,endpoint 1 DMA buffer address
        pub type UEP1_DMA_W<'a, const O: u8> =
            crate::FieldWriter<'a, u16, UEP1_DMA_SPEC, u16, u16, 16, O>;
        impl R {
            ///Bits 0:15 - RW,endpoint 1 DMA buffer address
            #[inline(always)]
            pub fn uep1_dma(&self) -> UEP1_DMA_R {
                UEP1_DMA_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - RW,endpoint 1 DMA buffer address
            #[inline(always)]
            #[must_use]
            pub fn uep1_dma(&mut self) -> UEP1_DMA_W<0> {
                UEP1_DMA_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///endpoint 1 DMA buffer address
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [uep1_dma](index.html) module
        pub struct UEP1_DMA_SPEC;
        impl crate::RegisterSpec for UEP1_DMA_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [uep1_dma::R](R) reader structure
        impl crate::Readable for UEP1_DMA_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [uep1_dma::W](W) writer structure
        impl crate::Writable for UEP1_DMA_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets UEP1_DMA to value 0
        impl crate::Resettable for UEP1_DMA_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///UEP2_DMA__R16_UH_RX_DMA (rw) register accessor: an alias for `Reg<UEP2_DMA__R16_UH_RX_DMA_SPEC>`
    pub type UEP2_DMA__R16_UH_RX_DMA =
        crate::Reg<uep2_dma__r16_uh_rx_dma::UEP2_DMA__R16_UH_RX_DMA_SPEC>;
    ///endpoint 2 DMA buffer address;host rx endpoint buffer high address
    pub mod uep2_dma__r16_uh_rx_dma {
        ///Register `UEP2_DMA__R16_UH_RX_DMA` reader
        pub struct R(crate::R<UEP2_DMA__R16_UH_RX_DMA_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<UEP2_DMA__R16_UH_RX_DMA_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<UEP2_DMA__R16_UH_RX_DMA_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<UEP2_DMA__R16_UH_RX_DMA_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `UEP2_DMA__R16_UH_RX_DMA` writer
        pub struct W(crate::W<UEP2_DMA__R16_UH_RX_DMA_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<UEP2_DMA__R16_UH_RX_DMA_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<UEP2_DMA__R16_UH_RX_DMA_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<UEP2_DMA__R16_UH_RX_DMA_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `UEP2_DMA` reader - RW,endpoint 2 DMA buffer address;host rx endpoint buffer high address
        pub type UEP2_DMA_R = crate::FieldReader<u16, u16>;
        ///Field `UEP2_DMA` writer - RW,endpoint 2 DMA buffer address;host rx endpoint buffer high address
        pub type UEP2_DMA_W<'a, const O: u8> =
            crate::FieldWriter<'a, u16, UEP2_DMA__R16_UH_RX_DMA_SPEC, u16, u16, 16, O>;
        impl R {
            ///Bits 0:15 - RW,endpoint 2 DMA buffer address;host rx endpoint buffer high address
            #[inline(always)]
            pub fn uep2_dma(&self) -> UEP2_DMA_R {
                UEP2_DMA_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - RW,endpoint 2 DMA buffer address;host rx endpoint buffer high address
            #[inline(always)]
            #[must_use]
            pub fn uep2_dma(&mut self) -> UEP2_DMA_W<0> {
                UEP2_DMA_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///endpoint 2 DMA buffer address;host rx endpoint buffer high address
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [uep2_dma__r16_uh_rx_dma](index.html) module
        pub struct UEP2_DMA__R16_UH_RX_DMA_SPEC;
        impl crate::RegisterSpec for UEP2_DMA__R16_UH_RX_DMA_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [uep2_dma__r16_uh_rx_dma::R](R) reader structure
        impl crate::Readable for UEP2_DMA__R16_UH_RX_DMA_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [uep2_dma__r16_uh_rx_dma::W](W) writer structure
        impl crate::Writable for UEP2_DMA__R16_UH_RX_DMA_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets UEP2_DMA__R16_UH_RX_DMA to value 0
        impl crate::Resettable for UEP2_DMA__R16_UH_RX_DMA_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///UEP3_DMA__R16_UH_TX_DMA (rw) register accessor: an alias for `Reg<UEP3_DMA__R16_UH_TX_DMA_SPEC>`
    pub type UEP3_DMA__R16_UH_TX_DMA =
        crate::Reg<uep3_dma__r16_uh_tx_dma::UEP3_DMA__R16_UH_TX_DMA_SPEC>;
    ///endpoint 3 DMA buffer address;host tx endpoint buffer high address
    pub mod uep3_dma__r16_uh_tx_dma {
        ///Register `UEP3_DMA__R16_UH_TX_DMA` reader
        pub struct R(crate::R<UEP3_DMA__R16_UH_TX_DMA_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<UEP3_DMA__R16_UH_TX_DMA_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<UEP3_DMA__R16_UH_TX_DMA_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<UEP3_DMA__R16_UH_TX_DMA_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `UEP3_DMA__R16_UH_TX_DMA` writer
        pub struct W(crate::W<UEP3_DMA__R16_UH_TX_DMA_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<UEP3_DMA__R16_UH_TX_DMA_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<UEP3_DMA__R16_UH_TX_DMA_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<UEP3_DMA__R16_UH_TX_DMA_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `UEP3_DMA` reader - RW,endpoint 3 DMA buffer address;host rx endpoint buffer high address
        pub type UEP3_DMA_R = crate::FieldReader<u16, u16>;
        ///Field `UEP3_DMA` writer - RW,endpoint 3 DMA buffer address;host rx endpoint buffer high address
        pub type UEP3_DMA_W<'a, const O: u8> =
            crate::FieldWriter<'a, u16, UEP3_DMA__R16_UH_TX_DMA_SPEC, u16, u16, 16, O>;
        impl R {
            ///Bits 0:15 - RW,endpoint 3 DMA buffer address;host rx endpoint buffer high address
            #[inline(always)]
            pub fn uep3_dma(&self) -> UEP3_DMA_R {
                UEP3_DMA_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - RW,endpoint 3 DMA buffer address;host rx endpoint buffer high address
            #[inline(always)]
            #[must_use]
            pub fn uep3_dma(&mut self) -> UEP3_DMA_W<0> {
                UEP3_DMA_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///endpoint 3 DMA buffer address;host tx endpoint buffer high address
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [uep3_dma__r16_uh_tx_dma](index.html) module
        pub struct UEP3_DMA__R16_UH_TX_DMA_SPEC;
        impl crate::RegisterSpec for UEP3_DMA__R16_UH_TX_DMA_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [uep3_dma__r16_uh_tx_dma::R](R) reader structure
        impl crate::Readable for UEP3_DMA__R16_UH_TX_DMA_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [uep3_dma__r16_uh_tx_dma::W](W) writer structure
        impl crate::Writable for UEP3_DMA__R16_UH_TX_DMA_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets UEP3_DMA__R16_UH_TX_DMA to value 0
        impl crate::Resettable for UEP3_DMA__R16_UH_TX_DMA_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///UEP5_DMA (rw) register accessor: an alias for `Reg<UEP5_DMA_SPEC>`
    pub type UEP5_DMA = crate::Reg<uep5_dma::UEP5_DMA_SPEC>;
    ///endpoint 5 DMA buffer address
    pub mod uep5_dma {
        ///Register `UEP5_DMA` reader
        pub struct R(crate::R<UEP5_DMA_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<UEP5_DMA_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<UEP5_DMA_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<UEP5_DMA_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `UEP5_DMA` writer
        pub struct W(crate::W<UEP5_DMA_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<UEP5_DMA_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<UEP5_DMA_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<UEP5_DMA_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `UEP5_DMA` reader - RW,endpoint 5 DMA buffer address;host rx endpoint buffer high address
        pub type UEP5_DMA_R = crate::FieldReader<u16, u16>;
        ///Field `UEP5_DMA` writer - RW,endpoint 5 DMA buffer address;host rx endpoint buffer high address
        pub type UEP5_DMA_W<'a, const O: u8> =
            crate::FieldWriter<'a, u16, UEP5_DMA_SPEC, u16, u16, 16, O>;
        impl R {
            ///Bits 0:15 - RW,endpoint 5 DMA buffer address;host rx endpoint buffer high address
            #[inline(always)]
            pub fn uep5_dma(&self) -> UEP5_DMA_R {
                UEP5_DMA_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - RW,endpoint 5 DMA buffer address;host rx endpoint buffer high address
            #[inline(always)]
            #[must_use]
            pub fn uep5_dma(&mut self) -> UEP5_DMA_W<0> {
                UEP5_DMA_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///endpoint 5 DMA buffer address
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [uep5_dma](index.html) module
        pub struct UEP5_DMA_SPEC;
        impl crate::RegisterSpec for UEP5_DMA_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [uep5_dma::R](R) reader structure
        impl crate::Readable for UEP5_DMA_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [uep5_dma::W](W) writer structure
        impl crate::Writable for UEP5_DMA_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets UEP5_DMA to value 0
        impl crate::Resettable for UEP5_DMA_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///UEP6_DMA (rw) register accessor: an alias for `Reg<UEP6_DMA_SPEC>`
    pub type UEP6_DMA = crate::Reg<uep6_dma::UEP6_DMA_SPEC>;
    ///endpoint 6 DMA buffer address
    pub mod uep6_dma {
        ///Register `UEP6_DMA` reader
        pub struct R(crate::R<UEP6_DMA_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<UEP6_DMA_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<UEP6_DMA_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<UEP6_DMA_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `UEP6_DMA` writer
        pub struct W(crate::W<UEP6_DMA_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<UEP6_DMA_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<UEP6_DMA_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<UEP6_DMA_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `UEP6_DMA` reader - RW,endpoint 6 DMA buffer address;host rx endpoint buffer high address
        pub type UEP6_DMA_R = crate::FieldReader<u16, u16>;
        ///Field `UEP6_DMA` writer - RW,endpoint 6 DMA buffer address;host rx endpoint buffer high address
        pub type UEP6_DMA_W<'a, const O: u8> =
            crate::FieldWriter<'a, u16, UEP6_DMA_SPEC, u16, u16, 16, O>;
        impl R {
            ///Bits 0:15 - RW,endpoint 6 DMA buffer address;host rx endpoint buffer high address
            #[inline(always)]
            pub fn uep6_dma(&self) -> UEP6_DMA_R {
                UEP6_DMA_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - RW,endpoint 6 DMA buffer address;host rx endpoint buffer high address
            #[inline(always)]
            #[must_use]
            pub fn uep6_dma(&mut self) -> UEP6_DMA_W<0> {
                UEP6_DMA_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///endpoint 6 DMA buffer address
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [uep6_dma](index.html) module
        pub struct UEP6_DMA_SPEC;
        impl crate::RegisterSpec for UEP6_DMA_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [uep6_dma::R](R) reader structure
        impl crate::Readable for UEP6_DMA_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [uep6_dma::W](W) writer structure
        impl crate::Writable for UEP6_DMA_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets UEP6_DMA to value 0
        impl crate::Resettable for UEP6_DMA_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///UEP7_DMA (rw) register accessor: an alias for `Reg<UEP7_DMA_SPEC>`
    pub type UEP7_DMA = crate::Reg<uep7_dma::UEP7_DMA_SPEC>;
    ///endpoint 7 DMA buffer address
    pub mod uep7_dma {
        ///Register `UEP7_DMA` reader
        pub struct R(crate::R<UEP7_DMA_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<UEP7_DMA_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<UEP7_DMA_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<UEP7_DMA_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `UEP7_DMA` writer
        pub struct W(crate::W<UEP7_DMA_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<UEP7_DMA_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<UEP7_DMA_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<UEP7_DMA_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `UEP7_DMA` reader - RW,endpoint 7 DMA buffer address;host rx endpoint buffer high address
        pub type UEP7_DMA_R = crate::FieldReader<u16, u16>;
        ///Field `UEP7_DMA` writer - RW,endpoint 7 DMA buffer address;host rx endpoint buffer high address
        pub type UEP7_DMA_W<'a, const O: u8> =
            crate::FieldWriter<'a, u16, UEP7_DMA_SPEC, u16, u16, 16, O>;
        impl R {
            ///Bits 0:15 - RW,endpoint 7 DMA buffer address;host rx endpoint buffer high address
            #[inline(always)]
            pub fn uep7_dma(&self) -> UEP7_DMA_R {
                UEP7_DMA_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - RW,endpoint 7 DMA buffer address;host rx endpoint buffer high address
            #[inline(always)]
            #[must_use]
            pub fn uep7_dma(&mut self) -> UEP7_DMA_W<0> {
                UEP7_DMA_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///endpoint 7 DMA buffer address
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [uep7_dma](index.html) module
        pub struct UEP7_DMA_SPEC;
        impl crate::RegisterSpec for UEP7_DMA_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [uep7_dma::R](R) reader structure
        impl crate::Readable for UEP7_DMA_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [uep7_dma::W](W) writer structure
        impl crate::Writable for UEP7_DMA_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets UEP7_DMA to value 0
        impl crate::Resettable for UEP7_DMA_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///UEP0_T_LEN (rw) register accessor: an alias for `Reg<UEP0_T_LEN_SPEC>`
    pub type UEP0_T_LEN = crate::Reg<uep0_t_len::UEP0_T_LEN_SPEC>;
    ///endpoint 0 transmittal length
    pub mod uep0_t_len {
        ///Register `UEP0_T_LEN` reader
        pub struct R(crate::R<UEP0_T_LEN_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<UEP0_T_LEN_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<UEP0_T_LEN_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<UEP0_T_LEN_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `UEP0_T_LEN` writer
        pub struct W(crate::W<UEP0_T_LEN_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<UEP0_T_LEN_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<UEP0_T_LEN_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<UEP0_T_LEN_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `UEP0_T_LEN` reader - endpoint 0 transmittal length
        pub type UEP0_T_LEN_R = crate::FieldReader<u8, u8>;
        ///Field `UEP0_T_LEN` writer - endpoint 0 transmittal length
        pub type UEP0_T_LEN_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, UEP0_T_LEN_SPEC, u8, u8, 8, O>;
        impl R {
            ///Bits 0:7 - endpoint 0 transmittal length
            #[inline(always)]
            pub fn uep0_t_len(&self) -> UEP0_T_LEN_R {
                UEP0_T_LEN_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:7 - endpoint 0 transmittal length
            #[inline(always)]
            #[must_use]
            pub fn uep0_t_len(&mut self) -> UEP0_T_LEN_W<0> {
                UEP0_T_LEN_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///endpoint 0 transmittal length
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [uep0_t_len](index.html) module
        pub struct UEP0_T_LEN_SPEC;
        impl crate::RegisterSpec for UEP0_T_LEN_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [uep0_t_len::R](R) reader structure
        impl crate::Readable for UEP0_T_LEN_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [uep0_t_len::W](W) writer structure
        impl crate::Writable for UEP0_T_LEN_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets UEP0_T_LEN to value 0
        impl crate::Resettable for UEP0_T_LEN_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///UEP0_CTRL (rw) register accessor: an alias for `Reg<UEP0_CTRL_SPEC>`
    pub type UEP0_CTRL = crate::Reg<uep0_ctrl::UEP0_CTRL_SPEC>;
    ///endpoint 0 control
    pub mod uep0_ctrl {
        ///Register `UEP0_CTRL` reader
        pub struct R(crate::R<UEP0_CTRL_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<UEP0_CTRL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<UEP0_CTRL_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<UEP0_CTRL_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `UEP0_CTRL` writer
        pub struct W(crate::W<UEP0_CTRL_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<UEP0_CTRL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<UEP0_CTRL_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<UEP0_CTRL_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `MASK_UEP_T_RES` reader - bit mask of handshake response type for USB endpoint X transmittal (IN)
        pub type MASK_UEP_T_RES_R = crate::FieldReader<u8, u8>;
        ///Field `MASK_UEP_T_RES` writer - bit mask of handshake response type for USB endpoint X transmittal (IN)
        pub type MASK_UEP_T_RES_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, UEP0_CTRL_SPEC, u8, u8, 2, O>;
        ///Field `MASK_UEP_R_RES` reader - bit mask of handshake response type for USB endpoint X receiving (OUT)
        pub type MASK_UEP_R_RES_R = crate::FieldReader<u8, u8>;
        ///Field `MASK_UEP_R_RES` writer - bit mask of handshake response type for USB endpoint X receiving (OUT)
        pub type MASK_UEP_R_RES_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, UEP0_CTRL_SPEC, u8, u8, 2, O>;
        ///Field `UEP_AUTO_TOG` reader - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
        pub type UEP_AUTO_TOG_R = crate::BitReader<bool>;
        ///Field `UEP_AUTO_TOG` writer - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
        pub type UEP_AUTO_TOG_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, UEP0_CTRL_SPEC, bool, O>;
        ///Field `UEP_T_TOG` reader - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
        pub type UEP_T_TOG_R = crate::BitReader<bool>;
        ///Field `UEP_T_TOG` writer - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
        pub type UEP_T_TOG_W<'a, const O: u8> = crate::BitWriter<'a, u8, UEP0_CTRL_SPEC, bool, O>;
        ///Field `UEP_R_TOG` reader - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
        pub type UEP_R_TOG_R = crate::BitReader<bool>;
        ///Field `UEP_R_TOG` writer - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
        pub type UEP_R_TOG_W<'a, const O: u8> = crate::BitWriter<'a, u8, UEP0_CTRL_SPEC, bool, O>;
        impl R {
            ///Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)
            #[inline(always)]
            pub fn mask_uep_t_res(&self) -> MASK_UEP_T_RES_R {
                MASK_UEP_T_RES_R::new(self.bits & 3)
            }
            ///Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)
            #[inline(always)]
            pub fn mask_uep_r_res(&self) -> MASK_UEP_R_RES_R {
                MASK_UEP_R_RES_R::new((self.bits >> 2) & 3)
            }
            ///Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
            #[inline(always)]
            pub fn uep_auto_tog(&self) -> UEP_AUTO_TOG_R {
                UEP_AUTO_TOG_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
            #[inline(always)]
            pub fn uep_t_tog(&self) -> UEP_T_TOG_R {
                UEP_T_TOG_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
            #[inline(always)]
            pub fn uep_r_tog(&self) -> UEP_R_TOG_R {
                UEP_R_TOG_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)
            #[inline(always)]
            #[must_use]
            pub fn mask_uep_t_res(&mut self) -> MASK_UEP_T_RES_W<0> {
                MASK_UEP_T_RES_W::new(self)
            }
            ///Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)
            #[inline(always)]
            #[must_use]
            pub fn mask_uep_r_res(&mut self) -> MASK_UEP_R_RES_W<2> {
                MASK_UEP_R_RES_W::new(self)
            }
            ///Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
            #[inline(always)]
            #[must_use]
            pub fn uep_auto_tog(&mut self) -> UEP_AUTO_TOG_W<4> {
                UEP_AUTO_TOG_W::new(self)
            }
            ///Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
            #[inline(always)]
            #[must_use]
            pub fn uep_t_tog(&mut self) -> UEP_T_TOG_W<6> {
                UEP_T_TOG_W::new(self)
            }
            ///Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
            #[inline(always)]
            #[must_use]
            pub fn uep_r_tog(&mut self) -> UEP_R_TOG_W<7> {
                UEP_R_TOG_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///endpoint 0 control
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [uep0_ctrl](index.html) module
        pub struct UEP0_CTRL_SPEC;
        impl crate::RegisterSpec for UEP0_CTRL_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [uep0_ctrl::R](R) reader structure
        impl crate::Readable for UEP0_CTRL_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [uep0_ctrl::W](W) writer structure
        impl crate::Writable for UEP0_CTRL_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets UEP0_CTRL to value 0
        impl crate::Resettable for UEP0_CTRL_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///UEP1_T_LEN (rw) register accessor: an alias for `Reg<UEP1_T_LEN_SPEC>`
    pub type UEP1_T_LEN = crate::Reg<uep1_t_len::UEP1_T_LEN_SPEC>;
    ///endpoint 1 transmittal length
    pub mod uep1_t_len {
        ///Register `UEP1_T_LEN` reader
        pub struct R(crate::R<UEP1_T_LEN_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<UEP1_T_LEN_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<UEP1_T_LEN_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<UEP1_T_LEN_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `UEP1_T_LEN` writer
        pub struct W(crate::W<UEP1_T_LEN_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<UEP1_T_LEN_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<UEP1_T_LEN_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<UEP1_T_LEN_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `UEP1_T_LEN` reader - endpoint 1 transmittal length
        pub type UEP1_T_LEN_R = crate::FieldReader<u8, u8>;
        ///Field `UEP1_T_LEN` writer - endpoint 1 transmittal length
        pub type UEP1_T_LEN_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, UEP1_T_LEN_SPEC, u8, u8, 8, O>;
        impl R {
            ///Bits 0:7 - endpoint 1 transmittal length
            #[inline(always)]
            pub fn uep1_t_len(&self) -> UEP1_T_LEN_R {
                UEP1_T_LEN_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:7 - endpoint 1 transmittal length
            #[inline(always)]
            #[must_use]
            pub fn uep1_t_len(&mut self) -> UEP1_T_LEN_W<0> {
                UEP1_T_LEN_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///endpoint 1 transmittal length
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [uep1_t_len](index.html) module
        pub struct UEP1_T_LEN_SPEC;
        impl crate::RegisterSpec for UEP1_T_LEN_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [uep1_t_len::R](R) reader structure
        impl crate::Readable for UEP1_T_LEN_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [uep1_t_len::W](W) writer structure
        impl crate::Writable for UEP1_T_LEN_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets UEP1_T_LEN to value 0
        impl crate::Resettable for UEP1_T_LEN_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///UEP1_CTRL__R8_UH_SETUP (rw) register accessor: an alias for `Reg<UEP1_CTRL__R8_UH_SETUP_SPEC>`
    pub type UEP1_CTRL__R8_UH_SETUP =
        crate::Reg<uep1_ctrl__r8_uh_setup::UEP1_CTRL__R8_UH_SETUP_SPEC>;
    ///endpoint 1 control;host aux setup
    pub mod uep1_ctrl__r8_uh_setup {
        ///Register `UEP1_CTRL__R8_UH_SETUP` reader
        pub struct R(crate::R<UEP1_CTRL__R8_UH_SETUP_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<UEP1_CTRL__R8_UH_SETUP_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<UEP1_CTRL__R8_UH_SETUP_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<UEP1_CTRL__R8_UH_SETUP_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `UEP1_CTRL__R8_UH_SETUP` writer
        pub struct W(crate::W<UEP1_CTRL__R8_UH_SETUP_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<UEP1_CTRL__R8_UH_SETUP_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<UEP1_CTRL__R8_UH_SETUP_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<UEP1_CTRL__R8_UH_SETUP_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `MASK_UEP_T_RES` reader - bit mask of handshake response type for USB endpoint X transmittal (IN)
        pub type MASK_UEP_T_RES_R = crate::FieldReader<u8, u8>;
        ///Field `MASK_UEP_T_RES` writer - bit mask of handshake response type for USB endpoint X transmittal (IN)
        pub type MASK_UEP_T_RES_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, UEP1_CTRL__R8_UH_SETUP_SPEC, u8, u8, 2, O>;
        ///Field `MASK_UEP_R_RES` reader - bit mask of handshake response type for USB endpoint X receiving (OUT)
        pub type MASK_UEP_R_RES_R = crate::FieldReader<u8, u8>;
        ///Field `MASK_UEP_R_RES` writer - bit mask of handshake response type for USB endpoint X receiving (OUT)
        pub type MASK_UEP_R_RES_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, UEP1_CTRL__R8_UH_SETUP_SPEC, u8, u8, 2, O>;
        ///Field `UEP_AUTO_TOG` reader - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
        pub type UEP_AUTO_TOG_R = crate::BitReader<bool>;
        ///Field `UEP_AUTO_TOG` writer - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
        pub type UEP_AUTO_TOG_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, UEP1_CTRL__R8_UH_SETUP_SPEC, bool, O>;
        ///Field `UEP_T_TOG__RB_UH_SOF_EN` reader - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1;USB host automatic SOF enable
        pub type UEP_T_TOG__RB_UH_SOF_EN_R = crate::BitReader<bool>;
        ///Field `UEP_T_TOG__RB_UH_SOF_EN` writer - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1;USB host automatic SOF enable
        pub type UEP_T_TOG__RB_UH_SOF_EN_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, UEP1_CTRL__R8_UH_SETUP_SPEC, bool, O>;
        ///Field `UEP_R_TOG__RB_UH_PRE_PID_EN` reader - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1;RB_UH_PRE_PID_EN;USB host PRE PID enable for low speed device via hub
        pub type UEP_R_TOG__RB_UH_PRE_PID_EN_R = crate::BitReader<bool>;
        ///Field `UEP_R_TOG__RB_UH_PRE_PID_EN` writer - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1;RB_UH_PRE_PID_EN;USB host PRE PID enable for low speed device via hub
        pub type UEP_R_TOG__RB_UH_PRE_PID_EN_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, UEP1_CTRL__R8_UH_SETUP_SPEC, bool, O>;
        impl R {
            ///Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)
            #[inline(always)]
            pub fn mask_uep_t_res(&self) -> MASK_UEP_T_RES_R {
                MASK_UEP_T_RES_R::new(self.bits & 3)
            }
            ///Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)
            #[inline(always)]
            pub fn mask_uep_r_res(&self) -> MASK_UEP_R_RES_R {
                MASK_UEP_R_RES_R::new((self.bits >> 2) & 3)
            }
            ///Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
            #[inline(always)]
            pub fn uep_auto_tog(&self) -> UEP_AUTO_TOG_R {
                UEP_AUTO_TOG_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1;USB host automatic SOF enable
            #[inline(always)]
            pub fn uep_t_tog__rb_uh_sof_en(&self) -> UEP_T_TOG__RB_UH_SOF_EN_R {
                UEP_T_TOG__RB_UH_SOF_EN_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1;RB_UH_PRE_PID_EN;USB host PRE PID enable for low speed device via hub
            #[inline(always)]
            pub fn uep_r_tog__rb_uh_pre_pid_en(&self) -> UEP_R_TOG__RB_UH_PRE_PID_EN_R {
                UEP_R_TOG__RB_UH_PRE_PID_EN_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)
            #[inline(always)]
            #[must_use]
            pub fn mask_uep_t_res(&mut self) -> MASK_UEP_T_RES_W<0> {
                MASK_UEP_T_RES_W::new(self)
            }
            ///Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)
            #[inline(always)]
            #[must_use]
            pub fn mask_uep_r_res(&mut self) -> MASK_UEP_R_RES_W<2> {
                MASK_UEP_R_RES_W::new(self)
            }
            ///Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
            #[inline(always)]
            #[must_use]
            pub fn uep_auto_tog(&mut self) -> UEP_AUTO_TOG_W<4> {
                UEP_AUTO_TOG_W::new(self)
            }
            ///Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1;USB host automatic SOF enable
            #[inline(always)]
            #[must_use]
            pub fn uep_t_tog__rb_uh_sof_en(&mut self) -> UEP_T_TOG__RB_UH_SOF_EN_W<6> {
                UEP_T_TOG__RB_UH_SOF_EN_W::new(self)
            }
            ///Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1;RB_UH_PRE_PID_EN;USB host PRE PID enable for low speed device via hub
            #[inline(always)]
            #[must_use]
            pub fn uep_r_tog__rb_uh_pre_pid_en(&mut self) -> UEP_R_TOG__RB_UH_PRE_PID_EN_W<7> {
                UEP_R_TOG__RB_UH_PRE_PID_EN_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///endpoint 1 control;host aux setup
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [uep1_ctrl__r8_uh_setup](index.html) module
        pub struct UEP1_CTRL__R8_UH_SETUP_SPEC;
        impl crate::RegisterSpec for UEP1_CTRL__R8_UH_SETUP_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [uep1_ctrl__r8_uh_setup::R](R) reader structure
        impl crate::Readable for UEP1_CTRL__R8_UH_SETUP_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [uep1_ctrl__r8_uh_setup::W](W) writer structure
        impl crate::Writable for UEP1_CTRL__R8_UH_SETUP_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets UEP1_CTRL__R8_UH_SETUP to value 0
        impl crate::Resettable for UEP1_CTRL__R8_UH_SETUP_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///UEP2_T_LEN_R8_UH_EP_PID (rw) register accessor: an alias for `Reg<UEP2_T_LEN_R8_UH_EP_PID_SPEC>`
    pub type UEP2_T_LEN_R8_UH_EP_PID =
        crate::Reg<uep2_t_len_r8_uh_ep_pid::UEP2_T_LEN_R8_UH_EP_PID_SPEC>;
    ///endpoint 2 transmittal length;host endpoint and PID
    pub mod uep2_t_len_r8_uh_ep_pid {
        ///Register `UEP2_T_LEN_R8_UH_EP_PID` reader
        pub struct R(crate::R<UEP2_T_LEN_R8_UH_EP_PID_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<UEP2_T_LEN_R8_UH_EP_PID_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<UEP2_T_LEN_R8_UH_EP_PID_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<UEP2_T_LEN_R8_UH_EP_PID_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `UEP2_T_LEN_R8_UH_EP_PID` writer
        pub struct W(crate::W<UEP2_T_LEN_R8_UH_EP_PID_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<UEP2_T_LEN_R8_UH_EP_PID_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<UEP2_T_LEN_R8_UH_EP_PID_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<UEP2_T_LEN_R8_UH_EP_PID_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `MASK_UH_ENDP` reader - bit mask of endpoint number for USB host transfer
        pub type MASK_UH_ENDP_R = crate::FieldReader<u8, u8>;
        ///Field `MASK_UH_ENDP` writer - bit mask of endpoint number for USB host transfer
        pub type MASK_UH_ENDP_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, UEP2_T_LEN_R8_UH_EP_PID_SPEC, u8, u8, 4, O>;
        ///Field `UEP2_T_LEN` reader - endpoint 2 transmittal length;
        pub type UEP2_T_LEN_R = crate::FieldReader<u8, u8>;
        ///Field `UEP2_T_LEN` writer - endpoint 2 transmittal length;
        pub type UEP2_T_LEN_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, UEP2_T_LEN_R8_UH_EP_PID_SPEC, u8, u8, 8, O>;
        ///Field `MASK_UH_TOKEN` reader - bit mask of token PID for USB host transfer
        pub type MASK_UH_TOKEN_R = crate::FieldReader<u8, u8>;
        ///Field `MASK_UH_TOKEN` writer - bit mask of token PID for USB host transfer
        pub type MASK_UH_TOKEN_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, UEP2_T_LEN_R8_UH_EP_PID_SPEC, u8, u8, 4, O>;
        impl R {
            ///Bits 0:3 - bit mask of endpoint number for USB host transfer
            #[inline(always)]
            pub fn mask_uh_endp(&self) -> MASK_UH_ENDP_R {
                MASK_UH_ENDP_R::new(self.bits & 0x0f)
            }
            ///Bits 0:7 - endpoint 2 transmittal length;
            #[inline(always)]
            pub fn uep2_t_len(&self) -> UEP2_T_LEN_R {
                UEP2_T_LEN_R::new(self.bits)
            }
            ///Bits 4:7 - bit mask of token PID for USB host transfer
            #[inline(always)]
            pub fn mask_uh_token(&self) -> MASK_UH_TOKEN_R {
                MASK_UH_TOKEN_R::new((self.bits >> 4) & 0x0f)
            }
        }
        impl W {
            ///Bits 0:3 - bit mask of endpoint number for USB host transfer
            #[inline(always)]
            #[must_use]
            pub fn mask_uh_endp(&mut self) -> MASK_UH_ENDP_W<0> {
                MASK_UH_ENDP_W::new(self)
            }
            ///Bits 0:7 - endpoint 2 transmittal length;
            #[inline(always)]
            #[must_use]
            pub fn uep2_t_len(&mut self) -> UEP2_T_LEN_W<0> {
                UEP2_T_LEN_W::new(self)
            }
            ///Bits 4:7 - bit mask of token PID for USB host transfer
            #[inline(always)]
            #[must_use]
            pub fn mask_uh_token(&mut self) -> MASK_UH_TOKEN_W<4> {
                MASK_UH_TOKEN_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///endpoint 2 transmittal length;host endpoint and PID
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [uep2_t_len_r8_uh_ep_pid](index.html) module
        pub struct UEP2_T_LEN_R8_UH_EP_PID_SPEC;
        impl crate::RegisterSpec for UEP2_T_LEN_R8_UH_EP_PID_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [uep2_t_len_r8_uh_ep_pid::R](R) reader structure
        impl crate::Readable for UEP2_T_LEN_R8_UH_EP_PID_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [uep2_t_len_r8_uh_ep_pid::W](W) writer structure
        impl crate::Writable for UEP2_T_LEN_R8_UH_EP_PID_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets UEP2_T_LEN_R8_UH_EP_PID to value 0
        impl crate::Resettable for UEP2_T_LEN_R8_UH_EP_PID_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///UEP2_CTRL_R8_UH_RX_CTRL (rw) register accessor: an alias for `Reg<UEP2_CTRL_R8_UH_RX_CTRL_SPEC>`
    pub type UEP2_CTRL_R8_UH_RX_CTRL =
        crate::Reg<uep2_ctrl_r8_uh_rx_ctrl::UEP2_CTRL_R8_UH_RX_CTRL_SPEC>;
    ///endpoint 2 control;host receiver endpoint control
    pub mod uep2_ctrl_r8_uh_rx_ctrl {
        ///Register `UEP2_CTRL_R8_UH_RX_CTRL` reader
        pub struct R(crate::R<UEP2_CTRL_R8_UH_RX_CTRL_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<UEP2_CTRL_R8_UH_RX_CTRL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<UEP2_CTRL_R8_UH_RX_CTRL_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<UEP2_CTRL_R8_UH_RX_CTRL_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `UEP2_CTRL_R8_UH_RX_CTRL` writer
        pub struct W(crate::W<UEP2_CTRL_R8_UH_RX_CTRL_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<UEP2_CTRL_R8_UH_RX_CTRL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<UEP2_CTRL_R8_UH_RX_CTRL_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<UEP2_CTRL_R8_UH_RX_CTRL_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `MASK_UEP_T_RES` reader - bit mask of handshake response type for USB endpoint X transmittal (IN)
        pub type MASK_UEP_T_RES_R = crate::FieldReader<u8, u8>;
        ///Field `MASK_UEP_T_RES` writer - bit mask of handshake response type for USB endpoint X transmittal (IN)
        pub type MASK_UEP_T_RES_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, UEP2_CTRL_R8_UH_RX_CTRL_SPEC, u8, u8, 2, O>;
        ///Field `MASK_UH_R_RES` reader - bit mask of handshake response type for USB endpoint X receiving (OUT)
        pub type MASK_UH_R_RES_R = crate::BitReader<bool>;
        ///Field `MASK_UH_R_RES` writer - bit mask of handshake response type for USB endpoint X receiving (OUT)
        pub type MASK_UH_R_RES_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, UEP2_CTRL_R8_UH_RX_CTRL_SPEC, bool, O>;
        ///Field `MASK_UEP_R_RES` reader - bit mask of handshake response type for USB endpoint X receiving (OUT)
        pub type MASK_UEP_R_RES_R = crate::FieldReader<u8, u8>;
        ///Field `MASK_UEP_R_RES` writer - bit mask of handshake response type for USB endpoint X receiving (OUT)
        pub type MASK_UEP_R_RES_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, UEP2_CTRL_R8_UH_RX_CTRL_SPEC, u8, u8, 2, O>;
        ///Field `UEP_AUTO_TOG__RB_UH_R_AUTO_TOG` reader - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle;enable automatic toggle after successful transfer completion: 0=manual toggle, 1=automatic toggle
        pub type UEP_AUTO_TOG__RB_UH_R_AUTO_TOG_R = crate::BitReader<bool>;
        ///Field `UEP_AUTO_TOG__RB_UH_R_AUTO_TOG` writer - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle;enable automatic toggle after successful transfer completion: 0=manual toggle, 1=automatic toggle
        pub type UEP_AUTO_TOG__RB_UH_R_AUTO_TOG_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, UEP2_CTRL_R8_UH_RX_CTRL_SPEC, bool, O>;
        ///Field `UEP_T_TOG` reader - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
        pub type UEP_T_TOG_R = crate::BitReader<bool>;
        ///Field `UEP_T_TOG` writer - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
        pub type UEP_T_TOG_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, UEP2_CTRL_R8_UH_RX_CTRL_SPEC, bool, O>;
        ///Field `UEP_R_TOG__RB_UH_R_TOG` reader - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1;expected data toggle flag of host receiving (IN): 0=DATA0, 1=DATA1
        pub type UEP_R_TOG__RB_UH_R_TOG_R = crate::BitReader<bool>;
        ///Field `UEP_R_TOG__RB_UH_R_TOG` writer - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1;expected data toggle flag of host receiving (IN): 0=DATA0, 1=DATA1
        pub type UEP_R_TOG__RB_UH_R_TOG_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, UEP2_CTRL_R8_UH_RX_CTRL_SPEC, bool, O>;
        impl R {
            ///Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)
            #[inline(always)]
            pub fn mask_uep_t_res(&self) -> MASK_UEP_T_RES_R {
                MASK_UEP_T_RES_R::new(self.bits & 3)
            }
            ///Bit 2 - bit mask of handshake response type for USB endpoint X receiving (OUT)
            #[inline(always)]
            pub fn mask_uh_r_res(&self) -> MASK_UH_R_RES_R {
                MASK_UH_R_RES_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)
            #[inline(always)]
            pub fn mask_uep_r_res(&self) -> MASK_UEP_R_RES_R {
                MASK_UEP_R_RES_R::new((self.bits >> 2) & 3)
            }
            ///Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle;enable automatic toggle after successful transfer completion: 0=manual toggle, 1=automatic toggle
            #[inline(always)]
            pub fn uep_auto_tog__rb_uh_r_auto_tog(&self) -> UEP_AUTO_TOG__RB_UH_R_AUTO_TOG_R {
                UEP_AUTO_TOG__RB_UH_R_AUTO_TOG_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
            #[inline(always)]
            pub fn uep_t_tog(&self) -> UEP_T_TOG_R {
                UEP_T_TOG_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1;expected data toggle flag of host receiving (IN): 0=DATA0, 1=DATA1
            #[inline(always)]
            pub fn uep_r_tog__rb_uh_r_tog(&self) -> UEP_R_TOG__RB_UH_R_TOG_R {
                UEP_R_TOG__RB_UH_R_TOG_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)
            #[inline(always)]
            #[must_use]
            pub fn mask_uep_t_res(&mut self) -> MASK_UEP_T_RES_W<0> {
                MASK_UEP_T_RES_W::new(self)
            }
            ///Bit 2 - bit mask of handshake response type for USB endpoint X receiving (OUT)
            #[inline(always)]
            #[must_use]
            pub fn mask_uh_r_res(&mut self) -> MASK_UH_R_RES_W<2> {
                MASK_UH_R_RES_W::new(self)
            }
            ///Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)
            #[inline(always)]
            #[must_use]
            pub fn mask_uep_r_res(&mut self) -> MASK_UEP_R_RES_W<2> {
                MASK_UEP_R_RES_W::new(self)
            }
            ///Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle;enable automatic toggle after successful transfer completion: 0=manual toggle, 1=automatic toggle
            #[inline(always)]
            #[must_use]
            pub fn uep_auto_tog__rb_uh_r_auto_tog(
                &mut self,
            ) -> UEP_AUTO_TOG__RB_UH_R_AUTO_TOG_W<4> {
                UEP_AUTO_TOG__RB_UH_R_AUTO_TOG_W::new(self)
            }
            ///Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
            #[inline(always)]
            #[must_use]
            pub fn uep_t_tog(&mut self) -> UEP_T_TOG_W<6> {
                UEP_T_TOG_W::new(self)
            }
            ///Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1;expected data toggle flag of host receiving (IN): 0=DATA0, 1=DATA1
            #[inline(always)]
            #[must_use]
            pub fn uep_r_tog__rb_uh_r_tog(&mut self) -> UEP_R_TOG__RB_UH_R_TOG_W<7> {
                UEP_R_TOG__RB_UH_R_TOG_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///endpoint 2 control;host receiver endpoint control
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [uep2_ctrl_r8_uh_rx_ctrl](index.html) module
        pub struct UEP2_CTRL_R8_UH_RX_CTRL_SPEC;
        impl crate::RegisterSpec for UEP2_CTRL_R8_UH_RX_CTRL_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [uep2_ctrl_r8_uh_rx_ctrl::R](R) reader structure
        impl crate::Readable for UEP2_CTRL_R8_UH_RX_CTRL_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [uep2_ctrl_r8_uh_rx_ctrl::W](W) writer structure
        impl crate::Writable for UEP2_CTRL_R8_UH_RX_CTRL_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets UEP2_CTRL_R8_UH_RX_CTRL to value 0
        impl crate::Resettable for UEP2_CTRL_R8_UH_RX_CTRL_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///UEP3_T_LEN__R8_UH_TX_LEN (rw) register accessor: an alias for `Reg<UEP3_T_LEN__R8_UH_TX_LEN_SPEC>`
    pub type UEP3_T_LEN__R8_UH_TX_LEN =
        crate::Reg<uep3_t_len__r8_uh_tx_len::UEP3_T_LEN__R8_UH_TX_LEN_SPEC>;
    ///endpoint 3 transmittal length;host transmittal endpoint transmittal length
    pub mod uep3_t_len__r8_uh_tx_len {
        ///Register `UEP3_T_LEN__R8_UH_TX_LEN` reader
        pub struct R(crate::R<UEP3_T_LEN__R8_UH_TX_LEN_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<UEP3_T_LEN__R8_UH_TX_LEN_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<UEP3_T_LEN__R8_UH_TX_LEN_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<UEP3_T_LEN__R8_UH_TX_LEN_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `UEP3_T_LEN__R8_UH_TX_LEN` writer
        pub struct W(crate::W<UEP3_T_LEN__R8_UH_TX_LEN_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<UEP3_T_LEN__R8_UH_TX_LEN_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<UEP3_T_LEN__R8_UH_TX_LEN_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<UEP3_T_LEN__R8_UH_TX_LEN_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `UEP3_T_LEN__R8_UH_TX_LEN` reader - endpoint 1 transmittal length
        pub type UEP3_T_LEN__R8_UH_TX_LEN_R = crate::FieldReader<u8, u8>;
        ///Field `UEP3_T_LEN__R8_UH_TX_LEN` writer - endpoint 1 transmittal length
        pub type UEP3_T_LEN__R8_UH_TX_LEN_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, UEP3_T_LEN__R8_UH_TX_LEN_SPEC, u8, u8, 8, O>;
        impl R {
            ///Bits 0:7 - endpoint 1 transmittal length
            #[inline(always)]
            pub fn uep3_t_len__r8_uh_tx_len(&self) -> UEP3_T_LEN__R8_UH_TX_LEN_R {
                UEP3_T_LEN__R8_UH_TX_LEN_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:7 - endpoint 1 transmittal length
            #[inline(always)]
            #[must_use]
            pub fn uep3_t_len__r8_uh_tx_len(&mut self) -> UEP3_T_LEN__R8_UH_TX_LEN_W<0> {
                UEP3_T_LEN__R8_UH_TX_LEN_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///endpoint 3 transmittal length;host transmittal endpoint transmittal length
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [uep3_t_len__r8_uh_tx_len](index.html) module
        pub struct UEP3_T_LEN__R8_UH_TX_LEN_SPEC;
        impl crate::RegisterSpec for UEP3_T_LEN__R8_UH_TX_LEN_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [uep3_t_len__r8_uh_tx_len::R](R) reader structure
        impl crate::Readable for UEP3_T_LEN__R8_UH_TX_LEN_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [uep3_t_len__r8_uh_tx_len::W](W) writer structure
        impl crate::Writable for UEP3_T_LEN__R8_UH_TX_LEN_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets UEP3_T_LEN__R8_UH_TX_LEN to value 0
        impl crate::Resettable for UEP3_T_LEN__R8_UH_TX_LEN_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///UEP3_CTRL__R8_UH_TX_CTRL (rw) register accessor: an alias for `Reg<UEP3_CTRL__R8_UH_TX_CTRL_SPEC>`
    pub type UEP3_CTRL__R8_UH_TX_CTRL =
        crate::Reg<uep3_ctrl__r8_uh_tx_ctrl::UEP3_CTRL__R8_UH_TX_CTRL_SPEC>;
    ///endpoint 3 control;host transmittal endpoint control
    pub mod uep3_ctrl__r8_uh_tx_ctrl {
        ///Register `UEP3_CTRL__R8_UH_TX_CTRL` reader
        pub struct R(crate::R<UEP3_CTRL__R8_UH_TX_CTRL_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<UEP3_CTRL__R8_UH_TX_CTRL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<UEP3_CTRL__R8_UH_TX_CTRL_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<UEP3_CTRL__R8_UH_TX_CTRL_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `UEP3_CTRL__R8_UH_TX_CTRL` writer
        pub struct W(crate::W<UEP3_CTRL__R8_UH_TX_CTRL_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<UEP3_CTRL__R8_UH_TX_CTRL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<UEP3_CTRL__R8_UH_TX_CTRL_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<UEP3_CTRL__R8_UH_TX_CTRL_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `UH_T_RES` reader - bit mask of handshake response type for USB endpoint X transmittal (IN)
        pub type UH_T_RES_R = crate::FieldReader<u8, u8>;
        ///Field `UH_T_RES` writer - bit mask of handshake response type for USB endpoint X transmittal (IN)
        pub type UH_T_RES_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, UEP3_CTRL__R8_UH_TX_CTRL_SPEC, u8, u8, 2, O>;
        ///Field `MASK_UEP_T_RES` reader - bit mask of handshake response type for USB endpoint X transmittal (IN)
        pub type MASK_UEP_T_RES_R = crate::FieldReader<u8, u8>;
        ///Field `MASK_UEP_T_RES` writer - bit mask of handshake response type for USB endpoint X transmittal (IN)
        pub type MASK_UEP_T_RES_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, UEP3_CTRL__R8_UH_TX_CTRL_SPEC, u8, u8, 2, O>;
        ///Field `MASK_UEP_R_RES` reader - bit mask of handshake response type for USB endpoint X receiving (OUT)
        pub type MASK_UEP_R_RES_R = crate::FieldReader<u8, u8>;
        ///Field `MASK_UEP_R_RES` writer - bit mask of handshake response type for USB endpoint X receiving (OUT)
        pub type MASK_UEP_R_RES_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, UEP3_CTRL__R8_UH_TX_CTRL_SPEC, u8, u8, 2, O>;
        ///Field `UEP_AUTO_TOG_RB_UH_T_AUTO_TOG` reader - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
        pub type UEP_AUTO_TOG_RB_UH_T_AUTO_TOG_R = crate::BitReader<bool>;
        ///Field `UEP_AUTO_TOG_RB_UH_T_AUTO_TOG` writer - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
        pub type UEP_AUTO_TOG_RB_UH_T_AUTO_TOG_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, UEP3_CTRL__R8_UH_TX_CTRL_SPEC, bool, O>;
        ///Field `UEP_T_TOG_RB_UH_T_TOG` reader - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
        pub type UEP_T_TOG_RB_UH_T_TOG_R = crate::BitReader<bool>;
        ///Field `UEP_T_TOG_RB_UH_T_TOG` writer - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
        pub type UEP_T_TOG_RB_UH_T_TOG_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, UEP3_CTRL__R8_UH_TX_CTRL_SPEC, bool, O>;
        ///Field `UEP_R_TOG` reader - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
        pub type UEP_R_TOG_R = crate::BitReader<bool>;
        ///Field `UEP_R_TOG` writer - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
        pub type UEP_R_TOG_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, UEP3_CTRL__R8_UH_TX_CTRL_SPEC, bool, O>;
        impl R {
            ///Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)
            #[inline(always)]
            pub fn uh_t_res(&self) -> UH_T_RES_R {
                UH_T_RES_R::new(self.bits & 3)
            }
            ///Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)
            #[inline(always)]
            pub fn mask_uep_t_res(&self) -> MASK_UEP_T_RES_R {
                MASK_UEP_T_RES_R::new(self.bits & 3)
            }
            ///Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)
            #[inline(always)]
            pub fn mask_uep_r_res(&self) -> MASK_UEP_R_RES_R {
                MASK_UEP_R_RES_R::new((self.bits >> 2) & 3)
            }
            ///Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
            #[inline(always)]
            pub fn uep_auto_tog_rb_uh_t_auto_tog(&self) -> UEP_AUTO_TOG_RB_UH_T_AUTO_TOG_R {
                UEP_AUTO_TOG_RB_UH_T_AUTO_TOG_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
            #[inline(always)]
            pub fn uep_t_tog_rb_uh_t_tog(&self) -> UEP_T_TOG_RB_UH_T_TOG_R {
                UEP_T_TOG_RB_UH_T_TOG_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
            #[inline(always)]
            pub fn uep_r_tog(&self) -> UEP_R_TOG_R {
                UEP_R_TOG_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)
            #[inline(always)]
            #[must_use]
            pub fn uh_t_res(&mut self) -> UH_T_RES_W<0> {
                UH_T_RES_W::new(self)
            }
            ///Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)
            #[inline(always)]
            #[must_use]
            pub fn mask_uep_t_res(&mut self) -> MASK_UEP_T_RES_W<0> {
                MASK_UEP_T_RES_W::new(self)
            }
            ///Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)
            #[inline(always)]
            #[must_use]
            pub fn mask_uep_r_res(&mut self) -> MASK_UEP_R_RES_W<2> {
                MASK_UEP_R_RES_W::new(self)
            }
            ///Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
            #[inline(always)]
            #[must_use]
            pub fn uep_auto_tog_rb_uh_t_auto_tog(&mut self) -> UEP_AUTO_TOG_RB_UH_T_AUTO_TOG_W<4> {
                UEP_AUTO_TOG_RB_UH_T_AUTO_TOG_W::new(self)
            }
            ///Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
            #[inline(always)]
            #[must_use]
            pub fn uep_t_tog_rb_uh_t_tog(&mut self) -> UEP_T_TOG_RB_UH_T_TOG_W<6> {
                UEP_T_TOG_RB_UH_T_TOG_W::new(self)
            }
            ///Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
            #[inline(always)]
            #[must_use]
            pub fn uep_r_tog(&mut self) -> UEP_R_TOG_W<7> {
                UEP_R_TOG_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///endpoint 3 control;host transmittal endpoint control
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [uep3_ctrl__r8_uh_tx_ctrl](index.html) module
        pub struct UEP3_CTRL__R8_UH_TX_CTRL_SPEC;
        impl crate::RegisterSpec for UEP3_CTRL__R8_UH_TX_CTRL_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [uep3_ctrl__r8_uh_tx_ctrl::R](R) reader structure
        impl crate::Readable for UEP3_CTRL__R8_UH_TX_CTRL_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [uep3_ctrl__r8_uh_tx_ctrl::W](W) writer structure
        impl crate::Writable for UEP3_CTRL__R8_UH_TX_CTRL_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets UEP3_CTRL__R8_UH_TX_CTRL to value 0
        impl crate::Resettable for UEP3_CTRL__R8_UH_TX_CTRL_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///UEP4_T_LEN (rw) register accessor: an alias for `Reg<UEP4_T_LEN_SPEC>`
    pub type UEP4_T_LEN = crate::Reg<uep4_t_len::UEP4_T_LEN_SPEC>;
    ///endpoint 4 transmittal length
    pub mod uep4_t_len {
        ///Register `UEP4_T_LEN` reader
        pub struct R(crate::R<UEP4_T_LEN_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<UEP4_T_LEN_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<UEP4_T_LEN_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<UEP4_T_LEN_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `UEP4_T_LEN` writer
        pub struct W(crate::W<UEP4_T_LEN_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<UEP4_T_LEN_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<UEP4_T_LEN_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<UEP4_T_LEN_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `UEP4_T_LEN` reader - endpoint 4 transmittal length
        pub type UEP4_T_LEN_R = crate::FieldReader<u8, u8>;
        ///Field `UEP4_T_LEN` writer - endpoint 4 transmittal length
        pub type UEP4_T_LEN_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, UEP4_T_LEN_SPEC, u8, u8, 8, O>;
        impl R {
            ///Bits 0:7 - endpoint 4 transmittal length
            #[inline(always)]
            pub fn uep4_t_len(&self) -> UEP4_T_LEN_R {
                UEP4_T_LEN_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:7 - endpoint 4 transmittal length
            #[inline(always)]
            #[must_use]
            pub fn uep4_t_len(&mut self) -> UEP4_T_LEN_W<0> {
                UEP4_T_LEN_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///endpoint 4 transmittal length
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [uep4_t_len](index.html) module
        pub struct UEP4_T_LEN_SPEC;
        impl crate::RegisterSpec for UEP4_T_LEN_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [uep4_t_len::R](R) reader structure
        impl crate::Readable for UEP4_T_LEN_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [uep4_t_len::W](W) writer structure
        impl crate::Writable for UEP4_T_LEN_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets UEP4_T_LEN to value 0
        impl crate::Resettable for UEP4_T_LEN_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///UEP4_CTRL (rw) register accessor: an alias for `Reg<UEP4_CTRL_SPEC>`
    pub type UEP4_CTRL = crate::Reg<uep4_ctrl::UEP4_CTRL_SPEC>;
    ///endpoint 4 control
    pub mod uep4_ctrl {
        ///Register `UEP4_CTRL` reader
        pub struct R(crate::R<UEP4_CTRL_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<UEP4_CTRL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<UEP4_CTRL_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<UEP4_CTRL_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `UEP4_CTRL` writer
        pub struct W(crate::W<UEP4_CTRL_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<UEP4_CTRL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<UEP4_CTRL_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<UEP4_CTRL_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `MASK_UEP_T_RES` reader - bit mask of handshake response type for USB endpoint X transmittal (IN)
        pub type MASK_UEP_T_RES_R = crate::FieldReader<u8, u8>;
        ///Field `MASK_UEP_T_RES` writer - bit mask of handshake response type for USB endpoint X transmittal (IN)
        pub type MASK_UEP_T_RES_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, UEP4_CTRL_SPEC, u8, u8, 2, O>;
        ///Field `MASK_UEP_R_RES` reader - bit mask of handshake response type for USB endpoint X receiving (OUT)
        pub type MASK_UEP_R_RES_R = crate::FieldReader<u8, u8>;
        ///Field `MASK_UEP_R_RES` writer - bit mask of handshake response type for USB endpoint X receiving (OUT)
        pub type MASK_UEP_R_RES_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, UEP4_CTRL_SPEC, u8, u8, 2, O>;
        ///Field `UEP_AUTO_TOG` reader - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
        pub type UEP_AUTO_TOG_R = crate::BitReader<bool>;
        ///Field `UEP_AUTO_TOG` writer - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
        pub type UEP_AUTO_TOG_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, UEP4_CTRL_SPEC, bool, O>;
        ///Field `UEP_T_TOG` reader - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
        pub type UEP_T_TOG_R = crate::BitReader<bool>;
        ///Field `UEP_T_TOG` writer - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
        pub type UEP_T_TOG_W<'a, const O: u8> = crate::BitWriter<'a, u8, UEP4_CTRL_SPEC, bool, O>;
        ///Field `UEP_R_TOG` reader - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
        pub type UEP_R_TOG_R = crate::BitReader<bool>;
        ///Field `UEP_R_TOG` writer - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
        pub type UEP_R_TOG_W<'a, const O: u8> = crate::BitWriter<'a, u8, UEP4_CTRL_SPEC, bool, O>;
        impl R {
            ///Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)
            #[inline(always)]
            pub fn mask_uep_t_res(&self) -> MASK_UEP_T_RES_R {
                MASK_UEP_T_RES_R::new(self.bits & 3)
            }
            ///Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)
            #[inline(always)]
            pub fn mask_uep_r_res(&self) -> MASK_UEP_R_RES_R {
                MASK_UEP_R_RES_R::new((self.bits >> 2) & 3)
            }
            ///Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
            #[inline(always)]
            pub fn uep_auto_tog(&self) -> UEP_AUTO_TOG_R {
                UEP_AUTO_TOG_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
            #[inline(always)]
            pub fn uep_t_tog(&self) -> UEP_T_TOG_R {
                UEP_T_TOG_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
            #[inline(always)]
            pub fn uep_r_tog(&self) -> UEP_R_TOG_R {
                UEP_R_TOG_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)
            #[inline(always)]
            #[must_use]
            pub fn mask_uep_t_res(&mut self) -> MASK_UEP_T_RES_W<0> {
                MASK_UEP_T_RES_W::new(self)
            }
            ///Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)
            #[inline(always)]
            #[must_use]
            pub fn mask_uep_r_res(&mut self) -> MASK_UEP_R_RES_W<2> {
                MASK_UEP_R_RES_W::new(self)
            }
            ///Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
            #[inline(always)]
            #[must_use]
            pub fn uep_auto_tog(&mut self) -> UEP_AUTO_TOG_W<4> {
                UEP_AUTO_TOG_W::new(self)
            }
            ///Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
            #[inline(always)]
            #[must_use]
            pub fn uep_t_tog(&mut self) -> UEP_T_TOG_W<6> {
                UEP_T_TOG_W::new(self)
            }
            ///Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
            #[inline(always)]
            #[must_use]
            pub fn uep_r_tog(&mut self) -> UEP_R_TOG_W<7> {
                UEP_R_TOG_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///endpoint 4 control
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [uep4_ctrl](index.html) module
        pub struct UEP4_CTRL_SPEC;
        impl crate::RegisterSpec for UEP4_CTRL_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [uep4_ctrl::R](R) reader structure
        impl crate::Readable for UEP4_CTRL_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [uep4_ctrl::W](W) writer structure
        impl crate::Writable for UEP4_CTRL_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets UEP4_CTRL to value 0
        impl crate::Resettable for UEP4_CTRL_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///UEP5_T_LEN (rw) register accessor: an alias for `Reg<UEP5_T_LEN_SPEC>`
    pub type UEP5_T_LEN = crate::Reg<uep5_t_len::UEP5_T_LEN_SPEC>;
    ///endpoint 5 transmittal length
    pub mod uep5_t_len {
        ///Register `UEP5_T_LEN` reader
        pub struct R(crate::R<UEP5_T_LEN_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<UEP5_T_LEN_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<UEP5_T_LEN_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<UEP5_T_LEN_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `UEP5_T_LEN` writer
        pub struct W(crate::W<UEP5_T_LEN_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<UEP5_T_LEN_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<UEP5_T_LEN_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<UEP5_T_LEN_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `UEP5_T_LEN` reader - endpoint 5 transmittal length
        pub type UEP5_T_LEN_R = crate::FieldReader<u8, u8>;
        ///Field `UEP5_T_LEN` writer - endpoint 5 transmittal length
        pub type UEP5_T_LEN_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, UEP5_T_LEN_SPEC, u8, u8, 8, O>;
        impl R {
            ///Bits 0:7 - endpoint 5 transmittal length
            #[inline(always)]
            pub fn uep5_t_len(&self) -> UEP5_T_LEN_R {
                UEP5_T_LEN_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:7 - endpoint 5 transmittal length
            #[inline(always)]
            #[must_use]
            pub fn uep5_t_len(&mut self) -> UEP5_T_LEN_W<0> {
                UEP5_T_LEN_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///endpoint 5 transmittal length
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [uep5_t_len](index.html) module
        pub struct UEP5_T_LEN_SPEC;
        impl crate::RegisterSpec for UEP5_T_LEN_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [uep5_t_len::R](R) reader structure
        impl crate::Readable for UEP5_T_LEN_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [uep5_t_len::W](W) writer structure
        impl crate::Writable for UEP5_T_LEN_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets UEP5_T_LEN to value 0
        impl crate::Resettable for UEP5_T_LEN_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///UEP5_CTRL (rw) register accessor: an alias for `Reg<UEP5_CTRL_SPEC>`
    pub type UEP5_CTRL = crate::Reg<uep5_ctrl::UEP5_CTRL_SPEC>;
    ///endpoint 5 control
    pub mod uep5_ctrl {
        ///Register `UEP5_CTRL` reader
        pub struct R(crate::R<UEP5_CTRL_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<UEP5_CTRL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<UEP5_CTRL_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<UEP5_CTRL_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `UEP5_CTRL` writer
        pub struct W(crate::W<UEP5_CTRL_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<UEP5_CTRL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<UEP5_CTRL_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<UEP5_CTRL_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `MASK_UEP_T_RES` reader - bit mask of handshake response type for USB endpoint X transmittal (IN)
        pub type MASK_UEP_T_RES_R = crate::FieldReader<u8, u8>;
        ///Field `MASK_UEP_T_RES` writer - bit mask of handshake response type for USB endpoint X transmittal (IN)
        pub type MASK_UEP_T_RES_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, UEP5_CTRL_SPEC, u8, u8, 2, O>;
        ///Field `MASK_UEP_R_RES` reader - bit mask of handshake response type for USB endpoint X receiving (OUT)
        pub type MASK_UEP_R_RES_R = crate::FieldReader<u8, u8>;
        ///Field `MASK_UEP_R_RES` writer - bit mask of handshake response type for USB endpoint X receiving (OUT)
        pub type MASK_UEP_R_RES_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, UEP5_CTRL_SPEC, u8, u8, 2, O>;
        ///Field `UEP_AUTO_TOG` reader - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
        pub type UEP_AUTO_TOG_R = crate::BitReader<bool>;
        ///Field `UEP_AUTO_TOG` writer - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
        pub type UEP_AUTO_TOG_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, UEP5_CTRL_SPEC, bool, O>;
        ///Field `UEP_T_TOG` reader - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
        pub type UEP_T_TOG_R = crate::BitReader<bool>;
        ///Field `UEP_T_TOG` writer - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
        pub type UEP_T_TOG_W<'a, const O: u8> = crate::BitWriter<'a, u8, UEP5_CTRL_SPEC, bool, O>;
        ///Field `UEP_R_TOG` reader - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
        pub type UEP_R_TOG_R = crate::BitReader<bool>;
        ///Field `UEP_R_TOG` writer - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
        pub type UEP_R_TOG_W<'a, const O: u8> = crate::BitWriter<'a, u8, UEP5_CTRL_SPEC, bool, O>;
        impl R {
            ///Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)
            #[inline(always)]
            pub fn mask_uep_t_res(&self) -> MASK_UEP_T_RES_R {
                MASK_UEP_T_RES_R::new(self.bits & 3)
            }
            ///Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)
            #[inline(always)]
            pub fn mask_uep_r_res(&self) -> MASK_UEP_R_RES_R {
                MASK_UEP_R_RES_R::new((self.bits >> 2) & 3)
            }
            ///Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
            #[inline(always)]
            pub fn uep_auto_tog(&self) -> UEP_AUTO_TOG_R {
                UEP_AUTO_TOG_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
            #[inline(always)]
            pub fn uep_t_tog(&self) -> UEP_T_TOG_R {
                UEP_T_TOG_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
            #[inline(always)]
            pub fn uep_r_tog(&self) -> UEP_R_TOG_R {
                UEP_R_TOG_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)
            #[inline(always)]
            #[must_use]
            pub fn mask_uep_t_res(&mut self) -> MASK_UEP_T_RES_W<0> {
                MASK_UEP_T_RES_W::new(self)
            }
            ///Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)
            #[inline(always)]
            #[must_use]
            pub fn mask_uep_r_res(&mut self) -> MASK_UEP_R_RES_W<2> {
                MASK_UEP_R_RES_W::new(self)
            }
            ///Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
            #[inline(always)]
            #[must_use]
            pub fn uep_auto_tog(&mut self) -> UEP_AUTO_TOG_W<4> {
                UEP_AUTO_TOG_W::new(self)
            }
            ///Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
            #[inline(always)]
            #[must_use]
            pub fn uep_t_tog(&mut self) -> UEP_T_TOG_W<6> {
                UEP_T_TOG_W::new(self)
            }
            ///Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
            #[inline(always)]
            #[must_use]
            pub fn uep_r_tog(&mut self) -> UEP_R_TOG_W<7> {
                UEP_R_TOG_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///endpoint 5 control
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [uep5_ctrl](index.html) module
        pub struct UEP5_CTRL_SPEC;
        impl crate::RegisterSpec for UEP5_CTRL_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [uep5_ctrl::R](R) reader structure
        impl crate::Readable for UEP5_CTRL_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [uep5_ctrl::W](W) writer structure
        impl crate::Writable for UEP5_CTRL_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets UEP5_CTRL to value 0
        impl crate::Resettable for UEP5_CTRL_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///UEP6_T_LEN (rw) register accessor: an alias for `Reg<UEP6_T_LEN_SPEC>`
    pub type UEP6_T_LEN = crate::Reg<uep6_t_len::UEP6_T_LEN_SPEC>;
    ///endpoint 6 transmittal length
    pub mod uep6_t_len {
        ///Register `UEP6_T_LEN` reader
        pub struct R(crate::R<UEP6_T_LEN_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<UEP6_T_LEN_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<UEP6_T_LEN_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<UEP6_T_LEN_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `UEP6_T_LEN` writer
        pub struct W(crate::W<UEP6_T_LEN_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<UEP6_T_LEN_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<UEP6_T_LEN_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<UEP6_T_LEN_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `UEP6_T_LEN` reader - endpoint 6 transmittal length
        pub type UEP6_T_LEN_R = crate::FieldReader<u8, u8>;
        ///Field `UEP6_T_LEN` writer - endpoint 6 transmittal length
        pub type UEP6_T_LEN_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, UEP6_T_LEN_SPEC, u8, u8, 8, O>;
        impl R {
            ///Bits 0:7 - endpoint 6 transmittal length
            #[inline(always)]
            pub fn uep6_t_len(&self) -> UEP6_T_LEN_R {
                UEP6_T_LEN_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:7 - endpoint 6 transmittal length
            #[inline(always)]
            #[must_use]
            pub fn uep6_t_len(&mut self) -> UEP6_T_LEN_W<0> {
                UEP6_T_LEN_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///endpoint 6 transmittal length
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [uep6_t_len](index.html) module
        pub struct UEP6_T_LEN_SPEC;
        impl crate::RegisterSpec for UEP6_T_LEN_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [uep6_t_len::R](R) reader structure
        impl crate::Readable for UEP6_T_LEN_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [uep6_t_len::W](W) writer structure
        impl crate::Writable for UEP6_T_LEN_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets UEP6_T_LEN to value 0
        impl crate::Resettable for UEP6_T_LEN_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///UEP6_CTRL (rw) register accessor: an alias for `Reg<UEP6_CTRL_SPEC>`
    pub type UEP6_CTRL = crate::Reg<uep6_ctrl::UEP6_CTRL_SPEC>;
    ///endpoint 6 control
    pub mod uep6_ctrl {
        ///Register `UEP6_CTRL` reader
        pub struct R(crate::R<UEP6_CTRL_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<UEP6_CTRL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<UEP6_CTRL_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<UEP6_CTRL_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `UEP6_CTRL` writer
        pub struct W(crate::W<UEP6_CTRL_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<UEP6_CTRL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<UEP6_CTRL_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<UEP6_CTRL_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `MASK_UEP_T_RES` reader - bit mask of handshake response type for USB endpoint X transmittal (IN)
        pub type MASK_UEP_T_RES_R = crate::FieldReader<u8, u8>;
        ///Field `MASK_UEP_T_RES` writer - bit mask of handshake response type for USB endpoint X transmittal (IN)
        pub type MASK_UEP_T_RES_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, UEP6_CTRL_SPEC, u8, u8, 2, O>;
        ///Field `MASK_UEP_R_RES` reader - bit mask of handshake response type for USB endpoint X receiving (OUT)
        pub type MASK_UEP_R_RES_R = crate::FieldReader<u8, u8>;
        ///Field `MASK_UEP_R_RES` writer - bit mask of handshake response type for USB endpoint X receiving (OUT)
        pub type MASK_UEP_R_RES_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, UEP6_CTRL_SPEC, u8, u8, 2, O>;
        ///Field `UEP_AUTO_TOG` reader - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
        pub type UEP_AUTO_TOG_R = crate::BitReader<bool>;
        ///Field `UEP_AUTO_TOG` writer - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
        pub type UEP_AUTO_TOG_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, UEP6_CTRL_SPEC, bool, O>;
        ///Field `UEP_T_TOG` reader - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
        pub type UEP_T_TOG_R = crate::BitReader<bool>;
        ///Field `UEP_T_TOG` writer - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
        pub type UEP_T_TOG_W<'a, const O: u8> = crate::BitWriter<'a, u8, UEP6_CTRL_SPEC, bool, O>;
        ///Field `UEP_R_TOG` reader - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
        pub type UEP_R_TOG_R = crate::BitReader<bool>;
        ///Field `UEP_R_TOG` writer - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
        pub type UEP_R_TOG_W<'a, const O: u8> = crate::BitWriter<'a, u8, UEP6_CTRL_SPEC, bool, O>;
        impl R {
            ///Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)
            #[inline(always)]
            pub fn mask_uep_t_res(&self) -> MASK_UEP_T_RES_R {
                MASK_UEP_T_RES_R::new(self.bits & 3)
            }
            ///Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)
            #[inline(always)]
            pub fn mask_uep_r_res(&self) -> MASK_UEP_R_RES_R {
                MASK_UEP_R_RES_R::new((self.bits >> 2) & 3)
            }
            ///Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
            #[inline(always)]
            pub fn uep_auto_tog(&self) -> UEP_AUTO_TOG_R {
                UEP_AUTO_TOG_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
            #[inline(always)]
            pub fn uep_t_tog(&self) -> UEP_T_TOG_R {
                UEP_T_TOG_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
            #[inline(always)]
            pub fn uep_r_tog(&self) -> UEP_R_TOG_R {
                UEP_R_TOG_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)
            #[inline(always)]
            #[must_use]
            pub fn mask_uep_t_res(&mut self) -> MASK_UEP_T_RES_W<0> {
                MASK_UEP_T_RES_W::new(self)
            }
            ///Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)
            #[inline(always)]
            #[must_use]
            pub fn mask_uep_r_res(&mut self) -> MASK_UEP_R_RES_W<2> {
                MASK_UEP_R_RES_W::new(self)
            }
            ///Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
            #[inline(always)]
            #[must_use]
            pub fn uep_auto_tog(&mut self) -> UEP_AUTO_TOG_W<4> {
                UEP_AUTO_TOG_W::new(self)
            }
            ///Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
            #[inline(always)]
            #[must_use]
            pub fn uep_t_tog(&mut self) -> UEP_T_TOG_W<6> {
                UEP_T_TOG_W::new(self)
            }
            ///Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
            #[inline(always)]
            #[must_use]
            pub fn uep_r_tog(&mut self) -> UEP_R_TOG_W<7> {
                UEP_R_TOG_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///endpoint 6 control
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [uep6_ctrl](index.html) module
        pub struct UEP6_CTRL_SPEC;
        impl crate::RegisterSpec for UEP6_CTRL_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [uep6_ctrl::R](R) reader structure
        impl crate::Readable for UEP6_CTRL_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [uep6_ctrl::W](W) writer structure
        impl crate::Writable for UEP6_CTRL_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets UEP6_CTRL to value 0
        impl crate::Resettable for UEP6_CTRL_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///UEP7_T_LEN (rw) register accessor: an alias for `Reg<UEP7_T_LEN_SPEC>`
    pub type UEP7_T_LEN = crate::Reg<uep7_t_len::UEP7_T_LEN_SPEC>;
    ///endpoint 7 transmittal length
    pub mod uep7_t_len {
        ///Register `UEP7_T_LEN` reader
        pub struct R(crate::R<UEP7_T_LEN_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<UEP7_T_LEN_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<UEP7_T_LEN_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<UEP7_T_LEN_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `UEP7_T_LEN` writer
        pub struct W(crate::W<UEP7_T_LEN_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<UEP7_T_LEN_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<UEP7_T_LEN_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<UEP7_T_LEN_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `UEP7_T_LEN` reader - endpoint 7 transmittal length
        pub type UEP7_T_LEN_R = crate::FieldReader<u8, u8>;
        ///Field `UEP7_T_LEN` writer - endpoint 7 transmittal length
        pub type UEP7_T_LEN_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, UEP7_T_LEN_SPEC, u8, u8, 8, O>;
        impl R {
            ///Bits 0:7 - endpoint 7 transmittal length
            #[inline(always)]
            pub fn uep7_t_len(&self) -> UEP7_T_LEN_R {
                UEP7_T_LEN_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:7 - endpoint 7 transmittal length
            #[inline(always)]
            #[must_use]
            pub fn uep7_t_len(&mut self) -> UEP7_T_LEN_W<0> {
                UEP7_T_LEN_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///endpoint 7 transmittal length
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [uep7_t_len](index.html) module
        pub struct UEP7_T_LEN_SPEC;
        impl crate::RegisterSpec for UEP7_T_LEN_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [uep7_t_len::R](R) reader structure
        impl crate::Readable for UEP7_T_LEN_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [uep7_t_len::W](W) writer structure
        impl crate::Writable for UEP7_T_LEN_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets UEP7_T_LEN to value 0
        impl crate::Resettable for UEP7_T_LEN_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///UEP7_CTRL (rw) register accessor: an alias for `Reg<UEP7_CTRL_SPEC>`
    pub type UEP7_CTRL = crate::Reg<uep7_ctrl::UEP7_CTRL_SPEC>;
    ///endpoint 7 control
    pub mod uep7_ctrl {
        ///Register `UEP7_CTRL` reader
        pub struct R(crate::R<UEP7_CTRL_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<UEP7_CTRL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<UEP7_CTRL_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<UEP7_CTRL_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `UEP7_CTRL` writer
        pub struct W(crate::W<UEP7_CTRL_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<UEP7_CTRL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<UEP7_CTRL_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<UEP7_CTRL_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `MASK_UEP_T_RES` reader - bit mask of handshake response type for USB endpoint X transmittal (IN)
        pub type MASK_UEP_T_RES_R = crate::FieldReader<u8, u8>;
        ///Field `MASK_UEP_T_RES` writer - bit mask of handshake response type for USB endpoint X transmittal (IN)
        pub type MASK_UEP_T_RES_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, UEP7_CTRL_SPEC, u8, u8, 2, O>;
        ///Field `MASK_UEP_R_RES` reader - bit mask of handshake response type for USB endpoint X receiving (OUT)
        pub type MASK_UEP_R_RES_R = crate::FieldReader<u8, u8>;
        ///Field `MASK_UEP_R_RES` writer - bit mask of handshake response type for USB endpoint X receiving (OUT)
        pub type MASK_UEP_R_RES_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, UEP7_CTRL_SPEC, u8, u8, 2, O>;
        ///Field `UEP_AUTO_TOG` reader - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
        pub type UEP_AUTO_TOG_R = crate::BitReader<bool>;
        ///Field `UEP_AUTO_TOG` writer - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
        pub type UEP_AUTO_TOG_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, UEP7_CTRL_SPEC, bool, O>;
        ///Field `UEP_T_TOG` reader - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
        pub type UEP_T_TOG_R = crate::BitReader<bool>;
        ///Field `UEP_T_TOG` writer - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
        pub type UEP_T_TOG_W<'a, const O: u8> = crate::BitWriter<'a, u8, UEP7_CTRL_SPEC, bool, O>;
        ///Field `UEP_R_TOG` reader - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
        pub type UEP_R_TOG_R = crate::BitReader<bool>;
        ///Field `UEP_R_TOG` writer - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
        pub type UEP_R_TOG_W<'a, const O: u8> = crate::BitWriter<'a, u8, UEP7_CTRL_SPEC, bool, O>;
        impl R {
            ///Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)
            #[inline(always)]
            pub fn mask_uep_t_res(&self) -> MASK_UEP_T_RES_R {
                MASK_UEP_T_RES_R::new(self.bits & 3)
            }
            ///Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)
            #[inline(always)]
            pub fn mask_uep_r_res(&self) -> MASK_UEP_R_RES_R {
                MASK_UEP_R_RES_R::new((self.bits >> 2) & 3)
            }
            ///Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
            #[inline(always)]
            pub fn uep_auto_tog(&self) -> UEP_AUTO_TOG_R {
                UEP_AUTO_TOG_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
            #[inline(always)]
            pub fn uep_t_tog(&self) -> UEP_T_TOG_R {
                UEP_T_TOG_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
            #[inline(always)]
            pub fn uep_r_tog(&self) -> UEP_R_TOG_R {
                UEP_R_TOG_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)
            #[inline(always)]
            #[must_use]
            pub fn mask_uep_t_res(&mut self) -> MASK_UEP_T_RES_W<0> {
                MASK_UEP_T_RES_W::new(self)
            }
            ///Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)
            #[inline(always)]
            #[must_use]
            pub fn mask_uep_r_res(&mut self) -> MASK_UEP_R_RES_W<2> {
                MASK_UEP_R_RES_W::new(self)
            }
            ///Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
            #[inline(always)]
            #[must_use]
            pub fn uep_auto_tog(&mut self) -> UEP_AUTO_TOG_W<4> {
                UEP_AUTO_TOG_W::new(self)
            }
            ///Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
            #[inline(always)]
            #[must_use]
            pub fn uep_t_tog(&mut self) -> UEP_T_TOG_W<6> {
                UEP_T_TOG_W::new(self)
            }
            ///Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
            #[inline(always)]
            #[must_use]
            pub fn uep_r_tog(&mut self) -> UEP_R_TOG_W<7> {
                UEP_R_TOG_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///endpoint 7 control
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [uep7_ctrl](index.html) module
        pub struct UEP7_CTRL_SPEC;
        impl crate::RegisterSpec for UEP7_CTRL_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [uep7_ctrl::R](R) reader structure
        impl crate::Readable for UEP7_CTRL_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [uep7_ctrl::W](W) writer structure
        impl crate::Writable for UEP7_CTRL_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets UEP7_CTRL to value 0
        impl crate::Resettable for UEP7_CTRL_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
}
///USB2 register
pub struct USB2 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for USB2 {}
impl USB2 {
    ///Pointer to the register block
    pub const PTR: *const usb2::RegisterBlock = 0x4000_8400 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const usb2::RegisterBlock {
        Self::PTR
    }
}
impl Deref for USB2 {
    type Target = usb2::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for USB2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("USB2").finish()
    }
}
///USB2 register
pub mod usb2 {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        ///0x00 - USB2 base control
        pub usb2_ctrl: USB2_CTRL,
        ///0x01 - USB2 device physical prot control
        pub u2dev_ctrl__r8_u2host_ctrl: U2DEV_CTRL__R8_U2HOST_CTRL,
        ///0x02 - USB2 interrupt enable
        pub usb2_int_en: USB2_INT_EN,
        ///0x03 - USB2 device address
        pub usb2_dev_ad: USB2_DEV_AD,
        _reserved4: [u8; 0x01],
        ///0x05 - USB2 miscellaneous status
        pub usb2_mis_st: USB2_MIS_ST,
        ///0x06 - USB2 interrupt flag
        pub usb2_int_fg: USB2_INT_FG,
        ///0x07 - USB2 interrupt status
        pub usb2_int_st: USB2_INT_ST,
        ///0x08 - USB2 receiving length
        pub usb2_rx_len: USB2_RX_LEN,
        _reserved8: [u8; 0x03],
        ///0x0c - endpoint 4/1 mode
        pub u2ep4_1_mod: U2EP4_1_MOD,
        ///0x0d - endpoint 2_3 mode;host endpoint mode
        pub u2ep2_3_mod__r8_u2h_ep_mod: U2EP2_3_MOD__R8_U2H_EP_MOD,
        ///0x0e - USB2 endpoint 5/6/7 mode
        pub u2ep567_mod: U2EP567_MOD,
        _reserved11: [u8; 0x01],
        ///0x10 - endpoint 0 DMA buffer address
        pub u2ep0_dma: U2EP0_DMA,
        _reserved12: [u8; 0x02],
        ///0x14 - USB2 endpoint 1 DMA buffer address
        pub u2ep1_dma: U2EP1_DMA,
        _reserved13: [u8; 0x02],
        ///0x18 - USB2 endpoint 2 DMA buffer address;host rx endpoint buffer high address
        pub u2ep2_dma__r16_u2h_rx_dma: U2EP2_DMA__R16_U2H_RX_DMA,
        _reserved14: [u8; 0x02],
        ///0x1c - USB2 endpoint 3 DMA buffer address;host tx endpoint buffer high address
        pub u2ep3_dma__r16_u2h_tx_dma: U2EP3_DMA__R16_U2H_TX_DMA,
        _reserved15: [u8; 0x02],
        ///0x20 - USB2 endpoint 0 transmittal length
        pub u2ep0_t_len: U2EP0_T_LEN,
        _reserved16: [u8; 0x01],
        ///0x22 - USB2 endpoint 0 control
        pub u2ep0_ctrl: U2EP0_CTRL,
        _reserved17: [u8; 0x01],
        ///0x24 - USB2 endpoint 1 transmittal length
        pub u2ep1_t_len: U2EP1_T_LEN,
        _reserved18: [u8; 0x01],
        ///0x26 - USB2 endpoint 1 control;host aux setup
        pub u2ep1_ctrl__r8_u2h_setup: U2EP1_CTRL__R8_U2H_SETUP,
        _reserved19: [u8; 0x01],
        ///0x28 - USB2 endpoint 2 transmittal length;host endpoint and PID
        pub u2ep2_t_len_r8_u2h_ep_pid: U2EP2_T_LEN_R8_U2H_EP_PID,
        _reserved20: [u8; 0x01],
        ///0x2a - USB2 endpoint 2 control;host receiver endpoint control
        pub u2ep2_ctrl_r8_u2h_rx_ctrl: U2EP2_CTRL_R8_U2H_RX_CTRL,
        _reserved21: [u8; 0x01],
        ///0x2c - USB2 endpoint 3 transmittal length;host transmittal endpoint transmittal length
        pub u2ep3_t_len__r8_u2h_tx_len: U2EP3_T_LEN__R8_U2H_TX_LEN,
        _reserved22: [u8; 0x01],
        ///0x2e - USB2 endpoint 3 control;host transmittal endpoint control
        pub u2ep3_ctrl__r8_u2h_tx_ctrl: U2EP3_CTRL__R8_U2H_TX_CTRL,
        _reserved23: [u8; 0x01],
        ///0x30 - USB2 endpoint 4 transmittal length
        pub u2ep4_t_len: U2EP4_T_LEN,
        _reserved24: [u8; 0x01],
        ///0x32 - USB2 endpoint 4 control
        pub u2ep4_ctrl: U2EP4_CTRL,
        _reserved25: [u8; 0x21],
        ///0x54 - USB2 endpoint 5 DMA buffer address
        pub u2ep5_dma: U2EP5_DMA,
        _reserved26: [u8; 0x02],
        ///0x58 - USB2 endpoint 6 DMA buffer address
        pub u2ep6_dma: U2EP6_DMA,
        _reserved27: [u8; 0x02],
        ///0x5c - USB2 endpoint 7 DMA buffer address
        pub u2ep7_dma: U2EP7_DMA,
        _reserved28: [u8; 0x06],
        ///0x64 - USB2 endpoint 5 transmittal length
        pub u2ep5_t_len: U2EP5_T_LEN,
        _reserved29: [u8; 0x01],
        ///0x66 - USB2 endpoint 5 control
        pub u2ep5_ctrl: U2EP5_CTRL,
        _reserved30: [u8; 0x01],
        ///0x68 - USB2 endpoint 6 transmittal length
        pub u2ep6_t_len: U2EP6_T_LEN,
        _reserved31: [u8; 0x01],
        ///0x6a - USB2 endpoint 6 control
        pub u2ep6_ctrl: U2EP6_CTRL,
        _reserved32: [u8; 0x01],
        ///0x6c - USB2 endpoint 7 transmittal length
        pub u2ep7_t_len: U2EP7_T_LEN,
        _reserved33: [u8; 0x01],
        ///0x6e - USB2 endpoint 7 control
        pub u2ep7_ctrl: U2EP7_CTRL,
    }
    ///USB2_CTRL (rw) register accessor: an alias for `Reg<USB2_CTRL_SPEC>`
    pub type USB2_CTRL = crate::Reg<usb2_ctrl::USB2_CTRL_SPEC>;
    ///USB2 base control
    pub mod usb2_ctrl {
        ///Register `USB2_CTRL` reader
        pub struct R(crate::R<USB2_CTRL_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<USB2_CTRL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<USB2_CTRL_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<USB2_CTRL_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `USB2_CTRL` writer
        pub struct W(crate::W<USB2_CTRL_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<USB2_CTRL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<USB2_CTRL_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<USB2_CTRL_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `UC_DMA_EN` reader - DMA enable and DMA interrupt enable for USB
        pub type UC_DMA_EN_R = crate::BitReader<bool>;
        ///Field `UC_DMA_EN` writer - DMA enable and DMA interrupt enable for USB
        pub type UC_DMA_EN_W<'a, const O: u8> = crate::BitWriter<'a, u8, USB2_CTRL_SPEC, bool, O>;
        ///Field `UC_CLR_ALL` reader - force clear FIFO and count of USB
        pub type UC_CLR_ALL_R = crate::BitReader<bool>;
        ///Field `UC_CLR_ALL` writer - force clear FIFO and count of USB
        pub type UC_CLR_ALL_W<'a, const O: u8> = crate::BitWriter<'a, u8, USB2_CTRL_SPEC, bool, O>;
        ///Field `UC_RESET_SIE` reader - force reset USB SIE, need software clear
        pub type UC_RESET_SIE_R = crate::BitReader<bool>;
        ///Field `UC_RESET_SIE` writer - force reset USB SIE, need software clear
        pub type UC_RESET_SIE_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, USB2_CTRL_SPEC, bool, O>;
        ///Field `UC_INT_BUSY` reader - enable automatic responding busy for device mode or automatic pause for host mode during interrupt flag UIF_TRANSFER valid
        pub type UC_INT_BUSY_R = crate::BitReader<bool>;
        ///Field `UC_INT_BUSY` writer - enable automatic responding busy for device mode or automatic pause for host mode during interrupt flag UIF_TRANSFER valid
        pub type UC_INT_BUSY_W<'a, const O: u8> = crate::BitWriter<'a, u8, USB2_CTRL_SPEC, bool, O>;
        ///Field `MASK_UC_SYS_CTRL` reader - bit mask of USB system control
        pub type MASK_UC_SYS_CTRL_R = crate::FieldReader<u8, u8>;
        ///Field `MASK_UC_SYS_CTRL` writer - bit mask of USB system control
        pub type MASK_UC_SYS_CTRL_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, USB2_CTRL_SPEC, u8, u8, 2, O>;
        ///Field `UC_DEV_PU_EN` reader - USB device enable and internal pullup resistance enable
        pub type UC_DEV_PU_EN_R = crate::BitReader<bool>;
        ///Field `UC_DEV_PU_EN` writer - USB device enable and internal pullup resistance enable
        pub type UC_DEV_PU_EN_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, USB2_CTRL_SPEC, bool, O>;
        ///Field `UC_LOW_SPEED` reader - enable USB low speed: 0=12Mbps, 1=1.5Mbps
        pub type UC_LOW_SPEED_R = crate::BitReader<bool>;
        ///Field `UC_LOW_SPEED` writer - enable USB low speed: 0=12Mbps, 1=1.5Mbps
        pub type UC_LOW_SPEED_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, USB2_CTRL_SPEC, bool, O>;
        ///Field `UC_HOST_MODE` reader - enable USB host mode: 0=device mode, 1=host mode
        pub type UC_HOST_MODE_R = crate::BitReader<bool>;
        ///Field `UC_HOST_MODE` writer - enable USB host mode: 0=device mode, 1=host mode
        pub type UC_HOST_MODE_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, USB2_CTRL_SPEC, bool, O>;
        impl R {
            ///Bit 0 - DMA enable and DMA interrupt enable for USB
            #[inline(always)]
            pub fn uc_dma_en(&self) -> UC_DMA_EN_R {
                UC_DMA_EN_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - force clear FIFO and count of USB
            #[inline(always)]
            pub fn uc_clr_all(&self) -> UC_CLR_ALL_R {
                UC_CLR_ALL_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - force reset USB SIE, need software clear
            #[inline(always)]
            pub fn uc_reset_sie(&self) -> UC_RESET_SIE_R {
                UC_RESET_SIE_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - enable automatic responding busy for device mode or automatic pause for host mode during interrupt flag UIF_TRANSFER valid
            #[inline(always)]
            pub fn uc_int_busy(&self) -> UC_INT_BUSY_R {
                UC_INT_BUSY_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bits 4:5 - bit mask of USB system control
            #[inline(always)]
            pub fn mask_uc_sys_ctrl(&self) -> MASK_UC_SYS_CTRL_R {
                MASK_UC_SYS_CTRL_R::new((self.bits >> 4) & 3)
            }
            ///Bit 5 - USB device enable and internal pullup resistance enable
            #[inline(always)]
            pub fn uc_dev_pu_en(&self) -> UC_DEV_PU_EN_R {
                UC_DEV_PU_EN_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - enable USB low speed: 0=12Mbps, 1=1.5Mbps
            #[inline(always)]
            pub fn uc_low_speed(&self) -> UC_LOW_SPEED_R {
                UC_LOW_SPEED_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - enable USB host mode: 0=device mode, 1=host mode
            #[inline(always)]
            pub fn uc_host_mode(&self) -> UC_HOST_MODE_R {
                UC_HOST_MODE_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - DMA enable and DMA interrupt enable for USB
            #[inline(always)]
            #[must_use]
            pub fn uc_dma_en(&mut self) -> UC_DMA_EN_W<0> {
                UC_DMA_EN_W::new(self)
            }
            ///Bit 1 - force clear FIFO and count of USB
            #[inline(always)]
            #[must_use]
            pub fn uc_clr_all(&mut self) -> UC_CLR_ALL_W<1> {
                UC_CLR_ALL_W::new(self)
            }
            ///Bit 2 - force reset USB SIE, need software clear
            #[inline(always)]
            #[must_use]
            pub fn uc_reset_sie(&mut self) -> UC_RESET_SIE_W<2> {
                UC_RESET_SIE_W::new(self)
            }
            ///Bit 3 - enable automatic responding busy for device mode or automatic pause for host mode during interrupt flag UIF_TRANSFER valid
            #[inline(always)]
            #[must_use]
            pub fn uc_int_busy(&mut self) -> UC_INT_BUSY_W<3> {
                UC_INT_BUSY_W::new(self)
            }
            ///Bits 4:5 - bit mask of USB system control
            #[inline(always)]
            #[must_use]
            pub fn mask_uc_sys_ctrl(&mut self) -> MASK_UC_SYS_CTRL_W<4> {
                MASK_UC_SYS_CTRL_W::new(self)
            }
            ///Bit 5 - USB device enable and internal pullup resistance enable
            #[inline(always)]
            #[must_use]
            pub fn uc_dev_pu_en(&mut self) -> UC_DEV_PU_EN_W<5> {
                UC_DEV_PU_EN_W::new(self)
            }
            ///Bit 6 - enable USB low speed: 0=12Mbps, 1=1.5Mbps
            #[inline(always)]
            #[must_use]
            pub fn uc_low_speed(&mut self) -> UC_LOW_SPEED_W<6> {
                UC_LOW_SPEED_W::new(self)
            }
            ///Bit 7 - enable USB host mode: 0=device mode, 1=host mode
            #[inline(always)]
            #[must_use]
            pub fn uc_host_mode(&mut self) -> UC_HOST_MODE_W<7> {
                UC_HOST_MODE_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///USB2 base control
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [usb2_ctrl](index.html) module
        pub struct USB2_CTRL_SPEC;
        impl crate::RegisterSpec for USB2_CTRL_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [usb2_ctrl::R](R) reader structure
        impl crate::Readable for USB2_CTRL_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [usb2_ctrl::W](W) writer structure
        impl crate::Writable for USB2_CTRL_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets USB2_CTRL to value 0x06
        impl crate::Resettable for USB2_CTRL_SPEC {
            const RESET_VALUE: Self::Ux = 0x06;
        }
    }
    ///U2DEV_CTRL__R8_U2HOST_CTRL (rw) register accessor: an alias for `Reg<U2DEV_CTRL__R8_U2HOST_CTRL_SPEC>`
    pub type U2DEV_CTRL__R8_U2HOST_CTRL =
        crate::Reg<u2dev_ctrl__r8_u2host_ctrl::U2DEV_CTRL__R8_U2HOST_CTRL_SPEC>;
    ///USB2 device physical prot control
    pub mod u2dev_ctrl__r8_u2host_ctrl {
        ///Register `U2DEV_CTRL__R8_U2HOST_CTRL` reader
        pub struct R(crate::R<U2DEV_CTRL__R8_U2HOST_CTRL_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<U2DEV_CTRL__R8_U2HOST_CTRL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<U2DEV_CTRL__R8_U2HOST_CTRL_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<U2DEV_CTRL__R8_U2HOST_CTRL_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `U2DEV_CTRL__R8_U2HOST_CTRL` writer
        pub struct W(crate::W<U2DEV_CTRL__R8_U2HOST_CTRL_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<U2DEV_CTRL__R8_U2HOST_CTRL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<U2DEV_CTRL__R8_U2HOST_CTRL_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<U2DEV_CTRL__R8_U2HOST_CTRL_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `UD_PORT_EN__RB_UH_PORT_EN` reader - enable USB physical port I-O: 0=disable, 1=enable;enable USB port: 0=disable, 1=enable port, automatic disabled if USB device detached
        pub type UD_PORT_EN__RB_UH_PORT_EN_R = crate::BitReader<bool>;
        ///Field `UD_PORT_EN__RB_UH_PORT_EN` writer - enable USB physical port I-O: 0=disable, 1=enable;enable USB port: 0=disable, 1=enable port, automatic disabled if USB device detached
        pub type UD_PORT_EN__RB_UH_PORT_EN_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, U2DEV_CTRL__R8_U2HOST_CTRL_SPEC, bool, O>;
        ///Field `UD_GP_BIT__RB_UH_BUS_RESET` reader - general purpose bit;control USB bus reset: 0=normal, 1=force bus reset
        pub type UD_GP_BIT__RB_UH_BUS_RESET_R = crate::BitReader<bool>;
        ///Field `UD_GP_BIT__RB_UH_BUS_RESET` writer - general purpose bit;control USB bus reset: 0=normal, 1=force bus reset
        pub type UD_GP_BIT__RB_UH_BUS_RESET_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, U2DEV_CTRL__R8_U2HOST_CTRL_SPEC, bool, O>;
        ///Field `UD_LOW_SPEED__RB_UH_LOW_SPEED` reader - enable USB physical port low speed: 0=full speed, 1=low speed;enable USB port low speed: 0=full speed, 1=low speed
        pub type UD_LOW_SPEED__RB_UH_LOW_SPEED_R = crate::BitReader<bool>;
        ///Field `UD_LOW_SPEED__RB_UH_LOW_SPEED` writer - enable USB physical port low speed: 0=full speed, 1=low speed;enable USB port low speed: 0=full speed, 1=low speed
        pub type UD_LOW_SPEED__RB_UH_LOW_SPEED_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, U2DEV_CTRL__R8_U2HOST_CTRL_SPEC, bool, O>;
        ///Field `UD_DM_PIN__RB_UH_DM_PIN` reader - ReadOnly: indicate current UDM pin level
        pub type UD_DM_PIN__RB_UH_DM_PIN_R = crate::BitReader<bool>;
        ///Field `UD_DP_PIN__RB_UH_DP_PIN` reader - ReadOnly: indicate current UDP pin level
        pub type UD_DP_PIN__RB_UH_DP_PIN_R = crate::BitReader<bool>;
        ///Field `UD_PD_DIS__RB_UH_PD_DIS` reader - disable USB UDP-UDM pulldown resistance: 0=enable pulldown, 1=disable
        pub type UD_PD_DIS__RB_UH_PD_DIS_R = crate::BitReader<bool>;
        impl R {
            ///Bit 0 - enable USB physical port I-O: 0=disable, 1=enable;enable USB port: 0=disable, 1=enable port, automatic disabled if USB device detached
            #[inline(always)]
            pub fn ud_port_en__rb_uh_port_en(&self) -> UD_PORT_EN__RB_UH_PORT_EN_R {
                UD_PORT_EN__RB_UH_PORT_EN_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - general purpose bit;control USB bus reset: 0=normal, 1=force bus reset
            #[inline(always)]
            pub fn ud_gp_bit__rb_uh_bus_reset(&self) -> UD_GP_BIT__RB_UH_BUS_RESET_R {
                UD_GP_BIT__RB_UH_BUS_RESET_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - enable USB physical port low speed: 0=full speed, 1=low speed;enable USB port low speed: 0=full speed, 1=low speed
            #[inline(always)]
            pub fn ud_low_speed__rb_uh_low_speed(&self) -> UD_LOW_SPEED__RB_UH_LOW_SPEED_R {
                UD_LOW_SPEED__RB_UH_LOW_SPEED_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 4 - ReadOnly: indicate current UDM pin level
            #[inline(always)]
            pub fn ud_dm_pin__rb_uh_dm_pin(&self) -> UD_DM_PIN__RB_UH_DM_PIN_R {
                UD_DM_PIN__RB_UH_DM_PIN_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - ReadOnly: indicate current UDP pin level
            #[inline(always)]
            pub fn ud_dp_pin__rb_uh_dp_pin(&self) -> UD_DP_PIN__RB_UH_DP_PIN_R {
                UD_DP_PIN__RB_UH_DP_PIN_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 7 - disable USB UDP-UDM pulldown resistance: 0=enable pulldown, 1=disable
            #[inline(always)]
            pub fn ud_pd_dis__rb_uh_pd_dis(&self) -> UD_PD_DIS__RB_UH_PD_DIS_R {
                UD_PD_DIS__RB_UH_PD_DIS_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - enable USB physical port I-O: 0=disable, 1=enable;enable USB port: 0=disable, 1=enable port, automatic disabled if USB device detached
            #[inline(always)]
            #[must_use]
            pub fn ud_port_en__rb_uh_port_en(&mut self) -> UD_PORT_EN__RB_UH_PORT_EN_W<0> {
                UD_PORT_EN__RB_UH_PORT_EN_W::new(self)
            }
            ///Bit 1 - general purpose bit;control USB bus reset: 0=normal, 1=force bus reset
            #[inline(always)]
            #[must_use]
            pub fn ud_gp_bit__rb_uh_bus_reset(&mut self) -> UD_GP_BIT__RB_UH_BUS_RESET_W<1> {
                UD_GP_BIT__RB_UH_BUS_RESET_W::new(self)
            }
            ///Bit 2 - enable USB physical port low speed: 0=full speed, 1=low speed;enable USB port low speed: 0=full speed, 1=low speed
            #[inline(always)]
            #[must_use]
            pub fn ud_low_speed__rb_uh_low_speed(&mut self) -> UD_LOW_SPEED__RB_UH_LOW_SPEED_W<2> {
                UD_LOW_SPEED__RB_UH_LOW_SPEED_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///USB2 device physical prot control
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [u2dev_ctrl__r8_u2host_ctrl](index.html) module
        pub struct U2DEV_CTRL__R8_U2HOST_CTRL_SPEC;
        impl crate::RegisterSpec for U2DEV_CTRL__R8_U2HOST_CTRL_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [u2dev_ctrl__r8_u2host_ctrl::R](R) reader structure
        impl crate::Readable for U2DEV_CTRL__R8_U2HOST_CTRL_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [u2dev_ctrl__r8_u2host_ctrl::W](W) writer structure
        impl crate::Writable for U2DEV_CTRL__R8_U2HOST_CTRL_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets U2DEV_CTRL__R8_U2HOST_CTRL to value 0
        impl crate::Resettable for U2DEV_CTRL__R8_U2HOST_CTRL_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///USB2_INT_EN (rw) register accessor: an alias for `Reg<USB2_INT_EN_SPEC>`
    pub type USB2_INT_EN = crate::Reg<usb2_int_en::USB2_INT_EN_SPEC>;
    ///USB2 interrupt enable
    pub mod usb2_int_en {
        ///Register `USB2_INT_EN` reader
        pub struct R(crate::R<USB2_INT_EN_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<USB2_INT_EN_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<USB2_INT_EN_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<USB2_INT_EN_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `USB2_INT_EN` writer
        pub struct W(crate::W<USB2_INT_EN_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<USB2_INT_EN_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<USB2_INT_EN_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<USB2_INT_EN_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `UIE_BUS_RST__RB_UIE_DETECT` reader - enable interrupt for USB bus reset event for USB device mode;enable interrupt for USB device detected event for USB host mode
        pub type UIE_BUS_RST__RB_UIE_DETECT_R = crate::BitReader<bool>;
        ///Field `UIE_BUS_RST__RB_UIE_DETECT` writer - enable interrupt for USB bus reset event for USB device mode;enable interrupt for USB device detected event for USB host mode
        pub type UIE_BUS_RST__RB_UIE_DETECT_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, USB2_INT_EN_SPEC, bool, O>;
        ///Field `UIE_TRANSFER` reader - enable interrupt for USB transfer completion
        pub type UIE_TRANSFER_R = crate::BitReader<bool>;
        ///Field `UIE_TRANSFER` writer - enable interrupt for USB transfer completion
        pub type UIE_TRANSFER_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, USB2_INT_EN_SPEC, bool, O>;
        ///Field `UIE_SUSPEND` reader - enable interrupt for USB suspend or resume event
        pub type UIE_SUSPEND_R = crate::BitReader<bool>;
        ///Field `UIE_SUSPEND` writer - enable interrupt for USB suspend or resume event
        pub type UIE_SUSPEND_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, USB2_INT_EN_SPEC, bool, O>;
        ///Field `UIE_HST_SOF` reader - enable interrupt for host SOF timer action for USB host mode
        pub type UIE_HST_SOF_R = crate::BitReader<bool>;
        ///Field `UIE_HST_SOF` writer - enable interrupt for host SOF timer action for USB host mode
        pub type UIE_HST_SOF_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, USB2_INT_EN_SPEC, bool, O>;
        ///Field `UIE_FIFO_OV` reader - enable interrupt for FIFO overflow
        pub type UIE_FIFO_OV_R = crate::BitReader<bool>;
        ///Field `UIE_FIFO_OV` writer - enable interrupt for FIFO overflow
        pub type UIE_FIFO_OV_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, USB2_INT_EN_SPEC, bool, O>;
        ///Field `UIE_DEV_NAK` reader - enable interrupt for NAK responded for USB device mode
        pub type UIE_DEV_NAK_R = crate::BitReader<bool>;
        ///Field `UIE_DEV_NAK` writer - enable interrupt for NAK responded for USB device mode
        pub type UIE_DEV_NAK_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, USB2_INT_EN_SPEC, bool, O>;
        ///Field `UIE_DEV_SOF` reader - enable interrupt for SOF received for USB device mode
        pub type UIE_DEV_SOF_R = crate::BitReader<bool>;
        ///Field `UIE_DEV_SOF` writer - enable interrupt for SOF received for USB device mode
        pub type UIE_DEV_SOF_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, USB2_INT_EN_SPEC, bool, O>;
        impl R {
            ///Bit 0 - enable interrupt for USB bus reset event for USB device mode;enable interrupt for USB device detected event for USB host mode
            #[inline(always)]
            pub fn uie_bus_rst__rb_uie_detect(&self) -> UIE_BUS_RST__RB_UIE_DETECT_R {
                UIE_BUS_RST__RB_UIE_DETECT_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - enable interrupt for USB transfer completion
            #[inline(always)]
            pub fn uie_transfer(&self) -> UIE_TRANSFER_R {
                UIE_TRANSFER_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - enable interrupt for USB suspend or resume event
            #[inline(always)]
            pub fn uie_suspend(&self) -> UIE_SUSPEND_R {
                UIE_SUSPEND_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - enable interrupt for host SOF timer action for USB host mode
            #[inline(always)]
            pub fn uie_hst_sof(&self) -> UIE_HST_SOF_R {
                UIE_HST_SOF_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - enable interrupt for FIFO overflow
            #[inline(always)]
            pub fn uie_fifo_ov(&self) -> UIE_FIFO_OV_R {
                UIE_FIFO_OV_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 6 - enable interrupt for NAK responded for USB device mode
            #[inline(always)]
            pub fn uie_dev_nak(&self) -> UIE_DEV_NAK_R {
                UIE_DEV_NAK_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - enable interrupt for SOF received for USB device mode
            #[inline(always)]
            pub fn uie_dev_sof(&self) -> UIE_DEV_SOF_R {
                UIE_DEV_SOF_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - enable interrupt for USB bus reset event for USB device mode;enable interrupt for USB device detected event for USB host mode
            #[inline(always)]
            #[must_use]
            pub fn uie_bus_rst__rb_uie_detect(&mut self) -> UIE_BUS_RST__RB_UIE_DETECT_W<0> {
                UIE_BUS_RST__RB_UIE_DETECT_W::new(self)
            }
            ///Bit 1 - enable interrupt for USB transfer completion
            #[inline(always)]
            #[must_use]
            pub fn uie_transfer(&mut self) -> UIE_TRANSFER_W<1> {
                UIE_TRANSFER_W::new(self)
            }
            ///Bit 2 - enable interrupt for USB suspend or resume event
            #[inline(always)]
            #[must_use]
            pub fn uie_suspend(&mut self) -> UIE_SUSPEND_W<2> {
                UIE_SUSPEND_W::new(self)
            }
            ///Bit 3 - enable interrupt for host SOF timer action for USB host mode
            #[inline(always)]
            #[must_use]
            pub fn uie_hst_sof(&mut self) -> UIE_HST_SOF_W<3> {
                UIE_HST_SOF_W::new(self)
            }
            ///Bit 4 - enable interrupt for FIFO overflow
            #[inline(always)]
            #[must_use]
            pub fn uie_fifo_ov(&mut self) -> UIE_FIFO_OV_W<4> {
                UIE_FIFO_OV_W::new(self)
            }
            ///Bit 6 - enable interrupt for NAK responded for USB device mode
            #[inline(always)]
            #[must_use]
            pub fn uie_dev_nak(&mut self) -> UIE_DEV_NAK_W<6> {
                UIE_DEV_NAK_W::new(self)
            }
            ///Bit 7 - enable interrupt for SOF received for USB device mode
            #[inline(always)]
            #[must_use]
            pub fn uie_dev_sof(&mut self) -> UIE_DEV_SOF_W<7> {
                UIE_DEV_SOF_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///USB2 interrupt enable
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [usb2_int_en](index.html) module
        pub struct USB2_INT_EN_SPEC;
        impl crate::RegisterSpec for USB2_INT_EN_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [usb2_int_en::R](R) reader structure
        impl crate::Readable for USB2_INT_EN_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [usb2_int_en::W](W) writer structure
        impl crate::Writable for USB2_INT_EN_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets USB2_INT_EN to value 0
        impl crate::Resettable for USB2_INT_EN_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///USB2_DEV_AD (rw) register accessor: an alias for `Reg<USB2_DEV_AD_SPEC>`
    pub type USB2_DEV_AD = crate::Reg<usb2_dev_ad::USB2_DEV_AD_SPEC>;
    ///USB2 device address
    pub mod usb2_dev_ad {
        ///Register `USB2_DEV_AD` reader
        pub struct R(crate::R<USB2_DEV_AD_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<USB2_DEV_AD_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<USB2_DEV_AD_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<USB2_DEV_AD_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `USB2_DEV_AD` writer
        pub struct W(crate::W<USB2_DEV_AD_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<USB2_DEV_AD_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<USB2_DEV_AD_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<USB2_DEV_AD_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `MASK_USB_ADDR` reader - bit mask for USB device address
        pub type MASK_USB_ADDR_R = crate::FieldReader<u8, u8>;
        ///Field `MASK_USB_ADDR` writer - bit mask for USB device address
        pub type MASK_USB_ADDR_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, USB2_DEV_AD_SPEC, u8, u8, 7, O>;
        ///Field `UDA_GP_BIT` reader - general purpose bit
        pub type UDA_GP_BIT_R = crate::BitReader<bool>;
        ///Field `UDA_GP_BIT` writer - general purpose bit
        pub type UDA_GP_BIT_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, USB2_DEV_AD_SPEC, bool, O>;
        impl R {
            ///Bits 0:6 - bit mask for USB device address
            #[inline(always)]
            pub fn mask_usb_addr(&self) -> MASK_USB_ADDR_R {
                MASK_USB_ADDR_R::new(self.bits & 0x7f)
            }
            ///Bit 7 - general purpose bit
            #[inline(always)]
            pub fn uda_gp_bit(&self) -> UDA_GP_BIT_R {
                UDA_GP_BIT_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:6 - bit mask for USB device address
            #[inline(always)]
            #[must_use]
            pub fn mask_usb_addr(&mut self) -> MASK_USB_ADDR_W<0> {
                MASK_USB_ADDR_W::new(self)
            }
            ///Bit 7 - general purpose bit
            #[inline(always)]
            #[must_use]
            pub fn uda_gp_bit(&mut self) -> UDA_GP_BIT_W<7> {
                UDA_GP_BIT_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///USB2 device address
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [usb2_dev_ad](index.html) module
        pub struct USB2_DEV_AD_SPEC;
        impl crate::RegisterSpec for USB2_DEV_AD_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [usb2_dev_ad::R](R) reader structure
        impl crate::Readable for USB2_DEV_AD_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [usb2_dev_ad::W](W) writer structure
        impl crate::Writable for USB2_DEV_AD_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets USB2_DEV_AD to value 0
        impl crate::Resettable for USB2_DEV_AD_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///USB2_MIS_ST (r) register accessor: an alias for `Reg<USB2_MIS_ST_SPEC>`
    pub type USB2_MIS_ST = crate::Reg<usb2_mis_st::USB2_MIS_ST_SPEC>;
    ///USB2 miscellaneous status
    pub mod usb2_mis_st {
        ///Register `USB2_MIS_ST` reader
        pub struct R(crate::R<USB2_MIS_ST_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<USB2_MIS_ST_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<USB2_MIS_ST_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<USB2_MIS_ST_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `UMS_DEV_ATTACH` reader - RO, indicate device attached status on USB host
        pub type UMS_DEV_ATTACH_R = crate::BitReader<bool>;
        ///Field `UMS_DM_LEVEL` reader - RO, indicate UDM level saved at device attached to USB host
        pub type UMS_DM_LEVEL_R = crate::BitReader<bool>;
        ///Field `UMS_SUSPEND` reader - RO, indicate USB suspend status
        pub type UMS_SUSPEND_R = crate::BitReader<bool>;
        ///Field `UMS_BUS_RESET` reader - RO, indicate USB bus reset status
        pub type UMS_BUS_RESET_R = crate::BitReader<bool>;
        ///Field `UMS_R_FIFO_RDY` reader - RO, indicate USB receiving FIFO ready status (not empty)
        pub type UMS_R_FIFO_RDY_R = crate::BitReader<bool>;
        ///Field `UMS_SIE_FREE` reader - RO, indicate USB SIE free status
        pub type UMS_SIE_FREE_R = crate::BitReader<bool>;
        ///Field `UMS_SOF_ACT` reader - RO, indicate host SOF timer action status for USB host
        pub type UMS_SOF_ACT_R = crate::BitReader<bool>;
        ///Field `UMS_SOF_PRES` reader - RO, indicate host SOF timer presage status
        pub type UMS_SOF_PRES_R = crate::BitReader<bool>;
        impl R {
            ///Bit 0 - RO, indicate device attached status on USB host
            #[inline(always)]
            pub fn ums_dev_attach(&self) -> UMS_DEV_ATTACH_R {
                UMS_DEV_ATTACH_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RO, indicate UDM level saved at device attached to USB host
            #[inline(always)]
            pub fn ums_dm_level(&self) -> UMS_DM_LEVEL_R {
                UMS_DM_LEVEL_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RO, indicate USB suspend status
            #[inline(always)]
            pub fn ums_suspend(&self) -> UMS_SUSPEND_R {
                UMS_SUSPEND_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RO, indicate USB bus reset status
            #[inline(always)]
            pub fn ums_bus_reset(&self) -> UMS_BUS_RESET_R {
                UMS_BUS_RESET_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RO, indicate USB receiving FIFO ready status (not empty)
            #[inline(always)]
            pub fn ums_r_fifo_rdy(&self) -> UMS_R_FIFO_RDY_R {
                UMS_R_FIFO_RDY_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - RO, indicate USB SIE free status
            #[inline(always)]
            pub fn ums_sie_free(&self) -> UMS_SIE_FREE_R {
                UMS_SIE_FREE_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - RO, indicate host SOF timer action status for USB host
            #[inline(always)]
            pub fn ums_sof_act(&self) -> UMS_SOF_ACT_R {
                UMS_SOF_ACT_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - RO, indicate host SOF timer presage status
            #[inline(always)]
            pub fn ums_sof_pres(&self) -> UMS_SOF_PRES_R {
                UMS_SOF_PRES_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        ///USB2 miscellaneous status
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [usb2_mis_st](index.html) module
        pub struct USB2_MIS_ST_SPEC;
        impl crate::RegisterSpec for USB2_MIS_ST_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [usb2_mis_st::R](R) reader structure
        impl crate::Readable for USB2_MIS_ST_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets USB2_MIS_ST to value 0
        impl crate::Resettable for USB2_MIS_ST_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///USB2_INT_FG (rw) register accessor: an alias for `Reg<USB2_INT_FG_SPEC>`
    pub type USB2_INT_FG = crate::Reg<usb2_int_fg::USB2_INT_FG_SPEC>;
    ///USB2 interrupt flag
    pub mod usb2_int_fg {
        ///Register `USB2_INT_FG` reader
        pub struct R(crate::R<USB2_INT_FG_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<USB2_INT_FG_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<USB2_INT_FG_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<USB2_INT_FG_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `USB2_INT_FG` writer
        pub struct W(crate::W<USB2_INT_FG_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<USB2_INT_FG_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<USB2_INT_FG_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<USB2_INT_FG_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `UIF_BUS_RST__RB_UIF_DETECT` reader - RW,bus reset event interrupt flag for USB device mode, direct bit address clear or write 1 to clear;device detected event interrupt flag for USB host mode, direct bit address clear or write 1 to clear
        pub type UIF_BUS_RST__RB_UIF_DETECT_R = crate::BitReader<bool>;
        ///Field `UIF_BUS_RST__RB_UIF_DETECT` writer - RW,bus reset event interrupt flag for USB device mode, direct bit address clear or write 1 to clear;device detected event interrupt flag for USB host mode, direct bit address clear or write 1 to clear
        pub type UIF_BUS_RST__RB_UIF_DETECT_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, USB2_INT_FG_SPEC, bool, O>;
        ///Field `UIF_TRANSFER` reader - RW,USB transfer completion interrupt flag, direct bit address clear or write 1 to clear
        pub type UIF_TRANSFER_R = crate::BitReader<bool>;
        ///Field `UIF_TRANSFER` writer - RW,USB transfer completion interrupt flag, direct bit address clear or write 1 to clear
        pub type UIF_TRANSFER_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, USB2_INT_FG_SPEC, bool, O>;
        ///Field `UIF_SUSPEND` reader - RW,USB suspend or resume event interrupt flag, direct bit address clear or write 1 to clear
        pub type UIF_SUSPEND_R = crate::BitReader<bool>;
        ///Field `UIF_SUSPEND` writer - RW,USB suspend or resume event interrupt flag, direct bit address clear or write 1 to clear
        pub type UIF_SUSPEND_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, USB2_INT_FG_SPEC, bool, O>;
        ///Field `UIF_HST_SOF` reader - RW,host SOF timer interrupt flag for USB host, direct bit address clear or write 1 to clear
        pub type UIF_HST_SOF_R = crate::BitReader<bool>;
        ///Field `UIF_HST_SOF` writer - RW,host SOF timer interrupt flag for USB host, direct bit address clear or write 1 to clear
        pub type UIF_HST_SOF_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, USB2_INT_FG_SPEC, bool, O>;
        ///Field `UIF_FIFO_OV` reader - RW,FIFO overflow interrupt flag for USB, direct bit address clear or write 1 to clear
        pub type UIF_FIFO_OV_R = crate::BitReader<bool>;
        ///Field `UIF_FIFO_OV` writer - RW,FIFO overflow interrupt flag for USB, direct bit address clear or write 1 to clear
        pub type UIF_FIFO_OV_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, USB2_INT_FG_SPEC, bool, O>;
        ///Field `U_SIE_FREE` reader - RO, indicate USB SIE free status
        pub type U_SIE_FREE_R = crate::BitReader<bool>;
        ///Field `U_TOG_OK` reader - RO, indicate current USB transfer toggle is OK
        pub type U_TOG_OK_R = crate::BitReader<bool>;
        ///Field `U_IS_NAK` reader - RO, indicate current USB transfer is NAK received
        pub type U_IS_NAK_R = crate::BitReader<bool>;
        impl R {
            ///Bit 0 - RW,bus reset event interrupt flag for USB device mode, direct bit address clear or write 1 to clear;device detected event interrupt flag for USB host mode, direct bit address clear or write 1 to clear
            #[inline(always)]
            pub fn uif_bus_rst__rb_uif_detect(&self) -> UIF_BUS_RST__RB_UIF_DETECT_R {
                UIF_BUS_RST__RB_UIF_DETECT_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RW,USB transfer completion interrupt flag, direct bit address clear or write 1 to clear
            #[inline(always)]
            pub fn uif_transfer(&self) -> UIF_TRANSFER_R {
                UIF_TRANSFER_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RW,USB suspend or resume event interrupt flag, direct bit address clear or write 1 to clear
            #[inline(always)]
            pub fn uif_suspend(&self) -> UIF_SUSPEND_R {
                UIF_SUSPEND_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RW,host SOF timer interrupt flag for USB host, direct bit address clear or write 1 to clear
            #[inline(always)]
            pub fn uif_hst_sof(&self) -> UIF_HST_SOF_R {
                UIF_HST_SOF_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RW,FIFO overflow interrupt flag for USB, direct bit address clear or write 1 to clear
            #[inline(always)]
            pub fn uif_fifo_ov(&self) -> UIF_FIFO_OV_R {
                UIF_FIFO_OV_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - RO, indicate USB SIE free status
            #[inline(always)]
            pub fn u_sie_free(&self) -> U_SIE_FREE_R {
                U_SIE_FREE_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - RO, indicate current USB transfer toggle is OK
            #[inline(always)]
            pub fn u_tog_ok(&self) -> U_TOG_OK_R {
                U_TOG_OK_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - RO, indicate current USB transfer is NAK received
            #[inline(always)]
            pub fn u_is_nak(&self) -> U_IS_NAK_R {
                U_IS_NAK_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RW,bus reset event interrupt flag for USB device mode, direct bit address clear or write 1 to clear;device detected event interrupt flag for USB host mode, direct bit address clear or write 1 to clear
            #[inline(always)]
            #[must_use]
            pub fn uif_bus_rst__rb_uif_detect(&mut self) -> UIF_BUS_RST__RB_UIF_DETECT_W<0> {
                UIF_BUS_RST__RB_UIF_DETECT_W::new(self)
            }
            ///Bit 1 - RW,USB transfer completion interrupt flag, direct bit address clear or write 1 to clear
            #[inline(always)]
            #[must_use]
            pub fn uif_transfer(&mut self) -> UIF_TRANSFER_W<1> {
                UIF_TRANSFER_W::new(self)
            }
            ///Bit 2 - RW,USB suspend or resume event interrupt flag, direct bit address clear or write 1 to clear
            #[inline(always)]
            #[must_use]
            pub fn uif_suspend(&mut self) -> UIF_SUSPEND_W<2> {
                UIF_SUSPEND_W::new(self)
            }
            ///Bit 3 - RW,host SOF timer interrupt flag for USB host, direct bit address clear or write 1 to clear
            #[inline(always)]
            #[must_use]
            pub fn uif_hst_sof(&mut self) -> UIF_HST_SOF_W<3> {
                UIF_HST_SOF_W::new(self)
            }
            ///Bit 4 - RW,FIFO overflow interrupt flag for USB, direct bit address clear or write 1 to clear
            #[inline(always)]
            #[must_use]
            pub fn uif_fifo_ov(&mut self) -> UIF_FIFO_OV_W<4> {
                UIF_FIFO_OV_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///USB2 interrupt flag
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [usb2_int_fg](index.html) module
        pub struct USB2_INT_FG_SPEC;
        impl crate::RegisterSpec for USB2_INT_FG_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [usb2_int_fg::R](R) reader structure
        impl crate::Readable for USB2_INT_FG_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [usb2_int_fg::W](W) writer structure
        impl crate::Writable for USB2_INT_FG_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets USB2_INT_FG to value 0x20
        impl crate::Resettable for USB2_INT_FG_SPEC {
            const RESET_VALUE: Self::Ux = 0x20;
        }
    }
    ///USB2_INT_ST (r) register accessor: an alias for `Reg<USB2_INT_ST_SPEC>`
    pub type USB2_INT_ST = crate::Reg<usb2_int_st::USB2_INT_ST_SPEC>;
    ///USB2 interrupt status
    pub mod usb2_int_st {
        ///Register `USB2_INT_ST` reader
        pub struct R(crate::R<USB2_INT_ST_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<USB2_INT_ST_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<USB2_INT_ST_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<USB2_INT_ST_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `MASK_UIS_H_RES__MASK_UIS_ENDP` reader - RO, bit mask of current transfer handshake response for USB host mode: 0000=no response, time out from device, others=handshake response PID received;RO, bit mask of current transfer endpoint number for USB device mode
        pub type MASK_UIS_H_RES__MASK_UIS_ENDP_R = crate::FieldReader<u8, u8>;
        ///Field `MASK_UIS_TOKEN` reader - RO, bit mask of current token PID code received for USB device mode
        pub type MASK_UIS_TOKEN_R = crate::FieldReader<u8, u8>;
        ///Field `UIS_TOG_OK` reader - RO, indicate current USB transfer toggle is OK
        pub type UIS_TOG_OK_R = crate::BitReader<bool>;
        ///Field `UIS_SETUP_ACT` reader - RO, indicate current USB transfer is NAK received for USB device mode
        pub type UIS_SETUP_ACT_R = crate::BitReader<bool>;
        impl R {
            ///Bits 0:3 - RO, bit mask of current transfer handshake response for USB host mode: 0000=no response, time out from device, others=handshake response PID received;RO, bit mask of current transfer endpoint number for USB device mode
            #[inline(always)]
            pub fn mask_uis_h_res__mask_uis_endp(&self) -> MASK_UIS_H_RES__MASK_UIS_ENDP_R {
                MASK_UIS_H_RES__MASK_UIS_ENDP_R::new(self.bits & 0x0f)
            }
            ///Bits 4:5 - RO, bit mask of current token PID code received for USB device mode
            #[inline(always)]
            pub fn mask_uis_token(&self) -> MASK_UIS_TOKEN_R {
                MASK_UIS_TOKEN_R::new((self.bits >> 4) & 3)
            }
            ///Bit 6 - RO, indicate current USB transfer toggle is OK
            #[inline(always)]
            pub fn uis_tog_ok(&self) -> UIS_TOG_OK_R {
                UIS_TOG_OK_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - RO, indicate current USB transfer is NAK received for USB device mode
            #[inline(always)]
            pub fn uis_setup_act(&self) -> UIS_SETUP_ACT_R {
                UIS_SETUP_ACT_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        ///USB2 interrupt status
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [usb2_int_st](index.html) module
        pub struct USB2_INT_ST_SPEC;
        impl crate::RegisterSpec for USB2_INT_ST_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [usb2_int_st::R](R) reader structure
        impl crate::Readable for USB2_INT_ST_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets USB2_INT_ST to value 0
        impl crate::Resettable for USB2_INT_ST_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///USB2_RX_LEN (r) register accessor: an alias for `Reg<USB2_RX_LEN_SPEC>`
    pub type USB2_RX_LEN = crate::Reg<usb2_rx_len::USB2_RX_LEN_SPEC>;
    ///USB2 receiving length
    pub mod usb2_rx_len {
        ///Register `USB2_RX_LEN` reader
        pub struct R(crate::R<USB2_RX_LEN_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<USB2_RX_LEN_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<USB2_RX_LEN_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<USB2_RX_LEN_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `USB_RX_LEN` reader - RO,USB receiving length
        pub type USB_RX_LEN_R = crate::FieldReader<u8, u8>;
        impl R {
            ///Bits 0:7 - RO,USB receiving length
            #[inline(always)]
            pub fn usb_rx_len(&self) -> USB_RX_LEN_R {
                USB_RX_LEN_R::new(self.bits)
            }
        }
        ///USB2 receiving length
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [usb2_rx_len](index.html) module
        pub struct USB2_RX_LEN_SPEC;
        impl crate::RegisterSpec for USB2_RX_LEN_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [usb2_rx_len::R](R) reader structure
        impl crate::Readable for USB2_RX_LEN_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets USB2_RX_LEN to value 0
        impl crate::Resettable for USB2_RX_LEN_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///U2EP4_1_MOD (rw) register accessor: an alias for `Reg<U2EP4_1_MOD_SPEC>`
    pub type U2EP4_1_MOD = crate::Reg<u2ep4_1_mod::U2EP4_1_MOD_SPEC>;
    ///endpoint 4/1 mode
    pub mod u2ep4_1_mod {
        ///Register `U2EP4_1_MOD` reader
        pub struct R(crate::R<U2EP4_1_MOD_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<U2EP4_1_MOD_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<U2EP4_1_MOD_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<U2EP4_1_MOD_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `U2EP4_1_MOD` writer
        pub struct W(crate::W<U2EP4_1_MOD_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<U2EP4_1_MOD_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<U2EP4_1_MOD_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<U2EP4_1_MOD_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `UEP4_TX_EN` reader - enable USB endpoint 4 transmittal (IN)
        pub type UEP4_TX_EN_R = crate::BitReader<bool>;
        ///Field `UEP4_TX_EN` writer - enable USB endpoint 4 transmittal (IN)
        pub type UEP4_TX_EN_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, U2EP4_1_MOD_SPEC, bool, O>;
        ///Field `UEP4_RX_EN` reader - enable USB endpoint 4 receiving (OUT)
        pub type UEP4_RX_EN_R = crate::BitReader<bool>;
        ///Field `UEP4_RX_EN` writer - enable USB endpoint 4 receiving (OUT)
        pub type UEP4_RX_EN_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, U2EP4_1_MOD_SPEC, bool, O>;
        ///Field `UEP1_BUF_MOD` reader - buffer mode of USB endpoint 1
        pub type UEP1_BUF_MOD_R = crate::BitReader<bool>;
        ///Field `UEP1_BUF_MOD` writer - buffer mode of USB endpoint 1
        pub type UEP1_BUF_MOD_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, U2EP4_1_MOD_SPEC, bool, O>;
        ///Field `UEP1_TX_EN` reader - enable USB endpoint 1 transmittal (IN)
        pub type UEP1_TX_EN_R = crate::BitReader<bool>;
        ///Field `UEP1_TX_EN` writer - enable USB endpoint 1 transmittal (IN)
        pub type UEP1_TX_EN_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, U2EP4_1_MOD_SPEC, bool, O>;
        ///Field `UEP1_RX_EN` reader - enable USB endpoint 1 receiving (OUT)
        pub type UEP1_RX_EN_R = crate::BitReader<bool>;
        ///Field `UEP1_RX_EN` writer - enable USB endpoint 1 receiving (OUT)
        pub type UEP1_RX_EN_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, U2EP4_1_MOD_SPEC, bool, O>;
        impl R {
            ///Bit 2 - enable USB endpoint 4 transmittal (IN)
            #[inline(always)]
            pub fn uep4_tx_en(&self) -> UEP4_TX_EN_R {
                UEP4_TX_EN_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - enable USB endpoint 4 receiving (OUT)
            #[inline(always)]
            pub fn uep4_rx_en(&self) -> UEP4_RX_EN_R {
                UEP4_RX_EN_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - buffer mode of USB endpoint 1
            #[inline(always)]
            pub fn uep1_buf_mod(&self) -> UEP1_BUF_MOD_R {
                UEP1_BUF_MOD_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 6 - enable USB endpoint 1 transmittal (IN)
            #[inline(always)]
            pub fn uep1_tx_en(&self) -> UEP1_TX_EN_R {
                UEP1_TX_EN_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - enable USB endpoint 1 receiving (OUT)
            #[inline(always)]
            pub fn uep1_rx_en(&self) -> UEP1_RX_EN_R {
                UEP1_RX_EN_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 2 - enable USB endpoint 4 transmittal (IN)
            #[inline(always)]
            #[must_use]
            pub fn uep4_tx_en(&mut self) -> UEP4_TX_EN_W<2> {
                UEP4_TX_EN_W::new(self)
            }
            ///Bit 3 - enable USB endpoint 4 receiving (OUT)
            #[inline(always)]
            #[must_use]
            pub fn uep4_rx_en(&mut self) -> UEP4_RX_EN_W<3> {
                UEP4_RX_EN_W::new(self)
            }
            ///Bit 4 - buffer mode of USB endpoint 1
            #[inline(always)]
            #[must_use]
            pub fn uep1_buf_mod(&mut self) -> UEP1_BUF_MOD_W<4> {
                UEP1_BUF_MOD_W::new(self)
            }
            ///Bit 6 - enable USB endpoint 1 transmittal (IN)
            #[inline(always)]
            #[must_use]
            pub fn uep1_tx_en(&mut self) -> UEP1_TX_EN_W<6> {
                UEP1_TX_EN_W::new(self)
            }
            ///Bit 7 - enable USB endpoint 1 receiving (OUT)
            #[inline(always)]
            #[must_use]
            pub fn uep1_rx_en(&mut self) -> UEP1_RX_EN_W<7> {
                UEP1_RX_EN_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///endpoint 4/1 mode
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [u2ep4_1_mod](index.html) module
        pub struct U2EP4_1_MOD_SPEC;
        impl crate::RegisterSpec for U2EP4_1_MOD_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [u2ep4_1_mod::R](R) reader structure
        impl crate::Readable for U2EP4_1_MOD_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [u2ep4_1_mod::W](W) writer structure
        impl crate::Writable for U2EP4_1_MOD_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets U2EP4_1_MOD to value 0
        impl crate::Resettable for U2EP4_1_MOD_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///U2EP2_3_MOD__R8_U2H_EP_MOD (rw) register accessor: an alias for `Reg<U2EP2_3_MOD__R8_U2H_EP_MOD_SPEC>`
    pub type U2EP2_3_MOD__R8_U2H_EP_MOD =
        crate::Reg<u2ep2_3_mod__r8_u2h_ep_mod::U2EP2_3_MOD__R8_U2H_EP_MOD_SPEC>;
    ///endpoint 2_3 mode;host endpoint mode
    pub mod u2ep2_3_mod__r8_u2h_ep_mod {
        ///Register `U2EP2_3_MOD__R8_U2H_EP_MOD` reader
        pub struct R(crate::R<U2EP2_3_MOD__R8_U2H_EP_MOD_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<U2EP2_3_MOD__R8_U2H_EP_MOD_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<U2EP2_3_MOD__R8_U2H_EP_MOD_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<U2EP2_3_MOD__R8_U2H_EP_MOD_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `U2EP2_3_MOD__R8_U2H_EP_MOD` writer
        pub struct W(crate::W<U2EP2_3_MOD__R8_U2H_EP_MOD_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<U2EP2_3_MOD__R8_U2H_EP_MOD_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<U2EP2_3_MOD__R8_U2H_EP_MOD_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<U2EP2_3_MOD__R8_U2H_EP_MOD_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `UEP2_BUF_MOD__RB_UH_EP_RBUF_MOD` reader - buffer mode of USB endpoint 2;buffer mode of USB host IN endpoint
        pub type UEP2_BUF_MOD__RB_UH_EP_RBUF_MOD_R = crate::BitReader<bool>;
        ///Field `UEP2_BUF_MOD__RB_UH_EP_RBUF_MOD` writer - buffer mode of USB endpoint 2;buffer mode of USB host IN endpoint
        pub type UEP2_BUF_MOD__RB_UH_EP_RBUF_MOD_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, U2EP2_3_MOD__R8_U2H_EP_MOD_SPEC, bool, O>;
        ///Field `UEP2_TX_EN` reader - enable USB endpoint 2 transmittal (IN)
        pub type UEP2_TX_EN_R = crate::BitReader<bool>;
        ///Field `UEP2_TX_EN` writer - enable USB endpoint 2 transmittal (IN)
        pub type UEP2_TX_EN_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, U2EP2_3_MOD__R8_U2H_EP_MOD_SPEC, bool, O>;
        ///Field `UEP2_RX_EN__RB_UH_EP_RX_EN` reader - enable USB endpoint 2 receiving (OUT);enable USB host IN endpoint receiving
        pub type UEP2_RX_EN__RB_UH_EP_RX_EN_R = crate::BitReader<bool>;
        ///Field `UEP2_RX_EN__RB_UH_EP_RX_EN` writer - enable USB endpoint 2 receiving (OUT);enable USB host IN endpoint receiving
        pub type UEP2_RX_EN__RB_UH_EP_RX_EN_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, U2EP2_3_MOD__R8_U2H_EP_MOD_SPEC, bool, O>;
        ///Field `UEP3_BUF_MOD__RB_UH_EP_TBUF_MOD` reader - buffer mode of USB endpoint 3;buffer mode of USB host OUT endpoint
        pub type UEP3_BUF_MOD__RB_UH_EP_TBUF_MOD_R = crate::BitReader<bool>;
        ///Field `UEP3_BUF_MOD__RB_UH_EP_TBUF_MOD` writer - buffer mode of USB endpoint 3;buffer mode of USB host OUT endpoint
        pub type UEP3_BUF_MOD__RB_UH_EP_TBUF_MOD_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, U2EP2_3_MOD__R8_U2H_EP_MOD_SPEC, bool, O>;
        ///Field `UEP3_TX_EN__RB_UH_EP_TX_EN` reader - enable USB endpoint 3 transmittal (IN);enable USB host OUT endpoint transmittal
        pub type UEP3_TX_EN__RB_UH_EP_TX_EN_R = crate::BitReader<bool>;
        ///Field `UEP3_TX_EN__RB_UH_EP_TX_EN` writer - enable USB endpoint 3 transmittal (IN);enable USB host OUT endpoint transmittal
        pub type UEP3_TX_EN__RB_UH_EP_TX_EN_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, U2EP2_3_MOD__R8_U2H_EP_MOD_SPEC, bool, O>;
        ///Field `UEP3_RX_EN` reader - enable USB endpoint 3 receiving (OUT)
        pub type UEP3_RX_EN_R = crate::BitReader<bool>;
        ///Field `UEP3_RX_EN` writer - enable USB endpoint 3 receiving (OUT)
        pub type UEP3_RX_EN_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, U2EP2_3_MOD__R8_U2H_EP_MOD_SPEC, bool, O>;
        impl R {
            ///Bit 0 - buffer mode of USB endpoint 2;buffer mode of USB host IN endpoint
            #[inline(always)]
            pub fn uep2_buf_mod__rb_uh_ep_rbuf_mod(&self) -> UEP2_BUF_MOD__RB_UH_EP_RBUF_MOD_R {
                UEP2_BUF_MOD__RB_UH_EP_RBUF_MOD_R::new((self.bits & 1) != 0)
            }
            ///Bit 2 - enable USB endpoint 2 transmittal (IN)
            #[inline(always)]
            pub fn uep2_tx_en(&self) -> UEP2_TX_EN_R {
                UEP2_TX_EN_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - enable USB endpoint 2 receiving (OUT);enable USB host IN endpoint receiving
            #[inline(always)]
            pub fn uep2_rx_en__rb_uh_ep_rx_en(&self) -> UEP2_RX_EN__RB_UH_EP_RX_EN_R {
                UEP2_RX_EN__RB_UH_EP_RX_EN_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - buffer mode of USB endpoint 3;buffer mode of USB host OUT endpoint
            #[inline(always)]
            pub fn uep3_buf_mod__rb_uh_ep_tbuf_mod(&self) -> UEP3_BUF_MOD__RB_UH_EP_TBUF_MOD_R {
                UEP3_BUF_MOD__RB_UH_EP_TBUF_MOD_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 6 - enable USB endpoint 3 transmittal (IN);enable USB host OUT endpoint transmittal
            #[inline(always)]
            pub fn uep3_tx_en__rb_uh_ep_tx_en(&self) -> UEP3_TX_EN__RB_UH_EP_TX_EN_R {
                UEP3_TX_EN__RB_UH_EP_TX_EN_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - enable USB endpoint 3 receiving (OUT)
            #[inline(always)]
            pub fn uep3_rx_en(&self) -> UEP3_RX_EN_R {
                UEP3_RX_EN_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - buffer mode of USB endpoint 2;buffer mode of USB host IN endpoint
            #[inline(always)]
            #[must_use]
            pub fn uep2_buf_mod__rb_uh_ep_rbuf_mod(
                &mut self,
            ) -> UEP2_BUF_MOD__RB_UH_EP_RBUF_MOD_W<0> {
                UEP2_BUF_MOD__RB_UH_EP_RBUF_MOD_W::new(self)
            }
            ///Bit 2 - enable USB endpoint 2 transmittal (IN)
            #[inline(always)]
            #[must_use]
            pub fn uep2_tx_en(&mut self) -> UEP2_TX_EN_W<2> {
                UEP2_TX_EN_W::new(self)
            }
            ///Bit 3 - enable USB endpoint 2 receiving (OUT);enable USB host IN endpoint receiving
            #[inline(always)]
            #[must_use]
            pub fn uep2_rx_en__rb_uh_ep_rx_en(&mut self) -> UEP2_RX_EN__RB_UH_EP_RX_EN_W<3> {
                UEP2_RX_EN__RB_UH_EP_RX_EN_W::new(self)
            }
            ///Bit 4 - buffer mode of USB endpoint 3;buffer mode of USB host OUT endpoint
            #[inline(always)]
            #[must_use]
            pub fn uep3_buf_mod__rb_uh_ep_tbuf_mod(
                &mut self,
            ) -> UEP3_BUF_MOD__RB_UH_EP_TBUF_MOD_W<4> {
                UEP3_BUF_MOD__RB_UH_EP_TBUF_MOD_W::new(self)
            }
            ///Bit 6 - enable USB endpoint 3 transmittal (IN);enable USB host OUT endpoint transmittal
            #[inline(always)]
            #[must_use]
            pub fn uep3_tx_en__rb_uh_ep_tx_en(&mut self) -> UEP3_TX_EN__RB_UH_EP_TX_EN_W<6> {
                UEP3_TX_EN__RB_UH_EP_TX_EN_W::new(self)
            }
            ///Bit 7 - enable USB endpoint 3 receiving (OUT)
            #[inline(always)]
            #[must_use]
            pub fn uep3_rx_en(&mut self) -> UEP3_RX_EN_W<7> {
                UEP3_RX_EN_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///endpoint 2_3 mode;host endpoint mode
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [u2ep2_3_mod__r8_u2h_ep_mod](index.html) module
        pub struct U2EP2_3_MOD__R8_U2H_EP_MOD_SPEC;
        impl crate::RegisterSpec for U2EP2_3_MOD__R8_U2H_EP_MOD_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [u2ep2_3_mod__r8_u2h_ep_mod::R](R) reader structure
        impl crate::Readable for U2EP2_3_MOD__R8_U2H_EP_MOD_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [u2ep2_3_mod__r8_u2h_ep_mod::W](W) writer structure
        impl crate::Writable for U2EP2_3_MOD__R8_U2H_EP_MOD_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets U2EP2_3_MOD__R8_U2H_EP_MOD to value 0
        impl crate::Resettable for U2EP2_3_MOD__R8_U2H_EP_MOD_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///U2EP567_MOD (rw) register accessor: an alias for `Reg<U2EP567_MOD_SPEC>`
    pub type U2EP567_MOD = crate::Reg<u2ep567_mod::U2EP567_MOD_SPEC>;
    ///USB2 endpoint 5/6/7 mode
    pub mod u2ep567_mod {
        ///Register `U2EP567_MOD` reader
        pub struct R(crate::R<U2EP567_MOD_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<U2EP567_MOD_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<U2EP567_MOD_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<U2EP567_MOD_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `U2EP567_MOD` writer
        pub struct W(crate::W<U2EP567_MOD_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<U2EP567_MOD_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<U2EP567_MOD_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<U2EP567_MOD_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `UEP5_TX_EN` reader - enable USB endpoint 5 transmittal (IN)
        pub type UEP5_TX_EN_R = crate::BitReader<bool>;
        ///Field `UEP5_TX_EN` writer - enable USB endpoint 5 transmittal (IN)
        pub type UEP5_TX_EN_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, U2EP567_MOD_SPEC, bool, O>;
        ///Field `UEP5_RX_EN` reader - enable USB endpoint 5 receiving (OUT)
        pub type UEP5_RX_EN_R = crate::BitReader<bool>;
        ///Field `UEP5_RX_EN` writer - enable USB endpoint 5 receiving (OUT)
        pub type UEP5_RX_EN_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, U2EP567_MOD_SPEC, bool, O>;
        ///Field `UEP6_TX_EN` reader - enable USB endpoint 6 transmittal (IN)
        pub type UEP6_TX_EN_R = crate::BitReader<bool>;
        ///Field `UEP6_TX_EN` writer - enable USB endpoint 6 transmittal (IN)
        pub type UEP6_TX_EN_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, U2EP567_MOD_SPEC, bool, O>;
        ///Field `UEP6_RX_EN` reader - enable USB endpoint 6 receiving (OUT)
        pub type UEP6_RX_EN_R = crate::BitReader<bool>;
        ///Field `UEP6_RX_EN` writer - enable USB endpoint 6 receiving (OUT)
        pub type UEP6_RX_EN_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, U2EP567_MOD_SPEC, bool, O>;
        ///Field `UEP7_TX_EN` reader - enable USB endpoint 7 transmittal (IN)
        pub type UEP7_TX_EN_R = crate::BitReader<bool>;
        ///Field `UEP7_TX_EN` writer - enable USB endpoint 7 transmittal (IN)
        pub type UEP7_TX_EN_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, U2EP567_MOD_SPEC, bool, O>;
        ///Field `UEP7_RX_EN` reader - enable USB endpoint 7 receiving (OUT)
        pub type UEP7_RX_EN_R = crate::BitReader<bool>;
        ///Field `UEP7_RX_EN` writer - enable USB endpoint 7 receiving (OUT)
        pub type UEP7_RX_EN_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, U2EP567_MOD_SPEC, bool, O>;
        impl R {
            ///Bit 0 - enable USB endpoint 5 transmittal (IN)
            #[inline(always)]
            pub fn uep5_tx_en(&self) -> UEP5_TX_EN_R {
                UEP5_TX_EN_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - enable USB endpoint 5 receiving (OUT)
            #[inline(always)]
            pub fn uep5_rx_en(&self) -> UEP5_RX_EN_R {
                UEP5_RX_EN_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - enable USB endpoint 6 transmittal (IN)
            #[inline(always)]
            pub fn uep6_tx_en(&self) -> UEP6_TX_EN_R {
                UEP6_TX_EN_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - enable USB endpoint 6 receiving (OUT)
            #[inline(always)]
            pub fn uep6_rx_en(&self) -> UEP6_RX_EN_R {
                UEP6_RX_EN_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - enable USB endpoint 7 transmittal (IN)
            #[inline(always)]
            pub fn uep7_tx_en(&self) -> UEP7_TX_EN_R {
                UEP7_TX_EN_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - enable USB endpoint 7 receiving (OUT)
            #[inline(always)]
            pub fn uep7_rx_en(&self) -> UEP7_RX_EN_R {
                UEP7_RX_EN_R::new(((self.bits >> 5) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - enable USB endpoint 5 transmittal (IN)
            #[inline(always)]
            #[must_use]
            pub fn uep5_tx_en(&mut self) -> UEP5_TX_EN_W<0> {
                UEP5_TX_EN_W::new(self)
            }
            ///Bit 1 - enable USB endpoint 5 receiving (OUT)
            #[inline(always)]
            #[must_use]
            pub fn uep5_rx_en(&mut self) -> UEP5_RX_EN_W<1> {
                UEP5_RX_EN_W::new(self)
            }
            ///Bit 2 - enable USB endpoint 6 transmittal (IN)
            #[inline(always)]
            #[must_use]
            pub fn uep6_tx_en(&mut self) -> UEP6_TX_EN_W<2> {
                UEP6_TX_EN_W::new(self)
            }
            ///Bit 3 - enable USB endpoint 6 receiving (OUT)
            #[inline(always)]
            #[must_use]
            pub fn uep6_rx_en(&mut self) -> UEP6_RX_EN_W<3> {
                UEP6_RX_EN_W::new(self)
            }
            ///Bit 4 - enable USB endpoint 7 transmittal (IN)
            #[inline(always)]
            #[must_use]
            pub fn uep7_tx_en(&mut self) -> UEP7_TX_EN_W<4> {
                UEP7_TX_EN_W::new(self)
            }
            ///Bit 5 - enable USB endpoint 7 receiving (OUT)
            #[inline(always)]
            #[must_use]
            pub fn uep7_rx_en(&mut self) -> UEP7_RX_EN_W<5> {
                UEP7_RX_EN_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///USB2 endpoint 5/6/7 mode
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [u2ep567_mod](index.html) module
        pub struct U2EP567_MOD_SPEC;
        impl crate::RegisterSpec for U2EP567_MOD_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [u2ep567_mod::R](R) reader structure
        impl crate::Readable for U2EP567_MOD_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [u2ep567_mod::W](W) writer structure
        impl crate::Writable for U2EP567_MOD_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets U2EP567_MOD to value 0
        impl crate::Resettable for U2EP567_MOD_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///U2EP0_DMA (rw) register accessor: an alias for `Reg<U2EP0_DMA_SPEC>`
    pub type U2EP0_DMA = crate::Reg<u2ep0_dma::U2EP0_DMA_SPEC>;
    ///endpoint 0 DMA buffer address
    pub mod u2ep0_dma {
        ///Register `U2EP0_DMA` reader
        pub struct R(crate::R<U2EP0_DMA_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<U2EP0_DMA_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<U2EP0_DMA_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<U2EP0_DMA_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `U2EP0_DMA` writer
        pub struct W(crate::W<U2EP0_DMA_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<U2EP0_DMA_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<U2EP0_DMA_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<U2EP0_DMA_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `UEP0_DMA` reader - RW,endpoint 0 DMA buffer address
        pub type UEP0_DMA_R = crate::FieldReader<u16, u16>;
        ///Field `UEP0_DMA` writer - RW,endpoint 0 DMA buffer address
        pub type UEP0_DMA_W<'a, const O: u8> =
            crate::FieldWriter<'a, u16, U2EP0_DMA_SPEC, u16, u16, 16, O>;
        impl R {
            ///Bits 0:15 - RW,endpoint 0 DMA buffer address
            #[inline(always)]
            pub fn uep0_dma(&self) -> UEP0_DMA_R {
                UEP0_DMA_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - RW,endpoint 0 DMA buffer address
            #[inline(always)]
            #[must_use]
            pub fn uep0_dma(&mut self) -> UEP0_DMA_W<0> {
                UEP0_DMA_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///endpoint 0 DMA buffer address
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [u2ep0_dma](index.html) module
        pub struct U2EP0_DMA_SPEC;
        impl crate::RegisterSpec for U2EP0_DMA_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [u2ep0_dma::R](R) reader structure
        impl crate::Readable for U2EP0_DMA_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [u2ep0_dma::W](W) writer structure
        impl crate::Writable for U2EP0_DMA_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets U2EP0_DMA to value 0
        impl crate::Resettable for U2EP0_DMA_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///U2EP1_DMA (rw) register accessor: an alias for `Reg<U2EP1_DMA_SPEC>`
    pub type U2EP1_DMA = crate::Reg<u2ep1_dma::U2EP1_DMA_SPEC>;
    ///USB2 endpoint 1 DMA buffer address
    pub mod u2ep1_dma {
        ///Register `U2EP1_DMA` reader
        pub struct R(crate::R<U2EP1_DMA_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<U2EP1_DMA_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<U2EP1_DMA_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<U2EP1_DMA_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `U2EP1_DMA` writer
        pub struct W(crate::W<U2EP1_DMA_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<U2EP1_DMA_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<U2EP1_DMA_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<U2EP1_DMA_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `UEP1_DMA` reader - RW,endpoint 1 DMA buffer address
        pub type UEP1_DMA_R = crate::FieldReader<u16, u16>;
        ///Field `UEP1_DMA` writer - RW,endpoint 1 DMA buffer address
        pub type UEP1_DMA_W<'a, const O: u8> =
            crate::FieldWriter<'a, u16, U2EP1_DMA_SPEC, u16, u16, 16, O>;
        impl R {
            ///Bits 0:15 - RW,endpoint 1 DMA buffer address
            #[inline(always)]
            pub fn uep1_dma(&self) -> UEP1_DMA_R {
                UEP1_DMA_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - RW,endpoint 1 DMA buffer address
            #[inline(always)]
            #[must_use]
            pub fn uep1_dma(&mut self) -> UEP1_DMA_W<0> {
                UEP1_DMA_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///USB2 endpoint 1 DMA buffer address
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [u2ep1_dma](index.html) module
        pub struct U2EP1_DMA_SPEC;
        impl crate::RegisterSpec for U2EP1_DMA_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [u2ep1_dma::R](R) reader structure
        impl crate::Readable for U2EP1_DMA_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [u2ep1_dma::W](W) writer structure
        impl crate::Writable for U2EP1_DMA_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets U2EP1_DMA to value 0
        impl crate::Resettable for U2EP1_DMA_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///U2EP2_DMA__R16_U2H_RX_DMA (rw) register accessor: an alias for `Reg<U2EP2_DMA__R16_U2H_RX_DMA_SPEC>`
    pub type U2EP2_DMA__R16_U2H_RX_DMA =
        crate::Reg<u2ep2_dma__r16_u2h_rx_dma::U2EP2_DMA__R16_U2H_RX_DMA_SPEC>;
    ///USB2 endpoint 2 DMA buffer address;host rx endpoint buffer high address
    pub mod u2ep2_dma__r16_u2h_rx_dma {
        ///Register `U2EP2_DMA__R16_U2H_RX_DMA` reader
        pub struct R(crate::R<U2EP2_DMA__R16_U2H_RX_DMA_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<U2EP2_DMA__R16_U2H_RX_DMA_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<U2EP2_DMA__R16_U2H_RX_DMA_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<U2EP2_DMA__R16_U2H_RX_DMA_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `U2EP2_DMA__R16_U2H_RX_DMA` writer
        pub struct W(crate::W<U2EP2_DMA__R16_U2H_RX_DMA_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<U2EP2_DMA__R16_U2H_RX_DMA_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<U2EP2_DMA__R16_U2H_RX_DMA_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<U2EP2_DMA__R16_U2H_RX_DMA_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `UEP2_DMA` reader - RW,endpoint 2 DMA buffer address;host rx endpoint buffer high address
        pub type UEP2_DMA_R = crate::FieldReader<u16, u16>;
        ///Field `UEP2_DMA` writer - RW,endpoint 2 DMA buffer address;host rx endpoint buffer high address
        pub type UEP2_DMA_W<'a, const O: u8> =
            crate::FieldWriter<'a, u16, U2EP2_DMA__R16_U2H_RX_DMA_SPEC, u16, u16, 16, O>;
        impl R {
            ///Bits 0:15 - RW,endpoint 2 DMA buffer address;host rx endpoint buffer high address
            #[inline(always)]
            pub fn uep2_dma(&self) -> UEP2_DMA_R {
                UEP2_DMA_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - RW,endpoint 2 DMA buffer address;host rx endpoint buffer high address
            #[inline(always)]
            #[must_use]
            pub fn uep2_dma(&mut self) -> UEP2_DMA_W<0> {
                UEP2_DMA_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///USB2 endpoint 2 DMA buffer address;host rx endpoint buffer high address
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [u2ep2_dma__r16_u2h_rx_dma](index.html) module
        pub struct U2EP2_DMA__R16_U2H_RX_DMA_SPEC;
        impl crate::RegisterSpec for U2EP2_DMA__R16_U2H_RX_DMA_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [u2ep2_dma__r16_u2h_rx_dma::R](R) reader structure
        impl crate::Readable for U2EP2_DMA__R16_U2H_RX_DMA_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [u2ep2_dma__r16_u2h_rx_dma::W](W) writer structure
        impl crate::Writable for U2EP2_DMA__R16_U2H_RX_DMA_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets U2EP2_DMA__R16_U2H_RX_DMA to value 0
        impl crate::Resettable for U2EP2_DMA__R16_U2H_RX_DMA_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///U2EP3_DMA__R16_U2H_TX_DMA (rw) register accessor: an alias for `Reg<U2EP3_DMA__R16_U2H_TX_DMA_SPEC>`
    pub type U2EP3_DMA__R16_U2H_TX_DMA =
        crate::Reg<u2ep3_dma__r16_u2h_tx_dma::U2EP3_DMA__R16_U2H_TX_DMA_SPEC>;
    ///USB2 endpoint 3 DMA buffer address;host tx endpoint buffer high address
    pub mod u2ep3_dma__r16_u2h_tx_dma {
        ///Register `U2EP3_DMA__R16_U2H_TX_DMA` reader
        pub struct R(crate::R<U2EP3_DMA__R16_U2H_TX_DMA_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<U2EP3_DMA__R16_U2H_TX_DMA_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<U2EP3_DMA__R16_U2H_TX_DMA_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<U2EP3_DMA__R16_U2H_TX_DMA_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `U2EP3_DMA__R16_U2H_TX_DMA` writer
        pub struct W(crate::W<U2EP3_DMA__R16_U2H_TX_DMA_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<U2EP3_DMA__R16_U2H_TX_DMA_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<U2EP3_DMA__R16_U2H_TX_DMA_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<U2EP3_DMA__R16_U2H_TX_DMA_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `UEP3_DMA` reader - RW,endpoint 3 DMA buffer address;host rx endpoint buffer high address
        pub type UEP3_DMA_R = crate::FieldReader<u16, u16>;
        ///Field `UEP3_DMA` writer - RW,endpoint 3 DMA buffer address;host rx endpoint buffer high address
        pub type UEP3_DMA_W<'a, const O: u8> =
            crate::FieldWriter<'a, u16, U2EP3_DMA__R16_U2H_TX_DMA_SPEC, u16, u16, 16, O>;
        impl R {
            ///Bits 0:15 - RW,endpoint 3 DMA buffer address;host rx endpoint buffer high address
            #[inline(always)]
            pub fn uep3_dma(&self) -> UEP3_DMA_R {
                UEP3_DMA_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - RW,endpoint 3 DMA buffer address;host rx endpoint buffer high address
            #[inline(always)]
            #[must_use]
            pub fn uep3_dma(&mut self) -> UEP3_DMA_W<0> {
                UEP3_DMA_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///USB2 endpoint 3 DMA buffer address;host tx endpoint buffer high address
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [u2ep3_dma__r16_u2h_tx_dma](index.html) module
        pub struct U2EP3_DMA__R16_U2H_TX_DMA_SPEC;
        impl crate::RegisterSpec for U2EP3_DMA__R16_U2H_TX_DMA_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [u2ep3_dma__r16_u2h_tx_dma::R](R) reader structure
        impl crate::Readable for U2EP3_DMA__R16_U2H_TX_DMA_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [u2ep3_dma__r16_u2h_tx_dma::W](W) writer structure
        impl crate::Writable for U2EP3_DMA__R16_U2H_TX_DMA_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets U2EP3_DMA__R16_U2H_TX_DMA to value 0
        impl crate::Resettable for U2EP3_DMA__R16_U2H_TX_DMA_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///U2EP5_DMA (rw) register accessor: an alias for `Reg<U2EP5_DMA_SPEC>`
    pub type U2EP5_DMA = crate::Reg<u2ep5_dma::U2EP5_DMA_SPEC>;
    ///USB2 endpoint 5 DMA buffer address
    pub mod u2ep5_dma {
        ///Register `U2EP5_DMA` reader
        pub struct R(crate::R<U2EP5_DMA_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<U2EP5_DMA_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<U2EP5_DMA_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<U2EP5_DMA_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `U2EP5_DMA` writer
        pub struct W(crate::W<U2EP5_DMA_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<U2EP5_DMA_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<U2EP5_DMA_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<U2EP5_DMA_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `UEP5_DMA` reader - RW,endpoint 5 DMA buffer address;host rx endpoint buffer high address
        pub type UEP5_DMA_R = crate::FieldReader<u16, u16>;
        ///Field `UEP5_DMA` writer - RW,endpoint 5 DMA buffer address;host rx endpoint buffer high address
        pub type UEP5_DMA_W<'a, const O: u8> =
            crate::FieldWriter<'a, u16, U2EP5_DMA_SPEC, u16, u16, 16, O>;
        impl R {
            ///Bits 0:15 - RW,endpoint 5 DMA buffer address;host rx endpoint buffer high address
            #[inline(always)]
            pub fn uep5_dma(&self) -> UEP5_DMA_R {
                UEP5_DMA_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - RW,endpoint 5 DMA buffer address;host rx endpoint buffer high address
            #[inline(always)]
            #[must_use]
            pub fn uep5_dma(&mut self) -> UEP5_DMA_W<0> {
                UEP5_DMA_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///USB2 endpoint 5 DMA buffer address
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [u2ep5_dma](index.html) module
        pub struct U2EP5_DMA_SPEC;
        impl crate::RegisterSpec for U2EP5_DMA_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [u2ep5_dma::R](R) reader structure
        impl crate::Readable for U2EP5_DMA_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [u2ep5_dma::W](W) writer structure
        impl crate::Writable for U2EP5_DMA_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets U2EP5_DMA to value 0
        impl crate::Resettable for U2EP5_DMA_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///U2EP6_DMA (rw) register accessor: an alias for `Reg<U2EP6_DMA_SPEC>`
    pub type U2EP6_DMA = crate::Reg<u2ep6_dma::U2EP6_DMA_SPEC>;
    ///USB2 endpoint 6 DMA buffer address
    pub mod u2ep6_dma {
        ///Register `U2EP6_DMA` reader
        pub struct R(crate::R<U2EP6_DMA_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<U2EP6_DMA_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<U2EP6_DMA_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<U2EP6_DMA_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `U2EP6_DMA` writer
        pub struct W(crate::W<U2EP6_DMA_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<U2EP6_DMA_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<U2EP6_DMA_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<U2EP6_DMA_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `UEP6_DMA` reader - RW,endpoint 6 DMA buffer address;host rx endpoint buffer high address
        pub type UEP6_DMA_R = crate::FieldReader<u16, u16>;
        ///Field `UEP6_DMA` writer - RW,endpoint 6 DMA buffer address;host rx endpoint buffer high address
        pub type UEP6_DMA_W<'a, const O: u8> =
            crate::FieldWriter<'a, u16, U2EP6_DMA_SPEC, u16, u16, 16, O>;
        impl R {
            ///Bits 0:15 - RW,endpoint 6 DMA buffer address;host rx endpoint buffer high address
            #[inline(always)]
            pub fn uep6_dma(&self) -> UEP6_DMA_R {
                UEP6_DMA_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - RW,endpoint 6 DMA buffer address;host rx endpoint buffer high address
            #[inline(always)]
            #[must_use]
            pub fn uep6_dma(&mut self) -> UEP6_DMA_W<0> {
                UEP6_DMA_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///USB2 endpoint 6 DMA buffer address
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [u2ep6_dma](index.html) module
        pub struct U2EP6_DMA_SPEC;
        impl crate::RegisterSpec for U2EP6_DMA_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [u2ep6_dma::R](R) reader structure
        impl crate::Readable for U2EP6_DMA_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [u2ep6_dma::W](W) writer structure
        impl crate::Writable for U2EP6_DMA_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets U2EP6_DMA to value 0
        impl crate::Resettable for U2EP6_DMA_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///U2EP7_DMA (rw) register accessor: an alias for `Reg<U2EP7_DMA_SPEC>`
    pub type U2EP7_DMA = crate::Reg<u2ep7_dma::U2EP7_DMA_SPEC>;
    ///USB2 endpoint 7 DMA buffer address
    pub mod u2ep7_dma {
        ///Register `U2EP7_DMA` reader
        pub struct R(crate::R<U2EP7_DMA_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<U2EP7_DMA_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<U2EP7_DMA_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<U2EP7_DMA_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `U2EP7_DMA` writer
        pub struct W(crate::W<U2EP7_DMA_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<U2EP7_DMA_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<U2EP7_DMA_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<U2EP7_DMA_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `UEP7_DMA` reader - RW,endpoint 7 DMA buffer address;host rx endpoint buffer high address
        pub type UEP7_DMA_R = crate::FieldReader<u16, u16>;
        ///Field `UEP7_DMA` writer - RW,endpoint 7 DMA buffer address;host rx endpoint buffer high address
        pub type UEP7_DMA_W<'a, const O: u8> =
            crate::FieldWriter<'a, u16, U2EP7_DMA_SPEC, u16, u16, 16, O>;
        impl R {
            ///Bits 0:15 - RW,endpoint 7 DMA buffer address;host rx endpoint buffer high address
            #[inline(always)]
            pub fn uep7_dma(&self) -> UEP7_DMA_R {
                UEP7_DMA_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - RW,endpoint 7 DMA buffer address;host rx endpoint buffer high address
            #[inline(always)]
            #[must_use]
            pub fn uep7_dma(&mut self) -> UEP7_DMA_W<0> {
                UEP7_DMA_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///USB2 endpoint 7 DMA buffer address
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [u2ep7_dma](index.html) module
        pub struct U2EP7_DMA_SPEC;
        impl crate::RegisterSpec for U2EP7_DMA_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [u2ep7_dma::R](R) reader structure
        impl crate::Readable for U2EP7_DMA_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [u2ep7_dma::W](W) writer structure
        impl crate::Writable for U2EP7_DMA_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets U2EP7_DMA to value 0
        impl crate::Resettable for U2EP7_DMA_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///U2EP0_T_LEN (rw) register accessor: an alias for `Reg<U2EP0_T_LEN_SPEC>`
    pub type U2EP0_T_LEN = crate::Reg<u2ep0_t_len::U2EP0_T_LEN_SPEC>;
    ///USB2 endpoint 0 transmittal length
    pub mod u2ep0_t_len {
        ///Register `U2EP0_T_LEN` reader
        pub struct R(crate::R<U2EP0_T_LEN_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<U2EP0_T_LEN_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<U2EP0_T_LEN_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<U2EP0_T_LEN_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `U2EP0_T_LEN` writer
        pub struct W(crate::W<U2EP0_T_LEN_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<U2EP0_T_LEN_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<U2EP0_T_LEN_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<U2EP0_T_LEN_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `UEP0_T_LEN` reader - endpoint 0 transmittal length
        pub type UEP0_T_LEN_R = crate::FieldReader<u8, u8>;
        ///Field `UEP0_T_LEN` writer - endpoint 0 transmittal length
        pub type UEP0_T_LEN_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, U2EP0_T_LEN_SPEC, u8, u8, 8, O>;
        impl R {
            ///Bits 0:7 - endpoint 0 transmittal length
            #[inline(always)]
            pub fn uep0_t_len(&self) -> UEP0_T_LEN_R {
                UEP0_T_LEN_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:7 - endpoint 0 transmittal length
            #[inline(always)]
            #[must_use]
            pub fn uep0_t_len(&mut self) -> UEP0_T_LEN_W<0> {
                UEP0_T_LEN_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///USB2 endpoint 0 transmittal length
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [u2ep0_t_len](index.html) module
        pub struct U2EP0_T_LEN_SPEC;
        impl crate::RegisterSpec for U2EP0_T_LEN_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [u2ep0_t_len::R](R) reader structure
        impl crate::Readable for U2EP0_T_LEN_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [u2ep0_t_len::W](W) writer structure
        impl crate::Writable for U2EP0_T_LEN_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets U2EP0_T_LEN to value 0
        impl crate::Resettable for U2EP0_T_LEN_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///U2EP0_CTRL (rw) register accessor: an alias for `Reg<U2EP0_CTRL_SPEC>`
    pub type U2EP0_CTRL = crate::Reg<u2ep0_ctrl::U2EP0_CTRL_SPEC>;
    ///USB2 endpoint 0 control
    pub mod u2ep0_ctrl {
        ///Register `U2EP0_CTRL` reader
        pub struct R(crate::R<U2EP0_CTRL_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<U2EP0_CTRL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<U2EP0_CTRL_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<U2EP0_CTRL_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `U2EP0_CTRL` writer
        pub struct W(crate::W<U2EP0_CTRL_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<U2EP0_CTRL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<U2EP0_CTRL_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<U2EP0_CTRL_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `MASK_UEP_T_RES` reader - bit mask of handshake response type for USB endpoint X transmittal (IN)
        pub type MASK_UEP_T_RES_R = crate::FieldReader<u8, u8>;
        ///Field `MASK_UEP_T_RES` writer - bit mask of handshake response type for USB endpoint X transmittal (IN)
        pub type MASK_UEP_T_RES_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, U2EP0_CTRL_SPEC, u8, u8, 2, O>;
        ///Field `MASK_UEP_R_RES` reader - bit mask of handshake response type for USB endpoint X receiving (OUT)
        pub type MASK_UEP_R_RES_R = crate::FieldReader<u8, u8>;
        ///Field `MASK_UEP_R_RES` writer - bit mask of handshake response type for USB endpoint X receiving (OUT)
        pub type MASK_UEP_R_RES_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, U2EP0_CTRL_SPEC, u8, u8, 2, O>;
        ///Field `UEP_AUTO_TOG` reader - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
        pub type UEP_AUTO_TOG_R = crate::BitReader<bool>;
        ///Field `UEP_AUTO_TOG` writer - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
        pub type UEP_AUTO_TOG_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, U2EP0_CTRL_SPEC, bool, O>;
        ///Field `UEP_T_TOG` reader - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
        pub type UEP_T_TOG_R = crate::BitReader<bool>;
        ///Field `UEP_T_TOG` writer - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
        pub type UEP_T_TOG_W<'a, const O: u8> = crate::BitWriter<'a, u8, U2EP0_CTRL_SPEC, bool, O>;
        ///Field `UEP_R_TOG` reader - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
        pub type UEP_R_TOG_R = crate::BitReader<bool>;
        ///Field `UEP_R_TOG` writer - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
        pub type UEP_R_TOG_W<'a, const O: u8> = crate::BitWriter<'a, u8, U2EP0_CTRL_SPEC, bool, O>;
        impl R {
            ///Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)
            #[inline(always)]
            pub fn mask_uep_t_res(&self) -> MASK_UEP_T_RES_R {
                MASK_UEP_T_RES_R::new(self.bits & 3)
            }
            ///Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)
            #[inline(always)]
            pub fn mask_uep_r_res(&self) -> MASK_UEP_R_RES_R {
                MASK_UEP_R_RES_R::new((self.bits >> 2) & 3)
            }
            ///Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
            #[inline(always)]
            pub fn uep_auto_tog(&self) -> UEP_AUTO_TOG_R {
                UEP_AUTO_TOG_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
            #[inline(always)]
            pub fn uep_t_tog(&self) -> UEP_T_TOG_R {
                UEP_T_TOG_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
            #[inline(always)]
            pub fn uep_r_tog(&self) -> UEP_R_TOG_R {
                UEP_R_TOG_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)
            #[inline(always)]
            #[must_use]
            pub fn mask_uep_t_res(&mut self) -> MASK_UEP_T_RES_W<0> {
                MASK_UEP_T_RES_W::new(self)
            }
            ///Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)
            #[inline(always)]
            #[must_use]
            pub fn mask_uep_r_res(&mut self) -> MASK_UEP_R_RES_W<2> {
                MASK_UEP_R_RES_W::new(self)
            }
            ///Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
            #[inline(always)]
            #[must_use]
            pub fn uep_auto_tog(&mut self) -> UEP_AUTO_TOG_W<4> {
                UEP_AUTO_TOG_W::new(self)
            }
            ///Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
            #[inline(always)]
            #[must_use]
            pub fn uep_t_tog(&mut self) -> UEP_T_TOG_W<6> {
                UEP_T_TOG_W::new(self)
            }
            ///Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
            #[inline(always)]
            #[must_use]
            pub fn uep_r_tog(&mut self) -> UEP_R_TOG_W<7> {
                UEP_R_TOG_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///USB2 endpoint 0 control
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [u2ep0_ctrl](index.html) module
        pub struct U2EP0_CTRL_SPEC;
        impl crate::RegisterSpec for U2EP0_CTRL_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [u2ep0_ctrl::R](R) reader structure
        impl crate::Readable for U2EP0_CTRL_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [u2ep0_ctrl::W](W) writer structure
        impl crate::Writable for U2EP0_CTRL_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets U2EP0_CTRL to value 0
        impl crate::Resettable for U2EP0_CTRL_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///U2EP1_T_LEN (rw) register accessor: an alias for `Reg<U2EP1_T_LEN_SPEC>`
    pub type U2EP1_T_LEN = crate::Reg<u2ep1_t_len::U2EP1_T_LEN_SPEC>;
    ///USB2 endpoint 1 transmittal length
    pub mod u2ep1_t_len {
        ///Register `U2EP1_T_LEN` reader
        pub struct R(crate::R<U2EP1_T_LEN_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<U2EP1_T_LEN_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<U2EP1_T_LEN_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<U2EP1_T_LEN_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `U2EP1_T_LEN` writer
        pub struct W(crate::W<U2EP1_T_LEN_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<U2EP1_T_LEN_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<U2EP1_T_LEN_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<U2EP1_T_LEN_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `UEP1_T_LEN` reader - endpoint 1 transmittal length
        pub type UEP1_T_LEN_R = crate::FieldReader<u8, u8>;
        ///Field `UEP1_T_LEN` writer - endpoint 1 transmittal length
        pub type UEP1_T_LEN_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, U2EP1_T_LEN_SPEC, u8, u8, 8, O>;
        impl R {
            ///Bits 0:7 - endpoint 1 transmittal length
            #[inline(always)]
            pub fn uep1_t_len(&self) -> UEP1_T_LEN_R {
                UEP1_T_LEN_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:7 - endpoint 1 transmittal length
            #[inline(always)]
            #[must_use]
            pub fn uep1_t_len(&mut self) -> UEP1_T_LEN_W<0> {
                UEP1_T_LEN_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///USB2 endpoint 1 transmittal length
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [u2ep1_t_len](index.html) module
        pub struct U2EP1_T_LEN_SPEC;
        impl crate::RegisterSpec for U2EP1_T_LEN_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [u2ep1_t_len::R](R) reader structure
        impl crate::Readable for U2EP1_T_LEN_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [u2ep1_t_len::W](W) writer structure
        impl crate::Writable for U2EP1_T_LEN_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets U2EP1_T_LEN to value 0
        impl crate::Resettable for U2EP1_T_LEN_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///U2EP1_CTRL__R8_U2H_SETUP (rw) register accessor: an alias for `Reg<U2EP1_CTRL__R8_U2H_SETUP_SPEC>`
    pub type U2EP1_CTRL__R8_U2H_SETUP =
        crate::Reg<u2ep1_ctrl__r8_u2h_setup::U2EP1_CTRL__R8_U2H_SETUP_SPEC>;
    ///USB2 endpoint 1 control;host aux setup
    pub mod u2ep1_ctrl__r8_u2h_setup {
        ///Register `U2EP1_CTRL__R8_U2H_SETUP` reader
        pub struct R(crate::R<U2EP1_CTRL__R8_U2H_SETUP_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<U2EP1_CTRL__R8_U2H_SETUP_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<U2EP1_CTRL__R8_U2H_SETUP_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<U2EP1_CTRL__R8_U2H_SETUP_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `U2EP1_CTRL__R8_U2H_SETUP` writer
        pub struct W(crate::W<U2EP1_CTRL__R8_U2H_SETUP_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<U2EP1_CTRL__R8_U2H_SETUP_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<U2EP1_CTRL__R8_U2H_SETUP_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<U2EP1_CTRL__R8_U2H_SETUP_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `MASK_UEP_T_RES` reader - bit mask of handshake response type for USB endpoint X transmittal (IN)
        pub type MASK_UEP_T_RES_R = crate::FieldReader<u8, u8>;
        ///Field `MASK_UEP_T_RES` writer - bit mask of handshake response type for USB endpoint X transmittal (IN)
        pub type MASK_UEP_T_RES_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, U2EP1_CTRL__R8_U2H_SETUP_SPEC, u8, u8, 2, O>;
        ///Field `MASK_UEP_R_RES` reader - bit mask of handshake response type for USB endpoint X receiving (OUT)
        pub type MASK_UEP_R_RES_R = crate::FieldReader<u8, u8>;
        ///Field `MASK_UEP_R_RES` writer - bit mask of handshake response type for USB endpoint X receiving (OUT)
        pub type MASK_UEP_R_RES_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, U2EP1_CTRL__R8_U2H_SETUP_SPEC, u8, u8, 2, O>;
        ///Field `UEP_AUTO_TOG` reader - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
        pub type UEP_AUTO_TOG_R = crate::BitReader<bool>;
        ///Field `UEP_AUTO_TOG` writer - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
        pub type UEP_AUTO_TOG_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, U2EP1_CTRL__R8_U2H_SETUP_SPEC, bool, O>;
        ///Field `UEP_T_TOG__RB_UH_SOF_EN` reader - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1;USB host automatic SOF enable
        pub type UEP_T_TOG__RB_UH_SOF_EN_R = crate::BitReader<bool>;
        ///Field `UEP_T_TOG__RB_UH_SOF_EN` writer - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1;USB host automatic SOF enable
        pub type UEP_T_TOG__RB_UH_SOF_EN_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, U2EP1_CTRL__R8_U2H_SETUP_SPEC, bool, O>;
        ///Field `UEP_R_TOG__RB_UH_PRE_PID_EN` reader - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1;RB_UH_PRE_PID_EN;USB host PRE PID enable for low speed device via hub
        pub type UEP_R_TOG__RB_UH_PRE_PID_EN_R = crate::BitReader<bool>;
        ///Field `UEP_R_TOG__RB_UH_PRE_PID_EN` writer - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1;RB_UH_PRE_PID_EN;USB host PRE PID enable for low speed device via hub
        pub type UEP_R_TOG__RB_UH_PRE_PID_EN_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, U2EP1_CTRL__R8_U2H_SETUP_SPEC, bool, O>;
        impl R {
            ///Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)
            #[inline(always)]
            pub fn mask_uep_t_res(&self) -> MASK_UEP_T_RES_R {
                MASK_UEP_T_RES_R::new(self.bits & 3)
            }
            ///Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)
            #[inline(always)]
            pub fn mask_uep_r_res(&self) -> MASK_UEP_R_RES_R {
                MASK_UEP_R_RES_R::new((self.bits >> 2) & 3)
            }
            ///Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
            #[inline(always)]
            pub fn uep_auto_tog(&self) -> UEP_AUTO_TOG_R {
                UEP_AUTO_TOG_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1;USB host automatic SOF enable
            #[inline(always)]
            pub fn uep_t_tog__rb_uh_sof_en(&self) -> UEP_T_TOG__RB_UH_SOF_EN_R {
                UEP_T_TOG__RB_UH_SOF_EN_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1;RB_UH_PRE_PID_EN;USB host PRE PID enable for low speed device via hub
            #[inline(always)]
            pub fn uep_r_tog__rb_uh_pre_pid_en(&self) -> UEP_R_TOG__RB_UH_PRE_PID_EN_R {
                UEP_R_TOG__RB_UH_PRE_PID_EN_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)
            #[inline(always)]
            #[must_use]
            pub fn mask_uep_t_res(&mut self) -> MASK_UEP_T_RES_W<0> {
                MASK_UEP_T_RES_W::new(self)
            }
            ///Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)
            #[inline(always)]
            #[must_use]
            pub fn mask_uep_r_res(&mut self) -> MASK_UEP_R_RES_W<2> {
                MASK_UEP_R_RES_W::new(self)
            }
            ///Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
            #[inline(always)]
            #[must_use]
            pub fn uep_auto_tog(&mut self) -> UEP_AUTO_TOG_W<4> {
                UEP_AUTO_TOG_W::new(self)
            }
            ///Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1;USB host automatic SOF enable
            #[inline(always)]
            #[must_use]
            pub fn uep_t_tog__rb_uh_sof_en(&mut self) -> UEP_T_TOG__RB_UH_SOF_EN_W<6> {
                UEP_T_TOG__RB_UH_SOF_EN_W::new(self)
            }
            ///Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1;RB_UH_PRE_PID_EN;USB host PRE PID enable for low speed device via hub
            #[inline(always)]
            #[must_use]
            pub fn uep_r_tog__rb_uh_pre_pid_en(&mut self) -> UEP_R_TOG__RB_UH_PRE_PID_EN_W<7> {
                UEP_R_TOG__RB_UH_PRE_PID_EN_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///USB2 endpoint 1 control;host aux setup
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [u2ep1_ctrl__r8_u2h_setup](index.html) module
        pub struct U2EP1_CTRL__R8_U2H_SETUP_SPEC;
        impl crate::RegisterSpec for U2EP1_CTRL__R8_U2H_SETUP_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [u2ep1_ctrl__r8_u2h_setup::R](R) reader structure
        impl crate::Readable for U2EP1_CTRL__R8_U2H_SETUP_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [u2ep1_ctrl__r8_u2h_setup::W](W) writer structure
        impl crate::Writable for U2EP1_CTRL__R8_U2H_SETUP_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets U2EP1_CTRL__R8_U2H_SETUP to value 0
        impl crate::Resettable for U2EP1_CTRL__R8_U2H_SETUP_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///U2EP2_T_LEN_R8_U2H_EP_PID (rw) register accessor: an alias for `Reg<U2EP2_T_LEN_R8_U2H_EP_PID_SPEC>`
    pub type U2EP2_T_LEN_R8_U2H_EP_PID =
        crate::Reg<u2ep2_t_len_r8_u2h_ep_pid::U2EP2_T_LEN_R8_U2H_EP_PID_SPEC>;
    ///USB2 endpoint 2 transmittal length;host endpoint and PID
    pub mod u2ep2_t_len_r8_u2h_ep_pid {
        ///Register `U2EP2_T_LEN_R8_U2H_EP_PID` reader
        pub struct R(crate::R<U2EP2_T_LEN_R8_U2H_EP_PID_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<U2EP2_T_LEN_R8_U2H_EP_PID_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<U2EP2_T_LEN_R8_U2H_EP_PID_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<U2EP2_T_LEN_R8_U2H_EP_PID_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `U2EP2_T_LEN_R8_U2H_EP_PID` writer
        pub struct W(crate::W<U2EP2_T_LEN_R8_U2H_EP_PID_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<U2EP2_T_LEN_R8_U2H_EP_PID_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<U2EP2_T_LEN_R8_U2H_EP_PID_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<U2EP2_T_LEN_R8_U2H_EP_PID_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `MASK_UH_ENDP` reader - bit mask of endpoint number for USB host transfer
        pub type MASK_UH_ENDP_R = crate::FieldReader<u8, u8>;
        ///Field `MASK_UH_ENDP` writer - bit mask of endpoint number for USB host transfer
        pub type MASK_UH_ENDP_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, U2EP2_T_LEN_R8_U2H_EP_PID_SPEC, u8, u8, 4, O>;
        ///Field `UEP2_T_LEN` reader - endpoint 2 transmittal length;
        pub type UEP2_T_LEN_R = crate::FieldReader<u8, u8>;
        ///Field `UEP2_T_LEN` writer - endpoint 2 transmittal length;
        pub type UEP2_T_LEN_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, U2EP2_T_LEN_R8_U2H_EP_PID_SPEC, u8, u8, 8, O>;
        ///Field `MASK_UH_TOKEN` reader - bit mask of token PID for USB host transfer
        pub type MASK_UH_TOKEN_R = crate::FieldReader<u8, u8>;
        ///Field `MASK_UH_TOKEN` writer - bit mask of token PID for USB host transfer
        pub type MASK_UH_TOKEN_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, U2EP2_T_LEN_R8_U2H_EP_PID_SPEC, u8, u8, 4, O>;
        impl R {
            ///Bits 0:3 - bit mask of endpoint number for USB host transfer
            #[inline(always)]
            pub fn mask_uh_endp(&self) -> MASK_UH_ENDP_R {
                MASK_UH_ENDP_R::new(self.bits & 0x0f)
            }
            ///Bits 0:7 - endpoint 2 transmittal length;
            #[inline(always)]
            pub fn uep2_t_len(&self) -> UEP2_T_LEN_R {
                UEP2_T_LEN_R::new(self.bits)
            }
            ///Bits 4:7 - bit mask of token PID for USB host transfer
            #[inline(always)]
            pub fn mask_uh_token(&self) -> MASK_UH_TOKEN_R {
                MASK_UH_TOKEN_R::new((self.bits >> 4) & 0x0f)
            }
        }
        impl W {
            ///Bits 0:3 - bit mask of endpoint number for USB host transfer
            #[inline(always)]
            #[must_use]
            pub fn mask_uh_endp(&mut self) -> MASK_UH_ENDP_W<0> {
                MASK_UH_ENDP_W::new(self)
            }
            ///Bits 0:7 - endpoint 2 transmittal length;
            #[inline(always)]
            #[must_use]
            pub fn uep2_t_len(&mut self) -> UEP2_T_LEN_W<0> {
                UEP2_T_LEN_W::new(self)
            }
            ///Bits 4:7 - bit mask of token PID for USB host transfer
            #[inline(always)]
            #[must_use]
            pub fn mask_uh_token(&mut self) -> MASK_UH_TOKEN_W<4> {
                MASK_UH_TOKEN_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///USB2 endpoint 2 transmittal length;host endpoint and PID
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [u2ep2_t_len_r8_u2h_ep_pid](index.html) module
        pub struct U2EP2_T_LEN_R8_U2H_EP_PID_SPEC;
        impl crate::RegisterSpec for U2EP2_T_LEN_R8_U2H_EP_PID_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [u2ep2_t_len_r8_u2h_ep_pid::R](R) reader structure
        impl crate::Readable for U2EP2_T_LEN_R8_U2H_EP_PID_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [u2ep2_t_len_r8_u2h_ep_pid::W](W) writer structure
        impl crate::Writable for U2EP2_T_LEN_R8_U2H_EP_PID_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets U2EP2_T_LEN_R8_U2H_EP_PID to value 0
        impl crate::Resettable for U2EP2_T_LEN_R8_U2H_EP_PID_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///U2EP2_CTRL_R8_U2H_RX_CTRL (rw) register accessor: an alias for `Reg<U2EP2_CTRL_R8_U2H_RX_CTRL_SPEC>`
    pub type U2EP2_CTRL_R8_U2H_RX_CTRL =
        crate::Reg<u2ep2_ctrl_r8_u2h_rx_ctrl::U2EP2_CTRL_R8_U2H_RX_CTRL_SPEC>;
    ///USB2 endpoint 2 control;host receiver endpoint control
    pub mod u2ep2_ctrl_r8_u2h_rx_ctrl {
        ///Register `U2EP2_CTRL_R8_U2H_RX_CTRL` reader
        pub struct R(crate::R<U2EP2_CTRL_R8_U2H_RX_CTRL_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<U2EP2_CTRL_R8_U2H_RX_CTRL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<U2EP2_CTRL_R8_U2H_RX_CTRL_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<U2EP2_CTRL_R8_U2H_RX_CTRL_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `U2EP2_CTRL_R8_U2H_RX_CTRL` writer
        pub struct W(crate::W<U2EP2_CTRL_R8_U2H_RX_CTRL_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<U2EP2_CTRL_R8_U2H_RX_CTRL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<U2EP2_CTRL_R8_U2H_RX_CTRL_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<U2EP2_CTRL_R8_U2H_RX_CTRL_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `MASK_UEP_T_RES` reader - bit mask of handshake response type for USB endpoint X transmittal (IN)
        pub type MASK_UEP_T_RES_R = crate::FieldReader<u8, u8>;
        ///Field `MASK_UEP_T_RES` writer - bit mask of handshake response type for USB endpoint X transmittal (IN)
        pub type MASK_UEP_T_RES_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, U2EP2_CTRL_R8_U2H_RX_CTRL_SPEC, u8, u8, 2, O>;
        ///Field `MASK_UH_R_RES` reader - bit mask of handshake response type for USB endpoint X receiving (OUT)
        pub type MASK_UH_R_RES_R = crate::BitReader<bool>;
        ///Field `MASK_UH_R_RES` writer - bit mask of handshake response type for USB endpoint X receiving (OUT)
        pub type MASK_UH_R_RES_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, U2EP2_CTRL_R8_U2H_RX_CTRL_SPEC, bool, O>;
        ///Field `MASK_UEP_R_RES` reader - bit mask of handshake response type for USB endpoint X receiving (OUT)
        pub type MASK_UEP_R_RES_R = crate::FieldReader<u8, u8>;
        ///Field `MASK_UEP_R_RES` writer - bit mask of handshake response type for USB endpoint X receiving (OUT)
        pub type MASK_UEP_R_RES_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, U2EP2_CTRL_R8_U2H_RX_CTRL_SPEC, u8, u8, 2, O>;
        ///Field `UEP_AUTO_TOG__RB_UH_R_AUTO_TOG` reader - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle;enable automatic toggle after successful transfer completion: 0=manual toggle, 1=automatic toggle
        pub type UEP_AUTO_TOG__RB_UH_R_AUTO_TOG_R = crate::BitReader<bool>;
        ///Field `UEP_AUTO_TOG__RB_UH_R_AUTO_TOG` writer - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle;enable automatic toggle after successful transfer completion: 0=manual toggle, 1=automatic toggle
        pub type UEP_AUTO_TOG__RB_UH_R_AUTO_TOG_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, U2EP2_CTRL_R8_U2H_RX_CTRL_SPEC, bool, O>;
        ///Field `UEP_T_TOG` reader - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
        pub type UEP_T_TOG_R = crate::BitReader<bool>;
        ///Field `UEP_T_TOG` writer - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
        pub type UEP_T_TOG_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, U2EP2_CTRL_R8_U2H_RX_CTRL_SPEC, bool, O>;
        ///Field `UEP_R_TOG__RB_UH_R_TOG` reader - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1;expected data toggle flag of host receiving (IN): 0=DATA0, 1=DATA1
        pub type UEP_R_TOG__RB_UH_R_TOG_R = crate::BitReader<bool>;
        ///Field `UEP_R_TOG__RB_UH_R_TOG` writer - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1;expected data toggle flag of host receiving (IN): 0=DATA0, 1=DATA1
        pub type UEP_R_TOG__RB_UH_R_TOG_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, U2EP2_CTRL_R8_U2H_RX_CTRL_SPEC, bool, O>;
        impl R {
            ///Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)
            #[inline(always)]
            pub fn mask_uep_t_res(&self) -> MASK_UEP_T_RES_R {
                MASK_UEP_T_RES_R::new(self.bits & 3)
            }
            ///Bit 2 - bit mask of handshake response type for USB endpoint X receiving (OUT)
            #[inline(always)]
            pub fn mask_uh_r_res(&self) -> MASK_UH_R_RES_R {
                MASK_UH_R_RES_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)
            #[inline(always)]
            pub fn mask_uep_r_res(&self) -> MASK_UEP_R_RES_R {
                MASK_UEP_R_RES_R::new((self.bits >> 2) & 3)
            }
            ///Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle;enable automatic toggle after successful transfer completion: 0=manual toggle, 1=automatic toggle
            #[inline(always)]
            pub fn uep_auto_tog__rb_uh_r_auto_tog(&self) -> UEP_AUTO_TOG__RB_UH_R_AUTO_TOG_R {
                UEP_AUTO_TOG__RB_UH_R_AUTO_TOG_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
            #[inline(always)]
            pub fn uep_t_tog(&self) -> UEP_T_TOG_R {
                UEP_T_TOG_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1;expected data toggle flag of host receiving (IN): 0=DATA0, 1=DATA1
            #[inline(always)]
            pub fn uep_r_tog__rb_uh_r_tog(&self) -> UEP_R_TOG__RB_UH_R_TOG_R {
                UEP_R_TOG__RB_UH_R_TOG_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)
            #[inline(always)]
            #[must_use]
            pub fn mask_uep_t_res(&mut self) -> MASK_UEP_T_RES_W<0> {
                MASK_UEP_T_RES_W::new(self)
            }
            ///Bit 2 - bit mask of handshake response type for USB endpoint X receiving (OUT)
            #[inline(always)]
            #[must_use]
            pub fn mask_uh_r_res(&mut self) -> MASK_UH_R_RES_W<2> {
                MASK_UH_R_RES_W::new(self)
            }
            ///Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)
            #[inline(always)]
            #[must_use]
            pub fn mask_uep_r_res(&mut self) -> MASK_UEP_R_RES_W<2> {
                MASK_UEP_R_RES_W::new(self)
            }
            ///Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle;enable automatic toggle after successful transfer completion: 0=manual toggle, 1=automatic toggle
            #[inline(always)]
            #[must_use]
            pub fn uep_auto_tog__rb_uh_r_auto_tog(
                &mut self,
            ) -> UEP_AUTO_TOG__RB_UH_R_AUTO_TOG_W<4> {
                UEP_AUTO_TOG__RB_UH_R_AUTO_TOG_W::new(self)
            }
            ///Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
            #[inline(always)]
            #[must_use]
            pub fn uep_t_tog(&mut self) -> UEP_T_TOG_W<6> {
                UEP_T_TOG_W::new(self)
            }
            ///Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1;expected data toggle flag of host receiving (IN): 0=DATA0, 1=DATA1
            #[inline(always)]
            #[must_use]
            pub fn uep_r_tog__rb_uh_r_tog(&mut self) -> UEP_R_TOG__RB_UH_R_TOG_W<7> {
                UEP_R_TOG__RB_UH_R_TOG_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///USB2 endpoint 2 control;host receiver endpoint control
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [u2ep2_ctrl_r8_u2h_rx_ctrl](index.html) module
        pub struct U2EP2_CTRL_R8_U2H_RX_CTRL_SPEC;
        impl crate::RegisterSpec for U2EP2_CTRL_R8_U2H_RX_CTRL_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [u2ep2_ctrl_r8_u2h_rx_ctrl::R](R) reader structure
        impl crate::Readable for U2EP2_CTRL_R8_U2H_RX_CTRL_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [u2ep2_ctrl_r8_u2h_rx_ctrl::W](W) writer structure
        impl crate::Writable for U2EP2_CTRL_R8_U2H_RX_CTRL_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets U2EP2_CTRL_R8_U2H_RX_CTRL to value 0
        impl crate::Resettable for U2EP2_CTRL_R8_U2H_RX_CTRL_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///U2EP3_T_LEN__R8_U2H_TX_LEN (rw) register accessor: an alias for `Reg<U2EP3_T_LEN__R8_U2H_TX_LEN_SPEC>`
    pub type U2EP3_T_LEN__R8_U2H_TX_LEN =
        crate::Reg<u2ep3_t_len__r8_u2h_tx_len::U2EP3_T_LEN__R8_U2H_TX_LEN_SPEC>;
    ///USB2 endpoint 3 transmittal length;host transmittal endpoint transmittal length
    pub mod u2ep3_t_len__r8_u2h_tx_len {
        ///Register `U2EP3_T_LEN__R8_U2H_TX_LEN` reader
        pub struct R(crate::R<U2EP3_T_LEN__R8_U2H_TX_LEN_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<U2EP3_T_LEN__R8_U2H_TX_LEN_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<U2EP3_T_LEN__R8_U2H_TX_LEN_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<U2EP3_T_LEN__R8_U2H_TX_LEN_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `U2EP3_T_LEN__R8_U2H_TX_LEN` writer
        pub struct W(crate::W<U2EP3_T_LEN__R8_U2H_TX_LEN_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<U2EP3_T_LEN__R8_U2H_TX_LEN_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<U2EP3_T_LEN__R8_U2H_TX_LEN_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<U2EP3_T_LEN__R8_U2H_TX_LEN_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `UEP3_T_LEN__R8_UH_TX_LEN` reader - endpoint 1 transmittal length
        pub type UEP3_T_LEN__R8_UH_TX_LEN_R = crate::FieldReader<u8, u8>;
        ///Field `UEP3_T_LEN__R8_UH_TX_LEN` writer - endpoint 1 transmittal length
        pub type UEP3_T_LEN__R8_UH_TX_LEN_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, U2EP3_T_LEN__R8_U2H_TX_LEN_SPEC, u8, u8, 8, O>;
        impl R {
            ///Bits 0:7 - endpoint 1 transmittal length
            #[inline(always)]
            pub fn uep3_t_len__r8_uh_tx_len(&self) -> UEP3_T_LEN__R8_UH_TX_LEN_R {
                UEP3_T_LEN__R8_UH_TX_LEN_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:7 - endpoint 1 transmittal length
            #[inline(always)]
            #[must_use]
            pub fn uep3_t_len__r8_uh_tx_len(&mut self) -> UEP3_T_LEN__R8_UH_TX_LEN_W<0> {
                UEP3_T_LEN__R8_UH_TX_LEN_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///USB2 endpoint 3 transmittal length;host transmittal endpoint transmittal length
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [u2ep3_t_len__r8_u2h_tx_len](index.html) module
        pub struct U2EP3_T_LEN__R8_U2H_TX_LEN_SPEC;
        impl crate::RegisterSpec for U2EP3_T_LEN__R8_U2H_TX_LEN_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [u2ep3_t_len__r8_u2h_tx_len::R](R) reader structure
        impl crate::Readable for U2EP3_T_LEN__R8_U2H_TX_LEN_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [u2ep3_t_len__r8_u2h_tx_len::W](W) writer structure
        impl crate::Writable for U2EP3_T_LEN__R8_U2H_TX_LEN_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets U2EP3_T_LEN__R8_U2H_TX_LEN to value 0
        impl crate::Resettable for U2EP3_T_LEN__R8_U2H_TX_LEN_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///U2EP3_CTRL__R8_U2H_TX_CTRL (rw) register accessor: an alias for `Reg<U2EP3_CTRL__R8_U2H_TX_CTRL_SPEC>`
    pub type U2EP3_CTRL__R8_U2H_TX_CTRL =
        crate::Reg<u2ep3_ctrl__r8_u2h_tx_ctrl::U2EP3_CTRL__R8_U2H_TX_CTRL_SPEC>;
    ///USB2 endpoint 3 control;host transmittal endpoint control
    pub mod u2ep3_ctrl__r8_u2h_tx_ctrl {
        ///Register `U2EP3_CTRL__R8_U2H_TX_CTRL` reader
        pub struct R(crate::R<U2EP3_CTRL__R8_U2H_TX_CTRL_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<U2EP3_CTRL__R8_U2H_TX_CTRL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<U2EP3_CTRL__R8_U2H_TX_CTRL_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<U2EP3_CTRL__R8_U2H_TX_CTRL_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `U2EP3_CTRL__R8_U2H_TX_CTRL` writer
        pub struct W(crate::W<U2EP3_CTRL__R8_U2H_TX_CTRL_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<U2EP3_CTRL__R8_U2H_TX_CTRL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<U2EP3_CTRL__R8_U2H_TX_CTRL_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<U2EP3_CTRL__R8_U2H_TX_CTRL_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `UH_T_RES` reader - bit mask of handshake response type for USB endpoint X transmittal (IN)
        pub type UH_T_RES_R = crate::FieldReader<u8, u8>;
        ///Field `UH_T_RES` writer - bit mask of handshake response type for USB endpoint X transmittal (IN)
        pub type UH_T_RES_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, U2EP3_CTRL__R8_U2H_TX_CTRL_SPEC, u8, u8, 2, O>;
        ///Field `MASK_UEP_T_RES` reader - bit mask of handshake response type for USB endpoint X transmittal (IN)
        pub type MASK_UEP_T_RES_R = crate::FieldReader<u8, u8>;
        ///Field `MASK_UEP_T_RES` writer - bit mask of handshake response type for USB endpoint X transmittal (IN)
        pub type MASK_UEP_T_RES_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, U2EP3_CTRL__R8_U2H_TX_CTRL_SPEC, u8, u8, 2, O>;
        ///Field `MASK_UEP_R_RES` reader - bit mask of handshake response type for USB endpoint X receiving (OUT)
        pub type MASK_UEP_R_RES_R = crate::FieldReader<u8, u8>;
        ///Field `MASK_UEP_R_RES` writer - bit mask of handshake response type for USB endpoint X receiving (OUT)
        pub type MASK_UEP_R_RES_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, U2EP3_CTRL__R8_U2H_TX_CTRL_SPEC, u8, u8, 2, O>;
        ///Field `UEP_AUTO_TOG_RB_UH_T_AUTO_TOG` reader - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
        pub type UEP_AUTO_TOG_RB_UH_T_AUTO_TOG_R = crate::BitReader<bool>;
        ///Field `UEP_AUTO_TOG_RB_UH_T_AUTO_TOG` writer - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
        pub type UEP_AUTO_TOG_RB_UH_T_AUTO_TOG_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, U2EP3_CTRL__R8_U2H_TX_CTRL_SPEC, bool, O>;
        ///Field `UEP_T_TOG_RB_UH_T_TOG` reader - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
        pub type UEP_T_TOG_RB_UH_T_TOG_R = crate::BitReader<bool>;
        ///Field `UEP_T_TOG_RB_UH_T_TOG` writer - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
        pub type UEP_T_TOG_RB_UH_T_TOG_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, U2EP3_CTRL__R8_U2H_TX_CTRL_SPEC, bool, O>;
        ///Field `UEP_R_TOG` reader - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
        pub type UEP_R_TOG_R = crate::BitReader<bool>;
        ///Field `UEP_R_TOG` writer - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
        pub type UEP_R_TOG_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, U2EP3_CTRL__R8_U2H_TX_CTRL_SPEC, bool, O>;
        impl R {
            ///Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)
            #[inline(always)]
            pub fn uh_t_res(&self) -> UH_T_RES_R {
                UH_T_RES_R::new(self.bits & 3)
            }
            ///Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)
            #[inline(always)]
            pub fn mask_uep_t_res(&self) -> MASK_UEP_T_RES_R {
                MASK_UEP_T_RES_R::new(self.bits & 3)
            }
            ///Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)
            #[inline(always)]
            pub fn mask_uep_r_res(&self) -> MASK_UEP_R_RES_R {
                MASK_UEP_R_RES_R::new((self.bits >> 2) & 3)
            }
            ///Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
            #[inline(always)]
            pub fn uep_auto_tog_rb_uh_t_auto_tog(&self) -> UEP_AUTO_TOG_RB_UH_T_AUTO_TOG_R {
                UEP_AUTO_TOG_RB_UH_T_AUTO_TOG_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
            #[inline(always)]
            pub fn uep_t_tog_rb_uh_t_tog(&self) -> UEP_T_TOG_RB_UH_T_TOG_R {
                UEP_T_TOG_RB_UH_T_TOG_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
            #[inline(always)]
            pub fn uep_r_tog(&self) -> UEP_R_TOG_R {
                UEP_R_TOG_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)
            #[inline(always)]
            #[must_use]
            pub fn uh_t_res(&mut self) -> UH_T_RES_W<0> {
                UH_T_RES_W::new(self)
            }
            ///Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)
            #[inline(always)]
            #[must_use]
            pub fn mask_uep_t_res(&mut self) -> MASK_UEP_T_RES_W<0> {
                MASK_UEP_T_RES_W::new(self)
            }
            ///Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)
            #[inline(always)]
            #[must_use]
            pub fn mask_uep_r_res(&mut self) -> MASK_UEP_R_RES_W<2> {
                MASK_UEP_R_RES_W::new(self)
            }
            ///Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
            #[inline(always)]
            #[must_use]
            pub fn uep_auto_tog_rb_uh_t_auto_tog(&mut self) -> UEP_AUTO_TOG_RB_UH_T_AUTO_TOG_W<4> {
                UEP_AUTO_TOG_RB_UH_T_AUTO_TOG_W::new(self)
            }
            ///Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
            #[inline(always)]
            #[must_use]
            pub fn uep_t_tog_rb_uh_t_tog(&mut self) -> UEP_T_TOG_RB_UH_T_TOG_W<6> {
                UEP_T_TOG_RB_UH_T_TOG_W::new(self)
            }
            ///Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
            #[inline(always)]
            #[must_use]
            pub fn uep_r_tog(&mut self) -> UEP_R_TOG_W<7> {
                UEP_R_TOG_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///USB2 endpoint 3 control;host transmittal endpoint control
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [u2ep3_ctrl__r8_u2h_tx_ctrl](index.html) module
        pub struct U2EP3_CTRL__R8_U2H_TX_CTRL_SPEC;
        impl crate::RegisterSpec for U2EP3_CTRL__R8_U2H_TX_CTRL_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [u2ep3_ctrl__r8_u2h_tx_ctrl::R](R) reader structure
        impl crate::Readable for U2EP3_CTRL__R8_U2H_TX_CTRL_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [u2ep3_ctrl__r8_u2h_tx_ctrl::W](W) writer structure
        impl crate::Writable for U2EP3_CTRL__R8_U2H_TX_CTRL_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets U2EP3_CTRL__R8_U2H_TX_CTRL to value 0
        impl crate::Resettable for U2EP3_CTRL__R8_U2H_TX_CTRL_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///U2EP4_T_LEN (rw) register accessor: an alias for `Reg<U2EP4_T_LEN_SPEC>`
    pub type U2EP4_T_LEN = crate::Reg<u2ep4_t_len::U2EP4_T_LEN_SPEC>;
    ///USB2 endpoint 4 transmittal length
    pub mod u2ep4_t_len {
        ///Register `U2EP4_T_LEN` reader
        pub struct R(crate::R<U2EP4_T_LEN_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<U2EP4_T_LEN_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<U2EP4_T_LEN_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<U2EP4_T_LEN_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `U2EP4_T_LEN` writer
        pub struct W(crate::W<U2EP4_T_LEN_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<U2EP4_T_LEN_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<U2EP4_T_LEN_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<U2EP4_T_LEN_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `UEP4_T_LEN` reader - endpoint 4 transmittal length
        pub type UEP4_T_LEN_R = crate::FieldReader<u8, u8>;
        ///Field `UEP4_T_LEN` writer - endpoint 4 transmittal length
        pub type UEP4_T_LEN_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, U2EP4_T_LEN_SPEC, u8, u8, 8, O>;
        impl R {
            ///Bits 0:7 - endpoint 4 transmittal length
            #[inline(always)]
            pub fn uep4_t_len(&self) -> UEP4_T_LEN_R {
                UEP4_T_LEN_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:7 - endpoint 4 transmittal length
            #[inline(always)]
            #[must_use]
            pub fn uep4_t_len(&mut self) -> UEP4_T_LEN_W<0> {
                UEP4_T_LEN_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///USB2 endpoint 4 transmittal length
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [u2ep4_t_len](index.html) module
        pub struct U2EP4_T_LEN_SPEC;
        impl crate::RegisterSpec for U2EP4_T_LEN_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [u2ep4_t_len::R](R) reader structure
        impl crate::Readable for U2EP4_T_LEN_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [u2ep4_t_len::W](W) writer structure
        impl crate::Writable for U2EP4_T_LEN_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets U2EP4_T_LEN to value 0
        impl crate::Resettable for U2EP4_T_LEN_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///U2EP4_CTRL (rw) register accessor: an alias for `Reg<U2EP4_CTRL_SPEC>`
    pub type U2EP4_CTRL = crate::Reg<u2ep4_ctrl::U2EP4_CTRL_SPEC>;
    ///USB2 endpoint 4 control
    pub mod u2ep4_ctrl {
        ///Register `U2EP4_CTRL` reader
        pub struct R(crate::R<U2EP4_CTRL_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<U2EP4_CTRL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<U2EP4_CTRL_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<U2EP4_CTRL_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `U2EP4_CTRL` writer
        pub struct W(crate::W<U2EP4_CTRL_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<U2EP4_CTRL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<U2EP4_CTRL_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<U2EP4_CTRL_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `MASK_UEP_T_RES` reader - bit mask of handshake response type for USB endpoint X transmittal (IN)
        pub type MASK_UEP_T_RES_R = crate::FieldReader<u8, u8>;
        ///Field `MASK_UEP_T_RES` writer - bit mask of handshake response type for USB endpoint X transmittal (IN)
        pub type MASK_UEP_T_RES_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, U2EP4_CTRL_SPEC, u8, u8, 2, O>;
        ///Field `MASK_UEP_R_RES` reader - bit mask of handshake response type for USB endpoint X receiving (OUT)
        pub type MASK_UEP_R_RES_R = crate::FieldReader<u8, u8>;
        ///Field `MASK_UEP_R_RES` writer - bit mask of handshake response type for USB endpoint X receiving (OUT)
        pub type MASK_UEP_R_RES_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, U2EP4_CTRL_SPEC, u8, u8, 2, O>;
        ///Field `UEP_AUTO_TOG` reader - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
        pub type UEP_AUTO_TOG_R = crate::BitReader<bool>;
        ///Field `UEP_AUTO_TOG` writer - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
        pub type UEP_AUTO_TOG_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, U2EP4_CTRL_SPEC, bool, O>;
        ///Field `UEP_T_TOG` reader - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
        pub type UEP_T_TOG_R = crate::BitReader<bool>;
        ///Field `UEP_T_TOG` writer - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
        pub type UEP_T_TOG_W<'a, const O: u8> = crate::BitWriter<'a, u8, U2EP4_CTRL_SPEC, bool, O>;
        ///Field `UEP_R_TOG` reader - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
        pub type UEP_R_TOG_R = crate::BitReader<bool>;
        ///Field `UEP_R_TOG` writer - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
        pub type UEP_R_TOG_W<'a, const O: u8> = crate::BitWriter<'a, u8, U2EP4_CTRL_SPEC, bool, O>;
        impl R {
            ///Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)
            #[inline(always)]
            pub fn mask_uep_t_res(&self) -> MASK_UEP_T_RES_R {
                MASK_UEP_T_RES_R::new(self.bits & 3)
            }
            ///Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)
            #[inline(always)]
            pub fn mask_uep_r_res(&self) -> MASK_UEP_R_RES_R {
                MASK_UEP_R_RES_R::new((self.bits >> 2) & 3)
            }
            ///Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
            #[inline(always)]
            pub fn uep_auto_tog(&self) -> UEP_AUTO_TOG_R {
                UEP_AUTO_TOG_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
            #[inline(always)]
            pub fn uep_t_tog(&self) -> UEP_T_TOG_R {
                UEP_T_TOG_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
            #[inline(always)]
            pub fn uep_r_tog(&self) -> UEP_R_TOG_R {
                UEP_R_TOG_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)
            #[inline(always)]
            #[must_use]
            pub fn mask_uep_t_res(&mut self) -> MASK_UEP_T_RES_W<0> {
                MASK_UEP_T_RES_W::new(self)
            }
            ///Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)
            #[inline(always)]
            #[must_use]
            pub fn mask_uep_r_res(&mut self) -> MASK_UEP_R_RES_W<2> {
                MASK_UEP_R_RES_W::new(self)
            }
            ///Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
            #[inline(always)]
            #[must_use]
            pub fn uep_auto_tog(&mut self) -> UEP_AUTO_TOG_W<4> {
                UEP_AUTO_TOG_W::new(self)
            }
            ///Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
            #[inline(always)]
            #[must_use]
            pub fn uep_t_tog(&mut self) -> UEP_T_TOG_W<6> {
                UEP_T_TOG_W::new(self)
            }
            ///Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
            #[inline(always)]
            #[must_use]
            pub fn uep_r_tog(&mut self) -> UEP_R_TOG_W<7> {
                UEP_R_TOG_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///USB2 endpoint 4 control
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [u2ep4_ctrl](index.html) module
        pub struct U2EP4_CTRL_SPEC;
        impl crate::RegisterSpec for U2EP4_CTRL_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [u2ep4_ctrl::R](R) reader structure
        impl crate::Readable for U2EP4_CTRL_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [u2ep4_ctrl::W](W) writer structure
        impl crate::Writable for U2EP4_CTRL_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets U2EP4_CTRL to value 0
        impl crate::Resettable for U2EP4_CTRL_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///U2EP5_T_LEN (rw) register accessor: an alias for `Reg<U2EP5_T_LEN_SPEC>`
    pub type U2EP5_T_LEN = crate::Reg<u2ep5_t_len::U2EP5_T_LEN_SPEC>;
    ///USB2 endpoint 5 transmittal length
    pub mod u2ep5_t_len {
        ///Register `U2EP5_T_LEN` reader
        pub struct R(crate::R<U2EP5_T_LEN_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<U2EP5_T_LEN_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<U2EP5_T_LEN_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<U2EP5_T_LEN_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `U2EP5_T_LEN` writer
        pub struct W(crate::W<U2EP5_T_LEN_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<U2EP5_T_LEN_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<U2EP5_T_LEN_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<U2EP5_T_LEN_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `UEP5_T_LEN` reader - endpoint 5 transmittal length
        pub type UEP5_T_LEN_R = crate::FieldReader<u8, u8>;
        ///Field `UEP5_T_LEN` writer - endpoint 5 transmittal length
        pub type UEP5_T_LEN_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, U2EP5_T_LEN_SPEC, u8, u8, 8, O>;
        impl R {
            ///Bits 0:7 - endpoint 5 transmittal length
            #[inline(always)]
            pub fn uep5_t_len(&self) -> UEP5_T_LEN_R {
                UEP5_T_LEN_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:7 - endpoint 5 transmittal length
            #[inline(always)]
            #[must_use]
            pub fn uep5_t_len(&mut self) -> UEP5_T_LEN_W<0> {
                UEP5_T_LEN_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///USB2 endpoint 5 transmittal length
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [u2ep5_t_len](index.html) module
        pub struct U2EP5_T_LEN_SPEC;
        impl crate::RegisterSpec for U2EP5_T_LEN_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [u2ep5_t_len::R](R) reader structure
        impl crate::Readable for U2EP5_T_LEN_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [u2ep5_t_len::W](W) writer structure
        impl crate::Writable for U2EP5_T_LEN_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets U2EP5_T_LEN to value 0
        impl crate::Resettable for U2EP5_T_LEN_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///U2EP5_CTRL (rw) register accessor: an alias for `Reg<U2EP5_CTRL_SPEC>`
    pub type U2EP5_CTRL = crate::Reg<u2ep5_ctrl::U2EP5_CTRL_SPEC>;
    ///USB2 endpoint 5 control
    pub mod u2ep5_ctrl {
        ///Register `U2EP5_CTRL` reader
        pub struct R(crate::R<U2EP5_CTRL_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<U2EP5_CTRL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<U2EP5_CTRL_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<U2EP5_CTRL_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `U2EP5_CTRL` writer
        pub struct W(crate::W<U2EP5_CTRL_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<U2EP5_CTRL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<U2EP5_CTRL_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<U2EP5_CTRL_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `MASK_UEP_T_RES` reader - bit mask of handshake response type for USB endpoint X transmittal (IN)
        pub type MASK_UEP_T_RES_R = crate::FieldReader<u8, u8>;
        ///Field `MASK_UEP_T_RES` writer - bit mask of handshake response type for USB endpoint X transmittal (IN)
        pub type MASK_UEP_T_RES_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, U2EP5_CTRL_SPEC, u8, u8, 2, O>;
        ///Field `MASK_UEP_R_RES` reader - bit mask of handshake response type for USB endpoint X receiving (OUT)
        pub type MASK_UEP_R_RES_R = crate::FieldReader<u8, u8>;
        ///Field `MASK_UEP_R_RES` writer - bit mask of handshake response type for USB endpoint X receiving (OUT)
        pub type MASK_UEP_R_RES_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, U2EP5_CTRL_SPEC, u8, u8, 2, O>;
        ///Field `UEP_AUTO_TOG` reader - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
        pub type UEP_AUTO_TOG_R = crate::BitReader<bool>;
        ///Field `UEP_AUTO_TOG` writer - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
        pub type UEP_AUTO_TOG_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, U2EP5_CTRL_SPEC, bool, O>;
        ///Field `UEP_T_TOG` reader - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
        pub type UEP_T_TOG_R = crate::BitReader<bool>;
        ///Field `UEP_T_TOG` writer - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
        pub type UEP_T_TOG_W<'a, const O: u8> = crate::BitWriter<'a, u8, U2EP5_CTRL_SPEC, bool, O>;
        ///Field `UEP_R_TOG` reader - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
        pub type UEP_R_TOG_R = crate::BitReader<bool>;
        ///Field `UEP_R_TOG` writer - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
        pub type UEP_R_TOG_W<'a, const O: u8> = crate::BitWriter<'a, u8, U2EP5_CTRL_SPEC, bool, O>;
        impl R {
            ///Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)
            #[inline(always)]
            pub fn mask_uep_t_res(&self) -> MASK_UEP_T_RES_R {
                MASK_UEP_T_RES_R::new(self.bits & 3)
            }
            ///Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)
            #[inline(always)]
            pub fn mask_uep_r_res(&self) -> MASK_UEP_R_RES_R {
                MASK_UEP_R_RES_R::new((self.bits >> 2) & 3)
            }
            ///Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
            #[inline(always)]
            pub fn uep_auto_tog(&self) -> UEP_AUTO_TOG_R {
                UEP_AUTO_TOG_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
            #[inline(always)]
            pub fn uep_t_tog(&self) -> UEP_T_TOG_R {
                UEP_T_TOG_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
            #[inline(always)]
            pub fn uep_r_tog(&self) -> UEP_R_TOG_R {
                UEP_R_TOG_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)
            #[inline(always)]
            #[must_use]
            pub fn mask_uep_t_res(&mut self) -> MASK_UEP_T_RES_W<0> {
                MASK_UEP_T_RES_W::new(self)
            }
            ///Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)
            #[inline(always)]
            #[must_use]
            pub fn mask_uep_r_res(&mut self) -> MASK_UEP_R_RES_W<2> {
                MASK_UEP_R_RES_W::new(self)
            }
            ///Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
            #[inline(always)]
            #[must_use]
            pub fn uep_auto_tog(&mut self) -> UEP_AUTO_TOG_W<4> {
                UEP_AUTO_TOG_W::new(self)
            }
            ///Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
            #[inline(always)]
            #[must_use]
            pub fn uep_t_tog(&mut self) -> UEP_T_TOG_W<6> {
                UEP_T_TOG_W::new(self)
            }
            ///Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
            #[inline(always)]
            #[must_use]
            pub fn uep_r_tog(&mut self) -> UEP_R_TOG_W<7> {
                UEP_R_TOG_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///USB2 endpoint 5 control
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [u2ep5_ctrl](index.html) module
        pub struct U2EP5_CTRL_SPEC;
        impl crate::RegisterSpec for U2EP5_CTRL_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [u2ep5_ctrl::R](R) reader structure
        impl crate::Readable for U2EP5_CTRL_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [u2ep5_ctrl::W](W) writer structure
        impl crate::Writable for U2EP5_CTRL_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets U2EP5_CTRL to value 0
        impl crate::Resettable for U2EP5_CTRL_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///U2EP6_T_LEN (rw) register accessor: an alias for `Reg<U2EP6_T_LEN_SPEC>`
    pub type U2EP6_T_LEN = crate::Reg<u2ep6_t_len::U2EP6_T_LEN_SPEC>;
    ///USB2 endpoint 6 transmittal length
    pub mod u2ep6_t_len {
        ///Register `U2EP6_T_LEN` reader
        pub struct R(crate::R<U2EP6_T_LEN_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<U2EP6_T_LEN_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<U2EP6_T_LEN_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<U2EP6_T_LEN_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `U2EP6_T_LEN` writer
        pub struct W(crate::W<U2EP6_T_LEN_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<U2EP6_T_LEN_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<U2EP6_T_LEN_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<U2EP6_T_LEN_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `UEP6_T_LEN` reader - endpoint 6 transmittal length
        pub type UEP6_T_LEN_R = crate::FieldReader<u8, u8>;
        ///Field `UEP6_T_LEN` writer - endpoint 6 transmittal length
        pub type UEP6_T_LEN_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, U2EP6_T_LEN_SPEC, u8, u8, 8, O>;
        impl R {
            ///Bits 0:7 - endpoint 6 transmittal length
            #[inline(always)]
            pub fn uep6_t_len(&self) -> UEP6_T_LEN_R {
                UEP6_T_LEN_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:7 - endpoint 6 transmittal length
            #[inline(always)]
            #[must_use]
            pub fn uep6_t_len(&mut self) -> UEP6_T_LEN_W<0> {
                UEP6_T_LEN_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///USB2 endpoint 6 transmittal length
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [u2ep6_t_len](index.html) module
        pub struct U2EP6_T_LEN_SPEC;
        impl crate::RegisterSpec for U2EP6_T_LEN_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [u2ep6_t_len::R](R) reader structure
        impl crate::Readable for U2EP6_T_LEN_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [u2ep6_t_len::W](W) writer structure
        impl crate::Writable for U2EP6_T_LEN_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets U2EP6_T_LEN to value 0
        impl crate::Resettable for U2EP6_T_LEN_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///U2EP6_CTRL (rw) register accessor: an alias for `Reg<U2EP6_CTRL_SPEC>`
    pub type U2EP6_CTRL = crate::Reg<u2ep6_ctrl::U2EP6_CTRL_SPEC>;
    ///USB2 endpoint 6 control
    pub mod u2ep6_ctrl {
        ///Register `U2EP6_CTRL` reader
        pub struct R(crate::R<U2EP6_CTRL_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<U2EP6_CTRL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<U2EP6_CTRL_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<U2EP6_CTRL_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `U2EP6_CTRL` writer
        pub struct W(crate::W<U2EP6_CTRL_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<U2EP6_CTRL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<U2EP6_CTRL_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<U2EP6_CTRL_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `MASK_UEP_T_RES` reader - bit mask of handshake response type for USB endpoint X transmittal (IN)
        pub type MASK_UEP_T_RES_R = crate::FieldReader<u8, u8>;
        ///Field `MASK_UEP_T_RES` writer - bit mask of handshake response type for USB endpoint X transmittal (IN)
        pub type MASK_UEP_T_RES_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, U2EP6_CTRL_SPEC, u8, u8, 2, O>;
        ///Field `MASK_UEP_R_RES` reader - bit mask of handshake response type for USB endpoint X receiving (OUT)
        pub type MASK_UEP_R_RES_R = crate::FieldReader<u8, u8>;
        ///Field `MASK_UEP_R_RES` writer - bit mask of handshake response type for USB endpoint X receiving (OUT)
        pub type MASK_UEP_R_RES_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, U2EP6_CTRL_SPEC, u8, u8, 2, O>;
        ///Field `UEP_AUTO_TOG` reader - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
        pub type UEP_AUTO_TOG_R = crate::BitReader<bool>;
        ///Field `UEP_AUTO_TOG` writer - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
        pub type UEP_AUTO_TOG_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, U2EP6_CTRL_SPEC, bool, O>;
        ///Field `UEP_T_TOG` reader - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
        pub type UEP_T_TOG_R = crate::BitReader<bool>;
        ///Field `UEP_T_TOG` writer - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
        pub type UEP_T_TOG_W<'a, const O: u8> = crate::BitWriter<'a, u8, U2EP6_CTRL_SPEC, bool, O>;
        ///Field `UEP_R_TOG` reader - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
        pub type UEP_R_TOG_R = crate::BitReader<bool>;
        ///Field `UEP_R_TOG` writer - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
        pub type UEP_R_TOG_W<'a, const O: u8> = crate::BitWriter<'a, u8, U2EP6_CTRL_SPEC, bool, O>;
        impl R {
            ///Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)
            #[inline(always)]
            pub fn mask_uep_t_res(&self) -> MASK_UEP_T_RES_R {
                MASK_UEP_T_RES_R::new(self.bits & 3)
            }
            ///Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)
            #[inline(always)]
            pub fn mask_uep_r_res(&self) -> MASK_UEP_R_RES_R {
                MASK_UEP_R_RES_R::new((self.bits >> 2) & 3)
            }
            ///Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
            #[inline(always)]
            pub fn uep_auto_tog(&self) -> UEP_AUTO_TOG_R {
                UEP_AUTO_TOG_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
            #[inline(always)]
            pub fn uep_t_tog(&self) -> UEP_T_TOG_R {
                UEP_T_TOG_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
            #[inline(always)]
            pub fn uep_r_tog(&self) -> UEP_R_TOG_R {
                UEP_R_TOG_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)
            #[inline(always)]
            #[must_use]
            pub fn mask_uep_t_res(&mut self) -> MASK_UEP_T_RES_W<0> {
                MASK_UEP_T_RES_W::new(self)
            }
            ///Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)
            #[inline(always)]
            #[must_use]
            pub fn mask_uep_r_res(&mut self) -> MASK_UEP_R_RES_W<2> {
                MASK_UEP_R_RES_W::new(self)
            }
            ///Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
            #[inline(always)]
            #[must_use]
            pub fn uep_auto_tog(&mut self) -> UEP_AUTO_TOG_W<4> {
                UEP_AUTO_TOG_W::new(self)
            }
            ///Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
            #[inline(always)]
            #[must_use]
            pub fn uep_t_tog(&mut self) -> UEP_T_TOG_W<6> {
                UEP_T_TOG_W::new(self)
            }
            ///Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
            #[inline(always)]
            #[must_use]
            pub fn uep_r_tog(&mut self) -> UEP_R_TOG_W<7> {
                UEP_R_TOG_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///USB2 endpoint 6 control
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [u2ep6_ctrl](index.html) module
        pub struct U2EP6_CTRL_SPEC;
        impl crate::RegisterSpec for U2EP6_CTRL_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [u2ep6_ctrl::R](R) reader structure
        impl crate::Readable for U2EP6_CTRL_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [u2ep6_ctrl::W](W) writer structure
        impl crate::Writable for U2EP6_CTRL_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets U2EP6_CTRL to value 0
        impl crate::Resettable for U2EP6_CTRL_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///U2EP7_T_LEN (rw) register accessor: an alias for `Reg<U2EP7_T_LEN_SPEC>`
    pub type U2EP7_T_LEN = crate::Reg<u2ep7_t_len::U2EP7_T_LEN_SPEC>;
    ///USB2 endpoint 7 transmittal length
    pub mod u2ep7_t_len {
        ///Register `U2EP7_T_LEN` reader
        pub struct R(crate::R<U2EP7_T_LEN_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<U2EP7_T_LEN_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<U2EP7_T_LEN_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<U2EP7_T_LEN_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `U2EP7_T_LEN` writer
        pub struct W(crate::W<U2EP7_T_LEN_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<U2EP7_T_LEN_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<U2EP7_T_LEN_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<U2EP7_T_LEN_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `UEP7_T_LEN` reader - endpoint 7 transmittal length
        pub type UEP7_T_LEN_R = crate::FieldReader<u8, u8>;
        ///Field `UEP7_T_LEN` writer - endpoint 7 transmittal length
        pub type UEP7_T_LEN_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, U2EP7_T_LEN_SPEC, u8, u8, 8, O>;
        impl R {
            ///Bits 0:7 - endpoint 7 transmittal length
            #[inline(always)]
            pub fn uep7_t_len(&self) -> UEP7_T_LEN_R {
                UEP7_T_LEN_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:7 - endpoint 7 transmittal length
            #[inline(always)]
            #[must_use]
            pub fn uep7_t_len(&mut self) -> UEP7_T_LEN_W<0> {
                UEP7_T_LEN_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///USB2 endpoint 7 transmittal length
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [u2ep7_t_len](index.html) module
        pub struct U2EP7_T_LEN_SPEC;
        impl crate::RegisterSpec for U2EP7_T_LEN_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [u2ep7_t_len::R](R) reader structure
        impl crate::Readable for U2EP7_T_LEN_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [u2ep7_t_len::W](W) writer structure
        impl crate::Writable for U2EP7_T_LEN_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets U2EP7_T_LEN to value 0
        impl crate::Resettable for U2EP7_T_LEN_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///U2EP7_CTRL (rw) register accessor: an alias for `Reg<U2EP7_CTRL_SPEC>`
    pub type U2EP7_CTRL = crate::Reg<u2ep7_ctrl::U2EP7_CTRL_SPEC>;
    ///USB2 endpoint 7 control
    pub mod u2ep7_ctrl {
        ///Register `U2EP7_CTRL` reader
        pub struct R(crate::R<U2EP7_CTRL_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<U2EP7_CTRL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<U2EP7_CTRL_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<U2EP7_CTRL_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `U2EP7_CTRL` writer
        pub struct W(crate::W<U2EP7_CTRL_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<U2EP7_CTRL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<U2EP7_CTRL_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<U2EP7_CTRL_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `MASK_UEP_T_RES` reader - bit mask of handshake response type for USB endpoint X transmittal (IN)
        pub type MASK_UEP_T_RES_R = crate::FieldReader<u8, u8>;
        ///Field `MASK_UEP_T_RES` writer - bit mask of handshake response type for USB endpoint X transmittal (IN)
        pub type MASK_UEP_T_RES_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, U2EP7_CTRL_SPEC, u8, u8, 2, O>;
        ///Field `MASK_UEP_R_RES` reader - bit mask of handshake response type for USB endpoint X receiving (OUT)
        pub type MASK_UEP_R_RES_R = crate::FieldReader<u8, u8>;
        ///Field `MASK_UEP_R_RES` writer - bit mask of handshake response type for USB endpoint X receiving (OUT)
        pub type MASK_UEP_R_RES_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, U2EP7_CTRL_SPEC, u8, u8, 2, O>;
        ///Field `UEP_AUTO_TOG` reader - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
        pub type UEP_AUTO_TOG_R = crate::BitReader<bool>;
        ///Field `UEP_AUTO_TOG` writer - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
        pub type UEP_AUTO_TOG_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, U2EP7_CTRL_SPEC, bool, O>;
        ///Field `UEP_T_TOG` reader - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
        pub type UEP_T_TOG_R = crate::BitReader<bool>;
        ///Field `UEP_T_TOG` writer - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
        pub type UEP_T_TOG_W<'a, const O: u8> = crate::BitWriter<'a, u8, U2EP7_CTRL_SPEC, bool, O>;
        ///Field `UEP_R_TOG` reader - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
        pub type UEP_R_TOG_R = crate::BitReader<bool>;
        ///Field `UEP_R_TOG` writer - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
        pub type UEP_R_TOG_W<'a, const O: u8> = crate::BitWriter<'a, u8, U2EP7_CTRL_SPEC, bool, O>;
        impl R {
            ///Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)
            #[inline(always)]
            pub fn mask_uep_t_res(&self) -> MASK_UEP_T_RES_R {
                MASK_UEP_T_RES_R::new(self.bits & 3)
            }
            ///Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)
            #[inline(always)]
            pub fn mask_uep_r_res(&self) -> MASK_UEP_R_RES_R {
                MASK_UEP_R_RES_R::new((self.bits >> 2) & 3)
            }
            ///Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
            #[inline(always)]
            pub fn uep_auto_tog(&self) -> UEP_AUTO_TOG_R {
                UEP_AUTO_TOG_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
            #[inline(always)]
            pub fn uep_t_tog(&self) -> UEP_T_TOG_R {
                UEP_T_TOG_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
            #[inline(always)]
            pub fn uep_r_tog(&self) -> UEP_R_TOG_R {
                UEP_R_TOG_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)
            #[inline(always)]
            #[must_use]
            pub fn mask_uep_t_res(&mut self) -> MASK_UEP_T_RES_W<0> {
                MASK_UEP_T_RES_W::new(self)
            }
            ///Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)
            #[inline(always)]
            #[must_use]
            pub fn mask_uep_r_res(&mut self) -> MASK_UEP_R_RES_W<2> {
                MASK_UEP_R_RES_W::new(self)
            }
            ///Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle
            #[inline(always)]
            #[must_use]
            pub fn uep_auto_tog(&mut self) -> UEP_AUTO_TOG_W<4> {
                UEP_AUTO_TOG_W::new(self)
            }
            ///Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
            #[inline(always)]
            #[must_use]
            pub fn uep_t_tog(&mut self) -> UEP_T_TOG_W<6> {
                UEP_T_TOG_W::new(self)
            }
            ///Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
            #[inline(always)]
            #[must_use]
            pub fn uep_r_tog(&mut self) -> UEP_R_TOG_W<7> {
                UEP_R_TOG_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///USB2 endpoint 7 control
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [u2ep7_ctrl](index.html) module
        pub struct U2EP7_CTRL_SPEC;
        impl crate::RegisterSpec for U2EP7_CTRL_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [u2ep7_ctrl::R](R) reader structure
        impl crate::Readable for U2EP7_CTRL_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [u2ep7_ctrl::W](W) writer structure
        impl crate::Writable for U2EP7_CTRL_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets U2EP7_CTRL to value 0
        impl crate::Resettable for U2EP7_CTRL_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
}
///Program Fast Interrupt Controller
pub struct PFIC {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for PFIC {}
impl PFIC {
    ///Pointer to the register block
    pub const PTR: *const pfic::RegisterBlock = 0xe000_e000 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const pfic::RegisterBlock {
        Self::PTR
    }
}
impl Deref for PFIC {
    type Target = pfic::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for PFIC {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("PFIC").finish()
    }
}
///Program Fast Interrupt Controller
pub mod pfic {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        ///0x00 - RO,Interrupt Status Register 1
        pub pfic_isr1: PFIC_ISR1,
        ///0x04 - RO,Interrupt Status Register 2
        pub pfic_isr2: PFIC_ISR2,
        _reserved2: [u8; 0x18],
        ///0x20 - RO,Interrupt Pending Register 1
        pub pfic_ipr1: PFIC_IPR1,
        ///0x24 - RO,Interrupt Pending Register 2
        pub pfic_ipr2: PFIC_IPR2,
        _reserved4: [u8; 0x18],
        ///0x40 - RW,Interrupt Priority Register
        pub pfic_ithresdr: PFIC_ITHRESDR,
        _reserved5: [u8; 0x04],
        ///0x48 - Interrupt Config Register
        pub pfic_cfgr: PFIC_CFGR,
        ///0x4c - Interrupt Global Register
        pub pfic_gisr: PFIC_GISR,
        ///0x50 - RW,Interrupt Fast ID Config Register
        pub pfic_idcfgr: PFIC_IDCFGR,
        _reserved8: [u8; 0x0c],
        ///0x60 - Interrupt 0 address Register
        pub pfic_fiaddrr0: PFIC_FIADDRR0,
        ///0x64 - Interrupt 1 address Register
        pub pfic_fiaddrr1: PFIC_FIADDRR1,
        ///0x68 - Interrupt 2 address Register
        pub pfic_fiaddrr2: PFIC_FIADDRR2,
        ///0x6c - Interrupt 3 address Register
        pub pfic_fiaddrr3: PFIC_FIADDRR3,
        _reserved12: [u8; 0x90],
        ///0x100 - Interrupt Setting Register
        pub pfic_ienr1: PFIC_IENR1,
        ///0x104 - Interrupt Setting Register
        pub pfic_ienr2: PFIC_IENR2,
        _reserved14: [u8; 0x78],
        ///0x180 - Interrupt Clear Register
        pub pfic_irer1: PFIC_IRER1,
        ///0x184 - Interrupt Clear Register
        pub pfic_irer2: PFIC_IRER2,
        _reserved16: [u8; 0x78],
        ///0x200 - Interrupt Pending Register
        pub pfic_ipsr1: PFIC_IPSR1,
        ///0x204 - Interrupt Pending Register
        pub pfic_ipsr2: PFIC_IPSR2,
        _reserved18: [u8; 0x78],
        ///0x280 - Interrupt Pending Clear Register
        pub pfic_iprr1: PFIC_IPRR1,
        ///0x284 - Interrupt Pending Clear Register
        pub pfic_iprr2: PFIC_IPRR2,
        _reserved20: [u8; 0x78],
        ///0x300 - Interrupt ACTIVE Register
        pub pfic_iactr1: PFIC_IACTR1,
        ///0x304 - Interrupt ACTIVE Register
        pub pfic_iactr2: PFIC_IACTR2,
        _reserved22: [u8; 0xf8],
        ///0x400 - Interrupt Priority configuration Register 0
        pub pfic_iprior0: PFIC_IPRIOR0,
        _reserved23: [u8; 0x1c],
        ///0x420 - Interrupt Priority configuration Register 1
        pub pfic_iprior1: PFIC_IPRIOR1,
        _reserved24: [u8; 0x1c],
        ///0x440 - Interrupt Priority configuration Register 2
        pub pfic_iprior2: PFIC_IPRIOR2,
        _reserved25: [u8; 0x1c],
        ///0x460 - Interrupt Priority configuration Register 3
        pub pfic_iprior3: PFIC_IPRIOR3,
        _reserved26: [u8; 0x1c],
        ///0x480 - Interrupt Priority configuration Register 4
        pub pfic_iprior4: PFIC_IPRIOR4,
        _reserved27: [u8; 0x1c],
        ///0x4a0 - Interrupt Priority configuration Register 5
        pub pfic_iprior5: PFIC_IPRIOR5,
        _reserved28: [u8; 0x1c],
        ///0x4c0 - Interrupt Priority configuration Register 6
        pub pfic_iprior6: PFIC_IPRIOR6,
        _reserved29: [u8; 0x1c],
        ///0x4e0 - Interrupt Priority configuration Register 7
        pub pfic_iprior7: PFIC_IPRIOR7,
        _reserved30: [u8; 0x1c],
        ///0x500 - Interrupt Priority configuration Register 8
        pub pfic_iprior8: PFIC_IPRIOR8,
        _reserved31: [u8; 0x1c],
        ///0x520 - Interrupt Priority configuration Register 9
        pub pfic_iprior9: PFIC_IPRIOR9,
        _reserved32: [u8; 0x1c],
        ///0x540 - Interrupt Priority configuration Register 10
        pub pfic_iprior10: PFIC_IPRIOR10,
        _reserved33: [u8; 0x1c],
        ///0x560 - Interrupt Priority configuration Register 11
        pub pfic_iprior11: PFIC_IPRIOR11,
        _reserved34: [u8; 0x1c],
        ///0x580 - Interrupt Priority configuration Register 12
        pub pfic_iprior12: PFIC_IPRIOR12,
        _reserved35: [u8; 0x1c],
        ///0x5a0 - Interrupt Priority configuration Register 13
        pub pfic_iprior13: PFIC_IPRIOR13,
        _reserved36: [u8; 0x1c],
        ///0x5c0 - Interrupt Priority configuration Register 14
        pub pfic_iprior14: PFIC_IPRIOR14,
        _reserved37: [u8; 0x1c],
        ///0x5e0 - Interrupt Priority configuration Register 15
        pub pfic_iprior15: PFIC_IPRIOR15,
        _reserved38: [u8; 0x1c],
        ///0x600 - Interrupt Priority configuration Register 16
        pub pfic_iprior16: PFIC_IPRIOR16,
        _reserved39: [u8; 0x1c],
        ///0x620 - Interrupt Priority configuration Register 17
        pub pfic_iprior17: PFIC_IPRIOR17,
        _reserved40: [u8; 0x1c],
        ///0x640 - Interrupt Priority configuration Register 18
        pub pfic_iprior18: PFIC_IPRIOR18,
        _reserved41: [u8; 0x1c],
        ///0x660 - Interrupt Priority configuration Register 19
        pub pfic_iprior19: PFIC_IPRIOR19,
        _reserved42: [u8; 0x1c],
        ///0x680 - Interrupt Priority configuration Register 20
        pub pfic_iprior20: PFIC_IPRIOR20,
        _reserved43: [u8; 0x1c],
        ///0x6a0 - Interrupt Priority configuration Register 21
        pub pfic_iprior21: PFIC_IPRIOR21,
        _reserved44: [u8; 0x1c],
        ///0x6c0 - Interrupt Priority configuration Register 22
        pub pfic_iprior22: PFIC_IPRIOR22,
        _reserved45: [u8; 0x1c],
        ///0x6e0 - Interrupt Priority configuration Register 23
        pub pfic_iprior23: PFIC_IPRIOR23,
        _reserved46: [u8; 0x1c],
        ///0x700 - Interrupt Priority configuration Register 24
        pub pfic_iprior24: PFIC_IPRIOR24,
        _reserved47: [u8; 0x1c],
        ///0x720 - Interrupt Priority configuration Register 25
        pub pfic_iprior25: PFIC_IPRIOR25,
        _reserved48: [u8; 0x1c],
        ///0x740 - Interrupt Priority configuration Register 26
        pub pfic_iprior26: PFIC_IPRIOR26,
        _reserved49: [u8; 0x1c],
        ///0x760 - Interrupt Priority configuration Register 27
        pub pfic_iprior27: PFIC_IPRIOR27,
        _reserved50: [u8; 0x1c],
        ///0x780 - Interrupt Priority configuration Register 28
        pub pfic_iprior28: PFIC_IPRIOR28,
        _reserved51: [u8; 0x1c],
        ///0x7a0 - Interrupt Priority configuration Register 29
        pub pfic_iprior29: PFIC_IPRIOR29,
        _reserved52: [u8; 0x1c],
        ///0x7c0 - Interrupt Priority configuration Register 30
        pub pfic_iprior30: PFIC_IPRIOR30,
        _reserved53: [u8; 0x1c],
        ///0x7e0 - Interrupt Priority configuration Register 31
        pub pfic_iprior31: PFIC_IPRIOR31,
        _reserved54: [u8; 0x1c],
        ///0x800 - Interrupt Priority configuration Register 32
        pub pfic_iprior32: PFIC_IPRIOR32,
        _reserved55: [u8; 0x1c],
        ///0x820 - Interrupt Priority configuration Register 33
        pub pfic_iprior33: PFIC_IPRIOR33,
        _reserved56: [u8; 0x1c],
        ///0x840 - Interrupt Priority configuration Register 34
        pub pfic_iprior34: PFIC_IPRIOR34,
        _reserved57: [u8; 0x1c],
        ///0x860 - Interrupt Priority configuration Register 35
        pub pfic_iprior35: PFIC_IPRIOR35,
        _reserved58: [u8; 0x1c],
        ///0x880 - Interrupt Priority configuration Register 36
        pub pfic_iprior36: PFIC_IPRIOR36,
        _reserved59: [u8; 0x1c],
        ///0x8a0 - Interrupt Priority configuration Register 37
        pub pfic_iprior37: PFIC_IPRIOR37,
        _reserved60: [u8; 0x1c],
        ///0x8c0 - Interrupt Priority configuration Register 38
        pub pfic_iprior38: PFIC_IPRIOR38,
        _reserved61: [u8; 0x1c],
        ///0x8e0 - Interrupt Priority configuration Register 39
        pub pfic_iprior39: PFIC_IPRIOR39,
        _reserved62: [u8; 0x1c],
        ///0x900 - Interrupt Priority configuration Register 40
        pub pfic_iprior40: PFIC_IPRIOR40,
        _reserved63: [u8; 0x1c],
        ///0x920 - Interrupt Priority configuration Register 41
        pub pfic_iprior41: PFIC_IPRIOR41,
        _reserved64: [u8; 0x1c],
        ///0x940 - Interrupt Priority configuration Register 42
        pub pfic_iprior42: PFIC_IPRIOR42,
        _reserved65: [u8; 0x1c],
        ///0x960 - Interrupt Priority configuration Register 43
        pub pfic_iprior43: PFIC_IPRIOR43,
        _reserved66: [u8; 0x1c],
        ///0x980 - Interrupt Priority configuration Register 44
        pub pfic_iprior44: PFIC_IPRIOR44,
        _reserved67: [u8; 0x1c],
        ///0x9a0 - Interrupt Priority configuration Register 45
        pub pfic_iprior45: PFIC_IPRIOR45,
        _reserved68: [u8; 0x1c],
        ///0x9c0 - Interrupt Priority configuration Register 46
        pub pfic_iprior46: PFIC_IPRIOR46,
        _reserved69: [u8; 0x1c],
        ///0x9e0 - Interrupt Priority configuration Register 47
        pub pfic_iprior47: PFIC_IPRIOR47,
        _reserved70: [u8; 0x1c],
        ///0xa00 - Interrupt Priority configuration Register 48
        pub pfic_iprior48: PFIC_IPRIOR48,
        _reserved71: [u8; 0x1c],
        ///0xa20 - Interrupt Priority configuration Register 49
        pub pfic_iprior49: PFIC_IPRIOR49,
        _reserved72: [u8; 0x1c],
        ///0xa40 - Interrupt Priority configuration Register 50
        pub pfic_iprior50: PFIC_IPRIOR50,
        _reserved73: [u8; 0x1c],
        ///0xa60 - Interrupt Priority configuration Register 51
        pub pfic_iprior51: PFIC_IPRIOR51,
        _reserved74: [u8; 0x1c],
        ///0xa80 - Interrupt Priority configuration Register 52
        pub pfic_iprior52: PFIC_IPRIOR52,
        _reserved75: [u8; 0x1c],
        ///0xaa0 - Interrupt Priority configuration Register 53
        pub pfic_iprior53: PFIC_IPRIOR53,
        _reserved76: [u8; 0x2c],
        ///0xad0 - Interrupt Priority configuration Register 54
        pub pfic_iprior54: PFIC_IPRIOR54,
        _reserved77: [u8; 0x0c],
        ///0xae0 - Interrupt Priority configuration Register 55
        pub pfic_iprior55: PFIC_IPRIOR55,
        _reserved78: [u8; 0x1c],
        ///0xb00 - Interrupt Priority configuration Register 56
        pub pfic_iprior56: PFIC_IPRIOR56,
        _reserved79: [u8; 0x1c],
        ///0xb20 - Interrupt Priority configuration Register 57
        pub pfic_iprior57: PFIC_IPRIOR57,
        _reserved80: [u8; 0x1c],
        ///0xb40 - Interrupt Priority configuration Register 58
        pub pfic_iprior58: PFIC_IPRIOR58,
        _reserved81: [u8; 0x1c],
        ///0xb60 - Interrupt Priority configuration Register 59
        pub pfic_iprior59: PFIC_IPRIOR59,
        _reserved82: [u8; 0x1c],
        ///0xb80 - Interrupt Priority configuration Register 60
        pub pfic_iprior60: PFIC_IPRIOR60,
        _reserved83: [u8; 0x1c],
        ///0xba0 - Interrupt Priority configuration Register 61
        pub pfic_iprior61: PFIC_IPRIOR61,
        _reserved84: [u8; 0x3c],
        ///0xbe0 - Interrupt Priority configuration Register 62
        pub pfic_iprior62: PFIC_IPRIOR62,
        _reserved85: [u8; 0x1c],
        ///0xc00 - Interrupt Priority configuration Register 63
        pub pfic_iprior63: PFIC_IPRIOR63,
        _reserved86: [u8; 0x010c],
        ///0xd10 - System Control Register
        pub pfic_sctlr: PFIC_SCTLR,
    }
    ///PFIC_ISR1 (r) register accessor: an alias for `Reg<PFIC_ISR1_SPEC>`
    pub type PFIC_ISR1 = crate::Reg<pfic_isr1::PFIC_ISR1_SPEC>;
    ///RO,Interrupt Status Register 1
    pub mod pfic_isr1 {
        ///Register `PFIC_ISR1` reader
        pub struct R(crate::R<PFIC_ISR1_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PFIC_ISR1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<PFIC_ISR1_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<PFIC_ISR1_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `INTENSTA` reader - Interrupt ID Status
        pub type INTENSTA_R = crate::FieldReader<u32, u32>;
        impl R {
            ///Bits 12:31 - Interrupt ID Status
            #[inline(always)]
            pub fn intensta(&self) -> INTENSTA_R {
                INTENSTA_R::new((self.bits >> 12) & 0x000f_ffff)
            }
        }
        ///RO,Interrupt Status Register 1
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [pfic_isr1](index.html) module
        pub struct PFIC_ISR1_SPEC;
        impl crate::RegisterSpec for PFIC_ISR1_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [pfic_isr1::R](R) reader structure
        impl crate::Readable for PFIC_ISR1_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets PFIC_ISR1 to value 0
        impl crate::Resettable for PFIC_ISR1_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///PFIC_ISR2 (r) register accessor: an alias for `Reg<PFIC_ISR2_SPEC>`
    pub type PFIC_ISR2 = crate::Reg<pfic_isr2::PFIC_ISR2_SPEC>;
    ///RO,Interrupt Status Register 2
    pub mod pfic_isr2 {
        ///Register `PFIC_ISR2` reader
        pub struct R(crate::R<PFIC_ISR2_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PFIC_ISR2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<PFIC_ISR2_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<PFIC_ISR2_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `INTENSTA` reader - Interrupt ID Status
        pub type INTENSTA_R = crate::FieldReader<u8, u8>;
        impl R {
            ///Bits 0:3 - Interrupt ID Status
            #[inline(always)]
            pub fn intensta(&self) -> INTENSTA_R {
                INTENSTA_R::new((self.bits & 0x0f) as u8)
            }
        }
        ///RO,Interrupt Status Register 2
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [pfic_isr2](index.html) module
        pub struct PFIC_ISR2_SPEC;
        impl crate::RegisterSpec for PFIC_ISR2_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [pfic_isr2::R](R) reader structure
        impl crate::Readable for PFIC_ISR2_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets PFIC_ISR2 to value 0
        impl crate::Resettable for PFIC_ISR2_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///PFIC_IPR1 (r) register accessor: an alias for `Reg<PFIC_IPR1_SPEC>`
    pub type PFIC_IPR1 = crate::Reg<pfic_ipr1::PFIC_IPR1_SPEC>;
    ///RO,Interrupt Pending Register 1
    pub mod pfic_ipr1 {
        ///Register `PFIC_IPR1` reader
        pub struct R(crate::R<PFIC_IPR1_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PFIC_IPR1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<PFIC_IPR1_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<PFIC_IPR1_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `PENDSTA` reader - PENDSTA
        pub type PENDSTA_R = crate::FieldReader<u32, u32>;
        impl R {
            ///Bits 12:31 - PENDSTA
            #[inline(always)]
            pub fn pendsta(&self) -> PENDSTA_R {
                PENDSTA_R::new((self.bits >> 12) & 0x000f_ffff)
            }
        }
        ///RO,Interrupt Pending Register 1
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [pfic_ipr1](index.html) module
        pub struct PFIC_IPR1_SPEC;
        impl crate::RegisterSpec for PFIC_IPR1_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [pfic_ipr1::R](R) reader structure
        impl crate::Readable for PFIC_IPR1_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets PFIC_IPR1 to value 0
        impl crate::Resettable for PFIC_IPR1_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///PFIC_IPR2 (r) register accessor: an alias for `Reg<PFIC_IPR2_SPEC>`
    pub type PFIC_IPR2 = crate::Reg<pfic_ipr2::PFIC_IPR2_SPEC>;
    ///RO,Interrupt Pending Register 2
    pub mod pfic_ipr2 {
        ///Register `PFIC_IPR2` reader
        pub struct R(crate::R<PFIC_IPR2_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PFIC_IPR2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<PFIC_IPR2_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<PFIC_IPR2_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `PENDSTA` reader - PENDSTA
        pub type PENDSTA_R = crate::FieldReader<u8, u8>;
        impl R {
            ///Bits 0:3 - PENDSTA
            #[inline(always)]
            pub fn pendsta(&self) -> PENDSTA_R {
                PENDSTA_R::new((self.bits & 0x0f) as u8)
            }
        }
        ///RO,Interrupt Pending Register 2
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [pfic_ipr2](index.html) module
        pub struct PFIC_IPR2_SPEC;
        impl crate::RegisterSpec for PFIC_IPR2_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [pfic_ipr2::R](R) reader structure
        impl crate::Readable for PFIC_IPR2_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets PFIC_IPR2 to value 0
        impl crate::Resettable for PFIC_IPR2_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///PFIC_ITHRESDR (rw) register accessor: an alias for `Reg<PFIC_ITHRESDR_SPEC>`
    pub type PFIC_ITHRESDR = crate::Reg<pfic_ithresdr::PFIC_ITHRESDR_SPEC>;
    ///RW,Interrupt Priority Register
    pub mod pfic_ithresdr {
        ///Register `PFIC_ITHRESDR` reader
        pub struct R(crate::R<PFIC_ITHRESDR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PFIC_ITHRESDR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<PFIC_ITHRESDR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<PFIC_ITHRESDR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `PFIC_ITHRESDR` writer
        pub struct W(crate::W<PFIC_ITHRESDR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PFIC_ITHRESDR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<PFIC_ITHRESDR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<PFIC_ITHRESDR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `THRESHOLD` reader - RW,THRESHOLD
        pub type THRESHOLD_R = crate::FieldReader<u8, u8>;
        ///Field `THRESHOLD` writer - RW,THRESHOLD
        pub type THRESHOLD_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, PFIC_ITHRESDR_SPEC, u8, u8, 8, O>;
        impl R {
            ///Bits 0:7 - RW,THRESHOLD
            #[inline(always)]
            pub fn threshold(&self) -> THRESHOLD_R {
                THRESHOLD_R::new((self.bits & 0xff) as u8)
            }
        }
        impl W {
            ///Bits 0:7 - RW,THRESHOLD
            #[inline(always)]
            #[must_use]
            pub fn threshold(&mut self) -> THRESHOLD_W<0> {
                THRESHOLD_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW,Interrupt Priority Register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [pfic_ithresdr](index.html) module
        pub struct PFIC_ITHRESDR_SPEC;
        impl crate::RegisterSpec for PFIC_ITHRESDR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [pfic_ithresdr::R](R) reader structure
        impl crate::Readable for PFIC_ITHRESDR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [pfic_ithresdr::W](W) writer structure
        impl crate::Writable for PFIC_ITHRESDR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets PFIC_ITHRESDR to value 0
        impl crate::Resettable for PFIC_ITHRESDR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///PFIC_CFGR (w) register accessor: an alias for `Reg<PFIC_CFGR_SPEC>`
    pub type PFIC_CFGR = crate::Reg<pfic_cfgr::PFIC_CFGR_SPEC>;
    ///Interrupt Config Register
    pub mod pfic_cfgr {
        ///Register `PFIC_CFGR` writer
        pub struct W(crate::W<PFIC_CFGR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PFIC_CFGR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<PFIC_CFGR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<PFIC_CFGR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `RESETSYS` writer - WO,RESETSYS
        pub type RESETSYS_W<'a, const O: u8> = crate::BitWriter<'a, u32, PFIC_CFGR_SPEC, bool, O>;
        ///Field `KEYCODE` writer - WO,KEYCODE
        pub type KEYCODE_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, PFIC_CFGR_SPEC, u16, u16, 16, O>;
        impl W {
            ///Bit 7 - WO,RESETSYS
            #[inline(always)]
            #[must_use]
            pub fn resetsys(&mut self) -> RESETSYS_W<7> {
                RESETSYS_W::new(self)
            }
            ///Bits 16:31 - WO,KEYCODE
            #[inline(always)]
            #[must_use]
            pub fn keycode(&mut self) -> KEYCODE_W<16> {
                KEYCODE_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Config Register
        ///
        ///This register you can [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [pfic_cfgr](index.html) module
        pub struct PFIC_CFGR_SPEC;
        impl crate::RegisterSpec for PFIC_CFGR_SPEC {
            type Ux = u32;
        }
        ///`write(|w| ..)` method takes [pfic_cfgr::W](W) writer structure
        impl crate::Writable for PFIC_CFGR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets PFIC_CFGR to value 0
        impl crate::Resettable for PFIC_CFGR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///PFIC_GISR (r) register accessor: an alias for `Reg<PFIC_GISR_SPEC>`
    pub type PFIC_GISR = crate::Reg<pfic_gisr::PFIC_GISR_SPEC>;
    ///Interrupt Global Register
    pub mod pfic_gisr {
        ///Register `PFIC_GISR` reader
        pub struct R(crate::R<PFIC_GISR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PFIC_GISR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<PFIC_GISR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<PFIC_GISR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `NESTSTA` reader - RO,NESTSTA
        pub type NESTSTA_R = crate::FieldReader<u8, u8>;
        ///Field `GACTSTA` reader - RO,GACTSTA
        pub type GACTSTA_R = crate::BitReader<bool>;
        ///Field `GPENDSTA` reader - RO,GPENDSTA
        pub type GPENDSTA_R = crate::BitReader<bool>;
        impl R {
            ///Bits 0:7 - RO,NESTSTA
            #[inline(always)]
            pub fn neststa(&self) -> NESTSTA_R {
                NESTSTA_R::new((self.bits & 0xff) as u8)
            }
            ///Bit 8 - RO,GACTSTA
            #[inline(always)]
            pub fn gactsta(&self) -> GACTSTA_R {
                GACTSTA_R::new(((self.bits >> 8) & 1) != 0)
            }
            ///Bit 9 - RO,GPENDSTA
            #[inline(always)]
            pub fn gpendsta(&self) -> GPENDSTA_R {
                GPENDSTA_R::new(((self.bits >> 9) & 1) != 0)
            }
        }
        ///Interrupt Global Register
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [pfic_gisr](index.html) module
        pub struct PFIC_GISR_SPEC;
        impl crate::RegisterSpec for PFIC_GISR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [pfic_gisr::R](R) reader structure
        impl crate::Readable for PFIC_GISR_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets PFIC_GISR to value 0
        impl crate::Resettable for PFIC_GISR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///PFIC_IDCFGR (rw) register accessor: an alias for `Reg<PFIC_IDCFGR_SPEC>`
    pub type PFIC_IDCFGR = crate::Reg<pfic_idcfgr::PFIC_IDCFGR_SPEC>;
    ///RW,Interrupt Fast ID Config Register
    pub mod pfic_idcfgr {
        ///Register `PFIC_IDCFGR` reader
        pub struct R(crate::R<PFIC_IDCFGR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PFIC_IDCFGR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<PFIC_IDCFGR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<PFIC_IDCFGR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `PFIC_IDCFGR` writer
        pub struct W(crate::W<PFIC_IDCFGR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PFIC_IDCFGR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<PFIC_IDCFGR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<PFIC_IDCFGR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `FIID0` reader - RW,FIID0
        pub type FIID0_R = crate::FieldReader<u8, u8>;
        ///Field `FIID0` writer - RW,FIID0
        pub type FIID0_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, PFIC_IDCFGR_SPEC, u8, u8, 8, O>;
        ///Field `FIID1` reader - RW,FIID1
        pub type FIID1_R = crate::FieldReader<u8, u8>;
        ///Field `FIID1` writer - RW,FIID1
        pub type FIID1_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, PFIC_IDCFGR_SPEC, u8, u8, 8, O>;
        ///Field `FIID2` reader - RW,FIID2
        pub type FIID2_R = crate::FieldReader<u8, u8>;
        ///Field `FIID2` writer - RW,FIID2
        pub type FIID2_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, PFIC_IDCFGR_SPEC, u8, u8, 8, O>;
        ///Field `FIID3` reader - RW,FIID3
        pub type FIID3_R = crate::FieldReader<u8, u8>;
        ///Field `FIID3` writer - RW,FIID3
        pub type FIID3_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, PFIC_IDCFGR_SPEC, u8, u8, 8, O>;
        impl R {
            ///Bits 0:7 - RW,FIID0
            #[inline(always)]
            pub fn fiid0(&self) -> FIID0_R {
                FIID0_R::new((self.bits & 0xff) as u8)
            }
            ///Bits 8:15 - RW,FIID1
            #[inline(always)]
            pub fn fiid1(&self) -> FIID1_R {
                FIID1_R::new(((self.bits >> 8) & 0xff) as u8)
            }
            ///Bits 16:23 - RW,FIID2
            #[inline(always)]
            pub fn fiid2(&self) -> FIID2_R {
                FIID2_R::new(((self.bits >> 16) & 0xff) as u8)
            }
            ///Bits 24:31 - RW,FIID3
            #[inline(always)]
            pub fn fiid3(&self) -> FIID3_R {
                FIID3_R::new(((self.bits >> 24) & 0xff) as u8)
            }
        }
        impl W {
            ///Bits 0:7 - RW,FIID0
            #[inline(always)]
            #[must_use]
            pub fn fiid0(&mut self) -> FIID0_W<0> {
                FIID0_W::new(self)
            }
            ///Bits 8:15 - RW,FIID1
            #[inline(always)]
            #[must_use]
            pub fn fiid1(&mut self) -> FIID1_W<8> {
                FIID1_W::new(self)
            }
            ///Bits 16:23 - RW,FIID2
            #[inline(always)]
            #[must_use]
            pub fn fiid2(&mut self) -> FIID2_W<16> {
                FIID2_W::new(self)
            }
            ///Bits 24:31 - RW,FIID3
            #[inline(always)]
            #[must_use]
            pub fn fiid3(&mut self) -> FIID3_W<24> {
                FIID3_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RW,Interrupt Fast ID Config Register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [pfic_idcfgr](index.html) module
        pub struct PFIC_IDCFGR_SPEC;
        impl crate::RegisterSpec for PFIC_IDCFGR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [pfic_idcfgr::R](R) reader structure
        impl crate::Readable for PFIC_IDCFGR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [pfic_idcfgr::W](W) writer structure
        impl crate::Writable for PFIC_IDCFGR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets PFIC_IDCFGR to value 0
        impl crate::Resettable for PFIC_IDCFGR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///PFIC_FIADDRR0 (rw) register accessor: an alias for `Reg<PFIC_FIADDRR0_SPEC>`
    pub type PFIC_FIADDRR0 = crate::Reg<pfic_fiaddrr0::PFIC_FIADDRR0_SPEC>;
    ///Interrupt 0 address Register
    pub mod pfic_fiaddrr0 {
        ///Register `PFIC_FIADDRR0` reader
        pub struct R(crate::R<PFIC_FIADDRR0_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PFIC_FIADDRR0_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<PFIC_FIADDRR0_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<PFIC_FIADDRR0_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `PFIC_FIADDRR0` writer
        pub struct W(crate::W<PFIC_FIADDRR0_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PFIC_FIADDRR0_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<PFIC_FIADDRR0_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<PFIC_FIADDRR0_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `FI0EN` reader - RW,FI0EN
        pub type FI0EN_R = crate::BitReader<bool>;
        ///Field `FI0EN` writer - RW,FI0EN
        pub type FI0EN_W<'a, const O: u8> = crate::BitWriter<'a, u32, PFIC_FIADDRR0_SPEC, bool, O>;
        ///Field `ADDR0` reader - RW,ADDR0
        pub type ADDR0_R = crate::FieldReader<u32, u32>;
        ///Field `ADDR0` writer - RW,ADDR0
        pub type ADDR0_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, PFIC_FIADDRR0_SPEC, u32, u32, 31, O>;
        impl R {
            ///Bit 0 - RW,FI0EN
            #[inline(always)]
            pub fn fi0en(&self) -> FI0EN_R {
                FI0EN_R::new((self.bits & 1) != 0)
            }
            ///Bits 1:31 - RW,ADDR0
            #[inline(always)]
            pub fn addr0(&self) -> ADDR0_R {
                ADDR0_R::new((self.bits >> 1) & 0x7fff_ffff)
            }
        }
        impl W {
            ///Bit 0 - RW,FI0EN
            #[inline(always)]
            #[must_use]
            pub fn fi0en(&mut self) -> FI0EN_W<0> {
                FI0EN_W::new(self)
            }
            ///Bits 1:31 - RW,ADDR0
            #[inline(always)]
            #[must_use]
            pub fn addr0(&mut self) -> ADDR0_W<1> {
                ADDR0_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt 0 address Register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [pfic_fiaddrr0](index.html) module
        pub struct PFIC_FIADDRR0_SPEC;
        impl crate::RegisterSpec for PFIC_FIADDRR0_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [pfic_fiaddrr0::R](R) reader structure
        impl crate::Readable for PFIC_FIADDRR0_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [pfic_fiaddrr0::W](W) writer structure
        impl crate::Writable for PFIC_FIADDRR0_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets PFIC_FIADDRR0 to value 0
        impl crate::Resettable for PFIC_FIADDRR0_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///PFIC_FIADDRR1 (rw) register accessor: an alias for `Reg<PFIC_FIADDRR1_SPEC>`
    pub type PFIC_FIADDRR1 = crate::Reg<pfic_fiaddrr1::PFIC_FIADDRR1_SPEC>;
    ///Interrupt 1 address Register
    pub mod pfic_fiaddrr1 {
        ///Register `PFIC_FIADDRR1` reader
        pub struct R(crate::R<PFIC_FIADDRR1_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PFIC_FIADDRR1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<PFIC_FIADDRR1_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<PFIC_FIADDRR1_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `PFIC_FIADDRR1` writer
        pub struct W(crate::W<PFIC_FIADDRR1_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PFIC_FIADDRR1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<PFIC_FIADDRR1_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<PFIC_FIADDRR1_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `FI1EN` reader - RW,FI1EN
        pub type FI1EN_R = crate::BitReader<bool>;
        ///Field `FI1EN` writer - RW,FI1EN
        pub type FI1EN_W<'a, const O: u8> = crate::BitWriter<'a, u32, PFIC_FIADDRR1_SPEC, bool, O>;
        ///Field `ADDR1` reader - RW,ADDR1
        pub type ADDR1_R = crate::FieldReader<u32, u32>;
        ///Field `ADDR1` writer - RW,ADDR1
        pub type ADDR1_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, PFIC_FIADDRR1_SPEC, u32, u32, 31, O>;
        impl R {
            ///Bit 0 - RW,FI1EN
            #[inline(always)]
            pub fn fi1en(&self) -> FI1EN_R {
                FI1EN_R::new((self.bits & 1) != 0)
            }
            ///Bits 1:31 - RW,ADDR1
            #[inline(always)]
            pub fn addr1(&self) -> ADDR1_R {
                ADDR1_R::new((self.bits >> 1) & 0x7fff_ffff)
            }
        }
        impl W {
            ///Bit 0 - RW,FI1EN
            #[inline(always)]
            #[must_use]
            pub fn fi1en(&mut self) -> FI1EN_W<0> {
                FI1EN_W::new(self)
            }
            ///Bits 1:31 - RW,ADDR1
            #[inline(always)]
            #[must_use]
            pub fn addr1(&mut self) -> ADDR1_W<1> {
                ADDR1_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt 1 address Register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [pfic_fiaddrr1](index.html) module
        pub struct PFIC_FIADDRR1_SPEC;
        impl crate::RegisterSpec for PFIC_FIADDRR1_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [pfic_fiaddrr1::R](R) reader structure
        impl crate::Readable for PFIC_FIADDRR1_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [pfic_fiaddrr1::W](W) writer structure
        impl crate::Writable for PFIC_FIADDRR1_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets PFIC_FIADDRR1 to value 0
        impl crate::Resettable for PFIC_FIADDRR1_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///PFIC_FIADDRR2 (rw) register accessor: an alias for `Reg<PFIC_FIADDRR2_SPEC>`
    pub type PFIC_FIADDRR2 = crate::Reg<pfic_fiaddrr2::PFIC_FIADDRR2_SPEC>;
    ///Interrupt 2 address Register
    pub mod pfic_fiaddrr2 {
        ///Register `PFIC_FIADDRR2` reader
        pub struct R(crate::R<PFIC_FIADDRR2_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PFIC_FIADDRR2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<PFIC_FIADDRR2_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<PFIC_FIADDRR2_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `PFIC_FIADDRR2` writer
        pub struct W(crate::W<PFIC_FIADDRR2_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PFIC_FIADDRR2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<PFIC_FIADDRR2_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<PFIC_FIADDRR2_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `FI2EN` reader - RW,FI2EN
        pub type FI2EN_R = crate::BitReader<bool>;
        ///Field `FI2EN` writer - RW,FI2EN
        pub type FI2EN_W<'a, const O: u8> = crate::BitWriter<'a, u32, PFIC_FIADDRR2_SPEC, bool, O>;
        ///Field `ADDR2` reader - RW,ADDR2
        pub type ADDR2_R = crate::FieldReader<u32, u32>;
        ///Field `ADDR2` writer - RW,ADDR2
        pub type ADDR2_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, PFIC_FIADDRR2_SPEC, u32, u32, 31, O>;
        impl R {
            ///Bit 0 - RW,FI2EN
            #[inline(always)]
            pub fn fi2en(&self) -> FI2EN_R {
                FI2EN_R::new((self.bits & 1) != 0)
            }
            ///Bits 1:31 - RW,ADDR2
            #[inline(always)]
            pub fn addr2(&self) -> ADDR2_R {
                ADDR2_R::new((self.bits >> 1) & 0x7fff_ffff)
            }
        }
        impl W {
            ///Bit 0 - RW,FI2EN
            #[inline(always)]
            #[must_use]
            pub fn fi2en(&mut self) -> FI2EN_W<0> {
                FI2EN_W::new(self)
            }
            ///Bits 1:31 - RW,ADDR2
            #[inline(always)]
            #[must_use]
            pub fn addr2(&mut self) -> ADDR2_W<1> {
                ADDR2_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt 2 address Register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [pfic_fiaddrr2](index.html) module
        pub struct PFIC_FIADDRR2_SPEC;
        impl crate::RegisterSpec for PFIC_FIADDRR2_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [pfic_fiaddrr2::R](R) reader structure
        impl crate::Readable for PFIC_FIADDRR2_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [pfic_fiaddrr2::W](W) writer structure
        impl crate::Writable for PFIC_FIADDRR2_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets PFIC_FIADDRR2 to value 0
        impl crate::Resettable for PFIC_FIADDRR2_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///PFIC_FIADDRR3 (rw) register accessor: an alias for `Reg<PFIC_FIADDRR3_SPEC>`
    pub type PFIC_FIADDRR3 = crate::Reg<pfic_fiaddrr3::PFIC_FIADDRR3_SPEC>;
    ///Interrupt 3 address Register
    pub mod pfic_fiaddrr3 {
        ///Register `PFIC_FIADDRR3` reader
        pub struct R(crate::R<PFIC_FIADDRR3_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PFIC_FIADDRR3_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<PFIC_FIADDRR3_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<PFIC_FIADDRR3_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `PFIC_FIADDRR3` writer
        pub struct W(crate::W<PFIC_FIADDRR3_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PFIC_FIADDRR3_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<PFIC_FIADDRR3_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<PFIC_FIADDRR3_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `FI3EN` reader - RW,FI3EN
        pub type FI3EN_R = crate::BitReader<bool>;
        ///Field `FI3EN` writer - RW,FI3EN
        pub type FI3EN_W<'a, const O: u8> = crate::BitWriter<'a, u32, PFIC_FIADDRR3_SPEC, bool, O>;
        ///Field `ADDR3` reader - RW,ADDR3
        pub type ADDR3_R = crate::FieldReader<u32, u32>;
        ///Field `ADDR3` writer - RW,ADDR3
        pub type ADDR3_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, PFIC_FIADDRR3_SPEC, u32, u32, 31, O>;
        impl R {
            ///Bit 0 - RW,FI3EN
            #[inline(always)]
            pub fn fi3en(&self) -> FI3EN_R {
                FI3EN_R::new((self.bits & 1) != 0)
            }
            ///Bits 1:31 - RW,ADDR3
            #[inline(always)]
            pub fn addr3(&self) -> ADDR3_R {
                ADDR3_R::new((self.bits >> 1) & 0x7fff_ffff)
            }
        }
        impl W {
            ///Bit 0 - RW,FI3EN
            #[inline(always)]
            #[must_use]
            pub fn fi3en(&mut self) -> FI3EN_W<0> {
                FI3EN_W::new(self)
            }
            ///Bits 1:31 - RW,ADDR3
            #[inline(always)]
            #[must_use]
            pub fn addr3(&mut self) -> ADDR3_W<1> {
                ADDR3_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt 3 address Register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [pfic_fiaddrr3](index.html) module
        pub struct PFIC_FIADDRR3_SPEC;
        impl crate::RegisterSpec for PFIC_FIADDRR3_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [pfic_fiaddrr3::R](R) reader structure
        impl crate::Readable for PFIC_FIADDRR3_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [pfic_fiaddrr3::W](W) writer structure
        impl crate::Writable for PFIC_FIADDRR3_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets PFIC_FIADDRR3 to value 0
        impl crate::Resettable for PFIC_FIADDRR3_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///PFIC_IENR1 (w) register accessor: an alias for `Reg<PFIC_IENR1_SPEC>`
    pub type PFIC_IENR1 = crate::Reg<pfic_ienr1::PFIC_IENR1_SPEC>;
    ///Interrupt Setting Register
    pub mod pfic_ienr1 {
        ///Register `PFIC_IENR1` writer
        pub struct W(crate::W<PFIC_IENR1_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PFIC_IENR1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<PFIC_IENR1_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<PFIC_IENR1_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `INTEN` writer - RW1,INTEN
        pub type INTEN_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, PFIC_IENR1_SPEC, u32, u32, 20, O>;
        impl W {
            ///Bits 12:31 - RW1,INTEN
            #[inline(always)]
            #[must_use]
            pub fn inten(&mut self) -> INTEN_W<12> {
                INTEN_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Setting Register
        ///
        ///This register you can [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [pfic_ienr1](index.html) module
        pub struct PFIC_IENR1_SPEC;
        impl crate::RegisterSpec for PFIC_IENR1_SPEC {
            type Ux = u32;
        }
        ///`write(|w| ..)` method takes [pfic_ienr1::W](W) writer structure
        impl crate::Writable for PFIC_IENR1_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets PFIC_IENR1 to value 0
        impl crate::Resettable for PFIC_IENR1_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///PFIC_IENR2 (w) register accessor: an alias for `Reg<PFIC_IENR2_SPEC>`
    pub type PFIC_IENR2 = crate::Reg<pfic_ienr2::PFIC_IENR2_SPEC>;
    ///Interrupt Setting Register
    pub mod pfic_ienr2 {
        ///Register `PFIC_IENR2` writer
        pub struct W(crate::W<PFIC_IENR2_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PFIC_IENR2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<PFIC_IENR2_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<PFIC_IENR2_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `INTEN` writer - RW1,INTEN
        pub type INTEN_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, PFIC_IENR2_SPEC, u8, u8, 4, O>;
        impl W {
            ///Bits 0:3 - RW1,INTEN
            #[inline(always)]
            #[must_use]
            pub fn inten(&mut self) -> INTEN_W<0> {
                INTEN_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Setting Register
        ///
        ///This register you can [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [pfic_ienr2](index.html) module
        pub struct PFIC_IENR2_SPEC;
        impl crate::RegisterSpec for PFIC_IENR2_SPEC {
            type Ux = u32;
        }
        ///`write(|w| ..)` method takes [pfic_ienr2::W](W) writer structure
        impl crate::Writable for PFIC_IENR2_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets PFIC_IENR2 to value 0
        impl crate::Resettable for PFIC_IENR2_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///PFIC_IRER1 (w) register accessor: an alias for `Reg<PFIC_IRER1_SPEC>`
    pub type PFIC_IRER1 = crate::Reg<pfic_irer1::PFIC_IRER1_SPEC>;
    ///Interrupt Clear Register
    pub mod pfic_irer1 {
        ///Register `PFIC_IRER1` writer
        pub struct W(crate::W<PFIC_IRER1_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PFIC_IRER1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<PFIC_IRER1_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<PFIC_IRER1_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `INTRESET` writer - RW1,INTRESET
        pub type INTRESET_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, PFIC_IRER1_SPEC, u32, u32, 20, O>;
        impl W {
            ///Bits 12:31 - RW1,INTRESET
            #[inline(always)]
            #[must_use]
            pub fn intreset(&mut self) -> INTRESET_W<12> {
                INTRESET_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Clear Register
        ///
        ///This register you can [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [pfic_irer1](index.html) module
        pub struct PFIC_IRER1_SPEC;
        impl crate::RegisterSpec for PFIC_IRER1_SPEC {
            type Ux = u32;
        }
        ///`write(|w| ..)` method takes [pfic_irer1::W](W) writer structure
        impl crate::Writable for PFIC_IRER1_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets PFIC_IRER1 to value 0
        impl crate::Resettable for PFIC_IRER1_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///PFIC_IRER2 (w) register accessor: an alias for `Reg<PFIC_IRER2_SPEC>`
    pub type PFIC_IRER2 = crate::Reg<pfic_irer2::PFIC_IRER2_SPEC>;
    ///Interrupt Clear Register
    pub mod pfic_irer2 {
        ///Register `PFIC_IRER2` writer
        pub struct W(crate::W<PFIC_IRER2_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PFIC_IRER2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<PFIC_IRER2_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<PFIC_IRER2_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `INTRESET` writer - RW1,INTRESET
        pub type INTRESET_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, PFIC_IRER2_SPEC, u8, u8, 4, O>;
        impl W {
            ///Bits 0:3 - RW1,INTRESET
            #[inline(always)]
            #[must_use]
            pub fn intreset(&mut self) -> INTRESET_W<0> {
                INTRESET_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Clear Register
        ///
        ///This register you can [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [pfic_irer2](index.html) module
        pub struct PFIC_IRER2_SPEC;
        impl crate::RegisterSpec for PFIC_IRER2_SPEC {
            type Ux = u32;
        }
        ///`write(|w| ..)` method takes [pfic_irer2::W](W) writer structure
        impl crate::Writable for PFIC_IRER2_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets PFIC_IRER2 to value 0
        impl crate::Resettable for PFIC_IRER2_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///PFIC_IPSR1 (w) register accessor: an alias for `Reg<PFIC_IPSR1_SPEC>`
    pub type PFIC_IPSR1 = crate::Reg<pfic_ipsr1::PFIC_IPSR1_SPEC>;
    ///Interrupt Pending Register
    pub mod pfic_ipsr1 {
        ///Register `PFIC_IPSR1` writer
        pub struct W(crate::W<PFIC_IPSR1_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PFIC_IPSR1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<PFIC_IPSR1_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<PFIC_IPSR1_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `PENDSET` writer - RW1,PENDSET
        pub type PENDSET_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, PFIC_IPSR1_SPEC, u32, u32, 20, O>;
        impl W {
            ///Bits 12:31 - RW1,PENDSET
            #[inline(always)]
            #[must_use]
            pub fn pendset(&mut self) -> PENDSET_W<12> {
                PENDSET_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Pending Register
        ///
        ///This register you can [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [pfic_ipsr1](index.html) module
        pub struct PFIC_IPSR1_SPEC;
        impl crate::RegisterSpec for PFIC_IPSR1_SPEC {
            type Ux = u32;
        }
        ///`write(|w| ..)` method takes [pfic_ipsr1::W](W) writer structure
        impl crate::Writable for PFIC_IPSR1_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets PFIC_IPSR1 to value 0
        impl crate::Resettable for PFIC_IPSR1_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///PFIC_IPSR2 (w) register accessor: an alias for `Reg<PFIC_IPSR2_SPEC>`
    pub type PFIC_IPSR2 = crate::Reg<pfic_ipsr2::PFIC_IPSR2_SPEC>;
    ///Interrupt Pending Register
    pub mod pfic_ipsr2 {
        ///Register `PFIC_IPSR2` writer
        pub struct W(crate::W<PFIC_IPSR2_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PFIC_IPSR2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<PFIC_IPSR2_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<PFIC_IPSR2_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `PENDSET` writer - RW1,PENDSET
        pub type PENDSET_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, PFIC_IPSR2_SPEC, u8, u8, 4, O>;
        impl W {
            ///Bits 0:3 - RW1,PENDSET
            #[inline(always)]
            #[must_use]
            pub fn pendset(&mut self) -> PENDSET_W<0> {
                PENDSET_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Pending Register
        ///
        ///This register you can [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [pfic_ipsr2](index.html) module
        pub struct PFIC_IPSR2_SPEC;
        impl crate::RegisterSpec for PFIC_IPSR2_SPEC {
            type Ux = u32;
        }
        ///`write(|w| ..)` method takes [pfic_ipsr2::W](W) writer structure
        impl crate::Writable for PFIC_IPSR2_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets PFIC_IPSR2 to value 0
        impl crate::Resettable for PFIC_IPSR2_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///PFIC_IPRR1 (w) register accessor: an alias for `Reg<PFIC_IPRR1_SPEC>`
    pub type PFIC_IPRR1 = crate::Reg<pfic_iprr1::PFIC_IPRR1_SPEC>;
    ///Interrupt Pending Clear Register
    pub mod pfic_iprr1 {
        ///Register `PFIC_IPRR1` writer
        pub struct W(crate::W<PFIC_IPRR1_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PFIC_IPRR1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<PFIC_IPRR1_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<PFIC_IPRR1_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `PENDRESET` writer - RW1,PENDRESET
        pub type PENDRESET_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, PFIC_IPRR1_SPEC, u32, u32, 20, O>;
        impl W {
            ///Bits 12:31 - RW1,PENDRESET
            #[inline(always)]
            #[must_use]
            pub fn pendreset(&mut self) -> PENDRESET_W<12> {
                PENDRESET_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Pending Clear Register
        ///
        ///This register you can [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [pfic_iprr1](index.html) module
        pub struct PFIC_IPRR1_SPEC;
        impl crate::RegisterSpec for PFIC_IPRR1_SPEC {
            type Ux = u32;
        }
        ///`write(|w| ..)` method takes [pfic_iprr1::W](W) writer structure
        impl crate::Writable for PFIC_IPRR1_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets PFIC_IPRR1 to value 0
        impl crate::Resettable for PFIC_IPRR1_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///PFIC_IPRR2 (w) register accessor: an alias for `Reg<PFIC_IPRR2_SPEC>`
    pub type PFIC_IPRR2 = crate::Reg<pfic_iprr2::PFIC_IPRR2_SPEC>;
    ///Interrupt Pending Clear Register
    pub mod pfic_iprr2 {
        ///Register `PFIC_IPRR2` writer
        pub struct W(crate::W<PFIC_IPRR2_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PFIC_IPRR2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<PFIC_IPRR2_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<PFIC_IPRR2_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `PENDRESET` writer - RW1,PENDRESET
        pub type PENDRESET_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, PFIC_IPRR2_SPEC, u8, u8, 4, O>;
        impl W {
            ///Bits 0:3 - RW1,PENDRESET
            #[inline(always)]
            #[must_use]
            pub fn pendreset(&mut self) -> PENDRESET_W<0> {
                PENDRESET_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Pending Clear Register
        ///
        ///This register you can [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [pfic_iprr2](index.html) module
        pub struct PFIC_IPRR2_SPEC;
        impl crate::RegisterSpec for PFIC_IPRR2_SPEC {
            type Ux = u32;
        }
        ///`write(|w| ..)` method takes [pfic_iprr2::W](W) writer structure
        impl crate::Writable for PFIC_IPRR2_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets PFIC_IPRR2 to value 0
        impl crate::Resettable for PFIC_IPRR2_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///PFIC_IACTR1 (rw) register accessor: an alias for `Reg<PFIC_IACTR1_SPEC>`
    pub type PFIC_IACTR1 = crate::Reg<pfic_iactr1::PFIC_IACTR1_SPEC>;
    ///Interrupt ACTIVE Register
    pub mod pfic_iactr1 {
        ///Register `PFIC_IACTR1` reader
        pub struct R(crate::R<PFIC_IACTR1_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PFIC_IACTR1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<PFIC_IACTR1_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<PFIC_IACTR1_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `PFIC_IACTR1` writer
        pub struct W(crate::W<PFIC_IACTR1_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PFIC_IACTR1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<PFIC_IACTR1_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<PFIC_IACTR1_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IACTS` reader - RW1,IACTS
        pub type IACTS_R = crate::FieldReader<u32, u32>;
        ///Field `IACTS` writer - RW1,IACTS
        pub type IACTS_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, PFIC_IACTR1_SPEC, u32, u32, 20, O>;
        impl R {
            ///Bits 12:31 - RW1,IACTS
            #[inline(always)]
            pub fn iacts(&self) -> IACTS_R {
                IACTS_R::new((self.bits >> 12) & 0x000f_ffff)
            }
        }
        impl W {
            ///Bits 12:31 - RW1,IACTS
            #[inline(always)]
            #[must_use]
            pub fn iacts(&mut self) -> IACTS_W<12> {
                IACTS_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt ACTIVE Register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [pfic_iactr1](index.html) module
        pub struct PFIC_IACTR1_SPEC;
        impl crate::RegisterSpec for PFIC_IACTR1_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [pfic_iactr1::R](R) reader structure
        impl crate::Readable for PFIC_IACTR1_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [pfic_iactr1::W](W) writer structure
        impl crate::Writable for PFIC_IACTR1_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets PFIC_IACTR1 to value 0
        impl crate::Resettable for PFIC_IACTR1_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///PFIC_IACTR2 (rw) register accessor: an alias for `Reg<PFIC_IACTR2_SPEC>`
    pub type PFIC_IACTR2 = crate::Reg<pfic_iactr2::PFIC_IACTR2_SPEC>;
    ///Interrupt ACTIVE Register
    pub mod pfic_iactr2 {
        ///Register `PFIC_IACTR2` reader
        pub struct R(crate::R<PFIC_IACTR2_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PFIC_IACTR2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<PFIC_IACTR2_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<PFIC_IACTR2_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `PFIC_IACTR2` writer
        pub struct W(crate::W<PFIC_IACTR2_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PFIC_IACTR2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<PFIC_IACTR2_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<PFIC_IACTR2_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IACTS` reader - RW1,IACTS
        pub type IACTS_R = crate::FieldReader<u8, u8>;
        ///Field `IACTS` writer - RW1,IACTS
        pub type IACTS_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, PFIC_IACTR2_SPEC, u8, u8, 4, O>;
        impl R {
            ///Bits 0:3 - RW1,IACTS
            #[inline(always)]
            pub fn iacts(&self) -> IACTS_R {
                IACTS_R::new((self.bits & 0x0f) as u8)
            }
        }
        impl W {
            ///Bits 0:3 - RW1,IACTS
            #[inline(always)]
            #[must_use]
            pub fn iacts(&mut self) -> IACTS_W<0> {
                IACTS_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt ACTIVE Register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [pfic_iactr2](index.html) module
        pub struct PFIC_IACTR2_SPEC;
        impl crate::RegisterSpec for PFIC_IACTR2_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [pfic_iactr2::R](R) reader structure
        impl crate::Readable for PFIC_IACTR2_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [pfic_iactr2::W](W) writer structure
        impl crate::Writable for PFIC_IACTR2_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets PFIC_IACTR2 to value 0
        impl crate::Resettable for PFIC_IACTR2_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///PFIC_IPRIOR0 (rw) register accessor: an alias for `Reg<PFIC_IPRIOR0_SPEC>`
    pub type PFIC_IPRIOR0 = crate::Reg<pfic_iprior0::PFIC_IPRIOR0_SPEC>;
    ///Interrupt Priority configuration Register 0
    pub mod pfic_iprior0 {
        ///Register `PFIC_IPRIOR0` reader
        pub struct R(crate::R<PFIC_IPRIOR0_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PFIC_IPRIOR0_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<PFIC_IPRIOR0_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<PFIC_IPRIOR0_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `PFIC_IPRIOR0` writer
        pub struct W(crate::W<PFIC_IPRIOR0_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PFIC_IPRIOR0_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<PFIC_IPRIOR0_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<PFIC_IPRIOR0_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR0` reader - RW,Interrupt priority for number 0-3
        pub type IPRIOR0_R = crate::FieldReader<u32, u32>;
        ///Field `IPRIOR0` writer - RW,Interrupt priority for number 0-3
        pub type IPRIOR0_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, PFIC_IPRIOR0_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 0-3
            #[inline(always)]
            pub fn iprior0(&self) -> IPRIOR0_R {
                IPRIOR0_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 0-3
            #[inline(always)]
            #[must_use]
            pub fn iprior0(&mut self) -> IPRIOR0_W<0> {
                IPRIOR0_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 0
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [pfic_iprior0](index.html) module
        pub struct PFIC_IPRIOR0_SPEC;
        impl crate::RegisterSpec for PFIC_IPRIOR0_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [pfic_iprior0::R](R) reader structure
        impl crate::Readable for PFIC_IPRIOR0_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [pfic_iprior0::W](W) writer structure
        impl crate::Writable for PFIC_IPRIOR0_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets PFIC_IPRIOR0 to value 0
        impl crate::Resettable for PFIC_IPRIOR0_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///PFIC_IPRIOR1 (rw) register accessor: an alias for `Reg<PFIC_IPRIOR1_SPEC>`
    pub type PFIC_IPRIOR1 = crate::Reg<pfic_iprior1::PFIC_IPRIOR1_SPEC>;
    ///Interrupt Priority configuration Register 1
    pub mod pfic_iprior1 {
        ///Register `PFIC_IPRIOR1` reader
        pub struct R(crate::R<PFIC_IPRIOR1_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PFIC_IPRIOR1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<PFIC_IPRIOR1_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<PFIC_IPRIOR1_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `PFIC_IPRIOR1` writer
        pub struct W(crate::W<PFIC_IPRIOR1_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PFIC_IPRIOR1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<PFIC_IPRIOR1_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<PFIC_IPRIOR1_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR1` reader - >RW,Interrupt priority for number 4-7
        pub type IPRIOR1_R = crate::FieldReader<u32, u32>;
        ///Field `IPRIOR1` writer - >RW,Interrupt priority for number 4-7
        pub type IPRIOR1_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, PFIC_IPRIOR1_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - >RW,Interrupt priority for number 4-7
            #[inline(always)]
            pub fn iprior1(&self) -> IPRIOR1_R {
                IPRIOR1_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - >RW,Interrupt priority for number 4-7
            #[inline(always)]
            #[must_use]
            pub fn iprior1(&mut self) -> IPRIOR1_W<0> {
                IPRIOR1_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 1
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [pfic_iprior1](index.html) module
        pub struct PFIC_IPRIOR1_SPEC;
        impl crate::RegisterSpec for PFIC_IPRIOR1_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [pfic_iprior1::R](R) reader structure
        impl crate::Readable for PFIC_IPRIOR1_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [pfic_iprior1::W](W) writer structure
        impl crate::Writable for PFIC_IPRIOR1_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets PFIC_IPRIOR1 to value 0
        impl crate::Resettable for PFIC_IPRIOR1_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///PFIC_IPRIOR2 (rw) register accessor: an alias for `Reg<PFIC_IPRIOR2_SPEC>`
    pub type PFIC_IPRIOR2 = crate::Reg<pfic_iprior2::PFIC_IPRIOR2_SPEC>;
    ///Interrupt Priority configuration Register 2
    pub mod pfic_iprior2 {
        ///Register `PFIC_IPRIOR2` reader
        pub struct R(crate::R<PFIC_IPRIOR2_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PFIC_IPRIOR2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<PFIC_IPRIOR2_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<PFIC_IPRIOR2_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `PFIC_IPRIOR2` writer
        pub struct W(crate::W<PFIC_IPRIOR2_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PFIC_IPRIOR2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<PFIC_IPRIOR2_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<PFIC_IPRIOR2_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR2` reader - >RW,Interrupt priority for number 8-11
        pub type IPRIOR2_R = crate::FieldReader<u32, u32>;
        ///Field `IPRIOR2` writer - >RW,Interrupt priority for number 8-11
        pub type IPRIOR2_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, PFIC_IPRIOR2_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - >RW,Interrupt priority for number 8-11
            #[inline(always)]
            pub fn iprior2(&self) -> IPRIOR2_R {
                IPRIOR2_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - >RW,Interrupt priority for number 8-11
            #[inline(always)]
            #[must_use]
            pub fn iprior2(&mut self) -> IPRIOR2_W<0> {
                IPRIOR2_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 2
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [pfic_iprior2](index.html) module
        pub struct PFIC_IPRIOR2_SPEC;
        impl crate::RegisterSpec for PFIC_IPRIOR2_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [pfic_iprior2::R](R) reader structure
        impl crate::Readable for PFIC_IPRIOR2_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [pfic_iprior2::W](W) writer structure
        impl crate::Writable for PFIC_IPRIOR2_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets PFIC_IPRIOR2 to value 0
        impl crate::Resettable for PFIC_IPRIOR2_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///PFIC_IPRIOR3 (rw) register accessor: an alias for `Reg<PFIC_IPRIOR3_SPEC>`
    pub type PFIC_IPRIOR3 = crate::Reg<pfic_iprior3::PFIC_IPRIOR3_SPEC>;
    ///Interrupt Priority configuration Register 3
    pub mod pfic_iprior3 {
        ///Register `PFIC_IPRIOR3` reader
        pub struct R(crate::R<PFIC_IPRIOR3_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PFIC_IPRIOR3_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<PFIC_IPRIOR3_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<PFIC_IPRIOR3_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `PFIC_IPRIOR3` writer
        pub struct W(crate::W<PFIC_IPRIOR3_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PFIC_IPRIOR3_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<PFIC_IPRIOR3_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<PFIC_IPRIOR3_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR3` reader - >RW,Interrupt priority for number 12-15
        pub type IPRIOR3_R = crate::FieldReader<u32, u32>;
        ///Field `IPRIOR3` writer - >RW,Interrupt priority for number 12-15
        pub type IPRIOR3_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, PFIC_IPRIOR3_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - >RW,Interrupt priority for number 12-15
            #[inline(always)]
            pub fn iprior3(&self) -> IPRIOR3_R {
                IPRIOR3_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - >RW,Interrupt priority for number 12-15
            #[inline(always)]
            #[must_use]
            pub fn iprior3(&mut self) -> IPRIOR3_W<0> {
                IPRIOR3_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 3
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [pfic_iprior3](index.html) module
        pub struct PFIC_IPRIOR3_SPEC;
        impl crate::RegisterSpec for PFIC_IPRIOR3_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [pfic_iprior3::R](R) reader structure
        impl crate::Readable for PFIC_IPRIOR3_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [pfic_iprior3::W](W) writer structure
        impl crate::Writable for PFIC_IPRIOR3_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets PFIC_IPRIOR3 to value 0
        impl crate::Resettable for PFIC_IPRIOR3_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///PFIC_IPRIOR4 (rw) register accessor: an alias for `Reg<PFIC_IPRIOR4_SPEC>`
    pub type PFIC_IPRIOR4 = crate::Reg<pfic_iprior4::PFIC_IPRIOR4_SPEC>;
    ///Interrupt Priority configuration Register 4
    pub mod pfic_iprior4 {
        ///Register `PFIC_IPRIOR4` reader
        pub struct R(crate::R<PFIC_IPRIOR4_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PFIC_IPRIOR4_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<PFIC_IPRIOR4_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<PFIC_IPRIOR4_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `PFIC_IPRIOR4` writer
        pub struct W(crate::W<PFIC_IPRIOR4_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PFIC_IPRIOR4_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<PFIC_IPRIOR4_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<PFIC_IPRIOR4_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR4` reader - >RW,Interrupt priority for number 16-19
        pub type IPRIOR4_R = crate::FieldReader<u32, u32>;
        ///Field `IPRIOR4` writer - >RW,Interrupt priority for number 16-19
        pub type IPRIOR4_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, PFIC_IPRIOR4_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - >RW,Interrupt priority for number 16-19
            #[inline(always)]
            pub fn iprior4(&self) -> IPRIOR4_R {
                IPRIOR4_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - >RW,Interrupt priority for number 16-19
            #[inline(always)]
            #[must_use]
            pub fn iprior4(&mut self) -> IPRIOR4_W<0> {
                IPRIOR4_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 4
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [pfic_iprior4](index.html) module
        pub struct PFIC_IPRIOR4_SPEC;
        impl crate::RegisterSpec for PFIC_IPRIOR4_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [pfic_iprior4::R](R) reader structure
        impl crate::Readable for PFIC_IPRIOR4_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [pfic_iprior4::W](W) writer structure
        impl crate::Writable for PFIC_IPRIOR4_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets PFIC_IPRIOR4 to value 0
        impl crate::Resettable for PFIC_IPRIOR4_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///PFIC_IPRIOR5 (rw) register accessor: an alias for `Reg<PFIC_IPRIOR5_SPEC>`
    pub type PFIC_IPRIOR5 = crate::Reg<pfic_iprior5::PFIC_IPRIOR5_SPEC>;
    ///Interrupt Priority configuration Register 5
    pub mod pfic_iprior5 {
        ///Register `PFIC_IPRIOR5` reader
        pub struct R(crate::R<PFIC_IPRIOR5_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PFIC_IPRIOR5_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<PFIC_IPRIOR5_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<PFIC_IPRIOR5_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `PFIC_IPRIOR5` writer
        pub struct W(crate::W<PFIC_IPRIOR5_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PFIC_IPRIOR5_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<PFIC_IPRIOR5_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<PFIC_IPRIOR5_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR5` reader - >RW,Interrupt priority for number 20-23
        pub type IPRIOR5_R = crate::FieldReader<u32, u32>;
        ///Field `IPRIOR5` writer - >RW,Interrupt priority for number 20-23
        pub type IPRIOR5_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, PFIC_IPRIOR5_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - >RW,Interrupt priority for number 20-23
            #[inline(always)]
            pub fn iprior5(&self) -> IPRIOR5_R {
                IPRIOR5_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - >RW,Interrupt priority for number 20-23
            #[inline(always)]
            #[must_use]
            pub fn iprior5(&mut self) -> IPRIOR5_W<0> {
                IPRIOR5_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 5
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [pfic_iprior5](index.html) module
        pub struct PFIC_IPRIOR5_SPEC;
        impl crate::RegisterSpec for PFIC_IPRIOR5_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [pfic_iprior5::R](R) reader structure
        impl crate::Readable for PFIC_IPRIOR5_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [pfic_iprior5::W](W) writer structure
        impl crate::Writable for PFIC_IPRIOR5_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets PFIC_IPRIOR5 to value 0
        impl crate::Resettable for PFIC_IPRIOR5_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///PFIC_IPRIOR6 (rw) register accessor: an alias for `Reg<PFIC_IPRIOR6_SPEC>`
    pub type PFIC_IPRIOR6 = crate::Reg<pfic_iprior6::PFIC_IPRIOR6_SPEC>;
    ///Interrupt Priority configuration Register 6
    pub mod pfic_iprior6 {
        ///Register `PFIC_IPRIOR6` reader
        pub struct R(crate::R<PFIC_IPRIOR6_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PFIC_IPRIOR6_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<PFIC_IPRIOR6_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<PFIC_IPRIOR6_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `PFIC_IPRIOR6` writer
        pub struct W(crate::W<PFIC_IPRIOR6_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PFIC_IPRIOR6_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<PFIC_IPRIOR6_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<PFIC_IPRIOR6_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR6` reader - >RW,Interrupt priority for number 24-27
        pub type IPRIOR6_R = crate::FieldReader<u32, u32>;
        ///Field `IPRIOR6` writer - >RW,Interrupt priority for number 24-27
        pub type IPRIOR6_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, PFIC_IPRIOR6_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - >RW,Interrupt priority for number 24-27
            #[inline(always)]
            pub fn iprior6(&self) -> IPRIOR6_R {
                IPRIOR6_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - >RW,Interrupt priority for number 24-27
            #[inline(always)]
            #[must_use]
            pub fn iprior6(&mut self) -> IPRIOR6_W<0> {
                IPRIOR6_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 6
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [pfic_iprior6](index.html) module
        pub struct PFIC_IPRIOR6_SPEC;
        impl crate::RegisterSpec for PFIC_IPRIOR6_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [pfic_iprior6::R](R) reader structure
        impl crate::Readable for PFIC_IPRIOR6_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [pfic_iprior6::W](W) writer structure
        impl crate::Writable for PFIC_IPRIOR6_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets PFIC_IPRIOR6 to value 0
        impl crate::Resettable for PFIC_IPRIOR6_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///PFIC_IPRIOR7 (rw) register accessor: an alias for `Reg<PFIC_IPRIOR7_SPEC>`
    pub type PFIC_IPRIOR7 = crate::Reg<pfic_iprior7::PFIC_IPRIOR7_SPEC>;
    ///Interrupt Priority configuration Register 7
    pub mod pfic_iprior7 {
        ///Register `PFIC_IPRIOR7` reader
        pub struct R(crate::R<PFIC_IPRIOR7_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PFIC_IPRIOR7_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<PFIC_IPRIOR7_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<PFIC_IPRIOR7_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `PFIC_IPRIOR7` writer
        pub struct W(crate::W<PFIC_IPRIOR7_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PFIC_IPRIOR7_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<PFIC_IPRIOR7_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<PFIC_IPRIOR7_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR7` reader - >RW,Interrupt priority for number 28-31
        pub type IPRIOR7_R = crate::FieldReader<u32, u32>;
        ///Field `IPRIOR7` writer - >RW,Interrupt priority for number 28-31
        pub type IPRIOR7_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, PFIC_IPRIOR7_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - >RW,Interrupt priority for number 28-31
            #[inline(always)]
            pub fn iprior7(&self) -> IPRIOR7_R {
                IPRIOR7_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - >RW,Interrupt priority for number 28-31
            #[inline(always)]
            #[must_use]
            pub fn iprior7(&mut self) -> IPRIOR7_W<0> {
                IPRIOR7_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 7
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [pfic_iprior7](index.html) module
        pub struct PFIC_IPRIOR7_SPEC;
        impl crate::RegisterSpec for PFIC_IPRIOR7_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [pfic_iprior7::R](R) reader structure
        impl crate::Readable for PFIC_IPRIOR7_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [pfic_iprior7::W](W) writer structure
        impl crate::Writable for PFIC_IPRIOR7_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets PFIC_IPRIOR7 to value 0
        impl crate::Resettable for PFIC_IPRIOR7_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///PFIC_IPRIOR8 (rw) register accessor: an alias for `Reg<PFIC_IPRIOR8_SPEC>`
    pub type PFIC_IPRIOR8 = crate::Reg<pfic_iprior8::PFIC_IPRIOR8_SPEC>;
    ///Interrupt Priority configuration Register 8
    pub mod pfic_iprior8 {
        ///Register `PFIC_IPRIOR8` reader
        pub struct R(crate::R<PFIC_IPRIOR8_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PFIC_IPRIOR8_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<PFIC_IPRIOR8_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<PFIC_IPRIOR8_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `PFIC_IPRIOR8` writer
        pub struct W(crate::W<PFIC_IPRIOR8_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PFIC_IPRIOR8_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<PFIC_IPRIOR8_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<PFIC_IPRIOR8_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR8` reader - >RW,Interrupt priority for number 32-35
        pub type IPRIOR8_R = crate::FieldReader<u32, u32>;
        ///Field `IPRIOR8` writer - >RW,Interrupt priority for number 32-35
        pub type IPRIOR8_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, PFIC_IPRIOR8_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - >RW,Interrupt priority for number 32-35
            #[inline(always)]
            pub fn iprior8(&self) -> IPRIOR8_R {
                IPRIOR8_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - >RW,Interrupt priority for number 32-35
            #[inline(always)]
            #[must_use]
            pub fn iprior8(&mut self) -> IPRIOR8_W<0> {
                IPRIOR8_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 8
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [pfic_iprior8](index.html) module
        pub struct PFIC_IPRIOR8_SPEC;
        impl crate::RegisterSpec for PFIC_IPRIOR8_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [pfic_iprior8::R](R) reader structure
        impl crate::Readable for PFIC_IPRIOR8_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [pfic_iprior8::W](W) writer structure
        impl crate::Writable for PFIC_IPRIOR8_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets PFIC_IPRIOR8 to value 0
        impl crate::Resettable for PFIC_IPRIOR8_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///PFIC_IPRIOR9 (rw) register accessor: an alias for `Reg<PFIC_IPRIOR9_SPEC>`
    pub type PFIC_IPRIOR9 = crate::Reg<pfic_iprior9::PFIC_IPRIOR9_SPEC>;
    ///Interrupt Priority configuration Register 9
    pub mod pfic_iprior9 {
        ///Register `PFIC_IPRIOR9` reader
        pub struct R(crate::R<PFIC_IPRIOR9_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PFIC_IPRIOR9_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<PFIC_IPRIOR9_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<PFIC_IPRIOR9_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `PFIC_IPRIOR9` writer
        pub struct W(crate::W<PFIC_IPRIOR9_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PFIC_IPRIOR9_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<PFIC_IPRIOR9_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<PFIC_IPRIOR9_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR9` reader - >RW,Interrupt priority for number 36-39
        pub type IPRIOR9_R = crate::FieldReader<u32, u32>;
        ///Field `IPRIOR9` writer - >RW,Interrupt priority for number 36-39
        pub type IPRIOR9_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, PFIC_IPRIOR9_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - >RW,Interrupt priority for number 36-39
            #[inline(always)]
            pub fn iprior9(&self) -> IPRIOR9_R {
                IPRIOR9_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - >RW,Interrupt priority for number 36-39
            #[inline(always)]
            #[must_use]
            pub fn iprior9(&mut self) -> IPRIOR9_W<0> {
                IPRIOR9_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 9
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [pfic_iprior9](index.html) module
        pub struct PFIC_IPRIOR9_SPEC;
        impl crate::RegisterSpec for PFIC_IPRIOR9_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [pfic_iprior9::R](R) reader structure
        impl crate::Readable for PFIC_IPRIOR9_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [pfic_iprior9::W](W) writer structure
        impl crate::Writable for PFIC_IPRIOR9_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets PFIC_IPRIOR9 to value 0
        impl crate::Resettable for PFIC_IPRIOR9_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///PFIC_IPRIOR10 (rw) register accessor: an alias for `Reg<PFIC_IPRIOR10_SPEC>`
    pub type PFIC_IPRIOR10 = crate::Reg<pfic_iprior10::PFIC_IPRIOR10_SPEC>;
    ///Interrupt Priority configuration Register 10
    pub mod pfic_iprior10 {
        ///Register `PFIC_IPRIOR10` reader
        pub struct R(crate::R<PFIC_IPRIOR10_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PFIC_IPRIOR10_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<PFIC_IPRIOR10_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<PFIC_IPRIOR10_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `PFIC_IPRIOR10` writer
        pub struct W(crate::W<PFIC_IPRIOR10_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PFIC_IPRIOR10_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<PFIC_IPRIOR10_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<PFIC_IPRIOR10_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR10` reader - >RW,Interrupt priority for number 40-43
        pub type IPRIOR10_R = crate::FieldReader<u32, u32>;
        ///Field `IPRIOR10` writer - >RW,Interrupt priority for number 40-43
        pub type IPRIOR10_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, PFIC_IPRIOR10_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - >RW,Interrupt priority for number 40-43
            #[inline(always)]
            pub fn iprior10(&self) -> IPRIOR10_R {
                IPRIOR10_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - >RW,Interrupt priority for number 40-43
            #[inline(always)]
            #[must_use]
            pub fn iprior10(&mut self) -> IPRIOR10_W<0> {
                IPRIOR10_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 10
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [pfic_iprior10](index.html) module
        pub struct PFIC_IPRIOR10_SPEC;
        impl crate::RegisterSpec for PFIC_IPRIOR10_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [pfic_iprior10::R](R) reader structure
        impl crate::Readable for PFIC_IPRIOR10_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [pfic_iprior10::W](W) writer structure
        impl crate::Writable for PFIC_IPRIOR10_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets PFIC_IPRIOR10 to value 0
        impl crate::Resettable for PFIC_IPRIOR10_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///PFIC_IPRIOR11 (rw) register accessor: an alias for `Reg<PFIC_IPRIOR11_SPEC>`
    pub type PFIC_IPRIOR11 = crate::Reg<pfic_iprior11::PFIC_IPRIOR11_SPEC>;
    ///Interrupt Priority configuration Register 11
    pub mod pfic_iprior11 {
        ///Register `PFIC_IPRIOR11` reader
        pub struct R(crate::R<PFIC_IPRIOR11_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PFIC_IPRIOR11_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<PFIC_IPRIOR11_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<PFIC_IPRIOR11_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `PFIC_IPRIOR11` writer
        pub struct W(crate::W<PFIC_IPRIOR11_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PFIC_IPRIOR11_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<PFIC_IPRIOR11_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<PFIC_IPRIOR11_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR11` reader - RW,Interrupt priority for number 44-47
        pub type IPRIOR11_R = crate::FieldReader<u32, u32>;
        ///Field `IPRIOR11` writer - RW,Interrupt priority for number 44-47
        pub type IPRIOR11_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, PFIC_IPRIOR11_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 44-47
            #[inline(always)]
            pub fn iprior11(&self) -> IPRIOR11_R {
                IPRIOR11_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 44-47
            #[inline(always)]
            #[must_use]
            pub fn iprior11(&mut self) -> IPRIOR11_W<0> {
                IPRIOR11_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 11
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [pfic_iprior11](index.html) module
        pub struct PFIC_IPRIOR11_SPEC;
        impl crate::RegisterSpec for PFIC_IPRIOR11_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [pfic_iprior11::R](R) reader structure
        impl crate::Readable for PFIC_IPRIOR11_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [pfic_iprior11::W](W) writer structure
        impl crate::Writable for PFIC_IPRIOR11_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets PFIC_IPRIOR11 to value 0
        impl crate::Resettable for PFIC_IPRIOR11_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///PFIC_IPRIOR12 (rw) register accessor: an alias for `Reg<PFIC_IPRIOR12_SPEC>`
    pub type PFIC_IPRIOR12 = crate::Reg<pfic_iprior12::PFIC_IPRIOR12_SPEC>;
    ///Interrupt Priority configuration Register 12
    pub mod pfic_iprior12 {
        ///Register `PFIC_IPRIOR12` reader
        pub struct R(crate::R<PFIC_IPRIOR12_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PFIC_IPRIOR12_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<PFIC_IPRIOR12_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<PFIC_IPRIOR12_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `PFIC_IPRIOR12` writer
        pub struct W(crate::W<PFIC_IPRIOR12_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PFIC_IPRIOR12_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<PFIC_IPRIOR12_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<PFIC_IPRIOR12_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR12` reader - RW,Interrupt priority for number 48-51
        pub type IPRIOR12_R = crate::FieldReader<u32, u32>;
        ///Field `IPRIOR12` writer - RW,Interrupt priority for number 48-51
        pub type IPRIOR12_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, PFIC_IPRIOR12_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 48-51
            #[inline(always)]
            pub fn iprior12(&self) -> IPRIOR12_R {
                IPRIOR12_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 48-51
            #[inline(always)]
            #[must_use]
            pub fn iprior12(&mut self) -> IPRIOR12_W<0> {
                IPRIOR12_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 12
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [pfic_iprior12](index.html) module
        pub struct PFIC_IPRIOR12_SPEC;
        impl crate::RegisterSpec for PFIC_IPRIOR12_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [pfic_iprior12::R](R) reader structure
        impl crate::Readable for PFIC_IPRIOR12_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [pfic_iprior12::W](W) writer structure
        impl crate::Writable for PFIC_IPRIOR12_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets PFIC_IPRIOR12 to value 0
        impl crate::Resettable for PFIC_IPRIOR12_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///PFIC_IPRIOR13 (rw) register accessor: an alias for `Reg<PFIC_IPRIOR13_SPEC>`
    pub type PFIC_IPRIOR13 = crate::Reg<pfic_iprior13::PFIC_IPRIOR13_SPEC>;
    ///Interrupt Priority configuration Register 13
    pub mod pfic_iprior13 {
        ///Register `PFIC_IPRIOR13` reader
        pub struct R(crate::R<PFIC_IPRIOR13_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PFIC_IPRIOR13_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<PFIC_IPRIOR13_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<PFIC_IPRIOR13_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `PFIC_IPRIOR13` writer
        pub struct W(crate::W<PFIC_IPRIOR13_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PFIC_IPRIOR13_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<PFIC_IPRIOR13_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<PFIC_IPRIOR13_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR13` reader - RW,Interrupt priority for number 52-55
        pub type IPRIOR13_R = crate::FieldReader<u32, u32>;
        ///Field `IPRIOR13` writer - RW,Interrupt priority for number 52-55
        pub type IPRIOR13_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, PFIC_IPRIOR13_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 52-55
            #[inline(always)]
            pub fn iprior13(&self) -> IPRIOR13_R {
                IPRIOR13_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 52-55
            #[inline(always)]
            #[must_use]
            pub fn iprior13(&mut self) -> IPRIOR13_W<0> {
                IPRIOR13_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 13
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [pfic_iprior13](index.html) module
        pub struct PFIC_IPRIOR13_SPEC;
        impl crate::RegisterSpec for PFIC_IPRIOR13_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [pfic_iprior13::R](R) reader structure
        impl crate::Readable for PFIC_IPRIOR13_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [pfic_iprior13::W](W) writer structure
        impl crate::Writable for PFIC_IPRIOR13_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets PFIC_IPRIOR13 to value 0
        impl crate::Resettable for PFIC_IPRIOR13_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///PFIC_IPRIOR14 (rw) register accessor: an alias for `Reg<PFIC_IPRIOR14_SPEC>`
    pub type PFIC_IPRIOR14 = crate::Reg<pfic_iprior14::PFIC_IPRIOR14_SPEC>;
    ///Interrupt Priority configuration Register 14
    pub mod pfic_iprior14 {
        ///Register `PFIC_IPRIOR14` reader
        pub struct R(crate::R<PFIC_IPRIOR14_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PFIC_IPRIOR14_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<PFIC_IPRIOR14_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<PFIC_IPRIOR14_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `PFIC_IPRIOR14` writer
        pub struct W(crate::W<PFIC_IPRIOR14_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PFIC_IPRIOR14_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<PFIC_IPRIOR14_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<PFIC_IPRIOR14_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR14` reader - RW,Interrupt priority for number 56-59
        pub type IPRIOR14_R = crate::FieldReader<u32, u32>;
        ///Field `IPRIOR14` writer - RW,Interrupt priority for number 56-59
        pub type IPRIOR14_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, PFIC_IPRIOR14_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 56-59
            #[inline(always)]
            pub fn iprior14(&self) -> IPRIOR14_R {
                IPRIOR14_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 56-59
            #[inline(always)]
            #[must_use]
            pub fn iprior14(&mut self) -> IPRIOR14_W<0> {
                IPRIOR14_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 14
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [pfic_iprior14](index.html) module
        pub struct PFIC_IPRIOR14_SPEC;
        impl crate::RegisterSpec for PFIC_IPRIOR14_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [pfic_iprior14::R](R) reader structure
        impl crate::Readable for PFIC_IPRIOR14_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [pfic_iprior14::W](W) writer structure
        impl crate::Writable for PFIC_IPRIOR14_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets PFIC_IPRIOR14 to value 0
        impl crate::Resettable for PFIC_IPRIOR14_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///PFIC_IPRIOR15 (rw) register accessor: an alias for `Reg<PFIC_IPRIOR15_SPEC>`
    pub type PFIC_IPRIOR15 = crate::Reg<pfic_iprior15::PFIC_IPRIOR15_SPEC>;
    ///Interrupt Priority configuration Register 15
    pub mod pfic_iprior15 {
        ///Register `PFIC_IPRIOR15` reader
        pub struct R(crate::R<PFIC_IPRIOR15_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PFIC_IPRIOR15_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<PFIC_IPRIOR15_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<PFIC_IPRIOR15_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `PFIC_IPRIOR15` writer
        pub struct W(crate::W<PFIC_IPRIOR15_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PFIC_IPRIOR15_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<PFIC_IPRIOR15_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<PFIC_IPRIOR15_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR15` reader - RW,Interrupt priority for number 60-63
        pub type IPRIOR15_R = crate::FieldReader<u32, u32>;
        ///Field `IPRIOR15` writer - RW,Interrupt priority for number 60-63
        pub type IPRIOR15_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, PFIC_IPRIOR15_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 60-63
            #[inline(always)]
            pub fn iprior15(&self) -> IPRIOR15_R {
                IPRIOR15_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 60-63
            #[inline(always)]
            #[must_use]
            pub fn iprior15(&mut self) -> IPRIOR15_W<0> {
                IPRIOR15_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 15
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [pfic_iprior15](index.html) module
        pub struct PFIC_IPRIOR15_SPEC;
        impl crate::RegisterSpec for PFIC_IPRIOR15_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [pfic_iprior15::R](R) reader structure
        impl crate::Readable for PFIC_IPRIOR15_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [pfic_iprior15::W](W) writer structure
        impl crate::Writable for PFIC_IPRIOR15_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets PFIC_IPRIOR15 to value 0
        impl crate::Resettable for PFIC_IPRIOR15_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///PFIC_IPRIOR16 (rw) register accessor: an alias for `Reg<PFIC_IPRIOR16_SPEC>`
    pub type PFIC_IPRIOR16 = crate::Reg<pfic_iprior16::PFIC_IPRIOR16_SPEC>;
    ///Interrupt Priority configuration Register 16
    pub mod pfic_iprior16 {
        ///Register `PFIC_IPRIOR16` reader
        pub struct R(crate::R<PFIC_IPRIOR16_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PFIC_IPRIOR16_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<PFIC_IPRIOR16_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<PFIC_IPRIOR16_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `PFIC_IPRIOR16` writer
        pub struct W(crate::W<PFIC_IPRIOR16_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PFIC_IPRIOR16_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<PFIC_IPRIOR16_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<PFIC_IPRIOR16_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR16` reader - RW,Interrupt priority for number 64-67
        pub type IPRIOR16_R = crate::FieldReader<u32, u32>;
        ///Field `IPRIOR16` writer - RW,Interrupt priority for number 64-67
        pub type IPRIOR16_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, PFIC_IPRIOR16_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 64-67
            #[inline(always)]
            pub fn iprior16(&self) -> IPRIOR16_R {
                IPRIOR16_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 64-67
            #[inline(always)]
            #[must_use]
            pub fn iprior16(&mut self) -> IPRIOR16_W<0> {
                IPRIOR16_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 16
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [pfic_iprior16](index.html) module
        pub struct PFIC_IPRIOR16_SPEC;
        impl crate::RegisterSpec for PFIC_IPRIOR16_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [pfic_iprior16::R](R) reader structure
        impl crate::Readable for PFIC_IPRIOR16_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [pfic_iprior16::W](W) writer structure
        impl crate::Writable for PFIC_IPRIOR16_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets PFIC_IPRIOR16 to value 0
        impl crate::Resettable for PFIC_IPRIOR16_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///PFIC_IPRIOR17 (rw) register accessor: an alias for `Reg<PFIC_IPRIOR17_SPEC>`
    pub type PFIC_IPRIOR17 = crate::Reg<pfic_iprior17::PFIC_IPRIOR17_SPEC>;
    ///Interrupt Priority configuration Register 17
    pub mod pfic_iprior17 {
        ///Register `PFIC_IPRIOR17` reader
        pub struct R(crate::R<PFIC_IPRIOR17_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PFIC_IPRIOR17_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<PFIC_IPRIOR17_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<PFIC_IPRIOR17_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `PFIC_IPRIOR17` writer
        pub struct W(crate::W<PFIC_IPRIOR17_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PFIC_IPRIOR17_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<PFIC_IPRIOR17_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<PFIC_IPRIOR17_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR17` reader - RW,Interrupt priority for number 68-71
        pub type IPRIOR17_R = crate::FieldReader<u32, u32>;
        ///Field `IPRIOR17` writer - RW,Interrupt priority for number 68-71
        pub type IPRIOR17_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, PFIC_IPRIOR17_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 68-71
            #[inline(always)]
            pub fn iprior17(&self) -> IPRIOR17_R {
                IPRIOR17_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 68-71
            #[inline(always)]
            #[must_use]
            pub fn iprior17(&mut self) -> IPRIOR17_W<0> {
                IPRIOR17_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 17
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [pfic_iprior17](index.html) module
        pub struct PFIC_IPRIOR17_SPEC;
        impl crate::RegisterSpec for PFIC_IPRIOR17_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [pfic_iprior17::R](R) reader structure
        impl crate::Readable for PFIC_IPRIOR17_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [pfic_iprior17::W](W) writer structure
        impl crate::Writable for PFIC_IPRIOR17_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets PFIC_IPRIOR17 to value 0
        impl crate::Resettable for PFIC_IPRIOR17_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///PFIC_IPRIOR18 (rw) register accessor: an alias for `Reg<PFIC_IPRIOR18_SPEC>`
    pub type PFIC_IPRIOR18 = crate::Reg<pfic_iprior18::PFIC_IPRIOR18_SPEC>;
    ///Interrupt Priority configuration Register 18
    pub mod pfic_iprior18 {
        ///Register `PFIC_IPRIOR18` reader
        pub struct R(crate::R<PFIC_IPRIOR18_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PFIC_IPRIOR18_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<PFIC_IPRIOR18_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<PFIC_IPRIOR18_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `PFIC_IPRIOR18` writer
        pub struct W(crate::W<PFIC_IPRIOR18_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PFIC_IPRIOR18_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<PFIC_IPRIOR18_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<PFIC_IPRIOR18_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR18` reader - RW,Interrupt priority for number 72-75
        pub type IPRIOR18_R = crate::FieldReader<u32, u32>;
        ///Field `IPRIOR18` writer - RW,Interrupt priority for number 72-75
        pub type IPRIOR18_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, PFIC_IPRIOR18_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 72-75
            #[inline(always)]
            pub fn iprior18(&self) -> IPRIOR18_R {
                IPRIOR18_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 72-75
            #[inline(always)]
            #[must_use]
            pub fn iprior18(&mut self) -> IPRIOR18_W<0> {
                IPRIOR18_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 18
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [pfic_iprior18](index.html) module
        pub struct PFIC_IPRIOR18_SPEC;
        impl crate::RegisterSpec for PFIC_IPRIOR18_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [pfic_iprior18::R](R) reader structure
        impl crate::Readable for PFIC_IPRIOR18_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [pfic_iprior18::W](W) writer structure
        impl crate::Writable for PFIC_IPRIOR18_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets PFIC_IPRIOR18 to value 0
        impl crate::Resettable for PFIC_IPRIOR18_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///PFIC_IPRIOR19 (rw) register accessor: an alias for `Reg<PFIC_IPRIOR19_SPEC>`
    pub type PFIC_IPRIOR19 = crate::Reg<pfic_iprior19::PFIC_IPRIOR19_SPEC>;
    ///Interrupt Priority configuration Register 19
    pub mod pfic_iprior19 {
        ///Register `PFIC_IPRIOR19` reader
        pub struct R(crate::R<PFIC_IPRIOR19_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PFIC_IPRIOR19_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<PFIC_IPRIOR19_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<PFIC_IPRIOR19_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `PFIC_IPRIOR19` writer
        pub struct W(crate::W<PFIC_IPRIOR19_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PFIC_IPRIOR19_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<PFIC_IPRIOR19_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<PFIC_IPRIOR19_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR19` reader - RW,Interrupt priority for number 76-79
        pub type IPRIOR19_R = crate::FieldReader<u32, u32>;
        ///Field `IPRIOR19` writer - RW,Interrupt priority for number 76-79
        pub type IPRIOR19_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, PFIC_IPRIOR19_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 76-79
            #[inline(always)]
            pub fn iprior19(&self) -> IPRIOR19_R {
                IPRIOR19_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 76-79
            #[inline(always)]
            #[must_use]
            pub fn iprior19(&mut self) -> IPRIOR19_W<0> {
                IPRIOR19_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 19
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [pfic_iprior19](index.html) module
        pub struct PFIC_IPRIOR19_SPEC;
        impl crate::RegisterSpec for PFIC_IPRIOR19_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [pfic_iprior19::R](R) reader structure
        impl crate::Readable for PFIC_IPRIOR19_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [pfic_iprior19::W](W) writer structure
        impl crate::Writable for PFIC_IPRIOR19_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets PFIC_IPRIOR19 to value 0
        impl crate::Resettable for PFIC_IPRIOR19_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///PFIC_IPRIOR20 (rw) register accessor: an alias for `Reg<PFIC_IPRIOR20_SPEC>`
    pub type PFIC_IPRIOR20 = crate::Reg<pfic_iprior20::PFIC_IPRIOR20_SPEC>;
    ///Interrupt Priority configuration Register 20
    pub mod pfic_iprior20 {
        ///Register `PFIC_IPRIOR20` reader
        pub struct R(crate::R<PFIC_IPRIOR20_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PFIC_IPRIOR20_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<PFIC_IPRIOR20_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<PFIC_IPRIOR20_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `PFIC_IPRIOR20` writer
        pub struct W(crate::W<PFIC_IPRIOR20_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PFIC_IPRIOR20_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<PFIC_IPRIOR20_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<PFIC_IPRIOR20_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR20` reader - RW,RW,Interrupt priority for number 80-83
        pub type IPRIOR20_R = crate::FieldReader<u32, u32>;
        ///Field `IPRIOR20` writer - RW,RW,Interrupt priority for number 80-83
        pub type IPRIOR20_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, PFIC_IPRIOR20_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - RW,RW,Interrupt priority for number 80-83
            #[inline(always)]
            pub fn iprior20(&self) -> IPRIOR20_R {
                IPRIOR20_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,RW,Interrupt priority for number 80-83
            #[inline(always)]
            #[must_use]
            pub fn iprior20(&mut self) -> IPRIOR20_W<0> {
                IPRIOR20_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 20
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [pfic_iprior20](index.html) module
        pub struct PFIC_IPRIOR20_SPEC;
        impl crate::RegisterSpec for PFIC_IPRIOR20_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [pfic_iprior20::R](R) reader structure
        impl crate::Readable for PFIC_IPRIOR20_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [pfic_iprior20::W](W) writer structure
        impl crate::Writable for PFIC_IPRIOR20_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets PFIC_IPRIOR20 to value 0
        impl crate::Resettable for PFIC_IPRIOR20_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///PFIC_IPRIOR21 (rw) register accessor: an alias for `Reg<PFIC_IPRIOR21_SPEC>`
    pub type PFIC_IPRIOR21 = crate::Reg<pfic_iprior21::PFIC_IPRIOR21_SPEC>;
    ///Interrupt Priority configuration Register 21
    pub mod pfic_iprior21 {
        ///Register `PFIC_IPRIOR21` reader
        pub struct R(crate::R<PFIC_IPRIOR21_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PFIC_IPRIOR21_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<PFIC_IPRIOR21_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<PFIC_IPRIOR21_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `PFIC_IPRIOR21` writer
        pub struct W(crate::W<PFIC_IPRIOR21_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PFIC_IPRIOR21_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<PFIC_IPRIOR21_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<PFIC_IPRIOR21_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR21` reader - RW,Interrupt priority for number 84-87
        pub type IPRIOR21_R = crate::FieldReader<u32, u32>;
        ///Field `IPRIOR21` writer - RW,Interrupt priority for number 84-87
        pub type IPRIOR21_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, PFIC_IPRIOR21_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 84-87
            #[inline(always)]
            pub fn iprior21(&self) -> IPRIOR21_R {
                IPRIOR21_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 84-87
            #[inline(always)]
            #[must_use]
            pub fn iprior21(&mut self) -> IPRIOR21_W<0> {
                IPRIOR21_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 21
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [pfic_iprior21](index.html) module
        pub struct PFIC_IPRIOR21_SPEC;
        impl crate::RegisterSpec for PFIC_IPRIOR21_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [pfic_iprior21::R](R) reader structure
        impl crate::Readable for PFIC_IPRIOR21_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [pfic_iprior21::W](W) writer structure
        impl crate::Writable for PFIC_IPRIOR21_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets PFIC_IPRIOR21 to value 0
        impl crate::Resettable for PFIC_IPRIOR21_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///PFIC_IPRIOR22 (rw) register accessor: an alias for `Reg<PFIC_IPRIOR22_SPEC>`
    pub type PFIC_IPRIOR22 = crate::Reg<pfic_iprior22::PFIC_IPRIOR22_SPEC>;
    ///Interrupt Priority configuration Register 22
    pub mod pfic_iprior22 {
        ///Register `PFIC_IPRIOR22` reader
        pub struct R(crate::R<PFIC_IPRIOR22_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PFIC_IPRIOR22_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<PFIC_IPRIOR22_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<PFIC_IPRIOR22_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `PFIC_IPRIOR22` writer
        pub struct W(crate::W<PFIC_IPRIOR22_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PFIC_IPRIOR22_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<PFIC_IPRIOR22_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<PFIC_IPRIOR22_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR22` reader - RW,Interrupt priority for number 88-91
        pub type IPRIOR22_R = crate::FieldReader<u32, u32>;
        ///Field `IPRIOR22` writer - RW,Interrupt priority for number 88-91
        pub type IPRIOR22_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, PFIC_IPRIOR22_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 88-91
            #[inline(always)]
            pub fn iprior22(&self) -> IPRIOR22_R {
                IPRIOR22_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 88-91
            #[inline(always)]
            #[must_use]
            pub fn iprior22(&mut self) -> IPRIOR22_W<0> {
                IPRIOR22_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 22
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [pfic_iprior22](index.html) module
        pub struct PFIC_IPRIOR22_SPEC;
        impl crate::RegisterSpec for PFIC_IPRIOR22_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [pfic_iprior22::R](R) reader structure
        impl crate::Readable for PFIC_IPRIOR22_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [pfic_iprior22::W](W) writer structure
        impl crate::Writable for PFIC_IPRIOR22_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets PFIC_IPRIOR22 to value 0
        impl crate::Resettable for PFIC_IPRIOR22_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///PFIC_IPRIOR23 (rw) register accessor: an alias for `Reg<PFIC_IPRIOR23_SPEC>`
    pub type PFIC_IPRIOR23 = crate::Reg<pfic_iprior23::PFIC_IPRIOR23_SPEC>;
    ///Interrupt Priority configuration Register 23
    pub mod pfic_iprior23 {
        ///Register `PFIC_IPRIOR23` reader
        pub struct R(crate::R<PFIC_IPRIOR23_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PFIC_IPRIOR23_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<PFIC_IPRIOR23_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<PFIC_IPRIOR23_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `PFIC_IPRIOR23` writer
        pub struct W(crate::W<PFIC_IPRIOR23_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PFIC_IPRIOR23_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<PFIC_IPRIOR23_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<PFIC_IPRIOR23_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR23` reader - RW,Interrupt priority for number 92-95
        pub type IPRIOR23_R = crate::FieldReader<u32, u32>;
        ///Field `IPRIOR23` writer - RW,Interrupt priority for number 92-95
        pub type IPRIOR23_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, PFIC_IPRIOR23_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 92-95
            #[inline(always)]
            pub fn iprior23(&self) -> IPRIOR23_R {
                IPRIOR23_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 92-95
            #[inline(always)]
            #[must_use]
            pub fn iprior23(&mut self) -> IPRIOR23_W<0> {
                IPRIOR23_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 23
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [pfic_iprior23](index.html) module
        pub struct PFIC_IPRIOR23_SPEC;
        impl crate::RegisterSpec for PFIC_IPRIOR23_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [pfic_iprior23::R](R) reader structure
        impl crate::Readable for PFIC_IPRIOR23_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [pfic_iprior23::W](W) writer structure
        impl crate::Writable for PFIC_IPRIOR23_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets PFIC_IPRIOR23 to value 0
        impl crate::Resettable for PFIC_IPRIOR23_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///PFIC_IPRIOR24 (rw) register accessor: an alias for `Reg<PFIC_IPRIOR24_SPEC>`
    pub type PFIC_IPRIOR24 = crate::Reg<pfic_iprior24::PFIC_IPRIOR24_SPEC>;
    ///Interrupt Priority configuration Register 24
    pub mod pfic_iprior24 {
        ///Register `PFIC_IPRIOR24` reader
        pub struct R(crate::R<PFIC_IPRIOR24_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PFIC_IPRIOR24_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<PFIC_IPRIOR24_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<PFIC_IPRIOR24_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `PFIC_IPRIOR24` writer
        pub struct W(crate::W<PFIC_IPRIOR24_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PFIC_IPRIOR24_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<PFIC_IPRIOR24_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<PFIC_IPRIOR24_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR24` reader - RW,Interrupt priority for number 96-99
        pub type IPRIOR24_R = crate::FieldReader<u32, u32>;
        ///Field `IPRIOR24` writer - RW,Interrupt priority for number 96-99
        pub type IPRIOR24_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, PFIC_IPRIOR24_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 96-99
            #[inline(always)]
            pub fn iprior24(&self) -> IPRIOR24_R {
                IPRIOR24_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 96-99
            #[inline(always)]
            #[must_use]
            pub fn iprior24(&mut self) -> IPRIOR24_W<0> {
                IPRIOR24_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 24
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [pfic_iprior24](index.html) module
        pub struct PFIC_IPRIOR24_SPEC;
        impl crate::RegisterSpec for PFIC_IPRIOR24_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [pfic_iprior24::R](R) reader structure
        impl crate::Readable for PFIC_IPRIOR24_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [pfic_iprior24::W](W) writer structure
        impl crate::Writable for PFIC_IPRIOR24_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets PFIC_IPRIOR24 to value 0
        impl crate::Resettable for PFIC_IPRIOR24_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///PFIC_IPRIOR25 (rw) register accessor: an alias for `Reg<PFIC_IPRIOR25_SPEC>`
    pub type PFIC_IPRIOR25 = crate::Reg<pfic_iprior25::PFIC_IPRIOR25_SPEC>;
    ///Interrupt Priority configuration Register 25
    pub mod pfic_iprior25 {
        ///Register `PFIC_IPRIOR25` reader
        pub struct R(crate::R<PFIC_IPRIOR25_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PFIC_IPRIOR25_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<PFIC_IPRIOR25_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<PFIC_IPRIOR25_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `PFIC_IPRIOR25` writer
        pub struct W(crate::W<PFIC_IPRIOR25_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PFIC_IPRIOR25_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<PFIC_IPRIOR25_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<PFIC_IPRIOR25_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR25` reader - RW,Interrupt priority for number 100-103
        pub type IPRIOR25_R = crate::FieldReader<u32, u32>;
        ///Field `IPRIOR25` writer - RW,Interrupt priority for number 100-103
        pub type IPRIOR25_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, PFIC_IPRIOR25_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 100-103
            #[inline(always)]
            pub fn iprior25(&self) -> IPRIOR25_R {
                IPRIOR25_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 100-103
            #[inline(always)]
            #[must_use]
            pub fn iprior25(&mut self) -> IPRIOR25_W<0> {
                IPRIOR25_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 25
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [pfic_iprior25](index.html) module
        pub struct PFIC_IPRIOR25_SPEC;
        impl crate::RegisterSpec for PFIC_IPRIOR25_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [pfic_iprior25::R](R) reader structure
        impl crate::Readable for PFIC_IPRIOR25_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [pfic_iprior25::W](W) writer structure
        impl crate::Writable for PFIC_IPRIOR25_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets PFIC_IPRIOR25 to value 0
        impl crate::Resettable for PFIC_IPRIOR25_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///PFIC_IPRIOR26 (rw) register accessor: an alias for `Reg<PFIC_IPRIOR26_SPEC>`
    pub type PFIC_IPRIOR26 = crate::Reg<pfic_iprior26::PFIC_IPRIOR26_SPEC>;
    ///Interrupt Priority configuration Register 26
    pub mod pfic_iprior26 {
        ///Register `PFIC_IPRIOR26` reader
        pub struct R(crate::R<PFIC_IPRIOR26_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PFIC_IPRIOR26_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<PFIC_IPRIOR26_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<PFIC_IPRIOR26_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `PFIC_IPRIOR26` writer
        pub struct W(crate::W<PFIC_IPRIOR26_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PFIC_IPRIOR26_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<PFIC_IPRIOR26_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<PFIC_IPRIOR26_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR26` reader - RW,Interrupt priority for number 104-107
        pub type IPRIOR26_R = crate::FieldReader<u32, u32>;
        ///Field `IPRIOR26` writer - RW,Interrupt priority for number 104-107
        pub type IPRIOR26_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, PFIC_IPRIOR26_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 104-107
            #[inline(always)]
            pub fn iprior26(&self) -> IPRIOR26_R {
                IPRIOR26_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 104-107
            #[inline(always)]
            #[must_use]
            pub fn iprior26(&mut self) -> IPRIOR26_W<0> {
                IPRIOR26_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 26
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [pfic_iprior26](index.html) module
        pub struct PFIC_IPRIOR26_SPEC;
        impl crate::RegisterSpec for PFIC_IPRIOR26_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [pfic_iprior26::R](R) reader structure
        impl crate::Readable for PFIC_IPRIOR26_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [pfic_iprior26::W](W) writer structure
        impl crate::Writable for PFIC_IPRIOR26_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets PFIC_IPRIOR26 to value 0
        impl crate::Resettable for PFIC_IPRIOR26_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///PFIC_IPRIOR27 (rw) register accessor: an alias for `Reg<PFIC_IPRIOR27_SPEC>`
    pub type PFIC_IPRIOR27 = crate::Reg<pfic_iprior27::PFIC_IPRIOR27_SPEC>;
    ///Interrupt Priority configuration Register 27
    pub mod pfic_iprior27 {
        ///Register `PFIC_IPRIOR27` reader
        pub struct R(crate::R<PFIC_IPRIOR27_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PFIC_IPRIOR27_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<PFIC_IPRIOR27_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<PFIC_IPRIOR27_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `PFIC_IPRIOR27` writer
        pub struct W(crate::W<PFIC_IPRIOR27_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PFIC_IPRIOR27_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<PFIC_IPRIOR27_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<PFIC_IPRIOR27_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR27` reader - RW,Interrupt priority for number 108-111
        pub type IPRIOR27_R = crate::FieldReader<u32, u32>;
        ///Field `IPRIOR27` writer - RW,Interrupt priority for number 108-111
        pub type IPRIOR27_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, PFIC_IPRIOR27_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 108-111
            #[inline(always)]
            pub fn iprior27(&self) -> IPRIOR27_R {
                IPRIOR27_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 108-111
            #[inline(always)]
            #[must_use]
            pub fn iprior27(&mut self) -> IPRIOR27_W<0> {
                IPRIOR27_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 27
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [pfic_iprior27](index.html) module
        pub struct PFIC_IPRIOR27_SPEC;
        impl crate::RegisterSpec for PFIC_IPRIOR27_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [pfic_iprior27::R](R) reader structure
        impl crate::Readable for PFIC_IPRIOR27_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [pfic_iprior27::W](W) writer structure
        impl crate::Writable for PFIC_IPRIOR27_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets PFIC_IPRIOR27 to value 0
        impl crate::Resettable for PFIC_IPRIOR27_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///PFIC_IPRIOR28 (rw) register accessor: an alias for `Reg<PFIC_IPRIOR28_SPEC>`
    pub type PFIC_IPRIOR28 = crate::Reg<pfic_iprior28::PFIC_IPRIOR28_SPEC>;
    ///Interrupt Priority configuration Register 28
    pub mod pfic_iprior28 {
        ///Register `PFIC_IPRIOR28` reader
        pub struct R(crate::R<PFIC_IPRIOR28_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PFIC_IPRIOR28_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<PFIC_IPRIOR28_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<PFIC_IPRIOR28_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `PFIC_IPRIOR28` writer
        pub struct W(crate::W<PFIC_IPRIOR28_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PFIC_IPRIOR28_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<PFIC_IPRIOR28_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<PFIC_IPRIOR28_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR28` reader - RW,Interrupt priority for number 112-115
        pub type IPRIOR28_R = crate::FieldReader<u32, u32>;
        ///Field `IPRIOR28` writer - RW,Interrupt priority for number 112-115
        pub type IPRIOR28_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, PFIC_IPRIOR28_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 112-115
            #[inline(always)]
            pub fn iprior28(&self) -> IPRIOR28_R {
                IPRIOR28_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 112-115
            #[inline(always)]
            #[must_use]
            pub fn iprior28(&mut self) -> IPRIOR28_W<0> {
                IPRIOR28_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 28
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [pfic_iprior28](index.html) module
        pub struct PFIC_IPRIOR28_SPEC;
        impl crate::RegisterSpec for PFIC_IPRIOR28_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [pfic_iprior28::R](R) reader structure
        impl crate::Readable for PFIC_IPRIOR28_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [pfic_iprior28::W](W) writer structure
        impl crate::Writable for PFIC_IPRIOR28_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets PFIC_IPRIOR28 to value 0
        impl crate::Resettable for PFIC_IPRIOR28_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///PFIC_IPRIOR29 (rw) register accessor: an alias for `Reg<PFIC_IPRIOR29_SPEC>`
    pub type PFIC_IPRIOR29 = crate::Reg<pfic_iprior29::PFIC_IPRIOR29_SPEC>;
    ///Interrupt Priority configuration Register 29
    pub mod pfic_iprior29 {
        ///Register `PFIC_IPRIOR29` reader
        pub struct R(crate::R<PFIC_IPRIOR29_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PFIC_IPRIOR29_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<PFIC_IPRIOR29_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<PFIC_IPRIOR29_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `PFIC_IPRIOR29` writer
        pub struct W(crate::W<PFIC_IPRIOR29_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PFIC_IPRIOR29_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<PFIC_IPRIOR29_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<PFIC_IPRIOR29_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR29` reader - RW,Interrupt priority for number 116-119
        pub type IPRIOR29_R = crate::FieldReader<u32, u32>;
        ///Field `IPRIOR29` writer - RW,Interrupt priority for number 116-119
        pub type IPRIOR29_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, PFIC_IPRIOR29_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 116-119
            #[inline(always)]
            pub fn iprior29(&self) -> IPRIOR29_R {
                IPRIOR29_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 116-119
            #[inline(always)]
            #[must_use]
            pub fn iprior29(&mut self) -> IPRIOR29_W<0> {
                IPRIOR29_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 29
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [pfic_iprior29](index.html) module
        pub struct PFIC_IPRIOR29_SPEC;
        impl crate::RegisterSpec for PFIC_IPRIOR29_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [pfic_iprior29::R](R) reader structure
        impl crate::Readable for PFIC_IPRIOR29_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [pfic_iprior29::W](W) writer structure
        impl crate::Writable for PFIC_IPRIOR29_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets PFIC_IPRIOR29 to value 0
        impl crate::Resettable for PFIC_IPRIOR29_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///PFIC_IPRIOR30 (rw) register accessor: an alias for `Reg<PFIC_IPRIOR30_SPEC>`
    pub type PFIC_IPRIOR30 = crate::Reg<pfic_iprior30::PFIC_IPRIOR30_SPEC>;
    ///Interrupt Priority configuration Register 30
    pub mod pfic_iprior30 {
        ///Register `PFIC_IPRIOR30` reader
        pub struct R(crate::R<PFIC_IPRIOR30_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PFIC_IPRIOR30_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<PFIC_IPRIOR30_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<PFIC_IPRIOR30_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `PFIC_IPRIOR30` writer
        pub struct W(crate::W<PFIC_IPRIOR30_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PFIC_IPRIOR30_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<PFIC_IPRIOR30_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<PFIC_IPRIOR30_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR30` reader - RW,Interrupt priority for number 120-123
        pub type IPRIOR30_R = crate::FieldReader<u32, u32>;
        ///Field `IPRIOR30` writer - RW,Interrupt priority for number 120-123
        pub type IPRIOR30_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, PFIC_IPRIOR30_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 120-123
            #[inline(always)]
            pub fn iprior30(&self) -> IPRIOR30_R {
                IPRIOR30_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 120-123
            #[inline(always)]
            #[must_use]
            pub fn iprior30(&mut self) -> IPRIOR30_W<0> {
                IPRIOR30_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 30
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [pfic_iprior30](index.html) module
        pub struct PFIC_IPRIOR30_SPEC;
        impl crate::RegisterSpec for PFIC_IPRIOR30_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [pfic_iprior30::R](R) reader structure
        impl crate::Readable for PFIC_IPRIOR30_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [pfic_iprior30::W](W) writer structure
        impl crate::Writable for PFIC_IPRIOR30_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets PFIC_IPRIOR30 to value 0
        impl crate::Resettable for PFIC_IPRIOR30_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///PFIC_IPRIOR31 (rw) register accessor: an alias for `Reg<PFIC_IPRIOR31_SPEC>`
    pub type PFIC_IPRIOR31 = crate::Reg<pfic_iprior31::PFIC_IPRIOR31_SPEC>;
    ///Interrupt Priority configuration Register 31
    pub mod pfic_iprior31 {
        ///Register `PFIC_IPRIOR31` reader
        pub struct R(crate::R<PFIC_IPRIOR31_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PFIC_IPRIOR31_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<PFIC_IPRIOR31_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<PFIC_IPRIOR31_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `PFIC_IPRIOR31` writer
        pub struct W(crate::W<PFIC_IPRIOR31_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PFIC_IPRIOR31_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<PFIC_IPRIOR31_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<PFIC_IPRIOR31_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR31` reader - RW,Interrupt priority for number 124-127
        pub type IPRIOR31_R = crate::FieldReader<u32, u32>;
        ///Field `IPRIOR31` writer - RW,Interrupt priority for number 124-127
        pub type IPRIOR31_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, PFIC_IPRIOR31_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 124-127
            #[inline(always)]
            pub fn iprior31(&self) -> IPRIOR31_R {
                IPRIOR31_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 124-127
            #[inline(always)]
            #[must_use]
            pub fn iprior31(&mut self) -> IPRIOR31_W<0> {
                IPRIOR31_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 31
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [pfic_iprior31](index.html) module
        pub struct PFIC_IPRIOR31_SPEC;
        impl crate::RegisterSpec for PFIC_IPRIOR31_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [pfic_iprior31::R](R) reader structure
        impl crate::Readable for PFIC_IPRIOR31_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [pfic_iprior31::W](W) writer structure
        impl crate::Writable for PFIC_IPRIOR31_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets PFIC_IPRIOR31 to value 0
        impl crate::Resettable for PFIC_IPRIOR31_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///PFIC_IPRIOR32 (rw) register accessor: an alias for `Reg<PFIC_IPRIOR32_SPEC>`
    pub type PFIC_IPRIOR32 = crate::Reg<pfic_iprior32::PFIC_IPRIOR32_SPEC>;
    ///Interrupt Priority configuration Register 32
    pub mod pfic_iprior32 {
        ///Register `PFIC_IPRIOR32` reader
        pub struct R(crate::R<PFIC_IPRIOR32_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PFIC_IPRIOR32_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<PFIC_IPRIOR32_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<PFIC_IPRIOR32_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `PFIC_IPRIOR32` writer
        pub struct W(crate::W<PFIC_IPRIOR32_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PFIC_IPRIOR32_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<PFIC_IPRIOR32_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<PFIC_IPRIOR32_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR32` reader - RW,Interrupt priority for number 128-131
        pub type IPRIOR32_R = crate::FieldReader<u32, u32>;
        ///Field `IPRIOR32` writer - RW,Interrupt priority for number 128-131
        pub type IPRIOR32_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, PFIC_IPRIOR32_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 128-131
            #[inline(always)]
            pub fn iprior32(&self) -> IPRIOR32_R {
                IPRIOR32_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 128-131
            #[inline(always)]
            #[must_use]
            pub fn iprior32(&mut self) -> IPRIOR32_W<0> {
                IPRIOR32_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 32
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [pfic_iprior32](index.html) module
        pub struct PFIC_IPRIOR32_SPEC;
        impl crate::RegisterSpec for PFIC_IPRIOR32_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [pfic_iprior32::R](R) reader structure
        impl crate::Readable for PFIC_IPRIOR32_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [pfic_iprior32::W](W) writer structure
        impl crate::Writable for PFIC_IPRIOR32_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets PFIC_IPRIOR32 to value 0
        impl crate::Resettable for PFIC_IPRIOR32_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///PFIC_IPRIOR33 (rw) register accessor: an alias for `Reg<PFIC_IPRIOR33_SPEC>`
    pub type PFIC_IPRIOR33 = crate::Reg<pfic_iprior33::PFIC_IPRIOR33_SPEC>;
    ///Interrupt Priority configuration Register 33
    pub mod pfic_iprior33 {
        ///Register `PFIC_IPRIOR33` reader
        pub struct R(crate::R<PFIC_IPRIOR33_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PFIC_IPRIOR33_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<PFIC_IPRIOR33_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<PFIC_IPRIOR33_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `PFIC_IPRIOR33` writer
        pub struct W(crate::W<PFIC_IPRIOR33_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PFIC_IPRIOR33_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<PFIC_IPRIOR33_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<PFIC_IPRIOR33_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR33` reader - RW,Interrupt priority for number 132-135
        pub type IPRIOR33_R = crate::FieldReader<u32, u32>;
        ///Field `IPRIOR33` writer - RW,Interrupt priority for number 132-135
        pub type IPRIOR33_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, PFIC_IPRIOR33_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 132-135
            #[inline(always)]
            pub fn iprior33(&self) -> IPRIOR33_R {
                IPRIOR33_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 132-135
            #[inline(always)]
            #[must_use]
            pub fn iprior33(&mut self) -> IPRIOR33_W<0> {
                IPRIOR33_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 33
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [pfic_iprior33](index.html) module
        pub struct PFIC_IPRIOR33_SPEC;
        impl crate::RegisterSpec for PFIC_IPRIOR33_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [pfic_iprior33::R](R) reader structure
        impl crate::Readable for PFIC_IPRIOR33_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [pfic_iprior33::W](W) writer structure
        impl crate::Writable for PFIC_IPRIOR33_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets PFIC_IPRIOR33 to value 0
        impl crate::Resettable for PFIC_IPRIOR33_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///PFIC_IPRIOR34 (rw) register accessor: an alias for `Reg<PFIC_IPRIOR34_SPEC>`
    pub type PFIC_IPRIOR34 = crate::Reg<pfic_iprior34::PFIC_IPRIOR34_SPEC>;
    ///Interrupt Priority configuration Register 34
    pub mod pfic_iprior34 {
        ///Register `PFIC_IPRIOR34` reader
        pub struct R(crate::R<PFIC_IPRIOR34_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PFIC_IPRIOR34_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<PFIC_IPRIOR34_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<PFIC_IPRIOR34_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `PFIC_IPRIOR34` writer
        pub struct W(crate::W<PFIC_IPRIOR34_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PFIC_IPRIOR34_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<PFIC_IPRIOR34_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<PFIC_IPRIOR34_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR34` reader - RW,Interrupt priority for number 136-139
        pub type IPRIOR34_R = crate::FieldReader<u32, u32>;
        ///Field `IPRIOR34` writer - RW,Interrupt priority for number 136-139
        pub type IPRIOR34_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, PFIC_IPRIOR34_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 136-139
            #[inline(always)]
            pub fn iprior34(&self) -> IPRIOR34_R {
                IPRIOR34_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 136-139
            #[inline(always)]
            #[must_use]
            pub fn iprior34(&mut self) -> IPRIOR34_W<0> {
                IPRIOR34_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 34
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [pfic_iprior34](index.html) module
        pub struct PFIC_IPRIOR34_SPEC;
        impl crate::RegisterSpec for PFIC_IPRIOR34_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [pfic_iprior34::R](R) reader structure
        impl crate::Readable for PFIC_IPRIOR34_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [pfic_iprior34::W](W) writer structure
        impl crate::Writable for PFIC_IPRIOR34_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets PFIC_IPRIOR34 to value 0
        impl crate::Resettable for PFIC_IPRIOR34_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///PFIC_IPRIOR35 (rw) register accessor: an alias for `Reg<PFIC_IPRIOR35_SPEC>`
    pub type PFIC_IPRIOR35 = crate::Reg<pfic_iprior35::PFIC_IPRIOR35_SPEC>;
    ///Interrupt Priority configuration Register 35
    pub mod pfic_iprior35 {
        ///Register `PFIC_IPRIOR35` reader
        pub struct R(crate::R<PFIC_IPRIOR35_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PFIC_IPRIOR35_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<PFIC_IPRIOR35_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<PFIC_IPRIOR35_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `PFIC_IPRIOR35` writer
        pub struct W(crate::W<PFIC_IPRIOR35_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PFIC_IPRIOR35_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<PFIC_IPRIOR35_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<PFIC_IPRIOR35_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR35` reader - RW,Interrupt priority for number 140-143
        pub type IPRIOR35_R = crate::FieldReader<u32, u32>;
        ///Field `IPRIOR35` writer - RW,Interrupt priority for number 140-143
        pub type IPRIOR35_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, PFIC_IPRIOR35_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 140-143
            #[inline(always)]
            pub fn iprior35(&self) -> IPRIOR35_R {
                IPRIOR35_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 140-143
            #[inline(always)]
            #[must_use]
            pub fn iprior35(&mut self) -> IPRIOR35_W<0> {
                IPRIOR35_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 35
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [pfic_iprior35](index.html) module
        pub struct PFIC_IPRIOR35_SPEC;
        impl crate::RegisterSpec for PFIC_IPRIOR35_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [pfic_iprior35::R](R) reader structure
        impl crate::Readable for PFIC_IPRIOR35_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [pfic_iprior35::W](W) writer structure
        impl crate::Writable for PFIC_IPRIOR35_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets PFIC_IPRIOR35 to value 0
        impl crate::Resettable for PFIC_IPRIOR35_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///PFIC_IPRIOR36 (rw) register accessor: an alias for `Reg<PFIC_IPRIOR36_SPEC>`
    pub type PFIC_IPRIOR36 = crate::Reg<pfic_iprior36::PFIC_IPRIOR36_SPEC>;
    ///Interrupt Priority configuration Register 36
    pub mod pfic_iprior36 {
        ///Register `PFIC_IPRIOR36` reader
        pub struct R(crate::R<PFIC_IPRIOR36_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PFIC_IPRIOR36_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<PFIC_IPRIOR36_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<PFIC_IPRIOR36_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `PFIC_IPRIOR36` writer
        pub struct W(crate::W<PFIC_IPRIOR36_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PFIC_IPRIOR36_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<PFIC_IPRIOR36_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<PFIC_IPRIOR36_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR36` reader - RW,Interrupt priority for number 144-147
        pub type IPRIOR36_R = crate::FieldReader<u32, u32>;
        ///Field `IPRIOR36` writer - RW,Interrupt priority for number 144-147
        pub type IPRIOR36_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, PFIC_IPRIOR36_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 144-147
            #[inline(always)]
            pub fn iprior36(&self) -> IPRIOR36_R {
                IPRIOR36_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 144-147
            #[inline(always)]
            #[must_use]
            pub fn iprior36(&mut self) -> IPRIOR36_W<0> {
                IPRIOR36_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 36
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [pfic_iprior36](index.html) module
        pub struct PFIC_IPRIOR36_SPEC;
        impl crate::RegisterSpec for PFIC_IPRIOR36_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [pfic_iprior36::R](R) reader structure
        impl crate::Readable for PFIC_IPRIOR36_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [pfic_iprior36::W](W) writer structure
        impl crate::Writable for PFIC_IPRIOR36_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets PFIC_IPRIOR36 to value 0
        impl crate::Resettable for PFIC_IPRIOR36_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///PFIC_IPRIOR37 (rw) register accessor: an alias for `Reg<PFIC_IPRIOR37_SPEC>`
    pub type PFIC_IPRIOR37 = crate::Reg<pfic_iprior37::PFIC_IPRIOR37_SPEC>;
    ///Interrupt Priority configuration Register 37
    pub mod pfic_iprior37 {
        ///Register `PFIC_IPRIOR37` reader
        pub struct R(crate::R<PFIC_IPRIOR37_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PFIC_IPRIOR37_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<PFIC_IPRIOR37_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<PFIC_IPRIOR37_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `PFIC_IPRIOR37` writer
        pub struct W(crate::W<PFIC_IPRIOR37_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PFIC_IPRIOR37_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<PFIC_IPRIOR37_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<PFIC_IPRIOR37_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR37` reader - RW,Interrupt priority for number 148-151
        pub type IPRIOR37_R = crate::FieldReader<u32, u32>;
        ///Field `IPRIOR37` writer - RW,Interrupt priority for number 148-151
        pub type IPRIOR37_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, PFIC_IPRIOR37_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 148-151
            #[inline(always)]
            pub fn iprior37(&self) -> IPRIOR37_R {
                IPRIOR37_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 148-151
            #[inline(always)]
            #[must_use]
            pub fn iprior37(&mut self) -> IPRIOR37_W<0> {
                IPRIOR37_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 37
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [pfic_iprior37](index.html) module
        pub struct PFIC_IPRIOR37_SPEC;
        impl crate::RegisterSpec for PFIC_IPRIOR37_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [pfic_iprior37::R](R) reader structure
        impl crate::Readable for PFIC_IPRIOR37_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [pfic_iprior37::W](W) writer structure
        impl crate::Writable for PFIC_IPRIOR37_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets PFIC_IPRIOR37 to value 0
        impl crate::Resettable for PFIC_IPRIOR37_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///PFIC_IPRIOR38 (rw) register accessor: an alias for `Reg<PFIC_IPRIOR38_SPEC>`
    pub type PFIC_IPRIOR38 = crate::Reg<pfic_iprior38::PFIC_IPRIOR38_SPEC>;
    ///Interrupt Priority configuration Register 38
    pub mod pfic_iprior38 {
        ///Register `PFIC_IPRIOR38` reader
        pub struct R(crate::R<PFIC_IPRIOR38_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PFIC_IPRIOR38_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<PFIC_IPRIOR38_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<PFIC_IPRIOR38_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `PFIC_IPRIOR38` writer
        pub struct W(crate::W<PFIC_IPRIOR38_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PFIC_IPRIOR38_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<PFIC_IPRIOR38_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<PFIC_IPRIOR38_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR38` reader - RW,Interrupt priority for number 152-155
        pub type IPRIOR38_R = crate::FieldReader<u32, u32>;
        ///Field `IPRIOR38` writer - RW,Interrupt priority for number 152-155
        pub type IPRIOR38_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, PFIC_IPRIOR38_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 152-155
            #[inline(always)]
            pub fn iprior38(&self) -> IPRIOR38_R {
                IPRIOR38_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 152-155
            #[inline(always)]
            #[must_use]
            pub fn iprior38(&mut self) -> IPRIOR38_W<0> {
                IPRIOR38_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 38
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [pfic_iprior38](index.html) module
        pub struct PFIC_IPRIOR38_SPEC;
        impl crate::RegisterSpec for PFIC_IPRIOR38_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [pfic_iprior38::R](R) reader structure
        impl crate::Readable for PFIC_IPRIOR38_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [pfic_iprior38::W](W) writer structure
        impl crate::Writable for PFIC_IPRIOR38_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets PFIC_IPRIOR38 to value 0
        impl crate::Resettable for PFIC_IPRIOR38_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///PFIC_IPRIOR39 (rw) register accessor: an alias for `Reg<PFIC_IPRIOR39_SPEC>`
    pub type PFIC_IPRIOR39 = crate::Reg<pfic_iprior39::PFIC_IPRIOR39_SPEC>;
    ///Interrupt Priority configuration Register 39
    pub mod pfic_iprior39 {
        ///Register `PFIC_IPRIOR39` reader
        pub struct R(crate::R<PFIC_IPRIOR39_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PFIC_IPRIOR39_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<PFIC_IPRIOR39_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<PFIC_IPRIOR39_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `PFIC_IPRIOR39` writer
        pub struct W(crate::W<PFIC_IPRIOR39_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PFIC_IPRIOR39_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<PFIC_IPRIOR39_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<PFIC_IPRIOR39_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR39` reader - RW,Interrupt priority for number 156-159
        pub type IPRIOR39_R = crate::FieldReader<u32, u32>;
        ///Field `IPRIOR39` writer - RW,Interrupt priority for number 156-159
        pub type IPRIOR39_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, PFIC_IPRIOR39_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 156-159
            #[inline(always)]
            pub fn iprior39(&self) -> IPRIOR39_R {
                IPRIOR39_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 156-159
            #[inline(always)]
            #[must_use]
            pub fn iprior39(&mut self) -> IPRIOR39_W<0> {
                IPRIOR39_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 39
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [pfic_iprior39](index.html) module
        pub struct PFIC_IPRIOR39_SPEC;
        impl crate::RegisterSpec for PFIC_IPRIOR39_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [pfic_iprior39::R](R) reader structure
        impl crate::Readable for PFIC_IPRIOR39_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [pfic_iprior39::W](W) writer structure
        impl crate::Writable for PFIC_IPRIOR39_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets PFIC_IPRIOR39 to value 0
        impl crate::Resettable for PFIC_IPRIOR39_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///PFIC_IPRIOR40 (rw) register accessor: an alias for `Reg<PFIC_IPRIOR40_SPEC>`
    pub type PFIC_IPRIOR40 = crate::Reg<pfic_iprior40::PFIC_IPRIOR40_SPEC>;
    ///Interrupt Priority configuration Register 40
    pub mod pfic_iprior40 {
        ///Register `PFIC_IPRIOR40` reader
        pub struct R(crate::R<PFIC_IPRIOR40_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PFIC_IPRIOR40_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<PFIC_IPRIOR40_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<PFIC_IPRIOR40_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `PFIC_IPRIOR40` writer
        pub struct W(crate::W<PFIC_IPRIOR40_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PFIC_IPRIOR40_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<PFIC_IPRIOR40_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<PFIC_IPRIOR40_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR40` reader - RW,Interrupt priority for number 160-163
        pub type IPRIOR40_R = crate::FieldReader<u32, u32>;
        ///Field `IPRIOR40` writer - RW,Interrupt priority for number 160-163
        pub type IPRIOR40_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, PFIC_IPRIOR40_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 160-163
            #[inline(always)]
            pub fn iprior40(&self) -> IPRIOR40_R {
                IPRIOR40_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 160-163
            #[inline(always)]
            #[must_use]
            pub fn iprior40(&mut self) -> IPRIOR40_W<0> {
                IPRIOR40_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 40
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [pfic_iprior40](index.html) module
        pub struct PFIC_IPRIOR40_SPEC;
        impl crate::RegisterSpec for PFIC_IPRIOR40_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [pfic_iprior40::R](R) reader structure
        impl crate::Readable for PFIC_IPRIOR40_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [pfic_iprior40::W](W) writer structure
        impl crate::Writable for PFIC_IPRIOR40_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets PFIC_IPRIOR40 to value 0
        impl crate::Resettable for PFIC_IPRIOR40_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///PFIC_IPRIOR41 (rw) register accessor: an alias for `Reg<PFIC_IPRIOR41_SPEC>`
    pub type PFIC_IPRIOR41 = crate::Reg<pfic_iprior41::PFIC_IPRIOR41_SPEC>;
    ///Interrupt Priority configuration Register 41
    pub mod pfic_iprior41 {
        ///Register `PFIC_IPRIOR41` reader
        pub struct R(crate::R<PFIC_IPRIOR41_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PFIC_IPRIOR41_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<PFIC_IPRIOR41_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<PFIC_IPRIOR41_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `PFIC_IPRIOR41` writer
        pub struct W(crate::W<PFIC_IPRIOR41_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PFIC_IPRIOR41_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<PFIC_IPRIOR41_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<PFIC_IPRIOR41_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR41` reader - RW,Interrupt priority for number 164-167
        pub type IPRIOR41_R = crate::FieldReader<u32, u32>;
        ///Field `IPRIOR41` writer - RW,Interrupt priority for number 164-167
        pub type IPRIOR41_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, PFIC_IPRIOR41_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 164-167
            #[inline(always)]
            pub fn iprior41(&self) -> IPRIOR41_R {
                IPRIOR41_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 164-167
            #[inline(always)]
            #[must_use]
            pub fn iprior41(&mut self) -> IPRIOR41_W<0> {
                IPRIOR41_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 41
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [pfic_iprior41](index.html) module
        pub struct PFIC_IPRIOR41_SPEC;
        impl crate::RegisterSpec for PFIC_IPRIOR41_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [pfic_iprior41::R](R) reader structure
        impl crate::Readable for PFIC_IPRIOR41_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [pfic_iprior41::W](W) writer structure
        impl crate::Writable for PFIC_IPRIOR41_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets PFIC_IPRIOR41 to value 0
        impl crate::Resettable for PFIC_IPRIOR41_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///PFIC_IPRIOR42 (rw) register accessor: an alias for `Reg<PFIC_IPRIOR42_SPEC>`
    pub type PFIC_IPRIOR42 = crate::Reg<pfic_iprior42::PFIC_IPRIOR42_SPEC>;
    ///Interrupt Priority configuration Register 42
    pub mod pfic_iprior42 {
        ///Register `PFIC_IPRIOR42` reader
        pub struct R(crate::R<PFIC_IPRIOR42_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PFIC_IPRIOR42_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<PFIC_IPRIOR42_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<PFIC_IPRIOR42_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `PFIC_IPRIOR42` writer
        pub struct W(crate::W<PFIC_IPRIOR42_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PFIC_IPRIOR42_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<PFIC_IPRIOR42_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<PFIC_IPRIOR42_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR42` reader - RW,Interrupt priority for number 168-171
        pub type IPRIOR42_R = crate::FieldReader<u32, u32>;
        ///Field `IPRIOR42` writer - RW,Interrupt priority for number 168-171
        pub type IPRIOR42_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, PFIC_IPRIOR42_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 168-171
            #[inline(always)]
            pub fn iprior42(&self) -> IPRIOR42_R {
                IPRIOR42_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 168-171
            #[inline(always)]
            #[must_use]
            pub fn iprior42(&mut self) -> IPRIOR42_W<0> {
                IPRIOR42_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 42
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [pfic_iprior42](index.html) module
        pub struct PFIC_IPRIOR42_SPEC;
        impl crate::RegisterSpec for PFIC_IPRIOR42_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [pfic_iprior42::R](R) reader structure
        impl crate::Readable for PFIC_IPRIOR42_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [pfic_iprior42::W](W) writer structure
        impl crate::Writable for PFIC_IPRIOR42_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets PFIC_IPRIOR42 to value 0
        impl crate::Resettable for PFIC_IPRIOR42_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///PFIC_IPRIOR43 (rw) register accessor: an alias for `Reg<PFIC_IPRIOR43_SPEC>`
    pub type PFIC_IPRIOR43 = crate::Reg<pfic_iprior43::PFIC_IPRIOR43_SPEC>;
    ///Interrupt Priority configuration Register 43
    pub mod pfic_iprior43 {
        ///Register `PFIC_IPRIOR43` reader
        pub struct R(crate::R<PFIC_IPRIOR43_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PFIC_IPRIOR43_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<PFIC_IPRIOR43_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<PFIC_IPRIOR43_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `PFIC_IPRIOR43` writer
        pub struct W(crate::W<PFIC_IPRIOR43_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PFIC_IPRIOR43_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<PFIC_IPRIOR43_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<PFIC_IPRIOR43_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR43` reader - RW,Interrupt priority for number 172-175
        pub type IPRIOR43_R = crate::FieldReader<u32, u32>;
        ///Field `IPRIOR43` writer - RW,Interrupt priority for number 172-175
        pub type IPRIOR43_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, PFIC_IPRIOR43_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 172-175
            #[inline(always)]
            pub fn iprior43(&self) -> IPRIOR43_R {
                IPRIOR43_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 172-175
            #[inline(always)]
            #[must_use]
            pub fn iprior43(&mut self) -> IPRIOR43_W<0> {
                IPRIOR43_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 43
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [pfic_iprior43](index.html) module
        pub struct PFIC_IPRIOR43_SPEC;
        impl crate::RegisterSpec for PFIC_IPRIOR43_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [pfic_iprior43::R](R) reader structure
        impl crate::Readable for PFIC_IPRIOR43_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [pfic_iprior43::W](W) writer structure
        impl crate::Writable for PFIC_IPRIOR43_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets PFIC_IPRIOR43 to value 0
        impl crate::Resettable for PFIC_IPRIOR43_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///PFIC_IPRIOR44 (rw) register accessor: an alias for `Reg<PFIC_IPRIOR44_SPEC>`
    pub type PFIC_IPRIOR44 = crate::Reg<pfic_iprior44::PFIC_IPRIOR44_SPEC>;
    ///Interrupt Priority configuration Register 44
    pub mod pfic_iprior44 {
        ///Register `PFIC_IPRIOR44` reader
        pub struct R(crate::R<PFIC_IPRIOR44_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PFIC_IPRIOR44_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<PFIC_IPRIOR44_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<PFIC_IPRIOR44_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `PFIC_IPRIOR44` writer
        pub struct W(crate::W<PFIC_IPRIOR44_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PFIC_IPRIOR44_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<PFIC_IPRIOR44_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<PFIC_IPRIOR44_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR44` reader - RW,Interrupt priority for number 176-179
        pub type IPRIOR44_R = crate::FieldReader<u32, u32>;
        ///Field `IPRIOR44` writer - RW,Interrupt priority for number 176-179
        pub type IPRIOR44_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, PFIC_IPRIOR44_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 176-179
            #[inline(always)]
            pub fn iprior44(&self) -> IPRIOR44_R {
                IPRIOR44_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 176-179
            #[inline(always)]
            #[must_use]
            pub fn iprior44(&mut self) -> IPRIOR44_W<0> {
                IPRIOR44_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 44
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [pfic_iprior44](index.html) module
        pub struct PFIC_IPRIOR44_SPEC;
        impl crate::RegisterSpec for PFIC_IPRIOR44_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [pfic_iprior44::R](R) reader structure
        impl crate::Readable for PFIC_IPRIOR44_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [pfic_iprior44::W](W) writer structure
        impl crate::Writable for PFIC_IPRIOR44_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets PFIC_IPRIOR44 to value 0
        impl crate::Resettable for PFIC_IPRIOR44_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///PFIC_IPRIOR45 (rw) register accessor: an alias for `Reg<PFIC_IPRIOR45_SPEC>`
    pub type PFIC_IPRIOR45 = crate::Reg<pfic_iprior45::PFIC_IPRIOR45_SPEC>;
    ///Interrupt Priority configuration Register 45
    pub mod pfic_iprior45 {
        ///Register `PFIC_IPRIOR45` reader
        pub struct R(crate::R<PFIC_IPRIOR45_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PFIC_IPRIOR45_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<PFIC_IPRIOR45_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<PFIC_IPRIOR45_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `PFIC_IPRIOR45` writer
        pub struct W(crate::W<PFIC_IPRIOR45_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PFIC_IPRIOR45_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<PFIC_IPRIOR45_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<PFIC_IPRIOR45_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR45` reader - RW,Interrupt priority for number 180-183
        pub type IPRIOR45_R = crate::FieldReader<u32, u32>;
        ///Field `IPRIOR45` writer - RW,Interrupt priority for number 180-183
        pub type IPRIOR45_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, PFIC_IPRIOR45_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 180-183
            #[inline(always)]
            pub fn iprior45(&self) -> IPRIOR45_R {
                IPRIOR45_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 180-183
            #[inline(always)]
            #[must_use]
            pub fn iprior45(&mut self) -> IPRIOR45_W<0> {
                IPRIOR45_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 45
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [pfic_iprior45](index.html) module
        pub struct PFIC_IPRIOR45_SPEC;
        impl crate::RegisterSpec for PFIC_IPRIOR45_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [pfic_iprior45::R](R) reader structure
        impl crate::Readable for PFIC_IPRIOR45_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [pfic_iprior45::W](W) writer structure
        impl crate::Writable for PFIC_IPRIOR45_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets PFIC_IPRIOR45 to value 0
        impl crate::Resettable for PFIC_IPRIOR45_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///PFIC_IPRIOR46 (rw) register accessor: an alias for `Reg<PFIC_IPRIOR46_SPEC>`
    pub type PFIC_IPRIOR46 = crate::Reg<pfic_iprior46::PFIC_IPRIOR46_SPEC>;
    ///Interrupt Priority configuration Register 46
    pub mod pfic_iprior46 {
        ///Register `PFIC_IPRIOR46` reader
        pub struct R(crate::R<PFIC_IPRIOR46_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PFIC_IPRIOR46_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<PFIC_IPRIOR46_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<PFIC_IPRIOR46_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `PFIC_IPRIOR46` writer
        pub struct W(crate::W<PFIC_IPRIOR46_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PFIC_IPRIOR46_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<PFIC_IPRIOR46_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<PFIC_IPRIOR46_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR46` reader - RW,Interrupt priority for number 184-187
        pub type IPRIOR46_R = crate::FieldReader<u32, u32>;
        ///Field `IPRIOR46` writer - RW,Interrupt priority for number 184-187
        pub type IPRIOR46_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, PFIC_IPRIOR46_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 184-187
            #[inline(always)]
            pub fn iprior46(&self) -> IPRIOR46_R {
                IPRIOR46_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 184-187
            #[inline(always)]
            #[must_use]
            pub fn iprior46(&mut self) -> IPRIOR46_W<0> {
                IPRIOR46_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 46
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [pfic_iprior46](index.html) module
        pub struct PFIC_IPRIOR46_SPEC;
        impl crate::RegisterSpec for PFIC_IPRIOR46_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [pfic_iprior46::R](R) reader structure
        impl crate::Readable for PFIC_IPRIOR46_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [pfic_iprior46::W](W) writer structure
        impl crate::Writable for PFIC_IPRIOR46_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets PFIC_IPRIOR46 to value 0
        impl crate::Resettable for PFIC_IPRIOR46_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///PFIC_IPRIOR47 (rw) register accessor: an alias for `Reg<PFIC_IPRIOR47_SPEC>`
    pub type PFIC_IPRIOR47 = crate::Reg<pfic_iprior47::PFIC_IPRIOR47_SPEC>;
    ///Interrupt Priority configuration Register 47
    pub mod pfic_iprior47 {
        ///Register `PFIC_IPRIOR47` reader
        pub struct R(crate::R<PFIC_IPRIOR47_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PFIC_IPRIOR47_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<PFIC_IPRIOR47_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<PFIC_IPRIOR47_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `PFIC_IPRIOR47` writer
        pub struct W(crate::W<PFIC_IPRIOR47_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PFIC_IPRIOR47_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<PFIC_IPRIOR47_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<PFIC_IPRIOR47_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR47` reader - RW,Interrupt priority for number 188-191
        pub type IPRIOR47_R = crate::FieldReader<u32, u32>;
        ///Field `IPRIOR47` writer - RW,Interrupt priority for number 188-191
        pub type IPRIOR47_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, PFIC_IPRIOR47_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 188-191
            #[inline(always)]
            pub fn iprior47(&self) -> IPRIOR47_R {
                IPRIOR47_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 188-191
            #[inline(always)]
            #[must_use]
            pub fn iprior47(&mut self) -> IPRIOR47_W<0> {
                IPRIOR47_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 47
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [pfic_iprior47](index.html) module
        pub struct PFIC_IPRIOR47_SPEC;
        impl crate::RegisterSpec for PFIC_IPRIOR47_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [pfic_iprior47::R](R) reader structure
        impl crate::Readable for PFIC_IPRIOR47_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [pfic_iprior47::W](W) writer structure
        impl crate::Writable for PFIC_IPRIOR47_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets PFIC_IPRIOR47 to value 0
        impl crate::Resettable for PFIC_IPRIOR47_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///PFIC_IPRIOR48 (rw) register accessor: an alias for `Reg<PFIC_IPRIOR48_SPEC>`
    pub type PFIC_IPRIOR48 = crate::Reg<pfic_iprior48::PFIC_IPRIOR48_SPEC>;
    ///Interrupt Priority configuration Register 48
    pub mod pfic_iprior48 {
        ///Register `PFIC_IPRIOR48` reader
        pub struct R(crate::R<PFIC_IPRIOR48_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PFIC_IPRIOR48_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<PFIC_IPRIOR48_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<PFIC_IPRIOR48_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `PFIC_IPRIOR48` writer
        pub struct W(crate::W<PFIC_IPRIOR48_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PFIC_IPRIOR48_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<PFIC_IPRIOR48_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<PFIC_IPRIOR48_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR48` reader - RW,Interrupt priority for number 192-195
        pub type IPRIOR48_R = crate::FieldReader<u32, u32>;
        ///Field `IPRIOR48` writer - RW,Interrupt priority for number 192-195
        pub type IPRIOR48_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, PFIC_IPRIOR48_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 192-195
            #[inline(always)]
            pub fn iprior48(&self) -> IPRIOR48_R {
                IPRIOR48_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 192-195
            #[inline(always)]
            #[must_use]
            pub fn iprior48(&mut self) -> IPRIOR48_W<0> {
                IPRIOR48_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 48
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [pfic_iprior48](index.html) module
        pub struct PFIC_IPRIOR48_SPEC;
        impl crate::RegisterSpec for PFIC_IPRIOR48_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [pfic_iprior48::R](R) reader structure
        impl crate::Readable for PFIC_IPRIOR48_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [pfic_iprior48::W](W) writer structure
        impl crate::Writable for PFIC_IPRIOR48_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets PFIC_IPRIOR48 to value 0
        impl crate::Resettable for PFIC_IPRIOR48_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///PFIC_IPRIOR49 (rw) register accessor: an alias for `Reg<PFIC_IPRIOR49_SPEC>`
    pub type PFIC_IPRIOR49 = crate::Reg<pfic_iprior49::PFIC_IPRIOR49_SPEC>;
    ///Interrupt Priority configuration Register 49
    pub mod pfic_iprior49 {
        ///Register `PFIC_IPRIOR49` reader
        pub struct R(crate::R<PFIC_IPRIOR49_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PFIC_IPRIOR49_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<PFIC_IPRIOR49_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<PFIC_IPRIOR49_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `PFIC_IPRIOR49` writer
        pub struct W(crate::W<PFIC_IPRIOR49_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PFIC_IPRIOR49_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<PFIC_IPRIOR49_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<PFIC_IPRIOR49_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR49` reader - RW,Interrupt priority for number 196-199
        pub type IPRIOR49_R = crate::FieldReader<u32, u32>;
        ///Field `IPRIOR49` writer - RW,Interrupt priority for number 196-199
        pub type IPRIOR49_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, PFIC_IPRIOR49_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 196-199
            #[inline(always)]
            pub fn iprior49(&self) -> IPRIOR49_R {
                IPRIOR49_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 196-199
            #[inline(always)]
            #[must_use]
            pub fn iprior49(&mut self) -> IPRIOR49_W<0> {
                IPRIOR49_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 49
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [pfic_iprior49](index.html) module
        pub struct PFIC_IPRIOR49_SPEC;
        impl crate::RegisterSpec for PFIC_IPRIOR49_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [pfic_iprior49::R](R) reader structure
        impl crate::Readable for PFIC_IPRIOR49_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [pfic_iprior49::W](W) writer structure
        impl crate::Writable for PFIC_IPRIOR49_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets PFIC_IPRIOR49 to value 0
        impl crate::Resettable for PFIC_IPRIOR49_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///PFIC_IPRIOR50 (rw) register accessor: an alias for `Reg<PFIC_IPRIOR50_SPEC>`
    pub type PFIC_IPRIOR50 = crate::Reg<pfic_iprior50::PFIC_IPRIOR50_SPEC>;
    ///Interrupt Priority configuration Register 50
    pub mod pfic_iprior50 {
        ///Register `PFIC_IPRIOR50` reader
        pub struct R(crate::R<PFIC_IPRIOR50_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PFIC_IPRIOR50_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<PFIC_IPRIOR50_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<PFIC_IPRIOR50_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `PFIC_IPRIOR50` writer
        pub struct W(crate::W<PFIC_IPRIOR50_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PFIC_IPRIOR50_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<PFIC_IPRIOR50_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<PFIC_IPRIOR50_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR50` reader - RW,Interrupt priority for number 200-203
        pub type IPRIOR50_R = crate::FieldReader<u32, u32>;
        ///Field `IPRIOR50` writer - RW,Interrupt priority for number 200-203
        pub type IPRIOR50_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, PFIC_IPRIOR50_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 200-203
            #[inline(always)]
            pub fn iprior50(&self) -> IPRIOR50_R {
                IPRIOR50_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 200-203
            #[inline(always)]
            #[must_use]
            pub fn iprior50(&mut self) -> IPRIOR50_W<0> {
                IPRIOR50_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 50
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [pfic_iprior50](index.html) module
        pub struct PFIC_IPRIOR50_SPEC;
        impl crate::RegisterSpec for PFIC_IPRIOR50_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [pfic_iprior50::R](R) reader structure
        impl crate::Readable for PFIC_IPRIOR50_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [pfic_iprior50::W](W) writer structure
        impl crate::Writable for PFIC_IPRIOR50_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets PFIC_IPRIOR50 to value 0
        impl crate::Resettable for PFIC_IPRIOR50_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///PFIC_IPRIOR51 (rw) register accessor: an alias for `Reg<PFIC_IPRIOR51_SPEC>`
    pub type PFIC_IPRIOR51 = crate::Reg<pfic_iprior51::PFIC_IPRIOR51_SPEC>;
    ///Interrupt Priority configuration Register 51
    pub mod pfic_iprior51 {
        ///Register `PFIC_IPRIOR51` reader
        pub struct R(crate::R<PFIC_IPRIOR51_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PFIC_IPRIOR51_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<PFIC_IPRIOR51_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<PFIC_IPRIOR51_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `PFIC_IPRIOR51` writer
        pub struct W(crate::W<PFIC_IPRIOR51_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PFIC_IPRIOR51_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<PFIC_IPRIOR51_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<PFIC_IPRIOR51_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR51` reader - RW,Interrupt priority for number 204-207
        pub type IPRIOR51_R = crate::FieldReader<u32, u32>;
        ///Field `IPRIOR51` writer - RW,Interrupt priority for number 204-207
        pub type IPRIOR51_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, PFIC_IPRIOR51_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 204-207
            #[inline(always)]
            pub fn iprior51(&self) -> IPRIOR51_R {
                IPRIOR51_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 204-207
            #[inline(always)]
            #[must_use]
            pub fn iprior51(&mut self) -> IPRIOR51_W<0> {
                IPRIOR51_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 51
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [pfic_iprior51](index.html) module
        pub struct PFIC_IPRIOR51_SPEC;
        impl crate::RegisterSpec for PFIC_IPRIOR51_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [pfic_iprior51::R](R) reader structure
        impl crate::Readable for PFIC_IPRIOR51_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [pfic_iprior51::W](W) writer structure
        impl crate::Writable for PFIC_IPRIOR51_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets PFIC_IPRIOR51 to value 0
        impl crate::Resettable for PFIC_IPRIOR51_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///PFIC_IPRIOR52 (rw) register accessor: an alias for `Reg<PFIC_IPRIOR52_SPEC>`
    pub type PFIC_IPRIOR52 = crate::Reg<pfic_iprior52::PFIC_IPRIOR52_SPEC>;
    ///Interrupt Priority configuration Register 52
    pub mod pfic_iprior52 {
        ///Register `PFIC_IPRIOR52` reader
        pub struct R(crate::R<PFIC_IPRIOR52_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PFIC_IPRIOR52_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<PFIC_IPRIOR52_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<PFIC_IPRIOR52_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `PFIC_IPRIOR52` writer
        pub struct W(crate::W<PFIC_IPRIOR52_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PFIC_IPRIOR52_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<PFIC_IPRIOR52_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<PFIC_IPRIOR52_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR52` reader - RW,Interrupt priority for number 208-211
        pub type IPRIOR52_R = crate::FieldReader<u32, u32>;
        ///Field `IPRIOR52` writer - RW,Interrupt priority for number 208-211
        pub type IPRIOR52_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, PFIC_IPRIOR52_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 208-211
            #[inline(always)]
            pub fn iprior52(&self) -> IPRIOR52_R {
                IPRIOR52_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 208-211
            #[inline(always)]
            #[must_use]
            pub fn iprior52(&mut self) -> IPRIOR52_W<0> {
                IPRIOR52_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 52
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [pfic_iprior52](index.html) module
        pub struct PFIC_IPRIOR52_SPEC;
        impl crate::RegisterSpec for PFIC_IPRIOR52_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [pfic_iprior52::R](R) reader structure
        impl crate::Readable for PFIC_IPRIOR52_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [pfic_iprior52::W](W) writer structure
        impl crate::Writable for PFIC_IPRIOR52_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets PFIC_IPRIOR52 to value 0
        impl crate::Resettable for PFIC_IPRIOR52_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///PFIC_IPRIOR53 (rw) register accessor: an alias for `Reg<PFIC_IPRIOR53_SPEC>`
    pub type PFIC_IPRIOR53 = crate::Reg<pfic_iprior53::PFIC_IPRIOR53_SPEC>;
    ///Interrupt Priority configuration Register 53
    pub mod pfic_iprior53 {
        ///Register `PFIC_IPRIOR53` reader
        pub struct R(crate::R<PFIC_IPRIOR53_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PFIC_IPRIOR53_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<PFIC_IPRIOR53_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<PFIC_IPRIOR53_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `PFIC_IPRIOR53` writer
        pub struct W(crate::W<PFIC_IPRIOR53_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PFIC_IPRIOR53_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<PFIC_IPRIOR53_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<PFIC_IPRIOR53_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR53` reader - RW,Interrupt priority for number 212-215
        pub type IPRIOR53_R = crate::FieldReader<u32, u32>;
        ///Field `IPRIOR53` writer - RW,Interrupt priority for number 212-215
        pub type IPRIOR53_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, PFIC_IPRIOR53_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 212-215
            #[inline(always)]
            pub fn iprior53(&self) -> IPRIOR53_R {
                IPRIOR53_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 212-215
            #[inline(always)]
            #[must_use]
            pub fn iprior53(&mut self) -> IPRIOR53_W<0> {
                IPRIOR53_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 53
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [pfic_iprior53](index.html) module
        pub struct PFIC_IPRIOR53_SPEC;
        impl crate::RegisterSpec for PFIC_IPRIOR53_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [pfic_iprior53::R](R) reader structure
        impl crate::Readable for PFIC_IPRIOR53_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [pfic_iprior53::W](W) writer structure
        impl crate::Writable for PFIC_IPRIOR53_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets PFIC_IPRIOR53 to value 0
        impl crate::Resettable for PFIC_IPRIOR53_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///PFIC_IPRIOR54 (rw) register accessor: an alias for `Reg<PFIC_IPRIOR54_SPEC>`
    pub type PFIC_IPRIOR54 = crate::Reg<pfic_iprior54::PFIC_IPRIOR54_SPEC>;
    ///Interrupt Priority configuration Register 54
    pub mod pfic_iprior54 {
        ///Register `PFIC_IPRIOR54` reader
        pub struct R(crate::R<PFIC_IPRIOR54_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PFIC_IPRIOR54_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<PFIC_IPRIOR54_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<PFIC_IPRIOR54_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `PFIC_IPRIOR54` writer
        pub struct W(crate::W<PFIC_IPRIOR54_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PFIC_IPRIOR54_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<PFIC_IPRIOR54_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<PFIC_IPRIOR54_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR54` reader - RW,Interrupt priority for number 216-219
        pub type IPRIOR54_R = crate::FieldReader<u32, u32>;
        ///Field `IPRIOR54` writer - RW,Interrupt priority for number 216-219
        pub type IPRIOR54_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, PFIC_IPRIOR54_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 216-219
            #[inline(always)]
            pub fn iprior54(&self) -> IPRIOR54_R {
                IPRIOR54_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 216-219
            #[inline(always)]
            #[must_use]
            pub fn iprior54(&mut self) -> IPRIOR54_W<0> {
                IPRIOR54_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 54
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [pfic_iprior54](index.html) module
        pub struct PFIC_IPRIOR54_SPEC;
        impl crate::RegisterSpec for PFIC_IPRIOR54_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [pfic_iprior54::R](R) reader structure
        impl crate::Readable for PFIC_IPRIOR54_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [pfic_iprior54::W](W) writer structure
        impl crate::Writable for PFIC_IPRIOR54_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets PFIC_IPRIOR54 to value 0
        impl crate::Resettable for PFIC_IPRIOR54_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///PFIC_IPRIOR55 (rw) register accessor: an alias for `Reg<PFIC_IPRIOR55_SPEC>`
    pub type PFIC_IPRIOR55 = crate::Reg<pfic_iprior55::PFIC_IPRIOR55_SPEC>;
    ///Interrupt Priority configuration Register 55
    pub mod pfic_iprior55 {
        ///Register `PFIC_IPRIOR55` reader
        pub struct R(crate::R<PFIC_IPRIOR55_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PFIC_IPRIOR55_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<PFIC_IPRIOR55_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<PFIC_IPRIOR55_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `PFIC_IPRIOR55` writer
        pub struct W(crate::W<PFIC_IPRIOR55_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PFIC_IPRIOR55_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<PFIC_IPRIOR55_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<PFIC_IPRIOR55_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR55` reader - RW,Interrupt priority for number 220-223
        pub type IPRIOR55_R = crate::FieldReader<u32, u32>;
        ///Field `IPRIOR55` writer - RW,Interrupt priority for number 220-223
        pub type IPRIOR55_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, PFIC_IPRIOR55_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 220-223
            #[inline(always)]
            pub fn iprior55(&self) -> IPRIOR55_R {
                IPRIOR55_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 220-223
            #[inline(always)]
            #[must_use]
            pub fn iprior55(&mut self) -> IPRIOR55_W<0> {
                IPRIOR55_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 55
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [pfic_iprior55](index.html) module
        pub struct PFIC_IPRIOR55_SPEC;
        impl crate::RegisterSpec for PFIC_IPRIOR55_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [pfic_iprior55::R](R) reader structure
        impl crate::Readable for PFIC_IPRIOR55_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [pfic_iprior55::W](W) writer structure
        impl crate::Writable for PFIC_IPRIOR55_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets PFIC_IPRIOR55 to value 0
        impl crate::Resettable for PFIC_IPRIOR55_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///PFIC_IPRIOR56 (rw) register accessor: an alias for `Reg<PFIC_IPRIOR56_SPEC>`
    pub type PFIC_IPRIOR56 = crate::Reg<pfic_iprior56::PFIC_IPRIOR56_SPEC>;
    ///Interrupt Priority configuration Register 56
    pub mod pfic_iprior56 {
        ///Register `PFIC_IPRIOR56` reader
        pub struct R(crate::R<PFIC_IPRIOR56_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PFIC_IPRIOR56_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<PFIC_IPRIOR56_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<PFIC_IPRIOR56_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `PFIC_IPRIOR56` writer
        pub struct W(crate::W<PFIC_IPRIOR56_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PFIC_IPRIOR56_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<PFIC_IPRIOR56_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<PFIC_IPRIOR56_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR56` reader - RW,Interrupt priority for number 224-227
        pub type IPRIOR56_R = crate::FieldReader<u32, u32>;
        ///Field `IPRIOR56` writer - RW,Interrupt priority for number 224-227
        pub type IPRIOR56_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, PFIC_IPRIOR56_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 224-227
            #[inline(always)]
            pub fn iprior56(&self) -> IPRIOR56_R {
                IPRIOR56_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 224-227
            #[inline(always)]
            #[must_use]
            pub fn iprior56(&mut self) -> IPRIOR56_W<0> {
                IPRIOR56_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 56
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [pfic_iprior56](index.html) module
        pub struct PFIC_IPRIOR56_SPEC;
        impl crate::RegisterSpec for PFIC_IPRIOR56_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [pfic_iprior56::R](R) reader structure
        impl crate::Readable for PFIC_IPRIOR56_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [pfic_iprior56::W](W) writer structure
        impl crate::Writable for PFIC_IPRIOR56_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets PFIC_IPRIOR56 to value 0
        impl crate::Resettable for PFIC_IPRIOR56_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///PFIC_IPRIOR57 (rw) register accessor: an alias for `Reg<PFIC_IPRIOR57_SPEC>`
    pub type PFIC_IPRIOR57 = crate::Reg<pfic_iprior57::PFIC_IPRIOR57_SPEC>;
    ///Interrupt Priority configuration Register 57
    pub mod pfic_iprior57 {
        ///Register `PFIC_IPRIOR57` reader
        pub struct R(crate::R<PFIC_IPRIOR57_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PFIC_IPRIOR57_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<PFIC_IPRIOR57_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<PFIC_IPRIOR57_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `PFIC_IPRIOR57` writer
        pub struct W(crate::W<PFIC_IPRIOR57_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PFIC_IPRIOR57_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<PFIC_IPRIOR57_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<PFIC_IPRIOR57_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR57` reader - RW,Interrupt priority for number 228-231
        pub type IPRIOR57_R = crate::FieldReader<u32, u32>;
        ///Field `IPRIOR57` writer - RW,Interrupt priority for number 228-231
        pub type IPRIOR57_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, PFIC_IPRIOR57_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 228-231
            #[inline(always)]
            pub fn iprior57(&self) -> IPRIOR57_R {
                IPRIOR57_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 228-231
            #[inline(always)]
            #[must_use]
            pub fn iprior57(&mut self) -> IPRIOR57_W<0> {
                IPRIOR57_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 57
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [pfic_iprior57](index.html) module
        pub struct PFIC_IPRIOR57_SPEC;
        impl crate::RegisterSpec for PFIC_IPRIOR57_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [pfic_iprior57::R](R) reader structure
        impl crate::Readable for PFIC_IPRIOR57_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [pfic_iprior57::W](W) writer structure
        impl crate::Writable for PFIC_IPRIOR57_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets PFIC_IPRIOR57 to value 0
        impl crate::Resettable for PFIC_IPRIOR57_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///PFIC_IPRIOR58 (rw) register accessor: an alias for `Reg<PFIC_IPRIOR58_SPEC>`
    pub type PFIC_IPRIOR58 = crate::Reg<pfic_iprior58::PFIC_IPRIOR58_SPEC>;
    ///Interrupt Priority configuration Register 58
    pub mod pfic_iprior58 {
        ///Register `PFIC_IPRIOR58` reader
        pub struct R(crate::R<PFIC_IPRIOR58_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PFIC_IPRIOR58_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<PFIC_IPRIOR58_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<PFIC_IPRIOR58_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `PFIC_IPRIOR58` writer
        pub struct W(crate::W<PFIC_IPRIOR58_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PFIC_IPRIOR58_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<PFIC_IPRIOR58_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<PFIC_IPRIOR58_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR58` reader - RW,Interrupt priority for number 232-235
        pub type IPRIOR58_R = crate::FieldReader<u32, u32>;
        ///Field `IPRIOR58` writer - RW,Interrupt priority for number 232-235
        pub type IPRIOR58_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, PFIC_IPRIOR58_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 232-235
            #[inline(always)]
            pub fn iprior58(&self) -> IPRIOR58_R {
                IPRIOR58_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 232-235
            #[inline(always)]
            #[must_use]
            pub fn iprior58(&mut self) -> IPRIOR58_W<0> {
                IPRIOR58_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 58
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [pfic_iprior58](index.html) module
        pub struct PFIC_IPRIOR58_SPEC;
        impl crate::RegisterSpec for PFIC_IPRIOR58_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [pfic_iprior58::R](R) reader structure
        impl crate::Readable for PFIC_IPRIOR58_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [pfic_iprior58::W](W) writer structure
        impl crate::Writable for PFIC_IPRIOR58_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets PFIC_IPRIOR58 to value 0
        impl crate::Resettable for PFIC_IPRIOR58_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///PFIC_IPRIOR59 (rw) register accessor: an alias for `Reg<PFIC_IPRIOR59_SPEC>`
    pub type PFIC_IPRIOR59 = crate::Reg<pfic_iprior59::PFIC_IPRIOR59_SPEC>;
    ///Interrupt Priority configuration Register 59
    pub mod pfic_iprior59 {
        ///Register `PFIC_IPRIOR59` reader
        pub struct R(crate::R<PFIC_IPRIOR59_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PFIC_IPRIOR59_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<PFIC_IPRIOR59_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<PFIC_IPRIOR59_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `PFIC_IPRIOR59` writer
        pub struct W(crate::W<PFIC_IPRIOR59_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PFIC_IPRIOR59_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<PFIC_IPRIOR59_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<PFIC_IPRIOR59_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR59` reader - RW,Interrupt priority for number 236-239
        pub type IPRIOR59_R = crate::FieldReader<u32, u32>;
        ///Field `IPRIOR59` writer - RW,Interrupt priority for number 236-239
        pub type IPRIOR59_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, PFIC_IPRIOR59_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 236-239
            #[inline(always)]
            pub fn iprior59(&self) -> IPRIOR59_R {
                IPRIOR59_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 236-239
            #[inline(always)]
            #[must_use]
            pub fn iprior59(&mut self) -> IPRIOR59_W<0> {
                IPRIOR59_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 59
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [pfic_iprior59](index.html) module
        pub struct PFIC_IPRIOR59_SPEC;
        impl crate::RegisterSpec for PFIC_IPRIOR59_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [pfic_iprior59::R](R) reader structure
        impl crate::Readable for PFIC_IPRIOR59_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [pfic_iprior59::W](W) writer structure
        impl crate::Writable for PFIC_IPRIOR59_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets PFIC_IPRIOR59 to value 0
        impl crate::Resettable for PFIC_IPRIOR59_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///PFIC_IPRIOR60 (rw) register accessor: an alias for `Reg<PFIC_IPRIOR60_SPEC>`
    pub type PFIC_IPRIOR60 = crate::Reg<pfic_iprior60::PFIC_IPRIOR60_SPEC>;
    ///Interrupt Priority configuration Register 60
    pub mod pfic_iprior60 {
        ///Register `PFIC_IPRIOR60` reader
        pub struct R(crate::R<PFIC_IPRIOR60_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PFIC_IPRIOR60_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<PFIC_IPRIOR60_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<PFIC_IPRIOR60_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `PFIC_IPRIOR60` writer
        pub struct W(crate::W<PFIC_IPRIOR60_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PFIC_IPRIOR60_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<PFIC_IPRIOR60_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<PFIC_IPRIOR60_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR60` reader - RW,Interrupt priority for number 240-243
        pub type IPRIOR60_R = crate::FieldReader<u32, u32>;
        ///Field `IPRIOR60` writer - RW,Interrupt priority for number 240-243
        pub type IPRIOR60_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, PFIC_IPRIOR60_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 240-243
            #[inline(always)]
            pub fn iprior60(&self) -> IPRIOR60_R {
                IPRIOR60_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 240-243
            #[inline(always)]
            #[must_use]
            pub fn iprior60(&mut self) -> IPRIOR60_W<0> {
                IPRIOR60_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 60
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [pfic_iprior60](index.html) module
        pub struct PFIC_IPRIOR60_SPEC;
        impl crate::RegisterSpec for PFIC_IPRIOR60_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [pfic_iprior60::R](R) reader structure
        impl crate::Readable for PFIC_IPRIOR60_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [pfic_iprior60::W](W) writer structure
        impl crate::Writable for PFIC_IPRIOR60_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets PFIC_IPRIOR60 to value 0
        impl crate::Resettable for PFIC_IPRIOR60_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///PFIC_IPRIOR61 (rw) register accessor: an alias for `Reg<PFIC_IPRIOR61_SPEC>`
    pub type PFIC_IPRIOR61 = crate::Reg<pfic_iprior61::PFIC_IPRIOR61_SPEC>;
    ///Interrupt Priority configuration Register 61
    pub mod pfic_iprior61 {
        ///Register `PFIC_IPRIOR61` reader
        pub struct R(crate::R<PFIC_IPRIOR61_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PFIC_IPRIOR61_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<PFIC_IPRIOR61_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<PFIC_IPRIOR61_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `PFIC_IPRIOR61` writer
        pub struct W(crate::W<PFIC_IPRIOR61_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PFIC_IPRIOR61_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<PFIC_IPRIOR61_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<PFIC_IPRIOR61_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR61` reader - RW,Interrupt priority for number 244-247
        pub type IPRIOR61_R = crate::FieldReader<u32, u32>;
        ///Field `IPRIOR61` writer - RW,Interrupt priority for number 244-247
        pub type IPRIOR61_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, PFIC_IPRIOR61_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 244-247
            #[inline(always)]
            pub fn iprior61(&self) -> IPRIOR61_R {
                IPRIOR61_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 244-247
            #[inline(always)]
            #[must_use]
            pub fn iprior61(&mut self) -> IPRIOR61_W<0> {
                IPRIOR61_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 61
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [pfic_iprior61](index.html) module
        pub struct PFIC_IPRIOR61_SPEC;
        impl crate::RegisterSpec for PFIC_IPRIOR61_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [pfic_iprior61::R](R) reader structure
        impl crate::Readable for PFIC_IPRIOR61_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [pfic_iprior61::W](W) writer structure
        impl crate::Writable for PFIC_IPRIOR61_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets PFIC_IPRIOR61 to value 0
        impl crate::Resettable for PFIC_IPRIOR61_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///PFIC_IPRIOR62 (rw) register accessor: an alias for `Reg<PFIC_IPRIOR62_SPEC>`
    pub type PFIC_IPRIOR62 = crate::Reg<pfic_iprior62::PFIC_IPRIOR62_SPEC>;
    ///Interrupt Priority configuration Register 62
    pub mod pfic_iprior62 {
        ///Register `PFIC_IPRIOR62` reader
        pub struct R(crate::R<PFIC_IPRIOR62_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PFIC_IPRIOR62_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<PFIC_IPRIOR62_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<PFIC_IPRIOR62_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `PFIC_IPRIOR62` writer
        pub struct W(crate::W<PFIC_IPRIOR62_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PFIC_IPRIOR62_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<PFIC_IPRIOR62_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<PFIC_IPRIOR62_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR62` reader - RW,Interrupt priority for number 248-251
        pub type IPRIOR62_R = crate::FieldReader<u32, u32>;
        ///Field `IPRIOR62` writer - RW,Interrupt priority for number 248-251
        pub type IPRIOR62_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, PFIC_IPRIOR62_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 248-251
            #[inline(always)]
            pub fn iprior62(&self) -> IPRIOR62_R {
                IPRIOR62_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 248-251
            #[inline(always)]
            #[must_use]
            pub fn iprior62(&mut self) -> IPRIOR62_W<0> {
                IPRIOR62_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 62
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [pfic_iprior62](index.html) module
        pub struct PFIC_IPRIOR62_SPEC;
        impl crate::RegisterSpec for PFIC_IPRIOR62_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [pfic_iprior62::R](R) reader structure
        impl crate::Readable for PFIC_IPRIOR62_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [pfic_iprior62::W](W) writer structure
        impl crate::Writable for PFIC_IPRIOR62_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets PFIC_IPRIOR62 to value 0
        impl crate::Resettable for PFIC_IPRIOR62_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///PFIC_IPRIOR63 (rw) register accessor: an alias for `Reg<PFIC_IPRIOR63_SPEC>`
    pub type PFIC_IPRIOR63 = crate::Reg<pfic_iprior63::PFIC_IPRIOR63_SPEC>;
    ///Interrupt Priority configuration Register 63
    pub mod pfic_iprior63 {
        ///Register `PFIC_IPRIOR63` reader
        pub struct R(crate::R<PFIC_IPRIOR63_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PFIC_IPRIOR63_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<PFIC_IPRIOR63_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<PFIC_IPRIOR63_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `PFIC_IPRIOR63` writer
        pub struct W(crate::W<PFIC_IPRIOR63_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PFIC_IPRIOR63_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<PFIC_IPRIOR63_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<PFIC_IPRIOR63_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IPRIOR63` reader - RW,Interrupt priority for number 252-255
        pub type IPRIOR63_R = crate::FieldReader<u32, u32>;
        ///Field `IPRIOR63` writer - RW,Interrupt priority for number 252-255
        pub type IPRIOR63_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, PFIC_IPRIOR63_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - RW,Interrupt priority for number 252-255
            #[inline(always)]
            pub fn iprior63(&self) -> IPRIOR63_R {
                IPRIOR63_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,Interrupt priority for number 252-255
            #[inline(always)]
            #[must_use]
            pub fn iprior63(&mut self) -> IPRIOR63_W<0> {
                IPRIOR63_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority configuration Register 63
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [pfic_iprior63](index.html) module
        pub struct PFIC_IPRIOR63_SPEC;
        impl crate::RegisterSpec for PFIC_IPRIOR63_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [pfic_iprior63::R](R) reader structure
        impl crate::Readable for PFIC_IPRIOR63_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [pfic_iprior63::W](W) writer structure
        impl crate::Writable for PFIC_IPRIOR63_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets PFIC_IPRIOR63 to value 0
        impl crate::Resettable for PFIC_IPRIOR63_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///PFIC_SCTLR (rw) register accessor: an alias for `Reg<PFIC_SCTLR_SPEC>`
    pub type PFIC_SCTLR = crate::Reg<pfic_sctlr::PFIC_SCTLR_SPEC>;
    ///System Control Register
    pub mod pfic_sctlr {
        ///Register `PFIC_SCTLR` reader
        pub struct R(crate::R<PFIC_SCTLR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PFIC_SCTLR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<PFIC_SCTLR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<PFIC_SCTLR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `PFIC_SCTLR` writer
        pub struct W(crate::W<PFIC_SCTLR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PFIC_SCTLR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<PFIC_SCTLR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<PFIC_SCTLR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `SLEEPONEXIT` reader - RW,SLEEPONEXIT
        pub type SLEEPONEXIT_R = crate::BitReader<bool>;
        ///Field `SLEEPONEXIT` writer - RW,SLEEPONEXIT
        pub type SLEEPONEXIT_W<'a, const O: u8> =
            crate::BitWriter<'a, u32, PFIC_SCTLR_SPEC, bool, O>;
        ///Field `SLEEPDEEP` reader - RW,SLEEPDEEP
        pub type SLEEPDEEP_R = crate::BitReader<bool>;
        ///Field `SLEEPDEEP` writer - RW,SLEEPDEEP
        pub type SLEEPDEEP_W<'a, const O: u8> = crate::BitWriter<'a, u32, PFIC_SCTLR_SPEC, bool, O>;
        ///Field `WFITOWFE` reader - RW,WFITOWFE
        pub type WFITOWFE_R = crate::BitReader<bool>;
        ///Field `WFITOWFE` writer - RW,WFITOWFE
        pub type WFITOWFE_W<'a, const O: u8> = crate::BitWriter<'a, u32, PFIC_SCTLR_SPEC, bool, O>;
        ///Field `SEVONPEND` reader - RW,SEVONPEND
        pub type SEVONPEND_R = crate::BitReader<bool>;
        ///Field `SEVONPEND` writer - RW,SEVONPEND
        pub type SEVONPEND_W<'a, const O: u8> = crate::BitWriter<'a, u32, PFIC_SCTLR_SPEC, bool, O>;
        ///Field `SETEVENT` reader - WO,SETEVENT
        pub type SETEVENT_R = crate::BitReader<bool>;
        ///Field `SETEVENT` writer - WO,SETEVENT
        pub type SETEVENT_W<'a, const O: u8> = crate::BitWriter<'a, u32, PFIC_SCTLR_SPEC, bool, O>;
        impl R {
            ///Bit 1 - RW,SLEEPONEXIT
            #[inline(always)]
            pub fn sleeponexit(&self) -> SLEEPONEXIT_R {
                SLEEPONEXIT_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RW,SLEEPDEEP
            #[inline(always)]
            pub fn sleepdeep(&self) -> SLEEPDEEP_R {
                SLEEPDEEP_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RW,WFITOWFE
            #[inline(always)]
            pub fn wfitowfe(&self) -> WFITOWFE_R {
                WFITOWFE_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RW,SEVONPEND
            #[inline(always)]
            pub fn sevonpend(&self) -> SEVONPEND_R {
                SEVONPEND_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - WO,SETEVENT
            #[inline(always)]
            pub fn setevent(&self) -> SETEVENT_R {
                SETEVENT_R::new(((self.bits >> 5) & 1) != 0)
            }
        }
        impl W {
            ///Bit 1 - RW,SLEEPONEXIT
            #[inline(always)]
            #[must_use]
            pub fn sleeponexit(&mut self) -> SLEEPONEXIT_W<1> {
                SLEEPONEXIT_W::new(self)
            }
            ///Bit 2 - RW,SLEEPDEEP
            #[inline(always)]
            #[must_use]
            pub fn sleepdeep(&mut self) -> SLEEPDEEP_W<2> {
                SLEEPDEEP_W::new(self)
            }
            ///Bit 3 - RW,WFITOWFE
            #[inline(always)]
            #[must_use]
            pub fn wfitowfe(&mut self) -> WFITOWFE_W<3> {
                WFITOWFE_W::new(self)
            }
            ///Bit 4 - RW,SEVONPEND
            #[inline(always)]
            #[must_use]
            pub fn sevonpend(&mut self) -> SEVONPEND_W<4> {
                SEVONPEND_W::new(self)
            }
            ///Bit 5 - WO,SETEVENT
            #[inline(always)]
            #[must_use]
            pub fn setevent(&mut self) -> SETEVENT_W<5> {
                SETEVENT_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///System Control Register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [pfic_sctlr](index.html) module
        pub struct PFIC_SCTLR_SPEC;
        impl crate::RegisterSpec for PFIC_SCTLR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [pfic_sctlr::R](R) reader structure
        impl crate::Readable for PFIC_SCTLR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [pfic_sctlr::W](W) writer structure
        impl crate::Writable for PFIC_SCTLR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets PFIC_SCTLR to value 0
        impl crate::Resettable for PFIC_SCTLR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
}
///Systick register
pub struct SYSTICK {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for SYSTICK {}
impl SYSTICK {
    ///Pointer to the register block
    pub const PTR: *const systick::RegisterBlock = 0xe000_f000 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const systick::RegisterBlock {
        Self::PTR
    }
}
impl Deref for SYSTICK {
    type Target = systick::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for SYSTICK {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("SYSTICK").finish()
    }
}
///Systick register
pub mod systick {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        ///0x00 - Systick counter control register
        pub stk_ctlr: STK_CTLR,
        ///0x04 - Systick count status register
        pub stk_sr: STK_SR,
        ///0x08 - Systick counter low register
        pub stk_cntl: STK_CNTL,
        ///0x0c - Systick counter high register
        pub stk_cnth: STK_CNTH,
        ///0x10 - Systick compare low register
        pub stk_cmplr: STK_CMPLR,
        ///0x14 - Systick compare high register
        pub stk_cmphr: STK_CMPHR,
    }
    ///STK_CTLR (rw) register accessor: an alias for `Reg<STK_CTLR_SPEC>`
    pub type STK_CTLR = crate::Reg<stk_ctlr::STK_CTLR_SPEC>;
    ///Systick counter control register
    pub mod stk_ctlr {
        ///Register `STK_CTLR` reader
        pub struct R(crate::R<STK_CTLR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<STK_CTLR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<STK_CTLR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<STK_CTLR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `STK_CTLR` writer
        pub struct W(crate::W<STK_CTLR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<STK_CTLR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<STK_CTLR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<STK_CTLR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `STE` reader - Systick counter enable
        pub type STE_R = crate::BitReader<bool>;
        ///Field `STE` writer - Systick counter enable
        pub type STE_W<'a, const O: u8> = crate::BitWriter<'a, u32, STK_CTLR_SPEC, bool, O>;
        ///Field `STIE` reader - Systick counter interrupt enable
        pub type STIE_R = crate::BitReader<bool>;
        ///Field `STIE` writer - Systick counter interrupt enable
        pub type STIE_W<'a, const O: u8> = crate::BitWriter<'a, u32, STK_CTLR_SPEC, bool, O>;
        ///Field `STCLK` reader - System counter clock Source selection
        pub type STCLK_R = crate::BitReader<bool>;
        ///Field `STCLK` writer - System counter clock Source selection
        pub type STCLK_W<'a, const O: u8> = crate::BitWriter<'a, u32, STK_CTLR_SPEC, bool, O>;
        ///Field `STRE` reader - System counter reload control
        pub type STRE_R = crate::BitReader<bool>;
        ///Field `STRE` writer - System counter reload control
        pub type STRE_W<'a, const O: u8> = crate::BitWriter<'a, u32, STK_CTLR_SPEC, bool, O>;
        ///Field `MODE` reader - counter mode
        pub type MODE_R = crate::BitReader<bool>;
        ///Field `MODE` writer - counter mode
        pub type MODE_W<'a, const O: u8> = crate::BitWriter<'a, u32, STK_CTLR_SPEC, bool, O>;
        ///Field `INIT` reader - Initial counter value updated
        pub type INIT_R = crate::BitReader<bool>;
        ///Field `INIT` writer - Initial counter value updated
        pub type INIT_W<'a, const O: u8> = crate::BitWriter<'a, u32, STK_CTLR_SPEC, bool, O>;
        ///Field `SWIE` reader - RW0,System soft interrupt enable
        pub type SWIE_R = crate::BitReader<bool>;
        ///Field `SWIE` writer - RW0,System soft interrupt enable
        pub type SWIE_W<'a, const O: u8> = crate::BitWriter<'a, u32, STK_CTLR_SPEC, bool, O>;
        impl R {
            ///Bit 0 - Systick counter enable
            #[inline(always)]
            pub fn ste(&self) -> STE_R {
                STE_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Systick counter interrupt enable
            #[inline(always)]
            pub fn stie(&self) -> STIE_R {
                STIE_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - System counter clock Source selection
            #[inline(always)]
            pub fn stclk(&self) -> STCLK_R {
                STCLK_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - System counter reload control
            #[inline(always)]
            pub fn stre(&self) -> STRE_R {
                STRE_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - counter mode
            #[inline(always)]
            pub fn mode(&self) -> MODE_R {
                MODE_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - Initial counter value updated
            #[inline(always)]
            pub fn init(&self) -> INIT_R {
                INIT_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 31 - RW0,System soft interrupt enable
            #[inline(always)]
            pub fn swie(&self) -> SWIE_R {
                SWIE_R::new(((self.bits >> 31) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - Systick counter enable
            #[inline(always)]
            #[must_use]
            pub fn ste(&mut self) -> STE_W<0> {
                STE_W::new(self)
            }
            ///Bit 1 - Systick counter interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn stie(&mut self) -> STIE_W<1> {
                STIE_W::new(self)
            }
            ///Bit 2 - System counter clock Source selection
            #[inline(always)]
            #[must_use]
            pub fn stclk(&mut self) -> STCLK_W<2> {
                STCLK_W::new(self)
            }
            ///Bit 3 - System counter reload control
            #[inline(always)]
            #[must_use]
            pub fn stre(&mut self) -> STRE_W<3> {
                STRE_W::new(self)
            }
            ///Bit 4 - counter mode
            #[inline(always)]
            #[must_use]
            pub fn mode(&mut self) -> MODE_W<4> {
                MODE_W::new(self)
            }
            ///Bit 5 - Initial counter value updated
            #[inline(always)]
            #[must_use]
            pub fn init(&mut self) -> INIT_W<5> {
                INIT_W::new(self)
            }
            ///Bit 31 - RW0,System soft interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn swie(&mut self) -> SWIE_W<31> {
                SWIE_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Systick counter control register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [stk_ctlr](index.html) module
        pub struct STK_CTLR_SPEC;
        impl crate::RegisterSpec for STK_CTLR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [stk_ctlr::R](R) reader structure
        impl crate::Readable for STK_CTLR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [stk_ctlr::W](W) writer structure
        impl crate::Writable for STK_CTLR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets STK_CTLR to value 0
        impl crate::Resettable for STK_CTLR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///STK_SR (rw) register accessor: an alias for `Reg<STK_SR_SPEC>`
    pub type STK_SR = crate::Reg<stk_sr::STK_SR_SPEC>;
    ///Systick count status register
    pub mod stk_sr {
        ///Register `STK_SR` reader
        pub struct R(crate::R<STK_SR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<STK_SR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<STK_SR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<STK_SR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `STK_SR` writer
        pub struct W(crate::W<STK_SR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<STK_SR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<STK_SR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<STK_SR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `CNTIF` reader - RW,CNTIF
        pub type CNTIF_R = crate::BitReader<bool>;
        ///Field `CNTIF` writer - RW,CNTIF
        pub type CNTIF_W<'a, const O: u8> = crate::BitWriter<'a, u32, STK_SR_SPEC, bool, O>;
        impl R {
            ///Bit 0 - RW,CNTIF
            #[inline(always)]
            pub fn cntif(&self) -> CNTIF_R {
                CNTIF_R::new((self.bits & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - RW,CNTIF
            #[inline(always)]
            #[must_use]
            pub fn cntif(&mut self) -> CNTIF_W<0> {
                CNTIF_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Systick count status register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [stk_sr](index.html) module
        pub struct STK_SR_SPEC;
        impl crate::RegisterSpec for STK_SR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [stk_sr::R](R) reader structure
        impl crate::Readable for STK_SR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [stk_sr::W](W) writer structure
        impl crate::Writable for STK_SR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets STK_SR to value 0
        impl crate::Resettable for STK_SR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///STK_CNTL (rw) register accessor: an alias for `Reg<STK_CNTL_SPEC>`
    pub type STK_CNTL = crate::Reg<stk_cntl::STK_CNTL_SPEC>;
    ///Systick counter low register
    pub mod stk_cntl {
        ///Register `STK_CNTL` reader
        pub struct R(crate::R<STK_CNTL_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<STK_CNTL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<STK_CNTL_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<STK_CNTL_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `STK_CNTL` writer
        pub struct W(crate::W<STK_CNTL_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<STK_CNTL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<STK_CNTL_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<STK_CNTL_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `CNTL` reader - RW,CNTL
        pub type CNTL_R = crate::FieldReader<u32, u32>;
        ///Field `CNTL` writer - RW,CNTL
        pub type CNTL_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, STK_CNTL_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - RW,CNTL
            #[inline(always)]
            pub fn cntl(&self) -> CNTL_R {
                CNTL_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,CNTL
            #[inline(always)]
            #[must_use]
            pub fn cntl(&mut self) -> CNTL_W<0> {
                CNTL_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Systick counter low register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [stk_cntl](index.html) module
        pub struct STK_CNTL_SPEC;
        impl crate::RegisterSpec for STK_CNTL_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [stk_cntl::R](R) reader structure
        impl crate::Readable for STK_CNTL_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [stk_cntl::W](W) writer structure
        impl crate::Writable for STK_CNTL_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets STK_CNTL to value 0
        impl crate::Resettable for STK_CNTL_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///STK_CNTH (rw) register accessor: an alias for `Reg<STK_CNTH_SPEC>`
    pub type STK_CNTH = crate::Reg<stk_cnth::STK_CNTH_SPEC>;
    ///Systick counter high register
    pub mod stk_cnth {
        ///Register `STK_CNTH` reader
        pub struct R(crate::R<STK_CNTH_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<STK_CNTH_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<STK_CNTH_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<STK_CNTH_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `STK_CNTH` writer
        pub struct W(crate::W<STK_CNTH_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<STK_CNTH_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<STK_CNTH_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<STK_CNTH_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `CNTH` reader - RW,CNTH
        pub type CNTH_R = crate::FieldReader<u32, u32>;
        ///Field `CNTH` writer - RW,CNTH
        pub type CNTH_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, STK_CNTH_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - RW,CNTH
            #[inline(always)]
            pub fn cnth(&self) -> CNTH_R {
                CNTH_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,CNTH
            #[inline(always)]
            #[must_use]
            pub fn cnth(&mut self) -> CNTH_W<0> {
                CNTH_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Systick counter high register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [stk_cnth](index.html) module
        pub struct STK_CNTH_SPEC;
        impl crate::RegisterSpec for STK_CNTH_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [stk_cnth::R](R) reader structure
        impl crate::Readable for STK_CNTH_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [stk_cnth::W](W) writer structure
        impl crate::Writable for STK_CNTH_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets STK_CNTH to value 0
        impl crate::Resettable for STK_CNTH_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///STK_CMPLR (rw) register accessor: an alias for `Reg<STK_CMPLR_SPEC>`
    pub type STK_CMPLR = crate::Reg<stk_cmplr::STK_CMPLR_SPEC>;
    ///Systick compare low register
    pub mod stk_cmplr {
        ///Register `STK_CMPLR` reader
        pub struct R(crate::R<STK_CMPLR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<STK_CMPLR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<STK_CMPLR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<STK_CMPLR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `STK_CMPLR` writer
        pub struct W(crate::W<STK_CMPLR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<STK_CMPLR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<STK_CMPLR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<STK_CMPLR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `CMPL` reader - RW,CMPL
        pub type CMPL_R = crate::FieldReader<u32, u32>;
        ///Field `CMPL` writer - RW,CMPL
        pub type CMPL_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, STK_CMPLR_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - RW,CMPL
            #[inline(always)]
            pub fn cmpl(&self) -> CMPL_R {
                CMPL_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,CMPL
            #[inline(always)]
            #[must_use]
            pub fn cmpl(&mut self) -> CMPL_W<0> {
                CMPL_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Systick compare low register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [stk_cmplr](index.html) module
        pub struct STK_CMPLR_SPEC;
        impl crate::RegisterSpec for STK_CMPLR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [stk_cmplr::R](R) reader structure
        impl crate::Readable for STK_CMPLR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [stk_cmplr::W](W) writer structure
        impl crate::Writable for STK_CMPLR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets STK_CMPLR to value 0
        impl crate::Resettable for STK_CMPLR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///STK_CMPHR (rw) register accessor: an alias for `Reg<STK_CMPHR_SPEC>`
    pub type STK_CMPHR = crate::Reg<stk_cmphr::STK_CMPHR_SPEC>;
    ///Systick compare high register
    pub mod stk_cmphr {
        ///Register `STK_CMPHR` reader
        pub struct R(crate::R<STK_CMPHR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<STK_CMPHR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<STK_CMPHR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<STK_CMPHR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `STK_CMPHR` writer
        pub struct W(crate::W<STK_CMPHR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<STK_CMPHR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<STK_CMPHR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<STK_CMPHR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `CMPH` reader - RW,CMPH
        pub type CMPH_R = crate::FieldReader<u32, u32>;
        ///Field `CMPH` writer - RW,CMPH
        pub type CMPH_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, STK_CMPHR_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - RW,CMPH
            #[inline(always)]
            pub fn cmph(&self) -> CMPH_R {
                CMPH_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - RW,CMPH
            #[inline(always)]
            #[must_use]
            pub fn cmph(&mut self) -> CMPH_W<0> {
                CMPH_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Systick compare high register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [stk_cmphr](index.html) module
        pub struct STK_CMPHR_SPEC;
        impl crate::RegisterSpec for STK_CMPHR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [stk_cmphr::R](R) reader structure
        impl crate::Readable for STK_CMPHR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [stk_cmphr::W](W) writer structure
        impl crate::Writable for STK_CMPHR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets STK_CMPHR to value 0
        impl crate::Resettable for STK_CMPHR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
}
#[no_mangle]
static mut DEVICE_PERIPHERALS: bool = false;
/// All the peripherals.
#[allow(non_snake_case)]
pub struct Peripherals {
    ///SYS
    pub SYS: SYS,
    ///TMR0
    pub TMR0: TMR0,
    ///TMR1
    pub TMR1: TMR1,
    ///TMR2
    pub TMR2: TMR2,
    ///TMR3
    pub TMR3: TMR3,
    ///UART0
    pub UART0: UART0,
    ///UART1
    pub UART1: UART1,
    ///UART2
    pub UART2: UART2,
    ///UART3
    pub UART3: UART3,
    ///SPI0
    pub SPI0: SPI0,
    ///SPI1
    pub SPI1: SPI1,
    ///I2C
    pub I2C: I2C,
    ///PWMX
    pub PWMX: PWMX,
    ///USB
    pub USB: USB,
    ///USB2
    pub USB2: USB2,
    ///PFIC
    pub PFIC: PFIC,
    ///SYSTICK
    pub SYSTICK: SYSTICK,
}
impl Peripherals {
    /// Returns all the peripherals *once*.
    #[cfg(feature = "critical-section")]
    #[inline]
    pub fn take() -> Option<Self> {
        critical_section::with(|_| {
            if unsafe { DEVICE_PERIPHERALS } {
                return None;
            }
            Some(unsafe { Peripherals::steal() })
        })
    }
    /// Unchecked version of `Peripherals::take`.
    ///
    /// # Safety
    ///
    /// Each of the returned peripherals must be used at most once.
    #[inline]
    pub unsafe fn steal() -> Self {
        DEVICE_PERIPHERALS = true;
        Peripherals {
            SYS: SYS {
                _marker: PhantomData,
            },
            TMR0: TMR0 {
                _marker: PhantomData,
            },
            TMR1: TMR1 {
                _marker: PhantomData,
            },
            TMR2: TMR2 {
                _marker: PhantomData,
            },
            TMR3: TMR3 {
                _marker: PhantomData,
            },
            UART0: UART0 {
                _marker: PhantomData,
            },
            UART1: UART1 {
                _marker: PhantomData,
            },
            UART2: UART2 {
                _marker: PhantomData,
            },
            UART3: UART3 {
                _marker: PhantomData,
            },
            SPI0: SPI0 {
                _marker: PhantomData,
            },
            SPI1: SPI1 {
                _marker: PhantomData,
            },
            I2C: I2C {
                _marker: PhantomData,
            },
            PWMX: PWMX {
                _marker: PhantomData,
            },
            USB: USB {
                _marker: PhantomData,
            },
            USB2: USB2 {
                _marker: PhantomData,
            },
            PFIC: PFIC {
                _marker: PhantomData,
            },
            SYSTICK: SYSTICK {
                _marker: PhantomData,
            },
        }
    }
}
